omException = FALSE;
        MethodTable *pSystemExceptionMT = g_Mscorlib.GetClass(CLASS__EXCEPTION);
        MethodTable *pInnerMT = (*except)->GetMethodTable();
        while (pInnerMT != NULL) {
           if (pInnerMT == pSystemExceptionMT) {
              fDerivesFromException = TRUE;
              break;
           }
           pInnerMT = pInnerMT->GetParentMethodTable();
        }
    }


    // Create the target object...
    o = AllocateObject(_pVMTargetExcept);
    GCPROTECT_BEGIN(o);
    INT64 args[2];

    // Call the constructor
    args[0]  = ObjToInt64(o);
    if (fDerivesFromException) {
       args[1]  = ObjToInt64(*except);
    } else {
       args[1] = ObjToInt64(NULL);
    }

    CallConstructor(&gsig_IM_Exception_RetVoid, args);

    oRet = o;

    GCPROTECT_END();
    return oRet;
}

// GetAnyRef
EEClass* InvokeUtil::GetAnyRef()
{
    THROWSCOMPLUSEXCEPTION();

    // @perf: return MethodTable instead
    return g_Mscorlib.GetExistingClass(CLASS__TYPED_REFERENCE)->GetClass();
}

// GetGlobalMethodInfo
// Given a MethodDesc* and Module get the methodInfo associated with it.
OBJECTREF InvokeUtil::GetGlobalMethodInfo(MethodDesc* pMeth,Module* pMod)
{
    _ASSERTE(pMeth);
    _ASSERTE(pMod);

    REFLECTMODULEBASEREF refModule = (REFLECTMODULEBASEREF) pMod->GetExposedModuleObject();
    ReflectMethodList* pML = NULL;
    GCPROTECT_BEGIN(refModule);
    pML = (ReflectMethodList*) refModule->GetGlobals();
    if (pML == 0) {
        refModule->SetGlobals(ReflectModuleGlobals::GetGlobals(pMod));
        pML = (ReflectMethodList*) refModule->GetGlobals();
        _ASSERTE(pML);
    }
    GCPROTECT_END();
    for (DWORD i=0;i<pML->dwMethods;i++) {
        if (pML->methods[i].pMethod == pMeth) {
            ReflectClass* pRC = 0;
            if (pML->dwMethods > 0) {
                EEClass* pEEC = pML->methods[i].pMethod->GetClass();
                if (pEEC) {
                    REFLECTCLASSBASEREF o = (REFLECTCLASSBASEREF) pEEC->GetExposedClassObject();
                    pRC = (ReflectClass*) o->GetData();
                }       
            }
            return (OBJECTREF) pML->methods[i].GetMethodInfo(pRC);
        }
    }

    _ASSERTE(!"Module Method Not Found");
    return 0;
}

// GetMethodInfo
// Given a MethodDesc* get the methodInfo associated with it.
OBJECTREF InvokeUtil::GetMethodInfo(MethodDesc* pMeth)
{
    THROWSCOMPLUSEXCEPTION();

    EEClass* pEEC = pMeth->GetClass();
    ReflectMethodList* pRML = 0;
    ReflectClass* pRC = 0;
    bool method = true;

    REFLECTCLASSBASEREF o = (REFLECTCLASSBASEREF) pEEC->GetExposedClassObject();
    _ASSERTE(o != NULL);
    
    pRC = (ReflectClass*) o->GetData();
    _ASSERTE(pRC);

    // Check to see if this is a constructor.
    if (IsMdRTSpecialName(pMeth->GetAttrs())) {
        LPCUTF8 szName = pMeth->GetName();
        if (strcmp(COR_CTOR_METHOD_NAME,szName) == 0 ||
            strcmp(COR_CCTOR_METHOD_NAME,szName) == 0) {
            pRML = pRC->GetConstructors();
            method = false;
        }
    }

    // If we haven't found the method list then we load up the
    //  full method list.
    if (pRML == 0)
        pRML = pRC->GetMethods();

    ReflectMethod* pRM = pRML->FindMethod(pMeth);
    // @TODO: This seems like a bug.
    if (pRM == 0)
        return 0;
    _ASSERTE(pRM);

    return (method) ? (OBJECTREF) pRM->GetMethodInfo(pRC) : (OBJECTREF) pRM->GetConstructorInfo(pRC);
}

// ChangeType
// This method will invoke the Binder change type method on the object
//  binder -- The Binder object
//  srcObj -- The source object to be changed
//  th -- The TypeHandel of the target type
//  locale -- The locale passed to the class.
OBJECTREF InvokeUtil::ChangeType(OBJECTREF binder,OBJECTREF srcObj,TypeHandle th,OBJECTREF locale)
{
    OBJECTREF typeClass = NULL;
    OBJECTREF o;


    GCPROTECT_BEGIN(locale);
    GCPROTECT_BEGIN(typeClass);
    GCPROTECT_BEGIN(srcObj);
    GCPROTECT_BEGIN(binder);

    _ASSERTE(binder != 0);
    _ASSERTE(srcObj != 0);

    MethodDesc* pCTMeth = g_Mscorlib.GetMethod(METHOD__BINDER__CHANGE_TYPE);

    // Now call this method on this object.
    MetaSig sigCT(pCTMeth->GetSig(),pCTMeth->GetModule());
    BYTE* pNewArgs = 0;
    UINT nStackBytes = sigCT.SizeOfVirtualFixedArgStack(0);
    pNewArgs = (BYTE *) _alloca(nStackBytes);
    BYTE *  pDst= pNewArgs;
    
    UINT cbSize;

    typeClass = th.CreateClassObj();

    // This pointer....NO GC AFTER THIS POINT!!!!
    *(OBJECTREF*) pDst = binder;
    pDst += nStackBytes;

    // Value
    cbSize = StackElemSize(4);
    pDst -= cbSize;
    *(OBJECTREF*) pDst = srcObj;

    // Type
    cbSize = StackElemSize(4);
    pDst -= cbSize;
    *(OBJECTREF*) pDst = typeClass;

    // Locale
    cbSize = StackElemSize(4);
    pDst -= cbSize;
    *(OBJECTREF*) pDst = locale;

    INT64 ret = pCTMeth->Call(pNewArgs,&sigCT); 
    o = Int64ToObj(ret);
    GCPROTECT_END();   // binder
    GCPROTECT_END();    // srcObj
    GCPROTECT_END();    // typeClass
    GCPROTECT_END();    // local


    return o;
}

EEClass* InvokeUtil::GetEEClass(TypeHandle th)
{
    if (th.IsUnsharedMT())
        return th.AsClass();

    TypeDesc* typeDesc = th.AsTypeDesc();
    if (typeDesc->IsByRef() || typeDesc->GetNormCorElementType()==ELEMENT_TYPE_PTR)     //  byrefs cact just like the type they modify
        return GetEEClass(th.AsTypeDesc()->GetTypeParam());

    // TODO Aafreen should be able to get rid of this special case
    if (typeDesc->GetNormCorElementType() == ELEMENT_TYPE_TYPEDBYREF)
        return GetAnyRef();

    return(typeDesc->GetMethodTable()->GetClass());
};

// ValidateObjectTarget
// This method will validate the Object/Target relationship
//  is correct.  It throws an exception if this is not the case.
void InvokeUtil::ValidateObjectTarget(FieldDesc* pField, EEClass* fldEEC, OBJECTREF *target)
{

    THROWSCOMPLUSEXCEPTION();

    // Verify the static/object relationship
    if (!*target) {
        if (!pField->IsStatic()) {
            COMPlusThrow(kTargetException,L"RFLCT.Targ_StatFldReqTarg");
        }
        return;
    }

    if (!pField->IsStatic()) {
        // Verify that the object is of the proper type...
        EEClass* pEEC = (*target)->GetClass();
        if (pEEC->IsThunking()) {
            pEEC = pEEC->AdjustForThunking(*target);
        }
        while (pEEC && pEEC != fldEEC)
            pEEC = pEEC->GetParentClass();

        // Give a second chance to thunking classes to do the 
        // correct cast
        if (!pEEC) {

            BOOL fCastOK = FALSE;
            if ((*target)->GetClass()->IsThunking()) {
                fCastOK = CRemotingServices::CheckCast(*target, fldEEC);
            }
            if(!fCastOK) {
                COMPlusThrow(kArgumentException,L"Arg_ObjObj");
            }
        }
    }
}

// GetFieldTypeHandle
// This will return type type handle and CorElementType for a field.
//  It may throw an exception of the TypeHandle cannot be found due to a TypeLoadException.
TypeHandle InvokeUtil::GetFieldTypeHandle(FieldDesc* pField,CorElementType* pType)
{
    THROWSCOMPLUSEXCEPTION();

    // Verify that the value passed can be widened into the target
    PCCOR_SIGNATURE pSig;
    DWORD           cSig;
    TypeHandle      th;

    pField->GetSig(&pSig, &cSig);
    FieldSig sig(pSig, pField->GetModule());
    *pType = sig.GetFieldType();

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
    th = sig.GetTypeHandle(&throwable);
    if (throwable != NULL)
        COMPlusThrow(throwable);
    GCPROTECT_END();
    return th;
}


// SetValidField
// Given an target object, a value object and a field this method will set the field
//  on the target object.  The field must be validate before calling this.
void InvokeUtil::SetValidField(CorElementType fldType,TypeHandle fldTH,FieldDesc* pField,OBJECTREF* target,OBJECTREF* valueObj)
{
    THROWSCOMPLUSEXCEPTION();

    // call the <cinit> 
    OBJECTREF Throwable;
    if (!pField->GetMethodTableOfEnclosingClass()->CheckRunClassInit(&Throwable)) {
        GCPROTECT_BEGIN(Throwable);
        OBJECTREF except = CreateTargetExcept(&Throwable);
        COMPlusThrow(except);
        GCPROTECT_END();
    }

    // Set the field
    INT64 value;
    switch (fldType) {
    case ELEMENT_TYPE_VOID:
        _ASSERTE(!"Void used as Field Type!");
        COMPlusThrow(kNotSupportedException);

    case ELEMENT_TYPE_BOOLEAN:  // boolean
    case ELEMENT_TYPE_I1:       // byte
    case ELEMENT_TYPE_U1:       // unsigned byte
        value = 0;
        if (*valueObj != 0) {
            MethodTable* p = (*valueObj)->GetMethodTable();
            CorElementType oType = p->GetNormCorElementType();
            CreatePrimitiveValue(fldType,oType,*valueObj,&value);
        }

        if (pField->IsStatic())
            pField->SetStaticValue8((unsigned char) value);
        else {
            pField->SetValue8(*target,(unsigned char) value);
        }
        break;

    case ELEMENT_TYPE_I2:       // short
    case ELEMENT_TYPE_U2:       // unsigned short
    case ELEMENT_TYPE_CHAR:     // char
        value = 0;
        if (*valueObj != 0) {
            MethodTable* p = (*valueObj)->GetMethodTable();
            CorElementType oType = p->GetNormCorElementType();
            CreatePrimitiveValue(fldType,oType,*valueObj,&value);
        }

        if (pField->IsStatic())
            pField->SetStaticValue16((short) value);
        else {
            pField->SetValue16(*target,(short) value);
        }
        break;

    case ELEMENT_TYPE_I:
        value = (INT64)GetIntPtrValue(valueObj);
        if (pField->IsStatic()) 
            pField->SetStaticValuePtr((void*) value);
         else {
            pField->SetValuePtr(*target,(void*) value);
        }
        break;
    case ELEMENT_TYPE_U:
        value = (INT64)GetUIntPtrValue(valueObj);
        if (pField->IsStatic()) 
            pField->SetStaticValuePtr((void*) value);
         else {
            pField->SetValuePtr(*target,(void*) value);
        }
        break;
    case ELEMENT_TYPE_PTR:      // pointers
        if ((*valueObj)->GetTypeHandle() == _ptr) {
            value = (size_t)GetPointerValue(valueObj);
            if (pField->IsStatic()) 
                pField->SetStaticValuePtr((void*) value);
            else {
                pField->SetValuePtr(*target,(void*) value);
            }
            break;
        }
        // drop through
    case ELEMENT_TYPE_FNPTR:
        {
            value = (size_t)GetIntPtrValue(valueObj);
            if (pField->IsStatic()) 
                pField->SetStaticValuePtr((void*) value);
            else {
                pField->SetValuePtr(*target,(void*) value);
            }
            break;
        }
        break;


    case ELEMENT_TYPE_I4:       // int
    case ELEMENT_TYPE_U4:       // unsigned int
    case ELEMENT_TYPE_R4:       // float
        value = 0;
        if (*valueObj != 0) {
            MethodTable* p = (*valueObj)->GetMethodTable();
            CorElementType oType = p->GetNormCorElementType();
            CreatePrimitiveValue(fldType,oType,*valueObj,&value);
        }

        if (pField->IsStatic()) 
            pField->SetStaticValue32((int) value);
         else {
            pField->SetValue32(*target,(int) value);
        }
        break;

    case ELEMENT_TYPE_I8:       // long
    case ELEMENT_TYPE_U8:       // unsigned long
    case ELEMENT_TYPE_R8:       // double
        value = 0;
        if (*valueObj != 0) {
            MethodTable* p = (*valueObj)->GetMethodTable();
            CorElementType oType = p->GetNormCorElementType();
            CreatePrimitiveValue(fldType,oType,*valueObj,&value);
        }

        if (pField->IsStatic())
            pField->SetStaticValue64(value);
        else {
            pField->SetValue64(*target,value);
        }
        break;

    case ELEMENT_TYPE_SZARRAY:          // Single Dim, Zero
    case ELEMENT_TYPE_ARRAY:            // General Array
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_VAR:
        if (pField->IsStatic())
        {
            pField->SetStaticOBJECTREF(*valueObj);
        }
        else
        {
            pField->SetRefValue(*target,*valueObj);
        }
        break;

    case ELEMENT_TYPE_VALUETYPE:
        {

            _ASSERTE(fldTH.IsUnsharedMT());

            MethodTable* pMT = fldTH.AsMethodTable();

            void *pNewSrc = NULL;
            void *pObj = NULL;
            // If we have a null value then we must create an empty field
            if (*valueObj == NULL) {
                int size = pMT->GetClass()->GetNumInstanceFieldBytes();
                pNewSrc = _alloca(size);
                memset(pNewSrc, 0, size);
            }
            else
                pNewSrc = (*valueObj)->UnBox();
            
            // Value classes require createing a boxed version of the field and then copying from the source...
            if (pField->IsStatic()) 
            {
                pObj = pField->GetPrimitiveOrValueClassStaticAddress();
                CopyValueClass(pObj, pNewSrc, pMT, (*target == NULL) ? GetAppDomain() : (*target)->GetAppDomain());
            }
            else 
            {
                Object *o = OBJECTREFToObject(*target);
                if(o->IsThunking())
                {
                    Object *puo = (Object *) CRemotingServices::AlwaysUnwrap((Object*) o);
                    OBJECTREF unwrapped = ObjectToOBJECTREF(puo);

                    CRemotingServices::FieldAccessor(pField, unwrapped, (void *)pNewSrc, FALSE);

                }
                else
                {
                    pObj = (*((BYTE**) target)) + pField->GetOffset() + sizeof(Object);
                    CopyValueClass(pObj, pNewSrc, pMT, (*target == NULL) ? GetAppDomain() : (*target)->GetAppDomain());
                }
            }
        }
        break;

    default:
        _ASSERTE(!"Unknown Type");
        // this is really an impossible condition
        COMPlusThrow(kNotSupportedException);
    }
}

// GetFieldValue
// This method will return an INT64 containing the value of the field.
INT64 InvokeUtil::GetFieldValue(CorElementType fldType,TypeHandle fldTH,FieldDesc* pField,OBJECTREF* target)
{
    THROWSCOMPLUSEXCEPTION();

    // call the <cinit> 
    OBJECTREF Throwable;
    if (!pField->GetMethodTableOfEnclosingClass()->CheckRunClassInit(&Throwable)) {
        GCPROTECT_BEGIN(Throwable);
        OBJECTREF except = CreateTargetExcept(&Throwable);
        COMPlusThrow(except);
        GCPROTECT_END();
    }

    INT64 value = 0;
    // For static final fields we need to get the value out of
    //  the constant table
    if (pField->GetOffset() == FIELD_OFFSET_NOT_REAL_FIELD) {
        value = GetValueFromConstantTable(pField);
        if (fldType == ELEMENT_TYPE_VALUETYPE) {
            OBJECTREF obj = AllocateObject(fldTH.AsMethodTable());
            CopyValueClass((obj)->UnBox(), &value, fldTH.AsMethodTable(), obj->GetAppDomain());
            value = ObjToInt64(obj);
        }
        return value;
    }

    // This is a hack because from the previous case we may end up with an
    //  Enum.  We want to process it here.
    // Get the value from the field
    switch (fldType) {
    case ELEMENT_TYPE_VOID:
        _ASSERTE(!"Void used as Field Type!");
        COMPlusThrow(kNotSupportedException);

    case ELEMENT_TYPE_BOOLEAN:  // boolean
    case ELEMENT_TYPE_I1:       // byte
    case ELEMENT_TYPE_U1:       // unsigned byte
        if (pField->IsStatic())
            value = pField->GetStaticValue8();
        else {
            value = pField->GetValue8(*target);
        }
        break;
    case ELEMENT_TYPE_I2:       // short
    case ELEMENT_TYPE_U2:       // unsigned short
    case ELEMENT_TYPE_CHAR:     // char
        if (pField->IsStatic())
            value =  pField->GetStaticValue16();
        else {
            value = pField->GetValue16(*target);
        }
        break;
    case ELEMENT_TYPE_I4:       // int
    case ELEMENT_TYPE_U4:       // unsigned int
    case ELEMENT_TYPE_R4:       // float
        if (pField->IsStatic()) 
            value =  pField->GetStaticValue32();
        else {
            value = pField->GetValue32(*target);
        }
        break;

    case ELEMENT_TYPE_I8:       // long
    case ELEMENT_TYPE_U8:       // unsigned long
    case ELEMENT_TYPE_R8:       // double
        if (pField->IsStatic())
            value = pField->GetStaticValue64();
        else {
            value = pField->GetValue64(*target);
        }
        break;

    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_SZARRAY:          // Single Dim, Zero
    case ELEMENT_TYPE_ARRAY:            // general array
    case ELEMENT_TYPE_VAR:
        if (pField->IsStatic())
        {                
            OBJECTREF or = pField->GetStaticOBJECTREF();
            value = ObjToInt64(or);
        }
        else
        {
            OBJECTREF or = pField->GetRefValue(*target);
            value = ObjToInt64(or);
        }
        break;

    case ELEMENT_TYPE_VALUETYPE:
        {
            // Value classes require createing a boxed version of the field and then
            //  copying from the source...
            // Allocate an object to return...
            _ASSERTE(fldTH.IsUnsharedMT());
            
            OBJECTREF obj = AllocateObject(fldTH.AsMethodTable());
            void *p = NULL;
            GCPROTECT_BEGIN(obj);
            // calculate the offset to the field...
            if (pField->IsStatic())
                p = pField->GetPrimitiveOrValueClassStaticAddress();
            else 
            {
                Object *o = OBJECTREFToObject(*target);
                if(o->IsThunking())
                {
                    Object *puo = (Object *) CRemotingServices::AlwaysUnwrap((Object*) o);
                    OBJECTREF unwrapped = ObjectToOBJECTREF(puo);

                    CRemotingServices::FieldAccessor(pField, unwrapped, (void *)obj->UnBox(), TRUE);
                }
                else
                {
                    p = (*((BYTE**) target)) + pField->GetOffset() + sizeof(Object);
                }
            }
            GCPROTECT_END();

            // copy the field to the unboxed object.
            // note: this will be done only for the non-remoting case
            if (p)
            {
                CopyValueClass(obj->UnBox(), p, fldTH.AsMethodTable(), obj->GetAppDomain());
            }
            value = ObjToInt64(obj);
        }
        break;

    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:
    case ELEMENT_TYPE_FNPTR:
        if (pField->IsStatic()) 
            value = (INT64)pField->GetStaticValuePtr();
        else {
            value = (INT64)pField->GetValuePtr(*target);
        }
        break;

    case ELEMENT_TYPE_PTR:
        {
            InitPointers();
            if (pField->IsStatic()) 
                value =  (INT64)pField->GetStaticValuePtr();
            else {
                value = (INT64)pField->GetValuePtr(*target);
            }
            OBJECTREF obj = AllocateObject(_ptr.AsMethodTable());
            GCPROTECT_BEGIN(obj);
            // Ignore null return
            OBJECTREF typeOR = fldTH.CreateClassObj();
            _ptrType->SetRefValue(obj,typeOR);
            _ptrValue->SetValuePtr(obj,(void*) value);
            value = ObjToInt64(obj);
            GCPROTECT_END();
        }
        break;

    default:
        _ASSERTE(!"Unknown Type");
        // this is really an impossible condition
        COMPlusThrow(kNotSupportedException);
    }
    return value;
}

MethodTable* InvokeUtil::GetParamArrayAttributeTypeHandle()
{
    if (!_pParamArrayAttribute) 
        _pParamArrayAttribute = g_Mscorlib.GetClass(CLASS__PARAM_ARRAY_ATTRIBUTE);
    return _pParamArrayAttribute;
}

// GetValueFromConstantTable
// This field will access a value for a field that is found
//  int the constant table
INT64 InvokeUtil::GetValueFromConstantTable(FieldDesc* fld)
{
    THROWSCOMPLUSEXCEPTION();

    MDDefaultValue defaultValue;    
    OBJECTREF obj;
    INT64 value = 0;

    // Grab the Constant as a meta data variants
    fld->GetMDImport()->GetDefaultValue(
        fld->GetMemberDef(),            // The member for which to get props.
        &defaultValue);                 // Default value.
        
    // Copy the value to the INT64
    switch (defaultValue.m_bType) {
    case ELEMENT_TYPE_BOOLEAN:
        value = defaultValue.m_bValue;
        break;

    case ELEMENT_TYPE_I1:
        value = defaultValue.m_cValue;
        break;

    case ELEMENT_TYPE_U1:
        value = defaultValue.m_byteValue;
        break;

    case ELEMENT_TYPE_I2:
        value = defaultValue.m_sValue;
        break;

    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        value = defaultValue.m_usValue;
        break;

    case ELEMENT_TYPE_I4:
        value = defaultValue.m_lValue;
        break;

    case ELEMENT_TYPE_U4:
        value = defaultValue.m_ulValue;
        break;

    case ELEMENT_TYPE_I8:
        value = defaultValue.m_llValue;
        break;

    case ELEMENT_TYPE_U8:
        value = defaultValue.m_ullValue;
        break;

    case ELEMENT_TYPE_R4:
        value = *((int*) &defaultValue.m_fltValue);
        break;

    case ELEMENT_TYPE_R8:
        value = *((INT64*) &defaultValue.m_dblValue);
        break;

    case ELEMENT_TYPE_STRING:
        obj = (OBJECTREF) COMString::NewString(defaultValue.m_wzValue, defaultValue.m_cbSize / sizeof(WCHAR));
        value = ObjToInt64(obj);
        break;

    case ELEMENT_TYPE_CLASS:
        break; // value must be 0

    default:
        COMPlusThrow(kNotSupportedException);
    }

    return value;
}

// FindMatchingMethods
// This method will return an array of MethodInfo object that
//  match the criteria passed....(This will cause GC to occur.)
LPVOID InvokeUtil::FindMatchingMethods(int bindingAttr,
                                       LPCUTF8 szName, 
                                       DWORD cName, 
                                       PTRARRAYREF *argTypes,
                                       int targArgCnt,
                                       bool checkCall,
                                       int callConv,
                                       ReflectClass* pRC,
                                       ReflectMethodList* pMeths, 
                                       TypeHandle elementType,
                                       bool verifyAccess)
{
    PTRARRAYREF     refArr;
    LPVOID          rv;
    RefSecContext   sCtx;

    if (pMeths->dwTotal == 0) 
        return 0;

    // The Search modifiers
    bool ignoreCase = (bindingAttr & BINDER_IgnoreCase)  != 0;
    bool declaredOnly = (bindingAttr & BINDER_DeclaredOnly)  != 0;
    bool loose = (bindingAttr & BINDER_OptionalParamBinding) != 0;

    // The search filters
    bool addStatic = ((bindingAttr & BINDER_Static)  != 0);
    bool addInst = ((bindingAttr & BINDER_Instance)  != 0);
    bool addPriv = ((bindingAttr & BINDER_NonPublic) != 0);
    bool addPub = ((bindingAttr & BINDER_Public) != 0);
    bool addInher = ((bindingAttr & BINDER_FlattenHierarchy) != 0);

    // Find methods.....
    int methCnt = 0;
    ReflectMethod** matchMeths = 0;
    matchMeths = (ReflectMethod**) _alloca(sizeof(ReflectMethod*) * pMeths->dwTotal);

    ReflectMethod* p;
    if (szName) {
        if (ignoreCase)
            p = pMeths->hash.GetIgnore(szName);
        else
            p = pMeths->hash.Get(szName);
    }
    else
        p = &(pMeths->methods[0]); // it's a constructor
    
    DWORD dwCurrentInh = 0;
    if ((!p) && addInher && pMeths->dwMethods < pMeths->dwTotal) {
        dwCurrentInh = pMeths->dwMethods;
        p = &(pMeths->methods[dwCurrentInh]);
    } 

    MethodTable *pParentMT = pRC->GetClass()->GetMethodTable();

    // Match the methods....
    while (p) {

        // Name Length... the ctor case will have the cName equal to 0
        if (cName && cName != p->dwNameCnt)
            goto end;

        // Check for access to publics, non-publics
        if (p->IsPublic()) {
            if (!addPub) goto end;
        }
        else {
            if (!addPriv) goto end;
            if (verifyAccess && !CheckAccess(&sCtx, p->attrs, pParentMT, 0)) goto end;
        }

        // Check fo static instance 
        if (p->IsStatic()) {
            if (!addStatic) goto end;
        }
        else {
            if (!addInst) goto end;
        }

        // Check name
        if (szName) {
            if (ignoreCase) {
                if (_stricmp(p->szName, szName) != 0)
                    goto end;
            }
            else {
                if (memcmp(p->szName, szName, cName))
                    goto end;
            }
        }

        // check the argument count if we are looking at that
        if (targArgCnt >= 0) {
            ExpandSig* pSig = p->GetSig();

            INT32 argCnt = pSig->NumFixedArgs();
            if (argCnt != targArgCnt) {

                // check if from InvokeMember(..) otherwise we certainly don't want to match when different arg number
                if ((bindingAttr & (BINDER_InvokeMethod | BINDER_CreateInstance)) && argTypes == NULL) {

                    // arguments count doesn't match, yet we can still have something we are interested in (i.e. varargs)
                    if (argCnt < targArgCnt && pSig->IsVarArg()) {
                        if ((callConv & VarArgs_CC) != 0) 
                            goto matchFound;
                    }

                    // this will happen in the optional parameter case when less parameters than actual are provided
                    IMDInternalImport *pInternalImport = p->pMethod->GetMDImport();
                    HENUMInternal   hEnumParam;
                    mdParamDef      paramDef = mdParamDefNil;
                    // get the args and make sure the missing one are in fact optional 
                    mdToken methodTk = p->GetToken();
                    if (!IsNilToken(methodTk)) {
                        HRESULT hr = pInternalImport->EnumInit(mdtParamDef, methodTk, &hEnumParam);
                        if (SUCCEEDED(hr)) {
                            
                            /**/
                            if (argCnt > targArgCnt && loose) {
                                ULONG cArg = (ULONG)targArgCnt + 1;
                                while (pInternalImport->EnumNext(&hEnumParam, &paramDef)) {
                                    LPCSTR  name;
                                    SHORT   seq;
                                    DWORD   revWord;
                                    name = pInternalImport->GetParamDefProps(paramDef,(USHORT*) &seq, &revWord);
                                    if ((ULONG)seq < cArg) 
                                        continue;
                                    else if ((ULONG)seq == cArg && (revWord & pdOptional)) {
                                        cArg++;
                                        continue;
                                    }
                                    else {
                                        break; // not an optional param, no match
                                    }
                                }
                                if (cArg == (ULONG)argCnt + 1) {
                                    pInternalImport->EnumClose(&hEnumParam);
                                    goto matchFound;
                                }
                            }
                            /**/

                            if ((argCnt < targArgCnt && argCnt > 0)|| argCnt == targArgCnt + 1) {
                                // it could be a param array. 

                                // get the sig of the last param
                                LPVOID pEnum;
                                pSig->Reset(&pEnum);
                                TypeHandle lastArgType;
                                for (INT32 i = 0; i < argCnt; i++) 
                                    lastArgType = pSig->NextArgExpanded(&pEnum);
                                    
                                pInternalImport->EnumReset(&hEnumParam);

                                // get metadata info and token for the last param
                                ULONG paramCount = pInternalImport->EnumGetCount(&hEnumParam);
                                for (ULONG ul = 0; ul < paramCount; ul++) 
                                    pInternalImport->EnumNext(&hEnumParam, &paramDef);
                                if (paramDef != mdParamDefNil) {
                                    LPCSTR  name;
                                    SHORT   seq;
                                    DWORD   revWord;
                                    name = pInternalImport->GetParamDefProps(paramDef,(USHORT*) &seq, &revWord);
                                    if (seq == argCnt) {
                                        // looks good! check that it is in fact a param array
                                        if (lastArgType.IsArray()) {
                                            if (COMCustomAttribute::IsDefined(p->GetModule(), paramDef, TypeHandle(InvokeUtil::GetParamArrayAttributeTypeHandle()))) {
                                                pInternalImport->EnumClose(&hEnumParam);
                                                goto matchFound;
                                            }
                                        }
                                    }
                                }
                            }
                            pInternalImport->EnumClose(&hEnumParam);
                        }
                    }
                }
                goto end;
            }
            // the number of arguments matches
        }
matchFound:

        // If we are only looking at the declared methods
        if (declaredOnly) {
            EEClass* pEEC = pRC->GetClass();
            if (p->pMethod->GetClass() != pEEC)
                goto end;
        }

        // Check the calling convention
        if (checkCall) {
            ExpandSig* pSig = p->GetSig();
            BYTE b = pSig->GetCallingConvention();
            // At the moment we only support to calling conventions
            //  we will check for VarArgs first and default to default...
            if (callConv == VarArgs_CC) {
                if (b != IMAGE_CEE_CS_CALLCONV_VARARG)
                    goto end;
            }
            else {
                if (b  != IMAGE_CEE_CS_CALLCONV_DEFAULT)
                    goto end;
            }

        }

        if ((bindingAttr & BINDER_ExactBinding) && argTypes != NULL && targArgCnt >= 0 && !(bindingAttr & BINDER_InvokeMethod)) {
            // if we are coming from GetMethod and BindingFlags.ExactBinding is provided 
            // check that we have the exact signature otherwise ignore
            LPVOID pEnum;
            ExpandSig* pSig = p->GetSig();
            INT32 argCnt = pSig->NumFixedArgs();

            pSig->Reset(&pEnum);
            TypeHandle argType;
            INT32 i = 0;
            for (; i < argCnt; i++) {
                argType = pSig->NextArgExpanded(&pEnum);
                REFLECTCLASSBASEREF type = (REFLECTCLASSBASEREF)((*argTypes)->GetAt(i));
                ReflectClass *pType = (ReflectClass*)type->GetData();
                TypeHandle actualArg = pType->GetTypeHandle();
                if (argType != actualArg) 
                    break;
            }
            if (i != argCnt) 
                goto end; // not all the args matched
        }

        // If the method has a linktime security demand attached, check it now.
        if (verifyAccess && !CheckLinktimeDemand(&sCtx, p->pMethod, false))
            goto end;

        // We got ourself a match...
        matchMeths[methCnt++] = p;
end:
        // Which list are we walking, ignore case or not?
        if (ignoreCase)
            p=p->pIgnNext;
        else
            p=p->pNext;

        if (!p && addInher) {

            // we've already started looking at inherited methods
            if (dwCurrentInh || (!pMeths->dwMethods)) {
                if (++dwCurrentInh < pMeths->dwTotal)
                    p = &(pMeths->methods[dwCurrentInh]);
            }

            // start looking at inherited methods
            else if (pMeths->dwMethods < pMeths->dwTotal) {
                dwCurrentInh = pMeths->dwMethods;
                p = &(pMeths->methods[dwCurrentInh]);
            }
        }           
    }

    // If we didn't find any methods then return
    if (methCnt == 0)
        return 0;

    OBJECTREF* temp = (OBJECTREF*) _alloca(sizeof(OBJECTREF) * methCnt);
    memset(temp,0,sizeof(OBJECTREF) * methCnt);
    GCPROTECT_ARRAY_BEGIN(*temp,methCnt);

    for (int i=0;i<methCnt;i++) {
        if (szName) 
            temp[i] = (OBJECTREF) matchMeths[i]->GetMethodInfo(pRC);
        else
            temp[i] = (OBJECTREF) matchMeths[i]->GetConstructorInfo(pRC);
    }

    // Allocate the MethodInfo Array and return it....
    refArr = (PTRARRAYREF) AllocateObjectArray(methCnt, elementType);

    int size = refArr->GetMethodTable()->GetComponentSize();
    char* dst = (char*)GetArrayElementPtr((OBJECTREF) refArr);
    memcpyGCRefs(dst, temp, size * methCnt);
    *((PTRARRAYREF*) &rv) = refArr;
    GCPROTECT_END();
    return rv;
}

// This can cause a GC...
OBJECTREF InvokeUtil::GetObjectFromMetaData(MDDefaultValue* mdValue)
{
    _ASSERTE(mdValue);

    INT64 value;

    CorElementType type = (CorElementType) mdValue->m_bType;
    switch (type)
    {
    case ELEMENT_TYPE_BOOLEAN:
        value = mdValue->m_bValue;
        break;
    case ELEMENT_TYPE_I1:
        value  = mdValue->m_cValue;
        break;  
    case ELEMENT_TYPE_U1:
        *(UINT32*)&value = mdValue->m_byteValue;
        break;  
    case ELEMENT_TYPE_I2:
        value = mdValue->m_sValue;
        break;  
    case ELEMENT_TYPE_U2:
        *(UINT32*)&value = mdValue->m_usValue;
        break;  
    case ELEMENT_TYPE_CHAR:             // char is stored as UI2 internally
        *(UINT32*)&value = mdValue->m_usValue;
        break;  
    case ELEMENT_TYPE_I4:
        value = mdValue->m_lValue;
        break;  
    case ELEMENT_TYPE_U4:
        *(UINT32*)&value = mdValue->m_ulValue;
        break;  
    case ELEMENT_TYPE_R4:
        *(R4*)&value = mdValue->m_fltValue;
        break;  
    case ELEMENT_TYPE_R8:
        *(R8*)&value = mdValue->m_dblValue;
        break;  
    case ELEMENT_TYPE_I8:
        value = mdValue->m_llValue;
        break;
    case ELEMENT_TYPE_U8:
        *(UINT64*)&value = mdValue->m_ullValue;
        break;
    case ELEMENT_TYPE_STRING: 
        {
            OBJECTREF obj = (OBJECTREF) COMString::NewString(mdValue->m_wzValue, mdValue->m_cbSize / sizeof(WCHAR));
            return obj;
        }
    case ELEMENT_TYPE_CLASS: 
    case ELEMENT_TYPE_OBJECT: 
    case ELEMENT_TYPE_VAR:
        {
            // The metadata only support NULL objectref's as default values.
            _ASSERTE(mdValue->m_unkValue == 0 && "Non NULL objectref's are not supported as default values!");
            return NULL;
        }
    default:
        {
            _ASSERTE(!"Invalid default value!");
            return NULL;
        }
    }

    // Get the type handle and then find it.
    TypeHandle th = ElementTypeToTypeHandle(type);
    _ASSERTE(th.IsUnsharedMT());
    MethodTable* pMT = th.AsMethodTable();
    OBJECTREF retO = AllocateObject(pMT);
    CopyValueClass(retO->UnBox(), &value, pMT, retO->GetAppDomain());
    return retO;
}


// Give a MethodDesc this method will return an array of ParameterInfo
//  object for that method.
PTRARRAYREF InvokeUtil::CreateParameterArray(REFLECTBASEREF* meth)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT         hr;
    PTRARRAYREF     pRet;
    PTRARRAYREF     pObjRet = 0;
    ULONG           paramCount = 0;
    LPCSTR*         pNames;
    DWORD*          pAttrs;
    mdToken*        pTokens;
    MDDefaultValue* pDefs;
    MethodDesc*     pCtorMeth;
    HENUMInternal   hEnumParam;
    
    
    // load all the info to do the work off the MethodInfo
    ReflectMethod* pRM = (ReflectMethod*) (*meth)->GetData();
    MethodDesc* pMeth = pRM->pMethod;
    Module *pMod = pMeth->GetModule();
    IMDInternalImport *pInternalImport = pMeth->GetMDImport();
    mdMethodDef md = pMeth->GetMemberDef();

    PCCOR_SIGNATURE pSignature;     // The signature of the found method
    DWORD           cSignature;
    pMeth->GetSig(&pSignature, &cSignature);
    MetaSig sig(pSignature, pMeth->GetModule());

    TypeHandle varTypes;
    if (pRM->typeHnd.IsArray()) 
        varTypes = pRM->typeHnd.AsTypeDesc()->GetTypeParam();
    
    // COMMember::m_pMTParameter is initialized
    COMMember::GetParameterInfo();
    _ASSERTE(COMMember::m_pMTParameter);
    //_ASSERTE(pMeth);

    // Get the signature...
    CorElementType retType = sig.GetReturnType();
    DWORD argCnt = sig.NumFixedArgs();
    BYTE callConv = sig.GetCallingConventionInfo(); 


    // allocate the return array
    pRet = (PTRARRAYREF) AllocateObjectArray(
        argCnt, COMMember::m_pMTParameter->m_pEEClass->GetMethodTable());
    GCPROTECT_BEGIN(pRet);

    // If there are paramter names in the meta-data then we will
    //  add them to the Paramter
    if ((md ^ mdtMethodDef) != 0) {
        hr = pInternalImport->EnumInit(mdtParamDef, md, &hEnumParam);
        if (FAILED(hr)) {
            _ASSERTE(!"Unable to get the Param Count");
            FATAL_EE_ERROR();
        }
        paramCount = pInternalImport->EnumGetCount(&hEnumParam);

        // If the parameters are defined then allocate an array of names
        //  which will be added below.  The array will be created in the same
        //  order as the parameters are defined.
        if (paramCount > 0) {
            mdParamDef      paramDef;
            int size = (argCnt > paramCount) ? argCnt : paramCount;

            // Allocate an array of names and a second array for the call to the
            //  get the parameter name ids.  These have two different scopes so
            //  they are allocated in two separate allocations.
            pNames = (LPCSTR*) _alloca((size) * sizeof (LPCSTR));
            ZeroMemory(pNames,(size) * sizeof(LPCSTR));
            pAttrs = (DWORD*) _alloca((size) * sizeof (DWORD));
            ZeroMemory(pAttrs,(size) * sizeof(DWORD));
            pDefs = (MDDefaultValue*) _alloca((size) * sizeof(MDDefaultValue));
            ZeroMemory(pDefs,(size) * sizeof(MDDefaultValue));
            pTokens = (mdToken*) _alloca((size) * sizeof(mdToken));
            ZeroMemory(pTokens,(size) * sizeof(mdToken));


            // Loop through all of the parameters and get their names
            for (ULONG i=0; pInternalImport->EnumNext(&hEnumParam, &paramDef); i++) {
                LPCSTR  name;
                SHORT   seq;
                DWORD   revWord;
            
                name = pInternalImport->GetParamDefProps(paramDef,
                            (USHORT*) &seq, &revWord);
                pTokens[seq-1] = paramDef;
                //-1 since the sequence always starts at position 1.
                if ((seq - 1) >= 0 && seq < (int) argCnt+1) {
                    pNames[seq-1] = name;
                    pAttrs[seq-1] = revWord;
                    pInternalImport->GetDefaultValue(paramDef,&pDefs[seq-1]);
               }
            }

            // we are done with the henumParam
            pInternalImport->EnumClose(&hEnumParam);
        }
        else {
            pNames = 0;
            pAttrs = 0;
            pDefs = 0;
            pTokens = 0;

        }
    }
    else {
        pNames = 0;
        pAttrs = 0;
        pDefs = 0;
        pTokens = 0;
    }

    // Run the Class Init for Paramter
    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
    if (!COMMember::m_pMTParameter->CheckRunClassInit(&Throwable)) {
        COMPlusThrow(Throwable);
    }

    // Find the constructor
    PCCOR_SIGNATURE pBinarySig;
    ULONG           cbBinarySigLength;

    HRESULT hr;
    
    hr = gsig_IM_Type_MemberInfo_Str_Int_Int_Int_Bool_Obj_IntPtr_Int_RetVoid.GetBinaryForm(&pBinarySig, &cbBinarySigLength);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY)
            COMPlusThrowOM();
        else
            FATAL_EE_ERROR();
    }

    EEClass* pVMCParam = COMMember::m_pMTParameter->GetClass();
    _ASSERTE(pVMCParam);
    pCtorMeth= pVMCParam->FindConstructor(pBinarySig,cbBinarySigLength,pVMCParam->GetModule());
    _ASSERTE(pCtorMeth);
    MetaSig sigCtor(pCtorMeth->GetSig(),pCtorMeth->GetModule());

    // Populate the Array
    sig.Reset();
    DWORD i,j;
    for (i=0,j=0;i<argCnt;i++) {
        STRINGREF str;
        int attr = 0;
        int modif = 0;
        OBJECTREF var;
        BOOL bHasDefaultValue;

        // This can cause a GC...
        // If there is no default value then make the default DBNull. The reason that we need to check
        // ELEMENT_TYPE_END is because we might have some empty parameter information. Our caller has
        // zero initialized the memory in this case.
        //
        if (pDefs && pDefs[i].m_bType != ELEMENT_TYPE_VOID && pDefs[i].m_bType != ELEMENT_TYPE_END)
        {
            var = GetObjectFromMetaData(&pDefs[i]);
            bHasDefaultValue = TRUE;
        }
        else 
        {
            var = 0;
            bHasDefaultValue = FALSE;
        }
        GCPROTECT_BEGIN(var);


        // Allocate a Param object
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF ob = (OBJECTREF) AllocateObject(COMMember::m_pMTParameter);
        pRet->SetAt(i, ob);

        sig.NextArg();

        Throwable = NULL;
        TypeHandle argTypeHnd = sig.GetArgProps().GetTypeHandle(sig.GetModule(), &Throwable, FALSE, FALSE, &varTypes);
        if (Throwable != NULL)
            COMPlusThrow(Throwable);

        if (argTypeHnd.IsByRef())
            modif = PM_ByRef;
        OBJECTREF o = argTypeHnd.CreateClassObj();

        GCPROTECT_BEGIN(o);

        // Create the name string if it exists
        if (pNames && pNames[j])
            str = COMString::NewString(pNames[j]);
        else 
            str = 0;

        if (pAttrs) 
            attr |= pAttrs[j];
        
        // Call the Constructor ParameterInfo()
        UINT cbSize;
        BYTE* pNewArgs = 0;
        UINT nStackBytes = sigCtor.SizeOfVirtualFixedArgStack(0);
        pNewArgs = (BYTE *) _alloca(nStackBytes);
        BYTE *  pDst= pNewArgs;
       
        // NO GC AFTER THIS POINT...
        *(OBJECTREF*) pDst = pRet->m_Array[i];
        pDst += nStackBytes;

        // type
        cbSize = StackElemSize(4);
        pDst -= cbSize;
        *(OBJECTREF*) pDst = o;

        // Method
        cbSize = StackElemSize(4);
        pDst -= cbSize;
        *(REFLECTBASEREF*) pDst = *meth;

        // name
        cbSize = StackElemSize(4);
        pDst -= cbSize;
        *(STRINGREF*) pDst = str;

        // pos
        cbSize = StackElemSize(sizeof(INT32));
        pDst -= cbSize;
        *(INT32*) pDst = i;

        // attr
        cbSize = StackElemSize(sizeof(INT32));
        pDst -= cbSize;
        *(INT32*) pDst = attr;

        // modif
        cbSize = StackElemSize(sizeof(INT32));
        pDst -= cbSize;
        *(INT32*) pDst = modif;

        // Has default value flag
        cbSize = StackElemSize(sizeof(INT8));
        pDst -= cbSize;
        *(INT8*) pDst = bHasDefaultValue;

        // Default Value
        cbSize = StackElemSize(4);
        pDst -= cbSize;
        *(OBJECTREF*) pDst = var;

        // Module
        cbSize = StackElemSize(sizeof(size_t)); // should be the agnostic int
        pDst -= cbSize;
        *(size_t*) pDst = (size_t) pMod;

        // token
        cbSize = StackElemSize(sizeof(INT32));
        pDst -= cbSize;
        if (pTokens)
            *(INT32*) pDst = (INT32) pTokens[i];
        else
            *(INT32*) pDst = 0;

        pCtorMeth->Call(pNewArgs,&sigCtor);
 
        GCPROTECT_END();
        GCPROTECT_END();
        j++;
    }

   
    if (i != j) {
        PTRARRAYREF p = (PTRARRAYREF) AllocateObjectArray(
            j, COMMember::m_pMTParameter->m_pEEClass->GetMethodTable());
        for (i=0;i<j;i++)
            p->SetAt(i, pRet->GetAt(i+1));
        pRet = p;
        
    }

    pObjRet = pRet;

    GCPROTECT_END();
    GCPROTECT_END();
    return pObjRet;
}

StackWalkAction RefSecContext::TraceCallerCallback(CrawlFrame* pCf, VOID* data)
{
    RefSecContext *pCtx = (RefSecContext*)data;

    // Handle the case where we locate the caller via stack crawl mark first.
    if (pCtx->m_pStackMark) {
        // The check here is between the address of a local variable
        // (the stack mark) and a pointer to the EIP for a frame
        // (which is actually the pointer to the return address to the
        // function from the previous frame). So we'll actually notice
        // which frame the stack mark was in one frame later. This is
        // fine if the stack crawl mark indicates LookForMyCaller, but for
        // LookForMe we must record the previous frame's method desc.
        _ASSERTE(*pCtx->m_pStackMark == LookForMyCaller || *pCtx->m_pStackMark == LookForMe);
        if (*pCtx->m_pStackMark == LookForMe && pCtx->m_pLastCaller) {
            pCtx->m_pCaller = pCtx->m_pLastCaller;
            return SWA_ABORT;
        }
        if ((size_t)pCf->GetRegisterSet()->pPC < (size_t)pCtx->m_pStackMark)
            if (*pCtx->m_pStackMark == LookForMyCaller)
                return SWA_CONTINUE;
            else
                pCtx->m_pLastCaller = pCf->GetFunction();
    }

    MethodDesc *pMeth = pCf->GetFunction();
    _ASSERTE(pMeth);

    if (pCtx->m_pStackMark == NULL) {

        MethodTable* pCaller = pMeth->GetMethodTable();

        // If we see the top of a remoting chain (a call to StackBuilderSink.PrivateProcessMessage), we skip all the frames until
        // we see the bottom (a transparent proxy).
        if (pMeth == s_pMethPrivateProcessMessage) {
            _ASSERTE(!pCtx->m_fSkippingRemoting);
            pCtx->m_fSkippingRemoting = true;
            return SWA_CONTINUE;
        }
        if (!pCf->IsFrameless() && pCf->GetFrame()->GetFrameType() == Frame::TYPE_TP_METHOD_FRAME) {
            _ASSERTE(pCtx->m_fSkippingRemoting);
            pCtx->m_fSkippingRemoting = false;
            return SWA_CONTINUE;
        }
        if (pCtx->m_fSkippingRemoting)
            return SWA_CONTINUE;

        // If we are calling this from a reflection class we need to continue
        // up the chain (RuntimeMethodInfo, RuntimeConstructorInfo, MethodInfo,
        // ConstructorInfo).
        if (pCaller == s_pTypeRuntimeMethodInfo ||
            pCaller == s_pTypeMethodBase ||
            pCaller == s_pTypeRuntimeConstructorInfo ||
            pCaller == s_pTypeConstructorInfo ||
            pCaller == s_pTypeRuntimeType ||
            pCaller == s_pTypeType ||
            pCaller == s_pTypeRuntimeFieldInfo ||
            pCaller == s_pTypeFieldInfo ||
            pCaller == s_pTypeRuntimeEventInfo ||
            pCaller == s_pTypeEventInfo ||
            pCaller == s_pTypeRuntimePropertyInfo ||
            pCaller == s_pTypePropertyInfo ||
            pCaller == s_pTypeActivator ||
            pCaller == s_pTypeAppDomain ||
            pCaller == s_pTypeAssembly ||
            pCaller == s_pTypeTypeDelegator ||
            pCaller == s_pTypeDelegate ||
            pCaller == s_pTypeMulticastDelegate)
            return SWA_CONTINUE;
    }

    // Return the calling MethodTable.
    pCtx->m_pCaller = pMeth;

    return SWA_ABORT;
}

MethodDesc *RefSecContext::GetCallerMethod()
{
    if (!m_fCheckedCaller) {
        m_pCaller = NULL;
        StackWalkFunctions(GetThread(), TraceCallerCallback, this);
        // If we didn't find a caller, we were called through interop. In this
        // case we know we're going to get full permissions.
        if (m_pCaller == NULL && !m_fCheckedPerm) {
            m_fCallerHasPerm = true;
            m_fCheckedPerm = true;
        }
        m_fCheckedCaller = true;
    }

    return m_pCaller;
}

MethodTable *RefSecContext::GetCallerMT()
{
    MethodDesc *pCaller = GetCallerMethod();
    return pCaller ? pCaller->GetMethodTable() : NULL;
}

bool RefSecContext::CallerHasPerm(DWORD dwFlags)
{
    THROWSCOMPLUSEXCEPTION();

    if (!m_fCheckedPerm) {
        DWORD   dwPermType = dwFlags & REFSEC_CHECK_MEMBERACCESS ? REFLECTION_MEMBER_ACCESS : REFLECTION_TYPE_INFO;

        COMPLUS_TRY {
            COMCodeAccessSecurityEngine::SpecialDemand(dwPermType);
            m_fCallerHasPerm = true;
        } COMPLUS_CATCH {
            m_fCallerHasPerm = false;
            if (dwFlags & REFSEC_THROW_MEMBERACCESS) {
                
                MethodDesc* pMDesc = GetCallerMethod();
                if (!pMDesc)
                    COMPlusThrow(kMethodAccessException, L"Arg_MethodAccessException");                    

                else
                {
                    LPCWSTR szClassName;
                    LPCUTF8 szUTFMethodName;
                    
                    DefineFullyQualifiedNameForClassWOnStack();
                    szClassName = GetFullyQualifiedNameForClassW(pMDesc->GetClass());
                    
                    szUTFMethodName = pMDesc->GetMDImport()->GetNameOfMethodDef(pMDesc->GetMemberDef());
					#define MAKE_TRANSLATIONFAILED szMethodName=L""
                    MAKE_WIDEPTR_FROMUTF8_FORPRINT(szMethodName, szUTFMethodName);;
					#undef MAKE_TRANSLATIONFAILED
                    
                    COMPlusThrow(kMethodAccessException, L"Arg_MethodAccessException");
                }
            }
            
            else if (dwFlags & REFSEC_THROW_FIELDACCESS)
                COMPlusThrow(kFieldAccessException, L"Arg_FieldAccessException");
            else if (dwFlags & REFSEC_THROW_SECURITY)
                COMPlusRareRethrow();
        } COMPLUS_END_CATCH

        m_fCheckedPerm = true;
    }

    return m_fCallerHasPerm;
}

// Check accessability of a field or method.
bool InvokeUtil::CheckAccess(RefSecContext *pCtx, DWORD dwAttr, MethodTable *pParentMT, DWORD dwFlags)
{
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pCallerMT = pCtx->GetCallerMT();

    // Always allow interop callers full access.
    if (!pCallerMT)
        return true;

    // Global methods are not visible outside the module they are defined in
    if ( (! ((pParentMT->GetClass()->GetCl() == COR_GLOBAL_PARENT_TOKEN) && 
             (pParentMT->GetModule() != pCallerMT->GetModule())) )) {
        BOOL canAccess;
        if (pCtx->GetClassOfInstance()) 
             canAccess = ClassLoader::CanAccess(pCallerMT->GetClass(),
                                                 pCallerMT->GetAssembly(),
                                                 pParentMT->GetClass(),
                                                 pParentMT->GetAssembly(),
                                                 pCtx->GetClassOfInstance(),
                                                 dwAttr);
        else
            canAccess = ClassLoader::CanAccess(pCallerMT->GetClass(),
                                                pCallerMT->GetAssembly(),
                                                pParentMT->GetClass(),
                                                pParentMT->GetAssembly(),
                                                dwAttr);
        if (canAccess) 
            return true;
    }
        
    return pCtx->CallerHasPerm(dwFlags);
}

// Check accessability of a type or nested type.
bool InvokeUtil::CheckAccessType(RefSecContext *pCtx, EEClass *pClass, DWORD dwFlags)
{
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pCallerMT = pCtx->GetCallerMT();

    // Always allow interop callers full access.
    if (!pCallerMT)
        return true;

    if (ClassLoader::CanAccessClass(pCallerMT->GetClass(),
                                    pCallerMT->GetAssembly(),
                                    pClass,
                                    pClass->GetAssembly()))
        return true;

    return pCtx->CallerHasPerm(dwFlags);
}

// If a method has a linktime demand attached, perform it.
bool InvokeUtil::CheckLinktimeDemand(RefSecContext *pCtx, MethodDesc *pMeth, bool fThrowOnError)
{
    THROWSCOMPLUSEXCEPTION();

    if (pMeth->RequiresLinktimeCheck() && pCtx->GetCallerMethod()) {
        OBJECTREF refThrowable = NULL;
        bool fOK = true;
        GCPROTECT_BEGIN(refThrowable);
        if (!Security::LinktimeCheckMethod(pCtx->GetCallerMethod()->GetAssembly(), pMeth, &refThrowable))
            fOK = false;
        if (!fOK && fThrowOnError)
            COMPlusThrow(refThrowable);
        GCPROTECT_END();
        return fOK;
    }
    return true;
}

BOOL InvokeUtil::CanCast(TypeHandle destinationType, TypeHandle sourceType, RefSecContext *pSCtx, OBJECTREF *pObject)
{
    if (pObject) {
        if ((*pObject)->GetMethodTable()->IsTransparentProxyType()) {
            MethodTable *pDstMT = destinationType.GetMethodTable();
            return CRemotingServices::CheckCast(*pObject, pDstMT->GetClass());
        }
    }

    if (sourceType.CanCastTo(destinationType)) 
        return true;
    else {
        // if the destination is either ELEMENT_TYPE_PTR or ELEMENT_TYPE_FNPTR and
        // the source is IntPtr we allow the cast requesting SKIP_VERIFICATION permission
        CorElementType destElemType = destinationType.GetNormCorElementType();
        if (destElemType == ELEMENT_TYPE_PTR || destElemType == ELEMENT_TYPE_FNPTR) {
            if (sourceType.AsMethodTable() == g_Mscorlib.FetchClass(CLASS__INTPTR)) {
                // assert we have skip verification permission
                //return Security::CanSkipVerification(pSCtx->GetCallerMethod()->GetModule());
                COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_SKIP_VER);
                return true;
            }
        }
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\jitinterfacegen.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: JITinterfaceGen.CPP
//
// ===========================================================================

// This contains GENeric C versions of some of the routines
// required by JITinterface.cpp. They are modeled after
// X86 specific routines found in JIThelp.asm or JITinterfaceX86.cpp

#include "common.h"
#include "JITInterface.h"
#include "EEConfig.h"
#include "excep.h"
#include "COMDelegate.h"
#include "remoting.h" // create context bound and remote class instances
#include "field.h"

#define JIT_LINKTIME_SECURITY


extern "C"
{
    VMHELPDEF hlpFuncTable[];
}


#ifdef MAXALLOC
extern AllocRequestManager g_gcAllocManager;

extern "C" BOOL CheckAllocRequest(size_t n)
{
    return g_gcAllocManager.CheckRequest(n);
}

extern "C" void UndoAllocRequest()
{
    g_gcAllocManager.UndoRequest();
}
#endif // MAXALLOC


// Nonguaranteed attempt to allocate small, non-finalizer, non-array object.
// Will return NULL if it finds it must gc, block, or throw an exception
// or anything else that requires a frame to track callee-saved registers.
// It should call try_fast_alloc but the inliner does not do
// a perfect job, so we do it by hand.
#pragma optimize("t", on)
Object * __fastcall JIT_TrialAllocSFastSP(MethodTable *mt)
{
    _ASSERTE(!"@TODO Port - JIT_TrialAllocSFastSP (JITinterfaceGen.cpp)");
    return NULL;
//    if (! checkAllocRequest())
//        return NULL;
//    if (++m_GCLock == 0)
//    {
//        size_t size = Align (mt->GetBaseSize());
//        assert (size >= Align (min_obj_size));
//        generation* gen = pGenGCHeap->generation_of (0);
//        BYTE*  result = generation_allocation_pointer (gen);
//        generation_allocation_pointer (gen) += size;
//        if (generation_allocation_pointer (gen) <=
//            generation_allocation_limit (gen))
//        {
//            LeaveAllocLock();
//            ((Object*)result)->SetMethodTable(mt);
//            return (Object*)result;
//        }
//        else
//        {
//            generation_allocation_pointer (gen) -= size;
//            LeaveAllocLock();
//        }
//    }
//    UndoAllocRequest();
//    goto CORINFO_HELP_NEWFAST
}


Object * __fastcall JIT_TrialAllocSFastMP(MethodTable *mt)
{
    _ASSERTE(!"@TODO Port - JIT_TrialAllocSFastMP (JITinterface.cpp)");
    return NULL;
}


HCIMPL1(int, JIT_Dbl2IntOvf, double val)
{
    __int32 ret = (__int32) val;   // consider inlining the assembly for the cast
    _ASSERTE(!"@TODO Port - JIT_Dbl2IntOvf (JITinterface.cpp)");
    return ret;
}
HCIMPLEND


HCIMPL1(INT64, JIT_Dbl2LngOvf, double val)
{
    __int64 ret = (__int64) val;   // consider inlining the assembly for the cast
    _ASSERTE(!"@TODO Port - JIT_Dbl2LngOvf (JITinterface.cpp)");
    return ret;
}
HCIMPLEND


#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL0(VOID, JIT_StressGC)
{
#ifdef _DEBUG
        HELPER_METHOD_FRAME_BEGIN_0();    // Set up a frame
        g_pGCHeap->GarbageCollect();
        HELPER_METHOD_FRAME_END();
#endif // _DEBUG
}
HCIMPLEND


/*********************************************************************/
// Initialize the part of the JIT helpers that require very little of
// EE infrastructure to be in place.
/*********************************************************************/
BOOL InitJITHelpers1()
{
    SYSTEM_INFO     sysInfo;

    // make certain object layout in corjit.h is consistant with
    // what is in object.h
    _ASSERTE(offsetof(Object, m_pMethTab) == offsetof(CORINFO_Object, methTable));
        // TODO: do array count
    _ASSERTE(offsetof(I1Array, m_Array) == offsetof(CORINFO_Array, i1Elems));
    _ASSERTE(offsetof(PTRArray, m_Array) == offsetof(CORINFO_RefArray, refElems));

    // Handle the case that we are on an MP machine.
    ::GetSystemInfo(&sysInfo);
    if (sysInfo.dwNumberOfProcessors != 1)
    {
                // Use the MP version of JIT_TrialAllocSFast
        _ASSERTE(hlpFuncTable[CORINFO_HELP_NEWSFAST].pfnHelper == JIT_TrialAllocSFastSP);
        hlpFuncTable[CORINFO_HELP_NEWSFAST].pfnHelper = JIT_TrialAllocSFastMP;

        _ASSERTE(hlpFuncTable[CORINFO_HELP_NEWSFAST_ALIGN8].pfnHelper == JIT_TrialAllocSFastSP);
        hlpFuncTable[CORINFO_HELP_NEWSFAST_ALIGN8].pfnHelper = JIT_TrialAllocSFastMP;
       
        // If we are on a multiproc machine stomp some nop's with lock prefix's
    }
    else
    {
        _ASSERTE(hlpFuncTable[CORINFO_HELP_NEWSFAST].pfnHelper == JIT_TrialAllocSFastSP);
        _ASSERTE(hlpFuncTable[CORINFO_HELP_NEWSFAST_ALIGN8].pfnHelper == JIT_TrialAllocSFastSP);

#ifdef MULTIPLE_HEAPS
                //stomp the allocator even for one processor
                hlpFuncTable[CORINFO_HELP_NEWSFAST].pfnHelper = JIT_TrialAllocSFastMP;
                hlpFuncTable[CORINFO_HELP_NEWSFAST_ALIGN8].pfnHelper = JIT_TrialAllocSFastMP;
#endif //MULTIPLE_HEAPS
    }

    // Copy the write barriers to their final resting place.
    // Note: I use a pfunc temporary here to avoid a WinCE internal compiler error
    return TRUE;
}


/*********************************************************************/
// This is a frameless helper for entering a monitor on a object.
// The object is in ARGUMENT_REG1.  This tries the normal case (no
// blocking or object allocation) in line and calls a framed helper
// for the other cases.
HCIMPL1(void, JIT_MonEnter, OBJECTREF or)
{
    THROWSCOMPLUSEXCEPTION();

    if (or == 0)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");
    or->EnterObjMonitor();
}
HCIMPLEND

/***********************************************************************/
// This is a frameless helper for trying to enter a monitor on a object.
// The object is in ARGUMENT_REG1 and a timeout in ARGUMENT_REG2. This tries the
// normal case (no object allocation) in line and calls a framed helper for the
// other cases.
HCIMPL1(BOOL, JIT_MonTryEnter, OBJECTREF or)
{
    THROWSCOMPLUSEXCEPTION();

    if (or == 0)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

    return or->TryEnterObjMonitor();
}
HCIMPLEND


/*********************************************************************/
// This is a frameless helper for exiting a monitor on a object.
// The object is in ARGUMENT_REG1.  This tries the normal case (no
// blocking or object allocation) in line and calls a framed helper
// for the other cases.
HCIMPL1(void, JIT_MonExit, OBJECTREF or)
{
    THROWSCOMPLUSEXCEPTION();

    if (or == 0)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

    or->LeaveObjMonitor();
}
HCIMPLEND


/*********************************************************************/
// This is a frameless helper for entering a static monitor on a class.
// The methoddesc is in ARGUMENT_REG1.  This tries the normal case (no
// blocking or object allocation) in line and calls a framed helper
// for the other cases.
// Note we are changing the methoddesc parameter to a pointer to the
// AwareLock.
HCIMPL1(void, JIT_MonEnterStatic, AwareLock *lock)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(lock);
    // no need to check for proxies, which is asserted inside the syncblock anyway
    lock->Enter();
}
HCIMPLEND


/*********************************************************************/
// A frameless helper for exiting a static monitor on a class.
// The methoddesc is in ARGUMENT_REG1.  This tries the normal case (no
// blocking or object allocation) in line and calls a framed helper
// for the other cases.
// Note we are changing the methoddesc parameter to a pointer to the
// AwareLock.
HCIMPL1(void, JIT_MonExitStatic, AwareLock *lock)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(lock);
    // no need to check for proxies, which is asserted inside the syncblock anyway
    lock->Leave();
}
HCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\jumptargettable.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "jumptargettable.h"

int X86JumpTargetTable::ComputeTargetOffset(int targetIndex)
{
    int offset = 0;

    //
    // Compute offset into subblock
    //

    offset += 3 - (targetIndex&3);

    int blockIndex = (targetIndex)>>2;

    //
    // Compute offset of block
    //

    while (blockIndex >= MAX_BLOCK_INDEX)
    {
        offset += FULL_BLOCK_SIZE;
        blockIndex -= MAX_BLOCK_INDEX;
    }

    //
    // Compute offset of subblock
    //

    if (blockIndex > 0)
    {
        if (blockIndex >= MAX_BEFORE_INDEX)
            offset += CENTRAL_JUMP_SIZE;

        offset += blockIndex * SUB_BLOCK_SIZE;
    }
    
    return offset;
}

int X86JumpTargetTable::ComputeSize(int targetCount)
{
    //
    // Handle the case of an empty table.
    //

    if (targetCount == 0)
        return 0;

    //
    // Get count of subblocks.  (Don't bother 
    // to trim the last block's size.)
    //

    int blockCount = (targetCount+SUB_TARGET_COUNT-1)>>2;

    //
    // Compute offset of start of block
    //

    int size = 0;

    while (blockCount >= MAX_BLOCK_INDEX)
    {
        size += FULL_BLOCK_SIZE;
        blockCount -= MAX_BLOCK_INDEX;
    }

    //
    // Compute number of subblocks.
    //

    if (blockCount > 0)
    {
        size += CENTRAL_JUMP_SIZE;
        size += blockCount * SUB_BLOCK_SIZE;
    }

    return size;
}

// 
// Returns offset of relative jump
//

int X86JumpTargetTable::EmitBlock(int targetCount, int baseIndex, BYTE *buffer)
{
    _ASSERTE((baseIndex&(SUB_TARGET_COUNT-1)) == 0);
    _ASSERTE(targetCount <= MAX_BLOCK_TARGET_COUNT);
    
    BYTE *p = buffer;

    //
    // Handle the case of an empty table.
    //

    if (targetCount == 0)
        return 0;

    //
    // Get count of subblocks.  (Don't bother 
    // to trim the last block's size.)
    //

    int blockCount = (targetCount+SUB_TARGET_COUNT-1)>>2;
    // @todo: "volatile" is working around a VC7 bug.  Remove it 
    // when the bug is fixed (10/12/00)
    volatile int blockIndex = 0;

    int beforeCount;
    if (blockCount >= MAX_BEFORE_INDEX)
        beforeCount = MAX_BEFORE_INDEX;
    else
        beforeCount = blockCount;

    blockCount -= beforeCount;

    // Compute jump site for internal branch destinations
    BYTE *jumpSite = buffer + (beforeCount * SUB_BLOCK_SIZE);

    // Emit before subblocks
    while (beforeCount-- > 0)
    {
        *p++ = INC_ESP;
        *p++ = INC_ESP;
        *p++ = INC_ESP;
        *p++ = MOV_AL;
        *p++ = (unsigned char) blockIndex++;
        *p++ = JMP_REL8;
        p++;

        _ASSERTE((jumpSite - p) < 127);
        p[-1] = (signed char) (jumpSite - p);
    }

    // Emit central jump site

    // movzx eax, al
    *p++ = MOVZX_EAX_AL_1;
    *p++ = MOVZX_EAX_AL_2;
    *p++ = MOVZX_EAX_AL_3;

    // add eax, (base block index*MAX_BLOCK_INDEX)
    *p++ = ADD_EAX;
    *((DWORD*&)p)++ = (baseIndex>>2);

    // jmp (target)
    *p++ = JMP_REL32;

    // Remember offset of jump address to return
    int jumpAddress = (int) (p - buffer);

    p += 4;

    _ASSERTE(blockCount <= MAX_AFTER_INDEX);

    // Emit after subblocks
    while (blockCount-- > 0)
    {
        *p++ = INC_ESP;
        *p++ = INC_ESP;
        *p++ = INC_ESP;
        *p++ = MOV_AL;
        *p++ = (unsigned char) blockIndex++;
        *p++ = JMP_REL8;
        p++;
        _ASSERTE((jumpSite - p) >= -128);
        p[-1] = (signed char) (jumpSite - p);
    }

    //
    // Return jump address site.
    //

    return jumpAddress;
}

int X86JumpTargetTable::ComputeTargetIndex(const BYTE *target)
{
    int targetIndex = 0;

    while (*target == X86JumpTargetTable::INC_ESP)
    {
        targetIndex++;
        target++;
    }

    _ASSERTE(*target == X86JumpTargetTable::MOV_AL);
    target++;
        
    targetIndex += (*target++) << 2;

    _ASSERTE(*target == X86JumpTargetTable::JMP_REL8);
    target++;

    signed char offset8 = (signed char) *target++;
    target += offset8;

    target += X86JumpTargetTable::CENTRAL_JUMP_EXTEND_EAX_SIZE;
    _ASSERTE(*target == X86JumpTargetTable::ADD_EAX);
    target++;

    targetIndex += (*(DWORD*)target) << 2;

    return targetIndex;
}

// -------------------------------------------------------
// Jump Target table stub manager functions & globals
// -------------------------------------------------------

X86JumpTargetTableStubManager *X86JumpTargetTableStubManager::g_pManager = NULL;

BOOL X86JumpTargetTableStubManager::Init()
{
    g_pManager = new X86JumpTargetTableStubManager();
    if (g_pManager == NULL)
        return FALSE;

    StubManager::AddStubManager(g_pManager);

    return TRUE;
}

#ifdef SHOULD_WE_CLEANUP
void X86JumpTargetTableStubManager::Uninit()
{
    delete g_pManager;
}
#endif /* SHOULD_WE_CLEANUP */

BOOL X86JumpTargetTableStubManager::CheckIsStub(const BYTE *stubStartAddress)
{
    //
    // First, check if it looks like a stub.
    //

    if (*(BYTE*)stubStartAddress != X86JumpTargetTable::INC_ESP &&
        *(BYTE*)stubStartAddress != X86JumpTargetTable::MOV_AL)
        return FALSE;

    return m_rangeList.IsInRange(stubStartAddress);
}

BOOL X86JumpTargetTableStubManager::DoTraceStub(const BYTE *stubStartAddress, 
                                                TraceDestination *trace)
{
    const BYTE *patchAddress = stubStartAddress;

    while (*patchAddress == X86JumpTargetTable::INC_ESP)
        patchAddress++;

    _ASSERTE(*patchAddress == X86JumpTargetTable::MOV_AL);
    patchAddress++;
    patchAddress++;

    _ASSERTE(*patchAddress == X86JumpTargetTable::JMP_REL8);
    patchAddress++;

    signed char offset8 = (signed char) *patchAddress++;
    patchAddress += offset8;

    patchAddress += X86JumpTargetTable::CENTRAL_JUMP_FIXUP_EAX_SIZE;

    _ASSERTE(*patchAddress == X86JumpTargetTable::JMP_REL32);

    trace->type = TRACE_MGR_PUSH;
    trace->address = patchAddress;
    trace->stubManager = this;

    LOG((LF_CORDB, LL_INFO10000,
         "X86JumpTargetTableStubManager::DoTraceStub yields TRACE_MGR_PUSH to 0x%08x "
         "for input 0x%08x\n",
         patchAddress, stubStartAddress));

    return TRUE;
}

BOOL X86JumpTargetTableStubManager::TraceManager(Thread *thread, 
                                                 TraceDestination *trace,
                                                 CONTEXT *pContext, BYTE **pRetAddr)
{
    //
    // Extract the vtable index from esp & eax, and
    // the instance pointer from esp.
    //

#ifdef _X86_ // non-x86 doesn't have eax/ecx in context
    int slotNumber = (pContext->Eax<<2) + (pContext->Esp&3);
    MethodTable *pMT = ((Object*)(size_t)(pContext->Ecx))->GetMethodTable();

    // 
    // We can go ahead and fixup the vtable here - it won't make any difference
    // if we fix it up multiple times.
    //

    SLOT slot = pMT->GetModule()->FixupInheritedSlot(pMT, slotNumber);

    trace->type = TRACE_STUB;
    trace->address = slot;
    trace->stubManager = this;

    LOG((LF_CORDB, LL_INFO10000,
         "X86JumpTargetTableStubManager::TraceManager yields TRACE_STUB to 0x%08x ",
         "based on method table %s and slot number %d\n",
         slot, pMT->GetClass()->m_szDebugClassName, slotNumber));

    return TRUE;
#else // !_X86_
    _ASSERTE(!"NYI");
    return FALSE;
#endif __X86_
}


MethodDesc *X86JumpTargetTableStubManager::Entry2MethodDesc(const BYTE *IP, 
                                                            MethodTable *pMT)
{
    if (CheckIsStub(IP))
    {
        int slotNumber = X86JumpTargetTable::ComputeTargetIndex(IP);

        MethodDesc *method = pMT->GetClass()->GetUnknownMethodDescForSlot(slotNumber);
        
        _ASSERTE(method);
        return method;
    }
    else
    {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\jitinterface.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: JITinterface.H
// 
// ===========================================================================

#ifndef JITINTERFACE_H 
#define JITINTERFACE_H

#include "corjit.h"
#include "corcompile.h"
#include "fcall.h"
#include "object.h"
#include "frames.h"

// Some defines for jitting
#define PREINIT_SIZE 1
#define NPDW   (sizeof(DWORD)*2)    // (4-bit) nibbles per dword
#define BBT    32                   // bytes per bucket
#define MAXCODEHEAPSIZE 64*1024
#define HEAP2MAPSIZE(x)  ((x) / (BBT*NPDW)*sizeof(DWORD))
#define ADDR2POS(x) ((x) >> 5)
#define ADDR2OFFS(x) (DWORD)((((x)&0x1f)>> 2)+1)

#define POSOFF2ADDR(pos, of) (DWORD*)(((pos) << 5) + (((of)-1)<< 2))
#define HEAP2MAPSIZE(x)  ((x) / (BBT*NPDW)*sizeof(DWORD))

#define POS2SHIFTCOUNT(x) (DWORD)(28 - (((x)%NPDW)<< 2))

#define RD2PAGE(x) (((x)+0xfff)/0x1000 * 0x1000)
#define SETHEADER(m, x) NibbleMapSet(m, ADDR2POS(x), ADDR2OFFS(x))
#define RESETHEADER(m, x) NibbleMapSet(m, ADDR2POS(x), 0)
#define PPMDTOJITSTART(x)               (void *)((DWORD)(x)+sizeof(void*))
#define JITSTARTTOPPMD(x)               ((MethodDesc**)(x) - 1)
#define JITSTARTTOPMD(x)                *JITSTARTTOPPMD(x)

#define SafeDelete(x) {if (x) delete(x);}

	// A number that represents the size of the largest value class
	// that we want a fast array allocation for.   If you make it too big
	// we get pesimistic about the number of elments we allow for fast
	// allocation.  
#define LARGE_ELEMENT_SIZE  16

#define JIT_DEFAULT_INLINE_SIZE 32

class Stub;
class MethodDesc;
class FieldDesc;
enum RuntimeExceptionKind;

class JIT_SetObjectArrayMaker : public LazyStubMaker
{
public:
    void *operator new(size_t size, void *pInPlace)
        {
            return pInPlace;
        }
    void CreateWorker(CPUSTUBLINKER *psl);
};

extern "C"
{
    void __stdcall JIT_UP_WriteBarrierEAX();        // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_WriteBarrierECX();        // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_WriteBarrierEBX();        // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_WriteBarrierEBP();        // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_WriteBarrierESI();        // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_WriteBarrierEDI();        // JIThelp.asm/JIThelp.s
}

BOOL InitJITHelpers1();
BOOL InitJITHelpers2();
Stub* JITFunction(MethodDesc* ftn, COR_ILMETHOD_DECODER* header, BOOL *fEJit, DWORD flags=0);
void* getJitHelper(CorInfoHelpFunc);

HRESULT LoadEEInfoTable(Module *currentModule, 
                        CORCOMPILE_EE_INFO_TABLE *table, SIZE_T tableSize);
HRESULT LoadHelperTable(Module *currentModule, 
                        void **table, SIZE_T tableSize);
HRESULT LoadDynamicInfoEntry(Module *currentModule,
                             Module *pInfoModule, BYTE *pBlob, 
                             int tableIndex, DWORD *entry);

extern FCDECL1(void, JIT_MonEnter, OBJECTREF or);         // JITinterfaceX86.cpp/JITinterfaceGen.cpp
extern FCDECL1(BOOL, JIT_MonTryEnter, OBJECTREF or);      // JITinterfaceX86.cpp/JITinterfaceGen.cpp
extern FCDECL1(void, JIT_MonExit, OBJECTREF or);          // JITinterfaceX86.cpp/JITinterfaceGen.cpp
extern FCDECL1(void, JIT_MonEnterStatic, AwareLock *lock);// JITinterfaceX86.cpp/JITinterfaceGen.cpp
extern FCDECL1(void, JIT_MonExitStatic, AwareLock *lock); // JITinterfaceX86.cpp/JITinterfaceGen.cpp
extern FCDECL2(__int32, JIT_GetField32, Object *obj, FieldDesc *pFD);
extern FCDECL2(__int64, JIT_GetField64, Object *obj, FieldDesc *pFD);
extern FCDECL2(Object* , JIT_GetField32Obj, Object *obj, FieldDesc *pFD);
extern FCDECL3(VOID, JIT_GetFieldStruct, LPVOID retBuff, Object *obj, FieldDesc *pFD);
extern FCDECL3(VOID, JIT_SetField32, Object *obj, FieldDesc *pFD, __int32 value);
extern FCDECL3(VOID, JIT_SetField64, Object *obj, FieldDesc *pFD, __int64 value);
extern FCDECL3(VOID, JIT_SetField32Obj, Object *obj, FieldDesc *pFD, Object *value);
extern FCDECL3(VOID, JIT_SetFieldStruct, Object *obj, FieldDesc *pFD, LPVOID valuePtr);
extern FCDECL1(Object*, JIT_Unwrap, Object* obj);;
extern FCDECL1(Object*, JIT_Wrap, Object* obj);
extern "C" __int64 __stdcall JIT_Dbl2Lng(double val);
extern "C" __int64 __stdcall JIT_Dbl2IntSSE2(double val);
extern "C" __int64 __stdcall JIT_Dbl2LngP4x87(double val);

float __stdcall JIT_FltRem(float divisor, float dividend);
double JIT_DblRem(double divisor, double dividend);
extern BOOL __stdcall JIT_CheckBoundaryForInline(CORINFO_METHOD_HANDLE hCaller, CORINFO_METHOD_HANDLE hCallee);

// We build the JIT helpers only when we have something to JIT.  But we refer to one
// of the JIT helpers out of our interface-invoke stubs, which we build during class
// loading.  Fortunately, we won't actually call through them until we have JITted
// something.  Provide a vector to call through for those stubs and bash it when
// the JIT helpers are available.
extern void *VectorToJIT_InternalThrowStack;

extern BYTE *JIT_WriteBarrier_Buf_Start; 
extern BYTE *JIT_WriteBarrier_Buf_End; 

extern StringObject* __fastcall FastAllocateString(DWORD cchArrayLength);
extern LPVOID *FCallFastAllocateStringImpl;

/*********************************************************************/
/*********************************************************************/
/* This is a little helper class that CEEInfo uses */

#include "siginfo.hpp"

struct ValueArrayDescr
{
    ValueArrayDescr(SigPointer aSig, Module* aModule, ValueArrayDescr* aNext=0) :
        sig(aSig), module(aModule), next(aNext) {}
    ~ValueArrayDescr() { if (next != 0) delete next; }

    SigPointer          sig;    // points to the signature describing the value array
    Module             *module; // module the signature comes from
    ValueArrayDescr    *next;
};

class CEEInfo : public virtual ICorDynamicInfo {
public:
    // ICorClassInfo stuff
    CorInfoType __stdcall asCorInfoType (CORINFO_CLASS_HANDLE cls);
    CORINFO_MODULE_HANDLE __stdcall getClassModule(CORINFO_CLASS_HANDLE clsHnd);
    const char* __stdcall getClassName (CORINFO_CLASS_HANDLE cls);
    DWORD __stdcall getClassAttribs (CORINFO_CLASS_HANDLE cls, CORINFO_METHOD_HANDLE context);
    CORINFO_CLASS_HANDLE __stdcall getSDArrayForClass(CORINFO_CLASS_HANDLE clsHnd);
    unsigned __stdcall getClassSize (CORINFO_CLASS_HANDLE cls);
    unsigned __stdcall getClassGClayout (CORINFO_CLASS_HANDLE cls, BYTE* gcPtrs); /* really GCType* gcPtrs */
    const unsigned __stdcall getClassNumInstanceFields(CORINFO_CLASS_HANDLE cls);
    const unsigned __stdcall getFieldNumber(CORINFO_FIELD_HANDLE fldHnd);

    // return the enclosing class of the field
    CORINFO_CLASS_HANDLE __stdcall getEnclosingClass (
                        CORINFO_FIELD_HANDLE    field );

    // Check Visibility rules.
    // For Protected (family access) members, type of the instance is also
    // considered when checking visibility rules.
    BOOL __stdcall canAccessField(
                        CORINFO_METHOD_HANDLE   context,
                        CORINFO_FIELD_HANDLE    target,
                        CORINFO_CLASS_HANDLE    instance);

    CorInfoHelpFunc __stdcall getNewHelper(CORINFO_CLASS_HANDLE newCls, CORINFO_METHOD_HANDLE scopeHnd);
    CorInfoHelpFunc __stdcall getNewArrHelper(CORINFO_CLASS_HANDLE arrayCls,
                                              CORINFO_METHOD_HANDLE context);
    CorInfoHelpFunc __stdcall getIsInstanceOfHelper(CORINFO_CLASS_HANDLE IsInstClsHnd);
    CorInfoHelpFunc __stdcall getChkCastHelper(CORINFO_CLASS_HANDLE IsInstClsHnd);
    BOOL __stdcall initClass (CORINFO_CLASS_HANDLE cls, CORINFO_METHOD_HANDLE context, BOOL speculative);
    BOOL __stdcall loadClass (CORINFO_CLASS_HANDLE cls, CORINFO_METHOD_HANDLE context, BOOL speculative);
    CORINFO_CLASS_HANDLE __stdcall getBuiltinClass(CorInfoClassId classId);

    // "System.Int32" ==> CORINFO_TYPE_INT..
    CorInfoType __stdcall getTypeForPrimitiveValueClass(
            CORINFO_CLASS_HANDLE        cls
            );

    // TRUE if child is a subtype of parent
    // if parent is an interface, then does child implement / extend parent
    BOOL __stdcall canCast(
            CORINFO_CLASS_HANDLE        child, 
            CORINFO_CLASS_HANDLE        parent
            );

    // returns is the intersection of cls1 and cls2.
    CORINFO_CLASS_HANDLE __stdcall mergeClasses(
            CORINFO_CLASS_HANDLE        cls1, 
            CORINFO_CLASS_HANDLE        cls2
            );

    // Given a class handle, returns the Parent type.
    // For COMObjectType, it returns Class Handle of System.Object.
    // Returns 0 if System.Object is passed in.
    CORINFO_CLASS_HANDLE __stdcall getParentType (
            CORINFO_CLASS_HANDLE        cls
            );

    // Returns the CorInfoType of the "child type". If the child type is
    // not a primitive type, *clsRet will be set.
    // Given an Array of Type Foo, returns Foo.
    // Given BYREF Foo, returns Foo
    CorInfoType __stdcall getChildType (
            CORINFO_CLASS_HANDLE       clsHnd,
            CORINFO_CLASS_HANDLE       *clsRet
            );

    // Check Visibility rules.
    BOOL __stdcall canAccessType(
            CORINFO_METHOD_HANDLE       context,
            CORINFO_CLASS_HANDLE        target
            );

    // Is this a Single dimentional array 
    BOOL __stdcall isSDArray(
            CORINFO_CLASS_HANDLE        cls
            );

    // Static helpers
    static BOOL CanCast(
            CorElementType el1, 
            CorElementType el2);

        // ICorScopeInfo stuff
    DWORD __stdcall getModuleAttribs (CORINFO_MODULE_HANDLE cls);
    CORINFO_CLASS_HANDLE __stdcall findClass(CORINFO_MODULE_HANDLE  scopeHnd, unsigned metaTOK, CORINFO_METHOD_HANDLE context);
    CORINFO_FIELD_HANDLE __stdcall findField(CORINFO_MODULE_HANDLE  scopeHnd, unsigned metaTOK, CORINFO_METHOD_HANDLE context);
    CORINFO_METHOD_HANDLE __stdcall findMethod(CORINFO_MODULE_HANDLE  scopeHnd, unsigned metaTOK, CORINFO_METHOD_HANDLE context);
    void __stdcall findSig(CORINFO_MODULE_HANDLE scopeHnd, unsigned sigTOK, CORINFO_SIG_INFO* sig);
    void __stdcall findCallSiteSig(CORINFO_MODULE_HANDLE scopeHnd, unsigned methTOK, CORINFO_SIG_INFO* sig);
    CORINFO_GENERIC_HANDLE __stdcall findToken (CORINFO_MODULE_HANDLE  scopeHnd, unsigned metaTOK, CORINFO_METHOD_HANDLE context,
                                                CORINFO_CLASS_HANDLE& tokenType);
    const char * __stdcall findNameOfToken (CORINFO_MODULE_HANDLE module, mdToken metaTOK);
    BOOL __stdcall canSkipVerification(CORINFO_MODULE_HANDLE moduleHnd, BOOL fQuickCheckOnly);

    // Checks if the given metadata token is valid
    BOOL __stdcall isValidToken (
            CORINFO_MODULE_HANDLE       module,
            mdToken                    metaTOK);

    // Checks if the given metadata token is valid StringRef
    BOOL __stdcall isValidStringRef (
            CORINFO_MODULE_HANDLE       module,
            mdToken                    metaTOK);

    static const char * __stdcall findNameOfToken (Module* module, mdToken metaTOK);

        // ICorMethodInfo stuff
    const char* __stdcall getMethodName (CORINFO_METHOD_HANDLE ftnHnd, const char** scopeName);
    unsigned __stdcall getMethodHash (CORINFO_METHOD_HANDLE ftnHnd);
    DWORD __stdcall getMethodAttribs (CORINFO_METHOD_HANDLE ftnHnd, CORINFO_METHOD_HANDLE context);
    void __stdcall setMethodAttribs (CORINFO_METHOD_HANDLE ftnHnd, DWORD attribs);
    
    bool __stdcall getMethodInfo (
            CORINFO_METHOD_HANDLE ftnHnd,
            CORINFO_METHOD_INFO*  methInfo);

    CorInfoInline __stdcall canInline (
            CORINFO_METHOD_HANDLE  callerHnd,
            CORINFO_METHOD_HANDLE  calleeHnd,
            CORINFO_ACCESS_FLAGS   flags);

    bool __stdcall canTailCall (
            CORINFO_METHOD_HANDLE  callerHnd,
            CORINFO_METHOD_HANDLE  calleeHnd,
            CORINFO_ACCESS_FLAGS   flags);

    void __stdcall getMethodSig (
            CORINFO_METHOD_HANDLE ftnHnd,
            CORINFO_SIG_INFO* sigInfo);

    void __stdcall getEHinfo(
            CORINFO_METHOD_HANDLE ftn,
            unsigned      EHnumber,
            CORINFO_EH_CLAUSE* clause);

    CORINFO_CLASS_HANDLE __stdcall getMethodClass (CORINFO_METHOD_HANDLE methodHnd);
    CORINFO_MODULE_HANDLE __stdcall getMethodModule (CORINFO_METHOD_HANDLE methodHnd);
    unsigned __stdcall getMethodVTableOffset (CORINFO_METHOD_HANDLE methodHnd);
    CorInfoIntrinsics __stdcall getIntrinsicID(CORINFO_METHOD_HANDLE method);

    BOOL __stdcall canPutField(
            CORINFO_METHOD_HANDLE method,
            CORINFO_FIELD_HANDLE field);
    CorInfoUnmanagedCallConv __stdcall getUnmanagedCallConv(CORINFO_METHOD_HANDLE method);
    BOOL __stdcall pInvokeMarshalingRequired(CORINFO_METHOD_HANDLE method, CORINFO_SIG_INFO* callSiteSig);

    // Generate a cookie based on the signature that would needs to be passed
    //  to the above generic stub
    LPVOID GetCookieForPInvokeCalliSig(CORINFO_SIG_INFO* szMetaSig, void ** ppIndirection);

    // Returns TRUE if the methods have compatible sig
    BOOL __stdcall compatibleMethodSig(
        CORINFO_METHOD_HANDLE child, 
        CORINFO_METHOD_HANDLE parent);

    // Check Visibility rules.
    // For Protected (family access) members, type of the instance is also
    // considered when checking visibility rules.
    BOOL __stdcall canAccessMethod(
            CORINFO_METHOD_HANDLE       context,
            CORINFO_METHOD_HANDLE       target,
            CORINFO_CLASS_HANDLE        instance);

    // Given a Delegate type and a method, check if the method signature
    // is Compatible with the Invoke method of the delegate.
    BOOL __stdcall isCompatibleDelegate(
            CORINFO_CLASS_HANDLE        objCls,
            CORINFO_METHOD_HANDLE       method,
            CORINFO_METHOD_HANDLE       delegateCtor);

    // Static helper
    static BOOL CompatibleMethodSig(
            MethodDesc *pMethDescA, 
            MethodDesc *pMethDescB);

        // ICorFieldInfo stuff
    const char* __stdcall getFieldName (CORINFO_FIELD_HANDLE field, 
                                        const char** scopeName);

    DWORD __stdcall getFieldAttribs (CORINFO_FIELD_HANDLE  field, 
                                     CORINFO_METHOD_HANDLE context,
                                     CORINFO_ACCESS_FLAGS  flags);

    CORINFO_CLASS_HANDLE __stdcall getFieldClass (CORINFO_FIELD_HANDLE field);
    CorInfoType __stdcall getFieldType (CORINFO_FIELD_HANDLE field, CORINFO_CLASS_HANDLE* structType);
    unsigned __stdcall getFieldOffset (CORINFO_FIELD_HANDLE field);
    void* __stdcall getFieldAddress(CORINFO_FIELD_HANDLE field, void **ppIndirection);
    CorInfoHelpFunc __stdcall getFieldHelper(CORINFO_FIELD_HANDLE field, enum CorInfoFieldAccess kind);


    virtual CorInfoFieldCategory __stdcall getFieldCategory (CORINFO_FIELD_HANDLE field);
    virtual unsigned __stdcall getIndirectionOffset ();

    // ICorDebugInfo stuff
    void * __stdcall allocateArray(ULONG cBytes);
    void __stdcall freeArray(void *array);
    void __stdcall getBoundaries(CORINFO_METHOD_HANDLE ftn,
                                 unsigned int *cILOffsets, DWORD **pILOffsets,
                                 ICorDebugInfo::BoundaryTypes *implictBoundaries);
    void __stdcall setBoundaries(CORINFO_METHOD_HANDLE ftn,
                                 ULONG32 cMap, OffsetMapping *pMap);
    void __stdcall getVars(CORINFO_METHOD_HANDLE ftn, ULONG32 *cVars,
                           ILVarInfo **vars, bool *extendOthers);
    void __stdcall setVars(CORINFO_METHOD_HANDLE ftn, ULONG32 cVars,
                           NativeVarInfo *vars);

        // ICorArgInfo stuff

    CorInfoTypeWithMod __stdcall getArgType (
            CORINFO_SIG_INFO*       sig,
            CORINFO_ARG_LIST_HANDLE    args,
            CORINFO_CLASS_HANDLE       *vcTypeRet
            );
    CORINFO_CLASS_HANDLE __stdcall getArgClass (
            CORINFO_SIG_INFO*       sig,
            CORINFO_ARG_LIST_HANDLE    args
            );
    CORINFO_ARG_LIST_HANDLE __stdcall getArgNext (
            CORINFO_ARG_LIST_HANDLE args
            );

    // ICorLinkInfo stuff

    bool __stdcall deferLocation(
            CORINFO_METHOD_HANDLE           ftn,
            IDeferredLocation              *pIDL
            ) { return false; }
    void __stdcall recordRelocation(
            void                       **location,
            WORD                         fRelocType
            ) { }

    // ICorErrorInfo stuff

    HRESULT __stdcall GetErrorHRESULT();
    CORINFO_CLASS_HANDLE __stdcall GetErrorClass();
    ULONG __stdcall GetErrorMessage(LPWSTR buffer, ULONG bufferLength);
    int __stdcall FilterException(struct _EXCEPTION_POINTERS *pExceptionPointers);

        // ICorStaticInfo stuff
    void __stdcall getEEInfo(CORINFO_EE_INFO *pEEInfoOut);

        //ICorDynamicInfo stuff
    virtual DWORD __stdcall getFieldThreadLocalStoreID (CORINFO_FIELD_HANDLE field, void **ppIndirection);
    void* __stdcall getInterfaceID (CORINFO_CLASS_HANDLE  cls, void **ppIndirection);
    unsigned __stdcall getInterfaceTableOffset (CORINFO_CLASS_HANDLE    cls, void **ppIndirection);
    unsigned __stdcall getClassDomainID (CORINFO_CLASS_HANDLE   cls, void **ppIndirection);
    CORINFO_VARARGS_HANDLE __stdcall getVarArgsHandle(CORINFO_SIG_INFO *sig, void **ppIndirection);
    void* __stdcall findPtr(CORINFO_MODULE_HANDLE scopeHnd, unsigned ptrTOK);
    virtual void* __stdcall getMethodSync(CORINFO_METHOD_HANDLE ftnHnd, void **ppIndirection);
    virtual void** __stdcall AllocHintPointer(CORINFO_METHOD_HANDLE methodHnd, void **ppIndirection);
    CorInfoCallCategory __stdcall getMethodCallCategory(CORINFO_METHOD_HANDLE   method);
    void* __stdcall getPInvokeUnmanagedTarget(CORINFO_METHOD_HANDLE method, void **ppIndirection);
    void* __stdcall getAddressOfPInvokeFixup(CORINFO_METHOD_HANDLE method, void **ppIndirection);
    CORINFO_PROFILING_HANDLE __stdcall GetProfilingHandle(CORINFO_METHOD_HANDLE method, BOOL *bpHookFunction, void **ppIndirection);
    LPVOID __stdcall constructStringLiteral(CORINFO_MODULE_HANDLE scopeHnd, mdToken metaTok, void **ppIndirection);
    CORINFO_CLASS_HANDLE __stdcall findMethodClass(CORINFO_MODULE_HANDLE module, mdToken methodTok);
    LPVOID __stdcall getInstantiationParam(CORINFO_MODULE_HANDLE module, mdToken methodTok, void **ppIndirection);

    DWORD __stdcall getThreadTLSIndex(void **ppIndirection);
    const void * __stdcall getInlinedCallFrameVptr(void **ppIndirection);
    LONG * __stdcall getAddrOfCaptureThreadGlobal(void **ppIndirection);
    void* __stdcall getHelperFtn (CorInfoHelpFunc ftnNum, void **ppIndirection);
    void* __stdcall getFunctionEntryPoint(CORINFO_METHOD_HANDLE ftn,
                                          InfoAccessType       *pAccessType,
                                          CORINFO_ACCESS_FLAGS  flags);
    void* __stdcall getFunctionFixedEntryPoint(CORINFO_METHOD_HANDLE ftn,
                                       InfoAccessType       *pAccessType,
                                       CORINFO_ACCESS_FLAGS  flags);

    CORINFO_MODULE_HANDLE __stdcall embedModuleHandle(CORINFO_MODULE_HANDLE handle,
                                                      void **ppIndirection);
    CORINFO_CLASS_HANDLE __stdcall embedClassHandle(CORINFO_CLASS_HANDLE handle,
                                                    void **ppIndirection);
    CORINFO_FIELD_HANDLE __stdcall embedFieldHandle(CORINFO_FIELD_HANDLE handle,
                                                    void **ppIndirection);
    CORINFO_METHOD_HANDLE __stdcall embedMethodHandle(CORINFO_METHOD_HANDLE handle,
                                                      void **ppIndirection);
    CORINFO_GENERIC_HANDLE __stdcall embedGenericHandle(
                        CORINFO_MODULE_HANDLE   module,
                        unsigned                metaTOK,
                        CORINFO_METHOD_HANDLE   context,
                        void                  **ppIndirection,
                        CORINFO_CLASS_HANDLE& tokenType);

    void __stdcall setOverride(ICorDynamicInfo *pOverride) { m_pOverride = pOverride; }

    CEEInfo()
      : m_pOverride(NULL),
        m_ValueArrays(0)
      {
          m_pOverride = this;
      }

    ~CEEInfo() { delete m_ValueArrays; }

private:
        // TODO Should really be eliminated, but currently used internally
    void* __stdcall getMethodEntryPoint(CORINFO_METHOD_HANDLE ftnHnd, 
                                        CORINFO_ACCESS_FLAGS  flags,
                                        void **ppIndirection);
    void* __stdcall getMethodPointer(CORINFO_METHOD_HANDLE methodHnd, 
                                     CORINFO_ACCESS_FLAGS  flags,
                                     void **ppIndirection);

        // allocate a descriptor that will be removed when this ICorJitInfo goes away
    ValueArrayDescr* allocDescr(SigPointer sig, Module* mod) {
        m_ValueArrays = new ValueArrayDescr(sig, mod, m_ValueArrays);
        return(m_ValueArrays);
    }

        // Value arrays descriptors have the low order bits set to indicate
        // that it is a value array descriptor
    static CORINFO_CLASS_HANDLE markAsValueArray(ValueArrayDescr* descr) {
        _ASSERTE(((size_t)descr & 3) == 0);
        return(CORINFO_CLASS_HANDLE((size_t)descr | 3));
    }
    static bool isValueArray(CORINFO_CLASS_HANDLE clsHnd) {
        return(((size_t)clsHnd & 3) == 3);
    }
    static ValueArrayDescr* asValueArray(CORINFO_CLASS_HANDLE clsHnd) {
        _ASSERTE(isValueArray(clsHnd));
        return((ValueArrayDescr*)(((size_t)clsHnd & ~3)));
    }

    ValueArrayDescr* m_ValueArrays;     // descriptions of value class arrays
#ifdef _DEBUG
    char clsNameBuff[MAX_CLASSNAME_LENGTH];  // used to form fully qualified class names
#endif

    // Cached type handles
    static TypeHandle s_th_System_RuntimeTypeHandle;
    static TypeHandle s_th_System_RuntimeMethodHandle;
    static TypeHandle s_th_System_RuntimeFieldHandle;
    static TypeHandle s_th_System_RuntimeArgumentHandle;
    static TypeHandle s_th_System_TypedReference;

    void __stdcall InitStaticTypeHandles();

protected:
    ICorDynamicInfo *       m_pOverride;    
};

/*********************************************************************/

class  IJitManager;
struct _hpCodeHdr;
typedef struct _hpCodeHdr CodeHeader;

#pragma warning (disable:4250)

class CEEJitInfo : public CEEInfo, public ICorJitInfo
{
public:

        // ICorJitInfo stuff
    HRESULT __stdcall allocMem (
            ULONG               codeSize,
            ULONG               roDataSize,
            ULONG               rwDataSize,
            void **             codeBlock,
            void **             roDataBlock,
            void **             rwDataBlock
            );

    HRESULT __stdcall alloc (
            ULONG code_len, unsigned char** ppCode,
            ULONG EHinfo_len, unsigned char** ppEHinfo,
            ULONG GCinfo_len, unsigned char** ppGCinfo
            );

    HRESULT __stdcall allocGCInfo (
            ULONG              size,
            void **             block
            );
    HRESULT __stdcall setEHcount (
            unsigned      cEH);
    void __stdcall setEHinfo (
            unsigned      EHnumber,
            const CORINFO_EH_CLAUSE* clause);

    void __stdcall getEHinfo(
            CORINFO_METHOD_HANDLE ftn,              /* IN  */
            unsigned      EHnumber,                 /* IN */
            CORINFO_EH_CLAUSE* clause               /* OUT */
            );

    BOOL _cdecl logMsg(unsigned level, const char* fmt, va_list args);
    virtual int doAssert(const char* szFile, int iLine, const char* szExpr);

    CorInfoHelpFunc __stdcall getNewHelper(CORINFO_CLASS_HANDLE newCls, CORINFO_METHOD_HANDLE scopeHnd);

	friend Stub* JITFunction(MethodDesc* ftn, COR_ILMETHOD_DECODER* header, BOOL *fEJit, DWORD flags);

    CEEJitInfo(MethodDesc* fd, COR_ILMETHOD_DECODER* header, 
               IJitManager* jm)
      : m_FD(fd), m_ILHeader(header), m_jitManager(jm), m_CodeHeader(0) {}

private :
    IJitManager*            m_jitManager;   // responsible for allocating memory
    MethodDesc*             m_FD;           // method being compiled
    CodeHeader*             m_CodeHeader;   // descriptor for JITTED code
    COR_ILMETHOD_DECODER *  m_ILHeader;     // the code header as exist in the file
    OBJECTREF               pThrowable;     // pointer to exception object
};

/*********************************************************************/
/*********************************************************************/

// flags for VMHELPDEF
#define VHF_STUBFUNC    1
#define VHF_GCRETURN    2
#define VHF_NOGCCHECK   4
#define VHF_NORETURN    8

typedef struct {
#ifdef _DEBUG
    CorInfoHelpFunc code;
#endif // _DEBUG
    void * pfnHelper;
    void * pfnStub;
//    short params;
    short flags;
} VMHELPDEF;

enum JIT_UTIL_FUNCS
{
        JIT_UTIL_MON_ENTER,
        JIT_UTIL_MON_TRY_ENTER,
        JIT_UTIL_MON_ENTER_STATIC,
        JIT_UTIL_MON_EXIT,
        JIT_UTIL_MON_EXIT_THINLOCK,
        JIT_UTIL_MON_CONTENTION,
        JIT_UTIL_CHKCASTBIZARRE,
        JIT_UTIL_ISINSTANCEBIZARRE
};


class JIT_TrialAlloc
{
public:
    enum Flags
    {
        NORMAL       = 0x0,
        MP_ALLOCATOR = 0x1,
        SIZE_IN_EAX  = 0x2,
        OBJ_ARRAY    = 0x4,
        ALIGN8       = 0x8,     // insert a dummy object to insure 8 byte alignment (until the next GC)
        ALIGN8OBJ    = 0x10,
        NO_FRAME     = 0x20,    // call is from unmanaged code - don't try to put up a frame
    };

    static void *GenAllocSFast(Flags flags);
    static void *GenBox(Flags flags);
    static void *GenAllocArray(Flags flags);
    static void *GenAllocString(Flags flags);

private:
    static void EmitAlignmentRoundup(CPUSTUBLINKER *psl,X86Reg regTestAlign, X86Reg regToAdj, Flags flags); 
    static void EmitDummyObject(CPUSTUBLINKER *psl, X86Reg regTestAlign, Flags flags);
    static void EmitCore(CPUSTUBLINKER *psl, CodeLabel *noLock, CodeLabel *noAlloc, Flags flags);
    static void EmitNoAllocCode(CPUSTUBLINKER *psl, Flags flags);

#if CHECK_APP_DOMAIN_LEAKS
    static void EmitSetAppDomain(CPUSTUBLINKER *psl);
    static void EmitCheckRestore(CPUSTUBLINKER *psl);
#endif
};

void *GenFastGetSharedStaticBase();

#if defined(STRESS_HEAP) && defined(_DEBUG)
void SetupGcCoverage(MethodDesc* pMD, BYTE* nativeCode);
BOOL OnGcCoverageInterrupt(PCONTEXT regs);
#endif

BOOL __fastcall ArrayStoreCheck(Object** pElement, PtrArray** pArray);
BOOL ObjIsInstanceOf(Object *pElement, TypeHandle toTypeHnd);

#endif // JITINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\invokeutil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// This module defines a Utility Class used by reflection
//
// Author: Daryl Olander
// Date: March/April 1998
////////////////////////////////////////////////////////////////////////////////

#ifndef __INVOKEUTIL_H__
#define __INVOKEUTIL_H__

// The following class represents the value class
#pragma pack(push)
#pragma pack(1)

struct InterfaceMapData {
	REFLECTCLASSBASEREF		m_targetType;
	REFLECTCLASSBASEREF		m_interfaceType;
	PTRARRAYREF				m_targetMethods;
	PTRARRAYREF				m_interfaceMethods;
};

// Calling Conventions
// NOTE: These are defined in CallingConventions.cool They must match up.
#define Standard_CC		0x0001
#define	VarArgs_CC		0x0002
#define Any_CC			(Standard_CC | VarArgs_CC)

#define VA_ATTR 1
#define VA_MASK 0

#define PRIMITIVE_TABLE_SIZE  ELEMENT_TYPE_STRING
#define PT_Primitive	0x01000000

// Define the copy back constants.
#define COPYBACK_PRIMITIVE		1
#define COPYBACK_OBJECTREF		2
#define COPYBACK_VALUECLASS		3

#pragma pack(pop)

// Structure used to track security access checks efficiently when applied
// across a range of methods, fields etc.
//
class RefSecContext
{
    bool            m_fCheckedCaller;
    bool            m_fCheckedPerm;
    bool            m_fCallerHasPerm;
    bool            m_fSkippingRemoting;
    MethodDesc     *m_pCaller;
    MethodDesc     *m_pLastCaller;
    StackCrawlMark *m_pStackMark;
    EEClass        *m_pClassOfInstance;

    static MethodDesc  *s_pMethPrivateProcessMessage;
    static MethodTable *s_pTypeRuntimeMethodInfo;
    static MethodTable *s_pTypeMethodBase;
    static MethodTable *s_pTypeRuntimeConstructorInfo;
    static MethodTable *s_pTypeConstructorInfo;
    static MethodTable *s_pTypeRuntimeType;
    static MethodTable *s_pTypeType;
    static MethodTable *s_pTypeRuntimeFieldInfo;
    static MethodTable *s_pTypeFieldInfo;
    static MethodTable *s_pTypeRuntimeEventInfo;
    static MethodTable *s_pTypeEventInfo;
    static MethodTable *s_pTypeRuntimePropertyInfo;
    static MethodTable *s_pTypePropertyInfo;
    static MethodTable *s_pTypeActivator;
    static MethodTable *s_pTypeAppDomain;
    static MethodTable *s_pTypeAssembly;
    static MethodTable *s_pTypeTypeDelegator;
    static MethodTable *s_pTypeDelegate;
    static MethodTable *s_pTypeMulticastDelegate;

    static StackWalkAction TraceCallerCallback(CrawlFrame* pCf, VOID* data);

    void Init()
    {
        ZeroMemory(this, sizeof(*this));
        if (s_pTypeMulticastDelegate == NULL) {
            s_pMethPrivateProcessMessage = g_Mscorlib.FetchMethod(METHOD__STACK_BUILDER_SINK__PRIVATE_PROCESS_MESSAGE);
            s_pTypeRuntimeMethodInfo = g_Mscorlib.FetchClass(CLASS__METHOD);
            s_pTypeMethodBase = g_Mscorlib.FetchClass(CLASS__METHOD_BASE);
            s_pTypeRuntimeConstructorInfo = g_Mscorlib.FetchClass(CLASS__CONSTRUCTOR);
            s_pTypeConstructorInfo = g_Mscorlib.FetchClass(CLASS__CONSTRUCTOR_INFO);
            s_pTypeRuntimeType = g_Mscorlib.FetchClass(CLASS__CLASS);
            s_pTypeType = g_Mscorlib.FetchClass(CLASS__TYPE);
            s_pTypeRuntimeFieldInfo = g_Mscorlib.FetchClass(CLASS__FIELD);
            s_pTypeFieldInfo = g_Mscorlib.FetchClass(CLASS__FIELD_INFO);
            s_pTypeRuntimeEventInfo = g_Mscorlib.FetchClass(CLASS__EVENT);
            s_pTypeEventInfo = g_Mscorlib.FetchClass(CLASS__EVENT_INFO);
            s_pTypeRuntimePropertyInfo = g_Mscorlib.FetchClass(CLASS__PROPERTY);
            s_pTypePropertyInfo = g_Mscorlib.FetchClass(CLASS__PROPERTY_INFO);
            s_pTypeActivator = g_Mscorlib.FetchClass(CLASS__ACTIVATOR);
            s_pTypeAppDomain = g_Mscorlib.FetchClass(CLASS__APP_DOMAIN);
            s_pTypeAssembly = g_Mscorlib.FetchClass(CLASS__ASSEMBLY);
            s_pTypeTypeDelegator = g_Mscorlib.FetchClass(CLASS__TYPE_DELEGATOR);
            s_pTypeDelegate = g_Mscorlib.FetchClass(CLASS__DELEGATE);
            s_pTypeMulticastDelegate = g_Mscorlib.FetchClass(CLASS__MULTICAST_DELEGATE);
        }
    }

public:
    RefSecContext() { Init(); }
    RefSecContext(StackCrawlMark *pStackMark) { Init(); m_pStackMark = pStackMark; }

    MethodTable *GetCallerMT();
    MethodDesc *GetCallerMethod();
    bool CallerHasPerm(DWORD dwFlags);
    void SetClassOfInstance(EEClass *pClassOfInstance) { m_pClassOfInstance = pClassOfInstance; }
    EEClass* GetClassOfInstance() { return m_pClassOfInstance; }
};

#define REFSEC_CHECK_MEMBERACCESS   0x00000001
#define REFSEC_THROW_MEMBERACCESS   0x00000002
#define REFSEC_THROW_FIELDACCESS    0x00000004
#define REFSEC_THROW_SECURITY       0x00000008

// This class abstracts the functionality which creats the
//  parameters on the call stack and deals with the return type
//  inside reflection.
//
class InvokeUtil
{
public:
	// Constructors
    InvokeUtil();
    ~InvokeUtil() {}

    void CheckArg(TypeHandle th, OBJECTREF* obj, RefSecContext *pSCtx);
    void CopyArg(TypeHandle th, OBJECTREF *obj, void *pDst);

	struct _ObjectToTypedReferenceArgs {
		DECLARE_ECALL_OBJECTREF_ARG(TypeHandle, th);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj);
        DECLARE_ECALL_PTR_ARG(TypedByRef, typedReference); 
    };
    
	// CreateTypedReference
	// This routine fills the data that is passed in a typed reference
	//  inside the signature.  We through an HRESULT if this fails
	//  th -- the Type handle 
	//	obj -- the object to put on the heap
	//	pDst -- Pointer to the stack location where we copy the value
	void CreateTypedReference(_ObjectToTypedReferenceArgs* args);

	// Given a type, this routine will convert an INT64 representing that
	//	type into an ObjectReference.  If the type is a primitive, the 
	//	value is wrapped in one of the Value classes.
    OBJECTREF CreateObject(TypeHandle th,INT64 value);

	// This is a special purpose Exception creation function.  It
	//	creates the TargetInvocationExeption placing the passed
	//	exception into it.
    OBJECTREF CreateTargetExcept(OBJECTREF* except);

	// This is a special purpose Exception creation function.  It
	//	creates the ReflectionClassLoadException placing the passed
	//	classes array and exception array into it.
    OBJECTREF CreateClassLoadExcept(OBJECTREF* classes,OBJECTREF* except);

    // Validate that the field can be widened for Set
    HRESULT ValidField(TypeHandle th, OBJECTREF* value, RefSecContext *pSCtx);

    // CreateCustomAttributeObject
    // Create a CustomAttribute object
    void CreateCustomAttributeObject(EEClass *pAttributeClass, 
                                     mdToken tkCtor, 
                                     const void *blobData, 
                                     ULONG blobCnt, 
                                     Module *pModule, 
                                     INT32 inheritedLevel,
                                     OBJECTREF *ca);
	
	// CheckSecurity
	// This method will throw a security exception if reflection security is
	//	not on.
	void CheckSecurity();


	// CheckReflectionAccess
	// This method will allow callers with the correct reflection permission
	//	to fully access an object (including privates, protects, etc.)
	void CheckReflectionAccess(RuntimeExceptionKind reKind);

	// ChangeType
	// This method will invoke the Binder change type method on the object
	//	binder -- The Binder object
	//	srcObj -- The source object to be changed
	//	th -- The TypeHandel of the target type
	//	locale -- The locale passed to the class.
	OBJECTREF ChangeType(OBJECTREF binder,OBJECTREF srcObj,TypeHandle th,OBJECTREF locale);

	// GetAnyRef
	EEClass* GetAnyRef();

	// GetMethodInfo
	// Given a MethodDesc* get the methodInfo associated with it.
	OBJECTREF GetMethodInfo(MethodDesc* pMeth);

	// GetGlobalMethodInfo
	// Given a MethodDesc* and Module get the methodInfo associated with it.
	OBJECTREF GetGlobalMethodInfo(MethodDesc* pMeth,Module* pMod);

	EEClass* GetEEClass(TypeHandle th);

	// FindMatchingMethods
	// This method will return an array of MethodInfo object that
	//	match the criteria passed....(This will cause GC to occur.)
	//
	// bindingAttr -- The binding flags
	// szName -- the name of the method
	// cName -- The number of characters in the name
	// targArgCnt -- the Argument count
	// checkCall -- check the calling conventions
	// callConv -- The calling convention
	// pRC -- The refleciton class
	// pMeths -- The method list we are searching
	LPVOID FindMatchingMethods(int bindingAttr, 
                               LPCUTF8 szName, 
                               DWORD cName, 
                               PTRARRAYREF *argType,
		                       int targArgCnt,
                               bool checkCall,
                               int callConv,
                               ReflectClass* pRC,
                               ReflectMethodList* pMeths, 
                               TypeHandle elementType,
                               bool verifyAccess);

	// The method converts a MDDefaultValue into an Object
	OBJECTREF GetObjectFromMetaData(MDDefaultValue* mdValue);

	// Give a MethodDesc this method will return an array of ParameterInfo
	//	object for that method.
	PTRARRAYREF CreateParameterArray(REFLECTBASEREF* meth);

	// CreatePrimitiveValue
	// This routine will validate the object and then place the value into 
	//  the destination
	//  dstType -- The type of the destination
	//  srcType -- The type of the source
	//	srcObj -- The Object containing the primitive value.
	//  pDst -- poiner to the destination
	void CreatePrimitiveValue(CorElementType dstType,CorElementType srcType,
		OBJECTREF srcObj,void* pDst);

	// IsPrimitiveType
	// This method will verify the passed in type is a primitive or not
	//	type -- the CorElementType to check for
    inline static DWORD IsPrimitiveType(const CorElementType type)
    {
		if (type >= PRIMITIVE_TABLE_SIZE) {
            if (ELEMENT_TYPE_I==type || ELEMENT_TYPE_U==type) {
                return TRUE;
            }
            return 0;
        }

        return (PT_Primitive & (PrimitiveAttributes[type][VA_ATTR] & Attr_Mask));
    }

	// CanPrimitiveWiden
	// This method determines if the srcType and be widdened without loss to the destType
	//	destType -- The target type
	//	srcType -- The source type.
    inline static DWORD CanPrimitiveWiden(const CorElementType destType, const CorElementType srcType)
    {
		if (destType >= PRIMITIVE_TABLE_SIZE || srcType >= PRIMITIVE_TABLE_SIZE) {
            if ((ELEMENT_TYPE_I==destType && ELEMENT_TYPE_I==srcType) ||
                (ELEMENT_TYPE_U==destType && ELEMENT_TYPE_U==srcType)) {
                return TRUE;
            }
			return 0;
        }
        return (PrimitiveAttributes[destType][VA_MASK] &
                (PrimitiveAttributes[srcType][VA_ATTR] & Widen_Mask));
    }

	// Field Stuff.  The following stuff deals with fields making it possible
	//	to set/get field values on objects

	// SetValidField
	// Given an target object, a value object and a field this method will set the field
	//	on the target object.  The field must be validate before calling this.
	void SetValidField(CorElementType fldType,TypeHandle fldTH,FieldDesc* pField,OBJECTREF* target,OBJECTREF* value);

	// GetFieldValue
	// This method will return an INT64 containing the value of the field.
	INT64 GetFieldValue(CorElementType fldType,TypeHandle fldTH,FieldDesc* pField,OBJECTREF* target);

	// GetFieldTypeHandle
	// This will return type type handle and CorElementType for a field.
	//	It may throw an exception of the TypeHandle cannot be found due to a TypeLoadException.
	TypeHandle GetFieldTypeHandle(FieldDesc* pField,CorElementType* pType);

	// ValidateObjectTarget
	// This method will validate the Object/Target relationship
	//	is correct.  It throws an exception if this is not the case.
	void ValidateObjectTarget(FieldDesc* pField, EEClass* fldEEC, OBJECTREF *target);

	ReflectClass* GetPointerType(OBJECTREF* pObj);
	void* GetPointerValue(OBJECTREF* pObj);
	void* GetIntPtrValue(OBJECTREF* pObj);
	void* GetUIntPtrValue(OBJECTREF* pObj);

	// This method will initalize the pointer data and MUST be called before every access to the next 3 fields
	void InitPointers();
    void InitIntPtr();

	// These fields are used to grab the pointer information
	FieldDesc*		_ptrType;
	FieldDesc*		_ptrValue;
	TypeHandle		_ptr;

    FieldDesc*      _IntPtrValue;
    FieldDesc*      _UIntPtrValue;


    // Check accessability of a field or method.
    static bool CheckAccess(RefSecContext *pCtx, DWORD dwAttributes, MethodTable *pParentMT, DWORD dwFlags);

    // Check accessability of a type or nested type.
    static bool CheckAccessType(RefSecContext *pCtx, EEClass *pClass, DWORD dwFlags);

    // If a method has a linktime demand attached, perform it.
    static bool CheckLinktimeDemand(RefSecContext *pCtx, MethodDesc *pMeth, bool fThrowOnError);

    static MethodTable *GetParamArrayAttributeTypeHandle();

    BOOL CanCast(TypeHandle destinationType, TypeHandle sourceType, RefSecContext *pSCtx, OBJECTREF *pObject = NULL);


private:
    // Grab the Value EEClass because we use this all the time
    MethodTable* _pVMTargetExcept;
    MethodTable* _pVMClassLoadExcept;
    PCCOR_SIGNATURE _pBindSig;     // The signature of the found method
    DWORD			_cBindSig;
	Module*			_pBindModule;
	TypeHandle		_voidPtr;
    MethodTable     *_pMTCustomAttribute;
    static MethodTable *_pParamArrayAttribute;

    // The Attributes Table
	// This constructs a table of legal widening operations
	//	for the primitive types.
    static DWORD PrimitiveAttributes[PRIMITIVE_TABLE_SIZE][2];
    static DWORD Attr_Mask;
    static DWORD Widen_Mask;
 
    void CheckType(TypeHandle dstTH, OBJECTREF *psrcObj);

	void CreateValueTypeValue(TypeHandle dstTH, void* pDst, CorElementType srcType, TypeHandle srcTH, OBJECTREF srcObj);

    void CreateByRef(TypeHandle dstTh,void* pDst,CorElementType srcType, TypeHandle srcTH,OBJECTREF srcObj, OBJECTREF *pIncomingObj);

	// GetBoxedObject
	// Given an address of a primitve type, this will box that data...
	OBJECTREF GetBoxedObject(TypeHandle th,void* pData);

	// GetValueFromConstantTable
	// This field will access a value for a field that is found
	// in the constant table
	static INT64 GetValueFromConstantTable(FieldDesc* fld);
};


#endif // __INVOKEUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\jumptargettable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef JUMPTARGETTABLE_H_
#define JUMPTARGETTABLE_H_

#include <WinWrap.h>
#include <windows.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>
#include <limits.h>


//
// An JumpTargetTable is a range of code which provides a dense set of
// jump addresses, which all cascade to a single routine, but which
// leave behind state from which a unique index can be recovered for
// each address.
//
// The jump target table assumes assumes that the low 2 bits of ESP
// will be zero on entry.  In addition to changing these 2 bits, it
// stomps the AL with part of the result.   (These 10 bits
// are used to recover the original value from the destination routine.)
//
// The jump table is laid out in blocks.  The smallest blocks
// (called subblocks) look like this:
//
// inc esp      
// inc esp      
// mov al, imm8 
// jmp rel8     
//
// Each of these subblocks yields 4 jump targets, at a cost of 7 bytes. 
//
// These subblocks can be clustered (19 before and 16 after) around a central jump site
// movzx eax, al
// add eax, (base index >> 2)
// jmp rel32    
//
// A full block thus yields a total of 140 target addresses, at a
// cost of 258 bytes of code.
//
// These blocks can be duplicated as needed to provide more targets, up to an abritrary number.
//
// The ultimate target of the jump block must take the low 2 bits out
// of esp, and add to eax (shifted left by 2), to form the
// final index.
//

//
// NOTE: There are a few minor optimizations that we could make, but we don't because
// it just complicates the layout & saves only a few bytes.
// - the subblock before the central jump site could have its "jmp rel8" omitted
// - the last subblock could have one or more "inc ecx"s omitted if the number of targets isn't evenly
//      divisible by 4.
//

class X86JumpTargetTable
{
    friend class X86JumpTargetTableStubManager;

    //
    // Instruction constants
    //

    enum
    {
        INC_ESP = 0x44,
        MOV_AL = 0xB0,
        JMP_REL8 = 0xEB,
        JMP_REL32 = 0xE9,
        MOVZX_EAX_AL_1 = 0x0F,
        MOVZX_EAX_AL_2 = 0xB6,
        MOVZX_EAX_AL_3 = 0xC0,
        ADD_EAX = 0x05,
    };

    //
    // Block geometry constants
    //

    enum
    {
        // number of jump targets in subblock
        SUB_TARGET_COUNT = 4,

        // size of sub block of 4 targets
        SUB_BLOCK_SIZE = 7,

        // size of central jump site, target of sub blocks
        CENTRAL_JUMP_EXTEND_EAX_SIZE = 3,
        CENTRAL_JUMP_ADD_BASE_SIZE = 5,
        CENTRAL_JUMP_FIXUP_EAX_SIZE = CENTRAL_JUMP_EXTEND_EAX_SIZE + CENTRAL_JUMP_ADD_BASE_SIZE,
        CENTRAL_JUMP_SIZE = CENTRAL_JUMP_FIXUP_EAX_SIZE + 5,

        // Max. number of subblocks before jump site (max offset 127)
        MAX_BEFORE_INDEX = 19,

        // Max. number of subblocks after jump site (min offset -128)
        MAX_AFTER_INDEX = 16,

        // Total subblock count in block
        MAX_BLOCK_INDEX = (MAX_BEFORE_INDEX + MAX_AFTER_INDEX),
    };

  public:

    enum
    {
        // Max number of targets
        MAX_TARGET_COUNT = UINT_MAX,

        // Number of jump targets in fully populated block
        MAX_BLOCK_TARGET_COUNT = MAX_BLOCK_INDEX*SUB_TARGET_COUNT,

        // Total size of fully populated block
        FULL_BLOCK_SIZE = (SUB_BLOCK_SIZE*MAX_BLOCK_INDEX + CENTRAL_JUMP_SIZE),
    };
    
    //
    // Computes the offset (into a series of contiguous blocks) 
    // of a the target for the given index.
    //

    static int ComputeTargetOffset(int targetIndex);

    //
    // Computes the size of a contiguous series of blocks
    // containing the specified number of targets.
    //
    static int ComputeSize(int targetCount);

    //
    // Compute the target index of a jump target
    // 
    static int ComputeTargetIndex(const BYTE *target);

    //
    // Emits one block, with indicies starting at baseIndex, and containing
    // the given number of targets.  (baseIndex must be divisble by 4.)
    // Returns the offset of where the relative address of the jump target
    // must be written.
    //
    // Note that you will normally call this in a loop, each block containing
    // at most MAX_BLOCK_TARGET_COUNT entries, and blocks before the last
    // being size FULL_BLOCK_SIZE.  (The reason for this is that
    // there is one jump target address per block, which the caller is responsible
    // for filling in.)
    //

    static int EmitBlock(int targetCount, int baseIndex, BYTE *buffer);
};

class X86JumpTargetTableStubManager : public StubManager
{
  public:

    static X86JumpTargetTableStubManager *g_pManager;

    static BOOL Init();
#ifdef SHOULD_WE_CLEANUP
    static void Uninit();
#endif /* SHOULD_WE_CLEANUP */

    X86JumpTargetTableStubManager() : StubManager(), m_rangeList() {}
    ~X86JumpTargetTableStubManager() {}

    LockedRangeList m_rangeList;

    BOOL CheckIsStub(const BYTE *stubStartAddress);
    BOOL DoTraceStub(const BYTE *stubStartAddress, TraceDestination *trace);

  private:

    BOOL TraceManager(Thread *thread, TraceDestination *trace,
                      CONTEXT *pContext, BYTE **pRetAddr);
    MethodDesc *Entry2MethodDesc(const BYTE *IP, MethodTable *pMT);
};

#endif // JUMPTARGETTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\jitinterface.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: JITinterface.CPP
//
// ===========================================================================

//
// JITinterface.CPP has been broken up to make it easier to port
// from platform to platform. The code is now organized as follows:
//
// JITinterface.CPP             - C Code that is the same across processors and platforms
// JITinterfaceGen.cpp          - Generic C versions of routines found in
//                                JIThelp.asm and/or JITinterfaceX86.cpp
// i386\JIThelp.asm             - Assembler code for the x86 platform
// Alpha\JIThelp.s              - Assembler code for the Alpha platform
// i386\JITinterfaceX86.cpp     - C code that is x86 processor specific
// Alpha\JITinterfaceAlpha.cpp  - C code that is Alpha processor specific
//
// New processor platforms that are added need only write custom
// versions of JITinterfaceXXX.cpp (where xxx is the processor id)
// optionally for performance new platforms could add new jithelp versions too.
//

#include "common.h"
#include "JITInterface.h"
#include "codeman.h"
#include "EjitMgr.h"
#include "method.hpp"
#include "class.h"
#include "object.h"
#include "field.h"
#include "stublink.h"
#include "corjit.h"
#include "corcompile.h"
#include "EEConfig.h"
#include "COMString.h"
#include "excep.h"
#include "log.h"
#include "excep.h"
#include "metasig.h"
#include "float.h"      // for isnan
#include "DbgInterface.h"
#include "gcscan.h"
#include "security.h"   // to get security method attribute
#include "ndirect.h"
#include "ml.h"
#include "gc.h"
#include "COMDelegate.h"
#include "jitperf.h" // to track jit perf
#include "CorProf.h"
#include "EEProfInterfaces.h"
#include "icecap.h"
#include "remoting.h" // create context bound and remote class instances
#include "PerfCounters.h"
#include "dataimage.h"
#ifdef PROFILING_SUPPORTED
#include "ProfToEEInterfaceImpl.h"
#endif // PROFILING_SUPPORTED
#include "tls.h"
#include "ecall.h"
#include "compile.h"
#include "comstringbuffer.h"

#include "StackProbe.h"

#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"
#endif // CUSTOMER_CHECKED_BUILD

#ifdef _ICECAP
#define PROFILE 1
#include "icapexp.h"
#else // !_ICECAP
#define StartCAP()
#define StopCAP()
#endif // _ICECAP

#define JIT_LINKTIME_SECURITY


// **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE
//
// A word about EEClass vs. MethodTable
// ------------------------------------
//
// At compile-time, we are happy to touch both MethodTable and EEClass.  However,
// at runtime we want to restrict ourselves to the MethodTable.  This is critical
// for common code paths, where we want to keep the EEClass out of our working
// set.  For uncommon code paths, like throwing exceptions or strange Contexts
// issues, it's okay to access the EEClass.
//
// To this end, the TypeHandle (CORINFO_CLASS_HANDLE) abstraction is now based on the
// MethodTable pointer instead of the EEClass pointer.  If you are writing a
// runtime helper that calls GetClass() to access the associated EEClass, please
// stop to wonder if you are making a mistake.
//
// **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE



// **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE
//
// A word about Frameless JIT Helpers & Exceptions
// -----------------------------------------------
//
// We are extremely fragile in the mechanism by which we throw exceptions from
// frameless helpers.
//
// This is described in a comment at the top of JIT_InternalThrowStack().  You
// should read that comment before implementing any frameless helpers that throw.
//
// **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE


/*********************************************************************/

// #define ENABLE_NON_LAZY_CLINIT

void JIT_BadHelper() {
    //@todo FIX should put something that will fail in a retail build
    _ASSERTE(!"Bad Helper");
}

#ifdef _DEBUG
#define HELPCODE(code)  code,
#else // !_DEBUG
#define HELPCODE(code)
#endif // _DEBUG

extern "C"
{
    VMHELPDEF hlpFuncTable[];
    VMHELPDEF utilFuncTable[];
}

#if defined(ENABLE_PERF_COUNTERS)
LARGE_INTEGER g_lastTimeInJitCompilation;
#endif

// We build the JIT helpers only when we have something to JIT.  But we refer to one
// of the JIT helpers out of our interface-invoke stubs, which we build during class
// loading.  Fortunately, we won't actually call through them until we have JITted
// something.  Provide a vector to call through for those stubs and bash it when
// the JIT helpers are available.
#ifdef _DEBUG
static void
#ifndef _ALPHA_ // Alpha doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
TrapCalls()
{
    DebugBreak();
}
#endif // _DEBUG
void *VectorToJIT_InternalThrowStack
#ifdef _DEBUG
 = TrapCalls
#endif // _DEBUG
;


void __stdcall JIT_EndCatch();               // JITinterfaceX86.cpp/JITinterfaceAlpha.cpp
FCDECL2(INT64, JIT_LMul, INT64 val1, INT64 val2);
FCDECL2(INT64, JIT_ULMul, UINT64 val1, UINT64 val2);
static unsigned __int64 __stdcall JIT_Dbl2ULng(double val);
static double __stdcall JIT_ULng2Dbl(unsigned __int64 val);
FCDECL3(void*, JIT_Ldelema_Ref, PtrArray* array, unsigned idx, CORINFO_CLASS_HANDLE type);
FCDECL3(void, JIT_Stelem_Ref, PtrArray* array, unsigned idx, Object* val);
FCDECL2(Object *, JIT_StrCns, unsigned metaTok, CORINFO_MODULE_HANDLE scopeHnd);
FCDECL2(LPVOID, JIT_GetRefAny, CORINFO_CLASS_HANDLE type, TypedByRef typedByRef);
FCDECL2(LPVOID, JIT_Unbox, CORINFO_CLASS_HANDLE type, Object* obj);
FCDECL2(Object*, JIT_Box, CORINFO_CLASS_HANDLE type, void* data);
FCDECL2(INT64, JIT_LDiv, INT64 divisor, INT64 dividend);
FCDECL2(INT64, JIT_LMod, INT64 divisor, INT64 dividend);
FCDECL2(UINT64, JIT_ULDiv, UINT64 divisor, UINT64 dividend);
FCDECL2(UINT64, JIT_ULMod, UINT64 divisor, UINT64 dividend);
FCDECL2(INT64, JIT_LMulOvf, INT64 val2, INT64 val1);
FCDECL2(INT64, JIT_ULMulOvf, UINT64 val2, UINT64 val1);
FCDECL1(Object*, JIT_NewFast, CORINFO_CLASS_HANDLE typeHnd_);
FCDECL1(Object*, JIT_NewCrossContext, CORINFO_CLASS_HANDLE typeHnd_);
FCDECL1(Object*, JIT_NewSpecial, CORINFO_CLASS_HANDLE typeHnd_);
FCDECL1(Object*, JIT_New, CORINFO_CLASS_HANDLE typeHnd_);
FCDECL1(Object*, JIT_NewString, unsigned length);
FCDECL1(void, JIT_InitClass, CORINFO_CLASS_HANDLE typeHnd_);
FCDECL2(Object*, JIT_NewArr1, CORINFO_CLASS_HANDLE typeHnd_, int size);
FCDECL1(void, JIT_RareDisableHelper, Thread* thread);
FCDECL1(int, JIT_Dbl2IntOvf, double val);    // JITinterfaceX86.cpp/JITinterfaceGen.cpp
FCDECL1(INT64, JIT_Dbl2LngOvf, double val);  // JITinterfaceX86.cpp/JITinterfaceGen.cpp
FCDECL1(unsigned, JIT_Dbl2UIntOvf, double val);
FCDECL1(UINT64, JIT_Dbl2ULngOvf, double val);
FCDECL1(void, JIT_InitClass_Framed, MethodTable* pMT);

FCDECL1(void, JITutil_MonEnter,  Object* obj);
FCDECL2(BOOL, JITutil_MonTryEnter,  Object* obj, __int32 timeOut);
FCDECL2(void, JITutil_MonContention, AwareLock* awarelock, Thread* thread);
FCDECL1(void, JITutil_MonExit,  AwareLock* lock);
FCDECL1(void, JITutil_MonExitThinLock,  Object* obj);
FCDECL1(void, JITutil_MonEnterStatic,  EEClass* pclass);


FCDECL2(Object*, JITutil_ChkCastBizarre, CORINFO_CLASS_HANDLE type, Object *obj);

Object* __fastcall JIT_TrialAllocSFastSP(MethodTable *mt);   // JITinterfaceX86.cpp/JITinterfaceGen.cpp
Object* __fastcall JIT_TrialAllocSFastMP(MethodTable *mt);   // JITinterfaceX86.cpp/JITinterfaceGen.cpp
FCDECL0(VOID, JIT_StressGC);                 // JITinterfaceX86.cpp/JITinterfaceGen.cpp
FCDECL1(Object*, JIT_CheckObj, Object* obj); 
FCDECL0(void, JIT_UserBreakpoint);
Object* __cdecl JIT_NewObj(CORINFO_MODULE_HANDLE scopeHnd, unsigned constrTok, int argN);
BOOL InitJITHelpers1();

extern "C"
{
    void __stdcall JIT_UP_WriteBarrierEBX();        // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_WriteBarrierECX();        // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_WriteBarrierESI();        // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_WriteBarrierEDI();        // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_WriteBarrierEBP();        // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_WriteBarrierEDX();        // JIThelp.asm/JIThelp.s

    void __stdcall JIT_UP_CheckedWriteBarrierEAX(); // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_CheckedWriteBarrierEBX(); // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_CheckedWriteBarrierECX(); // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_CheckedWriteBarrierESI(); // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_CheckedWriteBarrierEDI(); // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_CheckedWriteBarrierEBP(); // JIThelp.asm/JIThelp.s
    void __stdcall JIT_UP_CheckedWriteBarrierEDX(); // JIThelp.asm/JIThelp.s

    void __stdcall JIT_UP_ByRefWriteBarrier();      // JIThelp.asm/JIThelp.s
    void __stdcall JIT_IsInstanceOfClass();         // JIThelp.asm/JITinterfaceAlpha.cpp
    int  __stdcall JIT_IsInstanceOf();              // JITInterfaceX86.cpp, etc.
    void __stdcall JIT_LLsh();                      // JIThelp.asm/JITinterfaceAlpha.cpp
    void __stdcall JIT_LRsh();                      // JIThelp.asm/JITinterfaceAlpha.cpp
    void __stdcall JIT_LRsz();                      // JIThelp.asm/JITinterfaceAlpha.cpp
    int  __stdcall JIT_ChkCastClass();               // JITinterfaceX86.cpp/JITinterfaceAlpha.cpp
    int  __stdcall JIT_ChkCast();                   // JITInterfaceX86.cpp, etc.
    void __stdcall JIT_UP_WriteBarrierReg_PreGrow();// JIThelp.asm/JITinterfaceAlpha.cpp
    void __stdcall JIT_UP_WriteBarrierReg_PostGrow();// JIThelp.asm/JITinterfaceAlpha.cpp
    void __stdcall JIT_TailCall();                  // JIThelp.asm/JITinterfaceAlpha.cpp
}


/*********************************************************************/

inline Module* GetModule(CORINFO_MODULE_HANDLE scope) {
    return((Module*)scope);
}

inline CORINFO_MODULE_HANDLE GetScopeHandle(Module* module) {
    return(CORINFO_MODULE_HANDLE(module));
}

inline CORINFO_MODULE_HANDLE GetScopeHandle(MethodDesc* method) {
    return GetScopeHandle(method->GetModule());
}


inline HRESULT __stdcall CEEJitInfo::alloc (
        ULONG code_len, unsigned char** ppCode,
        ULONG EHinfo_len, unsigned char** ppEHinfo,
        ULONG GCinfo_len, unsigned char** ppGCinfo
        )
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    return m_jitManager->alloc(code_len, ppCode, EHinfo_len, ppEHinfo,
                               GCinfo_len, ppGCinfo, m_FD);
}

/*********************************************************************/

inline static CorInfoType toJitType(CorElementType eeType) {

    static unsigned char map[] = {
        CORINFO_TYPE_UNDEF,
        CORINFO_TYPE_VOID,
        CORINFO_TYPE_BOOL,
        CORINFO_TYPE_CHAR,
        CORINFO_TYPE_BYTE,
        CORINFO_TYPE_UBYTE,
        CORINFO_TYPE_SHORT,
        CORINFO_TYPE_USHORT,
        CORINFO_TYPE_INT,
        CORINFO_TYPE_UINT,
        CORINFO_TYPE_LONG,
        CORINFO_TYPE_ULONG,
        CORINFO_TYPE_FLOAT,
        CORINFO_TYPE_DOUBLE,
        CORINFO_TYPE_STRING,
        CORINFO_TYPE_PTR,            // PTR
        CORINFO_TYPE_BYREF,
        CORINFO_TYPE_VALUECLASS,
        CORINFO_TYPE_CLASS,
        CORINFO_TYPE_CLASS,          // VAR (type variable)
        CORINFO_TYPE_CLASS,          // MDARRAY
        CORINFO_TYPE_BYREF,          // COPYCTOR
        CORINFO_TYPE_REFANY,
        CORINFO_TYPE_VALUECLASS,     // VALUEARRAY
#ifndef _WIN64
        CORINFO_TYPE_INT,            // I
        CORINFO_TYPE_UINT,           // U
#else // !_WIN64
        CORINFO_TYPE_LONG,           // I
        CORINFO_TYPE_ULONG,          // U
#endif // _WIN64
        CORINFO_TYPE_DOUBLE,         // R

        // put the correct type when we know our implementation
        CORINFO_TYPE_PTR,            // FNPTR
        CORINFO_TYPE_CLASS,          // OBJECT
        CORINFO_TYPE_CLASS,          // SZARRAY
        CORINFO_TYPE_CLASS,          // GENERICARRAY
        CORINFO_TYPE_UNDEF,          // CMOD_REQD
        CORINFO_TYPE_UNDEF,          // CMOD_OPT
        CORINFO_TYPE_UNDEF,          // INTERNAL
        };

    _ASSERTE(sizeof(map) == ELEMENT_TYPE_MAX);
    _ASSERTE(eeType < sizeof(map));
        // spot check of the map
    _ASSERTE((CorInfoType) map[ELEMENT_TYPE_I4] == CORINFO_TYPE_INT);
    _ASSERTE((CorInfoType) map[ELEMENT_TYPE_VALUEARRAY] == CORINFO_TYPE_VALUECLASS);
    _ASSERTE((CorInfoType) map[ELEMENT_TYPE_PTR] == CORINFO_TYPE_PTR);
    _ASSERTE((CorInfoType) map[ELEMENT_TYPE_TYPEDBYREF] == CORINFO_TYPE_REFANY);
    _ASSERTE((CorInfoType) map[ELEMENT_TYPE_R] == CORINFO_TYPE_DOUBLE);

    return((CorInfoType) map[eeType]);
}

/*********************************************************************/
static HRESULT ConvToJitSig(PCCOR_SIGNATURE sig, CORINFO_MODULE_HANDLE scopeHnd, mdToken token, CORINFO_SIG_INFO* sigRet, bool localSig=false)
{
    THROWSCOMPLUSEXCEPTION();

    SigPointer ptr(sig);
    _ASSERTE(CORINFO_CALLCONV_DEFAULT == IMAGE_CEE_CS_CALLCONV_DEFAULT);
    _ASSERTE(CORINFO_CALLCONV_VARARG == IMAGE_CEE_CS_CALLCONV_VARARG);
    _ASSERTE(CORINFO_CALLCONV_MASK == IMAGE_CEE_CS_CALLCONV_MASK);
    _ASSERTE(CORINFO_CALLCONV_HASTHIS == IMAGE_CEE_CS_CALLCONV_HASTHIS);

    sigRet->sig = (CORINFO_SIG_HANDLE) sig;
    sigRet->retTypeClass = 0;
    sigRet->retTypeSigClass = 0;
    sigRet->scope = scopeHnd;
    sigRet->token = token;

    if (!localSig) {
        _ASSERTE(sig != 0);
        Module* module = GetModule(scopeHnd);
        sigRet->callConv = (CorInfoCallConv) ptr.GetCallingConvInfo();
        sigRet->numArgs = (unsigned short) ptr.GetData();
        CorElementType type = ptr.PeekElemType();

            // TODO - only do this for VALUETYPE
        if (!CorTypeInfo::IsPrimitiveType(type)) {
            TypeHandle typeHnd;
            OBJECTREF Throwable = NULL;
            GCPROTECT_BEGIN(Throwable);
            typeHnd = ptr.GetTypeHandle(module, &Throwable);
            if (typeHnd.IsNull()) {
                if (Throwable == NULL)
                    COMPlusThrow(kTypeLoadException);
                else
                    COMPlusThrow(Throwable);
            }
            GCPROTECT_END();

            CorElementType normType = typeHnd.GetNormCorElementType();
            // if we are looking up a value class don't morph it to a refernece type 
            // (This can only happen in illegal IL
            if (!CorTypeInfo::IsObjRef(normType))
                type = normType;

                // a null class handle means it is is a primitive.  
                // enums are exactly like primitives, even from a verificaiton standpoint
            sigRet->retTypeSigClass = CORINFO_CLASS_HANDLE(typeHnd.AsPtr());
            if (!typeHnd.IsEnum())
                sigRet->retTypeClass = CORINFO_CLASS_HANDLE(typeHnd.AsPtr());

        }
        sigRet->retType = toJitType(type);

        ptr.Skip();     // must to a skip so we skip any class tokens associated with the return type
        _ASSERTE(sigRet->retType < CORINFO_TYPE_COUNT);

        // I pass a SigPointer as a CORINFO_ARG_LIST_HANDLE and back
        _ASSERTE(sizeof(SigPointer) == sizeof(BYTE*));
        sigRet->args =  *((CORINFO_ARG_LIST_HANDLE*) (&ptr));

        // Force a load of value type arguments.  This is necessary because the
        // JIT doens't ask about argument types before making a call, but
        // the garbage collector will need to have them loaded so that
        // it can walk the stack during collection.
        //
        // @TODO: REMOVE THIS after BETA2 (no later than 5/1/01) it is no longer needed as the JIT
        // walks every call signature, which will force this load.  I am not removing
        // it simply because it has the POSSIBILITY of being destabilizing - vancem
        for(unsigned i=0; i < sigRet->numArgs; i++) {
            unsigned type = ptr.Normalize(module);
            if (type == ELEMENT_TYPE_VALUETYPE) {
                OBJECTREF throwable = NULL;
                GCPROTECT_BEGIN(throwable);

                TypeHandle typeHnd = ptr.GetTypeHandle(module, &throwable);
                if (typeHnd.IsNull()) {
                    _ASSERTE(throwable != NULL);
                    COMPlusThrow(throwable);
                }
                _ASSERTE(typeHnd.GetClass()->IsValueClass());
                GCPROTECT_END();
            }
            ptr.Skip();
        }
        // END part to rip out - vancem 

    } else {
        sigRet->callConv = CORINFO_CALLCONV_DEFAULT;
        sigRet->retType = CORINFO_TYPE_VOID;

        sigRet->numArgs = 0;
        if (sig != 0) {
            BAD_FORMAT_ASSERT(*sig == IMAGE_CEE_CS_CALLCONV_LOCAL_SIG);
            if (*sig != IMAGE_CEE_CS_CALLCONV_LOCAL_SIG)
                COMPlusThrowHR(COR_E_BADIMAGEFORMAT);
            ptr.GetData();
            sigRet->numArgs = (unsigned short) ptr.GetData();
        }

        // I pass a SigPointer as a CORINFO_ARG_LIST_HANDLE and back
        _ASSERTE(sizeof(SigPointer) == sizeof(BYTE*));
        sigRet->args =  *((CORINFO_ARG_LIST_HANDLE*) (&ptr));
    }

    return S_OK;
}

/*********************************************************************/
CORINFO_GENERIC_HANDLE __stdcall CEEInfo::findToken (
            CORINFO_MODULE_HANDLE  scopeHnd,
            unsigned      metaTOK,
            CORINFO_METHOD_HANDLE context,
            CORINFO_CLASS_HANDLE& tokenType     // field, method, etc. 
            )
{
    REQUIRES_4K_STACK;
    CORINFO_GENERIC_HANDLE ret;

    COOPERATIVE_TRANSITION_BEGIN();

    THROWSCOMPLUSEXCEPTION();

    mdToken     tokType = TypeFromToken(metaTOK);
    InitStaticTypeHandles();

    switch (tokType)
    {
    case mdtTypeRef:
    case mdtTypeDef:
    case mdtTypeSpec:
        ret = CORINFO_GENERIC_HANDLE(findClass(scopeHnd, metaTOK, context));
        tokenType = CORINFO_CLASS_HANDLE(s_th_System_RuntimeTypeHandle.AsPtr());
        break;

    case mdtMemberRef:
        {
            // OK, we have to look at the metadata to see if it's a field or method

            Module *pModule = (Module*)scopeHnd;

            PCCOR_SIGNATURE pSig;
            ULONG cSig;
            pModule->GetMDImport()->GetNameAndSigOfMemberRef(metaTOK, &pSig, &cSig);

        if (isCallConv(MetaSig::GetCallingConventionInfo(pModule, pSig), IMAGE_CEE_CS_CALLCONV_FIELD))
            {
                ret = CORINFO_GENERIC_HANDLE(findField(scopeHnd, metaTOK, context));
                tokenType = CORINFO_CLASS_HANDLE(s_th_System_RuntimeFieldHandle.AsPtr());
            }
            else
            {
                ret = CORINFO_GENERIC_HANDLE(findMethod(scopeHnd, metaTOK, context));
                tokenType = CORINFO_CLASS_HANDLE(s_th_System_RuntimeMethodHandle.AsPtr());
            }
        }
        break;

    case mdtMethodDef:
        ret = CORINFO_GENERIC_HANDLE(findMethod(scopeHnd, metaTOK, context));
        tokenType = CORINFO_CLASS_HANDLE(s_th_System_RuntimeMethodHandle.AsPtr());
        break;

    case mdtFieldDef:
        ret = CORINFO_GENERIC_HANDLE(findField(scopeHnd, metaTOK, context));
        tokenType = CORINFO_CLASS_HANDLE(s_th_System_RuntimeFieldHandle.AsPtr());
        break;

    default:
        BAD_FORMAT_ASSERT(!"Error, bad token type");
        COMPlusThrowHR(COR_E_BADIMAGEFORMAT);
    }

    COOPERATIVE_TRANSITION_END();
    return ret;
}
/*********************************************************************/
const char * __stdcall CEEInfo::findNameOfToken (
            CORINFO_MODULE_HANDLE       scopeHnd,
            mdToken                     metaTOK)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();  

    Module* module = GetModule(scopeHnd);
    return findNameOfToken(module, metaTOK);
}
/*********************************************************************/

BOOL __stdcall CEEInfo::canSkipVerification(CORINFO_MODULE_HANDLE moduleHnd, BOOL fQuickCheckOnly)
{
    BOOL canSkipVerif;
    COOPERATIVE_TRANSITION_BEGIN();

    THROWSCOMPLUSEXCEPTION();

    //
    // fQuickCheckOnly is set only by calls from Zapper::CompileAssembly
    // is because that allows us make a determination for the most
    // common full trust scenarios (local machine) without actually
    // resolving policy and bringing in a whole list of assembly
    // dependencies.  Also, quick checks don't call
    // OnLinktimeCanSkipVerificationCheck which means we don't add
    // permission sets to the persisted ngen module.
    //
    // The scenario of interest here is determing whether or not an
    // assembly MVID comparison is enough when loading an NGEN'd
    // assembly or if a full binary hash comparison must be done.
    //

    if (fQuickCheckOnly)
        canSkipVerif = Security::QuickCanSkipVerification(GetModule(moduleHnd));
    else
        canSkipVerif = Security::CanSkipVerification(GetModule(moduleHnd)->GetAssembly());

    COOPERATIVE_TRANSITION_END();
    return canSkipVerif;
}

/*********************************************************************/
// Checks if the given metadata token is valid
BOOL __stdcall CEEInfo::isValidToken (
        CORINFO_MODULE_HANDLE       module,
        mdToken                     metaTOK)
{
    return (GetModule(module))->GetMDImport()->IsValidToken(metaTOK);
}

/*********************************************************************/
// Checks if the given metadata token is valid StringRef
BOOL __stdcall CEEInfo::isValidStringRef (
        CORINFO_MODULE_HANDLE       module,
        mdToken                     metaTOK)
{
    return (GetModule(module))->IsValidStringRef(metaTOK);
}

/* static */
const char * __stdcall CEEInfo::findNameOfToken (Module* module,
                                                 mdToken metaTOK)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();  

    PCCOR_SIGNATURE sig = NULL;
    DWORD           cSig;

    mdToken tokType = TypeFromToken(metaTOK);
    if (tokType == mdtMemberRef)
        return (char *) module->GetMDImport()->GetNameAndSigOfMemberRef((mdMemberRef)metaTOK, &sig, &cSig);
    else if (tokType == mdtMethodDef)
        return (char*) module->GetMDImport()->GetNameOfMethodDef(metaTOK);

#ifdef _DEBUG
        static char buff[64];
        sprintf(buff, "Meta Token %#x", metaTOK);
    return buff;
#else // !_DEBUG
    return "<UNKNOWN>";
#endif // _DEBUG
}

/*********************************************************************/
CORINFO_CLASS_HANDLE __stdcall CEEInfo::findClass (
            CORINFO_MODULE_HANDLE  scopeHnd,
            unsigned      metaTOK,
            CORINFO_METHOD_HANDLE context)
{
    REQUIRES_4K_STACK;
    CORINFO_CLASS_HANDLE ret;

    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();

    if (TypeFromToken(metaTOK) != mdtTypeDef && 
        TypeFromToken(metaTOK) != mdtTypeRef &&
        TypeFromToken(metaTOK) != mdtTypeSpec)
    {
        BAD_FORMAT_ASSERT(!"Error, bad class token");
        COMPlusThrowHR(COR_E_BADIMAGEFORMAT);
    }

    Module* module = GetModule(scopeHnd);

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
    NameHandle name(module, metaTOK);
    TypeHandle clsHnd = module->GetClassLoader()->LoadTypeHandle(&name, &throwable);

    ret = CORINFO_CLASS_HANDLE(clsHnd.AsPtr());

        // make certain m_BaseSize is aligned properly
    _ASSERTE(clsHnd.IsNull() || !clsHnd.IsUnsharedMT() || clsHnd.GetMethodTable()->GetBaseSize() % sizeof(void*) == 0);

        // @todo: Need to do something with throwable
#ifdef JIT_LINKTIME_SECURITY

    // @todo :
    // The caller of this function needs to get the exception object and
    // inline a throw in the jitted code in place of the call.
    // Throwing here is temporary and need to be removed.

    // @Todo : Is it safe to throw from here ?
    if (throwable != NULL)
        COMPlusThrow(throwable);

#endif // JIT_LINKTIME_SECURITY
    GCPROTECT_END();
    COOPERATIVE_TRANSITION_END();
    return ret;
}

/*********************************************************************/
CORINFO_FIELD_HANDLE __stdcall CEEInfo::findField (
            CORINFO_MODULE_HANDLE  scopeHnd,
            unsigned      metaTOK,
            CORINFO_METHOD_HANDLE  context
                        )
{
    REQUIRES_4K_STACK;

    FieldDesc* fieldDesc = 0;

    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();

    if (TypeFromToken(metaTOK) != mdtFieldDef && 
        TypeFromToken(metaTOK) != mdtMemberRef)
    {
        BAD_FORMAT_ASSERT(!"Error, bad field token");
        COMPlusThrowHR(COR_E_BADIMAGEFORMAT);
    }

    Module* module = GetModule(scopeHnd);
    MethodDesc* method = (MethodDesc*) context;

    START_NON_JIT_PERF();
    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
    HRESULT res = EEClass::GetFieldDescFromMemberRef(module, (mdMemberRef) metaTOK, &fieldDesc, &throwable);

    if (SUCCEEDED(res))
    {
        if (method != NULL)
        {
            // Check private/protected etc. access
            if (ClassLoader::CanAccessField(method,
                                            fieldDesc) == FALSE)
            {
                CreateFieldExceptionObject(kFieldAccessException, fieldDesc, &throwable);
                fieldDesc = NULL;
                goto exit;
            }

        }
    }

exit:
    STOP_NON_JIT_PERF();

        // @todo: Need to do something with throwable
#ifdef JIT_LINKTIME_SECURITY

    // @todo :
    // The caller of this function needs to get the exception object and
    // inline a throw in the jitted code in place of the call.
    // Throwing here is temporary and need to be removed.

    // @Todo : Is it safe to throw from here ?
    if (throwable != NULL && fieldDesc == NULL)
        COMPlusThrow(throwable);

#endif // JIT_LINKTIME_SECURITY

    GCPROTECT_END();
    COOPERATIVE_TRANSITION_END();
    return(CORINFO_FIELD_HANDLE(fieldDesc));
}

/*********************************************************************/
void* __stdcall CEEInfo::findPtr(CORINFO_MODULE_HANDLE  scopeHnd, unsigned ptrTOK)
{
    // TODO NOW remove this.  it is not used. 
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    Module* module = GetModule(scopeHnd);
    return module->ResolveILRVA(ptrTOK, FALSE);
}

CORINFO_METHOD_HANDLE __stdcall CEEInfo::findMethod(CORINFO_MODULE_HANDLE  scopeHnd, unsigned metaTOK, CORINFO_METHOD_HANDLE context)
{
    REQUIRES_8K_STACK;

    MethodDesc* funcDesc = 0;
    HRESULT res = S_OK;

    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();     

    if (TypeFromToken(metaTOK) != mdtMethodDef && 
        TypeFromToken(metaTOK) != mdtMemberRef)
    {
        BAD_FORMAT_ASSERT(!"Error, bad method token");
        COMPlusThrowHR(COR_E_BADIMAGEFORMAT);
    }

    Module* module = GetModule(scopeHnd);
    MethodDesc* method = (MethodDesc*)context;


    START_NON_JIT_PERF();

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
    res = EEClass::GetMethodDescFromMemberRef(module, (mdMemberRef) metaTOK,(MethodDesc **) &funcDesc, &throwable);
    if (SUCCEEDED(res))
    {
        if (method != NULL)
        {
            if (ClassLoader::CanAccessMethod(method,
                                             funcDesc) == FALSE)
            {
#ifdef _DEBUG
                if(method && funcDesc) {
                    LOG((LF_CLASSLOADER,
                         LL_INFO10,
                         "\tERROR: Method %s:%s does not have access to %s:%s\n",
                         method->m_pszDebugClassName,
                         method->m_pszDebugMethodName,
                         funcDesc->m_pszDebugClassName,
                         funcDesc->m_pszDebugMethodName));
                }
#endif


                CreateMethodExceptionObject(kMethodAccessException, funcDesc, &throwable);
                funcDesc = NULL;
                goto exit;
            }

#ifdef JIT_LINKTIME_SECURITY
            if (funcDesc->RequiresLinktimeCheck() &&
                (Security::LinktimeCheckMethod(method->GetAssembly(), funcDesc, &throwable) == FALSE))
            {
                _ASSERTE(Security::IsSecurityOn());
                //@TODO: Ideally, we'd like to insert code at this field/method
                //@TODO: access point that throws a security exception. This
                //@TODO: mechanism is not yet in place.

                funcDesc = NULL;
                goto exit;
            }
#endif // JIT_LINKTIME_SECURITY
        }
        // we can ignore the result, if it fails, methodDesc == 0
        goto exit;
    }
    else
    {


// This code is currently busted because of the call to GetNameOfTypeRef that assumes that
// the parent token is a typeref. I am leaving it here because it will probably be usefull
// in setting up the throwable latter on.
#if 0
#ifdef _DEBUG

        /* If we could not resolve the method token,
           try to dump the name of the class and method if JitRequired */

        if (g_pConfig->IsJitRequired())
        {
            LPCUTF8     szMethodName = "", szNamespace = "", szClassName = "";
            HRESULT     hr;
            PCCOR_SIGNATURE sig = NULL;
            DWORD           cSig;
            mdToken ptkParent;
            mdToken tk  = TypeFromToken(metaTOK);

            if (tk == mdtMemberRef)
            {
                szMethodName = module->GetMDImport()->GetNameAndSigOfMemberRef((mdMemberRef)metaTOK, &sig, &cSig);
                ptkParent = module->GetMDImport()->GetParentOfMemberRef(metaTOK);
                module->GetMDImport()->GetNameOfTypeRef(ptkParent, &szNamespace, &szClassName);
            }
            else
            {
                szMethodName = module->GetMDImport()->GetNameOfMethodDef((mdMethodDef)metaTOK);
                hr = module->GetMDImport()->GetParentToken(metaTOK,&ptkParent);
                if (FAILED(hr))
                {
                    funcDesc = NULL;
                    goto exit;
                }
                module->GetMDImport()->GetNameOfTypeDef(ptkParent,&szClassName, &szNamespace);
            }

            printf("Could not find '%s.%s::%s'. Please make sure that "
                   "all required DLLs are available in %%CORPATH%%.\n",
                   szNamespace, szClassName, szMethodName);
        }
#endif _DEBUG
#endif
    }
exit:
    STOP_NON_JIT_PERF();

    // @todo: Need to do something with throwable

#ifdef JIT_LINKTIME_SECURITY

    // @todo :
    // The caller of this function needs to get the exception object and
    // inline a throw in the jitted code in place of the call.
    // Throwing here is temporary and need to be removed.

    // @Todo : Is it safe to throw from here ?
    if (throwable != NULL && funcDesc == NULL)
        COMPlusThrow(throwable);

#endif // JIT_LINKTIME_SECURITY


    GCPROTECT_END();
    COOPERATIVE_TRANSITION_END();
    return CORINFO_METHOD_HANDLE(funcDesc);
}

/*********************************************************************/
void __stdcall CEEInfo::findCallSiteSig (
        CORINFO_MODULE_HANDLE       scopeHnd,
        unsigned                    sigMethTok,
        CORINFO_SIG_INFO *          sigRet)
{
    REQUIRES_4K_STACK;

    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();

    Module* module = GetModule(scopeHnd);
    LPCUTF8         szName;
    PCCOR_SIGNATURE sig = NULL;
    DWORD           cSig;

    if (TypeFromToken(sigMethTok) == mdtMemberRef)
    {
        szName = module->GetMDImport()->GetNameAndSigOfMemberRef(sigMethTok, &sig, &cSig);

        // Defs have already been checked by the loader for validity
        // However refs need to be checked.
        if (!Security::LazyCanSkipVerification(module)) 
        {
            // Can pass 0 for the flags, since it is only used for defs.  
            HRESULT hr = validateTokenSig(sigMethTok, sig, cSig, 0, module->GetMDImport());
            if (FAILED(hr) && !Security::CanSkipVerification(module))
                COMPlusThrow(kInvalidProgramException);
        }
    }
    else if (TypeFromToken(sigMethTok) == mdtMethodDef)
    {
        sig = module->GetMDImport()->GetSigOfMethodDef(sigMethTok, &cSig);

    }



    HRESULT hr = ConvToJitSig(sig, scopeHnd, sigMethTok, sigRet);
    _ASSERTE(SUCCEEDED(hr));

    COOPERATIVE_TRANSITION_END();
}

/*********************************************************************/
void __stdcall CEEInfo::findSig (
        CORINFO_MODULE_HANDLE        scopeHnd,
        unsigned            sigTok,
                CORINFO_SIG_INFO *      sigRet)
{
    REQUIRES_4K_STACK;

    COOPERATIVE_TRANSITION_BEGIN();

    START_NON_JIT_PERF();

    Module* module = GetModule(scopeHnd);
    PCCOR_SIGNATURE sig = NULL;
    DWORD cSig = 0;

    // We need to resolve this stand alone sig
    sig = module->GetMDImport()->GetSigFromToken((mdSignature)sigTok,
                                                &cSig);
    STOP_NON_JIT_PERF();
    HRESULT hr = ConvToJitSig(sig, scopeHnd, sigTok, sigRet);
    _ASSERTE(SUCCEEDED(hr));
    COOPERATIVE_TRANSITION_END();
}

/*********************************************************************/
DWORD __stdcall CEEInfo::getModuleAttribs (CORINFO_MODULE_HANDLE scopeHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    return(0);      // @todo, we need a  'TRUSTED' flag!
}

/*********************************************************************/
unsigned __stdcall CEEInfo::getClassSize (CORINFO_CLASS_HANDLE clsHnd)
{
    REQUIRES_4K_STACK;

    unsigned ret;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (isValueArray(clsHnd)) {
        ValueArrayDescr* valArr = asValueArray(clsHnd);
        ret = valArr->sig.SizeOf(valArr->module);
    } else {
        TypeHandle VMClsHnd(clsHnd);
        ret = VMClsHnd.GetSize();
    }
    return ret;
}

/*********************************************************************/
unsigned __stdcall CEEInfo::getClassGClayout (CORINFO_CLASS_HANDLE clsHnd, BYTE* gcPtrs)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();
    unsigned ret;

    if (isValueArray(clsHnd)) {
        ValueArrayDescr* valArr = asValueArray(clsHnd);

        SigPointer elemType;
        ULONG count;
        valArr->sig.GetSDArrayElementProps(&elemType, &count);
        CorElementType type = elemType.PeekElemType();

        switch(GetElementTypeInfo(type)->m_gc) {
            case TYPE_GC_NONE: {
                unsigned numSlots = (elemType.SizeOf(valArr->module) * count + sizeof(void*)-1) / sizeof(void*);
                memset(gcPtrs, TYPE_GC_NONE, numSlots);
                ret = 0;
                }
                break;
            case TYPE_GC_REF:
                memset(gcPtrs, TYPE_GC_REF, count);
                ret = count;
                break;
            case TYPE_GC_OTHER:
                // This has bit rotted, but we currently don't use it, so it may not be worth fixing
#if 0
                {
                unsigned elemSize = elemType.SizeOf(valArr->module);
                _ASSERTE(elemSize % sizeof(void*) == 0);
                unsigned numSlots = elemSize / sizeof(void*);

                CORINFO_CLASS_HANDLE elemCls = getArgClass(GetScopeHandle(valArr->module), *((CORINFO_ARG_LIST_HANDLE*) &elemType));
                ret = getClassGClayout(elemCls, gcPtrs) * count;
                for(unsigned i = 0; i < count; i++)
                    memcpy(gcPtrs, &gcPtrs[i*numSlots], numSlots);
                }
                break;
#endif
            case TYPE_GC_BYREF:
            default:
                _ASSERTE(!"ILLEGAL");
                ret = 0;
                break;
        }
    } else {
        TypeHandle VMClsHnd(clsHnd);

        if (g_Mscorlib.IsClass(VMClsHnd.AsMethodTable(), CLASS__TYPED_REFERENCE))
        {
            gcPtrs[0] = TYPE_GC_BYREF;
            gcPtrs[1] = TYPE_GC_NONE;
            ret = 1;
        }
        else
        {
            EEClass* cls = VMClsHnd.GetClass();

            // Sanity test for class
            _ASSERTE(cls);
            _ASSERTE(cls->GetMethodTable()->GetClass() == cls);
            _ASSERTE(cls->IsValueClass());
            _ASSERTE(sizeof(BYTE) == 1);
            
            // assume no GC pointers at first
            ret = 0;
            memset(gcPtrs, TYPE_GC_NONE, 
                   (VMClsHnd.GetSize() + sizeof(void*) -1)/ sizeof(void*));

            // walk the GC descriptors, turning on the correct bits
            MethodTable *   pByValueMT = cls->GetMethodTable();
            if (cls->GetNumGCPointerSeries() > 0)
            {
                CGCDescSeries * pByValueSeries = ((CGCDesc*) pByValueMT)->GetLowestSeries();
                for (int i = 0; i < cls->GetNumGCPointerSeries(); i++)
                {
                    // Get offset into the value class of the first pointer field (includes a +Object)
                    DWORD dwSeriesSize = pByValueSeries->GetSeriesSize() + pByValueMT->GetBaseSize();
                    DWORD dwOffset = pByValueSeries->GetSeriesOffset() - sizeof(Object);
                    _ASSERTE (dwOffset % sizeof(void*) == 0);
                    _ASSERTE (dwSeriesSize % sizeof(void*) == 0);
                    
                    ret += dwSeriesSize / sizeof(void*);
                    memset(&gcPtrs[dwOffset/sizeof(void*)], TYPE_GC_REF, dwSeriesSize / sizeof(void*));
                    pByValueSeries++;
                }
            }
        }
    }
    STOP_NON_JIT_PERF();
    return(ret);
}
/*********************************************************************/
const unsigned __stdcall CEEInfo::getClassNumInstanceFields (CORINFO_CLASS_HANDLE clsHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    TypeHandle VMClsHnd(clsHnd);
    EEClass* cls = VMClsHnd.GetClass();
    _ASSERTE(cls);
    return cls->GetNumInstanceFields();

}

/*********************************************************************/
// Turn the given fieldDsc into a FieldNum
const unsigned __stdcall CEEInfo::getFieldNumber(CORINFO_FIELD_HANDLE fldHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    FieldDesc* fldDsc = (FieldDesc*) fldHnd;
    EEClass *   cls = fldDsc->GetEnclosingClass();
    DWORD       fldNum = 0;

    FieldDescIterator fdIterator(cls, FieldDescIterator::ALL_FIELDS);
    FieldDesc* pFD;

    while ((pFD = fdIterator.Next()) != NULL)
    {
        if (pFD == fldDsc)
            return (long) fldNum;

        if (pFD->IsStatic() == FALSE)
            fldNum++;
    }

    return -1;
}

/*********************************************************************/
// return the enclosing class of the field
CORINFO_CLASS_HANDLE __stdcall CEEInfo::getEnclosingClass (
                    CORINFO_FIELD_HANDLE    field )
{
    return ((CORINFO_CLASS_HANDLE) TypeHandle(((FieldDesc*)field)->GetEnclosingClass()->GetMethodTable()).AsPtr());
}

/*********************************************************************/
// Check Visibility rules.
// For Protected (family access) members, type of the instance is also
// considered when checking visibility rules.
BOOL __stdcall CEEInfo::canAccessField(
                    CORINFO_METHOD_HANDLE   context,
                    CORINFO_FIELD_HANDLE    target,
                    CORINFO_CLASS_HANDLE    instance)
{
    FieldDesc *pFD =  (FieldDesc*) target;
    EEClass   *pCls = pFD->GetEnclosingClass();

    return ClassLoader::CanAccess(
            ((MethodDesc*)context)->GetClass(),
            ((MethodDesc*)context)->GetModule()->GetAssembly(),
            pCls,
            pCls->GetAssembly(),
            TypeHandle(instance).GetClass(),
            pFD->GetAttributes());
}

/*********************************************************************/
/* get the class for the single dimentional array of 'clsHnd' elements */

CORINFO_CLASS_HANDLE __stdcall CEEInfo::getSDArrayForClass(CORINFO_CLASS_HANDLE clsHnd)
{
    REQUIRES_12K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    TypeHandle elemType(clsHnd);
    // TODO if we fail to load, report back why
    TypeHandle ret = elemType.GetModule()->GetClassLoader()->FindArrayForElem(elemType, ELEMENT_TYPE_SZARRAY);
    return((CORINFO_CLASS_HANDLE) ret.AsPtr());
}

/*********************************************************************/
CorInfoType __stdcall CEEInfo::asCorInfoType (CORINFO_CLASS_HANDLE clsHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    TypeHandle VMClsHnd(clsHnd);
    return toJitType(VMClsHnd.GetNormCorElementType());
}

/*********************************************************************/
const char* __stdcall CEEInfo::getClassName (CORINFO_CLASS_HANDLE clsHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(!isValueArray(clsHnd));
    TypeHandle VMClsHnd(clsHnd);
    EEClass* cls = VMClsHnd.GetClass();

        // Sanity test for class
    _ASSERTE(cls);
    _ASSERTE(cls->GetMethodTable()->GetClass() == cls);

#ifdef _DEBUG
    cls->_GetFullyQualifiedNameForClass(clsNameBuff, MAX_CLASSNAME_LENGTH);
    return(clsNameBuff);
#else 
    // since this is for diagnostic purposes only,
    // give up on the namespace, as we don't have a buffer to concat it
    // also note this won't show array class names.
    LPCUTF8 nameSpace;
    return cls-> GetFullyQualifiedNameInfo(&nameSpace);
#endif
}

/*********************************************************************/
CORINFO_MODULE_HANDLE __stdcall CEEInfo::getClassModule(CORINFO_CLASS_HANDLE clsHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    TypeHandle     VMClsHnd(clsHnd);

    return(CORINFO_MODULE_HANDLE(VMClsHnd.GetModule()));
}

/*********************************************************************/
DWORD __stdcall CEEInfo::getClassAttribs (CORINFO_CLASS_HANDLE clsHnd, CORINFO_METHOD_HANDLE context)
{
    REQUIRES_4K_STACK;

    // @todo FIX need to really fetch the class atributes.  at present
    // we don't need to because the JIT only cares in the case of COM classes
    DWORD ret =0;
    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();

    _ASSERTE(clsHnd);
    _ASSERTE(!isValueArray(clsHnd));

    TypeHandle     VMClsHnd(clsHnd);
    MethodTable    *pMT = VMClsHnd.GetMethodTable();
    EEClass        *cls = pMT->GetClass();
    _ASSERTE(cls->GetMethodTable()->GetClass() == cls);

    // Get the calling method
    MethodDesc* method = (MethodDesc*) context;

    if (pMT->IsArray())
        ret |= CORINFO_FLG_ARRAY;

    // Set the INITIALIZED bit if the class is initialized 
    if (pMT->IsClassInited())
        ret |= CORINFO_FLG_INITIALIZED;
    else if (pMT->IsShared() && !method->GetMethodTable()->IsShared())
    {
        // If we are accessing from unshared to shared code, we can check the
        // state of the current domain as well.

        COMPLUS_TRY 
          {
              DomainLocalBlock *pBlock = GetAppDomain()->GetDomainLocalBlock();
              if (pBlock->IsClassInitialized(pMT->GetSharedClassIndex()))
                  ret |= CORINFO_FLG_INITIALIZED;
          }
        COMPLUS_CATCH
          {
              // just eat the exception and assume class not inited
          }
        COMPLUS_END_CATCH;
    }

    // Set the NEEDS_INIT bit if we require the JIT to insert cctor logic before
    // access.  This is currently used only for static field accesses and method inlining.
    // Note that this is set independently of the INITIALIZED bit above.

    if (pMT != method->GetMethodTable())
    {
        if (pMT->IsShared())
        {
            // For shared classes, the inited bit is only set when we never need
            // class initialzation (no cctor or static handles)

            if (!pMT->IsClassInited())
            {
                // 
                // For the shared->shared access, it turns out we never have to do any initialization
                // in this case.  There are 2 cases:
                // 
                // BeforeFieldInit: in this case, no init is required on method calls, and 
                //  the shared helper will perform the required init on static field accesses.
                // Exact:  in this case we do need an init on method calls, but this will be
                //  provided by a prolog of the method itself.

                if (!method->GetMethodTable()->IsShared())
                {
                    // Unshared->shared access.  The difference in this case (from above) is 
                    // that we don't use the shared helper.  Thus we need the JIT to provide
                    // a class construction call.  

                    ret |= CORINFO_FLG_NEEDS_INIT;
                }
            }
        }
        else
        {
            // For accesses to unshared classes (which are by necessity from other unshared classes),
            // we need initialization iff we have a class constructor.

            if (pMT->HasClassConstructor())
                ret |= CORINFO_FLG_NEEDS_INIT;
        }
    }

    if (cls->IsInterface())
        ret |= CORINFO_FLG_INTERFACE;

    if (cls->HasVarSizedInstances())
        ret |= CORINFO_FLG_VAROBJSIZE;

    if (cls->IsValueClass()) 
    {
        ret |= CORINFO_FLG_VALUECLASS;

        if (cls->ContainsStackPtr())
            ret |= CORINFO_FLG_CONTAINS_STACK_PTR;
    }

    if (cls->IsContextful())
        ret |= CORINFO_FLG_CONTEXTFUL;

    if (cls->IsMarshaledByRef())
        ret |= CORINFO_FLG_MARSHAL_BYREF;

    if (cls == g_pObjectClass->GetClass())
        ret |= CORINFO_FLG_OBJECT;

    if (pMT->ContainsPointers())
        ret |= CORINFO_FLG_CONTAINS_GC_PTR;

    if (cls->IsAnyDelegateClass())
        ret |= CORINFO_FLG_DELEGATE;

    if (cls->IsSealed())
    {
        ret |= CORINFO_FLG_FINAL;
    }

    STOP_NON_JIT_PERF();

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return(ret);
}

/*********************************************************************/
BOOL __stdcall CEEInfo::initClass (CORINFO_CLASS_HANDLE clsHnd,
                                   CORINFO_METHOD_HANDLE context,
                                   BOOL speculative)
{
    REQUIRES_4K_STACK;


    MethodTable    *pMT = TypeHandle(clsHnd).GetMethodTable();
    MethodDesc *method = (MethodDesc*) context;

    BOOL result = FALSE;

    // Eagerly run the .cctor for the classes that are not value classes and
    // that have the BeforeFieldInit bit set.  (But don't run it if the 
    // caller is shared as it cannot help in the general case.)
    // 
    // @todo: remove the special case for system assembly when compilers and our 
    // code use BeforeFieldInit properly
    //
    // @todo: there is a potential problem here.  We don't know why the jitter
    // is requesting us to run class init - we just run it when asked. We assume
    // the jit has the correct logic to only call us when necessary.
    //
    // In the future, this routine should decide situationally as well as 
    // whether it's legal to run the constructor.  (But to do that, we need
    // to know what field or method we are accessing, not just the class.)

    if (!method->GetClass()->IsShared() && 
        (IsTdBeforeFieldInit(pMT->GetClass()->GetAttrClass())
         || pMT->GetModule()->GetAssembly() == SystemDomain::SystemAssembly()))
    {
        COOPERATIVE_TRANSITION_BEGIN();
        THROWSCOMPLUSEXCEPTION();

        result = TRUE;

        if (!speculative)
        {
            //
            // Run the .cctor
            //

            OBJECTREF throwable = NULL;
            GCPROTECT_BEGIN(throwable);
            if (!pMT->CheckRunClassInit(&throwable))
            {
                // Return FALSE, so the JIT will embed the check and get the
                // exception at execution time.
                result = FALSE;
            }
            GCPROTECT_END();

            // 
            // If we encountered a deadlock while running the class init, our method
            // may have already been jitted by now. If this is true, abort the jit
            // by throwing an exception. (Note that we are relying on the JIT catching
            // and handling this exception, so it doesn't really need a message.)
            //

            if (method->IsJitted())
                COMPlusThrow(kSynchronizationLockException);
        }
            
        COOPERATIVE_TRANSITION_END();
    }

    return result;
}

BOOL __stdcall CEEInfo::loadClass (CORINFO_CLASS_HANDLE clsHnd,
                                   CORINFO_METHOD_HANDLE context,
                                   BOOL speculative)
{
    REQUIRES_4K_STACK;

    MethodTable    *pMT = TypeHandle(clsHnd).GetMethodTable();

    //
    // It is always safe to restore a class at jit time, as it happens 
    // once per process and has no interesting side effects.
    //

    if (!speculative)
        pMT->CheckRestore();

    return TRUE;
}

/*********************************************************************/
CORINFO_CLASS_HANDLE __stdcall CEEInfo::getBuiltinClass(CorInfoClassId classId)
{
    CORINFO_CLASS_HANDLE result = (CORINFO_CLASS_HANDLE) 0;

    COOPERATIVE_TRANSITION_BEGIN();


    switch (classId)
    {
    case CLASSID_SYSTEM_OBJECT:
        result = (CORINFO_CLASS_HANDLE) g_pObjectClass;
        break;
    case CLASSID_TYPED_BYREF:
        InitStaticTypeHandles();
        result = CORINFO_CLASS_HANDLE(s_th_System_TypedReference.AsPtr());
        break;
    case CLASSID_TYPE_HANDLE:
        InitStaticTypeHandles();
        result = CORINFO_CLASS_HANDLE(s_th_System_RuntimeTypeHandle.AsPtr());
        break;
    case CLASSID_FIELD_HANDLE:
        InitStaticTypeHandles();
        result = CORINFO_CLASS_HANDLE(s_th_System_RuntimeFieldHandle.AsPtr());
        break;
    case CLASSID_METHOD_HANDLE:
        InitStaticTypeHandles();
        result = CORINFO_CLASS_HANDLE(s_th_System_RuntimeMethodHandle.AsPtr());
        break;
    case CLASSID_ARGUMENT_HANDLE:
        InitStaticTypeHandles();
        result = CORINFO_CLASS_HANDLE(s_th_System_RuntimeArgumentHandle.AsPtr());
        break;
    case CLASSID_STRING:
        result = (CORINFO_CLASS_HANDLE) g_pStringClass;
        break;
    default:
        _ASSERTE(!"NYI: unknown classId");
        break;
    }

    COOPERATIVE_TRANSITION_END();

    return result;
}

/*********************************************************************/
CorInfoType __stdcall CEEInfo::getTypeForPrimitiveValueClass(
        CORINFO_CLASS_HANDLE cls)
{
    TypeHandle th(cls);

    CorInfoType result = CORINFO_TYPE_UNDEF;

    COOPERATIVE_TRANSITION_BEGIN();

    switch (th.GetNormCorElementType())
    {
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        result = toJitType(ELEMENT_TYPE_I1);
        break;

    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        result = toJitType(ELEMENT_TYPE_I2);
        break;

    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
        result = toJitType(ELEMENT_TYPE_I4);
        break;

    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
        result = toJitType(ELEMENT_TYPE_I8);
        break;

    case ELEMENT_TYPE_I:

        // RuntimeTypeHandle, RuntimeMethodHandle, RuntimeArgHandle etc
        // Are disguised as ELEMENT_TYPE_I. Catch it here.
        InitStaticTypeHandles();

        if ((th == s_th_System_RuntimeTypeHandle) ||
            (th == s_th_System_RuntimeFieldHandle) ||
            (th == s_th_System_RuntimeMethodHandle) ||
            (th == s_th_System_RuntimeArgumentHandle))
        {
            result = CORINFO_TYPE_UNDEF;
            break;
        }

        // FALL THROUGH

    case ELEMENT_TYPE_U:
        result = toJitType(ELEMENT_TYPE_I);
        break;

    case ELEMENT_TYPE_R4:
        result = toJitType(ELEMENT_TYPE_R4);
        break;

    case ELEMENT_TYPE_R:
    case ELEMENT_TYPE_R8:
        result = toJitType(ELEMENT_TYPE_R8);
        break;

    case ELEMENT_TYPE_VOID:
        result = toJitType(ELEMENT_TYPE_VOID);
        break;
    }

    COOPERATIVE_TRANSITION_END();

    return result;
}

/*********************************************************************/
// TRUE if child is a subtype of parent
// if parent is an interface, then does child implement / extend parent
BOOL __stdcall CEEInfo::canCast(
        CORINFO_CLASS_HANDLE        child, 
        CORINFO_CLASS_HANDLE        parent)
{
    return ((TypeHandle)child).CanCastTo((TypeHandle)parent);
}

/*********************************************************************/
// returns is the intersection of cls1 and cls2.
CORINFO_CLASS_HANDLE __stdcall CEEInfo::mergeClasses(
        CORINFO_CLASS_HANDLE        cls1, 
        CORINFO_CLASS_HANDLE        cls2)
{
    return CORINFO_CLASS_HANDLE(TypeHandle::MergeTypeHandlesToCommonParent(
            TypeHandle(cls1), TypeHandle(cls2)).AsPtr());
}

/*********************************************************************/
// Given a class handle, returns the Parent type.
// For COMObjectType, it returns Class Handle of System.Object.
// Returns 0 if System.Object is passed in.
CORINFO_CLASS_HANDLE __stdcall CEEInfo::getParentType(
            CORINFO_CLASS_HANDLE    cls)
{
    _ASSERTE(!isValueArray(cls));

    TypeHandle th(cls);

    _ASSERTE(!th.IsNull());

    // Return System.Object for ComObject Types. This type hiearchy is
    // introduced by the EE, but won't be present in the metadata.
    if (th.GetMethodTable()->IsComObjectType())
    {
        return (CORINFO_CLASS_HANDLE) g_pObjectClass;
    }

    return CORINFO_CLASS_HANDLE(th.GetParent().AsPtr());
}


/*********************************************************************/
// Returns the CorInfoType of the "child type". If the child type is
// not a primitive type, *clsRet will be set.
// Given an Array of Type Foo, returns Foo.
// Given BYREF Foo, returns Foo
CorInfoType __stdcall CEEInfo::getChildType (
        CORINFO_CLASS_HANDLE       clsHnd,
        CORINFO_CLASS_HANDLE       *clsRet
        )
{

    REQUIRES_16K_STACK;

    CorInfoType ret = CORINFO_TYPE_UNDEF;
    *clsRet = 0;
    TypeHandle  retType;

    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);

    BOOL fErr = FALSE;

    if (isValueArray(clsHnd)) {

        ValueArrayDescr* valArr = asValueArray(clsHnd);

        CorElementType type;
        SigPointer ptr(valArr->sig);    // make a copy

        for(;;) {
            type = ptr.PeekElemType();
            if (type != ELEMENT_TYPE_PINNED)
                break;
            ptr.GetElemType();
        }
    
        if (type == ELEMENT_TYPE_VALUEARRAY) {

            ValueArrayDescr* elem = allocDescr(ptr, valArr->module);
            // set low order bits to mark as a value class array descriptor
            *clsRet = markAsValueArray(elem);
            ret = toJitType(ELEMENT_TYPE_VALUEARRAY);

        } else {

            retType = ptr.GetTypeHandle(valArr->module, &throwable);

            if (retType.IsNull())
                fErr = TRUE;
        }

    } else  {

        TypeHandle th(clsHnd);

        _ASSERTE(!th.IsNull());

        // BYREF, ARRAY types 
        if (th.IsTypeDesc())
            retType = th.AsTypeDesc()->GetTypeParam();
        else {
                // TODO we really should not have this case.  arrays type handles should
                // never be ordinary method tables. 
            EEClass* eeClass = th.GetClass();
            if (eeClass->IsArrayClass())
                retType = ((ArrayClass*) eeClass)->GetElementTypeHandle();
        }

    }

    if (fErr) {
        // If don't have a throwable, find out who didn't create one,
        // and fix it.
        _ASSERTE(throwable!=NULL);
        COMPlusThrow(throwable);
    }
    GCPROTECT_END();
    COOPERATIVE_TRANSITION_END();

    if (!retType.IsNull()) {
        CorElementType type = retType.GetNormCorElementType();
            // if it is true primtive (System.Int32 ..., return 0, to 
            // indicate that it is a primitive and not something like
            // a RuntimeArgumentHandle, that simply looks like a primitive

        if (!(retType.IsUnsharedMT() && retType.GetClass()->IsTruePrimitive())) 
            *clsRet = CORINFO_CLASS_HANDLE(retType.AsPtr());
        ret = toJitType(type);

        if (retType.IsEnum())
            *clsRet = 0;

        // @Todo : What if this one is a value array ?
    }

    return ret;
}

/*********************************************************************/
// Check Visibility rules.
BOOL __stdcall CEEInfo::canAccessType(
        CORINFO_METHOD_HANDLE       context,
        CORINFO_CLASS_HANDLE        target) 
{
    _ASSERTE(!isValueArray(target));

    return ClassLoader::CanAccessClass(
            ((MethodDesc*)context)->GetClass(),
            ((MethodDesc*)context)->GetModule()->GetAssembly(),
            TypeHandle(target).GetClass(),
            TypeHandle(target).GetClass()->GetAssembly());
}

/*********************************************************************/
// Check Visibility rules.
BOOL __stdcall CEEInfo::isSDArray(CORINFO_CLASS_HANDLE  cls)
{
    TypeHandle th(cls);

    _ASSERTE(!th.IsNull());

    if (!th.IsArray())
        return FALSE;

    if (th == TypeHandle(g_pArrayClass))
        return FALSE;

    return (th.AsArray()->GetRank() == 1);
}


/*********************************************************************/
// Static helpers
/*********************************************************************/
TypeHandle CEEInfo::s_th_System_RuntimeTypeHandle;
TypeHandle CEEInfo::s_th_System_RuntimeMethodHandle;
TypeHandle CEEInfo::s_th_System_RuntimeFieldHandle;
TypeHandle CEEInfo::s_th_System_RuntimeArgumentHandle;
TypeHandle CEEInfo::s_th_System_TypedReference;

/* static */
void __stdcall CEEInfo::InitStaticTypeHandles()
{
    static fInited = false;

    if (fInited)
        return;

    if (s_th_System_RuntimeTypeHandle.IsNull())
        s_th_System_RuntimeTypeHandle = TypeHandle(g_Mscorlib.FetchClass(CLASS__TYPE_HANDLE));

    if (s_th_System_RuntimeFieldHandle.IsNull())
        s_th_System_RuntimeFieldHandle = TypeHandle(g_Mscorlib.FetchClass(CLASS__FIELD_HANDLE));

    if (s_th_System_RuntimeMethodHandle.IsNull())
        s_th_System_RuntimeMethodHandle = TypeHandle(g_Mscorlib.FetchClass(CLASS__METHOD_HANDLE));

    if (s_th_System_RuntimeArgumentHandle.IsNull())
        s_th_System_RuntimeArgumentHandle = TypeHandle(g_Mscorlib.FetchClass(CLASS__ARGUMENT_HANDLE));

    if (s_th_System_TypedReference.IsNull())
        s_th_System_TypedReference = TypeHandle(g_Mscorlib.FetchClass(CLASS__TYPED_REFERENCE));

    fInited = true;
}

/*********************************************************************
 * This method returns TRUE only for primitive types like I1, I2.. R8 etc
 * Returns FALSE if the types are OBJREF, VALUECLASS etc.
 */
/* static */ 
BOOL CEEInfo::CanCast(CorElementType el1, CorElementType el2)
{
    if (el1 == el2)
        return CorIsPrimitiveType(el1);

    switch (el1)
    {
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        return (el2 == ELEMENT_TYPE_I1 || 
                el2 == ELEMENT_TYPE_U1 || 
                el2 == ELEMENT_TYPE_BOOLEAN);

    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        return (el2 == ELEMENT_TYPE_I2 || 
                el2 == ELEMENT_TYPE_U2 || 
                el2 == ELEMENT_TYPE_CHAR);

    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
        return (el2 == ELEMENT_TYPE_I4 ||
                el2 == ELEMENT_TYPE_U4);

    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
        return (el2 == ELEMENT_TYPE_I8 ||
                el2 == ELEMENT_TYPE_U8);

    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:
        return  (el2 == ELEMENT_TYPE_I || 
                 el2 == ELEMENT_TYPE_U);

    case ELEMENT_TYPE_R4:
        return (el2 == ELEMENT_TYPE_R4);

    case ELEMENT_TYPE_R8:
    case ELEMENT_TYPE_R:
        return (el2 == ELEMENT_TYPE_R8 || 
                el2 == ELEMENT_TYPE_R);
    }

    return FALSE;
}

/*********************************************************************/
/* static */
BOOL CEEInfo::CompatibleMethodSig(MethodDesc *pMethDescA, MethodDesc *pMethDescB)
{
    _ASSERTE(pMethDescA != NULL && pMethDescB != NULL);

    if (pMethDescA == pMethDescB)
        return TRUE;

    // Disallow virtual methods
    if (pMethDescA->IsVirtual() || pMethDescB->IsVirtual())
        return FALSE;

    Module *pModA, *pModB; 
    PCCOR_SIGNATURE pSigA, pSigB; 
    DWORD dwSigA, dwSigB;

    pMethDescA->GetSig(&pSigA, &dwSigA);
    pMethDescB->GetSig(&pSigB, &dwSigB);

    pModA = pMethDescA->GetModule();
    pModB = pMethDescB->GetModule();

    MetaSig SigA(pSigA, pModA);
    MetaSig SigB(pSigB, pModB);

    // check everyting CompareMethodSigs() does not check
    if (SigA.GetCallingConventionInfo() != SigB.GetCallingConventionInfo())
        return FALSE;

    if (SigA.NumFixedArgs() != SigB.NumFixedArgs())
        return FALSE;

    MethodTable *pMTA, *pMTB;

    pMTA = pMethDescA->GetMethodTable();
    pMTB = pMethDescB->GetMethodTable();

    // @Todo : Is SubClass OK ?
    if (pMTA != pMTB)
    {
        return FALSE;
    }

    return MetaSig::CompareMethodSigs(pSigA, dwSigA, pModA, pSigB, dwSigB, pModB);
}

/*********************************************************************/
void* __stdcall CEEInfo::getInterfaceID (CORINFO_CLASS_HANDLE  clsHnd,
                                         void **ppIndirection)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    _ASSERTE(!isValueArray(clsHnd));
    TypeHandle  VMClsHnd(clsHnd);

        // Sanity test for class
    _ASSERTE(VMClsHnd.AsClass()->GetMethodTable()->GetClass() == VMClsHnd.AsClass());

        // The Interface ID is defined to be the pointer to the MethodTable
        // for the interface to be looked up
    return VMClsHnd.AsMethodTable();
}


/***********************************************************************/
unsigned __stdcall CEEInfo::getInterfaceTableOffset (CORINFO_CLASS_HANDLE       clsHnd,
                                                     void **ppIndirection)
{
    REQUIRES_4K_STACK;

    THROWSCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    _ASSERTE(!isValueArray(clsHnd));
    TypeHandle  VMClsHnd(clsHnd);

        // Sanity test for class
    _ASSERTE(VMClsHnd.AsClass()->GetMethodTable()->GetClass() == VMClsHnd.AsClass());

     // Make sure we are restored so our interface ID is valid
     _ASSERTE(VMClsHnd.AsClass()->IsRestored());

    _ASSERTE(VMClsHnd.AsClass()->IsInterface());

    // Make sure we are restored so our interface ID is valid
    _ASSERTE(VMClsHnd.AsClass()->IsRestored());

    unsigned result = VMClsHnd.AsClass()->GetInterfaceId(); // Can throw.

    //
    // There is a case where we load a system domain com interface from one
    // app domain, then use a zap file in another app domain which tries to call on
    // that interface on a com wrapper.  I believe this is the only
    // place where we can hook in to map the interface from the system
    // domain into the current domain.
    //

    if (VMClsHnd.AsMethodTable()->GetModule()->GetDomain() == SystemDomain::System())
    {
        EEClass::MapInterfaceFromSystem(SystemDomain::GetCurrentDomain(),
                                        VMClsHnd.AsMethodTable());
    }

    return result;
}

/***********************************************************************/
unsigned __stdcall CEEInfo::getClassDomainID (CORINFO_CLASS_HANDLE clsHnd,
                                              void **ppIndirection)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    _ASSERTE(!isValueArray(clsHnd));
    TypeHandle  VMClsHnd(clsHnd);

        // Sanity test for class
    _ASSERTE(VMClsHnd.AsClass()->GetMethodTable()->GetClass() == VMClsHnd.AsClass());

    unsigned result = (unsigned)VMClsHnd.AsMethodTable()->GetSharedClassIndex();

    return result;
}

/***********************************************************************/
CorInfoHelpFunc CEEInfo::getNewHelper (CORINFO_CLASS_HANDLE newClsHnd, CORINFO_METHOD_HANDLE context)
{
    REQUIRES_4K_STACK;

    MethodDesc * method;

    _ASSERTE(!isValueArray(newClsHnd));
    TypeHandle  VMClsHnd(newClsHnd);

    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();     
        // Sanity test for class
    _ASSERTE(VMClsHnd.AsClass()->GetMethodTable()->GetClass() == VMClsHnd.AsClass());
    if(VMClsHnd.AsClass()->IsAbstract())
    {
        // Disabling this assert to allow automated tests for illegal il
        //_ASSERTE(!"Instantiation of an abstract class");
        COMPlusThrow(kNullReferenceException,L"InvalidOperation_BadTypeAttributesNotAbstract");
    }
    COOPERATIVE_TRANSITION_END();

        method = (MethodDesc*) context;

    MethodTable * pMT    = VMClsHnd.AsMethodTable();

    if (pMT->IsComObjectType() && !method->GetModule()->GetSecurityDescriptor()->CanCallUnmanagedCode())
    {
        // Caller does not have permission to make interop calls. Generate a
        // special helper that will throw a security exception when called.
        return CORINFO_HELP_SEC_UNMGDCODE_EXCPT;
    }

    if(CRemotingServices::IsRemoteActivationRequired(pMT->GetClass()))
    {
        return CORINFO_HELP_NEW_CROSSCONTEXT;
    }

    // We shouldn't get here with a COM object (they're all potentially
    // remotable, so they're covered by the case above).
    _ASSERTE(!pMT->IsComObjectType());

    if (GCHeap::IsLargeObject(pMT) ||
        pMT->HasFinalizer())
    {
#ifdef _DEBUG
        //printf("NEWFAST:   %s\n", pMT->GetClass()->m_szDebugClassName);
#endif // _DEBUG
        return CORINFO_HELP_NEWFAST;
    }

#ifdef _DEBUG
        //printf("NEWSFAST:  %s\n", pMT->GetClass()->m_szDebugClassName);
#endif // _DEBUG

        // don't call the super-optimized one since that does not check
        // for GCStress
#ifdef STRESS_HEAP
    if (g_pConfig->GetGCStressLevel() & EEConfig::GCSTRESS_ALLOC)
        return CORINFO_HELP_NEWFAST;
#endif // STRESS_HEAP

#ifdef _LOGALLOC
#ifdef LOGGING
    // Super fast version doesn't do logging
    if (LoggingOn(LF_GCALLOC, LL_INFO10))
        return CORINFO_HELP_NEWFAST;
#endif
#endif

#ifdef PROFILING_SUPPORTED
    // Don't use the SFAST allocator when tracking object allocations,
    // so we don't have to instrument it.
    if (CORProfilerTrackAllocationsEnabled())
        return CORINFO_HELP_NEWFAST;
#endif // PROFILING_SUPPORTED

    if (VMClsHnd.AsClass()->IsAlign8Candidate())
    {
        return CORINFO_HELP_NEWSFAST_ALIGN8;
    }

    return CORINFO_HELP_NEWSFAST;

}

/***********************************************************************/
CorInfoHelpFunc CEEInfo::getNewArrHelper (CORINFO_CLASS_HANDLE arrayClsHnd,
                                          CORINFO_METHOD_HANDLE context)
{
    REQUIRES_4K_STACK;

    TypeHandle arrayType(arrayClsHnd);
    ArrayTypeDesc* arrayTypeDesc = arrayType.AsArray();
    _ASSERTE(arrayTypeDesc->GetNormCorElementType() == ELEMENT_TYPE_SZARRAY);

#ifdef STRESS_HEAP
    if (g_pConfig->GetGCStressLevel() & EEConfig::GCSTRESS_ALLOC)
        return CORINFO_HELP_NEWARR_1_DIRECT;
#endif // STRESS_HEAP

    if(arrayTypeDesc->GetMethodTable()->HasSharedMethodTable()) {
                // It is an array of object refs
        _ASSERTE(CorTypeInfo::IsObjRef(arrayTypeDesc->GetTypeParam().GetNormCorElementType()));
        return CORINFO_HELP_NEWARR_1_OBJ;
    }
    else {
        _ASSERTE(!CorTypeInfo::IsObjRef(arrayTypeDesc->GetTypeParam().GetNormCorElementType()));

        // Make certain we called the class constructor
        if (!m_pOverride->initClass(CORINFO_CLASS_HANDLE(arrayTypeDesc->GetTypeParam().AsPtr()), 
                                    context, FALSE))
            return CORINFO_HELP_NEWARR_1_DIRECT;

        // If the elemen type has a default constructor, do it the slow way
        // TODO remove this after code generators do this explicitly (by 2/00)
        if (arrayTypeDesc->GetElementCtor())
            return CORINFO_HELP_NEWARR_1_DIRECT;

        if (arrayTypeDesc->GetTypeParam().GetSize() > LARGE_ELEMENT_SIZE)
            return CORINFO_HELP_NEWARR_1_DIRECT;

        // Fast version doesn't do logging
        if (LoggingOn(LF_GCALLOC, LL_INFO10))
            return (CORINFO_HELP_NEWARR_1_DIRECT);

#ifdef PROFILING_SUPPORTED
        // If we're profiling object allocations then we should always use the slow path
        if (CORProfilerTrackAllocationsEnabled())
            return (CORINFO_HELP_NEWARR_1_DIRECT);
#endif // PROFILING_SUPPORTED

        // See if we want to double align the object
        if (arrayTypeDesc->GetTypeParam().GetNormCorElementType() == ELEMENT_TYPE_R8) {
            return CORINFO_HELP_NEWARR_1_ALIGN8;
        }

        // Yea, we can do it the fast way!
        return CORINFO_HELP_NEWARR_1_VC;
    }
}

/***********************************************************************/
CorInfoHelpFunc CEEInfo::getIsInstanceOfHelper (CORINFO_CLASS_HANDLE IsInstClsHnd)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(!isValueArray(IsInstClsHnd));
    TypeHandle  clsHnd(IsInstClsHnd);

    // Sanity test for class
    _ASSERTE(!clsHnd.IsUnsharedMT() ||
            clsHnd.AsClass()->GetMethodTable()->GetClass() == clsHnd.AsClass());

    // If it is a class, but not a interface, use an optimized handler.
    if (clsHnd.IsUnsharedMT() && !clsHnd.AsMethodTable()->GetClass()->IsInterface())
        return CORINFO_HELP_ISINSTANCEOFCLASS;

    // Array or Interface.
    return CORINFO_HELP_ISINSTANCEOF;
}

/***********************************************************************/
CorInfoHelpFunc CEEInfo::getChkCastHelper (CORINFO_CLASS_HANDLE IsInstClsHnd)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(!isValueArray(IsInstClsHnd));
    TypeHandle  clsHnd(IsInstClsHnd);

    // Sanity test for class
    _ASSERTE(!clsHnd.IsUnsharedMT() ||
            clsHnd.AsClass()->GetMethodTable()->GetClass() == clsHnd.AsClass());

    // If it is a class, but not a interface, use an optimized handler.
    if (clsHnd.IsUnsharedMT() && !clsHnd.AsMethodTable()->GetClass()->IsInterface())
        return CORINFO_HELP_CHKCASTCLASS;

    // Array or Interface.
    return CORINFO_HELP_CHKCAST;
}
/***********************************************************************/
// This returns the typedesc from a method token. 
CORINFO_CLASS_HANDLE __stdcall CEEInfo::findMethodClass(CORINFO_MODULE_HANDLE scopeHnd, 
                                                        mdToken methodTOK)
{
    REQUIRES_8K_STACK;
    TypeHandle type;
    COOPERATIVE_TRANSITION_BEGIN();

    Module* module = GetModule(scopeHnd);
    IMDInternalImport *pInternalImport = module->GetMDImport();
        
    _ASSERTE(TypeFromToken(methodTOK) == mdtMemberRef);

    mdTypeDef typeSpec;
    HRESULT hr = pInternalImport->GetParentToken(methodTOK, &typeSpec); 
    _ASSERTE(SUCCEEDED(hr));

    NameHandle typeNameHnd(module, typeSpec);
    type = module->GetClassLoader()->LoadTypeHandle(&typeNameHnd);
    // Note at the moment we pass the typeHandle itself as the instantiation parameter
    // (because we have only arrays, and these only have one type parameter)
    // when we go to true parameterized types, this will be pointer to a list of type
    // handles

    COOPERATIVE_TRANSITION_END();
    return(CORINFO_CLASS_HANDLE(type.AsPtr()));
}
/***********************************************************************/
LPVOID __stdcall CEEInfo::getInstantiationParam(CORINFO_MODULE_HANDLE scopeHnd, 
                mdToken methodTOK, void **ppIndirection)
{
    REQUIRES_8K_STACK;

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    return  findMethodClass(scopeHnd,methodTOK);
}

/***********************************************************************/
        // registers a vararg sig & returns a class-specific cookie for it.
CORINFO_VARARGS_HANDLE __stdcall CEEInfo::getVarArgsHandle(CORINFO_SIG_INFO *sig,
                                                           void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    Module* module = GetModule(sig->scope);

    return CORINFO_VARARGS_HANDLE(module->GetVASigCookie((PCCOR_SIGNATURE)sig->sig));
}

/***********************************************************************/
unsigned __stdcall CEEInfo::getMethodHash (CORINFO_METHOD_HANDLE ftnHnd)
{
    MethodDesc* ftn = (MethodDesc*) ftnHnd;
        // Form a hash for the method.  We choose the following

        // start with something that represents a DLL uniquely (we
        // use imageBase for this.  Since this is always on a 64K 
        // boundry, get rid of the lower bits.  
    size_t hash = size_t(ftn->GetModule()->GetILBase()) >> 16;

        // Make the module fit in roughly 4 bits and make it so that
        // mscorlib.dll has hash = 0;
    hash = (hash + 1) % 17;     

        // 4K of method tokens per module
    size_t methodId = RidFromToken(ftn->GetMemberDef());
    hash =  methodId + (hash << 12);

        // Currently the hash should not be greater than a bit over 64K
        // you can start there to mean 'everything'.  
    return (unsigned)hash;
}

/***********************************************************************/
const char* __stdcall CEEInfo::getMethodName (CORINFO_METHOD_HANDLE ftnHnd, const char** scopeName)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    MethodDesc* ftn = (MethodDesc*) ftnHnd;

    if (scopeName != 0)
    {
        EEClass* cls = ftn->GetClass();
        *scopeName = "";
        if (cls) 
        {
#ifdef _DEBUG
            cls->_GetFullyQualifiedNameForClassNestedAware(clsNameBuff, MAX_CLASSNAME_LENGTH);
            *scopeName = clsNameBuff;
#else 
            // since this is for diagnostic purposes only,
            // give up on the namespace, as we don't have a buffer to concat it
            // also note this won't show array class names.         
            LPCUTF8 nameSpace;
            *scopeName= cls->GetFullyQualifiedNameInfo(&nameSpace);
#endif
        }
    }
    return(ftn->GetName());
}

/*********************************************************************/
DWORD __stdcall CEEInfo::getMethodAttribs (CORINFO_METHOD_HANDLE ftnHnd, CORINFO_METHOD_HANDLE callerHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

/*
        returns method attribute flags (defined in corhdr.h)

        NOTE: This doesn't return certain method flags
        (mdAssem, mdFamANDAssem, mdFamORAssem, mdPrivateScope)
*/
    START_NON_JIT_PERF();

    MethodDesc* ftn = (MethodDesc*) ftnHnd;
    MethodDesc* caller = (MethodDesc*) callerHnd;

    // @todo: can we git rid of CORINFO_FLG_ stuff and just include cor.h?

    DWORD ret;
    DWORD ret0;

    ret0 = ftn->GetAttrs();
    ret  = 0;

    if (IsMdPublic(ret0))
        ret |= CORINFO_FLG_PUBLIC;
    if (IsMdPrivate(ret0))
        ret |= CORINFO_FLG_PRIVATE;
    if (IsMdFamily(ret0))
        ret |= CORINFO_FLG_PROTECTED;
    if (IsMdStatic(ret0))
        ret |= CORINFO_FLG_STATIC;
    if (IsMdFinal(ret0))
        ret |= CORINFO_FLG_FINAL;
    if (ftn->IsSynchronized()) 
        ret |= CORINFO_FLG_SYNCH;
    if (ftn->CouldBeFCall())
        ret |= CORINFO_FLG_NOGCCHECK | CORINFO_FLG_INTRINSIC;
    if (IsMdVirtual(ret0))
        ret |= CORINFO_FLG_VIRTUAL;
    if (IsMdAbstract(ret0))
        ret |= CORINFO_FLG_ABSTRACT;
    if (IsMdInstanceInitializer(ret0, ftn->GetName()) ||
        IsMdClassConstructor(   ret0, ftn->GetName()))
        ret |= CORINFO_FLG_CONSTRUCTOR;
    
    //
    // See if we need to embed a .cctor call at the head of the
    // method body.
    //
    
    EEClass* pClass = ftn->GetClass();
    if (pClass->IsShared() 

        // Only if the class has a .cctor or static handles
        // (note for shared classes, this is exactly the case when the ClassInited bit is set)
        && (!pClass->GetMethodTable()->IsClassInited())

        // Only if strict init is required - otherwise we can wait for
        // field accesses to run .cctor
        && !IsTdBeforeFieldInit(pClass->GetAttrClass())

        // Run .cctor on statics & constructors
        && (IsMdInstanceInitializer(ret0, ftn->GetName()) || IsMdStatic(ret0))

        // Except don't class construct on .cctor - it would be circular
        && !IsMdClassConstructor(ret0, ftn->GetName())

        // if same class, it must have been run already.
        // Note that jit has both methods the same if asking whether to emit cctor
        // for a given method's code (as opposed to inlining codegen).
        && ((caller == ftn) || caller->GetClass() != pClass)

#if 1
        // System assembly always waits for field accesses
        // @todo: remove this when compilers (and our code) uses BeforeFieldInit bit
        && (ftn->GetModule()->GetAssembly() != SystemDomain::SystemAssembly())
#endif

        )       
        ret |= CORINFO_FLG_RUN_CCTOR;

    // method may not have the final bit, but the class might
    if (IsMdFinal(ret0) == 0)
    {
        DWORD dwAttrClass = pClass->GetAttrClass();

        if (IsTdSealed(dwAttrClass))
            ret |= CORINFO_FLG_FINAL;
    }

    if (ftn->IsEnCNewVirtual())
    {
        ret |= CORINFO_FLG_EnC;
    }

    if (ftn->IsNDirect())
    {
        if (!Security::IsSecurityOn() || (ftn->GetSecurityFlags() == 0))
            ret |= CORINFO_FLG_UNCHECKEDPINVOKE;
    }

    // Turn off inlining for the object class as contextful and
    // marshalbyref classes derive from it and we need to intercept
    // calls on such classes for remoting (we can make an exception for constructors of object
    if (ftn->IsNotInline() || ((pClass == g_pObjectClass->GetClass()) && !ftn->IsCtor()))
    {
        /* Function marked as not inlineable */
        ret |= CORINFO_FLG_DONT_INLINE;
    }

    // @todo: ultimately this needs to be marked in the meta-data
    if (!ftn->IsECall())
    {
        // now I have too many positives (too many EBP frames)

        MethodDesc* method = ftn;
        if (Security::HasREQ_SOAttribute(method->GetMDImport(), method->GetMemberDef()) == S_OK)
        {
#if 0
            printf("getMethodAttribs: %s is \"special\"", name);
#endif
            ret |= CORINFO_FLG_SECURITYCHECK;
        }

    }

    if (pClass->IsDelegateClass() && ((DelegateEEClass*)pClass)->m_pInvokeMethod == ftn)
    {
        ret |= CORINFO_FLG_DELEGATE_INVOKE;
    }

    STOP_NON_JIT_PERF();

    return ret;
}

static void *GetClassSync(MethodTable *pMT)
{
    void *ret;
    COOPERATIVE_TRANSITION_BEGIN();

    OBJECTREF ref = NULL;

    ref = pMT->GetClass()->GetExposedClassObject();
    if (ref == NULL)
        ret = NULL;
    else
        ret = (void*)ref->GetSyncBlock()->GetMonitor();

    COOPERATIVE_TRANSITION_END();
    return ret;
}

/*********************************************************************/
void* __stdcall CEEInfo::getMethodSync(CORINFO_METHOD_HANDLE ftnHnd,
                                       void **ppIndirection)
{
    REQUIRES_4K_STACK;

    void *ret;

    COOPERATIVE_TRANSITION_BEGIN();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    ret = GetClassSync(((MethodDesc*)ftnHnd)->GetMethodTable());

    COOPERATIVE_TRANSITION_END();
    return ret;
}

/*********************************************************************/
void __stdcall CEEInfo::setMethodAttribs (
        CORINFO_METHOD_HANDLE ftnHnd,
        DWORD          attribs)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    MethodDesc* ftn = (MethodDesc*) ftnHnd;

    if (attribs & CORINFO_FLG_DONT_INLINE)
        ftn->SetNotInline(true);

    //_ASSERTE(!"NYI");
}

/*********************************************************************/
void * __stdcall    CEEInfo::getMethodEntryPoint(CORINFO_METHOD_HANDLE ftnHnd,
                                                 CORINFO_ACCESS_FLAGS  flags,
                                                 void **ppIndirection)
{
    REQUIRES_4K_STACK;
    void * addrOfCode = NULL;

    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    MethodDesc * func = (MethodDesc*)ftnHnd;
    addrOfCode = (void *)func->GetAddrOfCodeForLdFtn();
    _ASSERTE(addrOfCode);

    STOP_NON_JIT_PERF();
    COOPERATIVE_TRANSITION_END();
    return(addrOfCode);
}

/*********************************************************************/
bool __stdcall      CEEInfo::getMethodInfo (CORINFO_METHOD_HANDLE     ftnHnd,
                                               CORINFO_METHOD_INFO * methInfo)
{
    bool ret;
    REQUIRES_16K_STACK;
    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();

    MethodDesc * ftn = (MethodDesc*) ftnHnd;
    HRESULT hr;

    /* Return false if not IL or has no code */
    if (!ftn->IsIL() || !ftn->GetRVA()) {
        ret = false;
        goto exit;
    }
    else {
        /* Get the IL header */
        /* TODO: canInline already did validation, however, we do it again
                 here because NGEN uses this function without calling canInine 
                 It would be nice to avoid this redundancy */
        Module* pModule = ftn->GetModule();
        bool verify = !Security::LazyCanSkipVerification(pModule);
        COR_ILMETHOD_DECODER header(ftn->GetILHeader(), ftn->GetMDImport(), verify);

        if(verify && header.Code)
        {
            IMAGE_DATA_DIRECTORY dir;
            dir.VirtualAddress = ftn->GetRVA();
            dir.Size = header.CodeSize + (header.EH ? header.EH->DataSize() : 0);
            if (pModule->IsPEFile() &&
                FAILED(pModule->GetPEFile()->VerifyDirectory(&dir,IMAGE_SCN_MEM_WRITE))) header.Code = 0;
        }
        BAD_FORMAT_ASSERT(header.Code != 0);
        if (header.Code == 0)
            COMPlusThrowHR(COR_E_BADIMAGEFORMAT);

        /* Grab information from the IL header */

        methInfo->ftn             = CORINFO_METHOD_HANDLE(ftn);
        methInfo->scope           = GetScopeHandle(ftn);
        methInfo->ILCode          = const_cast<BYTE*>(header.Code);
        methInfo->ILCodeSize      = header.CodeSize;
        methInfo->maxStack        = header.MaxStack;
        methInfo->EHcount         = header.EHCount();

        _ASSERTE(CORINFO_OPT_INIT_LOCALS == CorILMethod_InitLocals);
        methInfo->options         = (CorInfoOptions) header.Flags;

        /* Fetch the method signature */
        hr = ConvToJitSig(ftn->GetSig(), GetScopeHandle(ftn), mdTokenNil, &methInfo->args, false);
        _ASSERTE(SUCCEEDED(hr));

        _ASSERTE( (IsMdStatic(ftn->GetAttrs()) == 0) == ((methInfo->args.callConv & CORINFO_CALLCONV_HASTHIS) != 0));

        /* And its local variables */
        hr = ConvToJitSig(header.LocalVarSig, GetScopeHandle(ftn), mdTokenNil, &methInfo->locals, true);
        _ASSERTE(SUCCEEDED(hr));

        LOG((LF_JIT, LL_INFO100000, "Getting method info (possible inline) %s::%s%s\n",
            ftn->m_pszDebugMethodName, ftn->m_pszDebugClassName, ftn->m_pszDebugMethodSignature));

        ret = true;
    }

exit:
    COOPERATIVE_TRANSITION_END();
    return ret;
}

/*************************************************************
 * Check if the caller and calle are in the same assembly
 * i.e. do not inline across assemblies
 *************************************************************/

CorInfoInline __stdcall      CEEInfo::canInline (CORINFO_METHOD_HANDLE hCaller,
                                        CORINFO_METHOD_HANDLE hCallee,
                                        CORINFO_ACCESS_FLAGS  flags)
{
    CorInfoInline res = INLINE_FAIL;

    REQUIRES_16K_STACK;
    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();

    // Returns TRUE: if caller and callee are from the same assembly or the callee
    //               is part of the system assembly.
    //
    // If the caller and callee are from the same security and visibility scope
    // then the callee can be inlined into the caller. If they are not from the
    // same visibility scope then the callee cannot safely be inlined. For example,
    // if method b in class B in assembly BB calls method a in class A in assembly
    // AA it is not always safe to inline method a into method b. If method a makes
    // calles to methods in assembly AA that are private they would fail when made
    // from b. For security, if the callee does not have the same set of permissions
    // as the caller then subsequent security checks will have lost the set of permissions
    // granted method a. This can lead to security holes when permissions for a are
    // less then the granted permissions for b.

    // @TODO: CTS.
    // @TODO: CTS. we can loosen up the security restriction by checking to see if
    // the callers permissions are a subset or equal to the callee's or the callee
    // is fully trusted and would never fail a call. The visibility
    // problem will require additional checks to be made to ensure all calls from
    // a are reachable when called from b.

    MethodDesc* pCaller = (MethodDesc*) hCaller;
    MethodDesc* pCallee = (MethodDesc*) hCallee;

    _ASSERTE(pCaller->GetModule());
    _ASSERTE(pCaller->GetModule()->GetClassLoader());

    _ASSERTE(pCallee->GetModule());
    _ASSERTE(pCallee->GetModule()->GetClassLoader());


    if(pCallee->GetModule()->GetClassLoader() == SystemDomain::Loader())
        res = INLINE_PASS;
    else if (pCallee->GetModule()->GetClassLoader() != pCaller->GetModule()->GetClassLoader())
        res = INLINE_RESPECT_BOUNDARY;
    else
        res = INLINE_PASS;

#ifdef PROFILING_SUPPORTED
    if (IsProfilerPresent())
    {
        // If the profiler has set a mask preventing inlining, always return
        // false to the jit.
        if (CORProfilerDisableInlining())
            res = INLINE_FAIL;

        // If the profiler wishes to be notified of JIT events and the result from
        // the above tests will cause a function to be inlined, we need to tell the
        // profiler that this inlining is going to take place, and give them a
        // chance to prevent it.
        if (CORProfilerTrackJITInfo() && res != INLINE_FAIL)
        {
            BOOL fShouldInline;

            HRESULT hr = g_profControlBlock.pProfInterface->JITInlining(
                (ThreadID)GetThread(),
                (FunctionID)pCaller,
                (FunctionID)pCallee,
                &fShouldInline);

            if (SUCCEEDED(hr) && !fShouldInline)
                res = INLINE_FAIL;
        }
    }
#endif // PROFILING_SUPPORTED

    //  Inliner does not do code verification.
    //  Never inline anything that is not verifiable / bad code.
    //  Return false here if the jit fails or if jit emits verification 
    //  exception.

    if (!dontInline(res) && !pCallee->IsVerified()
        && !pCallee->GetModule()->IsSystem() &&
        /* Allow trusted code to be inlined without verification, but don't do a 
           complete policy resolve here. */
        // @TODO: We can't trust the callee's current security state during ngen, since it does
        // not get persisted in the caller's ngen image and cannot be cross-checked at run-time.
        (GetAppDomain()->IsCompilationDomain() || !Security::LazyCanSkipVerification(pCallee->GetModule())))
    {
#ifdef _VER_EE_VERIFICATION_ENABLED
        static ConfigDWORD peVerify(L"PEVerify", 0);
        if (peVerify.val()) 
        {
            COR_ILMETHOD_DECODER header(pCallee->GetILHeader(), pCallee->GetMDImport());
            pCallee->Verify(&header, TRUE, FALSE);
        }
#endif
        /* JIT will set the CORINFO_FLG_DONT_INLINE flag */ 
        /* Jit this method and check if this is a safe method */

        COR_ILMETHOD_DECODER header(pCallee->GetILHeader(), pCallee->GetMDImport(), true /*VERIFY*/);
        if(header.Code)
        {
            IMAGE_DATA_DIRECTORY dir;
            dir.VirtualAddress = pCallee->GetRVA();
            dir.Size = header.CodeSize + (header.EH ? header.EH->DataSize() : 0);
            if (pCallee->GetModule()->IsPEFile() &&
                FAILED(pCallee->GetModule()->GetPEFile()->VerifyDirectory(&dir,IMAGE_SCN_MEM_WRITE))) header.Code = 0;
        }
        BAD_FORMAT_ASSERT(header.Code != 0);
        if (header.Code == 0)
            COMPlusThrowHR(COR_E_BADIMAGEFORMAT);

        BOOL dummy;
        JITFunction(pCallee, &header, &dummy, CORJIT_FLG_IMPORT_ONLY);

        if (pCallee->IsNotInline() || !pCallee->IsVerified())
            res = INLINE_NEVER;
    }

    COOPERATIVE_TRANSITION_END();
    return (res);
}


/*************************************************************
 * Similar to above, but perform check for tail call
 * eligibility. The callee can be passed as NULL if not known
 * (calli and callvirt).
 *************************************************************/

bool __stdcall      CEEInfo::canTailCall (CORINFO_METHOD_HANDLE hCaller,
                                          CORINFO_METHOD_HANDLE hCallee,
                                          CORINFO_ACCESS_FLAGS  flags)
{
    bool ret;

    REQUIRES_4K_STACK;
    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();

    // See comments in canInline above.

    MethodDesc* pCaller = (MethodDesc*) hCaller;
    MethodDesc* pCallee = (MethodDesc*) hCallee;

    _ASSERTE(pCaller->GetModule());
    _ASSERTE(pCaller->GetModule()->GetClassLoader());

    _ASSERTE((pCallee == NULL) || pCallee->GetModule());
    _ASSERTE((pCallee == NULL) || pCallee->GetModule()->GetClassLoader());

    // If the callee is not known (callvirt, calli) or the caller and callee are
    // in different assemblies, we cannot allow the tailcall (since we'd
    // optimize away what might be the only stack frame for a given assembly,
    // skipping a security check).
    if(pCallee == NULL ||
       pCallee->GetModule()->GetClassLoader() != pCaller->GetModule()->GetClassLoader())
    {
        // We'll allow code with SkipVerification permission to tailcall into
        // another assembly anyway. It's the responsiblity of such code to make
        // sure that they're not opening up a security hole by calling untrusted
        // code in such cases.
        ret = Security::CanSkipVerification(pCaller->GetAssembly()) ? true : false;
    }
    else
        ret = TRUE;

    COOPERATIVE_TRANSITION_END();
    
    return ret;
}


/*********************************************************************/
// get individual exception handler
void __stdcall CEEInfo::getEHinfo(
            CORINFO_METHOD_HANDLE ftnHnd,
            unsigned      EHnumber,
            CORINFO_EH_CLAUSE* clause)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();

    MethodDesc * ftn          = (MethodDesc*) ftnHnd;

    COR_ILMETHOD_DECODER header(ftn->GetILHeader(), ftn->GetMDImport());

     _ASSERTE(header.EH);
    _ASSERTE(EHnumber < header.EH->EHCount());

    // These two structures should be identical, this is a spot check
    // TODO when file format cor.h stuff has been factored, we can make these structs the same
    _ASSERTE(sizeof(CORINFO_EH_CLAUSE) == sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
    _ASSERTE(offsetof(CORINFO_EH_CLAUSE, TryLength) == offsetof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT, TryLength));

    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehClause = (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*) clause;

    const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehInfo;
    ehInfo = header.EH->EHClause(EHnumber, ehClause);
    if (ehInfo != ehClause)
        *ehClause = *ehInfo;

    STOP_NON_JIT_PERF();
}

/*********************************************************************/
void __stdcall CEEInfo::getMethodSig (
            CORINFO_METHOD_HANDLE ftnHnd,
            CORINFO_SIG_INFO* sigRet
            )
{
    REQUIRES_8K_STACK;

    COOPERATIVE_TRANSITION_BEGIN();

    START_NON_JIT_PERF();

    MethodDesc* ftn = (MethodDesc*) ftnHnd;
    PCCOR_SIGNATURE sig = ftn->GetSig();

    STOP_NON_JIT_PERF();

    HRESULT hr = ConvToJitSig(sig, GetScopeHandle(ftn), mdTokenNil, sigRet);
    _ASSERTE(SUCCEEDED(hr));

        // We want the calling convention bit to be consistant with the method attribute bit
    _ASSERTE( (IsMdStatic(ftn->GetAttrs()) == 0) == ((sigRet->callConv & CORINFO_CALLCONV_HASTHIS) != 0) );

    COOPERATIVE_TRANSITION_END();
}

/***********************************************************************/
CORINFO_CLASS_HANDLE __stdcall CEEInfo::getMethodClass (CORINFO_METHOD_HANDLE methodHnd)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();

    MethodDesc* method = (MethodDesc*) methodHnd;
    CORINFO_CLASS_HANDLE clsHnd;

    clsHnd = CORINFO_CLASS_HANDLE(TypeHandle(method->GetMethodTable()).AsPtr());

    STOP_NON_JIT_PERF();
    return clsHnd;
}

/***********************************************************************/
CORINFO_MODULE_HANDLE __stdcall CEEInfo::getMethodModule (CORINFO_METHOD_HANDLE methodHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();

    MethodDesc* method = (MethodDesc*) methodHnd;
        CORINFO_MODULE_HANDLE moduleHnd = (CORINFO_MODULE_HANDLE) method->GetModule();

    STOP_NON_JIT_PERF();
    return moduleHnd;
}

/*********************************************************************/
CorInfoIntrinsics __stdcall CEEInfo::getIntrinsicID(CORINFO_METHOD_HANDLE methodHnd)
{
    REQUIRES_4K_STACK;

    CorInfoIntrinsics ret;
    COOPERATIVE_TRANSITION_BEGIN();

    MethodDesc* method = (MethodDesc*) methodHnd;

    if (method->GetClass()->IsArrayClass())
    {
        ArrayECallMethodDesc * arrMethod = (ArrayECallMethodDesc *)method;
        ret = CorInfoIntrinsics(arrMethod->m_intrinsicID);
    }
    else
    {
        ret = ECall::IntrinsicID(method);
    }

    COOPERATIVE_TRANSITION_END();
    return ret;
}

/*********************************************************************/
unsigned __stdcall CEEInfo::getMethodVTableOffset (CORINFO_METHOD_HANDLE methodHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();
    unsigned methodVtabOffset;

    MethodDesc* method = (MethodDesc*) methodHnd;
    const int methTabOffset = (int)(size_t)((MethodTable*) 0)->GetVtable();
    _ASSERTE(methTabOffset < 256);  // a rough sanity check

        // better be in the vtable
    _ASSERTE(method->GetSlot() < method->GetClass()->GetNumVtableSlots());

    if (method->GetClass()->IsInterface())
        methodVtabOffset = method->GetSlot()*sizeof(void*);
    else
        methodVtabOffset = method->GetSlot()*sizeof(void*) + methTabOffset;

    STOP_NON_JIT_PERF();
    return methodVtabOffset;
}

/*********************************************************************/
void** __stdcall CEEInfo::AllocHintPointer(CORINFO_METHOD_HANDLE methodHnd,
                                           void **ppIndirection)
{
    REQUIRES_4K_STACK;
    _ASSERTE(!"Old style interface invoke no longer supported.");

    return NULL;
}

/*********************************************************************/
void* __stdcall CEEInfo::getMethodPointer(CORINFO_METHOD_HANDLE ftnHnd,
                                          CORINFO_ACCESS_FLAGS  flags,
                                          void **ppIndirection)
{
    REQUIRES_4K_STACK;

    void *ret;

    COOPERATIVE_TRANSITION_BEGIN();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    MethodDesc* ftn = (MethodDesc*) ftnHnd;

    // Strings and Arrays are variable sized objects and so they
    // do not have an instance allocated before this method gets called.
    // We defer to the non-thunking path in this case.
    // Static methods by definition do not have an object for the method
    // called, hence it takes the non-thunking path too.
    // Value classes do not expect calls through method table pointer
    // and hence take the non-thunking path
    // Non contextful and agile (ie not marshal by ref) classes also
    // do not require the thunking path
    // Contextful and marshalbyref classes derive from Object class
    // so we need to take the thunking path for methods on Object class
    // for remoting
    //
    // TarunA 06/26/99
    EEClass* pClass = ftn->GetClass();
    LPVOID pvCode = NULL;

    // Check for calling a virtual method on marshalbyref class or object class
    // non virtually
    if(ftn->IsRemotingIntercepted2()) {

        // Contextful classes imply marshal by ref but not vice versa
        _ASSERTE(!pClass->IsContextful() || pClass->IsMarshaledByRef());

        // This call will find or create the thunk and store it in
        // a hash table
         pvCode = (LPVOID)CRemotingServices::GetNonVirtualThunkForVirtualMethod(ftn); // throws
        _ASSERTE(NULL != pvCode);
    } else {
        pClass = ftn->GetClass();
        pvCode = pClass->GetMethodSlot(ftn);
    }

    _ASSERTE(pvCode);
    ret = pvCode;

    COOPERATIVE_TRANSITION_END();
    return ret;

}

/*********************************************************************/
void* __stdcall CEEInfo::getFunctionEntryPoint(
                                CORINFO_METHOD_HANDLE ftnHnd,
                                InfoAccessType       *pAccessType,
                                CORINFO_ACCESS_FLAGS  flags)
{
    REQUIRES_4K_STACK;
    //COOPERATIVE_TRANSITION_BEGIN();   // Not needed -- getMethodPointer is guarded.
    _ASSERTE(*pAccessType == IAT_VALUE || *pAccessType == IAT_PVALUE || *pAccessType == IAT_PPVALUE);

    /* If the method's prestub has already been executed, we can call
       the function directly.
     */

    MethodDesc * ftn = (MethodDesc*) ftnHnd;
    if (!ftn->PointAtPreStub() && !ftn->MayBeRemotingIntercepted() && *pAccessType == IAT_VALUE)
    {
        *pAccessType = IAT_VALUE;
        return *(ftn->GetClass()->GetMethodSlot(ftn));
    }

    void *pAddr;
    void * addr = getMethodPointer(ftnHnd, flags, &pAddr);    // throws
    _ASSERTE((!addr) != (!pAddr));

    // Double-indirections not needed by EE
    _ASSERTE(addr);

    *pAccessType = IAT_PVALUE;
    //COOPERATIVE_TRANSITION_END();
    return addr;
}

/*********************************************************************/
void* __stdcall CEEInfo::getFunctionFixedEntryPoint(CORINFO_METHOD_HANDLE ftn,
                                            InfoAccessType       *pAccessType,
                                            CORINFO_ACCESS_FLAGS  flags)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();
    _ASSERTE(*pAccessType == IAT_VALUE || *pAccessType == IAT_PVALUE || *pAccessType == IAT_PPVALUE);

    void *pAddr;
    void * addr = getMethodEntryPoint(ftn, flags, &pAddr);
    _ASSERTE((!addr) != (!pAddr));
    _ASSERTE(addr); // The EE doesnt need the JIT to use an indirection

    *pAccessType = IAT_VALUE;
    return addr;
}

/*********************************************************************/
CorInfoCallCategory __stdcall CEEInfo::getMethodCallCategory(CORINFO_METHOD_HANDLE      ftnHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    MethodDesc *ftn = (MethodDesc*)ftnHnd;

    DWORD attribs = ftn->GetAttrs();

    if (IsMdPrivate(attribs)
        || IsMdStatic(attribs)
        || IsMdFinal(attribs)
        || IsMdInstanceInitializer(attribs, ftn->GetName())
        || IsMdClassConstructor(attribs, ftn->GetName()))
    {
        return CORINFO_CallCategoryPointer;
    }
    else
    {
        return CORINFO_CallCategoryVTableOffset;
    }

}





/*********************************************************************/
BOOL __stdcall CEEInfo::canPutField(
        CORINFO_METHOD_HANDLE methodHnd,
        CORINFO_FIELD_HANDLE fieldHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    MethodDesc* method = (MethodDesc*) methodHnd;
    FieldDesc* field = (FieldDesc*) fieldHnd;
    // @todo we should do the right check for static final fields
     return(1);
}

/*********************************************************************/
const char* __stdcall CEEInfo::getFieldName (CORINFO_FIELD_HANDLE fieldHnd, const char** scopeName)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    FieldDesc* field = (FieldDesc*) fieldHnd;
    if (scopeName != 0)
    {
        EEClass* cls = field->GetEnclosingClass();
        *scopeName = "";
        if (cls)
        {
#ifdef _DEBUG
            cls->_GetFullyQualifiedNameForClass(clsNameBuff, MAX_CLASSNAME_LENGTH);
            *scopeName = clsNameBuff;
#else 
            // since this is for diagnostic purposes only,
            // give up on the namespace, as we don't have a buffer to concat it
            // also note this won't show array class names.
            LPCUTF8 nameSpace;
            *scopeName= cls->GetFullyQualifiedNameInfo(&nameSpace);
#endif
        }
    }
    return(field->GetName());
}


/*********************************************************************/
DWORD __stdcall CEEInfo::getFieldAttribs (CORINFO_FIELD_HANDLE  fieldHnd, 
                                          CORINFO_METHOD_HANDLE context,
                                          CORINFO_ACCESS_FLAGS  flags)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

/*
        returns field attribute flags (defined in corhdr.h)

        NOTE: This doesn't return certain field flags
        (fdAssembly, fdFamANDAssem, fdFamORAssem, fdPrivateScope)
*/
    START_NON_JIT_PERF();

    FieldDesc* field = (FieldDesc*) fieldHnd;
    DWORD ret;
    // @todo: can we git rid of CORINFO_FLG_ stuff and just include cor.h?
    // @todo finish of these asserts so that they are all there

    DWORD ret0 = field->GetAttributes();
    ret = 0;

    if (IsFdPublic(ret0))
        ret |= CORINFO_FLG_PUBLIC;
    if (IsFdPrivate(ret0))
        ret |= CORINFO_FLG_PRIVATE;
    if (IsFdFamily(ret0))
        ret |= CORINFO_FLG_PROTECTED;
    if (IsFdStatic(ret0))
        ret |= CORINFO_FLG_STATIC;
    if (IsFdInitOnly(ret0))
        ret |= CORINFO_FLG_FINAL;

    if (IsFdHasFieldRVA(ret0))
    {
        ret |= CORINFO_FLG_UNMANAGED;
        Module* module = field->GetModule();
        if (module->IsPEFile()    && 
            module->GetPEFile()->IsTLSAddress(module->ResolveILRVA(field->GetOffset(), TRUE)))
        {
            ret |= CORINFO_FLG_TLS;
        }
    }

    /*@TODO: (FPG)
        IsFdVolatile might actually be useful if native compilers try to hoist fields
        of the current instance (e.g. this->x). Or is this just meant for statics?
    */

    /*@TODO: (FPG)
        What about IsFdTransient(), IsFdNotSerialized(),
                   IsFdPinvokeImpl(), IsFdLiteral() ?
    */

    if (field->IsEnCNew())
        ret |= CORINFO_FLG_EnC;

    if (field->IsStatic())
    {
        // static field reference

        if (field->IsThreadStatic() || field->IsContextStatic())
        {
            ret |= CORINFO_FLG_HELPER;
        }
        else
        {
            if (!field->IsSpecialStatic())   // Special means RVA, context or thread local 
            {
                if (field->GetFieldType() == ELEMENT_TYPE_VALUETYPE)
                    ret |= CORINFO_FLG_STATIC_IN_HEAP;

                // Only use a helper to access static fields inside shared assemblies.
                MethodDesc* contextMethod = (MethodDesc*) context;
                if (contextMethod->GetMethodTable()->IsShared())
                {
                    _ASSERTE(field->GetMethodTableOfEnclosingClass()->IsShared());
                    ret |= CORINFO_FLG_SHARED_HELPER;
                }
            }
        }
    }
    else
    {
        // instance field reference

#if CHECK_APP_DOMAIN_LEAKS
        if (field->IsDangerousAppDomainAgileField()
            && CorTypeInfo::IsObjRef(field->GetFieldType()))
        {
            //
            // In a checked field, we use a helper to enforce the app domain
            // agile invariant.
            //
            // @todo: we'd like to check this for value type fields as well - we
            // just need to add some code to iterate through the fields for 
            // references during the assignment.
            //
            ret |= CORINFO_FLG_HELPER;
        }
        else
#endif
        {
            EEClass * fldCls = field->GetEnclosingClass();

            if (fldCls->IsContextful())           // is contextful class (i,e. a proxy)
            {
                // If the caller is states that we have a 'this reference'
                // and he is also willing to unwrap it himself then
                // we won't require a helper call.
                if (!(flags & CORINFO_ACCESS_THIS  )  ||
                    !(flags & CORINFO_ACCESS_UNWRAP))
                {
                    // Normally a helper call is required.
                    ret |= CORINFO_FLG_HELPER;
                }
            }
            else if (fldCls->IsMarshaledByRef())  //  is marshaled by ref class
            {
                // If the caller is states that we have a 'this reference'
                // we won't require a helper call.
                if (!(flags & CORINFO_ACCESS_THIS))
                {
                    // Normally a helper call is required.
                    ret |= CORINFO_FLG_HELPER;
                }
            }
        }
    }

    STOP_NON_JIT_PERF();

    return(ret);
}

/*********************************************************************/
CORINFO_CLASS_HANDLE __stdcall CEEInfo::getFieldClass (CORINFO_FIELD_HANDLE fieldHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    FieldDesc* field = (FieldDesc*) fieldHnd;
    return(CORINFO_CLASS_HANDLE(TypeHandle(field->GetMethodTableOfEnclosingClass()).AsPtr()));
}

/*********************************************************************/
CorInfoType __stdcall CEEInfo::getFieldType (CORINFO_FIELD_HANDLE fieldHnd, CORINFO_CLASS_HANDLE* structType)
{
    REQUIRES_8K_STACK;

    *structType = 0;
    CorElementType type;

    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();

    FieldDesc* field = (FieldDesc*) fieldHnd;
    type = field->GetFieldType();

        // TODO should not burn the time to do this for anything but Value Classes
    _ASSERTE(type != ELEMENT_TYPE_BYREF);
    if (!CorTypeInfo::IsPrimitiveType(type))
    {
        PCCOR_SIGNATURE sig;
        DWORD sigCount;
        field->GetSig(&sig, &sigCount);
        CorCallingConvention conv = (CorCallingConvention) CorSigUncompressCallingConv(sig);
        _ASSERTE(isCallConv(conv, IMAGE_CEE_CS_CALLCONV_FIELD));

        SigPointer ptr(sig);
        //_ASSERTE(ptr.PeekElemType() ==  ELEMENT_TYPE_VALUETYPE);

        TypeHandle clsHnd;
        OBJECTREF Throwable = NULL;
        GCPROTECT_BEGIN(Throwable);
        clsHnd = ptr.GetTypeHandle(field->GetModule(), &Throwable);

        if (clsHnd.IsNull()) {
            if (Throwable == NULL)
                COMPlusThrow(kTypeLoadException);
            else
                COMPlusThrow(Throwable);
        }
        GCPROTECT_END();

        CorElementType normType = clsHnd.GetNormCorElementType();
        // if we are looking up a value class don't morph it to a refernece type 
        // (This can only happen in illegal IL), reference types don't need morphing. 
        if (type == ELEMENT_TYPE_VALUETYPE && !CorTypeInfo::IsObjRef(normType))
            type = normType;
        
        if (clsHnd.IsEnum())
            clsHnd = TypeHandle();
        *structType = CORINFO_CLASS_HANDLE(clsHnd.AsPtr());
    }

    COOPERATIVE_TRANSITION_END();

    return(toJitType(type));
}

/*********************************************************************/
unsigned __stdcall CEEInfo::getFieldOffset (CORINFO_FIELD_HANDLE fieldHnd)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    FieldDesc* field = (FieldDesc*) fieldHnd;

    // GetOffset() does not include the size of Object
    unsigned ret = field->GetOffset();

    // only the small types are not DWORD aligned.
    // FIX put this back _ASSERTE(field->GetFieldType() < ELEMENT_TYPE_I4 || (ret & 3) == 0);

    // TODO: GetOffset really should include the MethodTable* not just
    // the declared fields so we don't have to do this.

    // So if it is not a value class, add the Object into it
    if (field->IsStatic())
    {
        Module* pModule = field->GetModule();
        BYTE* ptr = pModule->ResolveILRVA(field->GetOffset(), field->IsRVA());
        if (pModule->IsPEFile() && pModule->GetPEFile()->IsTLSAddress(ptr))
            ret = (unsigned)(size_t)(ptr - pModule->GetPEFile()->GetTLSDirectory()->StartAddressOfRawData);
		else
		{
			if (field->GetMethodTableOfEnclosingClass()->IsShared()) 
			{
				// helper returns base of DomainLocalClass, skip stuff before statics 
				ret += (unsigned)DomainLocalClass::GetOffsetOfStatics();
			}
			else 
			{
				// TODO the jit calls this function when it shouldnt
				// _ASSERTE(!"Should not call on static members");
			}
		}
    }
    else if (!field->GetEnclosingClass()->IsValueClass())
        ret += sizeof(Object);

    return(ret);
}

/*********************************************************************/
void* __stdcall CEEInfo::getFieldAddress(CORINFO_FIELD_HANDLE fieldHnd,
                                         void **ppIndirection)
{
    REQUIRES_4K_STACK;

    void *result;

    COOPERATIVE_TRANSITION_BEGIN();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    FieldDesc* field = (FieldDesc*) fieldHnd;
    void *base;

    if (field->GetMethodTableOfEnclosingClass()->IsShared())
    {
        // @todo: assert that the current method being compiled is unshared

        // Allocate space for the local class if necessary, but don't trigger
        // class construction.
        DomainLocalBlock *pLocalBlock = GetAppDomain()->GetDomainLocalBlock();
        DomainLocalClass *pLocalClass = pLocalBlock->PopulateClass(field->GetMethodTableOfEnclosingClass());

        base = pLocalClass->GetStaticSpace();
    }
    else
        base = field->GetUnsharedBase();

    result = field->GetStaticAddressHandle(base);

    COOPERATIVE_TRANSITION_END();
    return result;

}

/*********************************************************************/
CorInfoHelpFunc __stdcall CEEInfo::getFieldHelper(CORINFO_FIELD_HANDLE fieldHnd, enum CorInfoFieldAccess kind)
{
    REQUIRES_4K_STACK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    FieldDesc* field = (FieldDesc*) fieldHnd;
    CorElementType type = field->GetFieldType();

    if (kind == CORINFO_ADDRESS) {
        if (field->IsStatic()) {
            /***** TODO enable this after Manish checks in -vancem 
            if (field->GetOffset() < FIELD_OFFSET_LAST_REAL_OFFSET) {
                if (field->IsThreadStatic()) {
                    if (CorTypeInfo::IsPrimitiveType(type)) 
                        return(CORINFO_HELP_GET_THREAD_FIELD_ADDR_PRIMITIVE);
                    if (CorTypeInfo::IsObjRef(type))
                        return(CORINFO_HELP_GET_THREAD_FIELD_ADDR_OBJREF);
                }
                else if (field->IsContextStatic()) {
                    if (CorTypeInfo::IsPrimitiveType(type))  
                        return(CORINFO_HELP_GET_CONTEXT_FIELD_ADDR_PRIMITIVE);
                    if (CorTypeInfo::IsObjRef(type))
                        return(CORINFO_HELP_GET_CONTEXT_FIELD_ADDR_OBJREF);
                }
            }
            *****/
            return(CORINFO_HELP_GETSTATICFIELDADDR);
        }
        else 
            return(CORINFO_HELP_GETFIELDADDR);
    }

    CorInfoHelpFunc ret;
    if (CorTypeInfo::IsObjRef(type))
        ret = CORINFO_HELP_GETFIELD32OBJ;
    else if (CorTypeInfo::Size(type) <= 4)
        ret = CORINFO_HELP_GETFIELD32;
    else if (CorTypeInfo::Size(type) == 8)
        ret = CORINFO_HELP_GETFIELD64;
    else
    {
        _ASSERTE(type == ELEMENT_TYPE_VALUETYPE);
        ret = CORINFO_HELP_GETFIELDSTRUCT;
    }

    _ASSERTE(kind == CORINFO_GET || kind == CORINFO_SET);
    _ASSERTE(!field->IsStatic());       // Static fields always accessed through address
    _ASSERTE(CORINFO_GET == 0);
    _ASSERTE((int) CORINFO_HELP_SETFIELD32 == (int) CORINFO_HELP_GETFIELD32 + (int) CORINFO_SET);
    _ASSERTE((int) CORINFO_HELP_SETFIELD64 == (int) CORINFO_HELP_GETFIELD64 + (int) CORINFO_SET);
    _ASSERTE((int) CORINFO_HELP_SETFIELD32OBJ == (int) CORINFO_HELP_GETFIELD32OBJ + (int) CORINFO_SET);
    _ASSERTE((int) CORINFO_HELP_SETFIELDSTRUCT == (int) CORINFO_HELP_GETFIELDSTRUCT + (int) CORINFO_SET);

    return (CorInfoHelpFunc) (ret + kind);
}

/*********************************************************************/
CorInfoFieldCategory __stdcall CEEInfo::getFieldCategory (CORINFO_FIELD_HANDLE fieldHnd)
{
    REQUIRES_4K_STACK;
    return CORINFO_FIELDCATEGORY_NORMAL;
}

DWORD __stdcall CEEInfo::getFieldThreadLocalStoreID(CORINFO_FIELD_HANDLE fieldHnd, void **ppIndirection)
{
    REQUIRES_4K_STACK;

    DWORD retVal;
    COOPERATIVE_TRANSITION_BEGIN();

    FieldDesc* field = (FieldDesc*) fieldHnd;
    Module* module = field->GetModule();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    _ASSERTE(field->IsRVA());       // Only RVA statics can be thread local
    _ASSERTE(module->GetPEFile()->IsTLSAddress(module->ResolveILRVA(field->GetOffset(), field->IsRVA())));
    retVal = *(PDWORD)(size_t)(module->GetPEFile()->GetTLSDirectory()->AddressOfIndex);

    COOPERATIVE_TRANSITION_END();
    return retVal;
}

/*********************************************************************/
unsigned __stdcall CEEInfo::getIndirectionOffset ()
{
    REQUIRES_4K_STACK;
    return 0;//DEPRECATED: @todo: remove this.
}

void *CEEInfo::allocateArray(ULONG cBytes)
{
#ifdef DEBUGGING_SUPPORTED
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    return g_pDebugInterface->allocateArray(cBytes);
#else // !DEBUGGING_SUPPORTED
    return NULL;
#endif // !DEBUGGING_SUPPORTED
}

void CEEInfo::freeArray(void *array)
{
#ifdef DEBUGGING_SUPPORTED
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    g_pDebugInterface->freeArray(array);
#endif // DEBUGGING_SUPPORTED
}

void CEEInfo::getBoundaries(CORINFO_METHOD_HANDLE ftn,
                               unsigned int *cILOffsets, DWORD **pILOffsets,
                               ICorDebugInfo::BoundaryTypes *implicitBoundaries)
{
#ifdef DEBUGGING_SUPPORTED
    REQUIRES_N4K_STACK(16); // this is big, since we can't throw 
    CANNOTTHROWCOMPLUSEXCEPTION();

#ifdef _DEBUG
    DWORD dwDebugBits = ((MethodDesc*)ftn)->GetModule()->GetDebuggerInfoBits();
    _ASSERTE(CORDebuggerTrackJITInfo(dwDebugBits) ||
             SystemDomain::GetCurrentDomain()->IsCompilationDomain() ||
             g_pConfig->GenDebugInfo() ||
             CORProfilerJITMapEnabled());
#endif

    g_pDebugInterface->getBoundaries(ftn, cILOffsets, pILOffsets,
                                     implicitBoundaries);
#endif // DEBUGGING_SUPPORTED
}

void CEEInfo::setBoundaries(CORINFO_METHOD_HANDLE ftn, ULONG32 cMap,
                               OffsetMapping *pMap)
{
#ifdef DEBUGGING_SUPPORTED
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    DWORD dwDebugBits = ((MethodDesc*)ftn)->GetModule()->GetDebuggerInfoBits();

    if (CORDebuggerTrackJITInfo(dwDebugBits) ||
        SystemDomain::GetCurrentDomain()->IsCompilationDomain() ||
        CORProfilerJITMapEnabled())
    {
        g_pDebugInterface->setBoundaries(ftn, cMap, pMap);
    }
#endif // DEBUGGING_SUPPORTED
}

void CEEInfo::getVars(CORINFO_METHOD_HANDLE ftn, ULONG32 *cVars, ILVarInfo **vars,
                         bool *extendOthers)
{
#ifdef DEBUGGING_SUPPORTED
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

#ifdef _DEBUG
    DWORD dwDebugBits = ((MethodDesc*)ftn)->GetModule()->GetDebuggerInfoBits();
    _ASSERTE(CORDebuggerTrackJITInfo(dwDebugBits) ||
             SystemDomain::GetCurrentDomain()->IsCompilationDomain() ||
             g_pConfig->GenDebugInfo() ||
             CORProfilerJITMapEnabled());
#endif

    g_pDebugInterface->getVars(ftn, cVars, vars, extendOthers);
#endif // DEBUGGING_SUPPORTED
}

void CEEInfo::setVars(CORINFO_METHOD_HANDLE ftn, ULONG32 cVars, NativeVarInfo *vars)
{
#ifdef DEBUGGING_SUPPORTED
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    DWORD dwDebugBits = ((MethodDesc*)ftn)->GetModule()->GetDebuggerInfoBits();
    if (CORDebuggerTrackJITInfo(dwDebugBits)
        || SystemDomain::GetCurrentDomain()->IsCompilationDomain()
        || CORProfilerJITMapEnabled())
        g_pDebugInterface->setVars(ftn, cVars, vars);
#endif // DEBUGGING_SUPPORTED
}

/*********************************************************************/
CORINFO_ARG_LIST_HANDLE __stdcall CEEInfo::getArgNext (
        CORINFO_ARG_LIST_HANDLE args
        )
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    SigPointer ptr(((unsigned __int8*) args));
    ptr.Skip();

        // I pass a SigPointer as a void* and back
    _ASSERTE(sizeof(SigPointer) == sizeof(BYTE*));
    return(*((CORINFO_ARG_LIST_HANDLE*) &ptr));
}

/*********************************************************************/
CorInfoTypeWithMod __stdcall CEEInfo::getArgType (
        CORINFO_SIG_INFO*       sig,
        CORINFO_ARG_LIST_HANDLE    args,
        CORINFO_CLASS_HANDLE       *vcTypeRet
        )
{
    CorInfoTypeWithMod ret = CorInfoTypeWithMod(CORINFO_TYPE_UNDEF);
    REQUIRES_8K_STACK;
    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();     

   _ASSERTE((BYTE*) sig->sig <= (BYTE*) sig->args);
   _ASSERTE((BYTE*) sig->args <= (BYTE*) args && (BYTE*) args < &((BYTE*) sig->args)[0x10000*5]);
    INDEBUG(*vcTypeRet = CORINFO_CLASS_HANDLE(size_t(0xCCCCCCCC)));

    SigPointer ptr((unsigned __int8*) args);
    CorElementType type = ptr.PeekElemType();
    while (type == ELEMENT_TYPE_PINNED) {
        type = ptr.GetElemType();
        ret = CORINFO_TYPE_MOD_PINNED;
    }

    TypeHandle typeHnd;
    if (type == ELEMENT_TYPE_VALUETYPE || type == ELEMENT_TYPE_TYPEDBYREF) {
        OBJECTREF Throwable = NULL;
        GCPROTECT_BEGIN(Throwable);
        typeHnd = ptr.GetTypeHandle(GetModule(sig->scope), &Throwable, TRUE);
        if (typeHnd.IsNull()) {
            if (Throwable == NULL)
                COMPlusThrow(kTypeLoadException);
            else
                COMPlusThrow(Throwable);
        }
        GCPROTECT_END();

        CorElementType normType = typeHnd.GetNormCorElementType();
            // if we are looking up a value class don't morph it to a refernece type 
            // (This can only happen in illegal IL
        if (!CorTypeInfo::IsObjRef(normType))
            type = normType;
        
            // a null class handle means it is is a primitive.  
            // enums are exactly like primitives, even from a verificaiton standpoint
        if (typeHnd.IsEnum())
            typeHnd = TypeHandle(); 
    }
    *vcTypeRet = CORINFO_CLASS_HANDLE(typeHnd.AsPtr());

    ret = CorInfoTypeWithMod(ret | toJitType(type));

    COOPERATIVE_TRANSITION_END();
    return(ret);
}

/*********************************************************************/
CORINFO_CLASS_HANDLE __stdcall CEEInfo::getArgClass (
        CORINFO_SIG_INFO*       sig,
    CORINFO_ARG_LIST_HANDLE    args
    )
{
    REQUIRES_16K_STACK;
    CORINFO_CLASS_HANDLE ret = NULL;

    COOPERATIVE_TRANSITION_BEGIN();
    THROWSCOMPLUSEXCEPTION();


    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);

    // make certain we dont have a completely wacked out sig pointer
    _ASSERTE((BYTE*) sig->sig <= (BYTE*) sig->args);
    _ASSERTE((BYTE*) sig->args <= (BYTE*) args && (BYTE*) args < &((BYTE*) sig->args)[0x10000*5]);

    Module* module = GetModule(sig->scope);
    SigPointer ptr((unsigned __int8*) args);

    CorElementType type;
    for(;;) {
        type = ptr.PeekElemType();
        if (type != ELEMENT_TYPE_PINNED)
            break;
        ptr.GetElemType();
    }

    if (!CorTypeInfo::IsPrimitiveType(type)) {
        ret = CORINFO_CLASS_HANDLE(ptr.GetTypeHandle(module, &throwable).AsPtr());

        if (!ret) {
            // If don't have a throwable, find out who didn't create one,
            // and fix it.
            _ASSERTE(throwable!=NULL);
            COMPlusThrow(throwable);
        }
    }

    GCPROTECT_END();
    COOPERATIVE_TRANSITION_END();
    return ret;
}

/*********************************************************************/

    // return the unmanaged calling convention for a PInvoke
CorInfoUnmanagedCallConv __stdcall CEEInfo::getUnmanagedCallConv(CORINFO_METHOD_HANDLE method)
{
    CorInfoUnmanagedCallConv conv = CORINFO_UNMANAGED_CALLCONV_UNKNOWN;
    BEGIN_REQUIRES_4K_STACK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    MethodDesc* ftn = (MethodDesc*) method;
    _ASSERTE(ftn->IsNDirect());

    CorPinvokeMap            pmconv;

    COMPLUS_TRY
    {
        CorNativeLinkType linkType;
        CorNativeLinkFlags linkFlags;
        LPCUTF8 pLibName = NULL;
        LPCUTF8 pEntrypointName = NULL;
        BOOL BestFit;
        BOOL ThrowOnUnmappableChar;

        CalculatePinvokeMapInfo(ftn,
                                &linkType,
                                &linkFlags,
                                &pmconv,
                                &pLibName,
                                &pEntrypointName,
                                &BestFit,
                                &ThrowOnUnmappableChar);
        // We've already asserts that this ftn is an NDirect so the above call
        // must either succeed or throw.

        switch (pmconv) {
            case pmCallConvStdcall:
                conv = CORINFO_UNMANAGED_CALLCONV_STDCALL;
                break;
            case pmCallConvCdecl:
                conv = CORINFO_UNMANAGED_CALLCONV_C;
                break;
            default:
                conv = CORINFO_UNMANAGED_CALLCONV_UNKNOWN;
        }



    }
    COMPLUS_CATCH
    {
        conv = CORINFO_UNMANAGED_CALLCONV_UNKNOWN;
    }
    COMPLUS_END_CATCH

    ENDCANNOTTHROWCOMPLUSEXCEPTION();


    END_CHECK_STACK;
    return conv;
}

/*********************************************************************/
BOOL __stdcall CEEInfo::pInvokeMarshalingRequired(CORINFO_METHOD_HANDLE method, CORINFO_SIG_INFO* callSiteSig)
{
    REQUIRES_8K_STACK;
    BOOL ret;
    COOPERATIVE_TRANSITION_BEGIN();
    START_NON_JIT_PERF();

#ifdef CUSTOMER_CHECKED_BUILD
    CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_StackImbalance))
    {
        ret = TRUE;
    }
    else
#endif
    if (method != 0) 
    {
        MethodDesc* ftn = (MethodDesc*) method;
        _ASSERTE(ftn->IsNDirect());
        NDirectMethodDesc *pMD = (NDirectMethodDesc*)ftn;

        NDirectMethodDesc::MarshCategory marshCatSnap = pMD->GetMarshCategory(); 
        if (marshCatSnap != pMD->kUnknown)
        {
            ret = marshCatSnap != pMD->kNoMarsh;
        }
        else
        {
            CorNativeLinkType type;
            CorNativeLinkFlags flags;
            LPCUTF8 szLibName = NULL;
            LPCUTF8 szEntrypointName = NULL;
            Stub  *pTempMLStub = NULL;
            CorPinvokeMap unmgdCallConv;
            BOOL BestFit;
            BOOL ThrowOnUnmappableChar;

            CalculatePinvokeMapInfo(pMD, &type, &flags, &unmgdCallConv, &szLibName, &szEntrypointName, &BestFit, &ThrowOnUnmappableChar);
            // @todo: The code to get the new-style signatures should be
            // encapsulated in the MethodDesc class.
            PCCOR_SIGNATURE pMetaSig;
            DWORD       cbMetaSig;
            pMD->GetSig(&pMetaSig, &cbMetaSig);

            NDirectMethodDesc::MarshCategory marshCat;
            OBJECTREF throwable = NULL;

            GCPROTECT_BEGIN(throwable);
            pTempMLStub = CreateNDirectMLStub(pMetaSig, pMD->GetModule(), pMD->GetMemberDef(), type, flags, unmgdCallConv, &throwable, FALSE, BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                                              ,pMD
#endif
                                              );
            GCPROTECT_END();

            if (!pTempMLStub)
            {
                marshCat = pMD->kYesMarsh;
            }
            else
            {
                pMD->ndirect.m_cbDstBufSize = ((MLHeader*)(pTempMLStub->GetEntryPoint()))->m_cbDstBuffer;

                MLHeader *header = (MLHeader*)(pTempMLStub->GetEntryPoint());

                marshCat = pMD->kNoMarsh;

                if (header->m_Flags != 0)
                {
                    // Has a floating point result
                    marshCat = pMD->kYesMarsh;
                }
                else
                {
                    const MLCode *pMLCode = header->GetMLCode();
                    MLCode mlcode;
                    while (ML_END != (mlcode = *(pMLCode++)))
                    {
                        if (!(mlcode == ML_COPY4 || mlcode == ML_COPYI4 || mlcode == ML_COPYU4 || mlcode == ML_INTERRUPT))
                        {
                            if (mlcode == ML_BUMPSRC)
                            {
                                pMLCode += 2;
                            }
                            else
                            {
                                marshCat = pMD->kYesMarsh;
                                break;
                            }
                        }
                    }
                }

                pTempMLStub->DecRef();

            }
            _ASSERTE(marshCat != pMD->kUnknown);
            pMD->ProbabilisticallyUpdateMarshCategory(marshCat);
            ret = marshCat != pMD->kNoMarsh;

                // make certain call site signature does not require marshelling
            if (!ret && *pMetaSig == IMAGE_CEE_CS_CALLCONV_VARARG)
                goto CHECK_SIG;
        }
    }
    else {
    CHECK_SIG:
            // Check to make certain that the signature only contains types that marshel trivially
        ret = FALSE;

        SigPointer ptr((PCCOR_SIGNATURE) callSiteSig->sig);
        ptr.GetCallingConvInfo();
        unsigned numArgs = ptr.GetData() + 1;   // +1 for return type
        do {
            SigPointer arg = ptr;
            CorElementType type = arg.GetElemType();
            if (type == ELEMENT_TYPE_PTR) 
            {
                if (arg.HasCustomModifier((Module*) callSiteSig->scope, "Microsoft.VisualC.NeedsCopyConstructorModifier", ELEMENT_TYPE_CMOD_REQD))
                {
                    ret = TRUE;
                    break;
                }
            } 
            else if (!CorTypeInfo::IsPrimitiveType(type))
            {
                ret = TRUE;
                break;
            }
           ptr.Skip();
            --numArgs;
        } while (numArgs != 0);
    }

    STOP_NON_JIT_PERF();

    COOPERATIVE_TRANSITION_END();
    return ret;
}

// Generate a cookie based on the signature that would needs to be passed
// to CORINFO_HELP_PINVOKE_CALLI
LPVOID CEEInfo::GetCookieForPInvokeCalliSig(CORINFO_SIG_INFO* szMetaSig,
                                            void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    return getVarArgsHandle(szMetaSig, ppIndirection);
}

/*********************************************************************/
// checks if two method sigs are compatible.
BOOL __stdcall CEEInfo::compatibleMethodSig(
            CORINFO_METHOD_HANDLE        child, 
            CORINFO_METHOD_HANDLE        parent)
{
    return CompatibleMethodSig((MethodDesc*)child, (MethodDesc*)parent);
}

/*********************************************************************/
// Check Visibility rules.
// For Protected (family access) members, type of the instance is also
// considered when checking visibility rules.
BOOL __stdcall CEEInfo::canAccessMethod(
        CORINFO_METHOD_HANDLE       context,
        CORINFO_METHOD_HANDLE       target,
        CORINFO_CLASS_HANDLE        instance) 
{
    return ClassLoader::CanAccess(
            ((MethodDesc*)context)->GetClass(),
            ((MethodDesc*)context)->GetModule()->GetAssembly(),
            ((MethodDesc*)target)->GetClass(),
            ((MethodDesc*)target)->GetModule()->GetAssembly(),
            TypeHandle(instance).GetClass(),
            ((MethodDesc*)target)->GetAttrs());
}

/*********************************************************************/
// Given an object type, method ptr, and  Delegate ctor, check if the object and method signature
// is Compatible with the Invoke method of the delegate.
BOOL __stdcall CEEInfo::isCompatibleDelegate(
            CORINFO_CLASS_HANDLE        objCls,
            CORINFO_METHOD_HANDLE       method,
            CORINFO_METHOD_HANDLE       delegateCtor)
{
    _ASSERTE(method != NULL);
    _ASSERTE(delegateCtor != NULL);

    BOOL result = FALSE;

    BEGIN_REQUIRES_4K_STACK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    EEClass* pClsDelegate = ((MethodDesc*)delegateCtor)->GetClass();

#ifdef _DEBUG
    _ASSERTE(pClsDelegate->IsAnyDelegateClass());
#endif

    MethodDesc* pMDFtn = (MethodDesc*) method;
    TypeHandle inst(objCls);

    COMPLUS_TRY
    {
        result = COMDelegate::ValidateCtor(pMDFtn, pClsDelegate, 
                inst.IsNull() ? NULL : inst.GetClass());
    }
    COMPLUS_CATCH
    {
    }
    COMPLUS_END_CATCH

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    END_CHECK_STACK;

    return result;
}

/*********************************************************************/
    // return the unmanaged target *if method has already been prelinked.*
void* __stdcall CEEInfo::getPInvokeUnmanagedTarget(CORINFO_METHOD_HANDLE method,
                                                    void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    MethodDesc* ftn = (MethodDesc*) method;
    _ASSERTE(ftn->IsNDirect());
    NDirectMethodDesc *pMD = (NDirectMethodDesc*)ftn;

    LPVOID pTarget = pMD->ndirect.m_pNDirectTarget;
    if (pTarget == pMD->ndirect.m_ImportThunkGlue)
    {
        return NULL;
    }
    else
    {
        return pTarget;
    }
}

/*********************************************************************/
    // return address of fixup area for late-bound N/Direct calls.
void* __stdcall CEEInfo::getAddressOfPInvokeFixup(CORINFO_METHOD_HANDLE method,
                                                   void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    MethodDesc* ftn = (MethodDesc*) method;
    _ASSERTE(ftn->IsNDirect());
    NDirectMethodDesc *pMD = (NDirectMethodDesc*)ftn;

    return (LPVOID)&(pMD->ndirect.m_pNDirectTarget);
}


/*********************************************************************/
    // Gets a method handle that can be used to correlate profiling data.
    // This is the IP of a native method, or the address of the descriptor struct
    // for IL.  Always guaranteed to be unique per process, and not to move. */
CORINFO_PROFILING_HANDLE __stdcall CEEInfo::GetProfilingHandle(CORINFO_METHOD_HANDLE method,
                                                               BOOL *pbHookFunction,
                                                               void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    MethodDesc* ftn = (MethodDesc*) method;
    CORINFO_PROFILING_HANDLE    handle = 0;

    extern FunctionIDMapper *g_pFuncIDMapper;
    handle = (CORINFO_PROFILING_HANDLE) g_pFuncIDMapper((FunctionID) ftn, pbHookFunction);

    return (handle);
}



/*********************************************************************/
    // Return details about EE internal data structures
void __stdcall CEEInfo::getEEInfo(CORINFO_EE_INFO *pEEInfoOut)
{
    REQUIRES_4K_STACK;
    COOPERATIVE_TRANSITION_BEGIN();

    START_NON_JIT_PERF();

    pEEInfoOut->sizeOfFrame       = sizeof(InlinedCallFrame);
    // Offsets into the Frame structure
    pEEInfoOut->offsetOfFrameVptr = 0;
    pEEInfoOut->offsetOfFrameLink = Frame::GetOffsetOfNextLink();

    // Details about the InlinedCallFrame
    pEEInfoOut->offsetOfInlinedCallFrameCallSiteTracker      = InlinedCallFrame::GetOffsetOfCallSiteTracker();
    pEEInfoOut->offsetOfInlinedCallFrameCalleeSavedRegisters = InlinedCallFrame::GetOffsetOfCalleeSavedRegisters();
    pEEInfoOut->offsetOfInlinedCallFrameCallTarget           = InlinedCallFrame::GetOffsetOfCallSiteTarget();
    pEEInfoOut->offsetOfInlinedCallFrameReturnAddress        = InlinedCallFrame::GetOffsetOfCallerReturnAddress();

    // Offsets into the Thread structure
    pEEInfoOut->offsetOfThreadFrame = Thread::GetOffsetOfCurrentFrame();
    pEEInfoOut->offsetOfGCState     = Thread::GetOffsetOfGCFlag();

    // Offsets into the method table.
    pEEInfoOut->offsetOfInterfaceTable = offsetof(MethodTable, m_pInterfaceVTableMap);

    // Delegate offsets
    pEEInfoOut->offsetOfDelegateInstance    = COMDelegate::GetOR()->GetOffset()        + sizeof(Object);
    pEEInfoOut->offsetOfDelegateFirstTarget = COMDelegate::GetMethodPtr()->GetOffset() + sizeof(Object);

    // Remoting offsets
    pEEInfoOut->offsetOfTransparentProxyRP = g_Mscorlib.GetFieldOffset(FIELD__TRANSPARENT_PROXY__RP);
    pEEInfoOut->offsetOfRealProxyServer    = g_Mscorlib.GetFieldOffset(FIELD__REAL_PROXY__SERVER);

#ifdef PLATFORM_CE
    pEEInfoOut->osType  = CORINFO_WINCE;
    pEEInfoOut->osMajor = 0;
    pEEInfoOut->osMinor = 0;
    pEEInfoOut->osBuild = 0;
#else // !PLATFORM_CE
#ifdef _X86_
    OSVERSIONINFO   sVerInfo;
    sVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    WszGetVersionEx(&sVerInfo);

    if (sVerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        pEEInfoOut->osType = CORINFO_WIN9x;
    else
        pEEInfoOut->osType = CORINFO_WINNT;

    pEEInfoOut->osMajor = sVerInfo.dwMajorVersion;
    pEEInfoOut->osMinor = sVerInfo.dwMinorVersion;
    pEEInfoOut->osBuild = sVerInfo.dwBuildNumber;
#else // !_X86_
    pEEInfoOut->osType  = CORINFO_WINNT;
    pEEInfoOut->osMajor = 0;
    pEEInfoOut->osMinor = 0;
    pEEInfoOut->osBuild = 0;
#endif // !_X86_
#endif // !PLATFORM_CE
    pEEInfoOut->noDirectTLS = (GetTLSAccessMode(GetThreadTLSIndex()) == TLSACCESS_GENERIC);

    STOP_NON_JIT_PERF();

    COOPERATIVE_TRANSITION_END();
}

    // Return details about EE internal data structures
DWORD __stdcall CEEInfo::getThreadTLSIndex(void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    return GetThreadTLSIndex();
}

const void * __stdcall CEEInfo::getInlinedCallFrameVptr(void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    return InlinedCallFrame::GetInlinedCallFrameFrameVPtr();
}

LONG * __stdcall CEEInfo::getAddrOfCaptureThreadGlobal(void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    return &g_TrapReturningThreads;
}

HRESULT __stdcall CEEInfo::GetErrorHRESULT()
{
    REQUIRES_4K_STACK;
    HRESULT hr;

    CANNOTTHROWCOMPLUSEXCEPTION();

    Thread *pCurThread = GetThread();
    BOOL toggleGC = !pCurThread->PreemptiveGCDisabled();

    if (toggleGC)
        pCurThread->DisablePreemptiveGC();

    OBJECTREF throwable = GetThread()->LastThrownObject();

    if (throwable == NULL)
        hr = S_OK;
    else
        hr = SecurityHelper::MapToHR(throwable);

    if (toggleGC)
        pCurThread->EnablePreemptiveGC();

    return hr;
}

CORINFO_CLASS_HANDLE __stdcall CEEInfo::GetErrorClass()
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    OBJECTREF throwable = GetThread()->LastThrownObject();

    if (throwable == NULL)
        return NULL;

    return (CORINFO_CLASS_HANDLE) TypeHandle(throwable->GetMethodTable()).AsPtr();
}



ULONG __stdcall CEEInfo::GetErrorMessage(LPWSTR buffer, ULONG bufferLength)
{
    ULONG result = 0;
    BEGIN_REQUIRES_4K_STACK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    OBJECTREF throwable = GetThread()->LastThrownObject();

    if (throwable != NULL)
    {
        COMPLUS_TRY
          {
              result = GetExceptionMessage(throwable, buffer, bufferLength);
          }
        COMPLUS_CATCH
          {
          }
        COMPLUS_END_CATCH
    }

    ENDCANNOTTHROWCOMPLUSEXCEPTION();


    END_CHECK_STACK;
    return result;
}

int __stdcall CEEInfo::FilterException(struct _EXCEPTION_POINTERS *pExceptionPointers) {

    REQUIRES_4K_STACK;
    unsigned code = pExceptionPointers->ExceptionRecord->ExceptionCode;

    if (COMPlusIsMonitorException(pExceptionPointers))
        return EXCEPTION_CONTINUE_EXECUTION;

#ifdef _DEBUG
    if (code == EXCEPTION_ACCESS_VIOLATION) {
        static int hit = 0;
        if (hit++ == 0) {
            _ASSERTE(!"Access violation while Jitting!");
            // If you set the debugger to catch access violations and 'go'
            // you will get back to the point at which the access violation occured
            return(EXCEPTION_CONTINUE_EXECUTION);
        }
        return(EXCEPTION_CONTINUE_SEARCH);
    }
#endif
    // No one should be catching breakpoint
    if (code == EXCEPTION_BREAKPOINT || code == STATUS_SINGLE_STEP)
        return(EXCEPTION_CONTINUE_SEARCH);

    if (code != EXCEPTION_COMPLUS)
        return(EXCEPTION_EXECUTE_HANDLER);

    // Don't catch ThreadStop exceptions

    int result;
    Thread *pCurThread = GetThread();
    BOOL toggleGC = !pCurThread->PreemptiveGCDisabled();

    if (toggleGC)
        pCurThread->DisablePreemptiveGC();

    OBJECTREF throwable = GetThread()->LastThrownObject();
    _ASSERTE(throwable != 0);

    GCPROTECT_BEGIN(throwable);

    if (IsUncatchable(&throwable))
        result = EXCEPTION_CONTINUE_SEARCH;
    else
        result = EXCEPTION_EXECUTE_HANDLER;

    GCPROTECT_END();

    if (toggleGC)
        pCurThread->EnablePreemptiveGC();

    return result;
}

CORINFO_MODULE_HANDLE __stdcall CEEInfo::embedModuleHandle(CORINFO_MODULE_HANDLE handle,
                                                             void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    return handle;
}

CORINFO_CLASS_HANDLE __stdcall CEEInfo::embedClassHandle(CORINFO_CLASS_HANDLE handle,
                                                           void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    return handle;
}

CORINFO_FIELD_HANDLE __stdcall CEEInfo::embedFieldHandle(CORINFO_FIELD_HANDLE handle,
                                                           void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    return handle;
}

CORINFO_METHOD_HANDLE __stdcall CEEInfo::embedMethodHandle(CORINFO_METHOD_HANDLE handle,
                                                             void **ppIndirection)
{
    REQUIRES_4K_STACK;
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    return handle;
}

CORINFO_GENERIC_HANDLE __stdcall CEEInfo::embedGenericHandle(
                    CORINFO_MODULE_HANDLE   module,
                    unsigned                metaTOK,
                    CORINFO_METHOD_HANDLE   context,
                    void                  **ppIndirection,
                    CORINFO_CLASS_HANDLE& tokenType)
{
    REQUIRES_4K_STACK;
    CORINFO_GENERIC_HANDLE ret;

    COOPERATIVE_TRANSITION_BEGIN();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    ret = findToken(module, metaTOK, context, tokenType);
    COOPERATIVE_TRANSITION_END();
    return ret;
}

/*********************************************************************/

HCIMPL2(CORINFO_MethodPtr, JIT_EnCResolveVirtual, void * obj, CORINFO_METHOD_HANDLE method)
{
#ifdef EnC_SUPPORTED
    THROWSCOMPLUSEXCEPTION();

    CORINFO_MethodPtr   addr;

    HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();    // Set up a frame
    if (obj == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

    MethodDesc* pMD = (MethodDesc*) method;
    EditAndContinueModule *pModule = (EditAndContinueModule*)pMD->GetModule();
    _ASSERTE(pModule->IsEditAndContinue());
    addr = (CORINFO_MethodPtr)pModule->ResolveVirtualFunction(ObjectToOBJECTREF((Object*) obj), pMD);
    _ASSERTE(addr);

    HELPER_METHOD_FRAME_END_POLL();
    return addr;
#else // !EnC_SUPPORTED
    return NULL;
#endif // EnC_SUPPORTED
}
HCIMPLEND

/*********************************************************************/
// Returns the address of the field in the object (This is an interior
// pointer and the caller has to use it appropriately). obj can be
// either a reference or a byref

HCIMPL2(void*, JIT_GetFieldAddr, Object * obj, EnCFieldDesc* pFD)
{
    if (GetThread()->CatchAtSafePoint())  {
        HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_1(Frame::FRAME_ATTR_RETURN_INTERIOR, obj);
        CommonTripThread(); 
        HELPER_METHOD_FRAME_END();
    }

    void * fldAddr = NULL;
    _ASSERTE(pFD->GetMethodTableOfEnclosingClass()->GetClass()->GetMethodTable() == pFD->GetMethodTableOfEnclosingClass());

    // If obj is a byref, it will never be null.
    // @TODO : Should GetAddress() be doing the null pointer check
    if (obj == NULL)
        FCThrow(kNullReferenceException);

    OBJECTREF or = ObjectToOBJECTREF(obj);
    if(or->GetMethodTable()->IsTransparentProxyType())
    {
        or = CRemotingServices::GetObjectFromProxy(or, FALSE);
        if (or->GetMethodTable()->IsTransparentProxyType())
            FCThrow(kInvalidOperationException);
    }

#ifdef EnC_SUPPORTED
    if (pFD->IsEnCNew()) 
    {
        EditAndContinueModule *pModule = (EditAndContinueModule*)pFD->GetModule();
        _ASSERTE(pModule->IsEditAndContinue());
        HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_NOPOLL(Frame::FRAME_ATTR_RETURN_INTERIOR);

        fldAddr = (void *)pModule->ResolveField(or, pFD, TRUE);
        HELPER_METHOD_FRAME_END();
    }
    else 
#endif // EnC_SUPPORTED
    {
        fldAddr = pFD->GetAddress(OBJECTREFToObject(or));
        _ASSERTE(or->GetMethodTable()->IsMarshaledByRef() || pFD->IsDangerousAppDomainAgileField());
    }

    return fldAddr;
}
HCIMPLEND

/*********************************************************************/

int CEEJitInfo::doAssert(const char* szFile, int iLine, const char* szExpr)
{
#ifdef _DEBUG
    return(_DbgBreakCheck(szFile, iLine, szExpr));
#else
    return(true);   // break into debugger
#endif
}

BOOL __cdecl CEEJitInfo::logMsg(unsigned level, const char* fmt, va_list args) {
#ifdef LOGGING
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(GetThread()->PreemptiveGCDisabled());  // can be used with FJIT codeLog to quickly locallize the problem

    if (LoggingOn(LF_JIT, level)) 
    {
        LogSpewValist(LF_JIT, level, (char*) fmt, args);
        return(true);
    }
#endif // LOGGING
    return false;
}

static OBJECTHANDLE __stdcall ConstructStringLiteral(CORINFO_MODULE_HANDLE scopeHnd, mdToken metaTok)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(TypeFromToken(metaTok) == mdtString);

    Module* module = GetModule(scopeHnd);
    EEStringData strData;

    module->ResolveStringRef(metaTok, &strData);

    OBJECTHANDLE string;
    // Retrieve the string from the AppDomain.

    BEGIN_ENSURE_COOPERATIVE_GC();

    string = (OBJECTHANDLE)module->GetAssembly()->Parent()->GetStringObjRefPtrFromUnicodeString(&strData);

    END_ENSURE_COOPERATIVE_GC();

    return string;
}

LPVOID __stdcall CEEInfo::constructStringLiteral(CORINFO_MODULE_HANDLE scopeHnd,
                                                 mdToken metaTok,
                                                 void **ppIndirection)
{
    REQUIRES_4K_STACK;
    LPVOID result;

    COOPERATIVE_TRANSITION_BEGIN();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    result = (LPVOID)ConstructStringLiteral(scopeHnd, metaTok); // throws

    COOPERATIVE_TRANSITION_END();
    return result;
}

/*********************************************************************/

HRESULT __stdcall CEEJitInfo::allocMem (
            ULONG               codeSize,
            ULONG               roDataSize,
            ULONG               rwDataSize,
            void **             codeBlock,
            void **             roDataBlock,
            void **             rwDataBlock
            )
{
    size_t  roDataExtra = 0;
    size_t  rwDataExtra = 0;

     CANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();

#define ALIGN_UP(val,align)     (ULONG)((align - ((size_t) val & (align - 1))) & (align - 1))

#ifdef _X86_

    // As per Intel Optimization Manual the cache line size is 32 bytes
#define CACHE_LINE_SIZE 32

    if (roDataSize > 0)
    {
        // Make sure that the codeSize a multiple of 4
        // This will insure that the first byte of
        // the roDataSize will be 4 byte aligned.
        codeSize += ALIGN_UP(codeSize, 4);

        if (roDataSize >= 8)
        {
            // allocates an extra 4 bytes so that we can
            // double word align the roData section.
            roDataExtra = 4;
        }
    }
    if (rwDataSize > 0)
    {
        // Make sure that the codeSize a multiple of 4
        codeSize   += ALIGN_UP(codeSize, 4);
        // Make sure that the roDataSize a multiple of 4
        roDataSize += ALIGN_UP(roDataSize, 4);
        // Make sure that the rwDataSize a full cache line
        rwDataSize += ALIGN_UP(rwDataSize, CACHE_LINE_SIZE);

        // We also need to make sure that the rwData section
        // starts on a new cache line
        rwDataExtra = (CACHE_LINE_SIZE - 4);
    }
#endif

    size_t totalSize = codeSize + roDataSize + roDataExtra
                                + rwDataSize + rwDataExtra;

    _ASSERTE(m_CodeHeader == 0);
    m_CodeHeader = m_jitManager->allocCode(m_FD,totalSize);

    if (!m_CodeHeader)
    {
        STOP_NON_JIT_PERF();
        return(E_FAIL);
    }

    // @TODO: The following is a hack to be removed shortly
    BYTE* start = ((EEJitManager*)m_jitManager)->JitToken2StartAddress((METHODTOKEN)m_CodeHeader);
    BYTE* current = start;

    *codeBlock = start;
    current += codeSize;

#ifdef _X86_
    /* Do we need to 8-byte align the roData section? */
    if (roDataSize >= 8)
    {
        size_t amount = ALIGN_UP(current, 8);
        _ASSERTE(amount <= roDataExtra);
        current += amount;
    }
#endif

    *roDataBlock = current;
    current += roDataSize;

#ifdef _X86_
    /* Do we need to cache line align the rwData section? */
    if (rwDataSize > 0)
    {
        size_t amount = ALIGN_UP(current, CACHE_LINE_SIZE);
        _ASSERTE(amount <= rwDataExtra);
        current     += amount;
    }
#endif

    *rwDataBlock = current;
    current += rwDataSize;

    _ASSERTE(((size_t) (current - start)) <= totalSize);

    STOP_NON_JIT_PERF();
    return(S_OK);
}

/*********************************************************************/
HRESULT __stdcall CEEJitInfo::allocGCInfo (ULONG size, void ** block)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();

    _ASSERTE(m_CodeHeader != 0);
    _ASSERTE(m_CodeHeader->phdrJitGCInfo == 0);
    *block = m_jitManager->allocGCInfo(m_CodeHeader,(DWORD)size);
    if (!*block)
    {
        STOP_NON_JIT_PERF();
        return(E_FAIL);
    }

    _ASSERTE(m_CodeHeader->phdrJitGCInfo != 0 && *block == m_CodeHeader->phdrJitGCInfo);

    STOP_NON_JIT_PERF();
    return S_OK;
}

/*********************************************************************/
HRESULT __stdcall CEEJitInfo::setEHcount (
        unsigned      cEH)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();

    _ASSERTE(cEH != 0);
    _ASSERTE(m_CodeHeader != 0);
    _ASSERTE(m_CodeHeader->phdrJitEHInfo == 0);
    EE_ILEXCEPTION* ret = m_jitManager->allocEHInfo(m_CodeHeader,cEH);
    if (!ret)
    {
        STOP_NON_JIT_PERF();
        return(E_FAIL);
    }
    _ASSERTE(m_CodeHeader->phdrJitEHInfo != 0 && m_CodeHeader->phdrJitEHInfo->EHCount() == cEH);

    STOP_NON_JIT_PERF();
    return(S_OK);
}

/*********************************************************************/
void __stdcall CEEJitInfo::setEHinfo (
        unsigned      EHnumber,
        const CORINFO_EH_CLAUSE* clause)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();
    // TODO Fix make the Code Manager EH clauses EH_INFO+
    _ASSERTE(m_CodeHeader->phdrJitEHInfo != 0 && EHnumber < m_CodeHeader->phdrJitEHInfo->EHCount());

    m_CodeHeader->phdrJitEHInfo->Clauses[EHnumber].TryOffset     = clause->TryOffset;
    m_CodeHeader->phdrJitEHInfo->Clauses[EHnumber].TryLength     = clause->TryLength;
    m_CodeHeader->phdrJitEHInfo->Clauses[EHnumber].HandlerOffset = clause->HandlerOffset;
    m_CodeHeader->phdrJitEHInfo->Clauses[EHnumber].HandlerLength = clause->HandlerLength;
    m_CodeHeader->phdrJitEHInfo->Clauses[EHnumber].ClassToken    = clause->ClassToken;
    m_CodeHeader->phdrJitEHInfo->Clauses[EHnumber].Flags                 = (CorExceptionFlag)clause->Flags;

    STOP_NON_JIT_PERF();
}

/*********************************************************************/
// get individual exception handler
void __stdcall CEEJitInfo::getEHinfo(
            CORINFO_METHOD_HANDLE ftn,                      /* IN  */
            unsigned      EHnumber,                 /* IN */
            CORINFO_EH_CLAUSE* clause)                  /* OUT */
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    START_NON_JIT_PERF();

    _ASSERTE(ftn == CORINFO_METHOD_HANDLE(m_FD));  // For now only support if the method being jitted
    _ASSERTE(m_ILHeader->EH);
    _ASSERTE(EHnumber < m_ILHeader->EH->EHCount());

    // These two structures should be identical, this is a spot check
    // TODO when file format cor.h stuff has been factored, we can make these structs the same
    _ASSERTE(sizeof(CORINFO_EH_CLAUSE) == sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
    _ASSERTE(offsetof(CORINFO_EH_CLAUSE, TryLength) == offsetof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT, TryLength));

    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehClause = (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*) clause;

    const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehInfo;
    ehInfo = m_ILHeader->EH->EHClause(EHnumber, ehClause);
    if (ehInfo != ehClause)
        *ehClause = *ehInfo;

    STOP_NON_JIT_PERF();
}

CorInfoHelpFunc CEEJitInfo::getNewHelper (CORINFO_CLASS_HANDLE newClsHnd, CORINFO_METHOD_HANDLE context)
{
    THROWSCOMPLUSEXCEPTION();     

    return CEEInfo::getNewHelper (newClsHnd, context == NULL ? CORINFO_METHOD_HANDLE(m_FD) : context);
}

extern int DumpCurrentStack();

/*********************************************************************/

 
CorJitResult CallCompileMethodWithSEHWrapper(IJitManager *jitMgr,
                                ICorJitInfo *comp,
                                struct CORINFO_METHOD_INFO *info,
                                unsigned flags,
                                BYTE **nativeEntry,
                                ULONG *nativeSizeOfCode,
                                bool debuggerTrackJITInfo,
                                MethodDesc *ftn)
{
    CorJitResult res = CORJIT_INTERNALERROR;

    // debuggerTrackJITInfo is only to be used to determine whether or not
    // to communicate with the debugger, NOT with how to generate code - use
    // flags for code gen, instead.

    __try
    {
#ifdef DEBUGGING_SUPPORTED
        if (debuggerTrackJITInfo || CORDebuggerAttached())
            g_pDebugInterface->JITBeginning(ftn, debuggerTrackJITInfo);
#endif

        res = jitMgr->m_jit->compileMethod(comp, info, flags,
            nativeEntry, nativeSizeOfCode);
    }
    __finally
    {
#ifdef DEBUGGING_SUPPORTED
        if (res == CORJIT_OK)
        {
            // Notify the debugger that we have successfully jitted the function

            if (debuggerTrackJITInfo || CORDebuggerAttached())
                g_pDebugInterface->JITComplete(ftn, 
                                               jitMgr->GetNativeEntry(*nativeEntry), 
                                               *nativeSizeOfCode,
                                               debuggerTrackJITInfo);
            if (CORDebuggerAttached())
                g_pDebugInterface->FunctionStubInitialized(ftn,
                                                           jitMgr->GetNativeEntry(*nativeEntry));
        }
        else if (ftn->IsJitted())
        {
            // This is the case where we aborted the jit because of a deadlock cycle
            // in initClass.  Nothing to do here (don't need to notify the debugger
            // because the function has already been successfully jitted)
        }
        else
        {
            if (debuggerTrackJITInfo)
            {
                LOG((LF_CORDB,LL_INFO10000, "FUDW: compileMethod threw an exception, and"
                     " FilterUndoDebuggerWork is backing out the DebuggerJitInfo! ("
                     "JITInterface.cpp"));
                g_pDebugInterface->JITComplete(ftn, 0, 0, debuggerTrackJITInfo);
            }
        }
#endif // DEBUGGING_SUPPORTED
    }

    return res;
}

/*********************************************************************/

Stub* JITFunction(MethodDesc* ftn, COR_ILMETHOD_DECODER* ILHeader, BOOL *fEJit, DWORD flags)
{
    Stub *ret = 0;

    THROWSCOMPLUSEXCEPTION();

    REQUIRES_16K_STACK;

    COOPERATIVE_TRANSITION_BEGIN();

    IJitManager *jitMgr = NULL;

    *fEJit = FALSE;
    // Has the user configured us to not JIT the method?
    if (g_pConfig->ShouldJitMethod(ftn))
    {
        // For the given flags see if we have a
        jitMgr = ExecutionManager::GetJitForType(miManaged|miIL);
        if (!jitMgr || !jitMgr->m_jit)
        {
            // if we fail to load a jit then try the ejit!
            jitMgr = ExecutionManager::GetJitForType(miManaged_IL_EJIT);
            if (!jitMgr || !jitMgr->m_jit)
                goto exit;
            *fEJit = TRUE;
        }
    }
    else if (g_pConfig->ShouldEJitMethod(ftn))
    {
        // For the given flags see if we have a
        jitMgr = ExecutionManager::GetJitForType(miManaged_IL_EJIT);
        if (!jitMgr || !jitMgr->m_jit)
            goto exit;
        *fEJit = TRUE;

    }
    else
        goto exit;

    {

// The following displays jitting methods for debug builds.
// This will aid in debugging on Windows CE.
// @TODO: Qualify the display with (DEBUG) when WinCE is stable
#if defined(PLATFORM_CE) //&& defined(DEBUG)
    LPCUTF8 cls  = ftn->GetClass() ? ftn->GetClass()->m_szDebugClassName
                                   : "GlobalFunction";
    LPCUTF8 name = ftn->GetName();
    DWORD dwCls = strlen(cls)+1;
    DWORD dwName = strlen(name)+1;

    CQuickBytes qb;
    LPWSTR wszCls = (LPWSTR) qb.Alloc(dwCls * sizeof(WCHAR));
    CQuickBytes qb2;
    LPWSTR wszName = (LPWSTR) qb2.Alloc(dwName * sizeof(WCHAR));

    WszMultiByteToWideChar(CP_UTF8,0,cls,-1,wszCls,dwCls);
    WszMultiByteToWideChar(CP_UTF8,0,name,-1,wszName,dwName);
    RETAILMSG(1,(L"Jitting method %s::%s\n",wszCls,wszName));
//    if (!_stricmp(cls,"Cb1456GetClass") &&
//       (!_stricmp(name,"runTest")))
//       DebugBreak();
#endif // PLATFORM_CE

#ifdef _DEBUG
    // This is here so we can see the name and class easily in the debugger

    LPCUTF8 cls  = ftn->GetClass() ? ftn->GetClass()->m_szDebugClassName
                                   : "GlobalFunction";
    LPCUTF8 name = ftn->GetName();

    // Set these up for the LOG() calls
    bool           isOptIl = FALSE;

    LOG((LF_JIT, LL_INFO1000, "{ Jitting method %s::%s  %s\n",cls,name, ftn->m_pszDebugMethodSignature));
#if 0
    if (!_stricmp(cls,"ENC") &&
       (!_stricmp(name,"G")))
    {
       static count = 0;
       count++;
       if (count > 0)
            DebugBreak();
    }
#endif

#endif // _DEBUG

    bool debuggerTrackJITInfo = false;

#ifdef DEBUGGING_SUPPORTED
    DWORD dwDebugBits = ftn->GetModule()->GetDebuggerInfoBits();
    debuggerTrackJITInfo = CORDebuggerTrackJITInfo(dwDebugBits) || CORProfilerJITMapEnabled();
#endif // DEBUGGING_SUPPORTED

    CORINFO_METHOD_INFO methodInfo;
    methodInfo.ftn = CORINFO_METHOD_HANDLE(ftn);
    methodInfo.scope = GetScopeHandle(ftn);
    methodInfo.ILCode = const_cast<BYTE*>(ILHeader->Code);
    methodInfo.ILCodeSize = ILHeader->CodeSize;
    methodInfo.maxStack = ILHeader->MaxStack;
    methodInfo.EHcount = ILHeader->EHCount();
    _ASSERTE(CORINFO_OPT_INIT_LOCALS == CorILMethod_InitLocals);
    methodInfo.options = (CorInfoOptions) ILHeader->Flags;


    // fetch the method signature
    HRESULT hr = ConvToJitSig(ftn->GetSig(), GetScopeHandle(ftn), mdTokenNil, &methodInfo.args, false);
    _ASSERTE(SUCCEEDED(hr));

            // method attributes and signature are consistant
    _ASSERTE( (IsMdStatic(ftn->GetAttrs()) == 0) == ((methodInfo.args.callConv & CORINFO_CALLCONV_HASTHIS) != 0) );

    // And its local variables
    hr = ConvToJitSig(ILHeader->LocalVarSig, GetScopeHandle(ftn), mdTokenNil, &methodInfo.locals, true);
    _ASSERTE(SUCCEEDED(hr));

    CEEJitInfo jitInfo(ftn, ILHeader, jitMgr);
    SLOT nativeEntry;
    ULONG sizeOfCode;
    CorJitResult res;

#ifdef DEBUGGING_SUPPORTED
    if (debuggerTrackJITInfo || CORProfilerDisableOptimizations())
    {
        flags |= CORJIT_FLG_DEBUG_INFO;

        if ((CORDebuggerTrackJITInfo(dwDebugBits) && !CORDebuggerAllowJITOpts(dwDebugBits)) || CORProfilerDisableOptimizations())
            flags |= CORJIT_FLG_DEBUG_OPT;

#ifdef EnC_SUPPORTED
        if (CORDebuggerEnCMode(dwDebugBits))
            flags |= CORJIT_FLG_DEBUG_EnC;
#endif // EnC_SUPPORTED
    }
#endif // DEBUGGING_SUPPORTED

#ifdef PROFILING_SUPPORTED
    if (CORProfilerTrackEnterLeave())
        flags |= CORJIT_FLG_PROF_ENTERLEAVE;

    if (CORProfilerTrackTransitions())
        flags |= CORJIT_FLG_PROF_NO_PINVOKE_INLINE;

    if (CORProfilerInprocEnabled())
        flags |= CORJIT_FLG_PROF_INPROC_ACTIVE;
#endif // PROFILING_SUPPORTED

    /*
    // NYI
    if (IsProfilingCallRet())
        flags |= CORJIT_FLG_PROF_CALLRET;
    */

    if (g_pConfig->GenLooseExceptOrder())
        flags |= CORJIT_FLG_LOOSE_EXCEPT_ORDER;

    // Set optimization flags

    unsigned optType = g_pConfig->GenOptimizeType();
    assert(optType <= OPT_RANDOM);

    if (optType == OPT_RANDOM)
        optType = methodInfo.ILCodeSize % OPT_RANDOM;

#ifdef _DEBUG
    if (g_pConfig->GenDebugInfo())
    {
        flags |= CORJIT_FLG_DEBUG_INFO;
        debuggerTrackJITInfo = true;
    }
    
    if (g_pConfig->GenDebuggableCode())
        flags |= CORJIT_FLG_DEBUG_OPT;
#endif

    const static unsigned optTypeFlags[] =
    {
        0,                      // OPT_BLENDED
        CORJIT_FLG_SIZE_OPT,    // OPT_CODE_SIZE
        CORJIT_FLG_SPEED_OPT    // OPT_CODE_SPEED
    };

    assert(optType < OPT_RANDOM);
    assert((sizeof(optTypeFlags)/sizeof(optTypeFlags[0])) == OPT_RANDOM);
    flags |= optTypeFlags[optType];
    flags |= g_pConfig->GetCpuFlag();
    flags |= g_pConfig->GetCpuCapabilities();

#ifdef _DEBUG
    if (g_pConfig->IsJitVerificationDisabled()) 
        flags |= CORJIT_FLG_SKIP_VERIFICATION;
#endif

    if (!(flags & CORJIT_FLG_IMPORT_ONLY) && Security::LazyCanSkipVerification(ftn->GetModule()))
        flags |= CORJIT_FLG_SKIP_VERIFICATION;


#if 0
    /* uncomment this if you want to selectively jit a descriptor */
    DWORD desc = (DWORD) ftn->GetDescr() - ftn->GetModule()->getBaseAddress();
    if (desc != 0x0001a0c8)
    {
        res = CORJIT_SKIPPED;
    }
    else
#endif // 0
    {
        /* There is a double indirection to call compilemethod  - can we
           improve this with the new structure? */

#if defined(ENABLE_PERF_COUNTERS)
        START_JIT_PERF();
#endif
        StartCAP();

#if defined(ENABLE_PERF_COUNTERS)
        LARGE_INTEGER CycleStart;
        QueryPerformanceCounter (&CycleStart);
#endif // ENABLE_PERF_COUNTERS

        CommonTripThread();         // Indicate we are at a GC safe point

        // Note on debuggerTrackInfo arg: if we're only importing (ie, verifying/
        // checking to make sure we could JIT, but not actually generating code (
        // eg, for inlining), then DON'T TELL THE DEBUGGER about this.
        res = CallCompileMethodWithSEHWrapper(jitMgr, 
                                              &jitInfo, 
                                              &methodInfo, 
                                              flags,
                                              &nativeEntry, 
                                              &sizeOfCode,
                                              (flags & CORJIT_FLG_IMPORT_ONLY)?false:debuggerTrackJITInfo,
                                              (MethodDesc*)ftn);

#if defined(ENABLE_PERF_COUNTERS)
        LARGE_INTEGER CycleStop;
        QueryPerformanceCounter(&CycleStop);

        GetPrivatePerfCounters().m_Jit.timeInJit = (CycleStop.QuadPart - CycleStart.QuadPart);
        GetGlobalPerfCounters().m_Jit.timeInJit = (CycleStop.QuadPart - CycleStart.QuadPart);

        GetPrivatePerfCounters().m_Jit.timeInJitBase = (CycleStop.QuadPart - g_lastTimeInJitCompilation.QuadPart);
        GetGlobalPerfCounters().m_Jit.timeInJitBase = (CycleStop.QuadPart - g_lastTimeInJitCompilation.QuadPart);
        g_lastTimeInJitCompilation = CycleStop;
                
        GetPrivatePerfCounters().m_Jit.cMethodsJitted++;
        GetGlobalPerfCounters().m_Jit.cMethodsJitted++;

        GetPrivatePerfCounters().m_Jit.cbILJitted+=methodInfo.ILCodeSize;
        GetGlobalPerfCounters().m_Jit.cbILJitted+=methodInfo.ILCodeSize;
#endif // ENABLE_PERF_COUNTERS

        StopCAP();
#if defined(ENABLE_PERF_COUNTERS)
        STOP_JIT_PERF();
#endif

    }
    LOG((LF_JIT, LL_INFO1000, "Done Jitting method %s::%s  %s }\n",cls,name, ftn->m_pszDebugMethodSignature));

    if (flags & CORJIT_FLG_IMPORT_ONLY) {
        if (SUCCEEDED(res))
            ftn->SetIsVerified(TRUE);       // We only cared about the success and the side effect of setting 'Not Inline'
        goto done;
    }
    
    if (!SUCCEEDED(res))
    {
        COUNTER_ONLY(GetPrivatePerfCounters().m_Jit.cJitFailures++);
        COUNTER_ONLY(GetGlobalPerfCounters().m_Jit.cJitFailures++);

#ifdef _DEBUG
        MethodDesc* method  = (MethodDesc*) ftn;
        if (res != CORJIT_SKIPPED)
            LOG((LF_JIT, LL_WARNING,
                 "WARNING: Refused to %sJit method %s::%s%s\n",
                 (isOptIl ? "OptJit" : "Jit"), cls, name, ftn->m_pszDebugMethodSignature));
#endif // _DEBUG

        // For untrusted assemblies, throw an invalid program exception. can't use the
        // FJIT since it has not been verified.  

        if (((flags & CORJIT_FLG_SKIP_VERIFICATION) == 0) &&
            (Security::CanSkipVerification(ftn->GetModule()) == FALSE))
            goto exit;
    
        if (res == CORJIT_BADCODE)
            goto exit;

#ifdef _DEBUG
        if (*fEJit == FALSE && res != CORJIT_SKIPPED && g_pConfig->IsJitRequired())
            _ASSERTE(!"Refuse to JIT the method, press ignore to run the EJIT");
#endif // _DEBUG

        if (*fEJit != FALSE)            // EJIT failed.  bail!
        {
                _ASSERTE(!"FJIT failed");
                goto exit;
        }

        // The main jit failed - so we now try to Econo-JIT if this is straight-IL
        if (g_pConfig->ShouldEJitMethod(ftn))
        {
            jitMgr = ExecutionManager::GetJitForType(miManaged_IL_EJIT);
            if (!jitMgr || !jitMgr->m_jit)
                goto exit;
            CEEJitInfo ejitInfo(ftn, ILHeader, jitMgr);

            // See other call to CallCompileMethodWithSEHWrapper for explanation
            // of debuggerTrackInfo arg.
            res = CallCompileMethodWithSEHWrapper(jitMgr,
                                                  &ejitInfo, 
                                                  &methodInfo, 
                                                  flags,
                                                  &nativeEntry, 
                                                  &sizeOfCode,
                                                  (flags & CORJIT_FLG_IMPORT_ONLY)?false:debuggerTrackJITInfo,
                                                  (MethodDesc*)ftn);

            if (SUCCEEDED(res))
            {
                // We were able to FJIT this method - So we need to set the implflags to EJIT
                *fEJit = TRUE;
            }
            else
            {
#ifdef _DEBUG
                MethodDesc* method  = (MethodDesc*) ftn;
                LOG((LF_JIT, LL_WARNING,
                     "WARNING: Refused to Econo-Jit method %s::%s%s\n",
                      cls, name, ftn->m_pszDebugMethodSignature));
#endif // _DEBUG
                if (ejitInfo.m_CodeHeader)
                    jitMgr->RemoveJitData((METHODTOKEN) (ejitInfo.m_CodeHeader));

                if (res == CORJIT_OUTOFMEM)
                    COMPlusThrowOM();

                goto exit;
            }
        }
        else
        {
            if (jitInfo.m_CodeHeader)
                jitMgr->RemoveJitData((METHODTOKEN) (jitInfo.m_CodeHeader));

            goto exit;
        }
    }

    MethodDesc* method  = (MethodDesc*) ftn;
#ifdef _WIN64
    LOG((LF_JIT, LL_INFO1000,
        "%s Jitted Entry %16x method %s::%s %s\n",
        (isOptIl ? "OptJit" : (*fEJit? "Ejit" : "Jit")), nativeEntry, cls, name, ftn->m_pszDebugMethodSignature));
#else // !_WIN64
    LOG((LF_JIT, LL_INFO1000,
        "%s Jitted Entry %08x method %s::%s %s\n",
        (isOptIl ? "OptJit" : (*fEJit? "Ejit" : "Jit")), nativeEntry, cls, name, ftn->m_pszDebugMethodSignature));
#endif // _WIN64
    // @todo remove the following
    //if (!_stricmp(name,"GetHash")) {
    //    DebugBreak();
    //}

#ifdef VTUNE_STATS
    extern LPCUTF8 NameForMethodDesc(UINT_PTR pMD);
    extern MethodDesc* IP2MD(ULONG_PTR IP);
    extern LPCUTF8 ClassNameForMethodDesc(UINT_PTR pMD);
    MethodDesc* meth = IP2MD ((ULONG_PTR)nativeEntry);

    WCHAR dumpMethods[3];

    if (WszGetEnvironmentVariable(L"DUMP_METHODS", dumpMethods, 2))
    {
        printf("VtuneStats %s::%s 0x%x\n", ClassNameForMethodDesc((UINT_PTR)meth), NameForMethodDesc((UINT_PTR)meth), nativeEntry);
    }
#endif // VTUNE_STATS

    ret = (Stub*)nativeEntry;
    }
exit:
    if (!ret)
        COMPlusThrow(kInvalidProgramException);

done:
    COOPERATIVE_TRANSITION_END();
    return ret;
}

/*********************************************************************/

//
// Table loading functions
//

HRESULT LoadEEInfoTable(Module *currentModule,
                        CORCOMPILE_EE_INFO_TABLE *table,
                        SIZE_T tableSize)
{
    _ASSERTE(tableSize >= sizeof(CORCOMPILE_EE_INFO_TABLE));

    //
    // Fill in dynamic EE Info values
    //

    table->inlinedCallFrameVptr = InlinedCallFrame::GetInlinedCallFrameFrameVPtr();
    table->addrOfCaptureThreadGlobal = &g_TrapReturningThreads;
    table->threadTlsIndex = GetThreadTLSIndex();
    table->module = (CORINFO_MODULE_HANDLE) currentModule;

    //
    // Fill in TLS index for rva statics, if appropriate.
    //

    IMAGE_TLS_DIRECTORY *pTLSDirectory
      = currentModule->GetPEFile()->GetTLSDirectory();
    if (pTLSDirectory == NULL)
        table->rvaStaticTlsIndex = 0;
    else
        table->rvaStaticTlsIndex = *(DWORD*)(size_t)(pTLSDirectory->AddressOfIndex);

    return S_OK;
}

HRESULT LoadHelperTable(Module *currentModule,
                        void **table,
                        SIZE_T tableSize)
{
    void **value = table;
    void **valueEnd = (void **) (((BYTE*)table) + tableSize);

    _ASSERTE(valueEnd <= value + CORINFO_HELP_COUNT);

    //
    // Fill in helpers
    //

    VMHELPDEF *hlpFunc = hlpFuncTable;

    while (value < valueEnd)
        *value++ = hlpFunc++->pfnHelper;

    return S_OK;
}

static size_t HandleTokenLoader(Module *currentModule, Module *pInfoModule, ICorCompileInfo *info,
                                BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    switch (CEECompileInfo::GetEncodedType(pBlob))
    {
    case CEECompileInfo::ENCODE_TYPE_SIG:
        return (size_t) 
          CORINFO_CLASS_HANDLE(CEECompileInfo::DecodeClass(pInfoModule, pBlob).AsPtr());

    case CEECompileInfo::ENCODE_METHOD_TOKEN:
    case CEECompileInfo::ENCODE_METHOD_SIG:
        return (size_t) CEECompileInfo::DecodeMethod(pInfoModule, pBlob);

    case CEECompileInfo::ENCODE_FIELD_TOKEN:
    case CEECompileInfo::ENCODE_FIELD_SIG:
        return (size_t) CEECompileInfo::DecodeField(pInfoModule, pBlob);

    case CEECompileInfo::ENCODE_STRING_TOKEN:
    {
            size_t result;

            EEStringData strData;
            CEECompileInfo::DecodeString(pInfoModule, pBlob, &strData);

            BEGIN_ENSURE_COOPERATIVE_GC();

            result = (size_t) currentModule->GetDomain()->GetStringObjRefPtrFromUnicodeString(&strData);
            END_ENSURE_COOPERATIVE_GC();

            return result;
    }

    default:
        _ASSERTE(!"Bad blob type in handle table");
        return NULL;
    }
}

static size_t VarargsTokenLoader(Module *currentModule, Module *pInfoModule, 
                                 ICorCompileInfo *info, BYTE *pBlob)
{
    PCCOR_SIGNATURE sig = CEECompileInfo::DecodeSig(pInfoModule, pBlob);

    return (size_t) CORINFO_VARARGS_HANDLE(currentModule->GetVASigCookie(sig));
}

static size_t EntryPointTokenLoader(Module *currentModule, Module *pInfoModule, 
                                   ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc *pMethod = CEECompileInfo::DecodeMethod(pInfoModule, pBlob);
    InfoAccessType accessType = IAT_VALUE;

    void* ret = info->getFunctionFixedEntryPoint(CORINFO_METHOD_HANDLE(pMethod), &accessType);
    _ASSERTE(accessType==IAT_VALUE);

    return (size_t) ret;
}

static size_t FunctionPointerTokenLoader(Module *currentModule, Module *pInfoModule, 
                                        ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc *pMethod = CEECompileInfo::DecodeMethod(pInfoModule, pBlob);

    InfoAccessType accessType = IAT_PVALUE;
    void* ret = info->getFunctionEntryPoint(CORINFO_METHOD_HANDLE(pMethod), &accessType);
    _ASSERTE(accessType==IAT_PVALUE);
    return (size_t) ret;
}

static size_t SyncLockTokenLoader(Module *currentModule, Module *pInfoModule, 
                                 ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle th = CEECompileInfo::DecodeClass(pInfoModule, pBlob);

    return (size_t) GetClassSync(th.AsMethodTable());
}

static size_t PInvokeTargetTokenLoader(Module *currentModule, Module *pInfoModule, 
                                      ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc *pMethod = CEECompileInfo::DecodeMethod(pInfoModule, pBlob);

    _ASSERTE(pMethod->IsNDirect());
    NDirectMethodDesc *pMD = (NDirectMethodDesc*)pMethod;

    if (pMD->ndirect.m_pNDirectTarget == pMD->ndirect.m_ImportThunkGlue)
        pMD->DoPrestub(NULL);

    return (size_t) pMD->ndirect.m_pNDirectTarget;
}

static size_t IndirectPInvokeTargetTokenLoader(Module *currentModule, Module *pInfoModule, 
                                              ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc *pMethod = CEECompileInfo::DecodeMethod(pInfoModule, pBlob);

    return (size_t) info->getAddressOfPInvokeFixup(CORINFO_METHOD_HANDLE(pMethod));
}

static size_t ProfilingHandleTokenLoader(Module *currentModule, Module *pInfoModule, 
                                        ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc *pMethod = CEECompileInfo::DecodeMethod(pInfoModule, pBlob);

    BOOL bHookFunction;
    return (size_t) info->GetProfilingHandle(CORINFO_METHOD_HANDLE(pMethod), 
                                              &bHookFunction);
}

static size_t StaticFieldAddressTokenLoader(Module *currentModule, Module *pInfoModule, 
                                           ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    FieldDesc *pField = CEECompileInfo::DecodeField(pInfoModule, pBlob);

    return (size_t) info->getFieldAddress(CORINFO_FIELD_HANDLE(pField), NULL);
}

static size_t InterfaceTableOffsetTokenLoader(Module *currentModule, Module *pInfoModule, 
                                              ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle th = CEECompileInfo::DecodeClass(pInfoModule, pBlob);

    th.CheckRestore();

    CORINFO_CLASS_HANDLE classHandle = CORINFO_CLASS_HANDLE(th.AsPtr());

    return sizeof(void*) * (size_t)info->getInterfaceTableOffset(classHandle, NULL);
}

static size_t ClassDomainIDTokenLoader(Module *currentModule, Module *pInfoModule, 
                                       ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle th = CEECompileInfo::DecodeClass(pInfoModule, pBlob);

    CORINFO_CLASS_HANDLE classHandle = CORINFO_CLASS_HANDLE(th.AsPtr());

    return info->getClassDomainID(classHandle, NULL);
}

static size_t ClassConstructorTokenLoader(Module *currentModule, Module *pInfoModule, 
                                          ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle th = CEECompileInfo::DecodeClass(pInfoModule, pBlob);

    if (th.IsUnsharedMT())
    {
        OBJECTREF throwable = NULL;
        GCPROTECT_BEGIN(throwable);

        if (!th.AsMethodTable()->CheckRunClassInit(&throwable))
            COMPlusThrow(throwable);

        GCPROTECT_END();
    }

    return 0;
}

static size_t ClassRestoreTokenLoader(Module *currentModule, Module *pInfoModule, 
                                      ICorCompileInfo *info, BYTE *pBlob)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle th = CEECompileInfo::DecodeClass(pInfoModule, pBlob);

    th.CheckRestore();

    return 0;
}

typedef size_t (*TokenLoader)(Module *currentModule, Module *pInfoModule, 
                              ICorCompileInfo *info, BYTE *pBlob);

TokenLoader tokenLoaders[CORCOMPILE_TABLE_COUNT] =
{
    HandleTokenLoader,
    ClassConstructorTokenLoader,
    ClassRestoreTokenLoader,
    FunctionPointerTokenLoader,
    StaticFieldAddressTokenLoader,
    InterfaceTableOffsetTokenLoader,
    ClassDomainIDTokenLoader,
    EntryPointTokenLoader,
    SyncLockTokenLoader,
    PInvokeTargetTokenLoader,
    IndirectPInvokeTargetTokenLoader,
    ProfilingHandleTokenLoader,
    VarargsTokenLoader,
};

HRESULT LoadDynamicInfoEntry(Module *currentModule, Module *pInfoModule, BYTE *pBlob,
                             int tableIndex, DWORD *entry)
{
    *entry = tokenLoaders[tableIndex](currentModule, pInfoModule, GetCompileInfo(), pBlob);

    return S_OK;
}


/*********************************************************************/
HCIMPL2(Object *, JIT_StrCns, unsigned metaTok, CORINFO_MODULE_HANDLE scopeHnd)
{
    OBJECTHANDLE hndStr;

    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_NOPOLL(Frame::FRAME_ATTR_RETURNOBJ);
    HELPER_METHOD_POLL();

    // Retrieve the handle to the COM+ string object.
    hndStr = ConstructStringLiteral(scopeHnd, metaTok);
    HELPER_METHOD_FRAME_END();

    // Don't use ObjectFromHandle; this isn't a real handle
    return *(Object**)hndStr;
}
HCIMPLEND

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE

HCIMPL2(Object *, JITutil_IsInstanceOfBizarre, CORINFO_CLASS_HANDLE type, Object* obj)
{
    THROWSCOMPLUSEXCEPTION();

        // Null is an instance of any type
    //if (obj == NULL)
    //    return 0;
    _ASSERTE(obj != NULL);  // this check is done in the ASM helper

    TypeHandle clsHnd(type);
    _ASSERTE(!clsHnd.IsUnsharedMT() ||
             (clsHnd.IsUnsharedMT() && clsHnd.AsMethodTable()->GetClass()->IsInterface()));

    VALIDATEOBJECTREF(obj);
    MethodTable *pMT = obj->GetMethodTable();

    // any method table with an instance has been restored.
    _ASSERTE(pMT->GetClass()->IsRestored());

    // Since classes are handled in another helper, this can't happen.
    _ASSERTE(clsHnd != TypeHandle(pMT));

    if (pMT->IsThunking())
    {
        // TODO PERF: we don't have to erect a frame in cases for proxys
        // We can filter out some of these and only erect a frame in the
        // cases we really need it. 
        
        // Check whether the type represented by the proxy can be
        // cast to the given type
        HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_1(Frame::FRAME_ATTR_RETURNOBJ, obj);
        clsHnd.CheckRestore();
        if (!CRemotingServices::CheckCast(ObjectToOBJECTREF(obj), 
                clsHnd.AsMethodTable()->GetClass())) {
            obj = 0;
        }
        HELPER_METHOD_FRAME_END();
        return obj;
    }

    // If it is a class we can handle it all right here.
    // We have already checked for proxy. Code below can cause a GC, better
    // create a frame.
    if (clsHnd.IsUnsharedMT())
    {
        // Since non-interface classes are in another helper, this must be an interface.
        _ASSERTE(clsHnd.AsMethodTable()->GetClass()->IsInterface());

        // Differentiate between classic COM and managed object instances. In
        // the former case we might need to GC while determining whether the
        // interface is supported, so we'll need to build a frame and GC protect
        // the object reference.
        if (pMT->IsComObjectType())
        {
            HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_1(Frame::FRAME_ATTR_RETURNOBJ, obj);

            clsHnd.CheckRestore();
            if (!pMT->m_pEEClass->ComObjectSupportsInterface(OBJECTREF(obj), clsHnd.AsMethodTable()))
                obj = 0;
            HELPER_METHOD_FRAME_END();
        }
        else
        {
            // If the interface has not been restored then erect a helper frame to handle
            // exceptions and restore it.
            if (!clsHnd.AsMethodTable()->GetClass()->IsRestored())
            {
                HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_1(Frame::FRAME_ATTR_RETURNOBJ, obj);
                clsHnd.CheckRestore();
                HELPER_METHOD_FRAME_END();
                // Standard object type, no frame needed.
                if (!pMT->m_pEEClass->SupportsInterface(OBJECTREF(obj), clsHnd.AsMethodTable()))
                    obj = 0;
            }
            else
                obj = 0;

        }
    } 
    else {
        // We know that the clsHnd is an array so check the object.  If it is not an array return false.
        if (pMT->IsArray()) {
            ArrayBase* arrayObj = (ArrayBase*) OBJECTREFToObject(obj);
            // Check if both are SZARRAY and their typehandles match
            if (pMT->GetNormCorElementType() != ELEMENT_TYPE_SZARRAY ||
                clsHnd.GetNormCorElementType() != ELEMENT_TYPE_SZARRAY ||
                clsHnd.AsTypeDesc()->GetTypeParam() != arrayObj->GetElementTypeHandle())
            {
                ArrayTypeDesc objType(pMT, arrayObj->GetElementTypeHandle());
                HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_1(Frame::FRAME_ATTR_RETURNOBJ, obj);
                if (!objType.CanCastTo(clsHnd.AsArray()))
                    obj = 0;
                HELPER_METHOD_FRAME_END();
            }
        }
        else 
            obj = 0;
    }
    FC_GC_POLL_AND_RETURN_OBJREF(obj);
}
HCIMPLEND

// This is the failure & bizarre portion of JIT_ChkCast.  If the fast-path ASM case
// fails, we fall back here.
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE

HCIMPL2(Object *, JITutil_ChkCastBizarre, CORINFO_CLASS_HANDLE type, Object *obj)
{
        // Null is an instance of any type
    if (obj == NULL)
        return obj;

    // ChkCast is like isInstance trhow if null
    ENDFORBIDGC();
    obj = JITutil_IsInstanceOfBizarre(type, obj);
    if (obj != NULL)
        return(obj);

    FCThrow(kInvalidCastException);
}
HCIMPLEND

#define WriteBarrierIsPreGrow() (JIT_UP_WriteBarrierReg_Buf[0][10] == 0xc1)

BYTE JIT_UP_WriteBarrierReg_Buf[8][41]; // Executed copies of the thunk - 8 copies for 8 regs,
                                        // with copy 4 (ESP) unused

// Mark beginning of thunk buffer for EH checking
BYTE *JIT_WriteBarrier_Buf_Start = (BYTE *)JIT_UP_WriteBarrierReg_Buf;
// End of thunk buffer
BYTE *JIT_WriteBarrier_Buf_End = (BYTE *)JIT_UP_WriteBarrierReg_Buf + sizeof(JIT_UP_WriteBarrierReg_Buf);


/*********************************************************************/
// putting the framed helpers first
/*********************************************************************/
// A helper for JIT_MonEnter that is on the callee side of an ecall
// frame and handles cases that might allocate, throw or block.

HCIMPL1(void, JITutil_MonEnter,  Object* obj)
{
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    THROWSCOMPLUSEXCEPTION();
    obj->EnterObjMonitor();
    HELPER_METHOD_FRAME_END_POLL();
}
HCIMPLEND

/*********************************************************************/
// A helper for JIT_MonEnterStatic that is on the callee side of an ecall
// frame and handles cases that might allocate, throw or block.

HCIMPL1(void, JITutil_MonEnterStatic,  EEClass* pclass)
{
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    pclass->GetExposedClassObject()->EnterObjMonitor();
    HELPER_METHOD_FRAME_END_POLL();
}
HCIMPLEND

/*********************************************************************/
// A helper for JIT_MonTryEnter that is on the callee side of an ecall
// frame and handles cases that might allocate, throw or block.

HCIMPL2(BOOL, JITutil_MonTryEnter,  Object* obj, __int32 timeOut)
{
    BOOL ret;
    HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();
    THROWSCOMPLUSEXCEPTION();
    OBJECTREF objRef = ObjectToOBJECTREF(obj);
    ret = objRef->TryEnterObjMonitor(timeOut);
    HELPER_METHOD_FRAME_END_POLL();
    return(ret);
}
HCIMPLEND

#ifdef _DEBUG
#define _LOGCONTENTION
#endif // #ifdef _DEBUG

#ifdef  _LOGCONTENTION
inline void LogContention()
{
#ifdef LOGGING
    if (LoggingOn(LF_SYNC, LL_INFO100))
    {
        LogSpewAlways("Contention: Stack Trace Begin\n");
        void LogStackTrace();
        LogStackTrace();
        LogSpewAlways("Contention: Stack Trace End\n");
    }
#endif
}
#else
#define LogContention()
#endif

/*********************************************************************/
// A helper for JIT_MonEnter that is on the callee side of an ecall
// frame and handles the contention case.

HCIMPL2(void, JITutil_MonContention, AwareLock* awarelock, Thread* thread)
{
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    THROWSCOMPLUSEXCEPTION();

    COUNTER_ONLY(GetPrivatePerfCounters().m_LocksAndThreads.cContention++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_LocksAndThreads.cContention++);

    LogContention();
    Thread      *pCurThread = GetThread();
    OBJECTREF    obj = awarelock->GetOwningObject();
    bool    bEntered = false;

    // We cannot allow the AwareLock to be cleaned up underneath us by the GC.
    awarelock->IncrementTransientPrecious();

    GCPROTECT_BEGIN(obj);
    {
        pCurThread->EnablePreemptiveGC();

        // Try spinning and yielding before eventually blocking.
        // The limit of 10 is largely arbitrary - feel free to tune if you have evidence
        // you're making things better - petersol
        for (int iter = 0; iter < 10; iter++)
        {
            DWORD i = 50;
            do
            {
                if (awarelock->TryEnter())
                {
                    pCurThread->DisablePreemptiveGC();
                    bEntered = true;
                    goto entered;
                }

                if (g_SystemInfo.dwNumberOfProcessors <= 1)
                    break;

                // Delay by approximately 2*i clock cycles (Pentium III).
                // This is brittle code - future processors may of course execute this
                // faster or slower, and future code generators may eliminate the loop altogether.
                // The precise value of the delay is not critical, however, and I can't think
                // of a better way that isn't machine-dependent - petersol.
                int sum = 0;
                for (int delayCount = i; --delayCount; ) 
                {
                    sum += delayCount;
                    pause();            // indicate to the processor that we are spining 
                }
                if (sum == 0)
                {
                    // never executed, just to fool the compiler into thinking sum is live here,
                    // so that it won't optimize away the loop.
                    static char dummy;
                    dummy++;
                }

                // exponential backoff: wait 3 times as long in the next iteration
                i = i*3;
            }
            while (i < 20000*g_SystemInfo.dwNumberOfProcessors);

            pCurThread->DisablePreemptiveGC();
            pCurThread->HandleThreadAbort();
            pCurThread->EnablePreemptiveGC();

            __SwitchToThread(0);
        }

        // To make it easier to protect, Enter must always be called in cooperative
        // mode.
        pCurThread->DisablePreemptiveGC();
    }
entered:
    GCPROTECT_END();
    if (!bEntered)
    {
        awarelock->DecrementTransientPrecious();

        // We've tried hard to enter - we need to eventually block to avoid wasting too much cpu
        // time.
        awarelock->Enter();
    }


    // One way or another, we entered.
    HELPER_METHOD_FRAME_END_POLL();
}
HCIMPLEND

/*********************************************************************/
// A helper for JIT_MonExit and JIT_MonExitStatic that is on the
// callee side of an ecall frame and handles cases that might allocate,
// throw or block.

HCIMPL1(void, JITutil_MonExit,  AwareLock* lock)
{
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    THROWSCOMPLUSEXCEPTION();
    lock->Signal();
    HELPER_METHOD_FRAME_END_POLL();
}
HCIMPLEND

// A helper for JIT_MonExit to handle the rare case where one thread
// is exiting a lock while another has set the BIT_SBLK_SPIN_LOCK bit
// in the header to indicate that it's about to change the header.
// The thread exiting the lock can't just keep retrying, as we might be
// about to suspend threads for gc.

HCIMPL1(void, JITutil_MonExitThinLock,  Object* obj)
{
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    THROWSCOMPLUSEXCEPTION();

    // Rather than putting logic here that looks at the layout of the header and does the appropriate
    // thing, we force a sync block here. This is a perf compromise, but it's supposed to be rare case.
    obj->GetSyncBlock();
    obj->LeaveObjMonitor();

    HELPER_METHOD_FRAME_END_POLL();
}
HCIMPLEND

/*********************************************************************/
// When a GC happens, the upper and lower bounds of the ephemeral
// generation change.  This routine updates the WriteBarrier thunks
// with the new values.
void StompWriteBarrierEphemeral() {
#ifdef WRITE_BARRIER_CHECK
        // Don't do the fancy optimization if we are checking write barrier
    if (JIT_UP_WriteBarrierReg_Buf[0][0] == 0xE9)  // we are using slow write barrier
        return;
#endif

    // Update the lower bound.
    for (int reg = 0; reg < 8; reg++)
    {
        // assert there is in fact a cmp r/m32, imm32 there
        _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][2] == 0x81);

        // Update the immediate which is the lower bound of the ephemeral generation
        size_t *pfunc = (size_t *) &JIT_UP_WriteBarrierReg_Buf[reg][4];
        *pfunc = (size_t) g_ephemeral_low;
        if (!WriteBarrierIsPreGrow())
        {
            // assert there is in fact a cmp r/m32, imm32 there
            _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][10] == 0x81);

                // Update the upper bound if we are using the PostGrow thunk.
            pfunc = (size_t *) &JIT_UP_WriteBarrierReg_Buf[reg][12];
            *pfunc = (size_t) g_ephemeral_high;
        }
}
}

/*********************************************************************/
// When the GC heap grows, the ephemeral generation may no longer
// be after the older generations.  If this happens, we need to switch
// to the PostGrow thunk that checks both upper and lower bounds.
// regardless we need to update the thunk with the
// card_table - lowest_address.
void StompWriteBarrierResize(BOOL bReqUpperBoundsCheck)
{
#ifdef WRITE_BARRIER_CHECK
        // Don't do the fancy optimization if we are checking write barrier
    if (JIT_UP_WriteBarrierReg_Buf[0][0] == 0xE9)  // we are using slow write barrier
        return;
#endif


    bool bWriteBarrierIsPreGrow = WriteBarrierIsPreGrow();
    bool bStompWriteBarrierEphemeral = false;

    for (int reg = 0; reg < 8; reg++)
    {
        size_t *pfunc;

    // Check if we are still using the pre-grow version of the write barrier.
        if (bWriteBarrierIsPreGrow)
    {
        // Check if we need to use the upper bounds checking barrier stub.
        if (bReqUpperBoundsCheck)
        {
                Thread * pThread = GetThread();                        
                BOOL fToggle = (pThread != NULL) && (!pThread->PreemptiveGCDisabled());    
                if (fToggle) 
                    pThread->DisablePreemptiveGC();
                
                BOOL bEESuspended = FALSE;                        
                if( !GCHeap::IsGCInProgress()) {                	
                    bEESuspended = TRUE;             	
                    GCHeap::SuspendEE(GCHeap::SUSPEND_FOR_GC_PREP);        
                }    
        
            // Note: I use a pfunc temporary to avoid a WinCE internal compiler error
                pfunc = (size_t *) JIT_UP_WriteBarrierReg_PostGrow;
                memcpy(&JIT_UP_WriteBarrierReg_Buf[reg], pfunc, 39);

                // assert the copied code ends in a ret to make sure we got the right length
                _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][38] == 0xC3);
                
                // We need to adjust registers in a couple of instructions
                // It would be nice to have the template contain all zeroes for
                // the register fields (corresponding to EAX), but that doesn't
                // work because then we get a smaller encoding for the compares 
                // that only works for EAX but not the other registers
                // So we always have to clear the register fields before updating them.

                // First instruction to patch is a mov [edx], reg

                _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][0] == 0x89);
                // Update the reg field (bits 3..5) of the ModR/M byte of this instruction
                JIT_UP_WriteBarrierReg_Buf[reg][1] &= 0xc7;
                JIT_UP_WriteBarrierReg_Buf[reg][1] |= reg << 3;
                
                // Second instruction to patch is cmp reg, imm32 (low bound)

                _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][2] == 0x81);
                // Here the lowest three bits in ModR/M field are the register
                JIT_UP_WriteBarrierReg_Buf[reg][3] &= 0xf8;
                JIT_UP_WriteBarrierReg_Buf[reg][3] |= reg;
                
                // Third instruction to patch is another cmp reg, imm32 (high bound)

                _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][10] == 0x81);
                // Here the lowest three bits in ModR/M field are the register
                JIT_UP_WriteBarrierReg_Buf[reg][11] &= 0xf8;
                JIT_UP_WriteBarrierReg_Buf[reg][11] |= reg;
                
                bStompWriteBarrierEphemeral = true;
                // What we're trying to update is the offset field of a
                // cmp offset[edx], 0ffh instruction
                _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][21] == 0x80);
                pfunc = (size_t *) &JIT_UP_WriteBarrierReg_Buf[reg][23];
               *pfunc = (size_t) g_card_table;

                // What we're trying to update is the offset field of a
                // mov offset[edx], 0ffh instruction
                _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][31] == 0xC6);
                pfunc = (size_t *) &JIT_UP_WriteBarrierReg_Buf[reg][33];

                if(bEESuspended) 
                    GCHeap::RestartEE(FALSE, TRUE);                    

                if (fToggle) 
                    pThread->EnablePreemptiveGC();                
        }
        else
            {
                // What we're trying to update is the offset field of a
                // cmp offset[edx], 0ffh instruction
                _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][13] == 0x80);
                pfunc = (size_t *) &JIT_UP_WriteBarrierReg_Buf[reg][15];
               *pfunc = (size_t) g_card_table;

                // What we're trying to update is the offset field of a
                // mov offset[edx], 0ffh instruction
                _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][23] == 0xC6);
                pfunc = (size_t *) &JIT_UP_WriteBarrierReg_Buf[reg][25];
            }
    }
    else
        {
            // What we're trying to update is the offset field of a
            // cmp offset[edx], 0ffh instruction
            _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][21] == 0x80);
            pfunc = (size_t *) &JIT_UP_WriteBarrierReg_Buf[reg][23];
           *pfunc = (size_t) g_card_table;

            // What we're trying to update is the offset field of a
            // mov offset[edx], 0ffh instruction
            _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][31] == 0xC6);
            pfunc = (size_t *) &JIT_UP_WriteBarrierReg_Buf[reg][33];
        }

    // Stick in the adjustment value.
    *pfunc = (size_t) g_card_table;
}
    if (bStompWriteBarrierEphemeral)
        StompWriteBarrierEphemeral();

}


// In general, we want to use COMPlusThrow to throw exceptions.  However, 
// the JIT_Throw helper is a special case.  Here, we're called from
// managed code.  We have a guarantee that the first FS:0 handler
// is our COMPlusFrameHandler.  We could call COMPlusThrow(), which pushes
// another handler, but there is a significant (10% on JGFExceptionBench) 
// performance gain if we avoid this by calling RaiseTheException() 
// directly.
//
extern VOID RaiseTheException(OBJECTREF pThroable, BOOL rethrow);

/*************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL1(void, JIT_Throw,  Object* obj)
{
    THROWSCOMPLUSEXCEPTION();

    
    /* Make no assumptions about the current machine state */
    ResetCurrentContext();

    FC_GC_POLL_NOT_NEEDED();    // throws always open up for GC
    HELPER_METHOD_FRAME_BEGIN_ATTRIB_NOPOLL(Frame::FRAME_ATTR_EXCEPTION);    // Set up a frame

#ifdef _X86_
    // @TODO: This nees to be moved to macro in ExcepCpu.h
    // A stack probe.  Take the stack overflow early.
    __asm test [esp-0x1000], eax;
    __asm test [esp-0x2000], eax;
#endif

    VALIDATEOBJECTREF(obj);

#ifdef _DEBUG
    __helperframe.InsureInit();
    g_ExceptionEIP = __helperframe.GetReturnAddress();
#endif

    if (obj == 0)
        COMPlusThrow(kNullReferenceException);
    else
        RaiseTheException(ObjectToOBJECTREF(obj), FALSE);

    HELPER_METHOD_FRAME_END();
}
HCIMPLEND

/*************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL0(void, JIT_Rethrow)
{
    THROWSCOMPLUSEXCEPTION();

    FC_GC_POLL_NOT_NEEDED();    // throws always open up for GC
    HELPER_METHOD_FRAME_BEGIN_ATTRIB_NOPOLL(Frame::FRAME_ATTR_EXCEPTION);    // Set up a frame

    OBJECTREF throwable = GETTHROWABLE();
    if (throwable != NULL)
        RaiseTheException(throwable, TRUE);
    else
        // This can only be the result of bad IL (or some internal EE failure).
        RealCOMPlusThrow(kInvalidProgramException, (UINT)IDS_EE_RETHROW_NOT_ALLOWED);

    HELPER_METHOD_FRAME_END();
}
HCIMPLEND

/*********************************************************************/
/* throw an exception in jitted code where the return address does
   not accurately reflect what the correct 'try' block.  Instead
   'EHindex' represents the try block.  It is 0 if there is not try
    blocks, or a 1 based index of the try block we are currently in */

void OutOfLineException(unsigned EHindex, RuntimeExceptionKind excep, HelperMethodFrame* curFrame) {

    THROWSCOMPLUSEXCEPTION();

    /* Make no assumptions about the current machine state */
    ResetCurrentContext();

    // Indicate that the frame caused and exception
    unsigned attribs = Frame::FRAME_ATTR_EXCEPTION;

    /* We should no longer need to do this as the jit-compiler no longer
       does the throw from outside of the corresponding try block.
       @TODO: Remove FRAME_ATTR_OUT_OF_LINE, change the signature of
       CORINFO_HELP_RNGCHKFAIL and CORINFO_HELP_OVERFLOW, etc.
     */

    if (false &&
        EHindex > 0)
    {
        curFrame->InsureInit();
        --EHindex;
        /* Get the JitManager for the method */
        SLOT          retAddr = (SLOT)curFrame->GetReturnAddress();
        IJitManager*    pEEJM = ExecutionManager::FindJitMan(retAddr);
        _ASSERTE(pEEJM != 0);

        /* Now get the exception table of the method */

        METHODTOKEN     methodToken;
        DWORD           relOffset;
        pEEJM->JitCode2MethodTokenAndOffset(retAddr,&methodToken,&relOffset);
        SLOT            startAddr = retAddr - relOffset;
        _ASSERTE(methodToken);
        EH_CLAUSE_ENUMERATOR EnumState;
        unsigned        EHCount = pEEJM->InitializeEHEnumeration(methodToken,&EnumState);
        _ASSERTE(EHindex < EHCount);

        /* Find the matching clause */

        EE_ILEXCEPTION_CLAUSE EHClause, *EHClausePtr;
        do {
            EHClausePtr = pEEJM->GetNextEHClause(methodToken,&EnumState,&EHClause);
        } while (EHindex-- > 0);

        // Set the return address to somewhere in the exception handler
        // We better not ever return!
        BYTE* startAddrOfClause = startAddr + EHClausePtr->TryStartPC;
        curFrame->SetReturnAddress(startAddrOfClause);
        _ASSERTE(curFrame->GetReturnAddress() == startAddrOfClause);

            // tell the stack crawlerthat we are out of line
        attribs |= Frame::FRAME_ATTR_OUT_OF_LINE;
    }

    curFrame->SetFrameAttribs(attribs);
    COMPlusThrow(excep);
    _ASSERTE(!"COMPlusThrow returned!");
}

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL1(void, JIT_RngChkFail,  unsigned tryIndex)
{
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();    // Set up a frame

    // tryIndex is 0 if no exception handlers
    // otherwise it is the index (1 based), of the
    // most deeply nested handler that contains the throw
    OutOfLineException(tryIndex, kIndexOutOfRangeException, &__helperframe);    // __helperframe created by HELPER_METHOD_FRAME
    HELPER_METHOD_FRAME_END_POLL();
}
HCIMPLEND

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL1(void, JIT_Overflow,  unsigned tryIndex)
{
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();    // Set up a frame

    // tryIndex is 0 if no exception handlers
    // otherwise it is the index (1 based), of the
    // most deeply nested handler that contains the throw
    OutOfLineException(tryIndex, kOverflowException, &__helperframe);   // __helperframe created by HELPER_METHOD_FRAME
    HELPER_METHOD_FRAME_END_POLL();
}
HCIMPLEND

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL1(void, JIT_Verification,  int ilOffset)
{
    THROWSCOMPLUSEXCEPTION();

    FC_GC_POLL_NOT_NEEDED();    // throws always open up for GC
    HELPER_METHOD_FRAME_BEGIN_ATTRIB_NOPOLL(Frame::FRAME_ATTR_EXCEPTION);    // Set up a frame

#ifdef _X86_
    // @TODO: This nees to be moved to macro in ExcepCpu.h
    // A stack probe.  Take the stack overflow early.
    __asm test [esp-0x1000], eax;
    __asm test [esp-0x2000], eax;
#endif

    //WCHAR str[30];
    //swprintf(str,L"At or near IL offset %x\0",ilOffset);
    COMPlusThrow(kVerificationException);
    
    HELPER_METHOD_FRAME_END();
}
HCIMPLEND

/*********************************************************************/
HCIMPL1(void, JIT_SecurityUnmanagedCodeException, CORINFO_CLASS_HANDLE typeHnd_)
{
    THROWSCOMPLUSEXCEPTION();

    FC_GC_POLL_NOT_NEEDED();    // throws always open up for GC
    HELPER_METHOD_FRAME_BEGIN_ATTRIB_NOPOLL(Frame::FRAME_ATTR_EXCEPTION);    // Set up a frame

#ifdef _X86_
    // @TODO: This nees to be moved to macro in ExcepCpu.h
    // A stack probe.  Take the stack overflow early.
    __asm test [esp-0x1000], eax;
    __asm test [esp-0x2000], eax;
#endif

    Security::ThrowSecurityException(g_SecurityPermissionClassName, SPFLAGSUNMANAGEDCODE);
    
    HELPER_METHOD_FRAME_END();
}
HCIMPLEND

/*********************************************************************/
// JIT_UserBreakpoint
// Called by the JIT whenever a cee_break instruction should be executed.
// This ensures that enough info will be pushed onto the stack so that
// we can continue from the exception w/o having special code elsewhere.
// Body of function is written by debugger team
// Args: None
//
// @todo: make sure this actually gets called by all JITters
// Note: this code is duplicated in the ecall in VM\DebugDebugger:Break,
// so propogate changes to there

HCIMPL0(void, JIT_UserBreakpoint)
{
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();    // Set up a frame

#ifdef DEBUGGING_SUPPORTED
    DebuggerExitFrame __def;

    g_pDebugInterface->SendUserBreakpoint(GetThread());

    __def.Pop();
#else
    _ASSERTE("JIT_UserBreakpoint called, but debugging support is not available in this build.");
#endif // DEBUGGING_SUPPORTED

    HELPER_METHOD_FRAME_END_POLL();
}
HCIMPLEND

static const RuntimeExceptionKind map[CORINFO_Exception_Count] =
{
    kNullReferenceException,
    kDivideByZeroException,
    kInvalidCastException,
    kIndexOutOfRangeException,
    kOverflowException,
    kSynchronizationLockException,
    kArrayTypeMismatchException,
    kRankException,
    kArgumentNullException,
    kArgumentException,
};


/*********************************************************************/
HCIMPL1(void, JIT_InternalThrow, unsigned exceptNum)
{

        // spot check of the array above
    _ASSERTE(map[CORINFO_NullReferenceException] == kNullReferenceException);
    _ASSERTE(map[CORINFO_DivideByZeroException] == kDivideByZeroException);
    _ASSERTE(map[CORINFO_IndexOutOfRangeException] == kIndexOutOfRangeException);
    _ASSERTE(map[CORINFO_OverflowException] == kOverflowException);
    _ASSERTE(map[CORINFO_SynchronizationLockException] == kSynchronizationLockException);
    _ASSERTE(map[CORINFO_ArrayTypeMismatchException] == kArrayTypeMismatchException);
    _ASSERTE(map[CORINFO_RankException] == kRankException);
    _ASSERTE(map[CORINFO_ArgumentNullException] == kArgumentNullException);
    _ASSERTE(map[CORINFO_ArgumentException] == kArgumentException);

    _ASSERTE(exceptNum < CORINFO_Exception_Count);
    _ASSERTE(map[exceptNum] != 0);

        // Most JIT helpers can ONLY be called from jitted code, and thus the
        // exact depth is not needed.  However, Throw is tail called from stubs, 
        // which might have been called for CallDescr, so we need the exact depth
    FC_GC_POLL_NOT_NEEDED();    // throws always open up for GC
    HELPER_METHOD_FRAME_BEGIN_ATTRIB_NOPOLL(Frame::FRAME_ATTR_EXACT_DEPTH);
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(map[exceptNum]);
    HELPER_METHOD_FRAME_END();
}
HCIMPLEND

/*********************************************************************/
// Args: typedef struct {unsigned dummy_Stack; unsigned dummy_EDX; unsigned exceptNum} _InternalThrowStackArgs;
//
// The following is very subtle and illustrates the fragile nature of the throws from
// frameless JIT helpers.  A frameless JIT helper has a particular signature.  If it
// find that it cannot do its job, it JMPs to a JIT helper like JIT_InternalThrow.
// Its entrypoint to that helper is always the ECall stub, rather than the method
// itself.  That way, the ECall stub will set up a frame and we can successfully
// complete the throw.
//
// However, the ECall of the throwing helper needs to somewhat match the arguments to the
// frameless helper.  Otherwise the ECall frame will describe a stack state that is
// not the true stack state.
//
// With the register-based calling convention, 0, 1 or 2 32-bit scalar args will all
// map to the same stack shape.  That's because the args are enregistered.  But if
// we have some args on the stack, JIT_InternalThrow will no longer match the
// callsite.
//
// Interface invoke is one such situation.  It comes to JIT_InternalThrowStack
// instead.  This supports a single argument on the stack.  If you have a frameless
// helper that has more stuff on the stack, you probably need another version of
// this service!

HCIMPL3(void, JIT_InternalThrowStack, int dummyArg1, int dummyArg2, unsigned exceptNum)
{
        // spot check of the array above
    _ASSERTE(map[CORINFO_NullReferenceException] == kNullReferenceException);
    _ASSERTE(map[CORINFO_IndexOutOfRangeException] == kIndexOutOfRangeException);
    _ASSERTE(map[CORINFO_OverflowException] == kOverflowException);

    _ASSERTE(exceptNum < CORINFO_Exception_Count);
    _ASSERTE(map[exceptNum] != 0);

    FCThrowVoid(map[exceptNum]);
}
HCIMPLEND

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE

HCIMPL1(void*, JIT_GetStaticFieldAddr, FieldDesc *pFD)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pFD->IsThreadStatic() || pFD->IsContextStatic() || 
             pFD->GetMethodTableOfEnclosingClass()->IsShared());

    void *addr = NULL;

        // When we care at all about the speed of context and thread local statics
        // we shoudl avoid constructing the frame when possible
    OBJECTREF throwable = 0;
    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_1(Frame::FRAME_ATTR_RETURN_INTERIOR, throwable);

    MethodTable *pMT = pFD->GetMethodTableOfEnclosingClass();
    pMT->CheckRestore();

    DomainLocalClass *pLocalClass;
    if (!pMT->CheckRunClassInit(&throwable, &pLocalClass))
        COMPlusThrow(throwable);

    if(pFD->IsThreadStatic())
    {
        addr = Thread::GetStaticFieldAddress(pFD);
    }
    else if (pFD->IsContextStatic())
    {
        addr = Context::GetStaticFieldAddress(pFD);
    }
    else 
    {
        _ASSERTE(pMT->IsShared());

        void *base = pFD->GetSharedBase(pLocalClass);
        addr = pFD->GetStaticAddress(base);
    }

    HELPER_METHOD_FRAME_END();
    return addr;
}
HCIMPLEND

/*********************************************************************/
HCIMPL1(void *, JIT_GetThreadFieldAddr_Primitive, FieldDesc *pFD)
    
    MethodTable* pMT = pFD->GetMethodTableOfEnclosingClass();
    _ASSERTE(pFD->IsThreadStatic());
    _ASSERTE(CorTypeInfo::IsPrimitiveType(pFD->GetFieldType()));
    _ASSERTE(pFD->GetOffset() <= FIELD_OFFSET_LAST_REAL_OFFSET);

    if (!pMT->IsRestoredAndClassInited())
        goto SLOW;

    Thread* pThread = GetThread();
    STATIC_DATA *pData = pMT->IsShared() ? pThread->GetSharedStaticData() : pThread->GetUnsharedStaticData();
    if (pData == 0)
        goto SLOW;

    WORD wClassOffset = pMT->GetClass()->GetThreadStaticOffset();
    if (wClassOffset >= pData->cElem)
        goto SLOW;

    BYTE* dataBits = (BYTE*) pData->dataPtr[wClassOffset];
    if (dataBits == 0)
        goto SLOW;

    return &dataBits[pFD->GetOffsetUnsafe()];

SLOW:
    ENDFORBIDGC();
    return(JIT_GetStaticFieldAddr(pFD));
HCIMPLEND


void __declspec(naked) JIT_ProfilerStub()
{
#ifdef _X86_
    __asm
    {
        ret 4
    }
#else // !_X86_
    _ASSERTE(!"NYI");
#endif // !_X86_
}

/*********************************************************************/
HCIMPL1(void *, JIT_GetThreadFieldAddr_Objref, FieldDesc *pFD)

    MethodTable* pMT = pFD->GetMethodTableOfEnclosingClass();
    _ASSERTE(pFD->IsThreadStatic());
    _ASSERTE(CorTypeInfo::IsObjRef(pFD->GetFieldType()));
    _ASSERTE(pFD->GetOffset() <= FIELD_OFFSET_LAST_REAL_OFFSET);

    if (!pMT->IsRestoredAndClassInited())
        goto SLOW;

    Thread* pThread = GetThread();
    STATIC_DATA *pData = pMT->IsShared() ? pThread->GetSharedStaticData() : pThread->GetUnsharedStaticData();
    if (pData == 0)
        goto SLOW;

    WORD wClassOffset = pMT->GetClass()->GetThreadStaticOffset();
    if (wClassOffset >= pData->cElem)
        goto SLOW;

    BYTE* dataBits = (BYTE*) pData->dataPtr[wClassOffset];
    if (dataBits == 0)
        goto SLOW;

    Object** handle = *((Object***) &dataBits[pFD->GetOffsetUnsafe()]);
    if (handle == 0)
        goto SLOW;
    return handle;

SLOW:
    ENDFORBIDGC();
    return(JIT_GetStaticFieldAddr(pFD));

HCIMPLEND

/*********************************************************************/
HCIMPL1(void *, JIT_GetContextFieldAddr_Primitive, FieldDesc *pFD)
    
    MethodTable* pMT = pFD->GetMethodTableOfEnclosingClass();
    _ASSERTE(pFD->IsContextStatic());
    _ASSERTE(CorTypeInfo::IsPrimitiveType(pFD->GetFieldType()));
    _ASSERTE(pFD->GetOffset() <= FIELD_OFFSET_LAST_REAL_OFFSET);

    if (!pMT->IsRestoredAndClassInited())
        goto SLOW;

    Context* pCtx = GetCurrentContext();
    _ASSERTE(pCtx);
    STATIC_DATA *pData = pMT->IsShared() ? pCtx->GetSharedStaticData() : pCtx->GetUnsharedStaticData();
    if (pData == 0)
        goto SLOW;

    WORD wClassOffset = pMT->GetClass()->GetContextStaticOffset();
    if (wClassOffset >= pData->cElem)
        goto SLOW;

    BYTE* dataBits = (BYTE*) pData->dataPtr[wClassOffset];
    if (dataBits == 0)
        goto SLOW;

    return &dataBits[pFD->GetOffsetUnsafe()];

SLOW:
    ENDFORBIDGC();
    return(JIT_GetStaticFieldAddr(pFD));
HCIMPLEND

/*********************************************************************/
HCIMPL1(void *, JIT_GetContextFieldAddr_Objref, FieldDesc *pFD)
    
    MethodTable* pMT = pFD->GetMethodTableOfEnclosingClass();
    _ASSERTE(pFD->IsContextStatic());
    _ASSERTE(CorTypeInfo::IsObjRef(pFD->GetFieldType()));
    _ASSERTE(pFD->GetOffset() <= FIELD_OFFSET_LAST_REAL_OFFSET);

    if (!pMT->IsRestoredAndClassInited())
        goto SLOW;

    Context* pCtx = GetCurrentContext();
    _ASSERTE(pCtx);
    STATIC_DATA *pData = pMT->IsShared() ? pCtx->GetSharedStaticData() : pCtx->GetUnsharedStaticData();
    if (pData == 0)
        goto SLOW;

    WORD wClassOffset = pMT->GetClass()->GetContextStaticOffset();
    if (wClassOffset >= pData->cElem)
        goto SLOW;

    BYTE* dataBits = (BYTE*) pData->dataPtr[wClassOffset];
    if (dataBits == 0)
        goto SLOW;

    Object** handle = *((Object***) &dataBits[pFD->GetOffsetUnsafe()]);
    if (handle == 0)
        goto SLOW;

    return handle;

SLOW:
    ENDFORBIDGC();
    return(JIT_GetStaticFieldAddr(pFD));
HCIMPLEND


#pragma optimize("", on)

/*********************************************************************/
// This is a helper routine used by JIT_GetField32 below
#ifdef PLATFORM_CE
__int32 /*__stdcall*/ JIT_GetField32Worker(OBJECTREF or, FieldDesc *pFD)
#else // !PLATFORM_CE
__int32 __stdcall JIT_GetField32Worker(OBJECTREF or, FieldDesc *pFD)
#endif // !PLATFORM_CE
{
    THROWSCOMPLUSEXCEPTION();

    switch (pFD->GetFieldType())
    {
        case ELEMENT_TYPE_I1:
            return (INT8)(pFD->GetValue8(or));
        case ELEMENT_TYPE_BOOLEAN:
        case ELEMENT_TYPE_U1:
            return (UINT8)(pFD->GetValue8(or));
        case ELEMENT_TYPE_I2:
            return (INT16)(pFD->GetValue16(or));
        case ELEMENT_TYPE_CHAR:
        case ELEMENT_TYPE_U2:
            return (UINT16)(pFD->GetValue16(or));
        case ELEMENT_TYPE_I4: // can fallthru
        case ELEMENT_TYPE_U4:
        IN_WIN32(case ELEMENT_TYPE_PTR:)
        IN_WIN32(case ELEMENT_TYPE_I:)
        IN_WIN32(case ELEMENT_TYPE_U:)
            return pFD->GetValue32(or);

        case ELEMENT_TYPE_R4:
            INT32 value;
            value = pFD->GetValue32(or);
            setFPReturn(4, value);
            return value;

        default:
            _ASSERTE(!"Bad Type");
            // as the assert above implies, this should never happen, however if it does
            // it is acceptable to return 0, because the system is not in an inconsistant state.
            // Throwing is hard  because we are called from both framed and unframed contexts
            return 0;
    }
}

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL2(__int32, JIT_GetField32, Object *obj, FieldDesc *pFD)
{
    THROWSCOMPLUSEXCEPTION();
    // This is an instance field helper
    _ASSERTE(!pFD->IsStatic());

    if (obj == NULL)
        FCThrow(kNullReferenceException);

    OBJECTREF or = ObjectToOBJECTREF(obj);

    INT32 value = 0;

    // basic sanity checks.  Are we pointing at a valid FD and objRef?
    _ASSERTE(pFD->GetMethodTableOfEnclosingClass()->GetClass()->GetMethodTable() == pFD->GetMethodTableOfEnclosingClass());

    // Try an unwrap operation to check that we are not being called in the
    // same context as the server. If that is the case then unwrap will return
    // the server object.
    if(or->GetMethodTable()->IsTransparentProxyType())
    {
        or = CRemotingServices::GetObjectFromProxy(or, TRUE);
        // This is a cross context field access. Setup a frame as we will
        // transition to managed code later.
        HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();        // Set up a frame
        value = JIT_GetField32Worker(or, pFD);
        HELPER_METHOD_FRAME_END();                     // Tear down the frame
    }
    else
    {
        value = JIT_GetField32Worker(or, pFD);
    }

    FC_GC_POLL_RET();
    return value;
}
HCIMPLEND

/*********************************************************************/
// This is a helper routine used by JIT_GetField64 below
#ifdef PLATFORM_CE
__int64 /*__stdcall*/ JIT_GetField64Worker(OBJECTREF or, FieldDesc *pFD)
#else // !PLATFORM_CE
__int64 __stdcall JIT_GetField64Worker(OBJECTREF or, FieldDesc *pFD)
#endif // !PLATFORM_CE
{
    INT64 value = pFD->GetValue64(or);
    if (ELEMENT_TYPE_R8 == pFD->GetFieldType())
    {
        setFPReturn(8, value);
    }
    return value;
}

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL2(__int64, JIT_GetField64, Object *obj, FieldDesc *pFD)
{
    THROWSCOMPLUSEXCEPTION();
    // This is an instance field helper
    _ASSERTE(!pFD->IsStatic());

    if (obj == NULL)
        FCThrow(kNullReferenceException);

    OBJECTREF or = ObjectToOBJECTREF(obj);
    INT64 value = 0;

    _ASSERTE(pFD->GetMethodTableOfEnclosingClass()->GetClass()->GetMethodTable() == pFD->GetMethodTableOfEnclosingClass());
    // Try an unwrap operation to check that we are not being called in the
    // same context as the server. If that is the case then unwrap will return
    // the server object.
    if(or->GetMethodTable()->IsTransparentProxyType())
    {
        or = CRemotingServices::GetObjectFromProxy(or, TRUE);
        // This is a cross context field access. Setup a frame as we will
        // transition to managed code later.
        HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();        // Set up a frame

        value = JIT_GetField64Worker(or, pFD);

        HELPER_METHOD_FRAME_END();              // Tear down the frame
    }
    else
    {
        value = JIT_GetField64Worker(or, pFD);
    }
    FC_GC_POLL_RET();
    return value;
}
HCIMPLEND

/*********************************************************************/
// This is a helper routine used by JIT_SetField32 below
#ifdef PLATFORM_CE
static void /*__stdcall*/ JIT_SetField32Worker(OBJECTREF or, FieldDesc *pFD, __int32 value)
#else // !PLATFORM_CE
static void __stdcall JIT_SetField32Worker(OBJECTREF or, FieldDesc *pFD, __int32 value)
#endif // !PLATFORM_CE
{
    THROWSCOMPLUSEXCEPTION();

    switch (pFD->GetFieldType())
    {
        case ELEMENT_TYPE_I1:
        case ELEMENT_TYPE_U1:
        case ELEMENT_TYPE_BOOLEAN:
            pFD->SetValue8(or, value);
            break;

        case ELEMENT_TYPE_I2:
        case ELEMENT_TYPE_U2:
        case ELEMENT_TYPE_CHAR:
            pFD->SetValue16(or, value);
            break;

        case ELEMENT_TYPE_I4: // can fallthru
        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_R4:
        IN_WIN32(case ELEMENT_TYPE_PTR:)
        IN_WIN32(case ELEMENT_TYPE_I:)
        IN_WIN32(case ELEMENT_TYPE_U:)
            pFD->SetValue32(or, value);
            break;

        default:
            _ASSERTE(!"Bad Type");
            // as the assert above implies, this should never happen, however if it does
            // it is acceptable do nothging, because the system is not in an inconsistant state.
            // Throwing is hard  because we are called from both framed and unframed contexts
    }
}

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL3(VOID, JIT_SetField32, Object *obj, FieldDesc *pFD, __int32 value)
{
    THROWSCOMPLUSEXCEPTION();
    // This is an instance field helper
    _ASSERTE(!pFD->IsStatic());

    if (obj == NULL)
        FCThrowVoid(kNullReferenceException);

    OBJECTREF or = ObjectToOBJECTREF(obj);

    // basic sanity checks.  Are we pointing at a valid FD and objRef?
    _ASSERTE(pFD->GetMethodTableOfEnclosingClass()->GetClass()->GetMethodTable() == pFD->GetMethodTableOfEnclosingClass());

    // Try an unwrap operation to check that we are not being called in the
    // same context as the server. If that is the case then unwrap will return
    // the server object.
    if(or->GetMethodTable()->IsTransparentProxyType())
    {
        or = CRemotingServices::GetObjectFromProxy(or, TRUE);
        // This is a cross context field access. Setup a frame as we will
        // transition to managed code later.
        HELPER_METHOD_FRAME_BEGIN_NOPOLL();        // Set up a frame

        JIT_SetField32Worker(or, pFD, value);

        HELPER_METHOD_FRAME_END();          // Tear down the frame
    }
    else
    {
        JIT_SetField32Worker(or, pFD, value);
    }

    FC_GC_POLL();
}
HCIMPLEND

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL3(VOID, JIT_SetField64, Object *obj, FieldDesc *pFD, __int64 value)
{
    THROWSCOMPLUSEXCEPTION();
    // This is an instance field helper
    _ASSERTE(!pFD->IsStatic());

    if (obj == NULL)
        FCThrowVoid(kNullReferenceException);

    OBJECTREF or = ObjectToOBJECTREF(obj);

    // basic sanity checks.  Are we pointing at a valid FD and objRef?
    _ASSERTE(pFD->GetMethodTableOfEnclosingClass()->GetClass()->GetMethodTable() == pFD->GetMethodTableOfEnclosingClass());

    // Try an unwrap operation to check that we are not being called in the
    // same context as the server. If that is the case then unwrap will return
    // the server object.
    if(or->GetMethodTable()->IsTransparentProxyType())
    {
        or = CRemotingServices::GetObjectFromProxy(or, TRUE);
        // This is a cross context field access. Setup a frame as we will
        // transition to managed code later.
        HELPER_METHOD_FRAME_BEGIN_NOPOLL();        // Set up a frame

        pFD->SetValue64(or, value);

        HELPER_METHOD_FRAME_END();          // Tear down the frame
    }
    else
    {
        *((__int64 *)pFD->GetAddress(OBJECTREFToObject(or))) = value;
    }
    FC_GC_POLL();
}
HCIMPLEND

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL2(Object*, JIT_GetField32Obj, Object *obj, FieldDesc *pFD)
{
    // This is an instance field helper
    _ASSERTE(!pFD->IsStatic());

    // Assert that we are called only for objects
    _ASSERTE(!pFD->IsPrimitive() && !pFD->IsByValue());

    if (obj == NULL)
        FCThrow(kNullReferenceException);

    OBJECTREF newobj = NULL;

#if CHECK_APP_DOMAIN_LEAKS
    if (pFD->GetMethodTableOfEnclosingClass()->IsValueClass())
    {
        // This case should only occur for dangerous fields
        _ASSERTE(pFD->IsDangerousAppDomainAgileField());
        newobj = *(OBJECTREF*)pFD->GetAddress((void*)obj); 
    }
    else
#endif
    {
        OBJECTREF or = ObjectToOBJECTREF(obj);

    // We should use this helper to get field values for marshalbyref types
    // or proxy types
        _ASSERTE(or->GetClass()->IsMarshaledByRef() || or->IsThunking() 
                 || pFD->IsDangerousAppDomainAgileField());

        // Try an unwrap operation to check that we are not being called in the
        // same context as the server. If that is the case then unwrap will return
        // the server object.
        if(or->GetMethodTable()->IsTransparentProxyType())
        {
            or = CRemotingServices::GetObjectFromProxy(or, TRUE);
            // This is a cross context field access. Setup a frame as we will
            // transition to managed code later.
            HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_NOPOLL(Frame::FRAME_ATTR_RETURNOBJ);    // Set up a frame

            newobj = pFD->GetRefValue(or);
            HELPER_METHOD_FRAME_END();          // Tear down the frame
        }
        else
        {
            newobj = ObjectToOBJECTREF(*((Object**) pFD->GetAddress(OBJECTREFToObject(or))));
        }
    }

    FC_GC_POLL_AND_RETURN_OBJREF(OBJECTREFToObject(newobj));
}
HCIMPLEND

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL3(VOID, JIT_SetField32Obj, Object *obj, FieldDesc *pFD, Object *value)
{
    // This is an instance field helper
    _ASSERTE(!pFD->IsStatic());

    // Assert that we are called only for objects
    _ASSERTE(!pFD->IsPrimitive() && !pFD->IsByValue());

    if (obj == NULL)
        FCThrowVoid(kNullReferenceException);

#if CHECK_APP_DOMAIN_LEAKS
    if (pFD->GetMethodTableOfEnclosingClass()->IsValueClass())
    {
        // This case should only occur for dangerous fields
        _ASSERTE(pFD->IsDangerousAppDomainAgileField());
        SetObjectReference((OBJECTREF*) pFD->GetAddress((void*)obj), 
                           ObjectToOBJECTREF(value), GetAppDomain());
    }
    else
#endif
    {
        OBJECTREF or = ObjectToOBJECTREF(obj);

       // We should use this helper to get field values for marshalbyref types
        // or proxy types
        _ASSERTE(or->GetClass()->IsMarshaledByRef() || or->IsThunking()
                 || pFD->IsDangerousAppDomainAgileField());

        // Try an unwrap operation to check that we are not being called in the
        // same context as the server. If that is the case then unwrap will return
        // the server object.
        if(or->GetMethodTable()->IsTransparentProxyType())
        {
            or = CRemotingServices::GetObjectFromProxy(or, TRUE);

            // This is a cross context field access. Setup a frame as we will
            // transition to managed code later.
            HELPER_METHOD_FRAME_BEGIN_NOPOLL();        // Set up a frame

            pFD->SetRefValue(or, ObjectToOBJECTREF(value));

            HELPER_METHOD_FRAME_END();          // Tear down the frame
        }
        else
        {
            pFD->SetRefValue(or, ObjectToOBJECTREF(value));
        }
    }
    FC_GC_POLL();
}
HCIMPLEND


/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL3(VOID, JIT_GetFieldStruct, LPVOID retBuff, Object *obj, FieldDesc *pFD)
{
    // This is an instance field helper
    _ASSERTE(!pFD->IsStatic());

    // Assert that we are not called for objects or primitive types
    _ASSERTE(!pFD->IsPrimitive());

    if (obj == NULL)
        FCThrowVoid(kNullReferenceException);

    OBJECTREF or = ObjectToOBJECTREF(obj);

    // We should use this helper to get field values for marshalbyref types
    // or proxy types
    _ASSERTE(or->GetClass()->IsMarshaledByRef() || or->IsThunking());

    // BUGBUG: Define struct getter on FieldDesc  TarunA

    // This may be a  cross context field access. Setup a frame as we will
    // transition to managed code later
    //
    // @todo: also in the prejit case, we may restore the class of the
    // field, which requires a frame be pushed.  We probably need to
    // plug up this hole, in which case we can conditionally push the
    // frame only in the proxy case.

    HELPER_METHOD_FRAME_BEGIN_NOPOLL();        // Set up a frame

    // Try an unwrap operation to check that we are not being called in the
    // same context as the server. If that is the case then unwrap will return
    // the server object.
    if(or->GetMethodTable()->IsTransparentProxyType())
        or = CRemotingServices::GetObjectFromProxy(or, TRUE);

    CRemotingServices::FieldAccessor(pFD, or, retBuff, TRUE);

    HELPER_METHOD_FRAME_END_POLL();          // Tear down the frame
}
HCIMPLEND

/*********************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL3(VOID, JIT_SetFieldStruct, Object *obj, FieldDesc *pFD, LPVOID valuePtr)
{
    // Assert that we are not called for objects or primitive types
    _ASSERTE(!pFD->IsPrimitive());

    if (obj == NULL)
        FCThrowVoid(kNullReferenceException);

    OBJECTREF or = ObjectToOBJECTREF(obj);

    // We should use this helper to get field values for marshalbyref types
    // or proxy types
    _ASSERTE(or->GetClass()->IsMarshaledByRef() || or->IsThunking()
             || pFD->IsDangerousAppDomainAgileField());

#ifdef _DEBUG
    if (pFD->IsDangerousAppDomainAgileField())
    {
        //
        // Verify that the object we are assigning to is also agile
        //

        if (or->IsAppDomainAgile())
        {
            // !!! validate that all dangerous fields of valuePtr are domain agile
        }
    }
#endif

    // BUGBUG: Define struct setter on FieldDesc  TarunA

    // This may be a  cross context field access. Setup a frame as we will
    // transition to managed code later
    //
    // @todo: also in the prejit case, we may restore the class of the
    // field, which requires a frame be pushed.  We probably need to
    // plug up this hole, in which case we can conditionally push the
    // frame only in the proxy case.

    HELPER_METHOD_FRAME_BEGIN_NOPOLL();        // Set up a frame

    // Try an unwrap operation to check that we are not being called in the
    // same context as the server. If that is the case then unwrap will return
    // the server object.
    BEGINFORBIDGC();
    if(or->GetMethodTable()->IsTransparentProxyType())
        or = CRemotingServices::GetObjectFromProxy(or, TRUE);
    ENDFORBIDGC();

    CRemotingServices::FieldAccessor(pFD, or, valuePtr, FALSE);

    HELPER_METHOD_FRAME_END_POLL();          // Tear down the frame
}
HCIMPLEND

/*********************************************************************/
// TODO: wire this into the FJIT.
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE

HCIMPL0(VOID, JIT_PollGC)
{
    FC_GC_POLL_NOT_NEEDED();

    Thread  *thread = GetThread();
    if (thread->CatchAtSafePoint())    // Does someone wants this thread stopped?
    {
        HELPER_METHOD_FRAME_BEGIN_NOPOLL();    // Set up a frame
#ifdef _DEBUG
        BOOL GCOnTransition = FALSE;
        if (g_pConfig->FastGCStressLevel()) {
            GCOnTransition = GC_ON_TRANSITIONS (FALSE);
        }
#endif
        CommonTripThread();         // Indicate we are at a GC safe point
#ifdef _DEBUG
        if (g_pConfig->FastGCStressLevel()) {
            GC_ON_TRANSITIONS (GCOnTransition);
        }
#endif
        HELPER_METHOD_FRAME_END();
    }
}
HCIMPLEND


/*********************************************************************/
/* we don't use HCIMPL macros because we don't want the overhead even in debug mode */

Object* __fastcall JIT_CheckObj(Object* obj)
{
    if (obj != 0) {
        MethodTable* pMT = obj->GetMethodTable();
        if (pMT->m_pEEClass->GetMethodTable() != pMT) {
            _ASSERTE(!"Bad Method Table");
            DebugBreak();
        }
    }
    return obj;
}

#pragma optimize("",on)


/*********************************************************************/

//
//@TODO The ref assignment helpers need to change on multiproc/uniproc
//@TODO machines for efficiency.   Currently, we are using the MP helpers
//@TODO even on a uniproc system so that we don't break on MP, but this
//@TODO costs as their is a lock'd operation in the MP helpers
//

extern "C" VMHELPDEF hlpFuncTable[] =
{
        // pfnHelper is set to NULL if it is a stubbed helper. It will be set in InitJITHelpers2
        //      code                        pfnHelper               pfnStub,flags

    { HELPCODE(CORINFO_HELP_UNDEF)              JIT_BadHelper,              0, 0 },

    // Arithmetic
    // CORINFO_HELP_DBL2INT, CORINFO_HELP_DBL2UINT, and CORINFO_HELP_DBL2LONG get
    // patched for CPUs that support SSE2 (P4 and above).
    { HELPCODE(CORINFO_HELP_LLSH)               JIT_LLsh,                   0, 0 },
    { HELPCODE(CORINFO_HELP_LRSH)               JIT_LRsh,                   0, 0 },
    { HELPCODE(CORINFO_HELP_LRSZ)               JIT_LRsz,                   0, 0 },
    { HELPCODE(CORINFO_HELP_LMUL)               JIT_LMul,                   0, 0 },
    { HELPCODE(CORINFO_HELP_LMUL_OVF)           JIT_LMulOvf,                0, 0 },
    { HELPCODE(CORINFO_HELP_ULMUL_OVF)          JIT_ULMulOvf,               0, 0 },
    { HELPCODE(CORINFO_HELP_LDIV)               JIT_LDiv,                   0, 0 },
    { HELPCODE(CORINFO_HELP_LMOD)               JIT_LMod,                   0, 0 },
    { HELPCODE(CORINFO_HELP_ULDIV)              JIT_ULDiv,                  0, 0 },
    { HELPCODE(CORINFO_HELP_ULMOD)              JIT_ULMod,                  0, 0 },
    { HELPCODE(CORINFO_HELP_ULNG2DBL)           JIT_ULng2Dbl,               0, 0 },
    { HELPCODE(CORINFO_HELP_DBL2INT)            JIT_Dbl2Lng,                0, 0 }, // use long version
    { HELPCODE(CORINFO_HELP_DBL2INT_OVF)        JIT_Dbl2IntOvf,             0, 0 },
    { HELPCODE(CORINFO_HELP_DBL2LNG)            JIT_Dbl2Lng,                0, 0 },
    { HELPCODE(CORINFO_HELP_DBL2LNG_OVF)        JIT_Dbl2LngOvf,             0, 0 },
    { HELPCODE(CORINFO_HELP_DBL2UINT)           JIT_Dbl2Lng,                0, 0 }, // use long version
    { HELPCODE(CORINFO_HELP_DBL2UINT_OVF)       JIT_Dbl2UIntOvf,            0, 0 },
    { HELPCODE(CORINFO_HELP_DBL2ULNG)           JIT_Dbl2ULng,               0, 0 },
    { HELPCODE(CORINFO_HELP_DBL2ULNG_OVF)       JIT_Dbl2ULngOvf,            0, 0 },
    { HELPCODE(CORINFO_HELP_FLTREM)             JIT_FltRem,                 0, 0 },
    { HELPCODE(CORINFO_HELP_DBLREM)             JIT_DblRem,                 0, 0 },

    // Allocating a new object
    { HELPCODE(CORINFO_HELP_NEW_DIRECT)         JIT_New,                    0, 0 }, // TODO remove no longe used
    { HELPCODE(CORINFO_HELP_NEW_CROSSCONTEXT)   JIT_NewCrossContext,        0, 0 },
    { HELPCODE(CORINFO_HELP_NEWFAST)            JIT_NewFast,                0, 0 },
    { HELPCODE(CORINFO_HELP_NEWSFAST)           JIT_TrialAllocSFastSP,      0, 0 },
    { HELPCODE(CORINFO_HELP_NEWSFAST_ALIGN8)    JIT_TrialAllocSFastSP,      0, 0 },
    { HELPCODE(CORINFO_HELP_NEW_SPECIALDIRECT)  JIT_NewSpecial,             0, 0 },
    { HELPCODE(CORINFO_HELP_NEWOBJ)             JIT_NewObj,                 0, 0 },
    { HELPCODE(CORINFO_HELP_NEWARR_1_DIRECT)    JIT_NewArr1,                0, 0 },
    { HELPCODE(CORINFO_HELP_NEWARR_1_OBJ)       JIT_NewArr1,                0, 0 },
    { HELPCODE(CORINFO_HELP_NEWARR_1_VC)        JIT_NewArr1,                0, 0 },
    { HELPCODE(CORINFO_HELP_NEWARR_1_ALIGN8)    JIT_NewArr1,                0, 0 },
    { HELPCODE(CORINFO_HELP_STRCNS)             JIT_StrCns,                 0, 0 },

    // Object model
    { HELPCODE(CORINFO_HELP_INITCLASS)          JIT_InitClass,              0, 0 },
    { HELPCODE(CORINFO_HELP_ISINSTANCEOF)       JIT_IsInstanceOf,           0, 0 },
    { HELPCODE(CORINFO_HELP_ISINSTANCEOFCLASS)  JIT_IsInstanceOfClass,      0, 0 },
    { HELPCODE(CORINFO_HELP_CHKCAST)            JIT_ChkCast,                0, 0 },
    { HELPCODE(CORINFO_HELP_CHKCASTCLASS)       JIT_ChkCastClass,           0, 0 },
    { HELPCODE(CORINFO_HELP_BOX)                JIT_Box,                    0, 0 },
    { HELPCODE(CORINFO_HELP_UNBOX)              JIT_Unbox,                  0, 0 },
    { HELPCODE(CORINFO_HELP_GETREFANY)          JIT_GetRefAny,              0, 0 },
    { HELPCODE(CORINFO_HELP_EnC_RESOLVEVIRTUAL) JIT_EnCResolveVirtual,      0, 0 },
    { HELPCODE(CORINFO_HELP_ARRADDR_ST)         JIT_Stelem_Ref,            0, 0 },
    { HELPCODE(CORINFO_HELP_LDELEMA_REF)        JIT_Ldelema_Ref,            0, 0 },

    // Exceptions
    { HELPCODE(CORINFO_HELP_THROW)              JIT_Throw,                  0, 0 },
    { HELPCODE(CORINFO_HELP_RETHROW)            JIT_Rethrow,                0, 0 },
    { HELPCODE(CORINFO_HELP_USER_BREAKPOINT)    JIT_UserBreakpoint,         0, 0 },
    { HELPCODE(CORINFO_HELP_RNGCHKFAIL)         JIT_RngChkFail,             0, 0 },
    { HELPCODE(CORINFO_HELP_OVERFLOW)           JIT_Overflow,               0, 0 },
    { HELPCODE(CORINFO_HELP_INTERNALTHROW)      JIT_InternalThrow,          0, 0 },
    { HELPCODE(CORINFO_HELP_INTERNALTHROWSTACK) JIT_InternalThrowStack,     0, 0 },
    { HELPCODE(CORINFO_HELP_VERIFICATION)       JIT_Verification,           0, 0 },
    { HELPCODE(CORINFO_HELP_ENDCATCH)           JIT_EndCatch,               0, 0 },

    // Synchronization
    { HELPCODE(CORINFO_HELP_MON_ENTER)          JIT_MonEnter,               0, 0 },
    { HELPCODE(CORINFO_HELP_MON_EXIT)           JIT_MonExit,                0, 0 },
    { HELPCODE(CORINFO_HELP_MON_ENTER_STATIC)   JIT_MonEnterStatic,         0, 0 },
    { HELPCODE(CORINFO_HELP_MON_EXIT_STATIC)    JIT_MonExitStatic,          0, 0 },

    // GC support
    { HELPCODE(CORINFO_HELP_STOP_FOR_GC)        JIT_RareDisableHelper,      0, 0 },
    { HELPCODE(CORINFO_HELP_POLL_GC)            JIT_PollGC,                 0, 0 },
    { HELPCODE(CORINFO_HELP_STRESS_GC)          JIT_StressGC,               0, 0 },
    { HELPCODE(CORINFO_HELP_CHECK_OBJ)          JIT_CheckObj,               0, 0 },

    // GC Write barrier support
    { HELPCODE(CORINFO_HELP_ASSIGN_REF_EAX)     JIT_UP_WriteBarrierReg_Buf[0], 0, 0 },
    { HELPCODE(CORINFO_HELP_ASSIGN_REF_EBX)     JIT_UP_WriteBarrierReg_Buf[3], 0, 0 },
    { HELPCODE(CORINFO_HELP_ASSIGN_REF_ECX)     JIT_UP_WriteBarrierReg_Buf[1], 0, 0 },
    { HELPCODE(CORINFO_HELP_ASSIGN_REF_ESI)     JIT_UP_WriteBarrierReg_Buf[6], 0, 0 },
    { HELPCODE(CORINFO_HELP_ASSIGN_REF_EDI)     JIT_UP_WriteBarrierReg_Buf[7], 0, 0 },
    { HELPCODE(CORINFO_HELP_ASSIGN_REF_EBP)     JIT_UP_WriteBarrierReg_Buf[5], 0, 0 },

    { HELPCODE(CORINFO_HELP_CHECKED_ASSIGN_REF_EAX) JIT_UP_CheckedWriteBarrierEAX,    0, 0 },
    { HELPCODE(CORINFO_HELP_CHECKED_ASSIGN_REF_EBX) JIT_UP_CheckedWriteBarrierEBX,    0, 0 },
    { HELPCODE(CORINFO_HELP_CHECKED_ASSIGN_REF_ECX) JIT_UP_CheckedWriteBarrierECX,    0, 0 },
    { HELPCODE(CORINFO_HELP_CHECKED_ASSIGN_REF_ESI) JIT_UP_CheckedWriteBarrierESI,    0, 0 },
    { HELPCODE(CORINFO_HELP_CHECKED_ASSIGN_REF_EDI) JIT_UP_CheckedWriteBarrierEDI,    0, 0 },
    { HELPCODE(CORINFO_HELP_CHECKED_ASSIGN_REF_EBP) JIT_UP_CheckedWriteBarrierEBP,    0, 0 },

    { HELPCODE(CORINFO_HELP_ASSIGN_BYREF)           JIT_UP_ByRefWriteBarrier,   0, 0},

    // Accessing fields
    { HELPCODE(CORINFO_HELP_GETFIELD32)             JIT_GetField32,             0, 0 },
    { HELPCODE(CORINFO_HELP_SETFIELD32)             JIT_SetField32,             0, 0 },
    { HELPCODE(CORINFO_HELP_GETFIELD64)             JIT_GetField64,             0, 0 },
    { HELPCODE(CORINFO_HELP_SETFIELD64)             JIT_SetField64,             0, 0 },
    { HELPCODE(CORINFO_HELP_GETFIELD32OBJ)          JIT_GetField32Obj,          0, 0 },
    { HELPCODE(CORINFO_HELP_SETFIELD32OBJ)          JIT_SetField32Obj,          0, 0 },
    { HELPCODE(CORINFO_HELP_GETFIELDSTRUCT)         JIT_GetFieldStruct,         0, 0 },
    { HELPCODE(CORINFO_HELP_SETFIELDSTRUCT)         JIT_SetFieldStruct,         0, 0 },
    { HELPCODE(CORINFO_HELP_GETFIELDADDR)           JIT_GetFieldAddr,           0, 0 },

    { HELPCODE(CORINFO_HELP_GETSTATICFIELDADDR)     JIT_GetStaticFieldAddr,     0, 0 },

    { HELPCODE(CORINFO_HELP_GETSHAREDSTATICBASE)    NULL,                       0, 0 },

    /* Profiling enter/leave probe addresses */
    { HELPCODE(CORINFO_HELP_PROF_FCN_CALL)          NULL,                       0, 0 },
    { HELPCODE(CORINFO_HELP_PROF_FCN_RET)           NULL,                       0, 0 },
    { HELPCODE(CORINFO_HELP_PROF_FCN_ENTER)         JIT_ProfilerStub,           0, 0 },
    { HELPCODE(CORINFO_HELP_PROF_FCN_LEAVE)         JIT_ProfilerStub,           0, 0 },
    { HELPCODE(CORINFO_HELP_PROF_FCN_TAILCALL)      JIT_ProfilerStub,           0, 0 },

    // Miscellaneous
    { HELPCODE(CORINFO_HELP_PINVOKE_CALLI)          NULL,                       0, 0 },
    { HELPCODE(CORINFO_HELP_TAILCALL)               JIT_TailCall,               0, 0 },

    { HELPCODE(CORINFO_HELP_GET_THREAD_FIELD_ADDR_PRIMITIVE)     JIT_GetThreadFieldAddr_Primitive, 0, 0 },
    { HELPCODE(CORINFO_HELP_GET_THREAD_FIELD_ADDR_OBJREF)        JIT_GetThreadFieldAddr_Objref,        0, 0 },

    { HELPCODE(CORINFO_HELP_GET_CONTEXT_FIELD_ADDR_PRIMITIVE)     JIT_GetContextFieldAddr_Primitive, 0, 0 },
    { HELPCODE(CORINFO_HELP_GET_CONTEXT_FIELD_ADDR_OBJREF)        JIT_GetContextFieldAddr_Objref,        0, 0 },

    { HELPCODE(CORINFO_HELP_NOTANUMBER)             NULL,                       0, 0 },

    { HELPCODE(CORINFO_HELP_SEC_UNMGDCODE_EXCPT)    JIT_SecurityUnmanagedCodeException,     0, 0 },

    { HELPCODE(CORINFO_HELP_GET_THREAD)             NULL,                       0, 0 },
};

extern "C" VMHELPDEF utilFuncTable[] =
{
    { HELPCODE((CorInfoHelpFunc)JIT_UTIL_MON_ENTER)          JITutil_MonEnter,       0, 0 },
    { HELPCODE((CorInfoHelpFunc)JIT_UTIL_MON_TRY_ENTER)      JITutil_MonTryEnter,    0, 0 },
    { HELPCODE((CorInfoHelpFunc)JIT_UTIL_MON_ENTER_STATIC)   JITutil_MonEnterStatic, 0, 0 },
    { HELPCODE((CorInfoHelpFunc)JIT_UTIL_MON_EXIT)           JITutil_MonExit,        0, 0 },
    { HELPCODE((CorInfoHelpFunc)JIT_UTIL_MON_EXIT_THINLOCK)  JITutil_MonExitThinLock,0, 0 },
    { HELPCODE((CorInfoHelpFunc)JIT_UTIL_MON_CONTENTION)     JITutil_MonContention,  0, 0 },
    { HELPCODE((CorInfoHelpFunc)JIT_UTIL_CHKCASTBIZARRE)     JITutil_ChkCastBizarre, 0, 0 },
    { HELPCODE((CorInfoHelpFunc)JIT_UTIL_ISINSTANCEBIZARRE)  JITutil_IsInstanceOfBizarre, 0, 0 },
};

#ifdef PROFILING_SUPPORTED
HRESULT ProfToEEInterfaceImpl::SetEnterLeaveFunctionHooksForJit(FunctionEnter *pFuncEnter,
                                                                FunctionLeave *pFuncLeave,
                                                                FunctionTailcall *pFuncTailcall)
{
    if (pFuncEnter)
        hlpFuncTable[CORINFO_HELP_PROF_FCN_ENTER].pfnHelper = (void *) pFuncEnter;

    if (pFuncLeave)
        hlpFuncTable[CORINFO_HELP_PROF_FCN_LEAVE].pfnHelper = (void *) pFuncLeave;

    if (pFuncTailcall)
        hlpFuncTable[CORINFO_HELP_PROF_FCN_TAILCALL].pfnHelper = (void *) pFuncTailcall;

    return (S_OK);
}
#endif // PROFILING_SUPPORTED

BOOL ObjIsInstanceOf(Object *pElement, TypeHandle toTypeHnd)
{
    _ASSERTE(pElement != NULL);

    BOOL       fCast = FALSE;
    TypeHandle ElemTypeHnd = pElement->GetTypeHandle();

    // Some of the pathways through here can trigger a GC.  But it is required that
    // those callers which don't involve odd cases like COM and remoting do not.
    //
    // There is code in JIT_Stelem_Ref that relies on this.

    // Start by doing a quick static cast check to see if the type information captured in
    // the metadata indicates that the cast is legal.
    if (!ElemTypeHnd.GetMethodTable()->IsThunking())
    {
        fCast = ElemTypeHnd.CanCastTo(toTypeHnd);
        if (fCast)
            return(fCast);
    }

    // If we are trying to store a proxy in the array we need to delegate to remoting
    // services which will determine whether the proxy and the array element
    // type are compatible.
    if(ElemTypeHnd.GetMethodTable()->IsThunking())
    {
        _ASSERTE(CRemotingServices::IsTransparentProxy(pElement));
        fCast = CRemotingServices::CheckCast(ObjectToOBJECTREF(pElement), toTypeHnd.AsClass());
        if (fCast)
            return(fCast);
    }

        // If the array is an array of interfaces and the element is a COM object then we need
        // to do a check to see if the element implements the array's interface.
    if(ElemTypeHnd.GetMethodTable()->IsComObjectType() && toTypeHnd.GetMethodTable()->IsInterface())
    {
        TRIGGERSGC();
        OBJECTREF obj = ObjectToOBJECTREF(pElement);
        GCPROTECT_BEGIN(obj);
        fCast = ElemTypeHnd.GetClass()->ComObjectSupportsInterface(obj, toTypeHnd.GetMethodTable());
        GCPROTECT_END();
    }

    return(fCast);
}

#pragma optimize("",on)


/*********************************************************************/
// Initialize the part of the JIT helpers that require much of the
// EE infrastructure to be in place.
/*********************************************************************/
extern ECFunc  gStringBufferFuncs[];

BOOL InitJITHelpers2()
{
    // forward decl defined in ndirect.cpp
    LPVOID GetEntryPointForPInvokeCalliStub();
    // get entry for the generic stub for unmanaged calli
    hlpFuncTable[CORINFO_HELP_PINVOKE_CALLI].pfnHelper = GetEntryPointForPInvokeCalliStub();

    // Update the vector that the interface invoke stubs are calling through.
    _ASSERTE(VectorToJIT_InternalThrowStack == TrapCalls);
    VectorToJIT_InternalThrowStack = hlpFuncTable[CORINFO_HELP_INTERNALTHROWSTACK].pfnHelper;

#ifdef PROFILING_SUPPORTED
    if (!CORProfilerTrackAllocationsEnabled())
#endif
    {
        JIT_TrialAlloc::Flags flags = JIT_TrialAlloc::ALIGN8;
        if (g_SystemInfo.dwNumberOfProcessors != 1)
            flags = JIT_TrialAlloc::Flags(flags | JIT_TrialAlloc::MP_ALLOCATOR);
        hlpFuncTable[CORINFO_HELP_NEWARR_1_ALIGN8].pfnHelper
          = JIT_TrialAlloc::GenAllocArray(flags);
    }

    if (gStringBufferFuncs[0].m_pImplementation == COMStringBuffer::GetCurrentThread) {
    _ASSERTE(GetThread != NULL);
        gStringBufferFuncs[0].m_pImplementation = GetThread;
    }
    else {
    _ASSERTE(!"Please keep InternalGetCurrentThread first");
    }

#if defined(ENABLE_PERF_COUNTERS)
    g_lastTimeInJitCompilation.QuadPart = 0;
#endif

    return TRUE;
}

/*********************************************************************/
void* __stdcall CEEInfo::getHelperFtn (CorInfoHelpFunc ftnNum,
                                       void **ppIndirection)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (ppIndirection != NULL)
        *ppIndirection = NULL;

    return(getJitHelper(ftnNum));
}

/*********************************************************************/
void* getJitHelper(CorInfoHelpFunc ftnNum)
{
    _ASSERTE((unsigned) ftnNum < sizeof(hlpFuncTable) / sizeof(VMHELPDEF));
    _ASSERTE(hlpFuncTable[ftnNum].code == ftnNum);

    _ASSERTE(hlpFuncTable[ftnNum].pfnHelper);
    return(hlpFuncTable[ftnNum].pfnHelper);
}

/*********************************************************************/
HCIMPL2(INT64, JIT_LMul, INT64 val2, INT64 val1)
{
    // Special case 0
    if ((val1 == 0) || (val2 == 0))
    {
        _ASSERT(0 == (val1 * val2));
        return 0;
    }

    return (val1 * val2);
}
HCIMPLEND

/*********************************************************************/
HCIMPL2(INT64, JIT_ULMul, UINT64 val2, UINT64 val1)
{
    // Special case 0
    if ((val1 == 0) || (val2 == 0))
    {
        _ASSERT(0 == (val1 * val2));
        return 0;
    }

    return (val1 * val2);
}
HCIMPLEND

/*********************************************************************/
HCIMPL2(INT64, JIT_LMulOvf, INT64 val2, INT64 val1)
{
    THROWSCOMPLUSEXCEPTION();

        // @TODO: figure out how to do this without converting to the unsigned case
    __int64 ret = val1 * val2;

    unsigned __int64 uval1 = (val1 < 0) ? -val1 : val1;
    unsigned __int64 uval2 = (val2 < 0) ? -val2 : val2;

        // compute result as unsigned
    __int64 uret  = uval1 * uval2;

        // Get the upper 32 bits of the numbers
    unsigned __int64 uval1High = (unsigned) (uval1 >> 32);
    unsigned __int64 uval2High = (unsigned) (uval2 >> 32);

        // Compute the 'middle' bits of the long multiplication
    unsigned __int64 uvalMid =
        (uval1High * (unsigned) uval2 + uval2High * (unsigned) uval1) +
        ((((unsigned __int64) (unsigned) uval1) * (unsigned) uval2) >> 32);

        // See if any bits after bit 63 are set
    if (uval1High * uval2High != 0 || (uvalMid >> 32) != 0)
        goto THROW;

        // have we spilled into the sign bit?
    if (uret < 0) {
            // MIN_INT is a special case, we did not overflow the sign as
            // long as the signs of the original args are different
        if (!(uret == 0x8000000000000000L && (val1 < 0) != (val2 < 0)))
            goto THROW;
    }
    return(ret);

THROW:
    FCThrow(kOverflowException);
}
HCIMPLEND

#pragma optimize("t", on)

/*********************************************************************/
HCIMPL2(INT64, JIT_ULMulOvf, UINT64 val2, UINT64 val1)
{
        // Get the upper 32 bits of the numbers
    unsigned __int64 val1High = (unsigned) (val1 >> 32);
    unsigned __int64 val2High = (unsigned) (val2 >> 32);

        // Compute the 'middle' bits of the long multiplication
    unsigned __int64 valMid =
        (val1High * (unsigned) val2 + val2High * (unsigned) val1) +
        ((((unsigned __int64) (unsigned) val1) * (unsigned) val2) >> 32);

        // See if any bits after bit 63 are set
    if (val1High * val2High != 0 || (valMid >> 32) != 0) {
        FCThrow(kOverflowException);
    }

    return(val1 * val2);
}
HCIMPLEND

/*********************************************************************/
HCIMPL2(INT64, JIT_LDiv, INT64 divisor, INT64 dividend)
{
    RuntimeExceptionKind ehKind;
    if (divisor != 0)
    {
        if (divisor != -1) 
        {
            // Check for -ive or +ive numbers in the range -2**31 to 2**31
            if (((int)dividend == dividend) && ((int)divisor == divisor))
                return((int)dividend / (int)divisor);
            // For all other combinations fallback to int64 div.
            else
                return(dividend / divisor);
        }
        else 
        {
            if (dividend == 0x8000000000000000L)
            {
                ehKind = kOverflowException;
                goto ThrowExcep;
            }
            return -dividend;
        }
    }
    else
    {
        ehKind = kDivideByZeroException;
        goto ThrowExcep;
    }

ThrowExcep:
    FCThrow(ehKind);
}
HCIMPLEND

/*********************************************************************/
HCIMPL2(INT64, JIT_LMod, INT64 divisor, INT64 dividend)
{
    RuntimeExceptionKind ehKind;
    if (divisor != 0)
    {
        if (divisor != -1) 
        {
            // Check for -ive or +ive numbers in the range -2**31 to 2**31
            if (((int)dividend == dividend) && ((int)divisor == divisor))
                return((int)dividend % (int)divisor);
            // For all other combinations fallback to int64 div.
            else
                return(dividend % divisor);
        }
        else 
        {
            // TODO, we really should remove this as it lengthens to the code path 
            // and the spec really says that it should not throw an exception. 
            if (dividend == 0x8000000000000000L)
            {
                ehKind = kOverflowException;
                goto ThrowExcep;
            }
            return 0;
        }
    }
    else
    {
        ehKind = kDivideByZeroException;
        goto ThrowExcep;
    }

ThrowExcep:
    FCThrow(ehKind);
}
HCIMPLEND

/*********************************************************************/
HCIMPL2(UINT64, JIT_ULDiv, UINT64 divisor, UINT64 dividend)
{

    if (divisor != 0)
    {
        if (((dividend & 0xFFFFFFFF00000000L) == 0) && ((divisor & 0xFFFFFFFF00000000L) == 0))
            return((unsigned int)dividend / (unsigned int)divisor);
        else
            return(dividend / divisor);
    }
    else
    {
        FCThrow(kDivideByZeroException);
    }
}
HCIMPLEND

/*********************************************************************/
HCIMPL2(UINT64, JIT_ULMod, UINT64 divisor, UINT64 dividend)
{

    if (divisor != 0)
    {
        if (((dividend & 0xFFFFFFFF00000000L) == 0) && ((divisor & 0xFFFFFFFF00000000L) == 0))
            return((unsigned int)dividend % (unsigned int)divisor);
        else
            return(dividend % divisor);
    }
    else
    {
        FCThrow(kDivideByZeroException);
    }
}
HCIMPLEND

#pragma optimize("", on)

/*********************************************************************/
//
static double __stdcall JIT_ULng2Dbl(unsigned __int64 val)
{
    double conv = (double) ((__int64) val);
    if (conv < 0)
        conv += (4294967296.0 * 4294967296.0);  // add 2^64
    _ASSERTE(conv >= 0);
    return(conv);
}

#ifndef _X86_
/*********************************************************************/
__int64 __stdcall JIT_Dbl2Lng(double val)
{
    return((__int64) val);
}
#endif

/*********************************************************************/
HCIMPL1(unsigned, JIT_Dbl2UIntOvf, double val)
{
        // Note that this expression also works properly for val = NaN case
    if (val > -1.0 && val < 4294967296)
        return((unsigned) JIT_Dbl2Lng(val));

    FCThrow(kOverflowException);
}
HCIMPLEND

/*********************************************************************/
static unsigned __int64 __stdcall JIT_Dbl2ULng(double val)
{
    const double two63  = 2147483648.0 * 4294967296.0;
    if (val < two63)
        return JIT_Dbl2Lng(val);

        // subtract 0x8000000000000000, do the convert then add it back again
    return (JIT_Dbl2Lng(val - two63) + 0x8000000000000000L);
}

/*********************************************************************/
HCIMPL1(UINT64, JIT_Dbl2ULngOvf, double val)
{
    const double two64  = 4294967296.0 * 4294967296.0;
        // Note that this expression also works properly for val = NaN case
    if (val > -1.0 && val < two64) {
        UINT64 ret = JIT_Dbl2ULng(val);
#ifdef _DEBUG
        // since no overflow can occur, the value always has to be within 1
        double roundTripVal = JIT_ULng2Dbl(ret);
        _ASSERTE(val - 1.0 <= roundTripVal && roundTripVal <= val + 1.0); 
#endif
        return ret;
    }

    FCThrow(kOverflowException);
}
HCIMPLEND

/*********************************************************************/
Object* __cdecl JIT_NewObj(CORINFO_MODULE_HANDLE scopeHnd, unsigned constrTok, int argN)
{
    THROWSCOMPLUSEXCEPTION();

    int* pArgs;
    DWORD* fwdArgList;
    unsigned i;

    HCIMPL_PROLOG(JIT_NewObj);
    OBJECTREF    ret = 0;
    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_1(Frame::FRAME_ATTR_RETURNOBJ, ret);    // Set up a frame
    THROWSCOMPLUSEXCEPTION();

    // TODO: avoid this token lookup at run time
    Module* pModule = GetModule(scopeHnd);
    MethodDesc *pMethod;
    if (FAILED(EEClass::GetMethodDescFromMemberRef(pModule, constrTok, &pMethod)))
    {
        if (pModule)
            COMPlusThrowMember(kMissingMethodException, pModule->GetMDImport(), constrTok);
        else
            COMPlusThrow(kMissingMethodException);
    }

    _ASSERTE(!pMethod->IsStatic());
    MethodTable *pMT = pMethod->GetMethodTable();
    _ASSERTE(pMT->IsArray());           // Should be using one of the fast new helpers, if you aren't an array

    unsigned dwNumArgs = MetaSig::NumFixedArgs(pModule, pMethod->GetSig());
    _ASSERTE(dwNumArgs > 0);

    // Load the associated array class.  Can't get this from MethodDesc because
    // all object array accessors share the same MethodDesc!
    mdTypeRef cr = pModule->GetMDImport()->GetParentOfMemberRef(constrTok);
    NameHandle name(pModule, cr);
    TypeHandle typeHnd = pModule->GetClassLoader()->LoadTypeHandle(&name);
    if (typeHnd.IsNull())
    {
        _ASSERTE(!"Unable to load array class");
        goto exit;
    }

    pArgs = &argN;
    
    // create an array where fwdArgList[0] == arg[0] ...
    fwdArgList = (DWORD *) _alloca(dwNumArgs*sizeof(DWORD));
    i = dwNumArgs;
    while (i > 0) {
        --i;
        fwdArgList[i] = *pArgs++;
    }

    ret = AllocateArrayEx(typeHnd, fwdArgList, dwNumArgs);

exit: ;
    HELPER_METHOD_FRAME_END();
    return (OBJECTREFToObject(ret));
}

/*************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL2(LPVOID, JIT_GetRefAny, CORINFO_CLASS_HANDLE type, TypedByRef typedByRef)
{
    TypeHandle clsHnd(type);

        // @TODO right now we check for precisely the correct type.
        // do we want to allow inheritance?  (watch out since value
        // classes inherit from object but do not normal object layout).
    if (clsHnd != typedByRef.type) {
        FCThrow(kInvalidCastException);
    }

    return(typedByRef.data);
}
HCIMPLEND

/*************************************************************/
// For an inlined N/Direct call (and possibly for other places that need this service)
// we have noticed that the returning thread should trap for one reason or another.
// ECall sets up the frame.

HCIMPL1(void, JIT_RareDisableHelper, Thread* thread)
{
        // We do this here (before we set up a frame), because the following scenario
        // We are in the process of doing an inlined pinvoke.  Since we are in preemtive
        // mode, the thread is allowed to continue.  The thread continues and gets a context
        // switch just after it has cleared the preemptive mode bit but before it gets
        // to this helper.    When we do our stack crawl now, we think this thread is 
        // in cooperative mode (and believed that it was suspended in the SuspendEE), so
        // we do a getthreadcontext (on the unsuspended thread!) and get an EIP in jitted code.
        // and proceed.   Assume the crawl of jitted frames is proceeding on the other thread
        // when this thread wakes up and sets up a frame.   Eventually the other thread
        // runs out of jitted frames and sees the frame we just established.  This causes
        // and assert in the stack crawling code.  If this assert is ignored, however, we
        // will end up scanning the jitted frames twice, which will lead to GC holes 
        //
        // TODO:  I believe it would be MUCH more robust if we should remember which threads 
        // we suspended in the SuspendEE, and only even consider using EIP if it was suspended
        // in the first phase.  
        //      - vancem 

    ENDFORBIDGC();
    thread->RareDisablePreemptiveGC();
    BEGINFORBIDGC();

    FC_GC_POLL_NOT_NEEDED();
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();    // Set up a frame
    THROWSCOMPLUSEXCEPTION();
    thread->HandleThreadAbort();
    HELPER_METHOD_FRAME_END();
}
HCIMPLEND

/*************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE

/*************************************************************/
/* the uncommon case for the helper below (allowing enums to be unboxed
   as their underlying type */

LPVOID __fastcall JIT_Unbox_Helper(CORINFO_CLASS_HANDLE type, Object* obj)
{
    TypeHandle typeHnd(type);

    CorElementType type1 = typeHnd.GetNormCorElementType();

        // we allow enums and their primtive type to be interchangable

    MethodTable* pMT2 = obj->GetMethodTable();
    CorElementType type2 = pMT2->GetNormCorElementType();
    if (type1 == type2)  {
        EEClass* pClass1 = typeHnd.GetClass();
        EEClass* pClass2 = pMT2->GetClass();
        if (pClass1 && (pClass1->IsEnum() || pClass1->IsTruePrimitive()) &&
            (pClass2->IsEnum() || pClass2->IsTruePrimitive())) {
            _ASSERTE(CorTypeInfo::IsPrimitiveType(type1));
            return(obj->GetData());
        }
    }

    return(0);
}

/*************************************************************/
HCIMPL2(LPVOID, JIT_Unbox, CORINFO_CLASS_HANDLE type, Object* obj)
{
    TypeHandle typeHnd(type);
    VALIDATEOBJECTREF(obj);
    _ASSERTE(typeHnd.IsUnsharedMT());       // value classes are always unshared
    _ASSERTE(typeHnd.AsClass()->GetMethodTable()->GetClass() == typeHnd.AsClass());

        // This has been tuned so that branch predictions are good
        // (fall through for forward branches) for the common case
    RuntimeExceptionKind except;
    if (obj != 0) {
        if (obj->GetMethodTable() == typeHnd.AsMethodTable())
            return(obj->GetData());
        else {
                // Stuff the uncommon case into a helper so that
                // its register needs don't cause spills that effect
                // the common case above.
            LPVOID ret = JIT_Unbox_Helper(type, obj);
            if (ret != 0)
                return(ret);
        }
        except = kInvalidCastException;
    }
    else
        except = kNullReferenceException;

    FCThrow(except);
}
HCIMPLEND

/*************************************************************/
#pragma optimize("t", on)

/* returns '&array[idx], after doing all the proper checks */

HCIMPL3(void*, JIT_Ldelema_Ref, PtrArray* array, unsigned idx, CORINFO_CLASS_HANDLE type)
{
    RuntimeExceptionKind except;
       // This has been carefully arranged to insure that in the common
        // case the branches are predicted properly (fall through).
        // and that we dont spill registers unnecessarily etc.
    if (array != 0)
        if (idx < array->GetNumComponents())
            if (array->GetElementTypeHandle() == TypeHandle(type))
                return(&array->m_Array[idx]);
            else
                except = kArrayTypeMismatchException;
        else
            except = kIndexOutOfRangeException;
    else
        except = kNullReferenceException;

    FCThrow(except);
}
HCIMPLEND


#pragma optimize("", on )                              /* put optimization back */

/*************************************************************/
#ifdef PLATFORM_CE
#pragma optimize("y",off) // HELPER_METHOD_FRAME requires a stack frame
#endif // PLATFORM_CE
HCIMPL2(Object*, JIT_Box, CORINFO_CLASS_HANDLE type, void* unboxedData)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle clsHnd(type);

    _ASSERTE(clsHnd.IsUnsharedMT());  // we never use this helper for arrays
        // Sanity test for class
    _ASSERTE(clsHnd.AsClass()->GetMethodTable()->GetClass() == clsHnd.AsClass());
    MethodTable *pMT = clsHnd.AsMethodTable();

    // TODO: if we care, we could do a fast trial allocation
    // and avoid the building the frame most times
    OBJECTREF newobj;
    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_NOPOLL(Frame::FRAME_ATTR_RETURNOBJ);    // Set up a frame
    GCPROTECT_BEGININTERIOR(unboxedData);
    HELPER_METHOD_POLL();

    pMT->CheckRestore();

    // You can only box things that inherit from valuetype or Enum.
    if (!CanBoxToObject(pMT))
        COMPlusThrow(kInvalidCastException, L"Arg_ObjObj");

#ifdef _DEBUG
    if (g_pConfig->FastGCStressLevel()) {
        GetThread()->DisableStressHeap();
    }
#endif

    newobj = FastAllocateObject(pMT);

    CopyValueClass(newobj->GetData(), unboxedData, pMT, newobj->GetAppDomain());
    GCPROTECT_END();
    HELPER_METHOD_FRAME_END();

    return(OBJECTREFToObject(newobj));
}
HCIMPLEND

/*************************************************************/
HCIMPL1(Object*, JIT_New, CORINFO_CLASS_HANDLE typeHnd_)
{
    TypeHandle typeHnd(typeHnd_);

    OBJECTREF newobj;
    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_NOPOLL(Frame::FRAME_ATTR_RETURNOBJ);    // Set up a frame
    HELPER_METHOD_POLL();

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(typeHnd.IsUnsharedMT());                                   // we never use this helper for arrays
    MethodTable *pMT = typeHnd.AsMethodTable();
    pMT->CheckRestore();

#ifdef _DEBUG
    if (g_pConfig->FastGCStressLevel()) {
        GetThread()->DisableStressHeap();
    }
#endif

    newobj = AllocateObject(pMT);

    HELPER_METHOD_FRAME_END();
    return(OBJECTREFToObject(newobj));
}
HCIMPLEND

/*************************************************************/
HCIMPL1(Object*, JIT_NewString, unsigned length)
{
    STRINGREF newStr;
    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_NOPOLL(Frame::FRAME_ATTR_RETURNOBJ);    // Set up a frame
    HELPER_METHOD_POLL();

    THROWSCOMPLUSEXCEPTION();

#ifdef _DEBUG
    if (g_pConfig->FastGCStressLevel()) {
        GetThread()->DisableStressHeap();
    }
#endif

    newStr = AllocateString(length+1);

    HELPER_METHOD_FRAME_END();
    return(OBJECTREFToObject(newStr));
}
HCIMPLEND

/*************************************************************/
HCIMPL1(Object*, JIT_NewSpecial, CORINFO_CLASS_HANDLE typeHnd_)
{
    TypeHandle typeHnd(typeHnd_);

    OBJECTREF newobj;
    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_NOPOLL(Frame::FRAME_ATTR_RETURNOBJ);    // Set up a frame
    HELPER_METHOD_POLL();

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(typeHnd.IsUnsharedMT());                                   // we never use this helper for arrays
    MethodTable *pMT = typeHnd.AsMethodTable();
    pMT->CheckRestore();

#ifdef _DEBUG
    if (g_pConfig->FastGCStressLevel()) {
        GetThread()->DisableStressHeap();
    }
#endif

    newobj = AllocateObjectSpecial(pMT);

    HELPER_METHOD_FRAME_END();
    return(OBJECTREFToObject(newobj));
}
HCIMPLEND

/*************************************************************/

HCIMPL1(Object*, JIT_NewFast, CORINFO_CLASS_HANDLE typeHnd_)
{
    TypeHandle typeHnd(typeHnd_);

    OBJECTREF newobj;
    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_NOPOLL(Frame::FRAME_ATTR_RETURNOBJ);    // Set up a frame
    HELPER_METHOD_POLL();

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(typeHnd.IsUnsharedMT());                                   // we never use this helper for arrays
    MethodTable *pMT = typeHnd.AsMethodTable();
    _ASSERTE(!(pMT->IsComObjectType()));
    // Don't bother to restore the method table; assume that the prestub of the
    // constructor will do that check.

#ifdef _DEBUG
    if (g_pConfig->FastGCStressLevel()) {
        GetThread()->DisableStressHeap();
    }
#endif

    newobj = FastAllocateObject(pMT);

    HELPER_METHOD_FRAME_END();
    return(OBJECTREFToObject(newobj));
}
HCIMPLEND

/*************************************************************/
HCIMPL2(Object*, JIT_NewArr1, CORINFO_CLASS_HANDLE typeHnd_, int size)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle typeHnd(typeHnd_);

    OBJECTREF newArray;
    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_NOPOLL(Frame::FRAME_ATTR_RETURNOBJ);    // Set up a frame
    HELPER_METHOD_POLL();

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(typeHnd.GetNormCorElementType() == ELEMENT_TYPE_SZARRAY);
    ArrayTypeDesc* pArrayClassRef = typeHnd.AsArray();

    if (size < 0)
        COMPlusThrow(kOverflowException);

        // is this a primitive type?
    CorElementType elemType = pArrayClassRef->GetElementTypeHandle().GetSigCorElementType();
    if (CorTypeInfo::IsPrimitiveType(elemType)) {
#ifdef _DEBUG
        if (g_pConfig->FastGCStressLevel()) {
            GetThread()->DisableStressHeap();
        }
#endif
		BOOL bAllocateInLargeHeap = FALSE;
		if (elemType == ELEMENT_TYPE_R8 && size >= int(g_pConfig->GetDoubleArrayToLargeObjectHeap())) {
			STRESS_LOG1(LF_GC, LL_INFO10, "Allocating double array of size %d to large object heap\n", size);
			bAllocateInLargeHeap = TRUE;
		}
		
        newArray = FastAllocatePrimitiveArray(pArrayClassRef->GetMethodTable(), size, bAllocateInLargeHeap);
    }
    else
        {
        // call class init if necessary
        OBJECTREF Throwable;
        if (pArrayClassRef->GetMethodTable()->CheckRunClassInit(&Throwable) == FALSE)
            COMPlusThrow(Throwable);
        // TODO we could speed this up since we know it is a single dimentional case
#ifdef _DEBUG
        if (g_pConfig->FastGCStressLevel()) {
            GetThread()->DisableStressHeap();
        }
#endif

        newArray = AllocateArrayEx(typeHnd, (DWORD*) &size, 1);
    }

    HELPER_METHOD_FRAME_END();
    return(OBJECTREFToObject(newArray));
}
HCIMPLEND

#pragma optimize("t", on)


/*********************************************************************/
/* Erect a frame, call the class initializer, and tear the frame down
   Must ONLY be called directly from a FCALL or HCALL, and the
   epilog from it must be simple (can be insured by */

HCIMPL1(void, JIT_InitClass_Framed, MethodTable* pMT)
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF throwable = 0;
    HELPER_METHOD_FRAME_BEGIN_1(throwable); 
    pMT->CheckRestore();
    if (pMT->CheckRunClassInit(&throwable) == FALSE)
        COMPlusThrow(throwable);
    HELPER_METHOD_FRAME_END(); 
HCIMPLEND

/*************************************************************/
HCIMPL1(void, JIT_InitClass, CORINFO_CLASS_HANDLE typeHnd_)

    //
    // Fast check to see if our method table bits are set
    //

    TypeHandle typeHnd(typeHnd_);
    MethodTable *pMT = typeHnd.AsMethodTable();
    if (pMT->IsRestoredAndClassInited())
        return;

    // 
    // Slower check for shared code case as well
    //

    if (pMT->IsShared() && pMT->IsRestored())
    {
        SIZE_T index = pMT->GetSharedClassIndex();
        DomainLocalBlock *pLocalBlock = GetAppDomain()->GetDomainLocalBlock();
        if (pLocalBlock->IsClassInitialized(index))
            return;
    }

    ENDFORBIDGC();
    //  
    // Don't worry about speed so much now as we've got a .cctor to run.
    //
    JIT_InitClass_Framed(pMT);
HCIMPLEND


//*****************************************************************************
EECodeInfo::EECodeInfo(METHODTOKEN token, IJitManager * pJM)
: m_methodToken(token), m_pMD(pJM->JitTokenToMethodDesc(token)), m_pJM(pJM)
{
}


EECodeInfo::EECodeInfo(METHODTOKEN token, IJitManager * pJM, MethodDesc *pMD)
: m_methodToken(token), m_pMD(pMD), m_pJM(pJM)
{
}


CEEInfo EECodeInfo::s_ceeInfo;

const char* __stdcall EECodeInfo::getMethodName(const char **moduleName /* OUT */ )
{
    return s_ceeInfo.getMethodName((CORINFO_METHOD_HANDLE)m_pMD, moduleName);
}

DWORD       __stdcall EECodeInfo::getMethodAttribs()
{
    return s_ceeInfo.getMethodAttribs((CORINFO_METHOD_HANDLE)m_pMD,(CORINFO_METHOD_HANDLE)m_pMD);
}

DWORD       __stdcall EECodeInfo::getClassAttribs()
{
    CORINFO_CLASS_HANDLE clsHnd = s_ceeInfo.getMethodClass((CORINFO_METHOD_HANDLE)m_pMD);
    return s_ceeInfo.getClassAttribs(clsHnd,(CORINFO_METHOD_HANDLE)m_pMD);
}

void        __stdcall EECodeInfo::getMethodSig(CORINFO_SIG_INFO *sig /* OUT */ )
{
    s_ceeInfo.getMethodSig((CORINFO_METHOD_HANDLE)m_pMD, sig);
}

LPVOID      __stdcall EECodeInfo::getStartAddress()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    return m_pJM->JitToken2StartAddress(m_methodToken);
}

// Used for icecap 4.1 integrated into the EE.
#if 0

/*********************************************************************/
// Map a MethodDesc to a handle that icecap 4.1 can use.
/*********************************************************************/
UINT_PTR GetProfilingHandleMap(MethodDesc *ftn, unsigned *pflags)
{
    UINT_PTR    handle = 0;

    // Assume by default that we want to wrap call sites.
    *pflags = FLG_ICECAP_FASTCAP;

    // IL uses the MethodDesc itself which is a heap pointer but will
    // never move in the process unlike the jitted IP location.
    if (ftn->IsIL())
    {
        handle = IcecapProbes::GetProfilingHandle(ftn);
        *pflags = FLG_ICECAP_CALLCAP;
    }
    // Everything else is native code.  Use the actual IP which will not
    // move and can be correlated to symbol files.
    else if (ftn->IsECall())
    {
        ECallMethodDesc *p = (ECallMethodDesc *) ftn;
        NDirect_Prelink(p);
        handle = (UINT_PTR) p->GetECallTarget();

        // There is a special subclass of ECall which is for auto-generated
        // stubs (for doing things like array access).  In this case, there
        // is no code to call per se.
        // @Todo: for right now I'm going to treat these like inlines, they
        // get counted in the caller's frame.
        if (handle == 0)
        {
            *pflags = 0;
            handle = IcecapProbes::GetProfilingHandle(ftn);
        }
    }
    else if (ftn->IsNDirect())
    {
        NDirectMethodDesc *p = (NDirectMethodDesc *) ftn;
        NDirect_Prelink(p);
        handle = (UINT_PTR) p->GetNDirectTarget();
    }

    _ASSERTE(handle && "Need a valid profiling handle");
    if (!handle)
        handle = (UINT_PTR) ftn;
    return (handle);
}

/*********************************************************************/
// Called to fill out the jit helper addresses for icecap profiling
// probes.  This is only done if profiling is enabled for icecap.
/*********************************************************************/
void SetIcecapStubbedHelpers()
{
    int         x, i;

    for (x = Start_Profiling, i = CORINFO_HELP_ICECAP_FASTCAP_START;  x <= Exit_Function;  x++, i++)
    {
        hlpFuncTable[i].pfnHelper = (void *) GetIcecapMethod((IcecapMethodID) x);
        _ASSERTE(hlpFuncTable[i].pfnHelper);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\list.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// @File: list.cpp
//
// @commn: Bunch of utility classes
//     
// HISTORY:
//   02/03/98: rajak:	created helper classes
//						DLink,  link node, every class that are intrusively linked
//								needs to have a data member of type DLink
//						DList:	Base list class contains the base implementation of all 
//								methods
//						TList:	Template linked list class, delegates all method calls
//								 to DList class, hence NO CODE BLOAT, we get good type checking
//						Queue:	Queue implementation, based on TList
//						
//						see below for futher info. on how to use these template classes
//
//-----------------------------------------------------------------------------

#include "common.h"

#include "list.h"

//----------------------------------------------------------------------------
// SLink::FindAndRemove(SLink *pHead, SLink* pLink)  
//		Find and remove
//----------------------------------------------------------------------------
SLink* SLink::FindAndRemove(SLink *pHead, SLink* pLink, SLink** ppPrior)
{
	_ASSERTE(pHead != NULL);
	_ASSERTE(pLink != NULL);

	SLink* pFreeLink = NULL;
    *ppPrior = NULL;

	while (pHead->m_pNext != NULL)
	{
		if (pHead->m_pNext == pLink)
		{
			pFreeLink = pLink;
			pHead->m_pNext = pLink->m_pNext;
            *ppPrior = pHead;
            break;
		}
        pHead = pHead->m_pNext;
	}
	
	return pFreeLink;
}


//----------------------------------------------------------------------------
//	void DLink::Remove (DLink* pLink)  
//		Remove the node from the list
//		the node has to be part of the circular list

void DLink::Remove (DLink* pLink)
{
	_ASSERTE(pLink != NULL);
	_ASSERTE(pLink->m_pNext != NULL);
	_ASSERTE(pLink->m_pPrev != NULL);

    DLink* pNext = pLink->m_pNext;
    DLink* pPrev = pLink->m_pPrev;

    pPrev->m_pNext = pNext;
    pNext->m_pPrev = pPrev;
    
    pLink->m_pNext = NULL;
    pLink->m_pPrev = NULL;

} // DList::Remove
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\listlock.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: ListLock.h
//
// ===========================================================================
// This file decribes the list lock and deadlock aware list lock.
// ===========================================================================
#ifndef LISTLOCK_H
#define LISTLOCK_H

#include "vars.hpp"
#include "threads.h"
#include "crst.h"

class ListLock;
// This structure is used for running class init methods (m_pData points to a EEClass) or JITing methods
// (m_pData points to a FunctionDesc). This class cannot have a destructor since it is used
// in function that also have COMPLUS_TRY's and the VC compiler doesn't allow classes with destructors
// to be allocated in a function that used SEH.
// @FUTURE Keep a pool of these (e.g. an array), so we don't have to allocate on the fly
// m_hInitException contains a handle to the exception thrown by the class init. This
// allows us to throw this information to the caller on subsequent class init attempts.
class LockedListElement
{
    friend ListLock;
    void InternalSetup(LockedListElement* pList,  void* pData)
    {
        m_pNext = pList;
        m_pData = pData;
        m_dwRefCount = 1;
        m_hrResultCode = E_FAIL;
        m_hInitException = NULL;
        InitializeCriticalSection(&m_CriticalSection);
    }

public:
    void *                  m_pData;
    CRITICAL_SECTION        m_CriticalSection;
    LockedListElement *     m_pNext;
    DWORD                   m_dwRefCount;
    HRESULT                 m_hrResultCode;
    OBJECTHANDLE            m_hInitException;

    void Enter()
    {
        _ASSERTE(m_dwRefCount != -1);
        Thread  *pCurThread = GetThread();
        BOOL     toggleGC = pCurThread->PreemptiveGCDisabled();

        if (toggleGC)
            pCurThread->EnablePreemptiveGC();
        LOCKCOUNTINCL("Enter in listlock.h");
        EnterCriticalSection(&m_CriticalSection);

        if (toggleGC)
            pCurThread->DisablePreemptiveGC();
    }

    void Leave()
    {
        _ASSERTE(m_dwRefCount != -1);
        LeaveCriticalSection(&m_CriticalSection);
        LOCKCOUNTDECL("Leave in listlock.h");
    }

    void Clear()
    {
        _ASSERTE(m_dwRefCount != -1);
        DeleteCriticalSection(&m_CriticalSection);
        m_dwRefCount = -1;
    }
};

class ListLock
{
    BaseCrst            m_CriticalSection;
    BOOL                m_fInited;
    LockedListElement * m_pHead;

public:

    BOOL IsInitialized()
    {
        return m_fInited;
    }

    // DO NOT MAKE A CONSTRUCTOR FOR THIS CLASS - There are global instances
    void Init(LPCSTR szTag, CrstLevel crstlevel, BOOL fAllowReentrancy, BOOL fAllowSameLevel)
    {
        m_pHead = NULL;
        m_CriticalSection.Init(szTag, crstlevel, fAllowReentrancy, fAllowSameLevel);
        m_fInited = TRUE;
    }

    void Destroy()
    {
        // There should not be any of these around
        _ASSERTE(m_pHead == NULL || dbg_fDrasticShutdown || g_fInControlC);

        if (m_fInited)
        {
            m_fInited = FALSE;
            m_CriticalSection.Destroy();
        }
    }

    void AddElement(LockedListElement* pElement, void* pData)
    {
        _ASSERTE(pElement);
        _ASSERTE(pData);
        pElement->InternalSetup(m_pHead, pData);
        m_pHead = pElement;
    }


    void Enter()
    {
        BOOL     toggleGC = FALSE;
        Thread  *pCurThread = GetThread();
        if(pCurThread) {
            toggleGC = pCurThread->PreemptiveGCDisabled();
            
            if (toggleGC)
                pCurThread->EnablePreemptiveGC();
        }

        LOCKCOUNTINCL("Enter in listlock.h");
        m_CriticalSection.Enter();
        
        if (toggleGC)
            pCurThread->DisablePreemptiveGC();
    }

    void Leave()
    {
        m_CriticalSection.Leave();
        LOCKCOUNTDECL("Leave in listlock.h");
    }

    // Must own the lock before calling this or is ok if the debugger has
    // all threads stopped
    LockedListElement *Find(void *pData);

    // Must own the lock before calling this!
    LockedListElement* Pop(BOOL unloading = FALSE) 
    {
#ifdef _DEBUG
        if(unloading == FALSE)
            _ASSERTE(m_CriticalSection.OwnedByCurrentThread());
#endif

        if(m_pHead == NULL) return NULL;
        LockedListElement* pEntry = m_pHead;
        m_pHead = m_pHead->m_pNext;
        return pEntry;
    }

    // Must own the lock before calling this!
    LockedListElement* Peek() 
    {
        _ASSERTE(m_CriticalSection.OwnedByCurrentThread());
        return m_pHead;
    }

    // Must own the lock before calling this!
    void Unlink(LockedListElement *pItem)
    {
        _ASSERTE(m_CriticalSection.OwnedByCurrentThread());
        LockedListElement *pSearch;
        LockedListElement *pPrev;

        pPrev = NULL;

        for (pSearch = m_pHead; pSearch != NULL; pSearch = pSearch->m_pNext)
        {
            if (pSearch == pItem)
            {
                if (pPrev == NULL)
                    m_pHead = pSearch->m_pNext;
                else
                    pPrev->m_pNext = pSearch->m_pNext;

                return;
            }

            pPrev = pSearch;
        }

        // Not found
    }

};


class WaitingThreadListElement
{
public:
    Thread *                   m_pThread;
    WaitingThreadListElement * m_pNext;
};

class DeadlockAwareLockedListElement: public LockedListElement
{
public:
    Thread *                   m_pLockOwnerThread;
    int                        m_LockOwnerThreadReEntrancyCount;
    WaitingThreadListElement * m_pWaitingThreadListHead;
    ListLock                 * m_pParentListLock;

    void AddEntryToList(ListLock* pLock, void* pData)
    {
        pLock->AddElement(this, pData);
        m_hrResultCode = S_FALSE; // Success code so that if we recurse back on ourselves (A->B->A), we don't fail
        m_pLockOwnerThread = NULL;
        m_pWaitingThreadListHead = NULL;
        m_pParentListLock = pLock;
        m_LockOwnerThreadReEntrancyCount = 0;
    }
        
    // This method cleans up all the data associated with the entry.
    void                       Destroy();

    // This method returns TRUE if the lock was acquired properly and FALSE
    // if trying to acquire the lock would cause a deadlock.
    BOOL                       DeadlockAwareEnter();
    void                       DeadlockAwareLeave();

    // This method returns NULL if there is no cycle between the start entry and any
    // entries owned by the current thread. If there is a cycle, the entry that the
    // current thread owns that is in the cycle is returned.
    static DeadlockAwareLockedListElement *GetCurThreadOwnedEntryInDeadlockCycle(DeadlockAwareLockedListElement *pStartingEntry, DeadlockAwareLockedListElement *pLockedListHead);
};

#endif // LISTLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\listlock.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: ListLock.cpp
//
// ===========================================================================
// This file decribes the list lock and deadlock aware list lock.
// ===========================================================================

#include "common.h"
#include "ListLock.h"

void DeadlockAwareLockedListElement::Destroy()
{
    DeleteCriticalSection(&m_CriticalSection);

    while (m_pWaitingThreadListHead)
    {
        WaitingThreadListElement *pCurWaitingThreadEntry = m_pWaitingThreadListHead;
        m_pWaitingThreadListHead = pCurWaitingThreadEntry->m_pNext;
        delete pCurWaitingThreadEntry;
    }
}

BOOL DeadlockAwareLockedListElement::DeadlockAwareEnter()
{
    Thread  *pCurThread = GetThread();
    BOOL     toggleGC = pCurThread->PreemptiveGCDisabled();

    if (toggleGC)
        pCurThread->EnablePreemptiveGC();


    //
    // Check the simple ( and most frequent ) conditions before we do any fancy 
    // deadlock detection.
    //

    m_pParentListLock->Enter();

    // !!! It is not safe to take the inner lock if there are threads
    // waiting for it.
    // This thread has m_pParentListLock, and will grab m_CriticalSection,
    // but one of the waiting thread may have grabbed m_CriticalSection,
    // and wants to grab m_pParentListLock.
	if (!m_pLockOwnerThread && !m_pWaitingThreadListHead)
	{
		// The lock does not have an owner then we can safely take it.
		LOCKCOUNTINCL("Deadlockawareenter in listlock.cpp");						\
	    EnterCriticalSection(&m_CriticalSection);
		m_pLockOwnerThread = pCurThread;
		m_LockOwnerThreadReEntrancyCount = 1;
		m_pParentListLock->Leave();
		if (toggleGC)
			pCurThread->DisablePreemptiveGC();
		return TRUE;
	}
	else if (pCurThread == m_pLockOwnerThread)
	{
		// The lock is owned by the current thread so we can safely take it.
		m_LockOwnerThreadReEntrancyCount++;
		m_pParentListLock->Leave();
		if (toggleGC)
			pCurThread->DisablePreemptiveGC();
		return TRUE;
	}


    //
    // Check for deadlocks and update the deadlock detection data. 
    //

    // Check for deadlocks.
    if (GetCurThreadOwnedEntryInDeadlockCycle(this, (DeadlockAwareLockedListElement*) m_pParentListLock->Peek()) != NULL)
    {
        m_pParentListLock->Leave();
        if (toggleGC)
            pCurThread->DisablePreemptiveGC();
        return FALSE;
    }

    // Update the deadlock detection data.
    WaitingThreadListElement *pNewWaitingThreadEntry = (WaitingThreadListElement *)_alloca(sizeof(WaitingThreadListElement));
    pNewWaitingThreadEntry->m_pThread = pCurThread;
    pNewWaitingThreadEntry->m_pNext = m_pWaitingThreadListHead;
    m_pWaitingThreadListHead = pNewWaitingThreadEntry;

    m_pParentListLock->Leave();


	//
	// Wait for the critical section.
	//
	LOCKCOUNTINCL("Deadlockawareenter in listlock.cpp");						\
    EnterCriticalSection(&m_CriticalSection);


    //
    // Update the deadlock detection data. This must be synchronized.
    //

    m_pParentListLock->Enter();

    if (m_pLockOwnerThread)
    {
        _ASSERTE(m_pLockOwnerThread == pCurThread);
        m_LockOwnerThreadReEntrancyCount++;
    }
    else
    {
        _ASSERTE(m_LockOwnerThreadReEntrancyCount == 0);
        m_pLockOwnerThread = pCurThread;
        m_LockOwnerThreadReEntrancyCount = 1;
    }

    WaitingThreadListElement **ppPrevWaitingThreadEntry = &m_pWaitingThreadListHead;
    WaitingThreadListElement *pCurrWaitingThreadEntry = m_pWaitingThreadListHead;
    while (pCurrWaitingThreadEntry)
    {
        if (pCurrWaitingThreadEntry == pNewWaitingThreadEntry)
        {
            *ppPrevWaitingThreadEntry = pCurrWaitingThreadEntry->m_pNext;
            break;
        }

        ppPrevWaitingThreadEntry = &pCurrWaitingThreadEntry->m_pNext;
        pCurrWaitingThreadEntry = pCurrWaitingThreadEntry->m_pNext;
    }

    // The current thread had better be in the list of waiting threads!
    _ASSERTE(pCurrWaitingThreadEntry);

    m_pParentListLock->Leave();


    //
    // Restore the GC state and return TRUE to indicate that the lock has been obtained.
    //

    if (toggleGC)
        pCurThread->DisablePreemptiveGC();
    return TRUE;
}

void DeadlockAwareLockedListElement::DeadlockAwareLeave()
{
	// Update the deadlock detection data. This must be synchronized.
	m_pParentListLock->Enter();
	if (--m_LockOwnerThreadReEntrancyCount == 0)
	{
		// If the reentrancy count hits 0 then we need to leave the critical section.
		m_pLockOwnerThread = NULL;
	    LeaveCriticalSection(&m_CriticalSection);
	    LOCKCOUNTDECL("Deadlockawareleave in listlock.cpp");						\

	}
	m_pParentListLock->Leave();
}

DeadlockAwareLockedListElement *DeadlockAwareLockedListElement::GetCurThreadOwnedEntryInDeadlockCycle(DeadlockAwareLockedListElement *pStartingEntry, DeadlockAwareLockedListElement *pLockedListHead)
{
    Thread *pCurThread = GetThread();
    Thread *pEntryOwnerThread = pStartingEntry->m_pLockOwnerThread;

    // We start at the head of the list and check to see if the specified thread is waiting
    // for a lock. If it is then we need to check to see if the owner of the lock is the
    // current thread. If it is then we have a deadlock situation. If it is not then
    // we check to see if the thread that owns the lock is waiting after another lock and
    // so forth.
    DeadlockAwareLockedListElement *pCurEntry = pLockedListHead;
    while (pCurEntry)
    {
        BOOL bThreadIsWaitingOnEntry = FALSE;

        WaitingThreadListElement *pCurWaitingThreadEntry = pCurEntry->m_pWaitingThreadListHead;
        while (pCurWaitingThreadEntry)
        {
            if (pCurWaitingThreadEntry->m_pThread == pEntryOwnerThread)
            {
                bThreadIsWaitingOnEntry = TRUE;
                break;
            }

            pCurWaitingThreadEntry = pCurWaitingThreadEntry->m_pNext;
        }

        if (bThreadIsWaitingOnEntry)
        {
            if (pCurEntry->m_pLockOwnerThread == pCurThread)
            {
                // The current thread owns the lock so this indicates a deadlock and the
                // entry is the one that needs to be returned.
                return pCurEntry;
            }
            else
            {
                // The current thread is waiting for another thread. So start back at the 
                // beginning of the list of entries using the owner of the current entry as 
                // the thread to check to see if it waiting on the current thread.
                pEntryOwnerThread = pCurEntry->m_pLockOwnerThread;
                pCurEntry = pLockedListHead;
                continue;
            }
        }

        pCurEntry = (DeadlockAwareLockedListElement*) pCurEntry->m_pNext;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\list.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// @File: list.h
//
// @commn: Bunch of utility classes
//     
// HISTORY:
//   02/03/98: rajak:	created helper classes
//						SLink, link node for singly linked list, every class that is intrusively
//								linked should have a data member of this type
//						SList, template linked list class, contains only inline 
//								methods for fast list operations, with proper type checking
//						DLink,  link node, every class that are intrusively linked
//								needs to have a data member of type DLink
//						DList:	Template linked list class, contains only inline methods
//							 hence NO CODE BLOAT, we get good type checking
//						Queue:	Queue implementation, based on TList
//						
//						see below for futher info. on how to use these template classes
//
//-----------------------------------------------------------------------------

//#ifndef _H_UTIL
//#error I am a part of util.hpp Please don't include me alone !
//#endif

#ifndef _H_LIST_
#define _H_LIST_

//------------------------------------------------------------------
// struct SLink, to use a singly linked list 
// have a data member of type SLink in your class
// and instantiate the template SList class, passing 
// in the offset to the SLink data member
//--------------------------------------------------------------------


struct SLink
{		
	SLink* m_pNext;
	SLink() 
	{
		m_pNext = NULL;
	}

	// find pLink within the list starting at pHead
	// if found remove the link from the list and return the link
	// otherwise return NULL
	static SLink* FindAndRemove(SLink *pHead, SLink* pLink, SLink ** ppPrior);
};

//------------------------------------------------------------------
// class SList, to use a singly linked list 
// have a data member of type SLink in your class
// and instantiate the template SList class, passing 
// in the offset to the SLink data member

// SList has two different behaviours depending on boolean
// fHead variable, 

// if fHead is true, then the list allows only InsertHead  operations
// if fHead is false, then the list allows only InsertTail operations
// the code is optimized to perform these operations
// all methods are inline, and conditional compiled based on template
// argument 'fHead'
// so there is no actual code size increase
//--------------------------------------------------------------
template <class T, int offset, bool fHead = false>
class SList
{
    friend HRESULT InitializeMiniDumpBlock();

public:
	// typedef used by the Queue class below
	typedef T ENTRY_TYPE; 

protected:

	// used as sentinel 
	SLink  m_link; // slink.m_pNext == Null
	SLink* m_pHead;
	SLink* m_pTail;

	// get the list node within the object
    SLink* GetLink (T* pLink)
	{
		return ((SLink*)((UCHAR *)pLink + offset));
	}
    
	// move to the beginning of the object given the pointer within the object
	T* GetObject (SLink* pLink)
	{
		// if offset == 0, compiler will optimize this call 
		// to just return pLink, so if possible always put m_link
		// as the first data member
		return (offset && (pLink == NULL)) // check for null
				? NULL 
				: (T*)((UCHAR *)pLink - offset);
	}

public:

	SList()
	{
		Init();
	}

	void Init()
	{
		m_pHead = &m_link;
		// NOTE :: fHead variable is template argument 
		// the following code is a compiled in, only if the fHead flag
		// is set to false,
		if (!fHead)
		{
			m_pTail = &m_link;
		}
	}

	bool IsEmpty()
	{
		return m_pHead->m_pNext == NULL;
	}

	void InsertTail(T *pObj)
	{
		// NOTE : conditional compilation on fHead template variable
		if (!fHead)
		{
			_ASSERTE(pObj != NULL);
			SLink *pLink = GetLink(pObj);

			m_pTail->m_pNext = pLink;
			m_pTail = pLink;
		}
		else 
		{// you instantiated this class asking only for InsertHead operations
			_ASSERTE(0);
		}
	}
	
	void InsertHead(T *pObj)
	{
		// NOTE : conditional compilation on fHead template variable
		if (fHead)
		{
			_ASSERTE(pObj != NULL);
			SLink *pLink = GetLink(pObj);

			pLink->m_pNext = m_pHead->m_pNext;
			m_pHead->m_pNext = pLink;
		}
		else
		{// you instantiated this class asking only for InsertTail operations
			_ASSERTE(0);
		}
	}

	T*	RemoveHead()
	{
		SLink* pLink = m_pHead->m_pNext;
		if (pLink != NULL)
		{
			m_pHead->m_pNext = pLink->m_pNext;
		}
		// conditionally compiled, if the instantiated class
		// uses Insert Tail operations
		if (!fHead)
		{
			if(m_pTail == pLink)
			{
				m_pTail = m_pHead;
			}
		}

		return GetObject(pLink);
	}

	T*	GetHead()
	{
		return GetObject(m_pHead->m_pNext);
	}

	T*	GetTail()
	{
		// conditional compile
		if (fHead)
		{	// you instantiated this class asking only for InsertHead operations
			// you need to walk the list yourself to find the tail
			_ASSERTE(0);
		}
		return (m_pHead != m_pTail) ? GetObject(m_pTail) : NULL;
	}

	T *GetNext(T *pObj)
	{
		_ASSERTE(pObj != NULL);
		return GetObject(GetLink(pObj)->m_pNext);
	}

	T* FindAndRemove(T *pObj)
	{
		_ASSERTE(pObj != NULL);

        SLink   *prior;
        SLink   *ret = SLink::FindAndRemove(m_pHead, GetLink(pObj), &prior);

        if (ret == m_pTail)
            m_pTail = prior;

		return GetObject(ret);
	}
};




//----------------------------------------------------------------------------
// @class: DLink 
// @commn: Linked list implementation below uses DLink as the element
//			any class whose instance is going to be a part of a linked list 
//			should contain a data member of type DLink
//
//----------------------------------------------------------------------------
struct DLink
{
public:
	DLink* m_pPrev;	// pointer to the prev node
    DLink* m_pNext;	// pointer to next node

	
	DLink()			//@constructor
	{
		Init();
	}

    void Init ()		// initialize pointers to NULL
	{
		m_pPrev = m_pNext = NULL;
	}

	// insert self node after pLink
	//static void InsertAfter (DLink* pPrev, DLink *pLink);
	//static DLink* Find(DLink* pHead, DLink* pLink);
	static void Remove(DLink* pLink);
};


//----------------------------------------------------------------------------
// Template class: DList 
//		
//     This templated class is an implementation of intrusive linked lists
//     i.e. a linked list where the storage for the linked fields is within the
//     structure to be linked itself. Class DList is actually a template,
//     taking two arguments:
//     1. type T: implements a link-list of pointers to T
//     2. offset: represents the offset of the link within the class T. 
//
//     Sample usage of this class is as follows:
// 
//     To make a linked list of Foo, the class Foo should look like this
//     class Foo 
//     {
//         .....
//         DLink m_Node;
//         .....
//     }
//  
//     Now to declare a linked list, just do the following:
//
//     typedef DList<Foo, offsetof(Foo, m_Node)> FooList;
// 
// NOTES: All methods in the class are inline, they do minimal work
//		  the base class DList provides the actual implementation
//		  so there isn't any code bloat due to use of templates
//		  Advantages: you get properly typed list 
//----------------------------------------------------------------------------
template <class T, int offset>
class DList 
{
	// node to keep track of the head and tail
	DLink		m_Base;    
public:

	// typedef used by the Queue class below
	typedef T ENTRY_TYPE; 

	// Init
    void Init ()
	{
		m_Base.m_pNext = &m_Base;
		m_Base.m_pPrev = &m_Base;
	}
    
	//@method: IsEmpty (), check if list is empty
    bool IsEmpty () const
	{
		return (m_Base.m_pNext == &m_Base);
	}

	// InsertHead
    void InsertHead (ENTRY_TYPE* pObj)
	{
		DLink *pLink = GetLink (pObj);
		_ASSERTE(pLink);
		InsertHead(pLink);
	}

	// InsertTail
    void InsertTail (ENTRY_TYPE* pObj)
	{
		DLink *pLink = GetLink (pObj);
		_ASSERTE(pLink);
		InsertTail(pLink);
	}

	// InsertAfter
    void InsertAfter (ENTRY_TYPE* pPrevObj,ENTRY_TYPE* pObj)
	{
		DLink *pLink = GetLink (pObj);
		DLink *pPrev = GetLink (pPrevObj);
		_ASSERTE(pLink);
		_ASSERTE(pPrev);
		InsertAfter (pPrev, pLink);
	}

	// InsertBefore
    void InsertBefore (ENTRY_TYPE* pCurr,ENTRY_TYPE* pObj)
	{
		_ASSERTE(pCurr);
		DLink *pLink = GetLink (pObj);
		DLink *pPrev = GetPrevLink (GetLink(pCurr));
		_ASSERTE(pLink);
		
		if (pPrev == NULL)
			InsertHead(pLink);
		else
			InsertAfter (pPrev,pLink);
	}

	// Remove
    void Remove (ENTRY_TYPE* pLink)
	{
		DLink::Remove (GetLink(pLink));
	}
    
	// GetNext
    ENTRY_TYPE* GetNext (ENTRY_TYPE* pObj)
	{
		DLink *pLink = GetLink(pObj);
		_ASSERTE(pLink);
		return GetObject(GetNextLink(pLink));

	}

	// GetPrev
    ENTRY_TYPE* GetPrev (ENTRY_TYPE* pObj)
	{
		DLink *pLink = GetLink(pObj);
		_ASSERTE(pLink);
		return GetObject(GetPrevLink(pLink));
	}
   
	// GetHead
    ENTRY_TYPE* GetHead ()
	{
		return GetObject(GetHeadLink());
	}
	
	// GetTail
    ENTRY_TYPE* GetTail ()
	{
		return GetObject(GetTailLink());
	}

	// RemoveHead
	ENTRY_TYPE* RemoveHead ()
	{
		DLink* pLink = GetHeadLink();
		//check for null
		if (pLink != NULL)
			DLink::Remove (pLink);
		return GetObject(pLink);
	}
    
	// RemoveTail
    ENTRY_TYPE* RemoveTail ()
	{
		DLink* pLink = GetTailLink();
		//check for null
		if (pLink != NULL)
			DLink::Remove (pLink);
		return GetObject(pLink);
	}

	ENTRY_TYPE* Find(ENTRY_TYPE* pObj)
	{
		_ASSERTE(pObj);
		DLink *pLink = GetLink(pObj);
		_ASSERTE(pLink);
		return GetObject(Find(pLink));
	}

	ENTRY_TYPE*	FindAndRemove(ENTRY_TYPE *pObj)
	{
		_ASSERTE(pObj);
		DLink *pLink = GetLink(pObj);
		_ASSERTE(pLink);
		pLink = Find(pLink);
		if (pLink)
			DLink::Remove(pLink);
		return GetObject(pLink);
	}

protected:

	void InsertHead (DLink* pLink);
	void InsertTail (DLink *pLink);
	void InsertAfter (DLink* pPrev, DLink* pLink);

	DLink* Find(DLink* pLink)
		{
			DLink* currNode = GetHeadLink();

			// Search the list for the given element
			// and remove.  
			//
			while ( currNode && currNode != pLink )
			{
				currNode = GetNextLink(currNode);
			}

			return currNode;
		}

	DLink* GetHeadLink()
	{
		return (IsEmpty ()) ? NULL : m_Base.m_pNext;
	}

	DLink* GetTailLink()
	{
		return (IsEmpty ()) ? NULL : m_Base.m_pPrev;
	}

	DLink* GetNextLink(DLink* pLink)
	{
		return (pLink->m_pNext == &m_Base) ? NULL : pLink->m_pNext;
	}

	DLink* GetPrevLink(DLink* pLink)
	{
		return (pLink->m_pPrev == &m_Base) ? NULL : pLink->m_pPrev;
	}

	// get the list node within the object
    DLink* GetLink (ENTRY_TYPE* pObj)
	{
		return ((DLink*)((UCHAR *)pObj + offset));
	}
    
	// move to the beginning of the object given the pointer within the object
	ENTRY_TYPE* GetObject (DLink* pLink)
	{
		return (offset && (pLink == NULL)) // check for null
				? NULL 
				: (ENTRY_TYPE*)((UCHAR *)pLink - offset);
	}

};



//----------------------------------------------------------------------------
// DList::InsertHead   
//		Insert node at the head of list. 
//
template <class T, int offset>
void
DList<T,offset>::InsertHead (DLink* pLink)
{
	_ASSERTE (pLink->m_pNext == NULL);
	_ASSERTE (pLink->m_pPrev == NULL);

    pLink->m_pNext = m_Base.m_pNext;
    m_Base.m_pNext->m_pPrev = pLink;
    
    m_Base.m_pNext = pLink;
    pLink->m_pPrev = &m_Base;
    
} // DList::InsertHead ()


//----------------------------------------------------------------------------
// DList::InsertTail   
//		Insert node at the tail of the list.
// 
template <class T, int offset>
void
DList<T,offset>::InsertTail (DLink *pLink)
{
	_ASSERTE (pLink->m_pNext == NULL);
	_ASSERTE (pLink->m_pPrev == NULL);

    pLink->m_pPrev = m_Base.m_pPrev;
    m_Base.m_pPrev->m_pNext = pLink;
    
    m_Base.m_pPrev = pLink;
    pLink->m_pNext = &m_Base;
    
} // DList::InsertTail ()


//----------------------------------------------------------------------------
// DList::InsertAfter   
//  
//
template <class T, int offset>
void 
DList<T,offset>::InsertAfter (DLink* pPrev,DLink* pLink)
{
    DLink* pNext;
    _ASSERTE (pPrev != NULL);
	_ASSERTE (pLink->m_pNext == NULL);
	_ASSERTE (pLink->m_pPrev == NULL);

    pNext = pPrev->m_pNext;
    
    pLink->m_pNext = pNext;
    pNext->m_pPrev = pLink;
    
    pPrev->m_pNext = pLink;
    pLink->m_pPrev = pPrev;

} // DList::InsertAfter ()


//----------------------------------------------------------------------------
// class: Queue 
//
//     This class implements a queue using the linked list implementation
//     provided by template TList class, the data members of the queue
//	   are of type T, the template class TList should also be of type T.
//		TList can be either a DList or an SList which supports InsertHead operations.
//
// NOTES: All methods in the class are inline, they do minimal work
//		  the m_list data member provides the actual implementation
//		  so there isn't any code bloat due to use of templates
//		  ADVANTAGES: you get properly typed queue 
//
//----------------------------------------------------------------------------

template <class TList>
class Queue
{
	// entry type depends on the type of the list
	typedef TList::ENTRY_TYPE ENTRY_TYPE;
	
	// length of the queue
	unsigned	m_len;

public:

	void	Init()
		{
			m_list.Init ();
		}

    void	Enqueue (ENTRY_TYPE* pLink)
		{
			m_len++;
			m_list.InsertTail(pLink);
		}

    ENTRY_TYPE*		Dequeue ()
		{
			ENTRY_TYPE* pObj = m_list.RemoveHead();
			if (pObj != NULL)
			{
				_ASSERTE(m_len > 0);
				m_len--;
			}
			return pObj;
		}

	ENTRY_TYPE*		FindAndRemove(ENTRY_TYPE* pLink)
		{
			ENTRY_TYPE* p = m_list.FindAndRemove(pLink);
			if (p != NULL)
			{
				_ASSERTE(m_len > 0);
				m_len--;
			}
			return p;
		}

    ENTRY_TYPE*		GetNext (ENTRY_TYPE* pLink)
	{
		return m_list.GetNext (pLink);
	}

    ENTRY_TYPE*		GetHead ()
	{
		return m_list.GetHead ();
	}

    ENTRY_TYPE*		Tail ()
	{
		return m_list.GetTail();
	}

    bool	IsEmpty ()
	{
		return m_list.IsEmpty ();
	}
    
	unsigned Length()
	{
		return m_len;
	}

private:
    TList	m_list;
};

#endif // _H_LIST_

// End of file: list.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mdconverter.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

	MDConverter.h

Abstract:

	This file declares the CMetaDataConverter

--*/


class CMetaDataConverter : public IMetaDataConverter
{
	CorHost* m_pCorHost;
public:
	CMetaDataConverter(CorHost* pCorHost) { m_pCorHost = pCorHost; }

    STDMETHOD (QueryInterface)(REFIID iid, void **ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

	STDMETHOD (GetMetaDataFromTypeInfo)(ITypeInfo* pITI, IMetaDataImport** ppMDI);
	STDMETHOD (GetMetaDataFromTypeLib)(ITypeLib* pITL, IMetaDataImport** ppMDI);
	STDMETHOD (GetTypeLibFromMetaData)(BSTR strModule, BSTR strTlbName, ITypeLib** ppITL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mdconverter.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

	MDConverter.cpp

Abstract:

	This module implements the CMetaDataConverter

--*/


#include "common.h"
#include "..\MD\inc\imptlb.h"
#include <corhost.h>
#include "MDConverter.h"
#include <utilcode.h>
#include "PerfCounters.h"


STDMETHODIMP CMetaDataConverter::QueryInterface(REFIID iid, void **ppv) {
    return m_pCorHost->QueryInterface(iid, ppv);
}

STDMETHODIMP_(ULONG) CMetaDataConverter::AddRef(void) {
    return m_pCorHost->AddRef(); 
}

STDMETHODIMP_(ULONG) CMetaDataConverter::Release(void) {
    return m_pCorHost->Release(); 
}




STDMETHODIMP CMetaDataConverter::GetMetaDataFromTypeInfo(ITypeInfo* pITI, IMetaDataImport** ppMDI)
{
	if (NULL == pITI || NULL == ppMDI)
		return E_POINTER;

	HRESULT hr = S_OK;
    mdTypeDef cl;

	// Create TypeLib importer
	CImportTlb TlbImporter;

	// Convert TypeInfo
	IfFailGo(TlbImporter.ImportTypeInfo(pITI, &cl));

	// QI for IMetaDataImport interface
	IfFailGo(TlbImporter.GetInterface(IID_IMetaDataImport, (void **) ppMDI));

ErrExit:
	return hr;
}



STDMETHODIMP CMetaDataConverter::GetMetaDataFromTypeLib(ITypeLib* pITL, IMetaDataImport** ppMDI)
{
	if (NULL == pITL || NULL == ppMDI)
		return E_POINTER;

	HRESULT hr = S_OK;

	// Create TypeLib importer
	CImportTlb TlbImporter;

	// Convert TypeLib
	IfFailGo(TlbImporter.ImportTypeLib(pITL));
    COUNTER_ONLY(GetPrivatePerfCounters().m_Interop.cTLBImports++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Interop.cTLBImports++);


	// QI for IMetaDataImport interface
	IfFailGo(TlbImporter.GetInterface(IID_IMetaDataImport, (void **) ppMDI));

ErrExit:
	return hr;
}



STDMETHODIMP CMetaDataConverter::GetTypeLibFromMetaData(BSTR strModule, BSTR strTlbName, ITypeLib** ppITL)
{
	if (NULL == strModule || NULL == strTlbName || NULL == ppITL)
		return E_POINTER;

    HRESULT	  hr = S_OK;
    BOOL	  fInitEE = FALSE;          
    Module	  *pModule = NULL;          
    Thread	  *pThread = NULL;
    AppDomain *pDomain = NULL;

    if (SystemDomain::System() == NULL) {
        IfFailGo(CoInitializeEE(COINITEE_DEFAULT));
        fInitEE = TRUE;
    }

    pThread = SetupThread();
    IfNullGo(pThread);

    {
    ExportTypeLibFromLoadedAssembly_Args args = {pModule->GetAssembly(), strTlbName, ppITL, 0, 0, S_OK};
    IfFailGo(SystemDomain::ExternalCreateDomain(strModule, &pModule, &pDomain, 
        (SystemDomain::ExternalCreateDomainWorker)ExportTypeLibFromLoadedAssembly_Wrapper, &args));
    
    if (!pModule) {
        IfFailGo(TLBX_E_CANT_LOAD_MODULE);
    }

    hr = args.hr;
    }

    IfFailGo(hr);     // so we get the DebBreakHr behavior

ErrExit:
    if (fInitEE)
        CoUninitializeEE(FALSE);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\listlock.inl ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: ListLock.inl
//
// ===========================================================================
// This file decribes the list lock and deadlock aware list lock functions
// that are inlined but can't go in the header.
// ===========================================================================
#ifndef LISTLOCK_INL
#define LISTLOCK_INL

#include "listlock.h"
#include "dbginterface.h"
// Must own the lock before calling this or is ok if the debugger has
// all threads stopped

inline LockedListElement *ListLock::Find(void *pData)
{
#ifdef DEBUGGING_SUPPORTED
    _ASSERTE(m_CriticalSection.OwnedByCurrentThread() || 
             CORDebuggerAttached() && g_pDebugInterface->IsStopped());
#else
    _ASSERTE(m_CriticalSection.OwnedByCurrentThread());
#endif // DEBUGGING_SUPPORTED

    LockedListElement *pSearch;

    for (pSearch = m_pHead; pSearch != NULL; pSearch = pSearch->m_pNext)
    {
        if (pSearch->m_pData == pData)
            return pSearch;
    }

    return NULL;
}


#endif // LISTLOCK_I
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\marshaler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "excep.h"
#include "comvariant.h"
#include "olevariant.h"
#include "comdatetime.h"
#include "comstring.h"
#include "comstringbuffer.h"
#include "nstruct.h"
#include "ml.h"
#include "stublink.h"
#include "mlgen.h"
#include "COMDelegate.h"
#include "mlinfo.h"
#include "COMNDirect.h"
#include "gc.h"
#include "log.h"
#include "comvarargs.h"
#include "frames.h"
#include "util.hpp"
#include "interoputil.h"

/* ------------------------------------------------------------------------- *
 * Marshalers
 * ------------------------------------------------------------------------- */

class Marshaler
{
  public:
    Marshaler(CleanupWorkList *pList, 
              BYTE nativeSize, BYTE comSize, 
              BYTE fReturnsNativeByref, BYTE fReturnsComByref)
      : m_pList(pList),
        m_cbNative(MLParmSize(nativeSize)), m_cbCom(StackElemSize(comSize)),
        m_fReturnsNativeByref(fReturnsNativeByref),
        m_fReturnsComByref(fReturnsComByref),
        m_pMarshalerCleanupNode(NULL) {}

    //
    // A marshaler should be created in space local to the stack frame being
    // marshaled.  Marshal() is called before the call is made, and Unmarshal()
    // afterward.  (Or Prereturn() and Return() for return values.)
    //
    // Note that marshalers rely on static overriding & template instantiation, 
    // rather than virtual functions.  This is strictly for reasons of efficiency, 
    // since the subclass-specialized functions are typically very simple 
    // functions that ought to be inlined.
    // (Actually a really smart compiler ought to be able to generate similar code
    // from virtual functions, but our compiler is not that smart.)
    //
    // NOTE ON NAMING:  (this is a bit confusing...)
    //   "Native" means unmanaged - e.g. classic COM
    //   "Com" means managed - i.e. COM+ runtime.
    //
    // Definitions:
    //
    // "SPACE" & "CONTENTS"
    // A value being marshaled is divided into 2 levels - its "space" and 
    // its "contents".  
    // The distinction is made as follows:
    //      an "in" parameter has both valid space & contents.
    //      an "non-in" parameter has valid space, but not valid contents.
    //      a byref "non-in" parameter has neither valid space nor contents.
    //
    // For instance, for an array type, the space is the array itself,
    // while the contents is the elements in the array.
    //
    // Note that only container types have a useful definition "space" vs. "contents",
    // primitive types simply ignore the concept & just have contents.  
    //
    // "HOME"                  
    // A marshaler has 2 "homes" - one for native values and one for com values.
    // The main function of the marshaler is to copy values in and out of the homes,
    // and convert between the two homes for marshaling purposes.
    //
    // A home has 3 states:
    //      empty: empty
    //      allocated: valid space but not contents
    //      full: valid space & contents.
    //
    // In order to clean up after a marshaling, the output home should be
    // emptied.
    //
    // A marshaler also has a "dest" pointer, which is a copy of a byref parameter's
    // input destination.
    //
    // Marshalers also define 4 constants:
    //  c_nativeSize - size of the native value on the stack
    //  c_comSize - size of the native value on the stack
    //  c_fReturnsNativeByref - whether a native return value is byref or not
    //      (on x86 this means a pointer to the value is returned)
    //  c_fReturnsComByref - whether a COM+ return value is byref or not
    //      (this means that the return value appears as a byref parameter)
    //

    //
    // Type primitives:
    //
    // These small routines form the primitive from which the marshaling
    // routines are built.  There are many of these routines, they
    // are mostly intended for use by the marshaling templates rather
    // than being called directly.  Because of the way the templates
    // are instantiated they will usually be inlined so the fact that
    // there are a lot of little routines won't be a performance hit.
    //

    //
    // InputStack : Copies a value from the stack into a home.
    //  START: the home is empty
    //  END: Home is allocated, but may or may not be full
    //      (depending on whether it's an [in] parameter)
    //

    void InputNativeStack(void *pStack) {}
    void InputComStack(void *pStack) {}

    //
    // InputRef : Copies the value referred to by the dest pointer into a home.
    //  START: the home is empty
    //  END: the home is full
    //
    void InputNativeRef(void *pStack) {}
    void InputComRef(void *pStack) {}

    //
    // InputDest : Copies a reference from the stack into the marshal's dest pointer.
    //
    void InputDest(void *pStack) { m_pDest = *(void**)pStack; }

    //
    // InputComField
    // OutputComField : Copies the com home to and from the given object
    // field.
    //
    void InputComField(void *pField) { _ASSERTE(!"NYI"); }
    void OutputComField(void *pField) { _ASSERTE(!"NYI"); };

    //
    // ConvertSpace: Converts the "space" layer from one home to another.
    // Temp version used when native buffer exists only over the call.
    //  START: dest home is empty
    //  END: dest home is allocated
    //
    void ConvertSpaceNativeToCom() {}
    void ConvertSpaceComToNative() {}
    void ConvertSpaceComToNativeTemp() {}

    //
    // ConvertSpace: Converts the "contents" layer from one home to another
    //  START: dest home is allocated
    //  END: dest home is full
    //
    void ConvertContentsNativeToCom() {}
    void ConvertContentsComToNative() {}

    //
    // ClearSpace: Clears the "space" and "contents" layer in a home.
    // Temp version used when native buffer exists only over the call.
    //  START: dest home is allocated
    //  END: dest home is empty
    //
    void ClearNative() {}
    void ClearNativeTemp() {}
    void ClearCom() {}


    // ReInitNative: Reinitializes the "space" to a safe value for deallocating
    // (normally a "NULL" pointer). Used to overwrite dangling pointers left
    // after a ClearNative(). Note that this method need not do anything if
    // the datatype isn't allocated or lacks allocated subparts.
    //   START: dest home is empty
    //   END:   dest home is full (and set to safe value)
    void ReInitNative() {}

    //
    // ClearContents: Clears the "contents" layer in a home.
    //  START: dest home is full
    //  END: dest home is allocated
    //
    void ClearNativeContents() {}
    void ClearComContents() {}

    //
    // OutputStack copies a home's value onto the stack, possibly
    // performing type promotion in the process.
    //  START: home is full
    //  END: home is empty
    //
    void OutputNativeStack(void *pStack) {}
    void OutputComStack(void *pStack) {}

    //
    // OutputRef copies a pointer to a home, onto the stack
    //
    void OutputNativeRef(void *pStack) {}
    void OutputComRef(void *pStack) {}


    // BackpropagateComRef copies second home to primary home if necessary
    void BackpropagateComRef() {}

    //
    // OutputDest copies a home's value into the location pointed
    // to by the dest pointer.
    //  START: home is full
    //  END: home is empty
    //
    void OutputNativeDest() {}
    void OutputComDest() {}

    //
    // Templates:
    // These templates build marshaling routines using the above primitives.
    // They are typically instantiated in subclasses of marshaler to implement
    // the virtual marshaling opcode routines.
    //

    //
    // Native to Com Marshaling
    //

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalNativeToComT(MARSHAL_CLASS *pMarshaler,
                                                void *pInStack, void *pOutStack)
    {
        pMarshaler->InputNativeStack(pInStack);
        pMarshaler->ConvertSpaceNativeToCom();
        pMarshaler->ConvertContentsNativeToCom();
        pMarshaler->OutputComStack(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalNativeToComOutT(MARSHAL_CLASS *pMarshaler,
                                                   void *pInStack, void *pOutStack)
    {
        pMarshaler->InputNativeStack(pInStack);
        pMarshaler->ConvertSpaceNativeToCom();
        pMarshaler->OutputComStack(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalNativeToComByrefT(MARSHAL_CLASS *pMarshaler,
                                                     void *pInStack, void *pOutStack)
    {
		THROWSCOMPLUSEXCEPTION();
        pMarshaler->InputDest(pInStack);
        if (!*(void**)pInStack)
		{
			COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");
		}
		pMarshaler->InputNativeRef(pInStack);
        pMarshaler->ConvertSpaceNativeToCom();
        pMarshaler->ConvertContentsNativeToCom();
        pMarshaler->OutputComRef(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalNativeToComByrefOutT(MARSHAL_CLASS *pMarshaler,
                                                        void *pInStack, void *pOutStack)
    {
        pMarshaler->InputDest(pInStack);
        pMarshaler->OutputComRef(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalNativeToComInT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ClearCom();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalNativeToComOutT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ConvertContentsComToNative();
        pMarshaler->ClearCom();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalNativeToComInOutT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNativeContents();
        pMarshaler->ConvertContentsComToNative();
        pMarshaler->ClearCom();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalNativeToComByrefInT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ClearCom();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalNativeToComByrefInOutT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNative();
        pMarshaler->ReInitNative();

        pMarshaler->BackpropagateComRef();
        pMarshaler->ConvertSpaceComToNative();
        pMarshaler->ConvertContentsComToNative();
        pMarshaler->OutputNativeDest();

        pMarshaler->ClearCom();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalNativeToComByrefOutT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->BackpropagateComRef();
        pMarshaler->ConvertSpaceComToNative();
        pMarshaler->ConvertContentsComToNative();
        pMarshaler->OutputNativeDest();
        pMarshaler->ClearCom();
    }

    //
    // Com to Native marshaling
    //

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalComToNativeT(MARSHAL_CLASS *pMarshaler,
                                                void *pInStack, void *pOutStack)
    {
        pMarshaler->InputComStack(pInStack);
        pMarshaler->ConvertSpaceComToNative();
        pMarshaler->ConvertContentsComToNative();
        pMarshaler->OutputNativeStack(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalComToNativeOutT(MARSHAL_CLASS *pMarshaler,
                                                   void *pInStack, void *pOutStack)
    {
        pMarshaler->InputComStack(pInStack);
        pMarshaler->ConvertSpaceComToNative();
        pMarshaler->OutputNativeStack(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalComToNativeByrefT(MARSHAL_CLASS *pMarshaler,
                                                     void *pInStack, void *pOutStack)
    {
        pMarshaler->InputDest(pInStack);
        pMarshaler->InputComRef(pInStack);
        pMarshaler->ConvertSpaceComToNative();
        pMarshaler->ConvertContentsComToNative();
        pMarshaler->OutputNativeRef(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalComToNativeByrefOutT(MARSHAL_CLASS *pMarshaler,
                                                        void *pInStack, void *pOutStack)
    {
        pMarshaler->InputDest(pInStack);
        pMarshaler->ReInitNative();
        if (pMarshaler->m_pList)
        {
            pMarshaler->m_pMarshalerCleanupNode = pMarshaler->m_pList->ScheduleMarshalerCleanupOnException(pMarshaler);
        }
        pMarshaler->OutputNativeRef(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeInT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNative();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeOutT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ConvertContentsNativeToCom();
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNative();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeInOutT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ClearComContents();
        pMarshaler->ConvertContentsNativeToCom();
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNative();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeByrefInT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNative();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeByrefInOutT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ClearCom();

        pMarshaler->ConvertSpaceNativeToCom();
        pMarshaler->ConvertContentsNativeToCom();

        pMarshaler->CancelCleanup();
        pMarshaler->ClearNative();

        pMarshaler->OutputComDest();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeByrefOutT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ConvertSpaceNativeToCom();
        pMarshaler->ConvertContentsNativeToCom();

        pMarshaler->CancelCleanup();
        pMarshaler->ClearNative();

        pMarshaler->OutputComDest();
    }

    //
    // Return Native from Com
    //

    template < class MARSHAL_CLASS >
    FORCEINLINE static void PrereturnNativeFromComT(MARSHAL_CLASS *pMarshaler,
                                                    void *pInStack, void *pOutStack)
    {
        if (pMarshaler->c_fReturnsComByref)
            pMarshaler->OutputComRef(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void PrereturnNativeFromComRetvalT(MARSHAL_CLASS *pMarshaler,
                                                          void *pInStack, void *pOutStack)
    {
        pMarshaler->InputDest(pInStack);
        if (pMarshaler->c_fReturnsComByref)
            pMarshaler->OutputComRef(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void ReturnNativeFromComT(MARSHAL_CLASS *pMarshaler,
                                                 void *pInReturn, void *pOutReturn)
    {
        if (!pMarshaler->c_fReturnsComByref)
            pMarshaler->InputComStack(pOutReturn);
        pMarshaler->ConvertSpaceComToNative();
        pMarshaler->ConvertContentsComToNative();
        if (pMarshaler->c_fReturnsNativeByref)
            pMarshaler->OutputNativeRef(pInReturn);
        else
            pMarshaler->OutputNativeStack(pInReturn);
        pMarshaler->ClearCom();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void ReturnNativeFromComRetvalT(MARSHAL_CLASS *pMarshaler,
                                                       void *pInReturn, void *pOutReturn)
    {
        if (!pMarshaler->c_fReturnsComByref)
            pMarshaler->InputComStack(pOutReturn);
        pMarshaler->ConvertSpaceComToNative();
        pMarshaler->ConvertContentsComToNative();
        pMarshaler->OutputNativeDest();
        pMarshaler->ClearCom();
    }

    //
    // Return Com from Native
    //

    template < class MARSHAL_CLASS >
    FORCEINLINE static void PrereturnComFromNativeT(MARSHAL_CLASS *pMarshaler,
                                                    void *pInStack, void *pOutStack)
    {
        if (pMarshaler->c_fReturnsComByref)
            pMarshaler->InputDest(pInStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void PrereturnComFromNativeRetvalT(MARSHAL_CLASS *pMarshaler,
                                                          void *pInStack, void *pOutStack)
    {
        if (pMarshaler->c_fReturnsComByref)
            pMarshaler->InputDest(pInStack);

        pMarshaler->ReInitNative();
        if (pMarshaler->m_pList)
        {
            pMarshaler->m_pMarshalerCleanupNode = pMarshaler->m_pList->ScheduleMarshalerCleanupOnException(pMarshaler);
        }
        pMarshaler->OutputNativeRef(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void ReturnComFromNativeT(MARSHAL_CLASS *pMarshaler,
                                                 void *pInReturn, void *pOutReturn)
    {
		THROWSCOMPLUSEXCEPTION();

        if (pMarshaler->c_fReturnsNativeByref)
        {
			if (!*(void**)pOutReturn)
			{
				COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");
			}
			pMarshaler->InputNativeRef(pOutReturn);
		}
		else
            pMarshaler->InputNativeStack(pOutReturn);

        pMarshaler->ConvertSpaceNativeToCom();
        pMarshaler->ConvertContentsNativeToCom();

        pMarshaler->CancelCleanup();
        pMarshaler->ClearNative();
        
        if (pMarshaler->c_fReturnsComByref)
            pMarshaler->OutputComDest();
        else
            pMarshaler->OutputComStack(pInReturn);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void ReturnComFromNativeRetvalT(MARSHAL_CLASS *pMarshaler,
                                                       void *pInReturn, void *pOutReturn)
    {
        pMarshaler->ConvertSpaceNativeToCom();
        pMarshaler->ConvertContentsNativeToCom();

        // ClearNative can trigger GC
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNative();

        // No GC after this
        if (pMarshaler->c_fReturnsComByref)
            pMarshaler->OutputComDest();
        else
            pMarshaler->OutputComStack(pInReturn);

    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void SetComT(MARSHAL_CLASS *pMarshaler,
                                 void *pInStack, void *pField)
    {
        pMarshaler->InputNativeStack(pInStack);
        pMarshaler->ConvertSpaceNativeToCom();
        pMarshaler->ConvertContentsNativeToCom();

        pMarshaler->OutputComField(pField);

        //pMarshaler->ClearNative();
    }

    template < class MARSHAL_CLASS > 
    FORCEINLINE static void GetComT(MARSHAL_CLASS *pMarshaler,
                                 void *pInReturn, void *pField) 
    {
        pMarshaler->InputComField(pField);

        pMarshaler->ConvertSpaceComToNative();
        pMarshaler->ConvertContentsComToNative();
        if (pMarshaler->c_fReturnsNativeByref)
            pMarshaler->OutputNativeRef(pInReturn);
        else
            pMarshaler->OutputNativeStack(pInReturn);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void PregetComRetvalT(MARSHAL_CLASS *pMarshaler,
                                          void *pInStack, void *pField)
    {
        pMarshaler->InputDest(pInStack);

        pMarshaler->InputComField(pField);

        pMarshaler->ConvertSpaceComToNative();
        pMarshaler->ConvertContentsComToNative();
        pMarshaler->OutputNativeDest();
    }

    // Alternative templates used when marshaling/unmarshaling from com to
    // native and we wish to distinguish between native buffers allocated on a
    // temporary basis as opposed to those given out permanently to native code.
    // See the comments for FAST_ALLOC_MARSHAL_OVERRIDES for more information.

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalComToNativeT2(MARSHAL_CLASS *pMarshaler,
                                                 void *pInStack, void *pOutStack)
    {
        pMarshaler->InputComStack(pInStack);
        pMarshaler->ConvertSpaceComToNativeTemp();
        pMarshaler->ConvertContentsComToNative();
        pMarshaler->OutputNativeStack(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalComToNativeOutT2(MARSHAL_CLASS *pMarshaler,
                                                    void *pInStack, void *pOutStack)
    {
        pMarshaler->InputComStack(pInStack);
        pMarshaler->ConvertSpaceComToNativeTemp();
        pMarshaler->OutputNativeStack(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void MarshalComToNativeByrefT2(MARSHAL_CLASS *pMarshaler,
                                                      void *pInStack, void *pOutStack)
    {
        pMarshaler->InputDest(pInStack);
        pMarshaler->InputComRef(pInStack);
        pMarshaler->ConvertSpaceComToNativeTemp();
        pMarshaler->ConvertContentsComToNative();
        pMarshaler->OutputNativeRef(pOutStack);
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeInT2(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNativeTemp();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeOutT2(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ConvertContentsNativeToCom();
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNativeTemp();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeInOutT2(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ClearComContents();
        pMarshaler->ConvertContentsNativeToCom();
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNativeTemp();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeByrefInT2(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->CancelCleanup();
        pMarshaler->ClearNativeTemp();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void UnmarshalComToNativeByrefInOutT2(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ClearCom();

        pMarshaler->ConvertSpaceNativeToCom();
        pMarshaler->ConvertContentsNativeToCom();
        pMarshaler->OutputComDest();

        pMarshaler->CancelCleanup();
        pMarshaler->ClearNativeTemp();
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void DoExceptionCleanupT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ClearNative();
        pMarshaler->ReInitNative();  // this is necessary in case the parameter
                                     // was pass "[in,out] byref" - as the caller
                                     // may still legally attempt cleanup on m_native.
    }

    template < class MARSHAL_CLASS >
    FORCEINLINE static void DoExceptionReInitT(MARSHAL_CLASS *pMarshaler)
    {
        pMarshaler->ReInitNative();  // this is necessary in case the parameter
                                     // was pass "[in,out] byref" - as the caller
                                     // may still legally attempt cleanup on m_native.
    }


    //
    // Virtual functions, to be overridden in leaf classes
    // (usually by a simple instantiation of each of the above templates.
    //
    // !!! this may be too much code - perhaps we should parameterize some
    // of these with in/out flags rather than having 3 separate routines.
    //

    virtual void GcScanRoots(promote_func *fn, ScanContext* sc)
    {}


    virtual void MarshalNativeToCom(void *pInStack, void *pOutStack) = 0;
    virtual void MarshalNativeToComOut(void *pInStack, void *pOutStack) = 0;
    virtual void MarshalNativeToComByref(void *pInStack, void *pOutStack) = 0;
    virtual void MarshalNativeToComByrefOut(void *pInStack, void *pOutStack) = 0;
    virtual void UnmarshalNativeToComIn() = 0;
    virtual void UnmarshalNativeToComOut() = 0;
    virtual void UnmarshalNativeToComInOut() = 0;
    virtual void UnmarshalNativeToComByrefIn() = 0;
    virtual void UnmarshalNativeToComByrefOut() = 0;
    virtual void UnmarshalNativeToComByrefInOut() = 0;

    virtual void MarshalComToNative(void *pInStack, void *pOutStack) = 0;
    virtual void MarshalComToNativeOut(void *pInStack, void *pOutStack) = 0;
    virtual void MarshalComToNativeByref(void *pInStack, void *pOutStack) = 0;
    virtual void MarshalComToNativeByrefOut(void *pInStack, void *pOutStack) = 0;
    virtual void UnmarshalComToNativeIn() = 0;
    virtual void UnmarshalComToNativeOut() = 0;
    virtual void UnmarshalComToNativeInOut() = 0;
    virtual void UnmarshalComToNativeByrefIn() = 0;
    virtual void UnmarshalComToNativeByrefOut() = 0;
    virtual void UnmarshalComToNativeByrefInOut() = 0;

    virtual void PrereturnNativeFromCom(void *pInStack, void *pOutStack) = 0;
    virtual void PrereturnNativeFromComRetval(void *pInStack, void *pOutStack) = 0;
    virtual void ReturnNativeFromCom(void *pInReturn, void *pOutReturn) = 0;
    virtual void ReturnNativeFromComRetval(void *pInReturn, void *pOutReturn) = 0;

    virtual void PrereturnComFromNative(void *pInStack, void *pOutStack) = 0;
    virtual void PrereturnComFromNativeRetval(void *pInStack, void *pOutStack) = 0;
    virtual void ReturnComFromNative(void *pInReturn, void *pOutReturn) = 0;
    virtual void ReturnComFromNativeRetval(void *pInReturn, void *pOutReturn) = 0;

    virtual void SetCom(void *pInReturn, void *pField) = 0;

    virtual void GetCom(void *pInReturn, void *pField) = 0;
    virtual void PregetComRetval(void *pInStack, void *pField) = 0;

    virtual void DoExceptionCleanup() = 0;
    virtual void DoExceptionReInit() = 0;


#define DEFAULT_MARSHAL_OVERRIDES                                        \
     void MarshalNativeToCom(void *pInStack, void *pOutStack)            \
        { MarshalNativeToComT(this, pInStack, pOutStack); }              \
     void MarshalNativeToComOut(void *pInStack, void *pOutStack)         \
        { MarshalNativeToComOutT(this, pInStack, pOutStack); }           \
     void MarshalNativeToComByref(void *pInStack, void *pOutStack)       \
        { MarshalNativeToComByrefT(this, pInStack, pOutStack); }         \
     void MarshalNativeToComByrefOut(void *pInStack, void *pOutStack)    \
        { MarshalNativeToComByrefOutT(this, pInStack, pOutStack); }      \
     void UnmarshalNativeToComIn()                                       \
        { UnmarshalNativeToComInT(this); }                               \
     void UnmarshalNativeToComOut()                                      \
        { UnmarshalNativeToComOutT(this); }                              \
     void UnmarshalNativeToComInOut()                                    \
        { UnmarshalNativeToComInOutT(this); }                            \
     void UnmarshalNativeToComByrefIn()                                  \
        { UnmarshalNativeToComByrefInT(this); }                          \
     void UnmarshalNativeToComByrefOut()                                 \
        { UnmarshalNativeToComByrefOutT(this); }                         \
     void UnmarshalNativeToComByrefInOut()                               \
        { UnmarshalNativeToComByrefInOutT(this); }                       \
     void MarshalComToNative(void *pInStack, void *pOutStack)            \
        { MarshalComToNativeT(this, pInStack, pOutStack); }              \
     void MarshalComToNativeOut(void *pInStack, void *pOutStack)         \
        { MarshalComToNativeOutT(this, pInStack, pOutStack); }           \
     void MarshalComToNativeByref(void *pInStack, void *pOutStack)       \
        { MarshalComToNativeByrefT(this, pInStack, pOutStack); }         \
     void MarshalComToNativeByrefOut(void *pInStack, void *pOutStack)    \
        { MarshalComToNativeByrefOutT(this, pInStack, pOutStack); }      \
     void UnmarshalComToNativeIn()                                       \
        { UnmarshalComToNativeInT(this); }                               \
     void UnmarshalComToNativeOut()                                      \
        { UnmarshalComToNativeOutT(this); }                              \
     void UnmarshalComToNativeInOut()                                    \
        { UnmarshalComToNativeInOutT(this); }                            \
     void UnmarshalComToNativeByrefIn()                                  \
        { UnmarshalComToNativeByrefInT(this); }                          \
     void UnmarshalComToNativeByrefOut()                                 \
        { UnmarshalComToNativeByrefOutT(this); }                         \
     void UnmarshalComToNativeByrefInOut()                               \
        { UnmarshalComToNativeByrefInOutT(this); }                       \
     void PrereturnNativeFromCom(void *pInStack, void *pOutStack)        \
        { PrereturnNativeFromComT(this, pInStack, pOutStack); }          \
     void PrereturnNativeFromComRetval(void *pInStack, void *pOutStack)  \
        { PrereturnNativeFromComRetvalT(this, pInStack, pOutStack); }    \
     void ReturnNativeFromCom(void *pInStack, void *pOutStack)           \
        { ReturnNativeFromComT(this, pInStack, pOutStack); }             \
     void ReturnNativeFromComRetval(void *pInStack, void *pOutStack)     \
        { ReturnNativeFromComRetvalT(this, pInStack, pOutStack); }       \
     void PrereturnComFromNative(void *pInStack, void *pOutStack)        \
        { PrereturnComFromNativeT(this, pInStack, pOutStack); }          \
     void PrereturnComFromNativeRetval(void *pInStack, void *pOutStack)  \
        { PrereturnComFromNativeRetvalT(this, pInStack, pOutStack); }    \
     void ReturnComFromNative(void *pInStack, void *pOutStack)           \
        { ReturnComFromNativeT(this, pInStack, pOutStack); }             \
     void ReturnComFromNativeRetval(void *pInStack, void *pOutStack)     \
        { ReturnComFromNativeRetvalT(this, pInStack, pOutStack); }       \
     void SetCom(void *pInStack, void *pField)                           \
        { SetComT(this, pInStack, pField); }                             \
     void GetCom(void *pInReturn, void *pField)                          \
        { GetComT(this, pInReturn, pField); }                            \
     void PregetComRetval(void *pInStack, void *pField)                  \
        { PregetComRetvalT(this, pInStack, pField); }                    \
     void DoExceptionCleanup()                                           \
        { DoExceptionCleanupT(this); }                                   \
     void DoExceptionReInit()                                            \
        { DoExceptionReInitT(this); }                                    \

    // When marshaling/unmarshaling from com to native using a temporary native
    // buffer we wish to avoid using the default marshaling overriddes and
    // instead use some which distinguish between allocating native buffers
    // which have unbounded lifetimes versus those which will exist for just the
    // duration of the marshal/unmarshal (we can heavily optimize buffer
    // allocation in the latter case). To this end we create two new helper
    // functions, ConvertSpaceComToNativeTemp and ClearNativeTemp, which will
    // perform the lightweight allocation/deallocation.
#define FAST_ALLOC_MARSHAL_OVERRIDES \
     void MarshalNativeToCom(void *pInStack, void *pOutStack)            \
        { MarshalNativeToComT(this, pInStack, pOutStack); }              \
     void MarshalNativeToComOut(void *pInStack, void *pOutStack)         \
        { MarshalNativeToComOutT(this, pInStack, pOutStack); }           \
     void MarshalNativeToComByref(void *pInStack, void *pOutStack)       \
        { MarshalNativeToComByrefT(this, pInStack, pOutStack); }         \
     void MarshalNativeToComByrefOut(void *pInStack, void *pOutStack)    \
        { MarshalNativeToComByrefOutT(this, pInStack, pOutStack); }      \
     void UnmarshalNativeToComIn()                                       \
        { UnmarshalNativeToComInT(this); }                               \
     void UnmarshalNativeToComOut()                                      \
        { UnmarshalNativeToComOutT(this); }                              \
     void UnmarshalNativeToComInOut()                                    \
        { UnmarshalNativeToComInOutT(this); }                            \
     void UnmarshalNativeToComByrefIn()                                  \
        { UnmarshalNativeToComByrefInT(this); }                          \
     void UnmarshalNativeToComByrefOut()                                 \
        { UnmarshalNativeToComByrefOutT(this); }                         \
     void UnmarshalNativeToComByrefInOut()                               \
        { UnmarshalNativeToComByrefInOutT(this); }                       \
     void MarshalComToNativeByrefOut(void *pInStack, void *pOutStack)    \
        { MarshalComToNativeByrefOutT(this, pInStack, pOutStack); }      \
     void UnmarshalComToNativeByrefOut()                                 \
        { UnmarshalComToNativeByrefOutT(this); }                         \
     void PrereturnNativeFromCom(void *pInStack, void *pOutStack)        \
        { PrereturnNativeFromComT(this, pInStack, pOutStack); }          \
     void PrereturnNativeFromComRetval(void *pInStack, void *pOutStack)  \
        { PrereturnNativeFromComRetvalT(this, pInStack, pOutStack); }    \
     void ReturnNativeFromCom(void *pInStack, void *pOutStack)           \
        { ReturnNativeFromComT(this, pInStack, pOutStack); }             \
     void ReturnNativeFromComRetval(void *pInStack, void *pOutStack)     \
        { ReturnNativeFromComRetvalT(this, pInStack, pOutStack); }       \
     void PrereturnComFromNative(void *pInStack, void *pOutStack)        \
        { PrereturnComFromNativeT(this, pInStack, pOutStack); }          \
     void PrereturnComFromNativeRetval(void *pInStack, void *pOutStack)  \
        { PrereturnComFromNativeRetvalT(this, pInStack, pOutStack); }    \
     void ReturnComFromNative(void *pInStack, void *pOutStack)           \
        { ReturnComFromNativeT(this, pInStack, pOutStack); }             \
     void ReturnComFromNativeRetval(void *pInStack, void *pOutStack)     \
        { ReturnComFromNativeRetvalT(this, pInStack, pOutStack); }       \
     void SetCom(void *pInStack, void *pField)                           \
        { SetComT(this, pInStack, pField); }                             \
     void GetCom(void *pInReturn, void *pField)                          \
        { GetComT(this, pInReturn, pField); }                            \
     void PregetComRetval(void *pInStack, void *pField)                  \
        { PregetComRetvalT(this, pInStack, pField); }                    \
     void MarshalComToNative(void *pInStack, void *pOutStack)            \
        { MarshalComToNativeT2(this, pInStack, pOutStack); }             \
     void MarshalComToNativeOut(void *pInStack, void *pOutStack)         \
        { MarshalComToNativeOutT2(this, pInStack, pOutStack); }          \
     void MarshalComToNativeByref(void *pInStack, void *pOutStack)       \
        { MarshalComToNativeByrefT2(this, pInStack, pOutStack); }        \
     void UnmarshalComToNativeIn()                                       \
        { UnmarshalComToNativeInT2(this); }                              \
     void UnmarshalComToNativeOut()                                      \
        { UnmarshalComToNativeOutT2(this); }                             \
     void UnmarshalComToNativeInOut()                                    \
        { UnmarshalComToNativeInOutT2(this); }                           \
     void UnmarshalComToNativeByrefIn()                                  \
        { UnmarshalComToNativeByrefInT2(this); }                         \
     void UnmarshalComToNativeByrefInOut()                               \
        { UnmarshalComToNativeByrefInOutT2(this); }                      \
    void DoExceptionCleanup()                                            \
       { DoExceptionCleanupT(this); }                                    \
       void DoExceptionReInit()                                            \
          { DoExceptionReInitT(this); }                                    \





    void CancelCleanup()
    {
        if (m_pMarshalerCleanupNode)
        {
            m_pMarshalerCleanupNode->CancelCleanup();
        }
    }

    BYTE                m_cbCom;
    BYTE                m_cbNative;
    BYTE                m_fReturnsComByref;
    BYTE                m_fReturnsNativeByref;
    CleanupWorkList     *m_pList;
    void                *m_pDest;
    CleanupWorkList::MarshalerCleanupNode *m_pMarshalerCleanupNode;

    typedef enum
    {
        HANDLEASNORMAL = 0,
        OVERRIDDEN = 1,
        DISALLOWED = 2,
    } ArgumentMLOverrideStatus;

    // A marshaler can override this to override the normal ML code generation.
    // We use this mechanism for two purposes:
    //
    //  - To implement types such as PIS's "asany", which work in only one
    //    direction and doesn't fit into the normal marshaler scheme.
    //
    //  - To implement stack allocation & pinning optimizations for
    //    the COM->Native calling case.
    //
    //
    // Returns:
    //   HANDLEASNORMAL, OVERRIDDEN or DISALLOWED
    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        return HANDLEASNORMAL;
    }


    // Similar to ArgumentMLOverride but for return values.
    static ArgumentMLOverrideStatus ReturnMLOverride(MLStubLinker *psl,
                                                     MLStubLinker *pslPost,
                                                     BOOL        comToNative,
                                                     BOOL        fThruBuffer,
                                                     MLOverrideArgs *pargs,
                                                     UINT       *pResID)
    {
        return HANDLEASNORMAL;
    }


};

//
// Macros to determine unnecessary unmarshaling
// conditions
//

#define NEEDS_UNMARSHAL_NATIVE_TO_COM_IN(c) \
    c::c_fNeedsClearCom

#define NEEDS_UNMARSHAL_NATIVE_TO_COM_OUT(c) \
    (c::c_fNeedsConvertContents \
     || c::c_fNeedsClearCom)

#define NEEDS_UNMARSHAL_NATIVE_TO_COM_IN_OUT(c) \
    (c::c_fNeedsClearNativeContents \
     || c::c_fNeedsConvertContents \
     || c::c_fNeedsClearCom)

#define NEEDS_UNMARSHAL_NATIVE_TO_COM_BYREF_IN(c) \
    c::c_fNeedsClearCom

#define NEEDS_UNMARSHAL_COM_TO_NATIVE_IN(c) \
    c::c_fNeedsClearNative

#define NEEDS_UNMARSHAL_COM_TO_NATIVE_OUT(c) \
    (c::c_fNeedsConvertContents \
     || c::c_fNeedsClearNative)

#define NEEDS_UNMARSHAL_COM_TO_NATIVE_IN_OUT(c) \
    (c::c_fNeedsClearComContents \
     || c::c_fNeedsConvertContents \
     || c::c_fNeedsClearNative)

#define NEEDS_UNMARSHAL_COM_TO_NATIVE_BYREF_IN(c) \
    c::c_fNeedsClearNative

#define NEEDS_UNMARSHAL_COM_TO_NATIVE_BYREF_IN(c) \
    c::c_fNeedsClearNative








/* ------------------------------------------------------------------------- *
 * Primitive type marshallers
 * ------------------------------------------------------------------------- */

//
// CopyMarshal handles marshaling of primitive types (with
// compatible layouts.)
//

template < class ELEMENT, class PROMOTED_ELEMENT, BOOL RETURNS_COM_BYREF > 
class CopyMarshaler : public Marshaler
{
  public:

    enum
    {
        c_nativeSize = sizeof(PROMOTED_ELEMENT),
        c_comSize = sizeof(PROMOTED_ELEMENT),

        c_fReturnsNativeByref = sizeof(ELEMENT)>8,
        c_fReturnsComByref = RETURNS_COM_BYREF,

        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = FALSE,

        c_fInOnly = TRUE,
    };
        
    CopyMarshaler(CleanupWorkList *pList)
      : Marshaler(pList, c_nativeSize, c_comSize, c_fReturnsNativeByref, c_fReturnsComByref) {}

    DEFAULT_MARSHAL_OVERRIDES;

    void InputNativeStack(void *pStack) { m_home = *(PROMOTED_ELEMENT*)pStack; }
    void InputComStack(void *pStack) { m_home = *(PROMOTED_ELEMENT*)pStack; }

    void InputNativeRef(void *pStack) { m_home = **(ELEMENT**)pStack; }
    void InputComRef(void *pStack) { m_home = **(ELEMENT**)pStack; }

    void OutputNativeStack(void *pStack) { *(PROMOTED_ELEMENT*)pStack = m_home; }
    void OutputComStack(void *pStack) { *(PROMOTED_ELEMENT*)pStack = m_home; }

    void OutputNativeRef(void *pStack) { *(ELEMENT **)pStack = &m_home; }
    void OutputComRef(void *pStack) { *(ELEMENT **)pStack = &m_home; }

    void OutputNativeDest() { *(ELEMENT *)m_pDest = m_home; }
    void OutputComDest() { *(ELEMENT *)m_pDest = m_home; }

    void InputComField(void *pField) { m_home = *(ELEMENT*)pField; }
    void OutputComField(void *pField) { *(ELEMENT*)pField = m_home; }

    // We only need one home, since the types are identical.  This makes
    // conversion a noop

    ELEMENT m_home;

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {

        if (byref)
        {
#ifdef TOUCH_ALL_PINNED_OBJECTS
            return HANDLEASNORMAL;
#else
            psl->MLEmit(ML_COPYPINNEDGCREF);
            return OVERRIDDEN;
#endif

        }
        else
        {
            return HANDLEASNORMAL;
        }

    }


};

typedef CopyMarshaler<INT8,INT32,FALSE> CopyMarshaler1;
typedef CopyMarshaler<UINT8,UINT32,FALSE> CopyMarshalerU1;
typedef CopyMarshaler<INT16,INT32,FALSE> CopyMarshaler2;
typedef CopyMarshaler<UINT16,UINT32,FALSE> CopyMarshalerU2;
typedef CopyMarshaler<INT32,INT32,FALSE> CopyMarshaler4;
typedef CopyMarshaler<INT64,INT64,FALSE> CopyMarshaler8;
typedef CopyMarshaler<DECIMAL,DECIMAL,TRUE> DecimalMarshaler;
typedef CopyMarshaler<GUID,GUID,TRUE> GuidMarshaler;
typedef CopyMarshaler<float, float, FALSE> FloatMarshaler;
typedef CopyMarshaler<double, double, FALSE> DoubleMarshaler;





#if 0

/* ------------------------------------------------------------------------- *
 * Floating point marshallers
 * ------------------------------------------------------------------------- */

//
// Same as copy marshalers, but handle FP register return conventions
//

class FloatMarshaler : public CopyMarshaler4
{
  public:
        
    FloatMarshaler(CleanupWorkList *pList)
      : CopyMarshaler4(pList) {}

    void ReturnComFromNative(void *pInReturn, void *pOutReturn)
    {
        getFPReturn(4,*(INT64*)pOutReturn);
        CopyMarshaler4::ReturnComFromNative(pInReturn, pOutReturn);
        setFPReturn(4, *(INT64*)pInReturn);
    }

    void ReturnNativeFromCom(void *pInReturn, void *pOutReturn)
    {
        getFPReturn(4,*(INT64*)pOutReturn);
        CopyMarshaler4::ReturnNativeFromCom(pInReturn, pOutReturn);
        setFPReturn(4, *(INT64*)pInReturn);
    }

    void ReturnComFromNativeRetval(void *pInReturn, void *pOutReturn)
    {
        CopyMarshaler4::ReturnComFromNativeRetval(pInReturn, pOutReturn);
        setFPReturn(4, *(INT64*)pInReturn);
    }

    void ReturnNativeFromComRetval(void *pInReturn, void *pOutReturn)
    {
        getFPReturn(4,*(INT64*)pOutReturn);
        CopyMarshaler4::ReturnNativeFromComRetval(pInReturn, pOutReturn);
    }

    void GetCom(void *pInReturn, void *pField)
    {
        CopyMarshaler4::GetCom(pInReturn, pField);
        setFPReturn(4, *(INT64*)pInReturn);
    }
};

class DoubleMarshaler : public CopyMarshaler8
{
  public:
        
    DoubleMarshaler(CleanupWorkList *pList)
      : CopyMarshaler8(pList) {}

    void ReturnComFromNative(void *pInReturn, void *pOutReturn)
    {
        getFPReturn(8,*(INT64*)pOutReturn);
        CopyMarshaler8::ReturnComFromNative(pInReturn, pOutReturn);
        setFPReturn(8, *(INT64*)pInReturn);
    }

    void ReturnNativeFromCom(void *pInReturn, void *pOutReturn)
    {
        getFPReturn(8,*(INT64*)pOutReturn);
        CopyMarshaler8::ReturnNativeFromCom(pInReturn, pOutReturn);
        setFPReturn(8, *(INT64*)pInReturn);
    }

    void ReturnComFromNativeRetval(void *pInReturn, void *pOutReturn)
    {
        CopyMarshaler8::ReturnComFromNativeRetval(pInReturn, pOutReturn);
        setFPReturn(8, *(INT64*)pInReturn);
    }

    void ReturnNativeFromComRetval(void *pInReturn, void *pOutReturn)
    {
        getFPReturn(8,*(INT64*)pOutReturn);
        CopyMarshaler8::ReturnNativeFromComRetval(pInReturn, pOutReturn);
    }

    void GetCom(void *pInReturn, void *pField)
    {
        CopyMarshaler8::GetCom(pInReturn, pField);
        setFPReturn(8, *(INT64*)pInReturn);
    }
};
#endif

/* ------------------------------------------------------------------------- *
 * Standard Marshaler template (for when there is no stack promotion.)
 * ------------------------------------------------------------------------- */

template < class NATIVE_TYPE, class COM_TYPE, 
           BOOL RETURNS_NATIVE_BYREF, BOOL RETURNS_COM_BYREF > 
class StandardMarshaler : public Marshaler
{
  public:

    enum
    {
        c_nativeSize = sizeof(NATIVE_TYPE),
        c_comSize = sizeof(COM_TYPE),
        c_fReturnsNativeByref = RETURNS_NATIVE_BYREF,
        c_fReturnsComByref = RETURNS_COM_BYREF
    };
        
    StandardMarshaler(CleanupWorkList *pList) 
      : Marshaler(pList, c_nativeSize, c_comSize, c_fReturnsNativeByref, c_fReturnsComByref) {}
    
    void InputNativeStack(void *pStack) { m_native = *(NATIVE_TYPE*)pStack; }
    void InputComStack(void *pStack) { m_com = *(COM_TYPE*)pStack; }

    void InputNativeRef(void *pStack) { m_native = **(NATIVE_TYPE**)pStack; }
    void InputComRef(void *pStack) { m_com = **(COM_TYPE**)pStack; }

    void OutputNativeStack(void *pStack) { *(NATIVE_TYPE*)pStack = m_native; }
    void OutputComStack(void *pStack) { *(COM_TYPE*)pStack = m_com; }

    void OutputNativeRef(void *pStack) { *(NATIVE_TYPE**)pStack = &m_native; }
    void OutputComRef(void *pStack) { *(COM_TYPE**)pStack = &m_com; }

    void OutputNativeDest() { *(NATIVE_TYPE*) m_pDest = m_native; }
    void OutputComDest() { *(COM_TYPE*) m_pDest = m_com; }

    void InputComField(void *pField) { m_com = *(COM_TYPE*)pField; }
    void OutputComField(void *pField) { *(COM_TYPE*)pField = m_com; }


    NATIVE_TYPE     m_native;
    COM_TYPE        m_com;
};




/* ------------------------------------------------------------------------- *
 * WinBool marshaller (32-bit Win32 BOOL)
 * ------------------------------------------------------------------------- */

class WinBoolMarshaler : public StandardMarshaler<BOOL, INT8, FALSE, FALSE>
{
  public:

    enum
    {
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,
        c_fInOnly = TRUE,
    };

    WinBoolMarshaler(CleanupWorkList *pList) 
      : StandardMarshaler<BOOL, INT8, FALSE, FALSE>(pList) {}
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ConvertContentsNativeToCom() { m_com = m_native ? 1 : 0; }
    void ConvertContentsComToNative() { m_native = (BOOL)m_com; }


    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref)
        {
#ifdef WRONGCALLINGCONVENTIONHACK
            psl->MLEmit(ML_COPY4);
#else
            psl->MLEmit(ML_COPYU1);
#endif
            return OVERRIDDEN;
        }
        else
        {
            return HANDLEASNORMAL;
        }

    }

};


/* ------------------------------------------------------------------------- *
 * VtBoolMarshaler marshaller (VARIANT_BOOL)
 * ------------------------------------------------------------------------- */

class VtBoolMarshaler : public StandardMarshaler<VARIANT_BOOL, INT8, FALSE, FALSE>
{
  public:

    enum
    {
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    VtBoolMarshaler(CleanupWorkList *pList) 
      : StandardMarshaler<VARIANT_BOOL, INT8, FALSE, FALSE>(pList) {}
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ConvertContentsNativeToCom() { m_com = (m_native == VARIANT_FALSE) ? 0 : 1; }
    void ConvertContentsComToNative() { m_native = (m_com) ? VARIANT_TRUE : VARIANT_FALSE; }

    void OutputComStack(void *pStack) { *(StackElemType*)pStack = (StackElemType)m_com; }

};



/* ------------------------------------------------------------------------- *
 * CBoolMarshaler marshaller (BYTE)
 * ------------------------------------------------------------------------- */

class CBoolMarshaler : public StandardMarshaler<BYTE, INT8, FALSE, FALSE>
{
  public:

    enum
    {
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    CBoolMarshaler(CleanupWorkList *pList) 
      : StandardMarshaler<BYTE, INT8, FALSE, FALSE>(pList) {}
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ConvertContentsNativeToCom() { m_com = m_native ? 1 : 0; }
    void ConvertContentsComToNative() { m_native = m_com ? 1 : 0; }

    void OutputComStack(void *pStack) { *(StackElemType*)pStack = (StackElemType)m_com; }

};



/* ------------------------------------------------------------------------- *
 * AnsiChar marshaller 
 * ------------------------------------------------------------------------- */

class AnsiCharMarshaler : public StandardMarshaler<UINT8, UINT16, FALSE, FALSE>
{
  public:

    enum
    {
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    AnsiCharMarshaler(CleanupWorkList *pList)
      : StandardMarshaler<UINT8, UINT16, FALSE, FALSE>(pList)
    {
        m_BestFitMap = TRUE;
        m_ThrowOnUnmappableChar = FALSE;
    }
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ConvertContentsNativeToCom()
    {
        MultiByteToWideChar(CP_ACP, 0, (LPSTR)&m_native, 1, (LPWSTR)&m_com, 1);
    }
    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();
        
        DWORD flags = 0;
        BOOL DefaultCharUsed = FALSE;
        
        if (m_BestFitMap == FALSE)
            flags = WC_NO_BEST_FIT_CHARS;

        if (!(WszWideCharToMultiByte(CP_ACP,
                            flags,
                            (LPWSTR)&m_com,
                            1,
                            (LPSTR)&m_native,
                            1,
                            NULL,
                            &DefaultCharUsed)))
        {
            COMPlusThrowWin32();
        }

        if (m_ThrowOnUnmappableChar && DefaultCharUsed)
                COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
    }

    void OutputComStack(void *pStack) { *(StackElemType*)pStack = (StackElemType)m_com; }

    void SetBestFitMap(BOOL BestFit) { m_BestFitMap = BestFit; }
    void SetThrowOnUnmappableChar(BOOL ThrowOnUnmapChar) { m_ThrowOnUnmappableChar = ThrowOnUnmapChar; }
    
    BOOL  m_BestFitMap;
    BOOL  m_ThrowOnUnmappableChar;
};


/* ------------------------------------------------------------------------- *
 * Currency marshaler.
 * ------------------------------------------------------------------------- */

class CurrencyMarshaler : public StandardMarshaler<CURRENCY, DECIMAL, TRUE, TRUE>
{
  public:

    enum
    {
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    CurrencyMarshaler(CleanupWorkList *pList) 
      : StandardMarshaler<CURRENCY, DECIMAL, TRUE, TRUE>(pList) {}
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ConvertContentsNativeToCom() 
    { 
        THROWSCOMPLUSEXCEPTION();

        HRESULT hr = VarDecFromCy(m_native, &m_com);
        IfFailThrow(hr);
        DecimalCanonicalize(&m_com);
    }
    
    void ConvertContentsComToNative() 
    { 
        THROWSCOMPLUSEXCEPTION();

        HRESULT hr = VarCyFromDec(&m_com, &m_native);
        IfFailThrow(hr);
    }
};


/* ------------------------------------------------------------------------- *
 * OLE_COLOR marshaler.
 * ------------------------------------------------------------------------- */

class OleColorMarshaler : public StandardMarshaler<OLE_COLOR, SYSTEMCOLOR, TRUE, TRUE>
{
  public:

    enum
    {
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    OleColorMarshaler(CleanupWorkList *pList) 
      : StandardMarshaler<OLE_COLOR, SYSTEMCOLOR, TRUE, TRUE>(pList) 
    {
        m_com.name = NULL;
        pList->NewProtectedMarshaler(this);
    }
    
    DEFAULT_MARSHAL_OVERRIDES;

    virtual void GcScanRoots(promote_func *fn, ScanContext* sc)
    {
        if (m_com.name != NULL)
        {
            LOG((LF_GC, INFO3, "Marshaler Promoting %x to ", m_com.name));
            (*fn)( *(Object**)&m_com.name, sc);
            LOG((LF_GC, INFO3, "%x\n", m_com.name ));
        }

    }

    void ConvertContentsNativeToCom() 
    { 
        ConvertOleColorToSystemColor(m_native, &m_com);
    }
    
    void ConvertContentsComToNative() 
    { 
        m_native = ConvertSystemColorToOleColor(&m_com);
    }

};


/* ------------------------------------------------------------------------- *
 * Value class marshallers
 * ------------------------------------------------------------------------- */

//
// ValueClassPtrMarshal handles marshaling of value class types (with
// compatible layouts), which are represented on the native side by ptrs 
// and in COM+ by value.
//

template < class ELEMENT > 
class ValueClassPtrMarshaler : public StandardMarshaler<ELEMENT *, ELEMENT, FALSE, TRUE>
{
  public:

    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    ValueClassPtrMarshaler(CleanupWorkList *pList)
      : StandardMarshaler<ELEMENT *, ELEMENT, FALSE, TRUE>(pList)
      {}

    FAST_ALLOC_MARSHAL_OVERRIDES;

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        m_native = (ELEMENT *) CoTaskMemAlloc(sizeof(ELEMENT));
        if (m_native == NULL)
            COMPlusThrowOM();

        m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
    }

    void ConvertSpaceComToNativeTemp()
    {
        m_native = (ELEMENT *) GetThread()->m_MarshalAlloc.Alloc(sizeof(ELEMENT));
    }

    void ConvertContentsNativeToCom() 
    { 
        if (m_native != NULL)
            m_com = *m_native;
    }

    void ConvertContentsComToNative() 
    { 
        if (m_native != NULL)
            *m_native = m_com;
    }

    void ClearNative()
    {
        if (m_native != NULL)
            CoTaskMemFree(m_native);
    }

    void ClearNativeTemp()
    {
    }

    void ReInitNative()
    {
        m_native = NULL;
    }
};

typedef ValueClassPtrMarshaler<DECIMAL> DecimalPtrMarshaler;
typedef ValueClassPtrMarshaler<GUID> GuidPtrMarshaler;

/* ------------------------------------------------------------------------- *
 * Date marshallers
 * ------------------------------------------------------------------------- */

class DateMarshaler : public StandardMarshaler<DATE, INT64, FALSE, TRUE>
{
  public:

    enum
    {
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    DateMarshaler(CleanupWorkList *pList) 
      : StandardMarshaler<DATE, INT64, FALSE, TRUE>(pList) {}
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ConvertContentsNativeToCom() { m_com = COMDateTime::DoubleDateToTicks(m_native); }
    void ConvertContentsComToNative() { m_native = COMDateTime::TicksToDoubleDate(m_com); }
};



/* ------------------------------------------------------------------------- *
 * Object marshallers
 * ------------------------------------------------------------------------- */


class ObjectMarshaler : public Marshaler
{
  public:
    enum
    {
        c_comSize = sizeof(OBJECTREF),
        c_nativeSize = sizeof(VARIANT),
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = TRUE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,
        c_fReturnsNativeByref = FALSE,
        c_fReturnsComByref = FALSE,


        c_fInOnly = TRUE,
    };


    ObjectMarshaler(CleanupWorkList *pList) 
      : Marshaler(pList, c_nativeSize, c_comSize, c_fReturnsNativeByref, c_fReturnsComByref)
      {
          m_com = pList->NewScheduledProtectedHandle(NULL);
          VariantInit(&m_native);

          m_secondHomeForC2NByRef = NULL;
          pList->NewProtectedMarshaler(this);

      }
    
    DEFAULT_MARSHAL_OVERRIDES;


    void InputDest(void *pStack) { m_pDest = pStack; }

    void InputNativeStack(void *pStack) { m_native = *(VARIANT*)pStack; }
    void InputComStack(void *pStack) { StoreObjectInHandle(m_com, ObjectToOBJECTREF(*(Object**)pStack)); }

    void InputNativeRef(void *pStack) { m_native = **(VARIANT**)pStack; }
    void InputComRef(void *pStack) { StoreObjectInHandle(m_com, ObjectToOBJECTREF(**(Object ***)pStack)); }

    void OutputNativeStack(void *pStack) { *(VARIANT*)pStack = m_native; }
    void OutputComStack(void *pStack) { *(OBJECTREF*)pStack = ObjectFromHandle(m_com); }

    void OutputNativeRef(void *pStack) { *(VARIANT**)pStack = &m_native; }
    void OutputComRef(void *pStack)
    {
        m_secondHomeForC2NByRef = ObjectFromHandle(m_com);

#ifdef _DEBUG
        // Since we are not using the GC frame to protect m_secondHomeForC2NByRef
        // but rather explicitly calling GCHeap::Promote() on it from
        // ObjectMarshaler::GcScanRoots(), we must cheat the dangerousObjRefs, so
        // it wouldn't complain on potential, but not happened GCs
        Thread::ObjectRefProtected(&m_secondHomeForC2NByRef);
#endif
        
        *(OBJECTREF**)pStack = &m_secondHomeForC2NByRef;
    }

    void BackpropagateComRef() 
	{ 
		StoreObjectInHandle(m_com, ObjectToOBJECTREF( *(Object**)&m_secondHomeForC2NByRef )); 
	}


    void OutputNativeDest() { **(VARIANT**)m_pDest = m_native; }
    void OutputComDest() { SetObjectReferenceUnchecked(*(OBJECTREF**)m_pDest,
                                                       ObjectFromHandle(m_com)); }

    void InputComField(void *pField) { StoreObjectInHandle(m_com, ObjectToOBJECTREF(*(Object**)pField)); }
    void OutputComField(void *pField) { SetObjectReferenceUnchecked((OBJECTREF*)pField,
                                                                    ObjectFromHandle(m_com)); }


    virtual void GcScanRoots(promote_func *fn, ScanContext* sc)
    {
        if (m_secondHomeForC2NByRef != NULL)
        {
            LOG((LF_GC, INFO3, "Marshaler Promoting %x to ", m_secondHomeForC2NByRef));
            (*fn)( *(Object**)&m_secondHomeForC2NByRef, sc);
            LOG((LF_GC, INFO3, "%x\n", m_secondHomeForC2NByRef ));
        }

    }

    OBJECTHANDLE        m_com;
    VARIANT             m_native;


    // A second OBJECTREF store for ReferenceMarshaler byref marshaling
    // from unmanaged to managed. This store is gc-promoted by
    // the UnmanagedToManagedCallFrame.
    //
    // Why is this needed? The real home is an objecthandle which we
    // can't legally pass as a byref argument to a managed method (we
    // have to use StoreObjectInHandle() to write to it or we mess
    // up the write barrier.)
    //
    OBJECTREF           m_secondHomeForC2NByRef;


#if defined(CHECK_FOR_VALID_VARIANTS)
    LPUTF8              m_strTypeName;
    LPUTF8              m_strMethodName;
    int                 m_iArg;
#endif

    void ConvertContentsNativeToCom() 
    { 
#if defined(CHECK_FOR_VALID_VARIANTS)
        BOOL bValidVariant = TRUE;

        try
        {
            VARIANT vTmp;
            VariantInit(&vTmp);

            Thread *pThread = GetThread();
            pThread->EnablePreemptiveGC();
            if (FAILED(VariantCopyInd(&vTmp, &m_native)))
                bValidVariant = FALSE;
            else
                SafeVariantClear(&vTmp);
            pThread->DisablePreemptiveGC();
        }
        catch (...)
        {
            bValidVariant = FALSE;
        }

        if (!bValidVariant)
        {
            SIZE_T cchType = strlen(m_strTypeName)+1;
            SIZE_T cchMeth = strlen(m_strMethodName)+1;

            CQuickBytes qb;
            LPWSTR wszTypeName = (LPWSTR) qb.Alloc(cchType * sizeof(WCHAR));
            CQuickBytes qb2;
            LPWSTR wszMethName = (LPWSTR) qb2.Alloc(cchMeth * sizeof(WCHAR));

            WszMultiByteToWideChar(CP_UTF8, 0, m_strTypeName, -1 , wszTypeName, (int)cchType);
            WszMultiByteToWideChar(CP_UTF8, 0, m_strMethodName, -1 , wszMethName, (int)cchMeth);

            if (CorMessageBox(NULL, IDS_INVALID_VARIANT_MSG, IDS_INVALID_VARIANT_CAPTION, MB_ICONSTOP | MB_OKCANCEL, m_iArg, wszMethName, wszTypeName) == IDCANCEL)
                _DbgBreak();
        }
#endif

        OBJECTREF Obj = NULL;
        GCPROTECT_BEGIN(Obj)
        {
            OleVariant::MarshalObjectForOleVariant(&m_native, &Obj);
            StoreObjectInHandle(m_com, Obj);
        }
        GCPROTECT_END();
    }

    void ConvertContentsComToNative() 
    { 
        OBJECTREF Obj = ObjectFromHandle(m_com);
        GCPROTECT_BEGIN(Obj)
        {
            OleVariant::MarshalOleVariantForObject(&Obj, &m_native);
        }
        GCPROTECT_END();
    }

    void ClearNative()
    {
        SafeVariantClear(&m_native);
    }


    void ReInitNative()
    {
        m_native.vt = VT_EMPTY;
    }

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (!comToNative && byref)
        {
            psl->MLEmit(ML_REFOBJECT_N2C);
            psl->Emit8( (fin ? ML_IN : 0) | (fout ? ML_OUT : 0) );
            pslPost->MLEmit(ML_REFOBJECT_N2C_POST);
            pslPost->Emit16(psl->MLNewLocal(sizeof(ML_REFOBJECT_N2C_SR)));
            return OVERRIDDEN;
        }
        else
        {
            return HANDLEASNORMAL;
        }

    }

    static ArgumentMLOverrideStatus ReturnMLOverride(MLStubLinker *psl,
                                                     MLStubLinker *pslPost,
                                                     BOOL        comToNative,
                                                     BOOL        fThruBuffer,
                                                     MLOverrideArgs *pargs,
                                                     UINT       *pResID)
    {
        if (comToNative && fThruBuffer)
        {
            psl->MLEmit(ML_PUSHVARIANTRETVAL);
            pslPost->MLEmit(ML_OBJECTRETC2N_POST);
            pslPost->Emit16(psl->MLNewLocal(sizeof(VARIANT)));
            return OVERRIDDEN;
        }
        else
        {
            return HANDLEASNORMAL;
        }
    }



};


/* ------------------------------------------------------------------------- *
 * Variant marshallers
 * ------------------------------------------------------------------------- */

class VariantMarshaler : public StandardMarshaler<VARIANT, VariantData*, TRUE, TRUE>
{
  public:
        
    enum
    {
        c_comSize = sizeof(VariantData),
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = TRUE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,


        c_fInOnly = TRUE,
    };

    VariantMarshaler(CleanupWorkList *pList) 
      : StandardMarshaler<VARIANT, VariantData*, TRUE, TRUE>(pList)
      {
          VariantInit(&m_native);
          m_cbCom = StackElemSize(sizeof(VariantData));
          m_com = &m_comdata;
          m_com->SetType(CV_NULL);
          m_com->SetObjRef(NULL);
      }
    
    DEFAULT_MARSHAL_OVERRIDES;


    void OutputComStack(void *pStack) { *(VariantData*)pStack = *m_com; }

    void InputComRef(void *pStack) { m_com = *(VariantData**)pStack; }
    void OutputComRef(void *pStack) { *(VariantData**)pStack = m_com; }

    void OutputComDest() { OutputComField(m_pDest); }

    void OutputComField(void *pField)
    {
        // Need to hit the write barrier here.
        VariantData *dest = (VariantData*) pField;

        dest->SetFullTypeInfo(m_com->GetFullTypeInfo());
        dest->SetObjRef(m_com->GetObjRef());
        dest->SetData(m_com->GetData());
    }

    void ConvertContentsNativeToCom() 
    { 
        OleVariant::MarshalComVariantForOleVariant(&m_native, m_com);
    }

    void ConvertContentsComToNative() 
    { 
        OleVariant::MarshalOleVariantForComVariant(m_com, &m_native);
    }

    void ClearNative()
    {
        SafeVariantClear(&m_native);
    }

    void ReInitNative()
    {
        m_native.vt = VT_EMPTY;
    }

    VariantData m_comdata;



    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (!comToNative && byref)
        {
            psl->MLEmit(ML_REFVARIANT_N2C);
            psl->Emit8( (fin ? ML_IN : 0) | (fout ? ML_OUT : 0) );
            pslPost->MLEmit(ML_REFVARIANT_N2C_POST);
            pslPost->Emit16(psl->MLNewLocal(sizeof(ML_REFVARIANT_N2C_SR)));
            return OVERRIDDEN;
        }
        else
        {
            return HANDLEASNORMAL;
        }

    }

};



/* ------------------------------------------------------------------------- *
 * Reference type abstract marshaler
 * ------------------------------------------------------------------------- */

//
// ReferenceMarshal 
//

class ReferenceMarshaler : public Marshaler
{
  public:
    enum
    {
        c_nativeSize = sizeof(void *),
        c_comSize = sizeof(OBJECTREF),
        c_fReturnsNativeByref = FALSE,
        c_fReturnsComByref = FALSE
    };
        
    ReferenceMarshaler(CleanupWorkList *pList) 
      : Marshaler(pList, c_nativeSize, c_comSize, c_fReturnsNativeByref, c_fReturnsComByref)
    {
        m_com = pList->NewScheduledProtectedHandle(NULL);
        m_native = NULL;
        m_secondHomeForC2NByRef = NULL;
        pList->NewProtectedMarshaler(this);
	}

    void InputDest(void *pStack) { m_pDest = pStack; }

    void InputNativeStack(void *pStack) { m_native = *(void **)pStack; }
    void InputComStack(void *pStack) { StoreObjectInHandle(m_com, ObjectToOBJECTREF(*(Object **)pStack)); }

    void InputNativeRef(void *pStack) { m_native = **(void ***)pStack; }
    void InputComRef(void *pStack) { StoreObjectInHandle(m_com, ObjectToOBJECTREF(**(Object ***)pStack)); }

    void OutputNativeStack(void *pStack) { *(void **)pStack = m_native; }
    void OutputComStack(void *pStack) { *(OBJECTREF*)pStack = ObjectFromHandle(m_com); }

    void OutputNativeRef(void *pStack) { *(void ***)pStack = &m_native; }

    void OutputComRef(void *pStack)
    {
        m_secondHomeForC2NByRef = ObjectFromHandle(m_com);

#ifdef _DEBUG
        // Since we are not using the GC frame to protect m_secondHomeForC2NByRef
        // but rather explicitly calling GCHeap::Promote() on it from
        // ObjectMarshaler::GcScanRoots(), we must cheat the dangerousObjRefs, so
        // it wouldn't complain on potential, but not happened GCs
        Thread::ObjectRefProtected(&m_secondHomeForC2NByRef);
#endif
        
        *(OBJECTREF**)pStack = &m_secondHomeForC2NByRef;
    }

    void BackpropagateComRef() 
	{ 
		StoreObjectInHandle(m_com, ObjectToOBJECTREF( *(Object**)&m_secondHomeForC2NByRef )); 
	}

    void OutputNativeDest() { **(void ***)m_pDest = m_native; }
    void OutputComDest() { SetObjectReferenceUnchecked(*(OBJECTREF**)m_pDest,
                                                       ObjectFromHandle(m_com)); }

    void InputComField(void *pField) { StoreObjectInHandle(m_com, ObjectToOBJECTREF(*(Object**)pField)); }
    void OutputComField(void *pField) { SetObjectReferenceUnchecked((OBJECTREF*)pField,
                                                                    ObjectFromHandle(m_com)); }
    void ReInitNative()
    {
        m_native = NULL;
    }

    virtual void GcScanRoots(promote_func *fn, ScanContext* sc)
    {
        if (m_secondHomeForC2NByRef != NULL)
        {
            LOG((LF_GC, INFO3, "Marshaler Promoting %x to ", m_secondHomeForC2NByRef));
            (*fn)( *(Object**)&m_secondHomeForC2NByRef, sc);
            LOG((LF_GC, INFO3, "%x\n", m_secondHomeForC2NByRef ));
        }

    }

    OBJECTHANDLE        m_com;
    void                *m_native;


    // A second OBJECTREF store for ReferenceMarshaler byref marshaling
    // from unmanaged to managed. This store is gc-promoted by
    // the UnmanagedToManagedCallFrame.
    //
    // Why is this needed? The real home is an objecthandle which we
    // can't legally pass as a byref argument to a managed method (we
    // have to use StoreObjectInHandle() to write to it or we mess
    // up the write barrier.)
    //
    OBJECTREF           m_secondHomeForC2NByRef;




};

/* ------------------------------------------------------------------------- *
 * String marshallers
 * ------------------------------------------------------------------------- */

class BSTRMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    BSTRMarshaler(CleanupWorkList *pList) : ReferenceMarshaler(pList) {}
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ConvertSpaceNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            ULONG length = SysStringByteLen((BSTR)m_native);

            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            // has trailing odd byte
            BOOL bHasTrailByte = ((length%sizeof(WCHAR)) != 0);         
            length = length/sizeof(WCHAR);
            StoreObjectInHandle(m_com, (OBJECTREF) COMString::NewString(length, bHasTrailByte));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            
            ULONG length = stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            length = length*sizeof(WCHAR);
            if (COMString::HasTrailByte(stringRef))
            {
                length+=1;
            }
            m_native = SysAllocStringByteLen(NULL, length);
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            SysFreeString((BSTR)m_native);
    }

    void ConvertContentsNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        BSTR str = (BSTR) m_native;

        if (str != NULL)
        {
            STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);
            
            // this is the right thing to do, but sometimes we 
            // end up thinking we're marshaling a BSTR when we're not, because
            // it's the default type.
            ULONG length = SysStringByteLen((BSTR)m_native);
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            ULONG charLength = length/sizeof(WCHAR);

            //@todo WFC HACK to assert
            if (LoggingOn(LF_INTEROP, LL_EVERYTHING))
            {
                if (wcslen(str) != charLength)
                {
                    _ASSERTE(!"wcsLen(str) != SysStringLen(str)");
                }
            }
            
            BOOL hasTrailByte = (length%sizeof(WCHAR) != 0);            

            memcpyNoGCRefs(stringRef->GetBuffer(), str,
                       charLength*sizeof(WCHAR));

            if (hasTrailByte)
            {
                BYTE* buff = (BYTE*)str;
                //set the trail byte
                COMString::SetTrailByte(stringRef, buff[length-1]);
            }
            // null terminate the StringRef

            WCHAR* wstr = (WCHAR *)stringRef->GetBuffer();
            wstr[charLength] = '\0';
        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            DWORD length = (DWORD)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            
            BYTE *buff = (BYTE*)m_native;
            ULONG byteLen = length * sizeof(WCHAR);

            memcpyNoGCRefs((WCHAR *) m_native, stringRef->GetBuffer(), 
                       byteLen);
            
            if (COMString::HasTrailByte(stringRef))
            {
                BYTE b; 
#ifdef _DEBUG
                BOOL hasTrailB =
#endif
                COMString::GetTrailByte(stringRef, &b);
                _ASSERTE(hasTrailB);
                buff[byteLen] = b;
            }
            else
            {
                // copy the null terminator
                WCHAR* wstr = (WCHAR *)m_native;
                wstr[length] = L'\0';
            }
        }
    }


    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref && fin && !fout)
        {
            psl->MLEmit(ML_BSTR_C2N);
            psl->MLNewLocal(sizeof(ML_BSTR_C2N_SR));
            return OVERRIDDEN;
        }
        else
        {
            return HANDLEASNORMAL;
        }

    }

};

class WSTRMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    WSTRMarshaler(CleanupWorkList *pList) : ReferenceMarshaler(pList) {}

    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ConvertSpaceNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            INT32 length = (INT32)wcslen((LPWSTR)m_native);
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            StoreObjectInHandle(m_com, (OBJECTREF) COMString::NewString(length));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            SIZE_T length = stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            m_native = (LPWSTR) CoTaskMemAlloc((length+1) * sizeof(WCHAR));
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            CoTaskMemFree((LPWSTR)m_native);
    }

    void ConvertSpaceComToNativeTemp()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            m_native = (LPWSTR) GetThread()->m_MarshalAlloc.Alloc((length+1) * sizeof(WCHAR));
        }
    }

    void ClearNativeTemp() 
    { 
    }

    void ConvertContentsNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        LPWSTR str = (LPWSTR) m_native;

        if (str != NULL)
        {
            STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

            SIZE_T length = wcslen((LPWSTR) m_native) + 1;
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            memcpyNoGCRefs(stringRef->GetBuffer(), str,
                       length * sizeof(WCHAR));
        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            SIZE_T length = stringRef->GetStringLength() + 1;
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            memcpyNoGCRefs((LPWSTR) m_native, stringRef->GetBuffer(), 
                       length * sizeof(WCHAR));
        }
    }

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref && fin && !fout)
        {
            psl->MLEmit(ML_PINNEDUNISTR_C2N);
            return OVERRIDDEN;
        }
        else
        {
            return HANDLEASNORMAL;
        }

    }
};

class CSTRMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    CSTRMarshaler(CleanupWorkList *pList) : ReferenceMarshaler(pList)
    {
        m_BestFitMap = TRUE;
        m_ThrowOnUnmappableChar = FALSE;
    }
    
    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ConvertSpaceNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            // The length returned by MultiByteToWideChar includes the null terminator
            // so we need to substract one to obtain the length of the actual string.
            UINT32 length = (UINT32)MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, 
                                                       (LPSTR)m_native, -1, 
                                                        NULL, 0) - 1;
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            if (length == ((UINT32)(-1)))
            {
                COMPlusThrowWin32();
            }
            StoreObjectInHandle(m_com, (OBJECTREF) COMString::NewString(length));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            m_native = CoTaskMemAlloc((length * GetMaxDBCSCharByteSize()) + 1);
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            CoTaskMemFree(m_native);
    }

    void ConvertSpaceComToNativeTemp()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            m_native = GetThread()->m_MarshalAlloc.Alloc((length * GetMaxDBCSCharByteSize()) + 1);
        }
    }

    void ClearNativeTemp() 
    { 
    }

    void ConvertContentsNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        LPSTR str = (LPSTR) m_native;

        if (str != NULL)
        {
            STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            length++;

            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPSTR) m_native, -1, 
                                    stringRef->GetBuffer(), length) == 0)
                COMPlusThrowWin32();
        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            DWORD mblength = 0;

            if (length)
            {
                DWORD flags = 0;
                BOOL DefaultCharUsed = FALSE;
        
                if (m_BestFitMap == FALSE)
                    flags = WC_NO_BEST_FIT_CHARS;
                
                mblength = WszWideCharToMultiByte(CP_ACP, flags,
                                        stringRef->GetBuffer(), length,
                                        (LPSTR) m_native, (length * GetMaxDBCSCharByteSize()) + 1,
                                        NULL, &DefaultCharUsed);
                if (mblength == 0)
                    COMPlusThrowWin32();

                if (m_ThrowOnUnmappableChar && DefaultCharUsed)
                    COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
            }
            ((CHAR*)m_native)[mblength] = '\0';

        }
    }


    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref && fin && !fout)
        {
            psl->MLEmit(ML_CSTR_C2N);
            psl->Emit8(pargs->m_pMLInfo->GetBestFitMapping());
            psl->Emit8(pargs->m_pMLInfo->GetThrowOnUnmappableChar());
            psl->MLNewLocal(sizeof(ML_CSTR_C2N_SR));
            return OVERRIDDEN;
        }
        else
        {
            return HANDLEASNORMAL;
        }
    }

    void SetBestFitMap(BOOL BestFit) { m_BestFitMap = BestFit; }
    void SetThrowOnUnmappableChar(BOOL ThrowOnUnmapChar) { m_ThrowOnUnmappableChar = ThrowOnUnmapChar; }
   
    BOOL  m_BestFitMap;
    BOOL  m_ThrowOnUnmappableChar;
};

// String marshalling Ex helpers
// used for marshalling arbitrary classes to native type strings

class BSTRMarshalerEx : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    BSTRMarshalerEx(CleanupWorkList *pList) : ReferenceMarshaler(pList) {}
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ConvertSpaceNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            // this is the right thing to do, but sometimes we 
            // end up thinking we're marshaling a BSTR when we're not, because
            // it's the default type.
            // SIZE_T length = SysStringLen((BSTR)m_native);
            UINT32 length = (UINT32)wcslen((BSTR)m_native);
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            StoreObjectInHandle(m_com, (OBJECTREF) COMString::NewString(length));
        }
    }

    void ToString()
    {
        if (ObjectFromHandle(m_com) != NULL)
        {
            // convert the StringRef 
            _ASSERTE(GetAppDomain()->IsSpecialStringClass(m_pMT));
            OBJECTREF oref = GetAppDomain()->ConvertSpecialStringToString(ObjectFromHandle(m_com));
            StoreObjectInHandle(m_com, oref);        
        }
    }

    void FromString()
    {
        OBJECTREF oref =  NULL;
        if (ObjectFromHandle(m_com) != NULL)
        {
            // convert the string ref to the appropriate type
            _ASSERTE(GetAppDomain()->IsSpecialStringClass(m_pMT));
            OBJECTREF oref = GetAppDomain()->ConvertStringToSpecialString(ObjectFromHandle(m_com));
            StoreObjectInHandle(m_com, oref);
        }       
    }

    void ConvertSpaceComToNative()
    {   
        THROWSCOMPLUSEXCEPTION();

        ToString();
        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);
        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            m_native = SysAllocStringLen(NULL, length);
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            SysFreeString((BSTR)m_native);
    }

    void ConvertContentsNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        BSTR str = (BSTR) m_native;

        if (str != NULL)
        {
            STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

            // this is the right thing to do, but sometimes we 
            // end up thinking we're marshaling a BSTR when we're not, because
            // it's the default type.
            // SIZE_T length = SysStringLen((BSTR)m_native);
            SIZE_T length = wcslen(str);
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            length++;

            memcpyNoGCRefs(stringRef->GetBuffer(), str,
                       length * sizeof(WCHAR));

            if (0)
            {
                // convert the string ref to the appropriate type
                FromString();
            }
        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        OBJECTREF oref = (OBJECTREF) ObjectFromHandle(m_com);
        if (oref == NULL)
            return;
        if (oref->GetMethodTable() != g_pStringClass)
        {
            ToString();
        }

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            SIZE_T length = stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            length++;
            memcpyNoGCRefs((WCHAR *) m_native, stringRef->GetBuffer(), 
                       length * sizeof(WCHAR));
        }
    }


    MethodTable*    m_pMT;
    void SetMethodTable(MethodTable *pMT) { m_pMT = pMT; }
};













class AnsiBSTRMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    AnsiBSTRMarshaler(CleanupWorkList *pList) : ReferenceMarshaler(pList)
    {
        m_BestFitMap = TRUE;
        m_ThrowOnUnmappableChar = FALSE;
    }
    
    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ConvertSpaceNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            // The length returned by MultiByteToWideChar includes the null terminator
            // so we need to substract one to obtain the length of the actual string.
            UINT32 length = (UINT32)MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, 
                                                       (LPSTR)m_native, -1, 
                                                        NULL, 0) - 1;
            if (length == ((UINT32)(-1)))
            {
                COMPlusThrowWin32();
            }
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            StoreObjectInHandle(m_com, (OBJECTREF) COMString::NewString(length));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            m_native = CoTaskMemAlloc((length * GetMaxDBCSCharByteSize()) + 1 + sizeof(DWORD));
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
            ((BYTE*&)m_native) += sizeof(DWORD);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            CoTaskMemFree( ((BYTE*)m_native) - sizeof(DWORD) );
    }

    void ConvertSpaceComToNativeTemp()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            m_native = GetThread()->m_MarshalAlloc.Alloc((length * GetMaxDBCSCharByteSize()) + 1 + sizeof(DWORD));
            ((BYTE*&)m_native) += sizeof(DWORD);
        }
    }

    void ClearNativeTemp() 
    { 
    }

    void ConvertContentsNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        LPSTR str = (LPSTR) m_native;

        if (str != NULL)
        {
            STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            length++;
            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPSTR) m_native, -1, 
                                         stringRef->GetBuffer(), length) == 0)
                COMPlusThrowWin32();

        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            DWORD nb = 0;
            if (length)
            {
                DWORD flags = 0;
                BOOL DefaultCharUsed = FALSE;

                if (m_BestFitMap == FALSE)
                    flags = WC_NO_BEST_FIT_CHARS;
            
                if ( (nb = WszWideCharToMultiByte(CP_ACP, flags,
                                        stringRef->GetBuffer(), length,
                                        (LPSTR) m_native, (length * GetMaxDBCSCharByteSize()) + 1,
                                        NULL, &DefaultCharUsed)) == 0)
                    COMPlusThrowWin32();

                if (m_ThrowOnUnmappableChar && DefaultCharUsed)
                    COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
            }
            ((CHAR*)m_native)[nb] = '\0';
            ((DWORD*)m_native)[-1] = nb;

        }
    }

    void SetBestFitMap(BOOL BestFit) { m_BestFitMap = BestFit; }
    void SetThrowOnUnmappableChar(BOOL ThrowOnUnmapChar) { m_ThrowOnUnmappableChar = ThrowOnUnmapChar; }
    
    BOOL  m_BestFitMap;
    BOOL  m_ThrowOnUnmappableChar;
};







class WSTRMarshalerEx : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    WSTRMarshalerEx(CleanupWorkList *pList) : ReferenceMarshaler(pList) {}
    
    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ToString()
    {
        if (ObjectFromHandle(m_com) == NULL)
            return;

        // convert the StringRef 
        _ASSERTE(GetAppDomain()->IsSpecialStringClass(m_pMT));
        OBJECTREF oref = GetAppDomain()->ConvertSpecialStringToString(ObjectFromHandle(m_com));
        StoreObjectInHandle(m_com, oref);        
    }

    void FromString()
    {
        if (ObjectFromHandle(m_com) == NULL)
            return;

        // convert the string ref to the appropriate type
        _ASSERTE(GetAppDomain()->IsSpecialStringClass(m_pMT));
        OBJECTREF oref = GetAppDomain()->ConvertStringToSpecialString(ObjectFromHandle(m_com));
        StoreObjectInHandle(m_com, oref);
    }

    void ConvertSpaceNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            UINT32 length = (UINT32)wcslen((LPWSTR)m_native);
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            StoreObjectInHandle(m_com, (OBJECTREF) COMString::NewString(length));
        }
    }

    void ConvertSpaceComToNative()
    {       
        THROWSCOMPLUSEXCEPTION();

        // convert the StringRef 
        ToString();
        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            SIZE_T length = stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            m_native = (LPWSTR) CoTaskMemAlloc((length+1) * sizeof(WCHAR));
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            CoTaskMemFree((LPWSTR)m_native);
    }

    void ConvertSpaceComToNativeTemp()
    {
        THROWSCOMPLUSEXCEPTION();

        // convert the StringRef 
        ToString();
        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            m_native = (LPWSTR) GetThread()->m_MarshalAlloc.Alloc((length+1) * sizeof(WCHAR));
        }
    }

    void ClearNativeTemp() 
    { 
    }

    void ConvertContentsNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        LPWSTR str = (LPWSTR) m_native;

        if (str != NULL)
        {
            STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

            SIZE_T length = wcslen((LPWSTR) m_native);
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            length++;
            memcpyNoGCRefs(stringRef->GetBuffer(), str,
                       length * sizeof(WCHAR));

            // convert the string ref to the appropriate type
            if (0)
            {
                FromString();
            }
        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        OBJECTREF oref = (OBJECTREF) ObjectFromHandle(m_com);
        if (oref == NULL)
        {
            return;
        }
        if (oref->GetMethodTable() != g_pStringClass)
        {
            ToString();
        }

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            SIZE_T length = stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            length++;
            memcpyNoGCRefs((LPWSTR) m_native, stringRef->GetBuffer(), 
                       length * sizeof(WCHAR));
        }
    }

    
    MethodTable*    m_pMT;
    void SetMethodTable(MethodTable *pMT) { m_pMT = pMT; }
};

class CSTRMarshalerEx : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = TRUE,
    };

    CSTRMarshalerEx(CleanupWorkList *pList) : ReferenceMarshaler(pList)
    {
        m_BestFitMap = TRUE;
        m_ThrowOnUnmappableChar = FALSE;
    }
    
    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ToString()
    {
        if (ObjectFromHandle(m_com) == NULL)
            return;

        // convert the StringRef 
        _ASSERTE(GetAppDomain()->IsSpecialStringClass(m_pMT));
        OBJECTREF oref = GetAppDomain()->ConvertSpecialStringToString(ObjectFromHandle(m_com));
        StoreObjectInHandle(m_com, oref);        
    }

    void FromString()
    {
        if (ObjectFromHandle(m_com) == NULL)
            return;

        // convert the string ref to the appropriate type
        _ASSERTE(GetAppDomain()->IsSpecialStringClass(m_pMT));
        OBJECTREF oref = GetAppDomain()->ConvertStringToSpecialString(ObjectFromHandle(m_com));
        StoreObjectInHandle(m_com, oref);
    }

    void ConvertSpaceNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            UINT32 length = (UINT32)MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, 
                                                       (LPSTR)m_native, -1, 
                                                        NULL, 0);
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            StoreObjectInHandle(m_com, (OBJECTREF) COMString::NewString(length));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        // convert the StringRef 
        ToString();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }


            m_native = CoTaskMemAlloc((length * GetMaxDBCSCharByteSize()) + 1);
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            CoTaskMemFree(m_native);
    }

    void ConvertSpaceComToNativeTemp()
    {
        THROWSCOMPLUSEXCEPTION();

        // convert the StringRef 
        ToString();

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }


            m_native = GetThread()->m_MarshalAlloc.Alloc((length * GetMaxDBCSCharByteSize()) + 1);
        }
    }

    void ClearNativeTemp() 
    { 
    }

    void ConvertContentsNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        LPSTR str = (LPSTR) m_native;

        if (str != NULL)
        {
            STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPSTR) m_native, -1, 
                                    stringRef->GetBuffer(), length) == 0)
                COMPlusThrowWin32();
        
            // convert the string ref to the appropriate type
            if (0)
            {
                FromString();
            }
        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        if (ObjectFromHandle(m_com) == NULL)
        {
            return;
        }
        OBJECTREF oref = (OBJECTREF) ObjectFromHandle(m_com);       
        if (oref->GetMethodTable() != g_pStringClass)
        {
            ToString();
        }

        STRINGREF stringRef = (STRINGREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            UINT32 length = (UINT32)stringRef->GetStringLength();
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            DWORD mblength = 0;

            if (length)
            {
                DWORD flags = 0;
                BOOL DefaultCharUsed = FALSE;
        
                if (m_BestFitMap == FALSE)
                    flags = WC_NO_BEST_FIT_CHARS;

                mblength = WszWideCharToMultiByte(CP_ACP, flags,
                                        stringRef->GetBuffer(), length,
                                        (LPSTR) m_native, (length * GetMaxDBCSCharByteSize()) + 1,
                                        NULL, &DefaultCharUsed);
                if (mblength == 0)
                    COMPlusThrowWin32();

                if (m_ThrowOnUnmappableChar && DefaultCharUsed)
                    COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
            }
            ((CHAR*)m_native)[mblength] = '\0';

        }
    }
    
    MethodTable*    m_pMT;
    void SetMethodTable(MethodTable *pMT) { m_pMT = pMT; }
    
    void SetBestFitMap(BOOL BestFit) { m_BestFitMap = BestFit; }
    void SetThrowOnUnmappableChar(BOOL ThrowOnUnmapChar) { m_ThrowOnUnmappableChar = ThrowOnUnmapChar; }

    BOOL  m_BestFitMap;
    BOOL  m_ThrowOnUnmappableChar;

};

/* ------------------------------------------------------------------------- *
 * StringBuffer marshallers
 * ------------------------------------------------------------------------- */
class BSTRBufferMarshaler : public ReferenceMarshaler
{

  //@bug: dead code: as soon as the integration merges with the main branch, can toss this.
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    BSTRBufferMarshaler(CleanupWorkList *pList) : ReferenceMarshaler(pList) {}
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ConvertSpaceNativeToCom()
    {
        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            UINT32 length = (UINT32)SysStringLen((BSTR)m_native);

            StoreObjectInHandle(m_com, (OBJECTREF) COMStringBuffer::NewStringBuffer(length));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            // There is a BVT which requires that the BSTR len be set
            // to the string buffer length, not its capactity.  I'm not
            // sure I agree that that's correct... -SET

            UINT32 length = (UINT32)COMStringBuffer::NativeGetLength(stringRef);
            m_native = SysAllocStringLen(NULL, length);
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            SysFreeString((BSTR)m_native);
    }

    void ConvertContentsNativeToCom()
    {
        BSTR str = (BSTR) m_native;

        if (str != NULL)
        {
            COMStringBuffer::ReplaceBuffer((STRINGBUFFERREF *) m_com,
                                           str, (INT32)wcslen(str));
        }
    }

    void ConvertContentsComToNative()
    {
        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            SIZE_T length = COMStringBuffer::NativeGetLength(stringRef);

            memcpyNoGCRefs((WCHAR *) m_native, COMStringBuffer::NativeGetBuffer(stringRef),
                       length * sizeof(WCHAR));
            ((WCHAR*)m_native)[length] = 0;
        }
    }
};



class WSTRBufferMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,

    };

    WSTRBufferMarshaler(CleanupWorkList *pList) : ReferenceMarshaler(pList) {}

    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ConvertSpaceNativeToCom()
    {
        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            StoreObjectInHandle(m_com, (OBJECTREF) COMStringBuffer::NewStringBuffer(16));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            SIZE_T capacity = COMStringBuffer::NativeGetCapacity(stringRef);
            if (capacity > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            m_native = CoTaskMemAlloc((capacity+2) * sizeof(WCHAR));
            if (m_native == NULL)
                COMPlusThrowOM();
            // HACK: N/Direct can be used to call Win32 apis that don't
            // strictly follow COM+ in/out semantics and thus may leave
            // garbage in the buffer in circumstances that we can't detect.
            // To prevent the marshaler from crashing when converting the
            // contents back to COM, ensure that there's a hidden null terminator
            // past the end of the official buffer.
            ((WCHAR*)m_native)[capacity+1] = L'\0';
#ifdef _DEBUG
            FillMemory(m_native, (capacity+1)*sizeof(WCHAR), 0xcc);
#endif

            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            CoTaskMemFree(m_native);
    }

    void ConvertSpaceComToNativeTemp()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 capacity = (UINT32)COMStringBuffer::NativeGetCapacity(stringRef);
            if (capacity > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            m_native = GetThread()->m_MarshalAlloc.Alloc((capacity+2) * sizeof(WCHAR));
            // HACK: N/Direct can be used to call Win32 apis that don't
            // strictly follow COM+ in/out semantics and thus may leave
            // garbage in the buffer in circumstances that we can't detect.
            // To prevent the marshaler from crashing when converting the
            // contents back to COM, ensure that there's a hidden null terminator
            // past the end of the official buffer.
            ((WCHAR*)m_native)[capacity+1] = L'\0';
#ifdef _DEBUG
            FillMemory(m_native, (capacity+1)*sizeof(WCHAR), 0xcc);
#endif
        }
    }

    void ClearNativeTemp() 
    { 
    }

    void ConvertContentsNativeToCom()
    {
        LPWSTR str = (LPWSTR) m_native;

        if (str != NULL)
        {
            STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

            COMStringBuffer::ReplaceBuffer((STRINGBUFFERREF *) m_com,
                                           str, (INT32)wcslen(str));
        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            SIZE_T length = COMStringBuffer::NativeGetLength(stringRef);
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            memcpyNoGCRefs((WCHAR *) m_native, COMStringBuffer::NativeGetBuffer(stringRef),
                       length * sizeof(WCHAR));
            ((WCHAR*)m_native)[length] = 0;
        }
    }


    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref && fin && fout)
        {
            psl->MLEmit(ML_WSTRBUILDER_C2N);
            pslPost->MLEmit(ML_WSTRBUILDER_C2N_POST);
            pslPost->Emit16(psl->MLNewLocal(sizeof(ML_WSTRBUILDER_C2N_SR)));
            return OVERRIDDEN;
        }

        return HANDLEASNORMAL;
    }


};

class CSTRBufferMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    CSTRBufferMarshaler(CleanupWorkList *pList) : ReferenceMarshaler(pList)
    {
        m_BestFitMap = TRUE;
        m_ThrowOnUnmappableChar = FALSE;
    }
    
    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ConvertSpaceNativeToCom()
    {
        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            StoreObjectInHandle(m_com, (OBJECTREF) COMStringBuffer::NewStringBuffer(16));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            SIZE_T capacity = COMStringBuffer::NativeGetCapacity(stringRef);
            if (capacity > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            // @todo: this is bogus, the buffer may not be initialized yet.

            // capacity is the count of wide chars, allocate buffer big enough for maximum
            // conversion to DBCS.
            m_native = CoTaskMemAlloc((capacity * GetMaxDBCSCharByteSize()) + 4);
            if (m_native == NULL)
                COMPlusThrowOM();

            // HACK: N/Direct can be used to call Win32 apis that don't
            // strictly follow COM+ in/out semantics and thus may leave
            // garbage in the buffer in circumstances that we can't detect.
            // To prevent the marshaler from crashing when converting the
            // contents back to COM, ensure that there's a hidden null terminator
            // past the end of the official buffer.
            ((CHAR*)m_native)[capacity+1] = '\0';
            ((CHAR*)m_native)[capacity+2] = '\0';
            ((CHAR*)m_native)[capacity+3] = '\0';

#ifdef _DEBUG
            FillMemory(m_native, (capacity+1) * sizeof(CHAR), 0xcc);
#endif
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            CoTaskMemFree(m_native);
    }

    void ConvertSpaceComToNativeTemp()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 capacity = (UINT32)COMStringBuffer::NativeGetCapacity(stringRef);
            if (capacity > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            // @todo: this is bogus, the buffer may not be initialized yet.

            // capacity is the count of wide chars, allocate buffer big enough for maximum
            // conversion to DBCS.
            m_native = GetThread()->m_MarshalAlloc.Alloc((capacity * GetMaxDBCSCharByteSize()) + 4);

            // HACK: N/Direct can be used to call Win32 apis that don't
            // strictly follow COM+ in/out semantics and thus may leave
            // garbage in the buffer in circumstances that we can't detect.
            // To prevent the marshaler from crashing when converting the
            // contents back to COM, ensure that there's a hidden null terminator
            // past the end of the official buffer.
            ((CHAR*)m_native)[capacity+1] = '\0';
            ((CHAR*)m_native)[capacity+2] = '\0';
            ((CHAR*)m_native)[capacity+3] = '\0';

#ifdef _DEBUG
            FillMemory(m_native, (capacity+1) * sizeof(CHAR), 0xcc);
#endif
        }
    }

    void ClearNativeTemp() 
    { 
    }

    void ConvertContentsNativeToCom()
    {
        LPSTR str = (LPSTR) m_native;

        if (str != NULL)
        {
            STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

            COMStringBuffer::ReplaceBufferAnsi((STRINGBUFFERREF *) m_com,
                                               str, (INT32)strlen(str));
        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            UINT32 length = (UINT32)COMStringBuffer::NativeGetLength(stringRef);
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            DWORD mblength = 0;

            if (length)
            {
                UINT32 capacity = (UINT32)COMStringBuffer::NativeGetCapacity(stringRef);
                if (capacity > 0x7ffffff0)
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
                }

                DWORD flags = 0;
                BOOL DefaultCharUsed = FALSE;
        
                if (m_BestFitMap == FALSE)
                    flags = WC_NO_BEST_FIT_CHARS;

                mblength = WszWideCharToMultiByte(CP_ACP, flags,
                                        COMStringBuffer::NativeGetBuffer(stringRef), length,
                                        (LPSTR) m_native, (capacity * GetMaxDBCSCharByteSize()) + 4,
                                        NULL, &DefaultCharUsed);
                if (mblength == 0)
                    COMPlusThrowWin32();

                if (m_ThrowOnUnmappableChar && DefaultCharUsed)
                    COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
            }
            ((CHAR*)m_native)[mblength] = '\0';
        }
    }


    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref && fin && fout)
        {
            psl->MLEmit(ML_CSTRBUILDER_C2N);
            psl->Emit8(pargs->m_pMLInfo->GetBestFitMapping());
            psl->Emit8(pargs->m_pMLInfo->GetThrowOnUnmappableChar());
            pslPost->MLEmit(ML_CSTRBUILDER_C2N_POST);
            pslPost->Emit16(psl->MLNewLocal(sizeof(ML_CSTRBUILDER_C2N_SR)));
            return OVERRIDDEN;
        }
        return HANDLEASNORMAL;
    }

    void SetBestFitMap(BOOL BestFit) { m_BestFitMap = BestFit; }
    void SetThrowOnUnmappableChar(BOOL ThrowOnUnmapChar) { m_ThrowOnUnmappableChar = ThrowOnUnmapChar; }

    BOOL  m_BestFitMap;
    BOOL  m_ThrowOnUnmappableChar;
};


// String Buffer marshalling Ex helpers
// used for marshalling arbitrary classes to native type strings

class BSTRBufferMarshalerEx : public ReferenceMarshaler
{

  //@todo: either fix or eliminate BSTR<->Buffer marshaling.
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    BSTRBufferMarshalerEx(CleanupWorkList *pList) : ReferenceMarshaler(pList) {}
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ToStringBuilder()
    {
        if (ObjectFromHandle(m_com) == NULL)
            return;

        _ASSERTE(GetAppDomain()->IsSpecialStringBuilderClass(m_pMT));
        OBJECTREF oref = GetAppDomain()->ConvertStringBuilderToSpecialStringBuilder(ObjectFromHandle(m_com));
        StoreObjectInHandle(m_com, oref);
    }

    void FromStringBuilder()
    {
        if (ObjectFromHandle(m_com) == NULL)
            return;

        // convert the string builder ref to the appropriate type
        _ASSERTE(GetAppDomain()->IsSpecialStringBuilderClass(m_pMT));
        OBJECTREF oref = GetAppDomain()->ConvertSpecialStringBuilderToStringBuilder(ObjectFromHandle(m_com));
        StoreObjectInHandle(m_com, oref);
    }

    void ConvertSpaceNativeToCom()
    {
        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            UINT32 length = (UINT32)SysStringLen((BSTR)m_native);

            StoreObjectInHandle(m_com, (OBJECTREF) COMStringBuffer::NewStringBuffer(length));               
         };
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        // convert to StringBuilderRef 

        ToStringBuilder();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            // @todo: There is a BVT which requires that the BSTR len be set
            // to the string buffer length, not its capactity.  I'm not
            // sure I agree that that's correct... -SET

            UINT32 length = (UINT32)COMStringBuffer::NativeGetLength(stringRef);
            m_native = SysAllocStringLen(NULL, length);
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            SysFreeString((BSTR)m_native);
    }

    void ConvertContentsNativeToCom()
    {
        BSTR str = (BSTR) m_native;

        if (str != NULL)
        {
            COMStringBuffer::ReplaceBuffer((STRINGBUFFERREF *) m_com,
                                           str, (INT32)wcslen(str));
        }

        if (0)
        {
            FromStringBuilder();
        }
    }

    void ConvertContentsComToNative()
    {
        OBJECTREF oref = (OBJECTREF) ObjectFromHandle(m_com);
        if (oref == NULL)
            return;

        if (oref->GetMethodTable() != COMStringBuffer::s_pStringBufferClass)
        {
            ToStringBuilder();
        }

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            SIZE_T length = COMStringBuffer::NativeGetLength(stringRef);

            memcpyNoGCRefs((WCHAR *) m_native, COMStringBuffer::NativeGetBuffer(stringRef),
                       length * sizeof(WCHAR));
            ((WCHAR*)m_native)[length] = 0;         
        }
    }

    
    MethodTable*    m_pMT;
    void SetMethodTable(MethodTable *pMT) { m_pMT = pMT; }
};


class WSTRBufferMarshalerEx : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    WSTRBufferMarshalerEx(CleanupWorkList *pList) : ReferenceMarshaler(pList) {}
    
    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ToStringBuilder()
    {
        if (ObjectFromHandle(m_com) == NULL)
            return;

        _ASSERTE(GetAppDomain()->IsSpecialStringBuilderClass(m_pMT));
        OBJECTREF oref = GetAppDomain()->ConvertSpecialStringBuilderToStringBuilder(ObjectFromHandle(m_com));
        StoreObjectInHandle(m_com, oref);
    }

    void FromStringBuilder()
    {
        if (ObjectFromHandle(m_com) == NULL)
            return;

        _ASSERTE(GetAppDomain()->IsSpecialStringBuilderClass(m_pMT));
        OBJECTREF oref = GetAppDomain()->ConvertStringBuilderToSpecialStringBuilder(ObjectFromHandle(m_com));
        StoreObjectInHandle(m_com, oref);
    }


    void ConvertSpaceNativeToCom()
    {
        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            StoreObjectInHandle(m_com, (OBJECTREF) COMStringBuffer::NewStringBuffer(16));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        // convert to StringBuilderRef 
        ToStringBuilder();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            SIZE_T capacity = COMStringBuffer::NativeGetCapacity(stringRef);
            if (capacity > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            m_native = CoTaskMemAlloc((capacity+2) * sizeof(WCHAR));
            if (m_native == NULL)
                COMPlusThrowOM();
            // HACK: N/Direct can be used to call Win32 apis that don't
            // strictly follow COM+ in/out semantics and thus may leave
            // garbage in the buffer in circumstances that we can't detect.
            // To prevent the marshaler from crashing when converting the
            // contents back to COM, ensure that there's a hidden null terminator
            // past the end of the official buffer.
            ((WCHAR*)m_native)[capacity+1] = L'\0';
#ifdef _DEBUG
            FillMemory(m_native, (capacity+1)*sizeof(WCHAR), 0xcc);
#endif

            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            CoTaskMemFree(m_native);
    }

    void ConvertSpaceComToNativeTemp()
    {
        THROWSCOMPLUSEXCEPTION();

        // convert to StringBuilderRef 
        ToStringBuilder();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 capacity = (UINT32)COMStringBuffer::NativeGetCapacity(stringRef);
            if (capacity > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            m_native = GetThread()->m_MarshalAlloc.Alloc((capacity+2) * sizeof(WCHAR));
            // HACK: N/Direct can be used to call Win32 apis that don't
            // strictly follow COM+ in/out semantics and thus may leave
            // garbage in the buffer in circumstances that we can't detect.
            // To prevent the marshaler from crashing when converting the
            // contents back to COM, ensure that there's a hidden null terminator
            // past the end of the official buffer.
            ((WCHAR*)m_native)[capacity+1] = L'\0';
#ifdef _DEBUG
            FillMemory(m_native, (capacity+1)*sizeof(WCHAR), 0xcc);
#endif
        }
    }

    void ClearNativeTemp() 
    { 
    }

    void ConvertContentsNativeToCom()
    {
        LPWSTR str = (LPWSTR) m_native;

        if (str != NULL)
        {
            STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

            COMStringBuffer::ReplaceBuffer((STRINGBUFFERREF *) m_com,
                                           str, (INT32)wcslen(str));
        }

        if (0)
        {
            // convert the string builder ref to the appropriate type
            FromStringBuilder();
        }
    };

        
    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        OBJECTREF oref = (OBJECTREF) ObjectFromHandle(m_com);
        if (oref == NULL)
            return;
        if (oref->GetMethodTable() != COMStringBuffer::s_pStringBufferClass)
        {
            ToStringBuilder();
        }

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            SIZE_T length = COMStringBuffer::NativeGetLength(stringRef);
            if (length > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            memcpyNoGCRefs((WCHAR *) m_native, COMStringBuffer::NativeGetBuffer(stringRef),
                       length * sizeof(WCHAR));
            ((WCHAR*)m_native)[length] = 0;
        }
    }


    
    MethodTable*    m_pMT;
    void SetMethodTable(MethodTable *pMT) { m_pMT = pMT; }

};

class CSTRBufferMarshalerEx : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    CSTRBufferMarshalerEx(CleanupWorkList *pList) : ReferenceMarshaler(pList)
    {
        m_BestFitMap = TRUE;
        m_ThrowOnUnmappableChar = FALSE;
    }
    
    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ToStringBuilder()
    {
        if (ObjectFromHandle(m_com) == NULL)
            return;

        _ASSERTE(GetAppDomain()->IsSpecialStringBuilderClass(m_pMT));
        OBJECTREF oref = GetAppDomain()->ConvertSpecialStringBuilderToStringBuilder(ObjectFromHandle(m_com));
        StoreObjectInHandle(m_com, oref);
    }

    void FromStringBuilder()
    {
        if (ObjectFromHandle(m_com) == NULL)
            return;

        // convert the string builder ref to the appropriate type
        _ASSERTE(GetAppDomain()->IsSpecialStringBuilderClass(m_pMT));
        OBJECTREF oref = GetAppDomain()->ConvertStringBuilderToSpecialStringBuilder(ObjectFromHandle(m_com));
        StoreObjectInHandle(m_com, oref);
    }

    void ConvertSpaceNativeToCom()
    {
        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            StoreObjectInHandle(m_com, (OBJECTREF) COMStringBuffer::NewStringBuffer(16));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        // convert to StringBuilderRef 
        ToStringBuilder();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            SIZE_T capacity = COMStringBuffer::NativeGetCapacity(stringRef);
            if (capacity > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            // @todo: this is bogus, the buffer may not be initialized yet.

            // capacity is count of chars, allocate room for max DBCS string convert.
            m_native = CoTaskMemAlloc((capacity * GetMaxDBCSCharByteSize()) + 4);
            if (m_native == NULL)
                COMPlusThrowOM();

            // HACK: N/Direct can be used to call Win32 apis that don't
            // strictly follow COM+ in/out semantics and thus may leave
            // garbage in the buffer in circumstances that we can't detect.
            // To prevent the marshaler from crashing when converting the
            // contents back to COM, ensure that there's a hidden null terminator
            // past the end of the official buffer.
            ((CHAR*)m_native)[capacity+1] = '\0';
            ((CHAR*)m_native)[capacity+2] = '\0';
            ((CHAR*)m_native)[capacity+3] = '\0';

#ifdef _DEBUG
            FillMemory(m_native, (capacity+1) * sizeof(CHAR), 0xcc);
#endif
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            CoTaskMemFree(m_native);
    }

    void ConvertSpaceComToNativeTemp()
    {
        THROWSCOMPLUSEXCEPTION();

        // convert to StringBuilderRef 
        ToStringBuilder();

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 capacity = (UINT32)COMStringBuffer::NativeGetCapacity(stringRef);
            if (capacity > 0x7ffffff0)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }

            // @todo: this is bogus, the buffer may not be initialized yet.

            m_native = GetThread()->m_MarshalAlloc.Alloc((capacity * GetMaxDBCSCharByteSize()) + 4);

            // HACK: N/Direct can be used to call Win32 apis that don't
            // strictly follow COM+ in/out semantics and thus may leave
            // garbage in the buffer in circumstances that we can't detect.
            // To prevent the marshaler from crashing when converting the
            // contents back to COM, ensure that there's a hidden null terminator
            // past the end of the official buffer.
            ((CHAR*)m_native)[capacity+1] = '\0';
            ((CHAR*)m_native)[capacity+2] = '\0';
            ((CHAR*)m_native)[capacity+3] = '\0';

#ifdef _DEBUG
            FillMemory(m_native, (capacity+1) * sizeof(CHAR), 0xcc);
#endif
        }
    }

    void ClearNativeTemp() 
    { 
    }

    void ConvertContentsNativeToCom()
    {
        LPSTR str = (LPSTR) m_native;

        if (str != NULL)
        {
            STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

            COMStringBuffer::ReplaceBufferAnsi((STRINGBUFFERREF *) m_com,
                                               str, (INT32)strlen(str));
        }

                // convert the string builder ref to the appropriate type
        if (0)
        {
            FromStringBuilder();
        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        OBJECTREF oref = (OBJECTREF) ObjectFromHandle(m_com);
        if (oref == NULL)
            return;
        if (oref->GetMethodTable() != COMStringBuffer::s_pStringBufferClass)
        {
            ToStringBuilder();
        }

        STRINGBUFFERREF stringRef = (STRINGBUFFERREF) ObjectFromHandle(m_com);

        if (stringRef != NULL)
        {
            UINT32 length = (UINT32)COMStringBuffer::NativeGetLength(stringRef);
            UINT32 capacity = (UINT32)COMStringBuffer::NativeGetCapacity(stringRef);
            if ( (capacity > 0x7ffffff0) || (length > 0x7ffffff0) )
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
            }
            DWORD mblength = 0;

            if (length)
            {
                DWORD flags = 0;
                BOOL DefaultCharUsed = FALSE;
        
                if (m_BestFitMap == FALSE)
                    flags = WC_NO_BEST_FIT_CHARS;

                mblength = WszWideCharToMultiByte(CP_ACP, flags,
                                        COMStringBuffer::NativeGetBuffer(stringRef), length,
                                        (LPSTR) m_native, (capacity * GetMaxDBCSCharByteSize()) + 4,
                                        NULL, &DefaultCharUsed);
                if (mblength == 0)
                    COMPlusThrowWin32();

                if (m_ThrowOnUnmappableChar && DefaultCharUsed)
                    COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
            }
            ((CHAR*)m_native)[mblength] = '\0';
        }
    }


    MethodTable*    m_pMT;
    void SetMethodTable(MethodTable *pMT) { m_pMT = pMT; }
    
    void SetBestFitMap(BOOL BestFit) { m_BestFitMap = BestFit; }
    void SetThrowOnUnmappableChar(BOOL ThrowOnUnmapChar) { m_ThrowOnUnmappableChar = ThrowOnUnmapChar; }

    BOOL  m_BestFitMap;
    BOOL  m_ThrowOnUnmappableChar;
};


/* ------------------------------------------------------------------------- *
 * Interface marshaller
 * ------------------------------------------------------------------------- */

class InterfaceMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = FALSE,

        c_fInOnly = TRUE,
    };

    InterfaceMarshaler(CleanupWorkList *pList) 
      : ReferenceMarshaler(pList) {}
    
    void SetClassMT(MethodTable *pClassMT) { m_pClassMT = pClassMT; }
    void SetItfMT(MethodTable *pItfMT) { m_pItfMT = pItfMT; }
    void SetIsDispatch(BOOL bDispatch) { m_bDispatch = bDispatch; }
    void SetClassIsHint(BOOL bClassIsHint) { m_bClassIsHint = bClassIsHint; }

    DEFAULT_MARSHAL_OVERRIDES;

    void ClearNative() 
    { 
        if (m_native != NULL)
        {
            ULONG cbRef = SafeRelease((IUnknown *)m_native);
            LogInteropRelease((IUnknown *)m_native, cbRef, "In/Out release");
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        OBJECTREF objectRef = ObjectFromHandle(m_com);

        if (objectRef == NULL)
        {
            m_native = NULL;
        }
        else
        {
            // When an interface method table is specified, m_fDispIntf must be consistent with the
            // interface type.
            _ASSERTE(!m_pItfMT || (!m_pItfMT->IsInterface() && m_bDispatch) ||
                (m_bDispatch ==  m_pItfMT->GetComInterfaceType() != ifVtable));

            // Convert the ObjectRef to a COM IP.
            if (m_pItfMT)
            {
                m_native = (void*) GetComIPFromObjectRef((OBJECTREF *)m_com, m_pItfMT);
            }
            else
            {
                ComIpType ReqIpType = m_bDispatch ? ComIpType_Dispatch : ComIpType_Unknown;
                m_native = (void*) GetComIPFromObjectRef((OBJECTREF *)m_com, ReqIpType, NULL);
            }

            if (m_native != NULL)
                m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ConvertSpaceNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();
        if (m_native == NULL)
        {
            StoreObjectInHandle(m_com, NULL);
        }
        else
        {
            OBJECTREF oref;

            _ASSERTE(!m_pClassMT || !m_pClassMT->IsInterface());
            oref = GetObjectRefFromComIP((IUnknown*)m_native, m_pClassMT, m_bClassIsHint);           

            // Store the object in the handle. This needs to happen before we call SupportsInterface
            // because SupportsInterface can cause a GC.
            StoreObjectInHandle(m_com, oref);

            // set oref to NULL so no body uses it
            // they should use 
            // ObjectFromHandle(m_com) if they want to get to the object
            oref = NULL; 

            // Make sure the interface is supported.
            _ASSERTE(!m_pItfMT || m_pItfMT->IsInterface() || m_pItfMT->GetClass()->GetComClassInterfaceType() == clsIfAutoDual);
            if (m_pItfMT != NULL && m_pItfMT->IsInterface())
            {
            	// refresh oref
            	oref = ObjectFromHandle(m_com);
                if (!oref->GetTrueClass()->SupportsInterface(oref, m_pItfMT))
                {
                    DefineFullyQualifiedNameForClassW()
                    GetFullyQualifiedNameForClassW(m_pItfMT->GetClass());
                    COMPlusThrow(kInvalidCastException, IDS_EE_QIFAILEDONCOMOBJ, _wszclsname_);
                }
            }			
        }
    }

    MethodTable     *m_pClassMT;
    MethodTable     *m_pItfMT;
    BOOL             m_bDispatch;
    BOOL             m_bClassIsHint;
};

/* ------------------------------------------------------------------------- *
 * Safearray marshallers
 * ------------------------------------------------------------------------- */

// @perf: pinning, stack alloc

class SafeArrayMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = TRUE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    SafeArrayMarshaler(CleanupWorkList *pList) 
      : ReferenceMarshaler(pList) 
    {
          m_combackup = pList->NewScheduledProtectedHandle(NULL);
          m_fStatic = FALSE;
    }
    
    void SetElementMethodTable(MethodTable *pElementMT) { m_pElementMT = pElementMT; }
    void SetElementType(VARTYPE vt) { m_vt = vt; }
    void SetRank(int iRank) { m_iRank = iRank; }
    void SetNoLowerBounds(UINT8 nolowerbounds) { m_nolowerbounds = nolowerbounds; }
    
    DEFAULT_MARSHAL_OVERRIDES;

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        if (ObjectFromHandle(m_com) != NULL)
        {
            VARTYPE vt = m_vt;
            MethodTable *pElemMT = m_pElementMT;

            if (vt == VT_EMPTY)
                vt = OleVariant::GetElementVarTypeForArrayRef(*((BASEARRAYREF*) m_com));

            // Retrieve the element method table if it is not specified for the parameter.
            if (!pElemMT)
                pElemMT = OleVariant::GetArrayElementTypeWrapperAware((BASEARRAYREF*) m_com).GetMethodTable();

            m_native = (void *) 
            OleVariant::CreateSafeArrayForArrayRef((BASEARRAYREF*) m_com, 
                                                    vt,
                                                    pElemMT);
            if (m_native != NULL)
                m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
            }
        else
        {
            m_native = NULL;
        }
    }

    void ConvertSpaceNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native != NULL)
        {
            VARTYPE vt = m_vt;
            MethodTable *pElemMT = m_pElementMT;

            if (vt == VT_EMPTY)
            {
                if (FAILED(ClrSafeArrayGetVartype((SAFEARRAY*) m_native, &vt)))
                    COMPlusThrow(kArgumentException, IDS_EE_INVALID_SAFEARRAY);
            }

            if (!pElemMT && vt == VT_RECORD)
                pElemMT = OleVariant::GetElementTypeForRecordSafeArray((SAFEARRAY*) m_native).GetMethodTable();

            // If the managed array has a rank defined then make sure the rank of the
            // SafeArray matches the defined rank.
            if (m_iRank != -1)           
            {
                int iSafeArrayRank = SafeArrayGetDim((SAFEARRAY*) m_native);
                if (m_iRank != iSafeArrayRank)
                {
                    WCHAR strExpectedRank[64];
                    WCHAR strActualRank[64];
                    _ltow(m_iRank, strExpectedRank, 10);
                    _ltow(iSafeArrayRank, strActualRank, 10);
                    COMPlusThrow(kSafeArrayRankMismatchException, IDS_EE_SAFEARRAYRANKMISMATCH, strActualRank, strExpectedRank);
                }
            }

            if (m_nolowerbounds)
            {
                long lowerbound;
                if ( (SafeArrayGetDim( (SAFEARRAY*)m_native ) != 1) ||
                     (FAILED(SafeArrayGetLBound( (SAFEARRAY*)m_native, 1, &lowerbound))) ||
                     lowerbound != 0 )
                {
                    COMPlusThrow(kSafeArrayRankMismatchException, IDS_EE_SAFEARRAYSZARRAYMISMATCH);
                }
            }

            StoreObjectInHandle(m_com, 
                (OBJECTREF) OleVariant::CreateArrayRefForSafeArray((SAFEARRAY*) m_native, 
                                                                vt, 
                                                                pElemMT));
        }
        else
        {
            StoreObjectInHandle(m_com, NULL);
        }
    }

    void ConvertContentsNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native != NULL)
        {
            VARTYPE vt = m_vt;
            MethodTable *pElemMT = m_pElementMT;

            if (vt == VT_EMPTY)
            {
                if (FAILED(ClrSafeArrayGetVartype((SAFEARRAY*) m_native, &vt)))
                    COMPlusThrow(kArgumentException, IDS_EE_INVALID_SAFEARRAY);
            }

            if (!pElemMT && vt == VT_RECORD)
                pElemMT = OleVariant::GetElementTypeForRecordSafeArray((SAFEARRAY*) m_native).GetMethodTable();

            OleVariant::MarshalArrayRefForSafeArray((SAFEARRAY*)m_native, 
                                                    (BASEARRAYREF *) m_com,
                                                    vt,
                                                    pElemMT);
        }
    }

    void ConvertContentsComToNative()
    {
        if (ObjectFromHandle(m_com) != NULL)
        {
            VARTYPE vt = m_vt;
            MethodTable *pElemMT = m_pElementMT;

            if (vt == VT_EMPTY)
                vt = OleVariant::GetElementVarTypeForArrayRef(*((BASEARRAYREF*) m_com));

            // Retrieve the element method table if it is not specified for the parameter.
            if (!pElemMT)
                pElemMT = OleVariant::GetArrayElementTypeWrapperAware((BASEARRAYREF*) m_com).GetMethodTable();

            OleVariant::MarshalSafeArrayForArrayRef((BASEARRAYREF *) m_com,
                                                    (SAFEARRAY*)m_native,
                                                    vt,
                                                    pElemMT);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
        {
            Thread *pThread = GetThread();
            pThread->EnablePreemptiveGC();
            SafeArrayDestroy((SAFEARRAY*)m_native);
            pThread->DisablePreemptiveGC();
        }
    }

    void ClearNativeContents()
    {
        // @todo: not sure this does the right 
        if (m_native != NULL)
        {
            Thread *pThread = GetThread();
            pThread->EnablePreemptiveGC();
            SafeArrayDestroyData((SAFEARRAY*)m_native); 
            pThread->DisablePreemptiveGC();
        }
    }


    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (byref && !comToNative && fin && fout)
        {
            UINT16 local = pargs->m_pMLInfo->EmitCreateOpcode(psl);
            psl->MLEmit(ML_MARSHAL_SAFEARRAY_N2C_BYREF);
            pslPost->MLEmit(ML_UNMARSHAL_SAFEARRAY_N2C_BYREF_IN_OUT);
            pslPost->Emit16(local);

            return OVERRIDDEN;
        }
        return HANDLEASNORMAL;
    }

    VARTYPE         m_vt;
    MethodTable     *m_pElementMT;
    int             m_iRank;
    OBJECTHANDLE    m_combackup;   //For static arrays, must hold on to the original
    BOOL            m_fStatic;     //Is this the special case of an FADF_STATIC array?
    UINT8           m_nolowerbounds;
};


/* ------------------------------------------------------------------------- *
 * Native array marshallers
 * ------------------------------------------------------------------------- */

// @perf: pinning, stack alloc

class NativeArrayMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = TRUE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    NativeArrayMarshaler(CleanupWorkList *pList) 
      : ReferenceMarshaler(pList), m_Array()
    {
        SetBestFitMap(TRUE);
        SetThrowOnUnmappableChar(FALSE);
    }
    
    void SetElementCount(DWORD count) { m_elementCount = count; }
    void SetElementMethodTable(MethodTable *pElementMT) { m_pElementMT = pElementMT; }
    void SetElementType(VARTYPE vt) { m_vt = vt; }
    void SetBestFitMap(BOOL BestFit) { m_BestFitMap = BestFit; }
    void SetThrowOnUnmappableChar(BOOL ThrowOnUnmapChar) { m_ThrowOnUnmappableChar = ThrowOnUnmapChar; }
    

    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        BASEARRAYREF arrayRef = (BASEARRAYREF) ObjectFromHandle(m_com);

        if (arrayRef == NULL)
            m_native = NULL;
        else
        {
            SIZE_T cElements = arrayRef->GetNumComponents();
            SIZE_T cbElement = OleVariant::GetElementSizeForVarType(m_vt, m_pElementMT);

            if (cbElement == 0)
                COMPlusThrow(kArgumentException, IDS_EE_COM_UNSUPPORTED_SIG);

            SIZE_T cbArray = cElements;
            if ( (!SafeMulSIZE_T(&cbArray, cbElement)) || cbArray > 0x7ffffff0)
            {
                COMPlusThrow(kArgumentException, IDS_EE_STRUCTARRAYTOOLARGE);
            }
            

            m_native = CoTaskMemAlloc(cbArray);
            if (m_native == NULL)
                COMPlusThrowOM();
        
                // initilaize the array
            FillMemory(m_native, cbArray, 0);
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ConvertSpaceComToNativeTemp()
    {
        THROWSCOMPLUSEXCEPTION();

        BASEARRAYREF arrayRef = (BASEARRAYREF) ObjectFromHandle(m_com);

        if (arrayRef == NULL)
            m_native = NULL;
        else
        {
            UINT32 cElements = arrayRef->GetNumComponents();
            UINT32 cbElement = (UINT32)OleVariant::GetElementSizeForVarType(m_vt, m_pElementMT);

            if (cbElement == 0)
                COMPlusThrow(kArgumentException, IDS_EE_COM_UNSUPPORTED_SIG);

            SIZE_T cbArray = cElements;
            if ( (!SafeMulSIZE_T(&cbArray, cbElement)) || cbArray > 0x7ffffff0)
            {
                COMPlusThrow(kArgumentException, IDS_EE_STRUCTARRAYTOOLARGE);
            }

            m_native = GetThread()->m_MarshalAlloc.Alloc(cbArray);
            if (m_native == NULL)
                COMPlusThrowOM();
            // initilaize the array
            FillMemory(m_native, cbArray, 0);
        }
    }

    void ConvertSpaceNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            // @todo: lookup this class before marshal time
            if (m_Array.IsNull())
            {
                // Get proper array class name & type
                m_Array = OleVariant::GetArrayForVarType(m_vt, TypeHandle(m_pElementMT));
                if (m_Array.IsNull())
                    COMPlusThrow(kTypeLoadException);
            }
            //
            // Allocate array
            //
            
            StoreObjectInHandle(m_com, AllocateArrayEx(m_Array, &m_elementCount, 1));
        }
    }

    void ConvertContentsNativeToCom()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_native != NULL)
        {
            // @todo: support more VarTypes !!!
            OleVariant::Marshaler *pMarshaler = OleVariant::GetMarshalerForVarType(m_vt);

            BASEARRAYREF *pArrayRef = (BASEARRAYREF *) m_com;

            if (pMarshaler == NULL || pMarshaler->OleToComArray == NULL)
            {
                SIZE_T cElements = (*pArrayRef)->GetNumComponents();
                SIZE_T cbArray = cElements;
                if ( (!SafeMulSIZE_T(&cbArray, OleVariant::GetElementSizeForVarType(m_vt, m_pElementMT))) || cbArray > 0x7ffffff0)
                {
                    COMPlusThrow(kArgumentException, IDS_EE_STRUCTARRAYTOOLARGE);
                }


                    // If we are copying variants, strings, etc, we need to use write barrier
                _ASSERTE(!GetTypeHandleForCVType(OleVariant::GetCVTypeForVarType(m_vt)).GetMethodTable()->ContainsPointers());
                memcpyNoGCRefs((*pArrayRef)->GetDataPtr(), m_native, 
                           cbArray );
            }
            else
                pMarshaler->OleToComArray(m_native, pArrayRef, m_pElementMT);
        }
    }

    void ConvertContentsComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        BASEARRAYREF *pArrayRef = (BASEARRAYREF *) m_com;

        if (*pArrayRef != NULL)
        {
            OleVariant::Marshaler *pMarshaler = OleVariant::GetMarshalerForVarType(m_vt);

            if (pMarshaler == NULL || pMarshaler->ComToOleArray == NULL)
            {
                SIZE_T cElements = (*pArrayRef)->GetNumComponents();
                SIZE_T cbArray = cElements;
                if ( (!SafeMulSIZE_T(&cbArray, OleVariant::GetElementSizeForVarType(m_vt, m_pElementMT))) || cbArray > 0x7ffffff0)
                {
                    COMPlusThrow(kArgumentException, IDS_EE_STRUCTARRAYTOOLARGE);
                }

                _ASSERTE(!GetTypeHandleForCVType(OleVariant::GetCVTypeForVarType(m_vt)).GetMethodTable()->ContainsPointers());
                memcpyNoGCRefs(m_native, (*pArrayRef)->GetDataPtr(), 
                           cbArray);
            }

            else if (m_vt == VTHACK_ANSICHAR)
            {
                SIZE_T elementCount = (*pArrayRef)->GetNumComponents();

                const WCHAR *pCom = (const WCHAR *) (*pArrayRef)->GetDataPtr();

                DWORD flags = 0;
                BOOL DefaultCharUsed = FALSE;
          
                if (m_BestFitMap == FALSE)
                    flags = WC_NO_BEST_FIT_CHARS;

                WszWideCharToMultiByte(CP_ACP,
                                     flags,
                                     (const WCHAR *)pCom,
                                     (int)elementCount,
                                     (CHAR *)m_native,
                                     (int)(elementCount * 2),
                                     NULL,
                                     &DefaultCharUsed);
    
                if (m_ThrowOnUnmappableChar && DefaultCharUsed)
                    COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
            }

            else if (m_vt == VT_LPSTR)
            {
                ASSERT_PROTECTED(pArrayRef);

                SIZE_T elementCount = (*pArrayRef)->GetNumComponents();

                LPSTR *pOle = (LPSTR *) m_native;
                LPSTR *pOleEnd = pOle + elementCount;

                STRINGREF *pCom = (STRINGREF *) (*pArrayRef)->GetDataPtr();

                while (pOle < pOleEnd)
                {
                    //
                    // We aren't calling anything which might cause a GC, so don't worry about
                    // the array moving here.
                    //

                    STRINGREF stringRef = *pCom++;

                    LPSTR lpstr;
                    if (stringRef == NULL)
                    {
                        lpstr = NULL;
                    }
                    else 
                    {
                        // Retrieve the length of the string.
                        int Length = stringRef->GetStringLength();

                        // Allocate the string using CoTaskMemAlloc.
                        lpstr = (LPSTR)CoTaskMemAlloc(Length + 1);
                        if (lpstr == NULL)
                            COMPlusThrowOM();

                        DWORD flags = 0;
                        BOOL DefaultCharUsed = FALSE;
                  
                        if (m_BestFitMap == FALSE)
                            flags = WC_NO_BEST_FIT_CHARS;

                        // Convert the unicode string to an ansi string.
                        if (WszWideCharToMultiByte(CP_ACP, flags, stringRef->GetBuffer(), Length, lpstr, Length, NULL, &DefaultCharUsed) == 0)
                            COMPlusThrowWin32();
                        lpstr[Length] = 0;

                        if (m_ThrowOnUnmappableChar && DefaultCharUsed)
                            COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
                    }

                    *pOle++ = lpstr;
                }
            }

            else
                pMarshaler->ComToOleArray(pArrayRef, m_native, m_pElementMT);
        }
    }

    void ClearNative()
    { 
        if (m_native != NULL)
        {
            ClearNativeContents();
            CoTaskMemFree(m_native);
        }
    }

    void ClearNativeTemp()
    { 
        if (m_native != NULL)
            ClearNativeContents();
    }

    void ClearNativeContents()
    {
        if (m_native != NULL)
        {
            OleVariant::Marshaler *pMarshaler = OleVariant::GetMarshalerForVarType(m_vt);

            // @todo: can we assume this is always valid???
            BASEARRAYREF *pArrayRef = (BASEARRAYREF *) m_com;

            if (pMarshaler != NULL && pMarshaler->ClearOleArray != NULL)
            {
                SIZE_T cElements = (*pArrayRef)->GetNumComponents();

                pMarshaler->ClearOleArray(m_native, cElements, m_pElementMT);
            }
        }
    }

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {

        VARTYPE vt = pargs->na.m_vt;

        if (vt == VTHACK_ANSICHAR && (byref || !comToNative))
        {
            *pResID = IDS_EE_BADPINVOKE_CHARARRAYRESTRICTION;
            return DISALLOWED;
        }

        if ( (!byref) && comToNative && NULL == OleVariant::GetMarshalerForVarType(vt) )
        {
            const BOOL fTouchPinnedObjects = 
#ifdef TOUCH_ALL_PINNED_OBJECT
TRUE;
#else
FALSE;
#endif
            if ((!fTouchPinnedObjects) && pargs->na.m_optionalbaseoffset != 0)
            {
                psl->MLEmit(ML_PINNEDISOMORPHICARRAY_C2N_EXPRESS);
                psl->Emit16(pargs->na.m_optionalbaseoffset);
            }
            else
            {
    
                psl->MLEmit(ML_PINNEDISOMORPHICARRAY_C2N);
                if (vt == VTHACK_BLITTABLERECORD)
                {
                    psl->Emit16( (UINT16)(pargs->na.m_pMT->GetNativeSize()) );
                }
                else
                {
                    psl->Emit16( (UINT16)(OleVariant::GetElementSizeForVarType(vt, pargs->na.m_pMT)) );
                }
            }
            return OVERRIDDEN;
        }


        //if ( (!byref) && !comToNative && NULL == OleVariant::GetMarshalerForVarType(vt) )
        //{
        //    psl->MLEmit(sizeof(LPVOID) == 4 ? ML_COPY4 : ML_COPY8);
        //    return OVERRIDDEN;
        //}



        return HANDLEASNORMAL;
    }

    BOOL                    m_BestFitMap;
    BOOL                    m_ThrowOnUnmappableChar;
    VARTYPE                 m_vt;
    MethodTable            *m_pElementMT;
    TypeHandle              m_Array;
    DWORD                   m_elementCount;
    
};





















/* ------------------------------------------------------------------------- *
 * AsAnyAArray marshaller (implements the PIS "asany" - Ansi mode)
 * ------------------------------------------------------------------------- */
class AsAnyAMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = TRUE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    AsAnyAMarshaler(CleanupWorkList *pList) 
      : ReferenceMarshaler(pList) {}
    
    
    DEFAULT_MARSHAL_OVERRIDES;


    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref)
        {
            psl->MLEmit(ML_OBJECT_C2N);
            psl->Emit8( (fin ? ML_IN : 0) | (fout ? ML_OUT : 0) );
            psl->Emit8(pargs->m_pMLInfo->GetBestFitMapping());
            psl->Emit8(pargs->m_pMLInfo->GetThrowOnUnmappableChar());
            psl->Emit8(1 /*isansi*/);
            pslPost->MLEmit(ML_OBJECT_C2N_POST);
            pslPost->Emit16(psl->MLNewLocal(SizeOfML_OBJECT_C2N_SR()));
            return OVERRIDDEN;
        }
        else
        {
            *pResID = IDS_EE_BADPINVOKE_ASANYRESTRICTION;
            return DISALLOWED;
        }
    }
};






/* ------------------------------------------------------------------------- *
 * AsAnyWArray marshaller (implements the PIS "asany" - Unicode mode)
 * ------------------------------------------------------------------------- */
class AsAnyWMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = TRUE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    AsAnyWMarshaler(CleanupWorkList *pList) 
      : ReferenceMarshaler(pList) {}
    
    
    DEFAULT_MARSHAL_OVERRIDES;


    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref)
        {
            psl->MLEmit(ML_OBJECT_C2N);
            psl->Emit8( (fin ? ML_IN : 0) | (fout ? ML_OUT : 0) );
            psl->Emit8(pargs->m_pMLInfo->GetBestFitMapping());
            psl->Emit8(pargs->m_pMLInfo->GetThrowOnUnmappableChar());
            psl->Emit8(0 /* !isansi */);
            pslPost->MLEmit(ML_OBJECT_C2N_POST);
            pslPost->Emit16(psl->MLNewLocal(SizeOfML_OBJECT_C2N_SR()));
            return OVERRIDDEN;
        }
        else
        {
            *pResID = IDS_EE_BADPINVOKE_ASANYRESTRICTION;
            return DISALLOWED;
        }
    }
};






/* ------------------------------------------------------------------------- *
 * Delegate marshaller
 * ------------------------------------------------------------------------- */

class DelegateMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = FALSE,

        c_fInOnly = TRUE,
    };

    DelegateMarshaler(CleanupWorkList *pList) 
      : ReferenceMarshaler(pList) {}
    

    DEFAULT_MARSHAL_OVERRIDES;


    void ConvertSpaceComToNative()
    {
        OBJECTREF objectRef = ObjectFromHandle(m_com);

        if (objectRef == NULL)
            m_native = NULL;
        else
            m_native = (void*) COMDelegate::ConvertToCallback(objectRef);
    }

    void ConvertSpaceNativeToCom()
    {
        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
            StoreObjectInHandle(m_com, COMDelegate::ConvertToDelegate(m_native));
    }

};














class BlittablePtrMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    BlittablePtrMarshaler(CleanupWorkList *pList, MethodTable *pMT) : ReferenceMarshaler(pList) { m_pMT = pMT; }

    FAST_ALLOC_MARSHAL_OVERRIDES;
    
    void ConvertSpaceNativeToCom()
    {
        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            StoreObjectInHandle(m_com, AllocateObject(m_pMT));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        OBJECTREF or = ObjectFromHandle(m_com);

        if (or == NULL)
            m_native = NULL;
        else
        {
            m_native = CoTaskMemAlloc(m_pMT->GetNativeSize());
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
            CoTaskMemFree(m_native);
    }

    void ConvertSpaceComToNativeTemp()
    {
        OBJECTREF or = ObjectFromHandle(m_com);

        if (or == NULL)
            m_native = NULL;
        else
            m_native = GetThread()->m_MarshalAlloc.Alloc(m_pMT->GetNativeSize());
    }

    void ClearNativeTemp() 
    { 
    }

    void ConvertContentsNativeToCom()
    {
        if (m_native != NULL)
        {
            OBJECTREF or = ObjectFromHandle(m_com);
            _ASSERTE(!m_pMT->ContainsPointers());

            memcpyNoGCRefs(or->GetData(), m_native, m_pMT->GetNativeSize());
        }
    }

    void ConvertContentsComToNative()
    {
        OBJECTREF or = ObjectFromHandle(m_com);

        _ASSERTE(!m_pMT->ContainsPointers());
        if (or != NULL)
        {
            memcpyNoGCRefs(m_native, or->GetData(), m_pMT->GetNativeSize());
        }
    }


    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref /*isomorphic so no need to check in/out */)
        {
            psl->MLEmit(ML_BLITTABLELAYOUTCLASS_C2N);
            return OVERRIDDEN;
        }
        else
        {
            return HANDLEASNORMAL;
        }

    }



  private:
    MethodTable *m_pMT;  //method table


};







class VBByValStrMarshaler : public Marshaler
{
  public:
    enum
    {
        c_nativeSize = sizeof(LPSTR),
        c_comSize = sizeof(OBJECTREF*),
        c_fReturnsNativeByref = FALSE,
        c_fReturnsComByref = FALSE,
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = TRUE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };
        
    VBByValStrMarshaler(CleanupWorkList *pList); 

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && byref && fin && fout)
        {
            psl->MLEmit(ML_VBBYVALSTR);
            psl->Emit8(pargs->m_pMLInfo->GetBestFitMapping());
            psl->Emit8(pargs->m_pMLInfo->GetThrowOnUnmappableChar());
            pslPost->MLEmit(ML_VBBYVALSTR_POST);
            pslPost->Emit16(psl->MLNewLocal(sizeof(ML_VBBYVALSTR_SR)));
            return OVERRIDDEN;
        }
        else
        {
            *pResID = IDS_EE_BADPINVOKE_VBBYVALSTRRESTRICTION;
            return DISALLOWED;
        }
    }

};




class VBByValStrWMarshaler : public Marshaler
{
  public:
    enum
    {
        c_nativeSize = sizeof(BSTR),
        c_comSize = sizeof(OBJECTREF*),
        c_fReturnsNativeByref = FALSE,
        c_fReturnsComByref = FALSE,
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = TRUE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };
        
    VBByValStrWMarshaler(CleanupWorkList *pList); 

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && byref && fin && fout)
        {
            psl->MLEmit(ML_VBBYVALSTRW);
            pslPost->MLEmit(ML_VBBYVALSTRW_POST);
            pslPost->Emit16(psl->MLNewLocal(sizeof(ML_VBBYVALSTRW_SR)));
            return OVERRIDDEN;
        }
        else
        {
            *pResID = IDS_EE_BADPINVOKE_VBBYVALSTRRESTRICTION;
            return DISALLOWED;
        }
    }

};










class LayoutClassPtrMarshaler : public ReferenceMarshaler
{
  public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = TRUE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };

    LayoutClassPtrMarshaler(CleanupWorkList *pList, MethodTable *pMT) : ReferenceMarshaler(pList) { m_pMT = pMT; }


    FAST_ALLOC_MARSHAL_OVERRIDES;

    void ConvertSpaceNativeToCom()
    {
        if (m_native == NULL)
            StoreObjectInHandle(m_com, NULL);
        else
        {
            StoreObjectInHandle(m_com, AllocateObject(m_pMT));
        }
    }

    void ConvertSpaceComToNative()
    {
        THROWSCOMPLUSEXCEPTION();

        OBJECTREF or = ObjectFromHandle(m_com);

        if (or == NULL)
            m_native = NULL;
        else
        {
            m_native = CoTaskMemAlloc(m_pMT->GetNativeSize());
            if (m_native == NULL)
                COMPlusThrowOM();
            m_pMarshalerCleanupNode = m_pList->ScheduleMarshalerCleanupOnException(this);
        }
    }

    void ClearNative() 
    { 
        if (m_native != NULL)
        {
            LayoutDestroyNative(m_native, m_pMT->GetClass());
            CoTaskMemFree(m_native);
        }
    }

    void ConvertSpaceComToNativeTemp()
    {
        OBJECTREF or = ObjectFromHandle(m_com);

        if (or == NULL)
            m_native = NULL;
        else
            m_native = GetThread()->m_MarshalAlloc.Alloc(m_pMT->GetNativeSize());
    }

    void ClearNativeTemp() 
    { 
        if (m_native != NULL)
            LayoutDestroyNative(m_native, m_pMT->GetClass());
    }

    void ConvertContentsNativeToCom()
    {
        if (m_native != NULL)
        {
            FmtClassUpdateComPlus( (OBJECTREF*)m_com, (LPBYTE)m_native, FALSE );
            //            LayoutUpdateComPlus( (LPVOID*)m_com, Object::GetOffsetOfFirstField(), m_pMT->GetClass(), (LPBYTE)m_native, NULL);
        }
    }

    void ConvertContentsComToNative()
    {
        OBJECTREF or = ObjectFromHandle(m_com);

        if (or != NULL)
        {
            FillMemory(m_native, m_pMT->GetNativeSize(), 0); //Gotta do this first so an error halfway thru doesn't leave things in a bad state.
            FmtClassUpdateNative( (OBJECTREF*)m_com, (LPBYTE)m_native);
            //LayoutUpdateNative( (LPVOID*)m_com, Object::GetOffsetOfFirstField(), m_pMT->GetClass(), (LPBYTE)m_native, FALSE);
        }
    }


    void ClearNativeContents()
    {
        if (m_native != NULL)
        {
            LayoutDestroyNative(m_native, m_pMT->GetClass());
        }
    }




  private:
    MethodTable *m_pMT;  //method table


};


class ArrayWithOffsetMarshaler : public Marshaler
{
  public:
    enum
    {
        c_nativeSize = sizeof(LPVOID),
        c_comSize = sizeof(ArrayWithOffsetData),
        c_fReturnsNativeByref = FALSE,
        c_fReturnsComByref = FALSE,
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = TRUE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };
        
    ArrayWithOffsetMarshaler(CleanupWorkList *pList); 

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref && fin && fout)
        {
            psl->MLEmit(ML_ARRAYWITHOFFSET_C2N);
            pslPost->MLEmit(ML_ARRAYWITHOFFSET_C2N_POST);
            pslPost->Emit16(psl->MLNewLocal(sizeof(ML_ARRAYWITHOFFSET_C2N_SR)));
            return OVERRIDDEN;
        }
        else
        {
            *pResID = IDS_EE_BADPINVOKE_AWORESTRICTION;
            return DISALLOWED;
        }
    }

};



class BlittableValueClassMarshaler : public Marshaler
{
  public:
    enum
    {
        c_nativeSize = VARIABLESIZE,
        c_comSize = VARIABLESIZE,
        c_fReturnsNativeByref = FALSE,
        c_fReturnsComByref = FALSE,
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = FALSE,

        c_fInOnly = TRUE,
    };
        
    BlittableValueClassMarshaler(CleanupWorkList *pList); 

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref && fin && !fout)
        {
            psl->MLEmit(ML_BLITTABLEVALUECLASS_C2N);
            psl->Emit32(pargs->m_pMT->GetNativeSize());
            return OVERRIDDEN;
        }
        else if (comToNative && byref)
        {
#ifdef TOUCH_ALL_PINNED_OBJECTS
            psl->MLEmit(ML_REFBLITTABLEVALUECLASS_C2N);
            psl->Emit32(pargs->m_pMT->GetNativeSize());
#else
            psl->MLEmit(ML_COPYPINNEDGCREF);
#endif
            return OVERRIDDEN;
        }
        else if (!comToNative && !byref && fin && !fout)
        {
            psl->MLEmit(ML_BLITTABLEVALUECLASS_N2C);
            psl->Emit32(pargs->m_pMT->GetNativeSize());
            return OVERRIDDEN;
        }
        else if (!comToNative && byref)
        {
            psl->MLEmit( sizeof(LPVOID) == 4 ? ML_COPY4 : ML_COPY8);
            return OVERRIDDEN;
        }
        else
        {
            *pResID = IDS_EE_BADPINVOKE_BVCRESTRICTION;
            return DISALLOWED;
        }
    }

};



class BlittableValueClassWithCopyCtorMarshaler : public Marshaler
{
  public:
    enum
    {
        c_nativeSize = VARIABLESIZE,
        c_comSize = sizeof(OBJECTREF),
        c_fReturnsNativeByref = FALSE,
        c_fReturnsComByref = FALSE,
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = FALSE,

        c_fInOnly = TRUE,
    };
        
    BlittableValueClassWithCopyCtorMarshaler(CleanupWorkList *pList); 

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (!byref && comToNative) {
            psl->MLEmit(ML_COPYCTOR_C2N);
            psl->EmitPtr(pargs->mm.m_pMT);
            psl->EmitPtr(pargs->mm.m_pCopyCtor);
            psl->EmitPtr(pargs->mm.m_pDtor);
            return OVERRIDDEN;
        } else  if (!byref && !comToNative) {
            psl->MLEmit(ML_COPYCTOR_N2C);
            psl->EmitPtr(pargs->mm.m_pMT);
            return OVERRIDDEN;
        } else {
            *pResID = IDS_EE_BADPINVOKE_COPYCTORRESTRICTION;
            return DISALLOWED;
        }
    }

};





class ValueClassMarshaler : public Marshaler
{
  public:
    enum
    {
        c_nativeSize = VARIABLESIZE,
        c_comSize = VARIABLESIZE,
        c_fReturnsNativeByref = FALSE,
        c_fReturnsComByref = FALSE,
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = FALSE,

        c_fInOnly = TRUE,
    };
        
    ValueClassMarshaler(CleanupWorkList *pList); 

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref && fin && !fout)
        {
            psl->MLEmit(ML_VALUECLASS_C2N);
            psl->EmitPtr(pargs->m_pMT);
            return OVERRIDDEN;
        }
        else if (comToNative && byref)
        {
            psl->MLEmit(ML_REFVALUECLASS_C2N);
            psl->Emit8( (fin ? ML_IN : 0) | (fout ? ML_OUT : 0) );
            psl->EmitPtr(pargs->m_pMT);
            pslPost->MLEmit(ML_REFVALUECLASS_C2N_POST);
            pslPost->Emit16(psl->MLNewLocal(sizeof(ML_REFVALUECLASS_C2N_SR)));
            return OVERRIDDEN;
        }
        else if (!comToNative && !byref && fin && !fout)
        {
            psl->MLEmit(ML_VALUECLASS_N2C);
            psl->EmitPtr(pargs->m_pMT);
            return OVERRIDDEN;
        }
        else if (!comToNative && byref)
        {
            psl->MLEmit(ML_REFVALUECLASS_N2C);
            psl->Emit8( (fin ? ML_IN : 0) | (fout ? ML_OUT : 0) );
            psl->EmitPtr(pargs->m_pMT);
            pslPost->MLEmit(ML_REFVALUECLASS_N2C_POST);
            pslPost->Emit16(psl->MLNewLocal(sizeof(ML_REFVALUECLASS_N2C_SR)));
            return OVERRIDDEN;
        }
        else
        {
            *pResID = IDS_EE_BADPINVOKE_VCRESTRICTION;

            return DISALLOWED;
        }
    }

};


/* ------------------------------------------------------------------------- *
 * Custom Marshaler.
 * ------------------------------------------------------------------------- */

class CustomMarshaler : public Marshaler
{
public:
    enum
    {
        c_fNeedsClearNative = TRUE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = TRUE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,
        c_fComRepresentationIsImmutable = FALSE,
        c_fReturnsNativeByref = FALSE,              // ?
        c_fReturnsComByref = FALSE,                 // ?
        c_fInOnly = FALSE,
    };
        
    CustomMarshaler(CleanupWorkList *pList, CustomMarshalerHelper *pCMHelper) 
    : Marshaler(pList, pCMHelper->GetNativeSize(), pCMHelper->GetManagedSize(), c_fReturnsNativeByref, c_fReturnsComByref)
    , m_ppCom(pList->NewProtectedObjectRef(NULL))
    , m_pNative(NULL)
    , m_pCMHelper(pCMHelper) {}

    void InputDest(void *pStack)
    {
        m_pDest = pStack;
    }

    void ConvertContentsNativeToCom()
    {
        *m_ppCom = m_pCMHelper->InvokeMarshalNativeToManagedMeth(m_pNative);
    }

    void ConvertContentsComToNative()
    {
        _ASSERTE(m_ppCom);
        OBJECTREF Obj = *m_ppCom;
        m_pNative = m_pCMHelper->InvokeMarshalManagedToNativeMeth(Obj);
    }

    void ClearNative() 
    { 
        m_pCMHelper->InvokeCleanUpNativeMeth(m_pNative);
    }

    void ClearCom() 
    { 
        OBJECTREF Obj = *m_ppCom;
        m_pCMHelper->InvokeCleanUpManagedMeth(Obj);
    }

    void ReInitNative()
    {
        m_pNative = NULL;
    }

    OBJECTREF               *m_ppCom;
    void                    *m_pNative;
    CustomMarshalerHelper   *m_pCMHelper;
};



//@todo: This marshaler has the same write-barrier hole as the
// ReferenceMarshaler - fix it the same way.
class ReferenceCustomMarshaler : public CustomMarshaler
{
public:       
    enum
    {
        c_nativeSize = sizeof(OBJECTREF),
        c_comSize = sizeof(void *),
    };

    ReferenceCustomMarshaler(CleanupWorkList *pList, CustomMarshalerHelper *pCMHelper) 
    : CustomMarshaler(pList, pCMHelper) {}

    DEFAULT_MARSHAL_OVERRIDES;

    void InputNativeStack(void *pStack)
    {
        m_pNative = *(void**)pStack;
    }

    void InputComStack(void *pStack) 
    {
        *m_ppCom = ObjectToOBJECTREF(*(Object**)pStack);
    }

    void InputNativeRef(void *pStack) 
    { 
        m_pNative = **(void ***)pStack; 
    }

    void InputComRef(void *pStack) 
    {
        *m_ppCom = ObjectToOBJECTREF(**(Object ***)pStack);
    }

    void OutputNativeStack(void *pStack) 
    { 
        *(void **)pStack = m_pNative; 
    }

    void OutputComStack(void *pStack) 
    { 
        *(OBJECTREF*)pStack = *m_ppCom;
    }

    void OutputNativeRef(void *pStack) 
    { 
        *(void **)pStack = &m_pNative;
    }

    void OutputComRef(void *pStack) 
    { 
        *(OBJECTREF**)pStack = m_ppCom;
    }

    void OutputNativeDest() 
    { 
        **(void ***)m_pDest = m_pNative; 
    }

    void OutputComDest() 
    { 
        SetObjectReferenceUnchecked(*(OBJECTREF**)m_pDest, *m_ppCom);
    }

    void InputComField(void *pField) 
    {
        *m_ppCom = ObjectToOBJECTREF(*(Object**)pField); 
    }

    void OutputComField(void *pField) 
    { 
        SetObjectReferenceUnchecked((OBJECTREF*)pField, *m_ppCom);
    }
};


class ValueClassCustomMarshaler : public CustomMarshaler
{
public:
    enum
    {
        c_nativeSize = VARIABLESIZE,
        c_comSize = VARIABLESIZE,
    };

    ValueClassCustomMarshaler(CleanupWorkList *pList, CustomMarshalerHelper *pCMHelper) 
    : CustomMarshaler(pList, pCMHelper) {}

    DEFAULT_MARSHAL_OVERRIDES;

    void InputNativeStack(void *pStack)
    {
        m_pNative = pStack;
    }

    void InputComStack(void *pStack) 
    { 
        // @TODO(DM): Box the value class and store the object in the handle.
        _ASSERTE(!"Value classes are not yet supported by the custom marshaler!");
    }

    void InputNativeRef(void *pStack) 
    { 
        m_pNative = *(void**)pStack; 
    }

    void InputComRef(void *pStack) 
    { 
        // @TODO(DM): Box the value class and store the object in the handle.
        _ASSERTE(!"Value classes are not yet supported by the custom marshaler!");
    }

    void OutputNativeStack(void *pStack) 
    { 
        memcpy(pStack, m_pNative, m_pCMHelper->GetNativeSize());
    }

    void OutputComStack(void *pStack) 
    { 
        // @TODO(DM): UnBox the value class and copy the unboxed contents back unto the stack.
        _ASSERTE(!"Value classes are not yet supported by the custom marshaler!");
    }

    void OutputNativeRef(void *pStack) 
    { 
        *(void **)m_pDest = &m_pNative; 
    }

    void OutputComRef(void *pStack) 
    { 
        // @TODO(DM): UnBox the value class and copy the unboxed contents back unto the stack.
        _ASSERTE(!"Value classes are not yet supported by the custom marshaler!");
    }

    void OutputNativeDest() 
    { 
        memcpy(m_pDest, m_pNative, m_pCMHelper->GetNativeSize());
    }

    void OutputComDest() 
    { 
        // @TODO(DM): UnBox the value class and copy the unboxed contents back unto the stack.
        _ASSERTE(!"Value classes are not yet supported by the custom marshaler!");
    }

    void InputComField(void *pField) 
    { 
        // @TODO(DM): Box the value class and store the object in the handle.
        _ASSERTE(!"Value classes are not yet supported by the custom marshaler!");
    }

    void OutputComField(void *pField) 
    { 
        // @TODO(DM): UnBox the value class and copy the unboxed contents into pField.
        _ASSERTE(!"Value classes are not yet supported by the custom marshaler!");
    }
};




/* ------------------------------------------------------------------------- *
 * ArgIterator marshaller
 * ------------------------------------------------------------------------- */

class ArgIteratorMarshaler : public StandardMarshaler<va_list, VARARGS*, TRUE, TRUE>
{
  public:
        
    enum
    {
        c_comSize = sizeof(VARARGS),
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,


        c_fInOnly = TRUE,
    };

    ArgIteratorMarshaler(CleanupWorkList *pList) 
      : StandardMarshaler<va_list, VARARGS*, TRUE, TRUE>(pList)
      {
      }
    
    DEFAULT_MARSHAL_OVERRIDES;



    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref)
        {
            psl->MLEmit(ML_ARGITERATOR_C2N);
            return OVERRIDDEN;
        }
        else if (!comToNative && !byref)
        {
            psl->MLEmit(ML_ARGITERATOR_N2C);
            return OVERRIDDEN;
        }
        else
        {
            *pResID = IDS_EE_BADPINVOKE_ARGITERATORRESTRICTION;
            return DISALLOWED;
        }

    }

};




/* ------------------------------------------------------------------------- *
 * HandleRef marshaller
 * ------------------------------------------------------------------------- */
class HandleRefMarshaler : public Marshaler
{
  public:
    enum
    {
        c_nativeSize = sizeof(LPVOID),
        c_comSize = sizeof(HANDLEREF),
        c_fReturnsNativeByref = FALSE,
        c_fReturnsComByref = FALSE,
        c_fNeedsClearNative = FALSE,
        c_fNeedsClearNativeContents = FALSE,
        c_fNeedsClearCom = FALSE,
        c_fNeedsClearComContents = FALSE,
        c_fNeedsConvertContents = TRUE,

        c_fInOnly = FALSE,
    };
        
    HandleRefMarshaler(CleanupWorkList *pList); 

    static ArgumentMLOverrideStatus ArgumentMLOverride(MLStubLinker *psl,
                                                       MLStubLinker *pslPost,
                                                       BOOL        byref,
                                                       BOOL        fin,
                                                       BOOL        fout,
                                                       BOOL        comToNative,
                                                       MLOverrideArgs *pargs,
                                                       UINT       *pResID)
    {
        if (comToNative && !byref)
        {
            psl->MLEmit(ML_HANDLEREF_C2N);
            return OVERRIDDEN;
        }
        else
        {
            *pResID = IDS_EE_BADPINVOKE_HANDLEREFRESTRICTION;
            return DISALLOWED;
        }
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\memorypool.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"

#include "memorypool.h"

void MemoryPool::AddBlock(SIZE_T elementCount)
{
	//
	// Allocate the new block.
	//

	Block *block = (Block *) new BYTE [sizeof(Block) + elementCount*m_elementSize];
	if (block == NULL)
		return;

	//
	// Chain all elements together for the free list
	//

	_ASSERTE(m_freeList == NULL);
	Element **prev = &m_freeList;

	Element *e = block->elements;
	Element *eEnd = (Element *) ((BYTE*) block->elements + elementCount*m_elementSize);
	while (e < eEnd)
	{
		*prev = e;
		prev = &e->next;
#if _DEBUG
		DeadBeef(e);
#endif
		e = (Element*) ((BYTE*)e + m_elementSize);
	}

	*prev = NULL;

	//
	// Initialize the other block fields & link the block into the block list
	//

	block->elementsEnd = e;
	block->next = m_blocks;
	m_blocks = block;
}

void MemoryPool::DeadBeef(Element *element)
{
#if _DEBUG
	int *i = &element->deadBeef;
	int *iEnd = (int*) ((BYTE*)element + m_elementSize);
	while (i < iEnd)
		*i++ = 0xdeadbeef;
#endif
}

MemoryPool::MemoryPool(SIZE_T elementSize, SIZE_T initGrowth, SIZE_T initCount)
  : m_elementSize(elementSize),
	m_growCount(initGrowth),
	m_blocks(NULL),
	m_freeList(NULL)
{
	_ASSERTE(elementSize >= sizeof(Element));
	_ASSERTE((elementSize & 0x3) == 0);

	if (initCount > 0)
		AddBlock(initCount);
}

MemoryPool::~MemoryPool()
{
	Block *block = m_blocks;
	while (block != NULL)
	{
		Block *next = block->next;
		delete [] block;
		block = next;
	}
}

BOOL MemoryPool::IsElement(void *element)
{
	Block *block = m_blocks;
	while (block != NULL)
	{
		if (element >= block->elements
			&& element < block->elementsEnd)
		{
			return ((BYTE *)element - (BYTE*)block->elements) % m_elementSize == 0;
		}
		block = block->next;
	}

	return FALSE;
}

BOOL MemoryPool::IsAllocatedElement(void *element)
{
	if (!IsElement(element))
		return FALSE;

	//
	// Now, make sure the element isn't
	// in the free list.
	//

#if _DEBUG
	//
	// In a debug build, all objects on the free list
	// will be marked with deadbeef.  This means that 
	// if the object is not deadbeef, it's not on the
	// free list.
	//
	// This check will give us decent performance in
	// a debug build for FreeElement, since we 
	// always expect to return TRUE in that case.
	//

	if (((Element*)element)->deadBeef != 0xdeadBeef)
		return TRUE;
#endif

	Element *f = m_freeList;
	while (f != NULL)
	{
		if (f == element)
			return FALSE;
		f = f->next;
	}

#if _DEBUG
	//
	// We should never get here in a debug build, because
	// all free elements should be deadbeefed.
	//
	_ASSERTE(0);
#endif

	return TRUE;
}

void *MemoryPool::AllocateElement()
{
	void *element = m_freeList;

	if (element == NULL)
	{
		AddBlock(m_growCount);
		element = m_freeList;
		if (element == NULL)
			return NULL;

		//
		// @todo: we may want to grow m_growCount here, 
		// to keep the number of blocks from growing linearly.
		// (this could reduce the performance of IsElement.)
		//
	}

	m_freeList = m_freeList->next;

	return element;
}

void MemoryPool::FreeElement(void *element)
{
#if _DEBUG // don't want to do this assert in a non-debug build; it is expensive
	_ASSERTE(IsAllocatedElement(element));
#endif

	Element *e = (Element *) element;

#if _DEBUG
	DeadBeef(e);
#endif

	e->next = m_freeList;
	m_freeList = e;
}

void MemoryPool::FreeAllElements()
{
	Block *block = m_blocks;
	while (block != NULL)
	{
		Block *next = block->next;
		delete [] block;
		block = next;
	}

	m_freeList = NULL;
	m_blocks = NULL;
}

MemoryPool::Iterator::Iterator(MemoryPool *pool)
{
	//
	// Warning!  This only works if you haven't freed
	// any elements.
	//

	m_next = pool->m_blocks;
	m_e = NULL;
	m_eEnd = NULL;
	m_end = (BYTE*) pool->m_freeList;
	m_size = pool->m_elementSize;
}

BOOL MemoryPool::Iterator::Next()
{
	if (m_e == m_eEnd
		|| (m_e == m_end && m_end != NULL))
	{
		if (m_next == NULL)
			return FALSE;
		m_e = (BYTE*) m_next->elements;
		m_eEnd = (BYTE*) m_next->elementsEnd;
		m_next = m_next->next;
		if (m_e == m_end)
			return FALSE;
	}

	m_e += m_size;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\metasig.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// METASIG.H -
//
// All literal MetaData signatures must be defined here.
// This is because the MetaData signature format will change
// from a literal string format to a byte array format
// on M3 (hah!). By keeping all metadata sigs in one file, we make
// the switchover easier.


#ifndef __METASIG_H__
#define __METASIG_H__

typedef struct HardCodedMetaSig *LPHARDCODEDMETASIG;

#include "crst.h"

struct HardCodedMetaSig {

        LPCUTF8         m_ObsoleteForm;
        const USHORT    *m_pParameters;
        BOOL            m_fConverted;
        PCCOR_SIGNATURE m_pBinarySig;
        ULONG           m_cbBinarySigLength;


        // Do a one-time conversion to binary form.
        HRESULT GetBinaryForm(PCCOR_SIGNATURE *ppBinarySig, ULONG *pcbBinarySigLength);


        // These versions throw COM+ exceptions
        PCCOR_SIGNATURE GetBinarySig();
        ULONG       GetBinarySigLength();

        // This always returns mscorlib's internal interface.
        IMDInternalImport* GetMDImport();

        // This returns mscorlib's module.
        Module* GetModule();

        static Crst *m_pCrst;
        static BYTE  m_CrstMemory[sizeof(Crst)];

        static BOOL Init();
#ifdef SHOULD_WE_CLEANUP
        static VOID Terminate();
#endif /* SHOULD_WE_CLEANUP */

#ifdef SHOULD_WE_CLEANUP
        static void Reinitialize();
#endif /* SHOULD_WE_CLEANUP */


};

#endif  //__METASIG_H__

// Generic sig's based on types.

// All sigs are alphabetized by the signature string and given a canonical name.  Do not
// give them "meaningful" names because we want to share them aggressively.  Do not add
// duplicates!

// The canonical form:
//
//   gsig_<what>_<types>
//
//   where <what> is:
//
//      -- Fld  -- explicitly a field
//   !  -- IM   -- used as a prefix to indicate an instance method (HASTHIS == TRUE)
//   <  --      -- implicitly a function (begin)
//   >  --      -- implicitly a function (end)
//      -- SM   -- static method
//
//   and <type> is:
//
//   a  -- Arr  -- array
//   P  -- Ptr  -- a pointer
//   r  -- Ref  -- a byref
//         Ret  -- indicates function return type
//
//         PMS  -- LPermissionSet;
//         Var  -- lSystem.Variant;
//
//   b  -- Byte -- (unsigned) byte
//   c  -- Char -- character (2 byte unsigned unicode)
//   d  -- Dbl  -- double
//   f  -- Flt  -- float
//   i  -- Int  -- integer
//   K  -- UInt  -- unsigned integer
//   I  -- IntPtr -- agnostic integer
//   U  -- UIntPtr -- agnostic unsigned integer
//   l  -- Long -- long integer
//   L  -- ULong -- unsigned long integer
//   e  --      -- ELEMENT_TYPE_TYPEDBYREF (as opposed to LSystem.TypedByRef)
//   h  -- Shrt -- short integer
//   H  -- UShrt -- unsigned short integer
//   v  -- Void -- Void
//   B  -- Sbyt -- signed byte
//   F  -- Bool -- boolean
//   j  -- Obj  -- System.Object
//   s  -- Str  -- System.String 
//   C  --      -- 
//   g  --      -- 
//   p  --      -- 
//

// Ignore the macros if we don't define them

#ifndef DEFINE_METASIG
#define DEFINE_METASIG(n,s)
#endif

#ifndef DEFINE_METASIG_PARAMS_1
#define DEFINE_METASIG_PARAMS_1(n,a1)
#endif

#ifndef DEFINE_METASIG_PARAMS_2
#define DEFINE_METASIG_PARAMS_2(n,a1,a2)
#endif

#ifndef DEFINE_METASIG_PARAMS_3
#define DEFINE_METASIG_PARAMS_3(n,a1,a2,a3)
#endif

#ifndef DEFINE_METASIG_PARAMS_4
#define DEFINE_METASIG_PARAMS_4(n,a1,a2,a3,a4)
#endif

#ifndef DEFINE_METASIG_PARAMS_5
#define DEFINE_METASIG_PARAMS_5(n,a1,a2,a3,a4,a5)
#endif

#ifndef DEFINE_METASIG_PARAMS_6
#define DEFINE_METASIG_PARAMS_6(n,a1,a2,a3,a4,a5,a6)
#endif


// Ignore type parameter if we don't care about it

#if defined(DEFINE_METASIG) && !defined(DEFINE_METASIG_T)
#define DEFINE_METASIG_T(n,s,t) DEFINE_METASIG(n,s)
#endif


// static methods:

DEFINE_METASIG(SM_Flt_RetFlt,                          "<f>f")
DEFINE_METASIG(SM_Dbl_RetDbl,                          "<d>d")
DEFINE_METASIG(SM_RefByte_RetByte,                     "<rb>b")
DEFINE_METASIG(SM_RefByte_Byte_RetVoid,                "<rbb>v")
DEFINE_METASIG(SM_RefShrt_RetShrt,                     "<rh>h")
DEFINE_METASIG(SM_RefShrt_Shrt_RetVoid,                "<rhh>v")
DEFINE_METASIG(SM_RefUShrt_RetUShrt,                   "<rH>H")
DEFINE_METASIG(SM_RefUShrt_UShrt_RetVoid,              "<rHH>v")
DEFINE_METASIG(SM_RefInt_RetInt,                       "<ri>i")
DEFINE_METASIG(SM_RefInt_Int_RetVoid,                  "<rii>v")
DEFINE_METASIG(SM_RefUInt_RetUInt,                     "<rK>K")
DEFINE_METASIG(SM_RefUInt_UInt_RetVoid,                "<rKK>v")
DEFINE_METASIG(SM_RefLong_RetLong,                     "<rl>l")
DEFINE_METASIG(SM_RefLong_Long_RetVoid,                "<rll>v")
DEFINE_METASIG(SM_RefULong_RetULong,                   "<rL>L")
DEFINE_METASIG(SM_RefULong_ULong_RetVoid,              "<rLL>v")
DEFINE_METASIG(SM_RefSByt_RetSByt,                     "<rB>B")
DEFINE_METASIG(SM_RefSByt_SByt_RetVoid,                "<rBB>v")
DEFINE_METASIG(SM_RefIntPtr_RetIntPtr,                 "<rI>I")
DEFINE_METASIG(SM_RefIntPtr_IntPtr_RetVoid,            "<rII>v")
DEFINE_METASIG(SM_RefUIntPtr_RetUIntPtr,               "<rU>U")
DEFINE_METASIG(SM_RefUIntPtr_UIntPtr_RetVoid,          "<rUU>v")
DEFINE_METASIG(SM_RefFlt_RetFlt,                       "<rf>f")
DEFINE_METASIG(SM_RefFlt_Flt_RetVoid,                  "<rff>v")
DEFINE_METASIG(SM_RefDbl_RetDbl,                       "<rd>d")
DEFINE_METASIG(SM_RefDbl_Dbl_RetVoid,                  "<rdd>v")
DEFINE_METASIG(SM_RefObj_RetObj,                       "<rj>j")
DEFINE_METASIG(SM_RefObj_Obj_RetVoid,                  "<rjj>v")
DEFINE_METASIG(SM_RefFlt_Flt_RetFlt,                   "<rff>f")
DEFINE_METASIG(SM_RefFlt_Flt_Flt_RetFlt,               "<rfff>f")
DEFINE_METASIG(SM_RefInt_Int_RetInt,                   "<rii>i")
DEFINE_METASIG(SM_RefInt_Int_Int_RetInt,               "<riii>i")
DEFINE_METASIG(SM_RefObj_Obj_RetObj,                   "<rjj>j")
DEFINE_METASIG(SM_RefObj_Obj_Obj_RetObj,               "<rjjj>j")

DEFINE_METASIG(SM_RetInt,                              "<>i")
DEFINE_METASIG(SM_RetObj,                              "<>j")
DEFINE_METASIG_T(SM_RetContext,                        "<>C", Context)
DEFINE_METASIG_T(SM_RetMethodBase,                     "<>C", MethodBase)
DEFINE_METASIG_T(SM_RetMethodInfo,                     "<>C", MethodInfo)
DEFINE_METASIG_T(SM_RetCodeAccessSecurityEngine,       "<>C", SecurityEngine)
DEFINE_METASIG(SM_RetStr,                              "<>s")
DEFINE_METASIG(SM_RetVoid,                             "<>v")

DEFINE_METASIG_T(SM_AppDomain_Int_RetObj,              "<Ci>j", AppDomain)

DEFINE_METASIG(SM_Char_RetArrByte,                     "<u>ab")
DEFINE_METASIG(SM_Dbl_RetInt,                          "<d>i")
DEFINE_METASIG(SM_Dbl_RetLong,                         "<d>l")
DEFINE_METASIG(SM_Dbl_RetArrByte,                      "<d>ab")
DEFINE_METASIG(SM_Flt_RetArrByte,                      "<f>ab")

DEFINE_METASIG(SM_Int_RetObj,                          "<i>j")
DEFINE_METASIG_T(SM_Int_RetPMS,                        "<i>C", PMS)
DEFINE_METASIG(SM_Int_RetStr,                          "<i>s")
DEFINE_METASIG(SM_Int_RetVoid,                         "<i>v")
DEFINE_METASIG(SM_Int_RetArrByte,                      "<i>ab")
DEFINE_METASIG_T(SM_Int_RetVar,                        "<i>g", Var)
DEFINE_METASIG(SM_Int_Int_RetInt,                      "<ii>i")
DEFINE_METASIG(SM_Int_Int_RetObj,                      "<ii>j")
DEFINE_METASIG(SM_Int_Int_RetVoid,                     "<ii>v")
DEFINE_METASIG(SM_Int_Int_Int_RetVoid,                 "<iii>v")
DEFINE_METASIG(SM_Int_Int_Bool_RetVoid,                "<iiF>v")
DEFINE_METASIG(SM_Int_Int_Obj_RetInt,                  "<iij>i")
DEFINE_METASIG(SM_Int_Obj_RetInt,                      "<ij>i")
DEFINE_METASIG(SM_Int_Obj_RetObj,                      "<ij>j")
DEFINE_METASIG(SM_Int_Str_RetVoid,                     "<is>v")
DEFINE_METASIG(SM_Int_Str_Char_Int_Int_Int_RetInt,     "<isuiii>i")
DEFINE_METASIG(SM_Int_Str_Str_Int_Int_Int_RetInt,      "<issiii>i")
DEFINE_METASIG(SM_Int_ArrByte_Int_Int_RetVoid,         "<iabii>v")
DEFINE_METASIG(SM_Int_ArrChar_Int_Int_RetVoid,         "<iauii>v")
DEFINE_METASIG(SM_Int_ArrDbl_Int_Int_RetVoid,          "<iadii>v")
DEFINE_METASIG(SM_Int_ArrFlt_Int_Int_RetVoid,          "<iafii>v")
DEFINE_METASIG(SM_Int_ArrInt_Int_Int_RetVoid,          "<iaiii>v")
DEFINE_METASIG(SM_Int_ArrLong_Int_Int_RetVoid,         "<ialii>v")
DEFINE_METASIG(SM_Int_ArrShrt_Int_Int_RetVoid,         "<iahii>v")

DEFINE_METASIG(SM_Long_RetArrByte,                     "<l>ab")
DEFINE_METASIG(SM_Long_Long_RetLong,                   "<ll>l")

DEFINE_METASIG_T(SM_LocalDataStore_RetVoid,            "<C>v", LocalDataStore)
DEFINE_METASIG_T(SM_Array_RetInt,                      "<C>i", Array)
DEFINE_METASIG_T(SM_ContextBoundObject_RetObj,         "<C>j", ContextBoundObject)
DEFINE_METASIG_T(SM_ContextBoundObject_RetBool,        "<C>F", ContextBoundObject)
DEFINE_METASIG_T(SM_Evidence_PMS_PMS_PMS_PMS_PMS_RetBool,"<CCCCCC>F", Evidence_PMS_PMS_PMS_PMS_PMS)
DEFINE_METASIG_T(SM_Exception_RetInt,                  "<C>i", Exception)
DEFINE_METASIG_T(SM_Assembly_RetVoid,                  "<C>v", Assembly)
DEFINE_METASIG_T(SM_Assembly_Stream_Bool_RetVoid,      "<CCF>v", Assembly_Stream)

DEFINE_METASIG(SM_Obj_RetInt,                          "<j>i")
DEFINE_METASIG(SM_Obj_RetObj,                          "<j>j")
DEFINE_METASIG(SM_Obj_RetStr,                          "<j>s")
DEFINE_METASIG(SM_Obj_RetVoid,                         "<j>v")
DEFINE_METASIG(SM_Obj_RetBool,                         "<j>F")
DEFINE_METASIG(SM_Obj_RetArrByte,                      "<j>ab")
DEFINE_METASIG_T(SM_Obj_RetIMessage,                    "<j>C", IMessage)
DEFINE_METASIG_T(SM_Obj_Obj_RetIMessage,               "<jj>C", IMessage)
DEFINE_METASIG_T(SM_Obj_Int_RefVariant_RetVoid,        "<jirg>v", Var)
DEFINE_METASIG_T(SM_Obj_Int_RetIMessage,               "<ji>C", IMessage)
DEFINE_METASIG(SM_Obj_Int_RetInt,                      "<ji>i")
DEFINE_METASIG(SM_Obj_Int_RetLong,                     "<ji>l")
DEFINE_METASIG(SM_Obj_Int_RetObj,                      "<ji>j")
DEFINE_METASIG_T(SM_Obj_RefMessageData_RetVoid,        "<jrg>v", MessageData)
DEFINE_METASIG(SM_Obj_Int_RetBool,                     "<ji>F")
DEFINE_METASIG(SM_Obj_Int_Int_RetVoid,                 "<jii>v")
DEFINE_METASIG(SM_Obj_Int_Long_RetVoid,                "<jil>v")
DEFINE_METASIG(SM_Obj_Int_Obj_RetVoid,                 "<jij>v")
DEFINE_METASIG(SM_Obj_Int_Obj_Int_Int_RetVoid,         "<jijii>v")
DEFINE_METASIG(SM_Obj_Str_RetVoid,                     "<js>v")
DEFINE_METASIG(SM_Obj_Obj_RefArrByte_RetArrByte,       "<jjrab>ab")
DEFINE_METASIG_T(SM_Obj_RefVariant_RetVoid,            "<jrg>v", Var)

DEFINE_METASIG_T(SM_RealProxy_Int_RetMarshalByRefObject,"<Ci>C", RealProxy_MarshalByRefObject)
DEFINE_METASIG_T(SM_RealProxy_Type_RetBool,             "<CC>F", RealProxy_Type) 
DEFINE_METASIG_T(SM_FrameSecurityDescriptor_IPermission_PermissionToken_RetBool, "<CCC>F", FrameSecurityDescriptor_IPermission_PermissionToken)
DEFINE_METASIG_T(SM_FrameSecurityDescriptor_PMS_PMS_RetBool,"<CCrC>F", FrameSecurityDescriptor_PMS_PMS)
DEFINE_METASIG_T(SM_FrameSecurityDescriptor_RetInt,    "<C>i", FrameSecurityDescriptor)
DEFINE_METASIG_T(SM_PermissionListSet_Bool_PMS_PMS_FrameSecurityDescriptor_RetBool, "<CFCCC>F", PermissionListSet_PMS_PMS_FrameSecurityDescriptor)
DEFINE_METASIG_T(SM_PMS_RetVoid,                       "<C>v", PMS)
DEFINE_METASIG_T(SM_PMS_PMS_CodeAccessPermission_PermissionToken_RetVoid, "<CCCC>v", PMS_PMS_CodeAccessPermission_PermissionToken)
DEFINE_METASIG_T(SM_PMS_IntPtr_RetVoid,                "<CI>v", PMS)
DEFINE_METASIG_T(SM_PMS_PMS_PMS_RetVoid,               "<CCC>v", PMS_PMS_PMS)
DEFINE_METASIG_T(SM_Evidence_PMS_PMS_PMS_PMS_int_Bool_RetPMS,"<CCCCrCriF>C", Evidence_PMS_PMS_PMS_PMS_PMS)
DEFINE_METASIG_T(SM_Evidence_RetInt,                   "<C>i", Evidence)
DEFINE_METASIG_T(SM_RefPMS_RetPMS,                     "<rC>C", PMS_PMS)

DEFINE_METASIG_T(SM_RefVariant_RetObject,                "<rg>j", Var)

DEFINE_METASIG(SM_Str_RetInt,                          "<s>i")
DEFINE_METASIG(SM_Str_Int_RetBool,                     "<si>F")
DEFINE_METASIG_T(SM_Str_RetICustomMarshaler,           "<s>C", ICustomMarshaler)
DEFINE_METASIG(SM_Str_RetStr,                          "<s>s")
DEFINE_METASIG(SM_Str_RetVoid,                         "<s>v")
DEFINE_METASIG(SM_Str_Str_RetStr,                      "<ss>s")
DEFINE_METASIG(SM_Str_Str_RetArrByte,                  "<ss>ab")
DEFINE_METASIG(SM_Str_Str_Str_RetStr,                  "<sss>s")
DEFINE_METASIG(SM_Str_ArrByte_Str_RetArrByte,          "<sabs>ab")
DEFINE_METASIG(SM_Str_ArrStr_Int_Int_RetStr,           "<sasii>s")
DEFINE_METASIG(SM_Str_Bool_Int_RetV,                   "<sFi>v")

DEFINE_METASIG_T(SM_Type_RetInt,                       "<C>i", Type)
DEFINE_METASIG_T(SM_Type_RetBool,                      "<C>F", Type)
DEFINE_METASIG_T(SM_Type_IntPtr_RetMarshalByRefObject, "<CI>C", Type_MarshalByRefObject)
DEFINE_METASIG_T(SM_Type_RetMarshalByRefObject,        "<C>C", Type_MarshalByRefObject)
DEFINE_METASIG_T(SM_Type_ArrObject_Bool_RetMarshalByRefObject, "<CajF>C", Type_MarshalByRefObject)
DEFINE_METASIG(SM_Shrt_RetArrByte,                     "<h>ab")
DEFINE_METASIG_T(SM_Bool_RetPMS,                       "<F>C", PMS)
DEFINE_METASIG(SM_ArrByte_RetArrByte,                  "<ab>ab")
DEFINE_METASIG(SM_ArrByte_RetObj,                      "<ab>j")
DEFINE_METASIG(SM_ArrByte_ArrByte_RefObj_RetObj,       "<ababrj>j")
DEFINE_METASIG(SM_ArrByte_Int_Int_Int_RetVoid,         "<abiii>v")
DEFINE_METASIG_T(SM_ArrByte_Int_Int_Encoding_RetStr,   "<abiiC>s", Encoding)
DEFINE_METASIG_T(SM_PtrSByt_Int_Int_Encoding_RetStr, "<PBiiC>s", Encoding)
DEFINE_METASIG(SM_ArrChar_RetStr,                      "<au>s")
DEFINE_METASIG(SM_ArrChar_Int_Int_RetStr,              "<auii>s")
DEFINE_METASIG(SM_ArrChar_Int_Int_Int_RetVoid,         "<auiii>v")
DEFINE_METASIG(SM_ArrDbl_Int_Int_Int_RetVoid,          "<adiii>v")
DEFINE_METASIG(SM_ArrFlt_Int_Int_Int_RetVoid,          "<afiii>v")
DEFINE_METASIG(SM_ArrInt_Int_Int_Int_RetVoid,          "<aiiii>v")
DEFINE_METASIG(SM_ArrLong_Int_Int_Int_RetVoid,         "<aliii>v")
DEFINE_METASIG(SM_ArrObj_RetArrByte,                   "<aj>ab")
DEFINE_METASIG(SM_ArrObj_RefArrByte_RetArrByte,        "<ajrab>ab")
DEFINE_METASIG(SM_ArrStr_RetStr,                       "<as>s")
DEFINE_METASIG_T(SM_ArrType_Type_RetBool,              "<aCC>F", Type_Type)
DEFINE_METASIG(SM_ArrShrt_Int_Int_Int_RetVoid,         "<ahiii>v")
DEFINE_METASIG_T(SM_Currency_Int_Int_RetStr,           "<gii>s", Currency)
DEFINE_METASIG_T(SM_DateTime_Int_Int_RetStr,           "<gii>s", DateTime)
DEFINE_METASIG_T(SM_TypedByRef_RetVar,                 "<g>g", TypedByRef_Var)
DEFINE_METASIG_T(SM_Var_Int_Int_RetStr,                "<gii>s", Var)
DEFINE_METASIG_T(SM_Var_Int_Int_Int_Int_Int_RetStr,    "<giiiii>s", Var)

DEFINE_METASIG_T(SM_RetResourceManager,                "<>C", ResourceManager)
DEFINE_METASIG_T(SM_Void_RetRuntimeTypeHandle,         "<>g", RuntimeTypeHandle)
DEFINE_METASIG_T(SM_PMS_PMS_ArrayList_ArrayList_RetVoid, "<CCCC>v", PMS_PMS_ArrayList_ArrayList)

// fields:
DEFINE_METASIG(Fld_Byte,                       "b")
DEFINE_METASIG(Fld_Char,                       "u")
DEFINE_METASIG(Fld_Dbl,                        "d")
DEFINE_METASIG(Fld_Flt,                        "f")
DEFINE_METASIG(Fld_Int,                        "i")
DEFINE_METASIG(Fld_IntPtr,                     "I")
DEFINE_METASIG(Fld_Long,                       "l")

DEFINE_METASIG_T(Fld_ContextBoundObject,       "C", ContextBoundObject)
DEFINE_METASIG_T(Fld_Delegate,                 "C", Delegate)
DEFINE_METASIG_T(Fld_Empty,                    "C", Empty)
DEFINE_METASIG_T(Fld_Exception,                "C", Exception)
DEFINE_METASIG_T(Fld_TextReader,               "C", TextReader)
DEFINE_METASIG_T(Fld_TextWriter,               "C", TextWriter)
DEFINE_METASIG_T(Fld_MarshalByRefObject,       "C", MarshalByRefObject)
DEFINE_METASIG_T(Fld_Missing,                  "C", Missing)
DEFINE_METASIG_T(Fld_MulticastDelegate,        "C", MulticastDelegate)
DEFINE_METASIG_T(Fld_Null,                     "C", Null)
DEFINE_METASIG(Fld_Obj,                        "j")
DEFINE_METASIG_T(Fld_TypeFilter,               "C", TypeFilter)
DEFINE_METASIG_T(Fld_MethodBase,               "C", MethodBase)
DEFINE_METASIG_T(Fld_MethodInfo,               "C", MethodInfo)
DEFINE_METASIG_T(Fld_RuntimeMethodInfo,        "C", RuntimeMethodInfo)
DEFINE_METASIG_T(Fld_CultureInfo,              "C", CultureInfo)
DEFINE_METASIG_T(Fld_CustomAttribute,          "C", CustomAttribute)

// The following are used for native implementation of contexts
DEFINE_METASIG_T(Fld_Context,                  "C", Context)
DEFINE_METASIG_T(Fld_ContextProperty,          "C", IContextProperty)
DEFINE_METASIG_T(Fld_ContextPropertyArray,     "aC", IContextProperty)
DEFINE_METASIG_T(Fld_DynamicPropertyHolder,    "C", DynamicPropertyHolder)
DEFINE_METASIG_T(Fld_IMessageSink,             "C", IMessageSink)
DEFINE_METASIG_T(Fld_AppDomain,                "C", AppDomain)
DEFINE_METASIG_T(Fld_SharedStatics,            "C", SharedStatics)

DEFINE_METASIG_T(Fld_LogicalCallContext,       "C", LogicalCallContext)
DEFINE_METASIG_T(Fld_IllogicalCallContext,     "C", IllogicalCallContext)
DEFINE_METASIG_T(Fld_Identity,                 "C", Identity)
DEFINE_METASIG_T(Fld_MCMDictionary,            "C", MCMDictionary)
DEFINE_METASIG_T(Fld_RealProxy,                "C", RealProxy)
DEFINE_METASIG_T(Fld_ServerIdentity,           "C", ServerIdentity)
DEFINE_METASIG_T(Fld_ResourceManager,          "C", ResourceManager)
DEFINE_METASIG_T(Fld_PMS,                      "C", PMS)
DEFINE_METASIG(Fld_Str,                        "s")
DEFINE_METASIG_T(Fld_Type,                     "C", Type)
DEFINE_METASIG_T(Fld_LocalDataStore,           "C", LocalDataStore)
DEFINE_METASIG(Fld_Shrt,                       "h")
DEFINE_METASIG(Fld_Bool,                       "F")
DEFINE_METASIG_T(Fld_PlatformID,               "g", PlatformID)
DEFINE_METASIG_T(Fld_TokenBasedSet,            "C", TokenBasedSet)
DEFINE_METASIG_T(Fld_Guid,                     "g", Guid)
DEFINE_METASIG_T(Fld_Hashtable,                "C", Hashtable)

DEFINE_METASIG(Fld_PtrVoid,                    "Pv")

DEFINE_METASIG(Fld_ArrByte,                    "ab")
DEFINE_METASIG(Fld_ArrChar,                    "au")
DEFINE_METASIG(Fld_ArrInt,                     "ai")
DEFINE_METASIG_T(Fld_ArrType,                  "aC", Type)
DEFINE_METASIG(Fld_ArrObj,                     "aj")

DEFINE_METASIG(IM_RetInt,                      "!<>i")
DEFINE_METASIG(IM_RetPtr,                      "!<>p")
DEFINE_METASIG(IM_RetLong,                     "!<>l")
DEFINE_METASIG_T(IM_RetAssemblyName,           "!<>C", AssemblyName)
DEFINE_METASIG_T(IM_Str_ArrB_Str_AHA_Ver_CI_ANF_RetV, "!<sabsgCCg>v", AHA_Ver_CI_ANF)
DEFINE_METASIG(IM_RetObj,                      "!<>j")
DEFINE_METASIG_T(IM_RetIEnumerator,            "!<>C", IEnumerator)
DEFINE_METASIG_T(IM_RetIPermission,            "!<>C", IPermission)
DEFINE_METASIG_T(IM_RetPMS,                    "!<>C", PMS)
DEFINE_METASIG(IM_RetStr,                      "!<>s")

DEFINE_METASIG_T(IM_RetStringBuilder,          "!<>C", StringBuilder)
DEFINE_METASIG_T(IM_RetType,                   "!<>C", Type)
DEFINE_METASIG_T(SM_Str_RetType,               "<s>C", Type)
DEFINE_METASIG_T(SM_Str_Bool_RetType,          "<sF>C", Type)
DEFINE_METASIG_T(SM_Str_Bool_Bool_RetType,     "<sFF>C", Type)
DEFINE_METASIG_T(IM_Str_RetType,               "!<s>C", Type)
DEFINE_METASIG_T(IM_Str_Bool_RetType,          "!<sF>C", Type)
DEFINE_METASIG_T(IM_Str_Bool_Bool_RetType,     "!<sFF>C", Type)
DEFINE_METASIG(IM_RetVoid,                     "!<>v")
DEFINE_METASIG(IM_RetBool,                     "!<>F")
DEFINE_METASIG(IM_RetArrByte,                  "!<>ab")
DEFINE_METASIG(IM_RetArrChar,                  "!<>au")
DEFINE_METASIG(IM_RetArrInt,                   "!<>ai")
DEFINE_METASIG(IM_RetArrObj,                   "!<>aj")
DEFINE_METASIG(IM_RetArrStr,                   "!<>as")
DEFINE_METASIG_T(IM_RetTypedByRef,             "!<>g", TypedByRef)
DEFINE_METASIG_T(IM_RetArrParameterInfo,       "!<>aC", ParameterInfo)
DEFINE_METASIG_T(IM_RetCultureInfo,            "!<>C", CultureInfo)
DEFINE_METASIG_T(IM_RetSecurityElement,       "!<>C", SecurityElement)

DEFINE_METASIG(IM_Bool_RetPtr,              "!<F>p")

DEFINE_METASIG(IM_PtrChar_RetVoid,             "!<Pu>v")
DEFINE_METASIG(IM_PtrChar_Int_Int_RetVoid,     "!<Puii>v")
DEFINE_METASIG(IM_PtrSByt_RetVoid,             "!<PB>v")
DEFINE_METASIG(IM_PtrSByt_Int_Int_RetVoid,     "!<PBii>v")
DEFINE_METASIG_T(IM_PtrSByt_Int_Int_Encoding_RetVoid, "!<PBiiC>v", Encoding)

DEFINE_METASIG(IM_Char_Char_RetStr,            "!<uu>s")
DEFINE_METASIG(IM_Char_RetChar,                "!<u>u")
DEFINE_METASIG(IM_Char_Int_RetVoid,            "!<ui>v")
DEFINE_METASIG_T(IM_Char_Char_Int_Int_RetStringBuilder, "!<uuii>C", StringBuilder)
DEFINE_METASIG_T(IM_Char_Int_RetStringBuilder,          "!<ui>C", StringBuilder)
DEFINE_METASIG(IM_Char_Int_Int_RetInt,         "!<uii>i")
DEFINE_METASIG_T(IM_CultureInfo_RetVoid,       "!<C>v", CultureInfo)
DEFINE_METASIG(IM_Dbl_RetVoid,                 "!<d>v")
DEFINE_METASIG(IM_Flt_RetVoid,                 "!<f>v")
DEFINE_METASIG_T(IM_Int_RetIMessage,           "!<i>C", IMessage)
DEFINE_METASIG(IM_Int_RetInt,                  "!<i>i")
DEFINE_METASIG(IM_Int_RetObj,                  "!<i>j")
DEFINE_METASIG_T(IM_Int_RetPermissionListSet,  "!<i>C", PermissionListSet)
DEFINE_METASIG(IM_Int_RetVoid,                 "!<i>v")
DEFINE_METASIG(IM_Int_RetBool,                 "!<i>F")
DEFINE_METASIG(IM_Int_RetArrChar,              "!<i>au")
DEFINE_METASIG_T(IM_Int_Char_RetStringBuilder, "!<iu>C", StringBuilder)
DEFINE_METASIG(IM_Int_Int_RetStr,              "!<ii>s")
DEFINE_METASIG(IM_Int_Int_RetVoid,             "!<ii>v")
DEFINE_METASIG_T(IM_RefMessageData_Int_RetVoid,"!<rgi>v", MessageData)
DEFINE_METASIG(IM_Int_Int_RetArrChar,          "!<ii>au")
DEFINE_METASIG(IM_Int_Int_Int_Int_RetVoid,     "!<iiii>v")
DEFINE_METASIG_T(IM_Int_PMS_PMS_RetVoid,         "!<iCC>v", PMS_PMS)
DEFINE_METASIG_T(IM_Int_Str_Int_RetStringBuilder,"!<isi>C", StringBuilder)
DEFINE_METASIG(IM_Int_Sht_Sht_ArrByte_RetVoid, "!<ihhab>v")
DEFINE_METASIG_T(IM_Int_ArrChar_Int_Int_RetStringBuilder, "!<iauii>C", StringBuilder)

DEFINE_METASIG(IM_Long_Long_RetVoid,           "!<ll>v")
DEFINE_METASIG_T(IM_Assembly_RetVoid,          "!<C>v", Assembly)
DEFINE_METASIG_T(IM_Assembly_RetBool,          "!<C>F", Assembly)
DEFINE_METASIG_T(IM_Assembly_AssemblyRegistrationFlags_RetBool, "!<Cg>F", Assembly_AssemblyRegistrationFlags)
DEFINE_METASIG_T(IM_StackFrameHelper_Int_RetVoid,"!<Ci>v", StackFrameHelper)
DEFINE_METASIG_T(IM_Exception_RetVoid,         "!<C>v", Exception)

DEFINE_METASIG(IM_Ptr_RetObj,                  "!<p>j")
DEFINE_METASIG(IM_Ptr_RetVoid,                 "!<p>v")
DEFINE_METASIG_T(IM_RefGuid_RetIntPtr,           "!<rg>I", Guid)

DEFINE_METASIG(IM_Obj_RetInt,                  "!<j>i")
DEFINE_METASIG(IM_Obj_RetPtr,                  "!<j>p")
DEFINE_METASIG_T(IM_Obj_RetPMS,                "!<j>C", PMS)
DEFINE_METASIG(IM_Obj_RetVoid,                 "!<j>v")
DEFINE_METASIG(IM_Obj_RetBool,                 "!<j>F")
DEFINE_METASIG(IM_Obj_RetObj,                  "!<j>j")
DEFINE_METASIG_T(IM_Obj_Int_RetPMS,            "!<ji>C", PMS)
DEFINE_METASIG(IM_Obj_Bool_RetVoid,            "!<jF>v")
DEFINE_METASIG_T(IM_Str_BindingFlags_Obj_ArrInt_RefMessageData_RetObj, "!<sgjairg>j", BindingFlags_MessageData)
DEFINE_METASIG_T(IM_Obj_Obj_BindingFlags_Binder_CultureInfo_RetVoid, "!<jjgCC>v", BindingFlags_Binder_CultureInfo)
DEFINE_METASIG_T(IM_Obj_Obj_BindingFlags_Binder_ArrObj_CultureInfo_RetVoid, "!<jjgCajC>v", BindingFlags_Binder_CultureInfo)
DEFINE_METASIG_T(IM_Obj_BindingFlags_Binder_ArrObj_CultureInfo_RetObj, "!<jgCajC>j", BindingFlags_Binder_CultureInfo)
DEFINE_METASIG_T(IM_Obj_Type_CultureInfo_RetObj, "!<jCC>j", Type_CultureInfo)
DEFINE_METASIG_T(IM_PlatformID_Version_RetVoid, "!<gC>v", PlatformID_Version)
DEFINE_METASIG_T(IM_RefStackCrawlMark_RetPermissionListSet, "!<rg>C", StackCrawlMark_PermissionListSet)
DEFINE_METASIG_T(IM_IPrincipal_RetVoid,        "!<C>v", IPrincipal)
DEFINE_METASIG_T(IM_FieldInfo_RefObj_RetVoid,  "!<Crj>v", FieldInfo)
DEFINE_METASIG_T(IM_FieldInfo_Obj_RetVoid,     "!<Cj>v", FieldInfo)
DEFINE_METASIG_T(IM_MemberInfo_RetVoid,        "!<C>v", MemberInfo)
DEFINE_METASIG_T(IM_MemberInfo_Obj_RetBool,    "!<Cj>F", MemberInfo)
DEFINE_METASIG_T(IM_Message_RetVoid,           "!<C>v", Message)
DEFINE_METASIG_T(IM_MethodBase_ArrObj_Obj_Int_Bool_RefArrObj_RetObj,"!<CajjiFraj>j", MethodBase)
DEFINE_METASIG_T(IM_CodeAccessPermission_RetVoid,"!<C>v", CodeAccessPermission) 
DEFINE_METASIG_T(IM_CodeAccessPermission_RetBool,"!<C>F", CodeAccessPermission) 
DEFINE_METASIG_T(IM_CodeAccessPermission_PermissionToken_RetBool,"!<CC>F", CodeAccessPermission_PermissionToken)
DEFINE_METASIG_T(IM_IEvidenceFactory_ArrByte_ArrByte_RetVoid,"!<Cabab>v", IEvidenceFactory)
DEFINE_METASIG(gsid_IM_ArrByte_String_int_int_int_RetVoid,"!<absiii>v")
DEFINE_METASIG_T(IM_IPermission_RetIPermission,"!<C>C", IPermission_IPermission)
DEFINE_METASIG_T(IM_IPermission_RetPermissionToken, "!<C>C", IPermission_PermissionToken)
DEFINE_METASIG_T(IM_IPermission_RetBool,       "!<C>F", IPermission)
DEFINE_METASIG_T(IM_PermissionListSet_RetVoid, "!<C>v", PermissionListSet)
DEFINE_METASIG_T(IM_PMS_RetPMS,                "!<C>C", PMS_PMS)
DEFINE_METASIG_T(IM_PMS_RetVoid,               "!<C>v", PMS)
DEFINE_METASIG_T(IM_PMS_PMS_RetVoid,           "!<CC>v", PMS_PMS)
DEFINE_METASIG_T(IM_PMS_RetBool,               "!<C>F", PMS)
DEFINE_METASIG_T(IM_PMS_OutPMS_RetBool,        "!<CrC>F", PMS_PMS)
DEFINE_METASIG_T(IM_PMS_Exception_PMS_RetBool, "!<CrCrC>F", PMS_Exception_PMS)
DEFINE_METASIG_T(IM_PMS_PMS_RetBool,           "!<CC>F", PMS_PMS)
DEFINE_METASIG_T(IM_PMS_PMS_PMS_PMS_PMS_RetBool, "!<CCCCC>F", PMS_PMS_PMS_PMS_PMS)
DEFINE_METASIG_T(IM_X509Certificate_RetVoid,   "!<C>v", X509Certificate)
DEFINE_METASIG(IM_RefObject_RetBool,           "!<rj>F")
DEFINE_METASIG_T(IM_Type_RetObj,               "!<C>j", Type)
DEFINE_METASIG_T(IM_ArrayList_ArrayList_RetVoid, "!<CC>v", ArrayList_ArrayList)

DEFINE_METASIG_T(IM_Str_RetModule,             "!<s>C", Module)
DEFINE_METASIG_T(IM_Str_RetAssembly,           "!<s>C", Assembly)
DEFINE_METASIG_T(IM_Str_Str_Str_Assembly_Assembly_RetVoid, "!<sssCC>v", Assembly_Assembly)
DEFINE_METASIG(IM_Str_Str_Obj_RetVoid,         "!<ssj>v")
DEFINE_METASIG(IM_Str_Str_RefObj_RetVoid,      "!<ssrj>v")
DEFINE_METASIG(IM_Str_RetObj,                  "!<s>j")
DEFINE_METASIG_T(IM_Str_RetFieldInfo,          "!<s>C", FieldInfo)
DEFINE_METASIG_T(IM_Str_RetPropertyInfo,       "!<s>C", PropertyInfo)
DEFINE_METASIG(IM_Str_RetStr,                  "!<s>s")
DEFINE_METASIG_T(IM_Str_RetStringBuilder,      "!<s>C", StringBuilder)

DEFINE_METASIG(IM_Str_RetVoid,                 "!<s>v")
DEFINE_METASIG_T(IM_Str_Exception_RetVoid,     "!<sC>v", Exception)
DEFINE_METASIG(IM_Str_RetBool,                 "!<s>F")
DEFINE_METASIG(IM_Str_RetArrByte,              "!<s>ab")
DEFINE_METASIG_T(IM_Str_ArrByte_Int_ArrByte_ArrByte_Evidence_RetEvidence, "!<sabiababC>C", Evidence_Evidence)
DEFINE_METASIG_T(IM_Evidence_Evidence_RetEvidence, "!<CC>C", Evidence_Evidence_Evidence)
DEFINE_METASIG(IM_Str_Int_Int_RetInt,          "!<sii>i")
DEFINE_METASIG_T(IM_Str_Int_Int_RetStringBuilder,"!<sii>C", StringBuilder)
DEFINE_METASIG(IM_Str_Obj_RetVoid,             "!<sj>v")
DEFINE_METASIG_T(IM_Str_BindingFlags_Binder_ArrType_ArrParameterModifier_RetMethodInfo,"!<sgCaCag>C", BindingFlags_Binder_Type_ParameterModifier_MethodInfo)
DEFINE_METASIG_T(IM_Str_BindingFlags_Binder_RetType_ArrType_ArrParameterModifier_RetPropertyInfo,"!<sgCCaCag>C", BindingFlags_Binder_Type_Type_ParameterModifier_MethodInfo)
DEFINE_METASIG(IM_Str_Str_RetStr,              "!<ss>s")
DEFINE_METASIG(IM_Str_Str_RetVoid,             "!<ss>v")
DEFINE_METASIG_T(IM_Str_Str_Int_Int_RetStringBuilder, "!<ssii>C", StringBuilder)
DEFINE_METASIG(IM_Str_Int_RetVoid,             "!<si>v")
DEFINE_METASIG(IM_Str_Str_Int_RetVoid,             "!<ssi>v")
DEFINE_METASIG(IM_Str_Str_Str_Int_RetVoid,     "!<sssi>v")
DEFINE_METASIG(IM_Str_Str_Str_RetVoid,         "!<sss>v")
DEFINE_METASIG(IM_Str_Str_Str_ArrByte_ArrByte_RetArrByte, "!<sssabab>ab")
DEFINE_METASIG(IM_Str_Str_ArrByte_RetVoid,     "!<ssab>v")
DEFINE_METASIG_T(IM_Str_BindingFlags_RetFieldInfo,  "!<sg>C", BindingFlags_FieldInfo)
DEFINE_METASIG_T(IM_Str_BindingFlags_RetMemberInfo, "!<sg>aC", BindingFlags_MemberInfo)
DEFINE_METASIG(IM_Str_ArrByte_RetVoid,         "!<sab>v")
DEFINE_METASIG(IM_Str_ArrByte_Int_RetVoid,     "!<sabi>v")
DEFINE_METASIG_T(IM_Str_FileMode_FileAccess_FileShare_Int_RetVoid,"!<sgggi>v", FileMode_FileAccess_FileShare)
DEFINE_METASIG_T(IM_Str_BindingFlags_RetMethodInfo, "!<sg>C", BindingFlags_MethodInfo)
DEFINE_METASIG_T(IM_Str_BindingFlags_RetPropertyInfo,"!<sg>C", BindingFlags_PropertyInfo)
DEFINE_METASIG_T(IM_Str_BindingFlags_Binder_Obj_ArrVar_ArrParameterModifier_CultureInfo_ArrStr_RetVar, "!<sgCjagagCas>g", BindingFlags_Binder_Var_ParameterModifier_CultureInfo_Var)
DEFINE_METASIG_T(IM_Str_BindingFlags_Binder_Obj_ArrObj_ArrParameterModifier_CultureInfo_ArrStr_RetObj, "!<sgCjajagCas>j", BindingFlags_Binder_ParameterModifier_CultureInfo)
DEFINE_METASIG_T(IM_Str_Delegate_RetMethodInfo,  "!<sC>C", Delegate_MethodInfo)
DEFINE_METASIG_T(IM_Str_Type_Str_RetVoid,        "!<sCs>v", Type)

DEFINE_METASIG_T(IM_StringBuilder_RetObj,        "!<C>j", StringBuilder)
DEFINE_METASIG_T(IM_Type_RetArrObj,              "!<CF>aj", Type)
DEFINE_METASIG_T(IM_Type_Obj_RetBool,            "!<Cj>F", Type)
DEFINE_METASIG_T(IM_Type_MemberInfo_Str_Int_Int_Int_Bool_Obj_IntPtr_Int_RetVoid, "!<CCsiiiFjIi>v", Type_MemberInfo)
DEFINE_METASIG(IM_Bool_RetVoid,                "!<F>v")
DEFINE_METASIG_T(IM_BindingFlags_RetArrFieldInfo,        "!<g>aC", BindingFlags_FieldInfo)
DEFINE_METASIG_T(IM_BindingFlags_RetArrMemberInfo,       "!<g>aC", BindingFlags_MemberInfo)
DEFINE_METASIG_T(IM_BindingFlags_RetArrMethodInfo,       "!<g>aC", BindingFlags_MethodInfo)
DEFINE_METASIG_T(IM_BindingFlags_RetArrPropertyInfo,     "!<g>aC", BindingFlags_PropertyInfo)
DEFINE_METASIG_T(IM_Bool_PMS_PMS_PMS_Int_RetVoid,"!<FCCCi>v", PMS_PMS_PMS)
DEFINE_METASIG(IM_Bool_Bool_RetVoid,           "!<FF>v")
DEFINE_METASIG(IM_ArrByte_RetInt,              "!<ab>i")
DEFINE_METASIG(IM_ArrByte_RetVoid,             "!<ab>v")
DEFINE_METASIG(IM_ArrByte_RetBool,             "!<ab>F")
DEFINE_METASIG(IM_ArrByte_RefInt_RetBool,      "!<abri>F")
DEFINE_METASIG(IM_ArrByte_RetArrChar,          "!<ab>au")
DEFINE_METASIG_T(IM_ArrByte_Int_Int_Encoding_RetVoid, "!<abiiC>v", Encoding)
DEFINE_METASIG(IM_ArrChar_RetVoid,             "!<au>v")
DEFINE_METASIG(IM_ArrChar_RetArrByte,          "!<au>ab")
DEFINE_METASIG(IM_ArrChar_Int_Int_RetInt,      "!<auii>i")
DEFINE_METASIG_T(IM_ArrChar_Int_Int_RetStringBuilder, "!<auii>C", StringBuilder)
DEFINE_METASIG(IM_ArrChar_Int_Int_RetVoid,     "!<auii>v")
DEFINE_METASIG(IM_ArrChar_Int_Int_Int_RetVoid, "!<auiii>v")
DEFINE_METASIG(IM_ArrStr_RetVoid,              "!<as>v")
DEFINE_METASIG_T(IM_ArrType_ArrException_Str_RetVoid,"!<aCaCs>v", Type_Exception)

DEFINE_METASIG_T(IM_Guid_RetVoid,                "!<g>v", Guid)
DEFINE_METASIG_T(IM_RuntimeArgumentHandle_RetVoid, "!<g>v", RuntimeArgumentHandle)
DEFINE_METASIG_T(IM_RuntimeArgumentHandle_PtrVoid_RetVoid, "!<gPv>v", RuntimeArgumentHandle)
DEFINE_METASIG_T(IM_SecurityPermissionFlag_RetVoid,"!<g>v", SecurityPermissionFlag)
DEFINE_METASIG_T(IM_SecurityAction_RetVoid, "!<g>v", SecurityAction)
DEFINE_METASIG_T(IM_ReflectionPermissionFlag_RetVoid,"!<g>v", ReflectionPermissionFlag)
DEFINE_METASIG_T(IM_LicenseInteropHelper_GetCurrentContextInfo, "!<rirIg>v", RuntimeTypeHandle)
DEFINE_METASIG(IM_LicenseInteropHelper_SaveKeyInCurrentContext, "!<I>v")
DEFINE_METASIG_T(IM_LicenseInteropHelper_AllocateAndValidateLicense, "!<gIi>j", RuntimeTypeHandle)
DEFINE_METASIG_T(IM_LicenseInteropHelper_RequestLicKey, "!<grI>i", RuntimeTypeHandle)
DEFINE_METASIG_T(IM_LicenseInteropHelper_GetLicInfo, "!<griri>v", RuntimeTypeHandle)
DEFINE_METASIG_T(IM_Void_RetRuntimeTypeHandle,         "<>g", RuntimeTypeHandle)

// App Domain related defines
DEFINE_METASIG_T(IM_LoaderOptimization_Str_Str_RetVoid,                 "!<gss>v", LoaderOptimization)
DEFINE_METASIG_T(SM_Str_Evidence_AppDomainSetup_RetAppDomain,           "<sCC>C", Evidence_AppDomainSetup_AppDomain)
DEFINE_METASIG_T(SM_Str_Evidence_Str_Str_Bool_RetAppDomain,             "<sCssF>C", Evidence_AppDomain)
DEFINE_METASIG_T(SM_Str_RetAppDomain,                                   "<s>C", AppDomain)
DEFINE_METASIG_T(SM_AppDomain_RetVoid,                                  "<C>v", AppDomain)
DEFINE_METASIG_PARAMS_1(LoaderOptimization, LOADER_OPTIMIZATION)
DEFINE_METASIG_PARAMS_2(Evidence_AppDomain, EVIDENCE, APP_DOMAIN)
DEFINE_METASIG_PARAMS_3(Evidence_AppDomainSetup_AppDomain, EVIDENCE, APPDOMAIN_SETUP, APP_DOMAIN)

DEFINE_METASIG_PARAMS_1(AppDomain,                   APP_DOMAIN)
DEFINE_METASIG_PARAMS_1(Array,                       ARRAY)
DEFINE_METASIG_PARAMS_1(ArrayList,                   ARRAY_LIST)
DEFINE_METASIG_PARAMS_1(Assembly,                    ASSEMBLY)
DEFINE_METASIG_PARAMS_1(AssemblyName,                ASSEMBLY_NAME)
DEFINE_METASIG_PARAMS_1(BindingFlags,                BINDING_FLAGS)
DEFINE_METASIG_PARAMS_1(CodeAccessPermission,        CODE_ACCESS_PERMISSION)
DEFINE_METASIG_PARAMS_1(Context,                     CONTEXT)
DEFINE_METASIG_PARAMS_1(ContextBoundObject,          CONTEXT_BOUND_OBJECT)
DEFINE_METASIG_PARAMS_1(CultureInfo,                 CULTURE_INFO)
DEFINE_METASIG_PARAMS_1(Currency,                    CURRENCY)
DEFINE_METASIG_PARAMS_1(CustomAttribute,             CUSTOM_ATTRIBUTE)
DEFINE_METASIG_PARAMS_1(DateTime,                    DATE_TIME)
DEFINE_METASIG_PARAMS_1(Delegate,                    DELEGATE)
DEFINE_METASIG_PARAMS_1(DynamicPropertyHolder,       DYNAMIC_PROPERTY_HOLDER)
DEFINE_METASIG_PARAMS_1(Empty,                       EMPTY)
DEFINE_METASIG_PARAMS_1(Encoding,                    ENCODING)
DEFINE_METASIG_PARAMS_1(Evidence,                    EVIDENCE)
DEFINE_METASIG_PARAMS_1(Exception,                   EXCEPTION)
DEFINE_METASIG_PARAMS_1(FieldInfo,                   FIELD_INFO)
DEFINE_METASIG_PARAMS_1(FrameSecurityDescriptor,     FRAME_SECURITY_DESCRIPTOR)
DEFINE_METASIG_PARAMS_1(Guid,                        GUID)
DEFINE_METASIG_PARAMS_1(Hashtable,                   HASHTABLE)
DEFINE_METASIG_PARAMS_1(IContextProperty,            ICONTEXT_PROPERTY)
DEFINE_METASIG_PARAMS_1(ICustomMarshaler,            ICUSTOM_MARSHALER)
DEFINE_METASIG_PARAMS_1(Identity,                    IDENTITY)
DEFINE_METASIG_PARAMS_1(IEnumerator,                 IENUMERATOR)
DEFINE_METASIG_PARAMS_1(IEvidenceFactory,            IEVIDENCE_FACTORY)
DEFINE_METASIG_PARAMS_1(IllogicalCallContext,        ILLOGICAL_CALL_CONTEXT)
DEFINE_METASIG_PARAMS_1(IMessage,                    IMESSAGE)
DEFINE_METASIG_PARAMS_1(IMessageSink,                IMESSAGE_SINK)
DEFINE_METASIG_PARAMS_1(IPermission,                 IPERMISSION)
DEFINE_METASIG_PARAMS_1(IPrincipal,                  IPRINCIPAL)
DEFINE_METASIG_PARAMS_1(LocalDataStore,              LOCAL_DATA_STORE)
DEFINE_METASIG_PARAMS_1(LogicalCallContext,          LOGICAL_CALL_CONTEXT)
DEFINE_METASIG_PARAMS_1(MarshalByRefObject,          MARSHAL_BY_REF_OBJECT)
DEFINE_METASIG_PARAMS_1(MCMDictionary,               MCM_DICTIONARY)
DEFINE_METASIG_PARAMS_1(MemberInfo,                  MEMBER)
DEFINE_METASIG_PARAMS_1(Message,                     MESSAGE)
DEFINE_METASIG_PARAMS_1(MessageData,                 MESSAGE_DATA)
DEFINE_METASIG_PARAMS_1(MethodBase,                  METHOD_BASE)
DEFINE_METASIG_PARAMS_1(MethodInfo,                  METHOD_INFO)
DEFINE_METASIG_PARAMS_1(Missing,                     MISSING)
DEFINE_METASIG_PARAMS_1(Module,                      MODULE)
DEFINE_METASIG_PARAMS_1(MulticastDelegate,           MULTICAST_DELEGATE)
DEFINE_METASIG_PARAMS_1(Null,                        NULL)
DEFINE_METASIG_PARAMS_1(ParameterInfo,               PARAMETER)
DEFINE_METASIG_PARAMS_1(PermissionListSet,           PERMISSION_LIST_SET)
DEFINE_METASIG_PARAMS_1(PMS,                         PERMISSION_SET)
DEFINE_METASIG_PARAMS_1(PlatformID,                  PLATFORM_ID)
DEFINE_METASIG_PARAMS_1(PropertyInfo,                PROPERTY_INFO)
DEFINE_METASIG_PARAMS_1(RealProxy,                   REAL_PROXY)
DEFINE_METASIG_PARAMS_1(ReflectionPermissionFlag,    REFLECTION_PERMISSION_FLAG)
DEFINE_METASIG_PARAMS_1(ResourceManager,             RESOURCE_MANAGER)
DEFINE_METASIG_PARAMS_1(RuntimeArgumentHandle,       ARGUMENT_HANDLE)
DEFINE_METASIG_PARAMS_1(RuntimeTypeHandle,           TYPE_HANDLE)
DEFINE_METASIG_PARAMS_1(RuntimeMethodInfo,           METHOD)
DEFINE_METASIG_PARAMS_1(SecurityAction,              SECURITY_ACTION)
DEFINE_METASIG_PARAMS_1(SecurityEngine,              SECURITY_ENGINE)
DEFINE_METASIG_PARAMS_1(SecurityElement,             SECURITY_ELEMENT)
DEFINE_METASIG_PARAMS_1(SecurityPermissionFlag,      SECURITY_PERMISSION_FLAG)
DEFINE_METASIG_PARAMS_1(ServerIdentity,              SERVER_IDENTITY)
DEFINE_METASIG_PARAMS_1(SharedStatics,               SHARED_STATICS)
DEFINE_METASIG_PARAMS_1(StackFrameHelper,            STACK_FRAME_HELPER)
DEFINE_METASIG_PARAMS_1(StringBuilder,               STRING_BUILDER)
DEFINE_METASIG_PARAMS_1(TextReader,                  TEXT_READER)
DEFINE_METASIG_PARAMS_1(TextWriter,                  TEXT_WRITER)
DEFINE_METASIG_PARAMS_1(TokenBasedSet,               TOKEN_BASED_SET)
DEFINE_METASIG_PARAMS_1(Type,                        TYPE)
DEFINE_METASIG_PARAMS_1(TypeFilter,                  CLASS_FILTER)
DEFINE_METASIG_PARAMS_1(TypedByRef,                  TYPED_REFERENCE)
DEFINE_METASIG_PARAMS_1(Var,                         VARIANT)
DEFINE_METASIG_PARAMS_1(X509Certificate,             X509_CERTIFICATE)

DEFINE_METASIG_PARAMS_2(Assembly_Stream,                     ASSEMBLY, STREAM)
DEFINE_METASIG_PARAMS_2(Assembly_Assembly,                   ASSEMBLY, ASSEMBLY)
DEFINE_METASIG_PARAMS_2(BindingFlags_CultureInfo,            BINDING_FLAGS, CULTURE_INFO)
DEFINE_METASIG_PARAMS_2(BindingFlags_FieldInfo,              BINDING_FLAGS, FIELD_INFO)
DEFINE_METASIG_PARAMS_2(BindingFlags_MemberInfo,             BINDING_FLAGS, MEMBER)
DEFINE_METASIG_PARAMS_2(BindingFlags_MessageData,            BINDING_FLAGS, MESSAGE_DATA)
DEFINE_METASIG_PARAMS_2(BindingFlags_MethodInfo,             BINDING_FLAGS, METHOD_INFO)
DEFINE_METASIG_PARAMS_2(BindingFlags_PropertyInfo,           BINDING_FLAGS, PROPERTY_INFO)
DEFINE_METASIG_PARAMS_2(CodeAccessPermission_PermissionToken,CODE_ACCESS_PERMISSION, PERMISSION_TOKEN)
DEFINE_METASIG_PARAMS_2(Delegate_MethodInfo,                 DELEGATE, METHOD_INFO)
DEFINE_METASIG_PARAMS_2(Evidence_Evidence,                   EVIDENCE, EVIDENCE)
DEFINE_METASIG_PARAMS_2(IPermission_IPermission,             IPERMISSION, IPERMISSION)
DEFINE_METASIG_PARAMS_2(IPermission_PermissionToken,         IPERMISSION, PERMISSION_TOKEN)
DEFINE_METASIG_PARAMS_2(PMS_PMS,                             PERMISSION_SET, PERMISSION_SET)
DEFINE_METASIG_PARAMS_2(PlatformID_Version,                  PLATFORM_ID, VERSION)
DEFINE_METASIG_PARAMS_2(RealProxy_MarshalByRefObject,        REAL_PROXY, MARSHAL_BY_REF_OBJECT)
DEFINE_METASIG_PARAMS_2(RealProxy_Type,                      REAL_PROXY, TYPE)
DEFINE_METASIG_PARAMS_2(StackCrawlMark_PermissionListSet,    STACKCRAWL_MARK, PERMISSION_LIST_SET)
DEFINE_METASIG_PARAMS_2(Type_CultureInfo,                    TYPE, CULTURE_INFO)
DEFINE_METASIG_PARAMS_2(Type_Exception,                      TYPE, EXCEPTION)
DEFINE_METASIG_PARAMS_2(Type_MarshalByRefObject,             TYPE, MARSHAL_BY_REF_OBJECT)
DEFINE_METASIG_PARAMS_2(Type_MemberInfo,                     TYPE, MEMBER)
DEFINE_METASIG_PARAMS_2(Type_Type,                           TYPE, TYPE)
DEFINE_METASIG_PARAMS_2(TypedByRef_Var,                      TYPED_REFERENCE, VARIANT)
DEFINE_METASIG_PARAMS_2(Assembly_AssemblyRegistrationFlags,  ASSEMBLY, ASSEMBLY_REGISTRATION_FLAGS)
DEFINE_METASIG_PARAMS_2(ArrayList_ArrayList,                 ARRAY_LIST, ARRAY_LIST)

DEFINE_METASIG_PARAMS_3(BindingFlags_Binder_CultureInfo,     BINDING_FLAGS, BINDER, CULTURE_INFO)
DEFINE_METASIG_PARAMS_3(FileMode_FileAccess_FileShare,       FILE_MODE, FILE_ACCESS, FILE_SHARE)
DEFINE_METASIG_PARAMS_3(FrameSecurityDescriptor_IPermission_PermissionToken, 
                                                             FRAME_SECURITY_DESCRIPTOR, IPERMISSION, PERMISSION_TOKEN)
DEFINE_METASIG_PARAMS_3(FrameSecurityDescriptor_PMS_PMS,     FRAME_SECURITY_DESCRIPTOR, PERMISSION_SET, PERMISSION_SET)
DEFINE_METASIG_PARAMS_3(PMS_PMS_PMS,                         PERMISSION_SET, PERMISSION_SET, PERMISSION_SET)
DEFINE_METASIG_PARAMS_3(PMS_Exception_PMS,                         PERMISSION_SET, EXCEPTION, PERMISSION_SET)
DEFINE_METASIG_PARAMS_3(Evidence_Evidence_Evidence,          EVIDENCE, EVIDENCE, EVIDENCE)

DEFINE_METASIG_PARAMS_4(BindingFlags_Binder_ParameterModifier_CultureInfo, BINDING_FLAGS, BINDER, PARAMETER_MODIFIER, CULTURE_INFO)
DEFINE_METASIG_PARAMS_4(PermissionListSet_PMS_PMS_FrameSecurityDescriptor, 
                                                            PERMISSION_LIST_SET, PERMISSION_SET, PERMISSION_SET, FRAME_SECURITY_DESCRIPTOR)
DEFINE_METASIG_PARAMS_4(PMS_PMS_CodeAccessPermission_PermissionToken, 
                                                            PERMISSION_SET, PERMISSION_SET, CODE_ACCESS_PERMISSION, PERMISSION_TOKEN)
DEFINE_METASIG_PARAMS_4(AHA_Ver_CI_ANF, ASSEMBLY_HASH_ALGORITHM, VERSION, CULTURE_INFO, ASSEMBLY_NAME_FLAGS)
DEFINE_METASIG_PARAMS_4(PMS_PMS_ArrayList_ArrayList, PERMISSION_SET, PERMISSION_SET, ARRAY_LIST, ARRAY_LIST)

DEFINE_METASIG_PARAMS_5(BindingFlags_Binder_Type_ParameterModifier_MethodInfo, BINDING_FLAGS, BINDER, TYPE, PARAMETER_MODIFIER, METHOD_INFO)
DEFINE_METASIG_PARAMS_5(PMS_PMS_PMS_PMS_PMS,                 PERMISSION_SET, PERMISSION_SET, PERMISSION_SET, PERMISSION_SET, PERMISSION_SET)

DEFINE_METASIG_PARAMS_6(Evidence_PMS_PMS_PMS_PMS_PMS, EVIDENCE, PERMISSION_SET, PERMISSION_SET, PERMISSION_SET, PERMISSION_SET, PERMISSION_SET)
DEFINE_METASIG_PARAMS_6(BindingFlags_Binder_Type_Type_ParameterModifier_MethodInfo, BINDING_FLAGS, BINDER, TYPE, TYPE, PARAMETER_MODIFIER, METHOD_INFO)
DEFINE_METASIG_PARAMS_6(BindingFlags_Binder_Var_ParameterModifier_CultureInfo_Var, BINDING_FLAGS, BINDER, VARIANT, PARAMETER_MODIFIER, CULTURE_INFO, VARIANT)


// Undefine macros in case we include the file again in the compilation unit

#undef  DEFINE_METASIG
#undef  DEFINE_METASIG_T
#undef  DEFINE_METASIG_PARAMS_1
#undef  DEFINE_METASIG_PARAMS_2
#undef  DEFINE_METASIG_PARAMS_3
#undef  DEFINE_METASIG_PARAMS_4
#undef  DEFINE_METASIG_PARAMS_5
#undef  DEFINE_METASIG_PARAMS_6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\message.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    message.cpp
**
** Author:  Matt Smith (MattSmit)
**
** Purpose: Encapsulates a function call frame into a message 
**          object with an interface that can enumerate the 
**          arguments of the message
**
** Date:    Mar 5, 1999
**
===========================================================*/
#include "common.h"
#include "COMString.h"
#include "COMReflectionCommon.h"
#include "COMDelegate.h"
#include "COMClass.h"
#include "excep.h"
#include "message.h"
#include "ReflectWrap.h"
#include "Remoting.h"
#include "field.h"
#include "eeconfig.h"
#include "invokeutil.h"

BOOL gfBltStack = TRUE;
#ifdef _DEBUG
BOOL g_MessageDebugOut = g_pConfig->GetConfigDWORD(L"MessageDebugOut", 0);
#endif

#define MESSAGEREFToMessage(m) ((MessageObject *) OBJECTREFToObject(m))

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::GetArgCount public
//
//  Synopsis:   Returns number of arguments in the method call
//
//  History:    05-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
FCIMPL1(INT32, CMessage::GetArgCount, MessageObject * pMessage)
{
    LOG((LF_REMOTING, LL_INFO10, "CMessage::GetArgCount IN pMsg:0x%x\n", pMessage));

    // Get the frame pointer from the object

    MetaSig *pSig = GetMetaSig(pMessage);

    // scan the sig for the argument count
    INT32 ret = pSig->NumFixedArgs();

    if (pMessage->pDelegateMD)
    {
        ret -= 2;
    }

    LOG((LF_REMOTING, LL_INFO10, "CMessage::GetArgCount OUT ret:0x%x\n", ret));
    return ret;
}
FCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::GetArg public
//
//  Synopsis:   Use to enumerate a call's arguments
//
//  History:    05-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
LPVOID __stdcall  CMessage::GetArg(GetArgArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();
    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::GetArgCount IN\n"));

    MessageObject *pMsg = MESSAGEREFToMessage(pArgs->pMessage);

    MetaSig *pSig = GetMetaSig(pMsg);

    if ((UINT)pArgs->argNum >= pSig->NumFixedArgs())
    {
        COMPlusThrow(kTargetParameterCountException);
    }
    #if 0
    if (pMsg->iLast != pArgs->argNum-1)
    {
        // skip past the first few
        // if > iLast we don't have to reset.
        if (pMsg->iLast <= pArgs->argNum-1)
        {
            pSig->Reset();
            pMsg->iLast = -1;
        }

        INT32 i;
        for (i = pMsg->iLast; i <= (pArgs->argNum-1); i++)
        {
            pSig->NextArg();
        }
    }
    #endif
    pSig->Reset();
    for (INT32 i = 0; i < (pArgs->argNum); i++)
    {
        pSig->NextArg();
    }

    BOOL fIsByRef = FALSE;
    CorElementType eType = pSig->NextArg();
    EEClass *      vtClass = NULL;
    if (eType == ELEMENT_TYPE_BYREF)
    {
        fIsByRef = TRUE;
        EEClass *pClass;
        eType = pSig->GetByRefType(&pClass);
        if (eType == ELEMENT_TYPE_VALUETYPE)
        {
            vtClass = pClass;
        }
    }
    else
    {
        if (eType == ELEMENT_TYPE_VALUETYPE)
        {
            vtClass = pSig->GetTypeHandle().GetClass();
        }
    }

    if (eType == ELEMENT_TYPE_PTR) 
    {
    COMPlusThrow(kRemotingException, L"Remoting_CantRemotePointerType");
    }
    pMsg->iLast = pArgs->argNum;

    
    OBJECTREF ret = NULL;

    GetObjectFromStack(&ret,
               GetStackPtr(pArgs->argNum, pMsg->pFrame, pSig), 
               eType, 
               vtClass,
               fIsByRef);

    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::GetArg OUT\n"));

    RETURN(ret, OBJECTREF);
}


#define RefreshMsg()   (MESSAGEREFToMessage(pArgs->pMessage))

LPVOID __stdcall  CMessage::GetArgs(GetArgsArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();
    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::GetArgCount IN\n"));

    MessageObject *pMsg = RefreshMsg();

    MetaSig *pSig = GetMetaSig(pMsg);
    // scan the sig for the argument count
    INT32 numArgs = pSig->NumFixedArgs();
    if (RefreshMsg()->pDelegateMD)
        numArgs -= 2;

    // Allocate an object array
    PTRARRAYREF pRet = (PTRARRAYREF) AllocateObjectArray(
        numArgs, g_pObjectClass);

    GCPROTECT_BEGIN(pRet);

    pSig->Reset();
    ArgIterator iter(RefreshMsg()->pFrame, pSig);

    for (int index = 0; index < numArgs; index++)
    {

        BOOL fIsByRef = FALSE;
        CorElementType eType;
        BYTE type;
        UINT32 size;
        PVOID addr;
        eType = pSig->PeekArg();
        addr = (LPBYTE) RefreshMsg()->pFrame + iter.GetNextOffset(&type, &size);

        EEClass *      vtClass = NULL;
        if (eType == ELEMENT_TYPE_BYREF)
        {
            fIsByRef = TRUE;
            EEClass *pClass;
            // If this is a by-ref arg, GetObjectFromStack() will dereference "addr" to
            // get the real argument address. Dereferencing now will open a gc hole if "addr" 
            // points into the gc heap, and we trigger gc between here and the point where 
            // we return the arguments. 
            //addr = *((PVOID *) addr);
            eType = pSig->GetByRefType(&pClass);
            if (eType == ELEMENT_TYPE_VALUETYPE)
            {
                vtClass = pClass;
            }
        }
        else
        {
            if (eType == ELEMENT_TYPE_VALUETYPE)
            {
                vtClass = pSig->GetTypeHandle().GetClass();
            }
        }

        if (eType == ELEMENT_TYPE_PTR) 
        {
            COMPlusThrow(kRemotingException, L"Remoting_CantRemotePointerType");
        }

    
        OBJECTREF arg = NULL;

        GetObjectFromStack(&arg,
                   addr, 
                   eType, 
                   vtClass,
                   fIsByRef);

        pRet->SetAt(index, arg);
    }

    GCPROTECT_END();

    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::GetArgs OUT\n"));

    RETURN(pRet, PTRARRAYREF);
}

void GetObjectFromStack(OBJECTREF* ppDest, PVOID val, const CorElementType eType, EEClass *pCls, BOOL fIsByRef)
{
    THROWSCOMPLUSEXCEPTION();

    TRIGGERSGC();

    // WARNING *ppDest is not protected!
    switch (CorTypeInfo::GetGCType(eType))
    {
        case TYPE_GC_NONE:
        {
            if(ELEMENT_TYPE_PTR == eType)
            {
                COMPlusThrow(kNotSupportedException);
            }
            else
            {
                MethodTable *pMT = TypeHandle(g_Mscorlib.FetchElementType(eType)).AsMethodTable();
                OBJECTREF pObj = FastAllocateObject(pMT);
                if (fIsByRef)
                    val = *((PVOID *)val);
                memcpyNoGCRefs(pObj->UnBox(),val, CorTypeInfo::Size(eType));
                *ppDest = pObj;
            }
        }
        break;
        case TYPE_GC_OTHER:
        {
            if (eType == ELEMENT_TYPE_VALUETYPE) 
            {
                //
                // box the value class
                //

                _ASSERTE(CanBoxToObject(pCls->GetMethodTable()));

                _ASSERTE(!g_pGCHeap->IsHeapPointer((BYTE *) ppDest) ||
                     !"(pDest) can not point to GC Heap");
                OBJECTREF pObj = FastAllocateObject(pCls->GetMethodTable());
                if (fIsByRef)
                    val = *((PVOID *)val);
                CopyValueClass(pObj->UnBox(), val, pObj->GetMethodTable(), pObj->GetAppDomain());

                *ppDest = pObj;
            }
            else
            {
                _ASSERTE(!"unsupported COR element type passed to remote call");
            }
        }
        break;
        case TYPE_GC_REF:
            if (fIsByRef)
                val = *((PVOID *)val);
            *ppDest = ObjectToOBJECTREF(*(Object **)val);
            break;
        default:
            _ASSERTE(!"unsupported COR element type passed to remote call");
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::PropagateOutParameters private
//
//  Synopsis:   Copy back data for in/out parameters and the return value
//
//  History:    05-Mar-99    MattSmit    Created
//              09-Nov-99    TarunA      Removed locals/Fix GC holes
//
//+----------------------------------------------------------------------------
void  __stdcall  CMessage::PropagateOutParameters(PropagateOutParametersArgs *pArgs)
{
    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::PropogateOutParameters IN\n"));

    BEGINFORBIDGC();

    MessageObject *pMsg = MESSAGEREFToMessage(pArgs->pMessage);

    // Copy the metasig so that it does not move due to GC
    MetaSig *pSig = (MetaSig *)_alloca(sizeof(MetaSig)); 
    memcpy(pSig, GetMetaSig(pMsg), sizeof(MetaSig));

    _ASSERTE(pSig != NULL);
    
    ArgIterator argit(pMsg->pFrame, pSig);

    ENDFORBIDGC();

    //**************************WARNING*********************************
    // We should handle GC from now on
    //******************************************************************

    // move into object to return to client

    // Propagate the return value only if the pMsg is not a Ctor message
    // Check if the return type has a return buffer associated with it
    if ( (pMsg->iFlags & MSGFLG_CTOR) == 0  &&  
        pSig->GetReturnType() != ELEMENT_TYPE_VOID)  
    {
        if (pSig->HasRetBuffArg())
        {
            // Copy from pArgs->RetVal into the retBuff.
            INT64 retVal =  CopyOBJECTREFToStack(
                                *((void**) argit.GetRetBuffArgAddr()), 
                                pArgs->RetVal, 
                                pSig->GetReturnType(),
                                NULL,
                                pSig,
                                TRUE);  // copy class contents

            // Refetch variables as GC could have happened after call to CopyOBJECTREFToStack
            pMsg = MESSAGEREFToMessage(pArgs->pMessage);
            // Copy the return value
            *(pMsg->pFrame->GetReturnValuePtr()) = retVal;            
        }
        else
        {
            // There is no separate return buffer, the retVal should fit in 
            // an INT64. 
            INT64 retVal = CopyOBJECTREFToStack(
                                NULL,                   //no return buff
                                pArgs->RetVal, 
                                pSig->GetReturnType(),
                                NULL,
                                pSig,
                                FALSE);                 //don't copy class contents

            // Refetch variables as GC could have happened after call to CopyOBJECTREFToStack
            pMsg = MESSAGEREFToMessage(pArgs->pMessage);
            // Copy the return value
            *(pMsg->pFrame->GetReturnValuePtr()) = retVal;            
        }
    }


    MetaSig *pSyncSig = NULL;
    if (pMsg->iFlags & MSGFLG_ENDINVOKE)
    {
        PCCOR_SIGNATURE pMethodSig;
        DWORD cSig;

        pMsg->pMethodDesc->GetSig(&pMethodSig, &cSig);
        _ASSERTE(pSig);

        pSyncSig = new (_alloca(sizeof(MetaSig))) MetaSig(pMethodSig, pMsg->pDelegateMD->GetModule());
    }
    else
    {
        pSyncSig = NULL;
    }

    // Refetch all the variables as GC could have happened after call to
    // CopyOBJECTREFToStack        
    pMsg = MESSAGEREFToMessage(pArgs->pMessage);
    OBJECTREF *pOutParams = (pArgs->pOutPrms != NULL) ? (OBJECTREF *) pArgs->pOutPrms->GetDataPtr() : NULL;
    UINT32  cOutParams = (pArgs->pOutPrms != NULL) ? pArgs->pOutPrms->GetNumComponents() : 0;
    if (cOutParams > 0)
    {
        BYTE typ;
        UINT32 structSize;
        PVOID *argAddr;
        UINT32 i = 0;
        UINT32 j = 0;
        for (i=0; i<cOutParams; i++)
        {
            if (pSyncSig)
            {
                typ = pSyncSig->NextArg();
                if (typ == ELEMENT_TYPE_BYREF)
                {
                    argAddr = (PVOID *)argit.GetNextArgAddr(&typ, &structSize);
                }
                else if (typ == 0)
                {
                    break;
                }
                else
                {
                    continue;
                }
            }
            else
            {
                argAddr = (PVOID *)argit.GetNextArgAddr(&typ, &structSize);
                if (argAddr == NULL)
                {
                    break;
                }
                else if (typ != ELEMENT_TYPE_BYREF)
                {
                    continue;
                }
            }

            EEClass *pClass = NULL;
            CorElementType brType = pSig->GetByRefType(&pClass);

            CopyOBJECTREFToStack(
                *argAddr, 
                pOutParams[i],
                brType, 
                pClass, 
                pSig,
                pClass ? pClass->IsValueClass() : FALSE);

            // Refetch all the variables because GC could happen at the
            // end of every loop after the call to CopyOBJECTREFToStack                
            pOutParams = (OBJECTREF *) pArgs->pOutPrms->GetDataPtr();                
        }
    }
}

INT64 CMessage::CopyOBJECTREFToStack( 
    PVOID pvDest, OBJECTREF pSrc, CorElementType typ, EEClass *pClass, 
    MetaSig *pSig, BOOL fCopyClassContents)
{
    THROWSCOMPLUSEXCEPTION();

    INT64 ret = 0;
                             
    if (fCopyClassContents)
    {
        // We have to copy the contents of a value class to pvDest

        // write unboxed version back to memory provided by the client
        if (pvDest)
        {
            OBJECTREF or = pSrc;
            if (or == NULL)
            {
                COMPlusThrow(kRemotingException, L"Remoting_Message_BadRetValOrOutArg");
            }
            CopyValueClassUnchecked(pvDest, or->UnBox(), or->GetMethodTable());
            // return the object so it can be stored in the frame and 
            // propagated to the root set
            ret  = *((INT64*) &or);
        }
    }
    else
    {
        // We have either a real OBJECTREF or something that does not have
        // a return buffer associated 

        // Check if it is an ObjectRef (from the GC heap)
        if (CorTypeInfo::IsObjRef(typ))
        {
            OBJECTREF or = pSrc;
            OBJECTREF savedOr = or;

            if ((or!=NULL) && (or->GetMethodTable()->IsTransparentProxyType()))
            {
                GCPROTECT_BEGIN(or);
                if (!pClass)
                    pClass = pSig->GetRetEEClass();
                // CheckCast ensures that the returned object (proxy) gets
                // refined to the level expected by the caller of the method
                if (!CRemotingServices::CheckCast(or, pClass))
                {
                    COMPlusThrow(kInvalidCastException, L"Arg_ObjObj");
                }
                savedOr = or;
                GCPROTECT_END();
            }
            if (pvDest)
            {
                SetObjectReferenceUnchecked((OBJECTREF *)pvDest, savedOr);
            }
            ret = *((INT64*) &savedOr);
        }
        else
        {
            // Note: this assert includes VALUETYPE because for Enums 
            // HasRetBuffArg() returns false since the normalized type is I4
            // so we end up here ... but GetReturnType() returns VALUETYPE
            // Almost all VALUETYPEs will go through the fCopyClassContents
            // codepath instead of here.
            // Also, IsPrimitiveType() does not check for IntPtr, UIntPtr etc
            // there is a note in siginfo.hpp about that ... hence we have 
            // ELEMENT_TYPE_I, ELEMENT_TYPE_U.
            _ASSERTE(
                CorTypeInfo::IsPrimitiveType(typ) 
                || (typ == ELEMENT_TYPE_VALUETYPE)
                || (typ == ELEMENT_TYPE_I)
                || (typ == ELEMENT_TYPE_U)
                || (typ == ELEMENT_TYPE_FNPTR)
                );

            // REVIEW: For a "ref int" arg, if a nasty sink replaces the boxed
            // int with a null OBJECTREF, this is where we check. We need to be
            // uniform in our policy w.r.t. this (throw v/s ignore)
            // The 'if' block above throws, CallFieldAccessor also has this 
            // problem.
            if (pSrc != NULL)
            {
                if (pvDest)
                {
                    memcpyNoGCRefs(
                        pvDest, 
                        pSrc->GetData(), 
                        gElementTypeInfo[typ].m_cbSize);
                }
                ret = *((INT64*) pSrc->GetData());
            }
        }
    }
    return ret;
}
//+----------------------------------------------------------------------------
//
//  Method:     CMessage::GetReturnValue
//
//  Synopsis:   Pull return value off the stack
//
//  History:    13-Dec-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
LPVOID __stdcall CMessage::GetReturnValue(GetReturnValueArgs *pArgs)
{
    MessageObject *pMsg = MESSAGEREFToMessage(pArgs->pMessage);

    MetaSig *pSig = GetMetaSig(pMsg);

    PVOID pvRet;
    if (pSig->HasRetBuffArg())
    {
        ArgIterator argit(pMsg->pFrame,pSig);
        pvRet = argit.GetRetBuffArgAddr();
    }
    else
    {
        pvRet = pMsg->pFrame->GetReturnValuePtr();
    }
    
    CorElementType eType = pSig->GetReturnType();
    EEClass *vtClass; 
    if (eType == ELEMENT_TYPE_VALUETYPE)
    {
        vtClass = pSig->GetRetEEClass();
    }
    else
    {
        vtClass = NULL;
    }
 
    OBJECTREF ret;
    GetObjectFromStack(&ret,
               pvRet,
               eType, 
               vtClass);
               
    RETURN(ret, OBJECTREF);
}

BOOL   __stdcall CMessage::Dispatch(DispatchArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();
    MessageObject *pMsg = MESSAGEREFToMessage(pArgs->pMessage);
    MetaSig *pSig = GetMetaSig(pMsg);
    
    if (!gfBltStack || (pMsg->iFlags & (MSGFLG_BEGININVOKE | MSGFLG_ENDINVOKE | MSGFLG_ONEWAY)))
    {
        return FALSE;
    }

    GCPROTECT_BEGIN(pMsg);

    pSig = GetMetaSig(pMsg);
    UINT nActualStackBytes = pSig->SizeOfActualFixedArgStack(!pSig->HasThis());
    MethodDesc *pMD = pMsg->pMethodDesc;

    // Get the address of the code
    const BYTE *pTarget = MethodTable::GetTargetFromMethodDescAndServer(pMD, &(pArgs->pServer), pArgs->fContext);    

#ifdef PROFILING_SUPPORTED
    // If we're profiling, notify the profiler that we're about to invoke the remoting target
    Thread *pCurThread;
    if (CORProfilerTrackRemoting())
    {
        pCurThread = GetThread();
        _ASSERTE(pCurThread);
        g_profControlBlock.pProfInterface->RemotingServerInvocationStarted(
            reinterpret_cast<ThreadID>(pCurThread));
    }
#endif // PROFILING_SUPPORTED
    
#ifdef _X86_
    // set retval

    INT64 retval = 0;
    INSTALL_COMPLUS_EXCEPTION_HANDLER();

    retval = CallDescrWorker((BYTE*)pMsg->pFrame + sizeof(FramedMethodFrame) + nActualStackBytes,
                             nActualStackBytes / STACK_ELEM_SIZE,
                             (ArgumentRegisters*)(((BYTE *)pMsg->pFrame) + FramedMethodFrame::GetOffsetOfArgumentRegisters()),
                             (LPVOID)pTarget);

    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();

#ifdef PROFILING_SUPPORTED
    // If we're profiling, notify the profiler that we're about to invoke the remoting target
    if (CORProfilerTrackRemoting())
        g_profControlBlock.pProfInterface->RemotingServerInvocationReturned(
            reinterpret_cast<ThreadID>(pCurThread));
#endif // PROFILING_SUPPORTED
    
    pMsg = MESSAGEREFToMessage(pArgs->pMessage);
    pSig = GetMetaSig(pMsg);    
    getFPReturn(pSig->GetFPReturnSize(), retval);
    
    if (pSig->GetReturnType() != ELEMENT_TYPE_VOID)
    {
        *((INT64 *) (MESSAGEREFToMessage(pArgs->pMessage))->pFrame->GetReturnValuePtr()) = retval;
    }    

    GCPROTECT_END();
    
    return TRUE;
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - Dispatch (Message.cpp)");
    return FALSE;
#endif // _X86_
}

LPVOID __stdcall CMessage::GetMethodBase(GetMethodBaseArgs *pArgs)
{
    
    // no need to GCPROTECT - gc is not happening
    MessageObject *pMsg = MESSAGEREFToMessage(pArgs->pMessage);

    // Initialize the message object if necessary
    MetaSig *pSig = GetMetaSig(pMsg);
    
    REFLECTBASEREF ret = GetExposedObjectFromMethodDesc(pMsg->pMethodDesc);
    RETURN(ret, REFLECTBASEREF);
}

HRESULT AppendAssemblyName(CQuickBytes *out, const CHAR* str) 
{
	SIZE_T len = strlen(str) * sizeof(CHAR); 
	SIZE_T oldSize = out->Size();
	if (FAILED(out->ReSize(oldSize + len + 2)))
        return E_OUTOFMEMORY;
	CHAR * cur = (CHAR *) ((BYTE *) out->Ptr() + oldSize - 1);
    if (*cur)
        cur++;
    *cur = ASSEMBLY_SEPARATOR_CHAR;
	memcpy(cur + 1, str, len);	
    cur += (len + 1);
    *cur = '\0';
    return S_OK;
} 

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::GetMethodName public
//
//  Synopsis:   return the method name
//
//  History:    05-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
LPVOID   __stdcall  CMessage::GetMethodName(GetMethodNameArgs *pArgs)
{
    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::GetMethodName IN\n"));

    ReflectMethod *pRM = (ReflectMethod*) pArgs->pMethodBase->GetData();
    //
    // FUTURE:: work around for formatter problem
    //
    LPCUTF8 mName = pRM->pMethod->GetName();
    STRINGREF strMethod;
    if (strcmp(mName, "<init>") == 0)
    {
        strMethod = COMString::NewString("ctor");
    }
    else
    {
        strMethod = COMString::NewString(mName);
    }

    // Now get typeNassembly name
    LPCUTF8 szAssembly = NULL;
    CQuickBytes     qb;
    GCPROTECT_BEGIN(strMethod);

    //Get class
    EEClass *pClass = pRM->pMethod->GetClass();
    //Get type
    REFLECTCLASSBASEREF objType = (REFLECTCLASSBASEREF)pClass->GetExposedClassObject();
    //Get ReflectClass
    ReflectClass *pRC = (ReflectClass *)objType->GetData();
    COMClass::GetNameInternal(pRC, COMClass::TYPE_NAME | COMClass::TYPE_NAMESPACE , &qb);

    Assembly* pAssembly = pClass->GetAssembly();
    pAssembly->GetName(&szAssembly);
    AppendAssemblyName(&qb, szAssembly);

    SetObjectReference((OBJECTREF *)pArgs->pTypeNAssemblyName, COMString::NewString((LPCUTF8)qb.Ptr()), GetAppDomain());

    GCPROTECT_END();

    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::GetMethodName OUT\n"));

    RETURN(strMethod, STRINGREF);
}

FCIMPL0(UINT32, CMessage::GetMetaSigLen)
    DWORD dwSize = sizeof(MetaSig);
    return dwSize;
FCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::Init
//
//  Synopsis:   Initialize internal state
//
//  History:    05-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
VOID   __stdcall  CMessage::Init(InitArgs *pArgs)
{
    // This is called from the managed world and assumed to be
    // idempotent!
    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::Init IN\n"));

    BEGINFORBIDGC();

    GetMetaSig(MESSAGEREFToMessage(pArgs->pMessage));

    ENDFORBIDGC();

    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::Init OUT\n"));
}

MetaSig * __stdcall CMessage::GetMetaSig(MessageObject* pMsg)
{
    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::GetMetaSig IN\n"));
    MetaSig* pEmbeddedMetaSig = (MetaSig*)(pMsg->pMetaSigHolder);

    _ASSERTE(pEmbeddedMetaSig);
    return pEmbeddedMetaSig;

}

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::GetAsyncBeginInfo
//
//  Synopsis:   Pull the AsyncBeginInfo object from an async call
//
//  History:    05-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
LPVOID   __stdcall  CMessage::GetAsyncBeginInfo(GetAsyncBeginInfoArgs *pArgs)
{
    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::GetAsyncBeginInfo IN\n"));

    MessageObject *pMsg = MESSAGEREFToMessage(pArgs->pMessage);

    MetaSig *pSig = GetMetaSig(pMsg);

    _ASSERTE(pMsg->iFlags & MSGFLG_BEGININVOKE);

    ArgIterator argit(pMsg->pFrame, pSig);

    if ((pArgs->ppACBD != NULL) || (pArgs->ppState != NULL))
    {
        BYTE typ;
        UINT32 size;
        LPVOID addr;
        LPVOID last = NULL, secondtolast = NULL;
        while ((addr = argit.GetNextArgAddr(&typ, &size)) != NULL)
        {
            secondtolast = last;
            last = addr;
        }
        if (pArgs->ppACBD != NULL) SetObjectReferenceUnchecked(pArgs->ppACBD, ObjectToOBJECTREF(*(Object **) secondtolast));
        if (pArgs->ppState != NULL) SetObjectReferenceUnchecked(pArgs->ppState, ObjectToOBJECTREF(*(Object **) last));
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::GetAsyncResult
//
//  Synopsis:   Pull the AsyncResult from an async call
//
//  History:    05-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
LPVOID   __stdcall  CMessage::GetAsyncResult(GetAsyncResultArgs *pArgs)
{
    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::GetAsyncResult IN\n"));

    MessageObject *pMsg = MESSAGEREFToMessage(pArgs->pMessage);
    _ASSERTE(pMsg->iFlags & MSGFLG_ENDINVOKE);
    return GetLastArgument(pMsg);
}

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::GetAsyncObject
//
//  Synopsis:   Pull the AsyncObject from an async call
//
//  History:    05-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
LPVOID   __stdcall  CMessage::GetAsyncObject(GetAsyncObjectArgs *pArgs)
{
    LOG((LF_REMOTING, LL_INFO10,
         "CMessage::GetAsyncObject IN\n"));

    MessageObject *pMsg = MESSAGEREFToMessage(pArgs->pMessage);

    MetaSig *pSig = GetMetaSig(pMsg);

    ArgIterator argit(pMsg->pFrame, pSig);

    return *((LPVOID*) argit.GetThisAddr());
}

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::GetLastArgument private
//
//  Synopsis:   Pull the last argument of 4 bytes off the stack
//
//  History:    05-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
LPVOID CMessage::GetLastArgument(MessageObject *pMsg)
{
    BEGINFORBIDGC();

    ArgIterator argit(pMsg->pFrame, GetMetaSig(pMsg));
    BYTE typ;
    UINT32 size;
    LPVOID addr;
    LPVOID backadder = NULL;
    while ((addr = argit.GetNextArgAddr(&typ, &size)) != NULL)
    {
        backadder = addr;
    }

    ENDFORBIDGC();

    return *((LPVOID *) backadder);
}

REFLECTBASEREF __stdcall CMessage::GetExposedObjectFromMethodDesc(MethodDesc *pMD)
{
    ReflectMethod* pRM;
    REFLECTCLASSBASEREF pRefClass = (REFLECTCLASSBASEREF) 
                            pMD->GetClass()->GetExposedClassObject();
    REFLECTBASEREF retVal = NULL;
    GCPROTECT_BEGIN(pRefClass);

    //NOTE: REFLECTION objects are alloced on a non-GC heap. So we don't GCProtect 
    //pRefxxx here.
    if (pMD->IsCtor())
    {
        pRM= ((ReflectClass*) pRefClass->GetData())->FindReflectConstructor(pMD);                  
        retVal = pRM->GetConstructorInfo((ReflectClass*) pRefClass->GetData());
    }
    else
    {
        pRM= ((ReflectClass*) pRefClass->GetData())->FindReflectMethod(pMD);
        retVal = pRM->GetMethodInfo((ReflectClass*) pRefClass->GetData());
    }
    GCPROTECT_END();
    return retVal;
}
//+----------------------------------------------------------------------------
//
//  Method:     CMessage::DebugOut public
//
//  Synopsis:   temp Debug out until the classlibs have one.
//
//  History:    05-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
VOID   __stdcall  CMessage::DebugOut(DebugOutArgs *pArgs)
{
#ifdef _DEBUG
    if (g_MessageDebugOut) 
    {
        WszOutputDebugString(pArgs->pOut->GetBuffer());
    }
#endif

}

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::DebugOutPtr public
//
//  Synopsis:   send raw ptr addr to the debug out
//
//  History:    05-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
VOID   __stdcall  CMessage::DebugOutPtr(DebugOutPtrArgs *pArgs)
{
#ifdef _DEBUG
    if (g_MessageDebugOut) 
    {
        WCHAR buf[64];
        wsprintfW(buf, L"0x%x", pArgs->pOut);
        WszOutputDebugString(buf);
    }
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::HasVarArgs public
//
//  Synopsis:   Return TRUE if the method is a VarArgs Method
//
//  History:    02-Feb-00   MattSmit    Created
//
//+----------------------------------------------------------------------------
FCIMPL1(BOOL, CMessage::HasVarArgs, MessageObject * pMessage)
{
    if (pMessage->pMethodDesc->IsVarArg()) 
        return TRUE;
    else
        return FALSE;
}
FCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::GetVarArgsPtr public
//
//  Synopsis:   Get internal pointer to the VarArgs array
//
//  History:    02-Feb-00   MattSmit    Created
//
//+----------------------------------------------------------------------------
FCIMPL1(PVOID, CMessage::GetVarArgsPtr, MessageObject * pMessage)
{
    return (PVOID) ((pMessage->pFrame) + 1);
}
FCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::GetStackPtr private
//
//  Synopsis:   Figure out where on the stack a parameter is stored
//
//  Parameters: ndx     - the parameter index (zero-based)
//              pFrame  - stack frame pointer (FramedMethodFrame)
//              pSig    - method signature, used to determine parameter sizes
//
//  History:    15-Mar-99    MattSmit    Created
//
//  CODEWORK:   Currently we assume all parameters to be 32-bit intrinsics
//              or 32-bit pointers.  Value classes are not handles correctly.
//
//+----------------------------------------------------------------------------
PVOID CMessage::GetStackPtr(INT32 ndx, FramedMethodFrame *pFrame, MetaSig *pSig)
{
    LOG((LF_REMOTING, LL_INFO100,
         "CMessage::GetStackPtr IN ndx:0x%x, pFrame:0x%x, pSig:0x%x\n",
         ndx, pFrame, pSig));

    BEGINFORBIDGC();

    ArgIterator iter(pFrame, pSig);
    BYTE typ = 0;
    UINT32 size;
    PVOID ret = NULL;

    // CODEWORK:: detect and optimize for sequential access
    _ASSERTE((UINT)ndx < pSig->NumFixedArgs());    
    for (int i=0; i<=ndx; i++)
        ret = iter.GetNextArgAddr(&typ, &size);

    ENDFORBIDGC();

    // If this is a by-ref arg, GetObjectFromStack() will dereference "ret" to
    // get the real argument address. Dereferencing now will open a gc hole if "ret" 
    // points into the gc heap, and we trigger gc between here and the point where 
    // we return the arguments. 
    //if (typ == ELEMENT_TYPE_BYREF)
    //{
    //    return *((PVOID *) ret);
    //}

    return ret;
}

//+----------------------------------------------------------------------------
//
//  Method:     CMessage::MethodAccessCheck public
//
//  Synopsis:   Check caller's access to a method, throw security exception on
//              failure.
//
//  Parameters: method      - MethodBase to check
//              stackMark   - StackCrawlMark used to find caller on stack
//
//  History:    13-Mar-01    RudiM    Created
//
//+----------------------------------------------------------------------------
VOID __stdcall CMessage::MethodAccessCheck(MethodAccessCheckArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    ReflectMethod* pRM = (ReflectMethod*)pArgs->method->GetData();
    RefSecContext sCtx(pArgs->stackMark);
    InvokeUtil::CheckAccess(&sCtx, pRM->attrs, pRM->pMethod->GetMethodTable(), REFSEC_THROW_SECURITY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\memorypool.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _MEMORYPOOL_
#define _MEMORYPOOL_

//
// A MemoryPool is an allocator for a fixed size elements.
// Allocating and freeing elements from the pool is very cheap compared
// to a general allocator like new.  However, a MemoryPool is slightly
// more greedy - it preallocates a bunch of elements at a time, and NEVER
// RELEASES MEMORY FROM THE POOL ONCE IT IS ALLOCATED, (unless you call
// FreeAllElements.)
//
// It also has several additional features:
//	* you can free the entire pool of objects cheaply.
//	* you can test an object to see if it's an element of the pool.	
//

class MemoryPool
{
  public:

	MemoryPool(SIZE_T elementSize, SIZE_T initGrowth = 20, SIZE_T initCount = 0);
	~MemoryPool();

	BOOL IsElement(void *element);
	BOOL IsAllocatedElement(void *element);
	void *AllocateElement();
	void FreeElement(void *element);
	void FreeAllElements();

  private:

	struct Element
	{
		Element *next;
#if _DEBUG
		int		deadBeef;
#endif
	};

	struct Block
	{
		Block	*next;
		Element *elementsEnd;
#pragma warning(push)
#pragma warning(disable:4200)
		Element elements[0];
#pragma warning(pop)
	};

	SIZE_T m_elementSize;
	SIZE_T m_growCount;
	Block *m_blocks;
	Element *m_freeList;

	void AddBlock(SIZE_T elementCount);
	void DeadBeef(Element *element);

 public:

	//
	// NOTE: You can currently only iterate the elements
	// if none have been freed.
	//

	class Iterator
    {
	private:
		Block	*m_next;
		BYTE	*m_e, *m_eEnd;
		BYTE	*m_end;
		SIZE_T	m_size;

	public:
		Iterator(MemoryPool *pool);

		BOOL Next();

		void *GetElement() { return (void *) (m_e-m_size); }
	};

	friend class Iterator;
};

#endif _MEMORYPOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\message.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
    /*============================================================
    **
    ** File:    message.h
    **
    ** Author:  Matt Smith (MattSmit)
    **
    ** Purpose: Encapsulates a function call frame into a message 
    **          object with an interface that can enumerate the 
    **          arguments of the messagef
    **
    ** Date:    Mar 5, 1999
    **
    ===========================================================*/
    #ifndef ___MESSAGE_H___
    #define ___MESSAGE_H___
    
    #include "fcall.h"
    
    void GetObjectFromStack(OBJECTREF* ppDest, PVOID val, const CorElementType eType, EEClass *pCls, BOOL fIsByRef = FALSE);
    
    
    //+----------------------------------------------------------
    //
    //  Struct:     MessageObject
    // 
    //  Synopsis:   Physical mapping of the System.Runtime.Remoting.Message
    //              object.
    //
    //  History:    05-Mar-1999    MattSmit     Created
    //
    //  CODEWORK:   Use metadata and asserts to make sure the 
    //              layout does not change. Hook InitializeRemoting
    //
    //------------------------------------------------------------
    class MessageObject : public Object
    {
        friend class CMessage;
        friend class Binder;

        STRINGREF          pMethodName;    // Method name
        BASEARRAYREF       pMethodSig;     // Array of parameter types
        REFLECTBASEREF     pMethodBase;    // Reflection method object
        OBJECTREF          pHashTable;     // hashtable for properties
        STRINGREF          pURI;           // object's URI
        OBJECTREF          pFault;         // exception
        OBJECTREF          pID;            // not used in VM, placeholder
        OBJECTREF          pSrvID;         // not used in VM, placeholder
        OBJECTREF          pCallCtx;       // not used in VM, placeholder
        OBJECTREF          pArgMapper;     // not used in VM, placeholder
        STRINGREF          pTypeName;       // not used in VM, placeholder
        FramedMethodFrame  *pFrame;
        MethodDesc         *pMethodDesc;
        MethodDesc         *pDelegateMD;
        INT32               iLast;
        INT32               iFlags;
        MetaSig            *pMetaSigHolder;
        INT32               initDone;       // called the native Init routine
    };

#ifdef _DEBUG
    typedef REF<MessageObject> MESSAGEREF;
#else
    typedef MessageObject* MESSAGEREF;
#endif

    // *******
    // Note: Needs to be in sync with flags in Message.cs
    // *******
    enum
    {
        MSGFLG_BEGININVOKE = 0x01,
        MSGFLG_ENDINVOKE   = 0x02,
        MSGFLG_CTOR        = 0x04,
        MSGFLG_ONEWAY      = 0x08,
        MSGFLG_FIXEDARGS   = 0x10,
        MSGFLG_VARARGS     = 0x20
    };
    
    //+----------------------------------------------------------
    //
    //  Class:      CMessage
    // 
    //  Synopsis:   EE counterpart to Microsoft.Runtime.Message.
    //              Encapsulates code to read a function call 
    //              frame into an interface that can enumerate
    //              the parameters.
    //
    //  History:    05-Mar-1999    MattSmit     Created
    //
    //------------------------------------------------------------
    class CMessage
    {
    public:
    
       // Methods used for stack walking
       struct GetArgCountArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF, pMessage );
       };
    #ifdef FCALLAVAILABLE
       static FCDECL1(INT32, GetArgCount, MessageObject *pMsg);
    #else
       static INT32 __stdcall GetArgCount (GetArgCountArgs *pArgs);
    #endif
       
       struct GetArgArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( MESSAGEREF, pMessage );
           DECLARE_ECALL_I4_ARG       ( INT32, argNum );
       };
       static LPVOID    __stdcall  GetArg     (GetArgArgs *pArgs);
    
       struct GetArgsArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( MESSAGEREF, pMessage );
       };
       static LPVOID    __stdcall  GetArgs     (GetArgsArgs *pArgs);
    
       struct PropagateOutParametersArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( MESSAGEREF, pMessage );
           DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF, RetVal );
           DECLARE_ECALL_OBJECTREF_ARG( BASEARRAYREF, pOutPrms );

       };
       static void     __stdcall  PropagateOutParameters(PropagateOutParametersArgs *pArgs);
       
       struct GetReturnValueArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( MESSAGEREF, pMessage );
       };
       static LPVOID    __stdcall  GetReturnValue(GetReturnValueArgs *pArgs);
       
       struct GetMethodNameArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( STRINGREF *, pTypeNAssemblyName );
           DECLARE_ECALL_OBJECTREF_ARG( REFLECTBASEREF, pMethodBase );
       };
       static LPVOID   __stdcall  GetMethodName(GetMethodNameArgs *pArgs);
       
       struct GetMethodBaseArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( MESSAGEREF, pMessage );
       };
       static LPVOID __stdcall  GetMethodBase(GetMethodBaseArgs *pArgs);
       
       struct InitArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( MESSAGEREF, pMessage );
       };
       static void     __stdcall  Init(InitArgs *pArgs);
       
       struct GetAsyncBeginInfoArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( MESSAGEREF, pMessage );
           DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF*, ppState);
           DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF*, ppACBD);
       };
       static LPVOID   __stdcall  GetAsyncBeginInfo(GetAsyncBeginInfoArgs *pArgs);
       
       struct GetAsyncResultArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( MESSAGEREF, pMessage );
       };
       static LPVOID   __stdcall  GetAsyncResult(GetAsyncResultArgs *pArgs);

       struct GetAsyncObjectArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( MESSAGEREF, pMessage );
       };
       static LPVOID   __stdcall  GetAsyncObject(GetAsyncObjectArgs *pArgs);
       
       struct DebugOutArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( STRINGREF, pOut );
       };
       static void     __stdcall  DebugOut(DebugOutArgs *pArgs);
    
       struct DebugOutPtrArgs
       {
           DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF, pOut );
       };
       static void     __stdcall  DebugOutPtr(DebugOutPtrArgs *pArgs);
    
       static void     __fastcall Break()
       {
           DebugBreak();
       }
       
       
       struct DispatchArgs 
       {
           DECLARE_ECALL_OBJECTREF_ARG( MESSAGEREF,    pMessage);
           DECLARE_ECALL_I4_ARG       (BOOL, fContext);
           DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF,    pServer);
       };
       static BOOL    __stdcall Dispatch(DispatchArgs *target);

       static FCDECL0(UINT32, GetMetaSigLen);
       static FCDECL1(BOOL, CMessage::HasVarArgs, MessageObject * poMessage);
       static FCDECL1(PVOID, CMessage::GetVarArgsPtr, MessageObject * poMessage);

        struct MethodAccessCheckArgs
        {
            DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, method); 
        };
        static void __stdcall MethodAccessCheck(MethodAccessCheckArgs *pArgs);
       
       // private helpers
    private:
       static REFLECTBASEREF GetExposedObjectFromMethodDesc(MethodDesc *pMD);
       static PVOID GetStackPtr(INT32 ndx, FramedMethodFrame *pFrame, MetaSig *pSig);       
       static MetaSig* GetMetaSig(MessageObject *pMsg);
       static INT64 __stdcall CallMethod(const void *pTarget,
                                         INT32 cArgs,
                                         FramedMethodFrame *pFrame,
                                         OBJECTREF pObj);
       static INT64 CopyOBJECTREFToStack(PVOID pvDest, OBJECTREF pSrc,
                     CorElementType typ, EEClass *pClass, MetaSig *pSig,
                     BOOL fCopyClassContents);
       static LPVOID GetLastArgument(MessageObject *pMsg);
    };
    
    #endif // ___MESSAGE_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\methodimpl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: MethodImpl.CPP
//
// ===========================================================================
//
// ===========================================================================
//

#include "common.h"
#include "methodimpl.h"

MethodDesc *MethodImpl::FindMethodDesc(DWORD slot, MethodDesc* defaultReturn)
{
    if(pdwSlots == NULL) return defaultReturn;

    DWORD dwSize = *pdwSlots;
    if(dwSize == 0) return defaultReturn;

    DWORD l = 1;      // the table is biased by one. The first entry is the size
    DWORD r = dwSize;
    DWORD pivot;
    while(1) {
        pivot =  (l + r) / 2;
        if(pdwSlots[pivot] == slot)
            break; // found it
        else if(pdwSlots[pivot] < slot) 
            l = pivot + 1;
        else
            r = pivot - 1;

        if(l > r) return defaultReturn; // Not here
    }

    MethodDesc *result = pImplementedMD[pivot-1]; // The method descs are not offset by one

    // Prejitted images may leave NULL in this table if
    // the methoddesc is declared in another module.
    // In this case we need to manually compute & restore it
    // from the slot number.

    if (result == NULL)
        result = RestoreSlot(pivot-1, defaultReturn->GetMethodTable());

    return result;
}

MethodDesc *MethodImpl::RestoreSlot(DWORD index, MethodTable *pMT)
{
    MethodDesc *result;

    DWORD slot = pdwSlots[index+1];

    // Since the overridden method is in a different module, we 
    // are guaranteed that it is from a different class.  It is
    // either an override of a parent virtual method or parent-implemented
    // interface, or of an interface that this class has introduced.  
            
    // In the former 2 cases, the slot number will be in the parent's 
    // vtable section, and we can retrieve the implemented MethodDesc from
    // there.  In the latter case, we can search through our interface
    // map to determine which interface it is from.

    EEClass *pParentClass = pMT->GetClass()->GetParentClass();
    if (pParentClass != NULL
        && slot < pParentClass->GetNumVtableSlots())
    {
        result = pParentClass->GetMethodDescForSlot(slot);
    }
    else
    {
        _ASSERTE(slot < pMT->GetClass()->GetNumVtableSlots());
                
        InterfaceInfo_t *pInterface = pMT->GetInterfaceForSlot(slot);
        _ASSERTE(pInterface != NULL);

        result = pInterface->m_pMethodTable->
          GetMethodDescForSlot(slot - pInterface->m_wStartSlot);
    }
            
    _ASSERTE(result != NULL);

    // Don't worry about races since we would all be setting the same result
    pImplementedMD[index] = result;

    return result;
}

MethodImpl* MethodImpl::GetMethodImplData(MethodDesc* pDesc)
{
    if(pDesc->IsMethodImpl() == FALSE)
        return NULL;
    else {
        MethodImpl* pImpl = NULL;
        switch(pDesc->GetClassification()) {
        case mcNDirect:
            pImpl = ((MI_NDirectMethodDesc*) pDesc)->GetImplData();
            break;
        case mcECall:
        case mcIL:
        case mcEEImpl:
            pImpl = ((MI_MethodDesc*) pDesc)->GetImplData();
            break;
        case mcComInterop:
            pImpl = ((MI_ComPlusCallMethodDesc*) pDesc)->GetImplData();
            break;
        default:
            _ASSERTE(!"We have an invalid method type for a method impl body");
        }
        
        return pImpl;
    }
}

MethodDesc* MethodImpl::GetFirstImplementedMD(MethodDesc *pContainer)
{
    _ASSERTE(GetSize() > 0);
    _ASSERTE(pImplementedMD != NULL);

    MethodDesc *pMD = pImplementedMD[0];

    if (pMD == NULL)
    {
        // Restore slot in prejit image if necessary
        RestoreSlot(0, pContainer->GetMethodTable());
        pMD = pImplementedMD[0];
        _ASSERTE(pMD != NULL);
    }

    return pImplementedMD[0];
}

HRESULT MethodImpl::Save(DataImage *image, mdToken attributed)
{
    HRESULT hr;

    DWORD size = GetSize();

    if (size > 0)
    {
        IfFailRet(image->StoreStructure(pdwSlots, (size+1)*sizeof(DWORD), 
                                        DataImage::SECTION_METHOD_DESC, 
                                        DataImage::DESCRIPTION_METHOD_DESC, 
                                        attributed, 1));
        IfFailRet(image->StoreStructure(pImplementedMD, size*sizeof(MethodDesc*), 
                                        DataImage::SECTION_METHOD_DESC, 
                                        DataImage::DESCRIPTION_METHOD_DESC, 
                                        attributed, 1));
    }

    return S_OK;
}

HRESULT MethodImpl::Fixup(DataImage *image, Module *pContainingModule, BOOL recursive)
{
    HRESULT hr;

    DWORD size = GetSize();

    if (size > 0)
    {
        if (recursive)
        {
            MethodDesc **pMD = pImplementedMD;
            MethodDesc **pMDEnd = pMD + size;
            while (pMD < pMDEnd)
            {
                if ((*pMD)->GetModule() == pContainingModule)
                    IfFailRet(image->FixupPointerField(pMD++));
                else
                    IfFailRet(image->ZeroPointerField(pMD++));
            }
        }

        IfFailRet(image->FixupPointerField(&pdwSlots));
        IfFailRet(image->FixupPointerField(&pImplementedMD));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\method.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// method.hpp
//
#ifndef _METHOD_H
#define _METHOD_H

#include "cor.h"
#include "util.hpp"
#include "clsload.hpp"
#include "codeman.h"
#include "class.h"
#include "siginfo.hpp"
#include "DeclSec.h"
#include "methodimpl.h"
#include <stddef.h>
#include <member-offset-info.h>

class Stub;
class ECallMethodDesc;
class LivePointerInfo;
class FieldDesc;
class NDirect;
class MethodDescChunk;
struct MLHeader;

#ifdef _X86_
#define TOKEN_IN_PREPAD 1
#endif


//=============================================================
// Splits methoddef token into a 1-byte and 2-byte piece for
// storage inside a methoddesc.
//=============================================================
FORCEINLINE BYTE GetTokenRange(mdToken tok)
{
    return (BYTE)(tok>>16);
}

FORCEINLINE VOID SplitToken(mdToken tok, BYTE *ptokrange, UINT16 *ptokremainder)
{
    *ptokrange = (BYTE)(tok>>16);                  
    *ptokremainder = (UINT16)(tok & 0x0000ffff);
}

FORCEINLINE mdToken MergeToken(BYTE tokrange, UINT16 tokremainder)
{
    return (tokrange << 16) | tokremainder;
}

#define mdUnstoredMethodBits ((DWORD)(nmdReserved1|nmdReserved2))

// The MethodDesc is a union of several types. The following
// 3-bit field determines which type it is. Note that JIT'ed/non-JIT'ed
// is not represented here because this isn't known until the
// method is executed for the first time. Because any thread could
// change this bit, it has to be done in a place where access is
// synchronized.

// @FUTURE: public/private/family/assembly/... bits can be folded into 3 bits

//#define mdMethodClassificationMask (mdReserved1|mdReserved2|mdReserved3);


// **** NOTE: if you add any new flags, make sure you add them to ClearFlagsOnUpdate
// so that when a method is replaced its relevant flags are updated

// Used in MethodDesc
enum MethodClassification
{
    mcIL        = 0, // IL
    mcECall     = 1, // ECall
    mcNDirect   = 2, // N/Direct
    mcEEImpl    = 3, // special method; implementation provided by EE
    mcArray     = 4, // Array ECall

    // This needs a little explanation.  There are MethodDescs on MethodTables
    // which are Interfaces.  These have the mdcInterface bit set.  Then there
    // are MethodDescs on MethodTables that are Classes, where the method is
    // exposed through an interface.  These do not have the mdcInterface bit set.
    //
    // So, today, a dispatch through an 'mdcInterface' MethodDesc is either an
    // error (someone forgot to look up the method in a class' VTable) or it is
    // a case of COM Interop.

    mcComInterop  = 5, 
};


// All flags in the MethodDesc now reside in a single 16-bit field. In the
// enumeration below, multi-bit fields are represented as a mask together with a
// shift to move the value to bit 0.

// *** NOTE ***
// mdcClassification, mdcNoPrestub, and mdcMethodDesc need to be adjacent and located starting
// at bit 0 for the logic in GetMethodTable to work.
// *** NOTE ***

enum MethodDescClassification
{
    
    // Method is IL, ECall etc., see MethodClassification above.
    mdcClassification                   = 0x0007,
    mdcClassificationShift              = 0,

    // Method is a body for a method impl (can be used to implement several declarations)
    mdcMethodImpl                       = 0x0008,

    // Method is static
    mdcStatic                           = 0x0010,

    // Is this method elligible for inlining?
    // For ECalls this bit means 'is and FCall' (the native code is not shared)
    mdcInlineEligibility                = 0x0020,

    // Temporary Security Interception.
    // Methods can now be intercepted by security. An intercepted method behaves
    // like it was an interpreted method. The Prestub at the top of the method desc
    // is replaced by an interception stub. Therefore, no back patching will occur.
    // We picked this approach to minimize the number variations given IL and native
    // code with edit and continue. E&C will need to find the real intercepted method
    // and if it is intercepted change the real stub. If E&C is enabled then there
    // is no back patching and needs to fix the pre-stub.
    mdcIntercepted                      = 0x0040,

    // Method requires linktime security checks.
    mdcRequiresLinktimeCheck            = 0x0080,

    // Method requires inheritance security checks.
    // If this bit is set, then this method demands inheritance permissions
    // or a method that this method overrides demands inheritance permissions
    // or both.
    mdcRequiresInheritanceCheck         = 0x0100,

    // The method that this method overrides requires an inheritance security check.
    // This bit is used as an optimization to avoid looking up overridden methods
    // during the inheritance check.
    mdcParentRequiresInheritanceCheck   = 0x0200,

    // Duplicate method.
    mdcDuplicate                        = 0x0400,

    // Method is a new virtual function added through EditAndContinue.
    mdcEnCNewVirtual                    = 0x0800,

    // Has this method been verified?
    mdcVerifiedState                    = 0x1000,

    // Does the method have nonzero security flags?
    mdcHasSecurity                      = 0x2000,

    // Is the method synchronized
    mdcSynchronized                     = 0x4000,

    // IsPrejitted is set if the method has prejitted code
    //
    // @nice: this flag is actually redundant with state in the
    // prestub & home vtable slot of the MD.  It's just too hard
    // to figure out how to untangle the mess of all the GetAddrofCode 
    // variants & not break anything.
    mdcPrejitted                        = 0x8000

};

extern unsigned g_ClassificationSizeTable[];

//
// Note: no one is allowed to use this mask outside of method.hpp and method.cpp. Don't make this public! Keep this
// version in sync with the version in the top of method.cpp.
//
#ifdef _IA64_
#define METHOD_IS_IL_FLAG   0xC000000000000000
#else
#define METHOD_IS_IL_FLAG   0xC0000000
#endif

// This is the maximum allowed RVA for a method.
#define METHOD_MAX_RVA      ~0xC0000000

//
// <3 byte pad> <5 byte stub> <Method...>
// |                        | |
//  \    MEMBER_ALIGN_PAD  /   \ this...
//
//
// The size of this structure needs to be a multiple of 8-bytes
// in 32-bit and a multiple of 16-bytes in 64-bit.  The reason
// 64-bit requires such a large alignment size is that all bundles
// must be 16-byte aligned and we have two bundles that precede
// this class.
//
// The following members guarantee this alignment:
//
//  m_DebugAlignPad
//  m_Align1
//  m_Align2
// 
// If the layout of this struct changes, these need to be 
// revisited to make sure the alignment is maintained.
//
class MethodDesc
{
// Make EEClass::BuildMethodTable() a friend function. This allows us to not provide any
// Seters.  Only BuildMethodTable should modify entrys in the methoddesc and by making
// all members private this restriction is enforced!
    friend HRESULT EEClass::BuildMethodTable(Module *pModule,
                                             mdToken cl,
                                             BuildingInterfaceInfo_t *pBuildingInterfaceList,
                                             const LayoutRawFieldInfo *pLayoutRawFieldInfos,
                                             OBJECTREF *pThrowable);
    friend class EEClass;
    friend class ArrayClass;
    friend NDirect;
    friend MethodDescChunk;
    friend class MDEnums;
    friend class MethodImpl;
    friend HRESULT InitializeMiniDumpBlock();
    friend struct MEMBER_OFFSET_INFO(MethodDesc);

public:
    enum
    {
#ifdef _IA64_
        ALIGNMENT_SHIFT = 4,
#else
        ALIGNMENT_SHIFT = 3,
#endif

        ALIGNMENT       = (1<<ALIGNMENT_SHIFT),
        ALIGNMENT_MASK  = (ALIGNMENT-1)
    };

    // @TODO: There is a much better way to fix the following and that is to
    //        make the non-x86 side of CallDescr handle GetSig differently.
    //        This is here temporarily as a quick fix since this breaks the
    //        Alpha build.
    INT64 CallDescr(const BYTE *pTarget, Module *pModule, MetaSig* sig, BOOL fIsStatic, const BYTE *pArguments);

    INT64 CallDescr(const BYTE *pTarget, Module *pModule, PCCOR_SIGNATURE pSig, BOOL fIsStatic, const INT64 *pArguments);

    INT64 CallDescr(const BYTE *pTarget, Module *pModule, MetaSig* pMetaSig, BOOL fIsStatic, const INT64 *pArguments);

#ifdef _DEBUG

    // These are set only for MethodDescs but every time I want to use the debugger
    // to examine these fields, the code has the silly thing stored in a MethodDesc*.
    // So...
    LPCUTF8         m_pszDebugMethodName;
    LPUTF8          m_pszDebugClassName;
    LPUTF8          m_pszDebugMethodSignature;
    EEClass        *m_pDebugEEClass;
    MethodTable    *m_pDebugMethodTable;

#ifdef STRESS_HEAP
    class GCCoverageInfo* m_GcCover;
#else // !STRESS_HEAP
    DWORD_PTR       m_DebugAlignPad; // 32-bit: fixes 8-byte align, 64-bit: fixes 16-byte align
#endif // !STRESS_HEAP
#endif // !_DEBUG

    // return the address of the stub
    inline BYTE *GetPreStubAddr()
    {
        return ((BYTE *) this) - METHOD_CALL_PRESTUB_SIZE;
    }

    // return the address of the stub
    static MethodDesc *GetMethodDescFromStubAddr(BYTE *addr)
    {
        return (MethodDesc *) (addr + METHOD_CALL_PRESTUB_SIZE);
    }

    DWORD GetAttrs();
    
    DWORD GetImplAttrs();
    
    // This function can lie if a method impl was used to implement
    // more then one method on this class. Use GetName(int) to indiciate
    // which slot you are interested in.
    LPCUTF8 GetName();

    LPCUTF8 GetName(USHORT slot);
    
    BOOL IsCompressedIL();
    
    FORCEINLINE LPCUTF8 GetNameOnNonArrayClass()
    {
        return (GetMDImport()->GetNameOfMethodDef(GetMemberDef()));
    }

    DWORD IsStaticInitMethod()
    {
        return IsMdClassConstructor(GetAttrs(), GetName());
    }
    
    inline BOOL IsMethodImpl()
    {
        return mdcMethodImpl & m_wFlags;
    }

    inline void SetMethodImpl(BOOL bIsMethodImpl)
    {
        m_wFlags = (WORD)((m_wFlags & ~mdcMethodImpl) |
                          (bIsMethodImpl ? mdcMethodImpl : 0));
    }

    inline DWORD IsStatic()
    {
        // This bit caches the following check:
        _ASSERTE(((m_wFlags & mdcStatic) != 0) == (IsMdStatic(GetAttrs()) != 0));

        return (m_wFlags & mdcStatic) != 0;
    }
    
    inline void SetStatic()
    {
        m_wFlags |= mdcStatic;
    }
    
    inline DWORD IsIL()
    {
        return mcIL == GetClassification();
    }
    
    inline DWORD IsECall()
    {
        return mcECall == GetClassification()
            || mcArray == GetClassification();
    }
    
    inline DWORD IsArray()
    {
        return mcArray == GetClassification();
    }
    
    inline DWORD IsEEImpl()
    {
        return mcEEImpl == GetClassification();
    }
    
    inline DWORD IsNDirect()
    {
        return mcNDirect == GetClassification();
    }
    
    inline DWORD IsInterface()
    {
        return GetMethodTable()->IsInterface();
    }
    
    inline DWORD IsComPlusCall()
    {
        return mcComInterop == GetClassification();
    }
    
    inline DWORD IsIntercepted()
    {
        return m_wFlags & mdcIntercepted;
    }

    // If the method is in an Edit and Contine (EnC) module, then
    // we DON'T want to backpatch this, ever.  We MUST always call
    // through the MethodDesc's PrestubAddr (5 bytes before the MethodDesc)
    // so that we can restore those bytes to "call prestub" if we want
    // to update the method.
    // 
    inline DWORD IsEnCMethod()
    {
        return GetModule()->IsEditAndContinue();
    }

    inline BOOL IsNotInline()
    {
        return (m_wFlags & mdcInlineEligibility);
    }
    
    // check if this methoddesc needs to be intercepted 
    // by the context code
    BOOL IsRemotingIntercepted()
    {
        EEClass *pClass = GetClass();
        return !IsVtableMethod() && !IsStatic() && (pClass->IsMarshaledByRef() || 
                                                    pClass->GetMethodTable() == g_pObjectClass);
    }

    // check if this needs to be intercepted by the context code
    // without using the methoddesc.
    // Happens if a virtual function is called non-virtually
    BOOL IsRemotingIntercepted2()
    {
        EEClass * pClass = GetClass();
        return IsVtableMethod() &&
            (pClass->IsMarshaledByRef() || pClass->GetMethodTable() == g_pObjectClass);
    }

    BOOL MayBeRemotingIntercepted()
    {
        EEClass * pClass = GetClass();
        return !IsStatic() &&
            (pClass->IsMarshaledByRef() || pClass->GetMethodTable() == g_pObjectClass);
    }

    // Does it represent a one way method call with no out/return parameters?
    inline BOOL IsOneWay()
    {
        return (S_OK == GetMDImport()->GetCustomAttributeByName(GetMemberDef(),
                                                                "System.Runtime.Remoting.Messaging.OneWayAttribute",
                                                                NULL,
                                                                NULL));

    }

    // If TRUE, the method is an FCALL, however might return
    // FALSE for FCALLs too if the FCALL has not been called
    // at least once.  (prestub has looked it up)
    inline BOOL MustBeFCall()
    {
        return (IsECall() && (m_wFlags & mdcInlineEligibility));
    }
    
    inline void SetNotInline(BOOL bEligibility)
    {
        if (IsECall()) return;      // we reuse the bit for ECall
        m_wFlags = (WORD)((m_wFlags & ~mdcInlineEligibility) |
                          (bEligibility ? mdcInlineEligibility : 0));
    }
    
    inline void SetFCall(BOOL fCall)
    {
        _ASSERTE(IsECall());        // we reuse the bit for ECall
        if (fCall)
            m_wFlags |= mdcInlineEligibility;
        else 
            m_wFlags &= ~mdcInlineEligibility;
    }
    
    
    inline BOOL IsVerified()
    {
        return m_wFlags & mdcVerifiedState;
    }
    
    inline void SetIsVerified(BOOL bIsVerified)
    {
        m_wFlags = (WORD)((m_wFlags & ~mdcVerifiedState) |
                          (bIsVerified ? mdcVerifiedState : 0));
    }

    BOOL CouldBeFCall();
    BOOL PointAtPreStub();

    inline void ClearFlagsOnUpdate()
    {
        SetIsVerified(FALSE);
        SetNotInline(FALSE);
    }
    
    BOOL IsVarArg();
    
    // Is this a stub used to unbox a value class prior to calling
    // and instance method?
    DWORD IsUnboxingStub();
    
    DWORD SetIntercepted(BOOL set);
    
    BOOL IsVoid();
    

    //================================================================
    // The following two methods are used to facilitate the use of
    // metadata instead of calldescrs in a separate section
    
    void SetClassification(DWORD dwClassification)
    {
        _ASSERTE(dwClassification <= mcComInterop);
        m_wFlags  = (WORD)((m_wFlags & ~mdcClassification) |
                           (dwClassification << mdcClassificationShift));
    }

    BOOL IsJitted()
    {
        return !((m_CodeOrIL & METHOD_IS_IL_FLAG) == METHOD_IS_IL_FLAG);
    }
    
    // IL RVA stored in same field as code address, but high bit set to
    // discriminate.
    ULONG GetRVA();

    void SetRVA(ULONG rva)
    {
        _ASSERTE(rva <= METHOD_MAX_RVA);
        ClearPrejitted();
        m_CodeOrIL = rva | METHOD_IS_IL_FLAG;
    }

    inline DWORD HasNativeRVA()
    {
        return IsPrejitted() && !IsJitted();
    }
    
    inline DWORD GetNativeRVA()
    {
        _ASSERTE(HasNativeRVA());
        return (DWORD)(m_CodeOrIL & ~METHOD_IS_IL_FLAG);
    }

    void *GetPrejittedCode();

    //==================================================================
    
    COR_ILMETHOD* GetILHeader();
    
    LivePointerInfo* GetLivePointerInfo( const BYTE *IP );
    
    BOOL HasStoredSig()
    {
        return IsArray() || IsECall() || IsEEImpl();
    }

    PCCOR_SIGNATURE GetSig();
    
    void GetSig(PCCOR_SIGNATURE *ppSig, DWORD *pcSig);
    
    IMDInternalImport* GetMDImport()
    {
        return GetModule()->GetMDImport();
    }
        
    IMetaDataEmit* GetEmitter()
    {
        return GetModule()->GetEmitter();
    }
    
    IMetaDataImport* GetImporter()
    {
        return GetModule()->GetImporter();
    }
    
    LONG GetComSlot();
    
    LONG GetComDispid();
    
    inline DWORD IsCtor()
    {
        return IsMdInstanceInitializer(GetAttrs(), GetName());
    }
    
    inline DWORD IsStaticOrPrivate()
    {
        DWORD attr = GetAttrs();
        return IsMdStatic(attr) || IsMdPrivate(attr);
    }
    
    inline DWORD IsFinal()
    {
        return IsMdFinal(GetAttrs());
    }

    inline void SetSynchronized()
    {
        m_wFlags |= mdcSynchronized;
    }
    
    inline DWORD IsSynchronized()
    {
        return (m_wFlags & mdcSynchronized) != 0;
    }
    
    inline void ClearPrejitted()
    {
        m_wFlags &= ~mdcPrejitted;
    }
        
    inline DWORD IsPrejitted()
    {
        return (m_wFlags & mdcPrejitted) != 0;
    }
    
    // does not necessarily return TRUE if private
    inline DWORD IsPrivate()
    {
        return IsMdPrivate(GetAttrs());
    }

    inline DWORD IsPublic()
    {
        return IsMdPublic(GetAttrs());
    }

    inline DWORD IsProtected()
    {
        return IsMdFamily(GetAttrs());
    }

    inline DWORD IsVtableMethod()
    {
        return GetSlot() < GetClass()->GetNumVtableSlots();
    }

    // does not necessarily return TRUE if virtual
    inline DWORD IsVirtual()
    {
        return IsMdVirtual(GetAttrs());
    }

    // does not necessarily return TRUE if abstract
    inline DWORD IsAbstract()
    {
        return IsMdAbstract(GetAttrs());
    }

    // duplicate methods
    inline BOOL  IsDuplicate()
    {
        return m_wFlags & mdcDuplicate;
    }

    void SetDuplicate()
    {
        // method table is not setup yet
        //_ASSERTE(!GetClass()->IsInterface());
        m_wFlags |= mdcDuplicate;
    }

    // Sparse methods are those that belong to an interface whose VTable
    // representation is sparse.
    inline BOOL IsSparse()
    {
        return GetMethodTable()->IsSparse();
    }

    inline BOOL IsEnCNewVirtual()
    {
        return m_wFlags & mdcEnCNewVirtual;
    }

    inline void SetEnCNewVirtual()
    {
        m_wFlags |= mdcEnCNewVirtual;
    }

    void SetSlot(WORD slot)
    {
        m_wSlotNumber = slot;
    }

    inline DWORD DontVirtualize()
    {
        return !IsVtableMethod();

        /*
        // DO: I commented this out.  I believe
        //  this is all code that tries to guess virutalness
        //  instead of looking at the virtual flag.
        if (IsMdRTSpecialName(attrs) ||
            IsMdStatic(attrs) ||
            IsMdPrivate(attrs) ||
            IsMdFinal(attrs))
            return TRUE;

        if (IsInterface())
            return TRUE;

        if (IsTdSealed(GetClass()->GetAttrClass()))
            return TRUE;

        return FALSE;
        */
    }

    inline EEClass* GetClass()
    {
        return GetMethodTable()->GetClass();
    }

    inline SLOT *GetVtable()
    {
        return GetMethodTable()->GetVtable();
    }

    inline MethodTable* GetMethodTable();   

    inline WORD GetSlot()
    {
        return m_wSlotNumber;
    }


    inline DWORD RequiresLinktimeCheck()
    {
        return m_wFlags & mdcRequiresLinktimeCheck;
    }

    inline DWORD RequiresInheritanceCheck()
    {
        return m_wFlags & mdcRequiresInheritanceCheck;
    }

    inline DWORD ParentRequiresInheritanceCheck()
    {
        return m_wFlags & mdcParentRequiresInheritanceCheck;
    }

    void SetRequiresLinktimeCheck()
    {
        m_wFlags |= mdcRequiresLinktimeCheck;
    }

    void SetRequiresInheritanceCheck()
    {
        m_wFlags |= mdcRequiresInheritanceCheck;
    }

    void SetParentRequiresInheritanceCheck()
    {
        m_wFlags |= mdcParentRequiresInheritanceCheck;
    }

    // fThrowException is used to prevent Verifier from
    // throwin an exception on error
    // fForceVerify is to be used by tools that need to
    // force verifier to verify code even if the code is fully trusted.
    HRESULT Verify(COR_ILMETHOD_DECODER* ILHeader, 
                   BOOL fThrowException, 
                   BOOL fForceVerify);

        BOOL InterlockedReplaceStub(Stub** ppStub, Stub *pNewStub);

        mdMethodDef GetMemberDef();

#ifdef _DEBUG
     private:
            void SMDDebugCheck(mdMethodDef mb);
#endif
     public:

        void SetMemberDef(mdMethodDef mb);

    // Set the offset of this method desc in a chunk table (which allows us
    // to work back to the method table/module pointer stored at the head of
    // the table.
    void SetChunkIndex(DWORD index, int flags)
    {
        // Calculate size of each method desc.
        DWORD size = g_ClassificationSizeTable[flags & (mdcClassification|mdcMethodImpl)];

        // Calculate the negative offset (mod 8) from the chunk table header.
        _ASSERTE((size & ALIGNMENT_MASK) == 0);
        DWORD offset = -(int)(index * (size >> ALIGNMENT_SHIFT));


#ifdef TOKEN_IN_PREPAD
        GetStubCallInstrs()->m_chunkIndex = (BYTE)offset;
#else
        // Fill in the offset in the top eight bits of the token field
        // (since we don't need the token type).
        m_dwToken &= 0x00FFFFFF;
        m_dwToken |= offset << 24;
#endif
        }

    // There are two overloads of GetAddrofCode.  If you have a static, or a
    // function, or you are (somehow!) guaranteed not to be thunking, use the
    // simple version.
    //
    // If this is an instance method, you should typically use the complex
    // overload so that we can do "virtual methods" correctly, including any
    // handling of context proxies and other thunking layers.
    //
    // Only call GetUnsafeAddrofCode() if you know what you are doing.  If
    // you can guarantee that no virtualization is necessary, or if you can
    // guarantee that it has already happened.  For instance, the frame of a
    // stackwalk has obviously been virtualized as much as it will be.
    const BYTE* GetAddrofCode();
    const BYTE* GetAddrofCode(OBJECTREF orThis);
    const BYTE* GetAddrofCodeNonVirtual();

    // @TODO - LBS Clean this up. This is a hack to allow the stack walkers
    //         to get the native address. Unsafe now returns the stub when
    //         it is intercepted or interpreted. It only returns the native addr
    //         when it is Jitted and NOT intercepted.
    const BYTE* GetUnsafeAddrofCode();
    const BYTE* GetNativeAddrofCode();

    // Yet another version of GetAddrofXXXCode()!
    // Please don't use this unless you have read the note in the 
    // implementation below
    const BYTE* GetAddrofJittedCode();

    // This returns either the actual address of the code if the method has already
    // been jitted (best perf) or the address of a stub 
    const BYTE* GetAddrOfCodeForLdFtn();

    void SetAddrofCode(BYTE* newAddr)
    {
        m_CodeOrIL = (size_t)newAddr;
        _ASSERTE(IsJitted());
    }

    // does this function return an object reference?
    enum RETURNTYPE {RETOBJ, RETBYREF, RETNONOBJ};
    RETURNTYPE ReturnsObject(
#ifdef _DEBUG
    bool supportStringConstructors = false
#endif    
        );
        
    // does this function return a value type?
    BOOL ReturnsValueType();



    Module *GetModule();

    Assembly *GetAssembly() { return GetModule()->GetAssembly(); }

        // Returns the # of bytes of stack required to build a call-stack
        // using the internal linearized calling convention. Includes
        // "this" pointer.
    UINT SizeOfVirtualFixedArgStack();


    // Returns the # of bytes of stack required to build a call-stack
    // using the actual calling convention used by the method. Includes
    // "this" pointer.
    UINT SizeOfActualFixedArgStack();


    // Returns the # of bytes to pop after a call. Not necessary the
    // same as SizeOfActualFixedArgStack()!
    UINT CbStackPop();

    void SetHasSecurity()
    {
        m_wFlags |= mdcHasSecurity;
    }

    BOOL HasSecurity()
    {
        return (m_wFlags & mdcHasSecurity) != 0;
    }

    DWORD GetSecurityFlags();
    DWORD GetSecurityFlags(IMDInternalImport *pInternalImport, mdToken tkMethod, mdToken tkClass, DWORD *dwClassDeclFlags, DWORD *dwClassNullDeclFlags, DWORD *dwMethDeclFlags, DWORD *dwMethNullDeclFlags);

    void destruct();
    //--------------------------------------------------------------------
    // Invoke a method. Arguments are packaged up in right->left order
    // which each array element corresponding to one argument.
    //
    // Can throw a COM+ exception.
    //
    // All the appropriate "virtual" semantics (include thunking like context
    // proxies) occurs inside Call.
    //
    // Call should never be called on interface MethodDesc's. The exception
    // to this rule is when calling on a COM object. In that case the call
    // needs to go through an interface MD and CallOnInterface is there
    // for that.
    //--------------------------------------------------------------------
    INT64 Call               (const BYTE *pArguments, MetaSig* sig);
    INT64 CallDebugHelper    (const BYTE *pArguments, MetaSig* sig);
    INT64 Call               (const INT64 *pArguments);
    INT64 Call               (const INT64 *pArguments, BinderMethodID mscorlibID);
    INT64 Call               (const INT64 *pArguments, MetaSig* sig);

    INT64 CallTransparentProxy(const INT64 *pArguments);

    INT64 CallOnInterface(const BYTE *pArguments, MetaSig* sig);
    INT64 CallOnInterface(const INT64 *pArguments);

    MethodImpl *GetMethodImpl();

    HRESULT Save(DataImage *image);
    HRESULT Fixup(DataImage *image, DWORD codeRVA);

    const BYTE *DoPrestub(MethodTable *pDispatchingMT);

public:

    // Returns the slot number of this MethodDesc in the vtable array.
    WORD           m_wSlotNumber;

private:

    // Flags.
    WORD           m_wFlags;

#ifdef TOKEN_IN_PREPAD
#ifdef _IA64_
    ULONG64        m_Align1;    // assures 16-byte alignment of MethodDesc on IA64
#endif // _IA64_
#else // !TOKEN_IN_PREPAD
    // Lower three bytes are method def token, upper byte is a combination of
    // offset (in method descs) from a pointer to the method table or module and
    // a flag bit (upper bit) that's 0 for a method and 1 for a global function.
    // The value of the type flag is chosen carefully so that GetMethodTable can
    // ignore it and remain fast, pushing the extra effort on the lesser used
    // GetModule for global functions.
    DWORD          m_dwToken;
    DWORD          m_Align2;    // assures 8-byte alignment of MethodDesc on x86 and 
                                // 16-byte alignment on IA64
#endif

    // *********************************************************************
    // *********************************************************************
    // If you think you want to change m_CodeOrIL to be public, think again.
    // Don't do that. Leave it alone and use the darn accessor!!
    // *********************************************************************
    // *********************************************************************
protected:
    // Stores either a native code address or an IL RVA (the high bit is set to
    // indicate IL). If an IL RVA is held, native address is assumed to be the
    // prestub address.
    size_t         m_CodeOrIL;

public:
    StubCallInstrs *GetStubCallInstrs()
    {
        return (StubCallInstrs*)( ((BYTE*)this) - METHOD_PREPAD );
    }


    // Checks if a given function pointer is the start of this method.
    // Note that if the ip points to something like the prestub,
    // this function could give a false positive. Hence, only use
    // this function for checking valid ip's with multiple methods.
    // Don't pass in random garbage.
    BOOL IsTarget(LPVOID ip)
    {
#ifdef _X86_
        StubCallInstrs *pStubCallInstrs = GetStubCallInstrs();

        if (ip == (LPVOID) &(pStubCallInstrs->m_op))
        {
            return TRUE;
        }
        
        if (ip == (LPVOID) (pStubCallInstrs->m_target + 1 + &(pStubCallInstrs->m_target)))
        {
            return TRUE;
        }
        return FALSE;

#else
        _ASSERTE(!"NYI");
        return FALSE;
#endif
    }

private:

    inline DWORD GetClassification()
    {
        return (m_wFlags & mdcClassification) >> mdcClassificationShift;
    }

    Stub *GetStub();
};

class MethodDescChunk
{
    friend HRESULT InitializeMiniDumpBlock();
    friend struct MEMBER_OFFSET_INFO(MethodDescChunk);

  public:
    static ULONG32 GetMaxMethodDescs(int flags)
    {
        SIZE_T mdSize = g_ClassificationSizeTable[flags & (mdcClassification|mdcMethodImpl)];
        _ASSERTE((mdSize & 0x07) == 0);
        return (ULONG32)(127 / (mdSize >> MethodDesc::ALIGNMENT_SHIFT));
    }

    static ULONG32 GetChunkCount(ULONG32 methodDescCount, int flags)
    {
        return (methodDescCount + (GetMaxMethodDescs(flags)-1)) / GetMaxMethodDescs(flags);
    }

    static MethodDescChunk *CreateChunk(LoaderHeap *pHeap, DWORD methodDescCount, int flags, BYTE tokRange);

    static MethodDescChunk *RecoverChunk(MethodDesc *methodDesc);

    void SetMethodTable(MethodTable *pMT);

    MethodTable *GetMethodTable()
    {
        return m_methodTable;
    }
        
    ULONG32 GetCount()
    {
        return m_count+1;
    }

    int GetKind()
    {
        return m_kind;
    }

    static ULONG32 GetMethodDescSize(int kind)
    {
        return g_ClassificationSizeTable[kind];
    }

    ULONG32 GetMethodDescSize()
    {
        return GetMethodDescSize(m_kind);
    }

    BYTE GetTokRange()
    {
        return m_tokrange;
    }

    ULONG32 Sizeof() 
    { 
        return (ULONG32)(sizeof(MethodDescChunk) + GetMethodDescSize() * GetCount());
    }

    MethodDesc *GetFirstMethodDesc()
    {
        return (MethodDesc *) (((BYTE*)(this + 1)) + METHOD_PREPAD);
    }

    MethodDesc *GetMethodDescAt(int n)
    {
        return (MethodDesc *) (((BYTE*)(this + 1)) + METHOD_PREPAD + GetMethodDescSize()*n);
    }

    MethodDescChunk *GetNextChunk()
    { 
        return m_next; 
    }

    void SetNextChunk(MethodDescChunk *chunk)
    { 
        m_next = chunk; 
    }

    HRESULT Save(DataImage *image);
    HRESULT Fixup(DataImage *image, DWORD *pRidToCodeRVAMap);

private:

        // This must be at the beginning for the asm routines to work.
    MethodTable *m_methodTable;

    MethodDescChunk     *m_next;
    USHORT               m_count;
    BYTE                 m_kind;
    BYTE                 m_tokrange;  

    //
    // IA64: this struct needs to be a multiple of 16 bytes so that
    //       the code that follows is 16-byte aligned.  
    //
    BYTE                 m_alignpad[METHOD_DESC_CHUNK_ALIGNPAD_BYTES];

        // If the method descs do not have prestubs, there is a gap of METHOD_PREPAD here
        // to make address arithmetic easier.

        // Followed by array of method descs...


};


class MDEnums
{
    public:
        enum {
#ifdef TOKEN_IN_PREPAD
            MD_IndexOffset = offsetof(StubCallInstrs, m_chunkIndex) - METHOD_PREPAD,
#else
            MD_IndexOffset = offsetof(MethodDesc, m_dwToken) + 3,
#endif
            MD_SkewOffset = - (int)(METHOD_PREPAD + sizeof(MethodDescChunk))
        };
};


inline /*static*/ MethodDescChunk *MethodDescChunk::RecoverChunk(MethodDesc *methodDesc)
{
    return (MethodDescChunk*)((BYTE*)methodDesc + (*((char*)methodDesc + MDEnums::MD_IndexOffset) * MethodDesc::ALIGNMENT) + MDEnums::MD_SkewOffset);
}



// convert arbitrary IP location in jitted code to a MethodDesc
MethodDesc* IP2MethodDesc(const BYTE* IP);

// convert an entry point into a MethodDesc
MethodDesc* Entry2MethodDesc(const BYTE* entryPoint, MethodTable *pMT);   


// There are two overloads of GetAddrofCode.  If you have a static, or a
// function, or you are (somehow!) guaranteed not to be thunking, use the
// simple version.
//
// If this is an instance method, you should typically use the complex
// overload so that we can do "virtual methods" correctly, including any
// handling of context proxies and other thunking layers, but more typically
// just adjusting for the inheritance hierarchy of overrides.
//
// Only call GetUnsafeAddrofCode() if you know what you are doing.  If
// you can guarantee that no virtualization is necessary, or if you can
// guarantee that it has already happened.  For instance, the frame of a
// stackwalk has obviously been virtualized as much as it will be.
inline const BYTE* MethodDesc::GetAddrofCode()
{

    // !! This logic is also duplicated in ASM code emitted by
    // EmitUMEntryThunkCall (nexport.cpp.) Don't change this
    // without updating that code!

    _ASSERTE(DontVirtualize() || !GetMethodTable()->IsThunking());
    
    return !IsJitted() ? GetPreStubAddr() : GetAddrofJittedCode();
}

inline const BYTE* MethodDesc::GetAddrofCode(OBJECTREF orThis)
{
    _ASSERTE(!DontVirtualize());

    // Deliberately use GetMethodTable -- not GetTrueMethodTable
    BYTE *addr = (BYTE *)*(orThis->GetClass()->GetMethodSlot(this));

    return addr;
}

inline const BYTE* MethodDesc::GetAddrofCodeNonVirtual()
{
    _ASSERTE(DontVirtualize());

    _ASSERTE(GetSlot() < (int)GetMethodTable()->GetTotalSlots());
    BYTE *addr = (BYTE *)*(GetClass()->GetMethodSlot(this));

    return addr;
}

inline const BYTE* MethodDesc::GetUnsafeAddrofCode()
{
    // See comments above.  Only call this if you are sure it is safe
    _ASSERTE(!GetMethodTable()->IsThunking());

    if(IsRemotingIntercepted() || IsIntercepted() || IsComPlusCall() || IsNDirect() || IsEnCMethod() || !IsJitted())
        return GetPreStubAddr();
    else
        return GetAddrofJittedCode();
}

inline const BYTE* MethodDesc::GetAddrofJittedCode()
{
    // ***************************************************
    // 
    // NOTE: This function is for the exclusive use of 
    // the PreStubWorker (MakeJITWorker)
    // Please do not call it from other places in the runtime... 
    // unless you *really* know what you are doing! 
    // 
    // It should always return m_CodeOrIL which is jitted native code!
    // 
    // ***************************************************
    _ASSERTE(IsJitted());
    return (BYTE*) m_CodeOrIL;
}


inline const BYTE* MethodDesc::GetNativeAddrofCode()
{
    // See comments above.  Only call this if you are sure it is safe

    // Commented this out - the debugger must call this routine to get the
    // native address of __TransparentProxy::.ctor during prejit.
    // _ASSERTE(!GetMethodTable()->IsThunking());

    const BYTE *addrOfCode = (const BYTE*)m_CodeOrIL;

    Module *pModule = GetModule();

    if (pModule->SupportsUpdateableMethods() && IsJitted())
        UpdateableMethodStubManager::CheckIsStub(addrOfCode, &addrOfCode);

    if (HasNativeRVA())
        addrOfCode = (const BYTE *) GetPrejittedCode();

    return addrOfCode;
}




//-----------------------------------------------------------------------
//  class MethodImpl
// 
//  There are method impl subclasses of the method desc classes. This 
//  was done to minimize the effect of MethodImpls which are very rare.
//  
//-----------------------------------------------------------------------

class MI_MethodDesc : public MethodDesc
{
    friend class MethodImpl;

    MethodImpl m_Overrides;

public:
    MethodImpl* GetImplData()
    {
        return & m_Overrides;
    }
};

class StoredSigMethodDesc : public MethodDesc
{
  public:
    // Put the sig RVA in here - this allows us to avoid
    // touching the method desc table when mscorlib is prejitted.
    //
    // @todo: This is not needed for FCalls - it should be removed 
    // when we have removed at least the majority of ECalls

    PCCOR_SIGNATURE m_pSig;
    DWORD           m_cSig;
};

//-----------------------------------------------------------------------
// Operations specific to ECall methods. We use a derived class to get
// the compiler involved in enforcing proper method type usage.
// DO NOT ADD FIELDS TO THIS CLASS.
//-----------------------------------------------------------------------

class ECallMethodDesc : public StoredSigMethodDesc
{
    public:

        LPVOID GetECallTarget()
        {
            _ASSERTE(IsECall());
            return (LPVOID)GetAddrofJittedCode();
        }

        VOID SetECallTarget(LPVOID pTarget)
        {
            _ASSERTE(IsECall());
            SetAddrofCode((BYTE*)pTarget);
        }

    static BYTE GetECallTargetOffset()
    {
        size_t ofs = offsetof(ECallMethodDesc, m_CodeOrIL);
        _ASSERTE(FitsInI1(ofs));
        return (BYTE)ofs;
    }

};

class MI_ECallMethodDesc : public ECallMethodDesc
{
    friend class MethodImpl;

    MethodImpl m_Overrides;

  public:
    MethodImpl* GetImplData()
    {
        return & m_Overrides;
    }
};

class ArrayECallMethodDesc : public ECallMethodDesc
{
public:         // should probably be private:
    WORD        m_wAttrs;           // method attributes
    BYTE        m_intrinsicID;
    BYTE        m_unused;
    LPCUTF8     m_pszArrayClassMethodName;
};

class MI_ArrayECallMethodDesc : public ArrayECallMethodDesc
{
    friend class MethodImpl;

    MethodImpl m_Overrides;

  public:
    MethodImpl* GetImplData()
    {
        return & m_Overrides;
    }
};

//-----------------------------------------------------------------------
// Operations specific to NDirect methods. We use a derived class to get
// the compiler involved in enforcing proper method type usage.
// DO NOT ADD FIELDS TO THIS CLASS.
//-----------------------------------------------------------------------
class NDirectMethodDesc : public MethodDesc
{
public:
    struct
    {
        // Initially points to m_ImportThunkGlue (which has an embedded call
        // to link the method.
        //
        // After linking, points to the actual unmanaged target.
        //
        // The JIT generates an indirect call through this location in some cases.
        LPVOID      m_pNDirectTarget;
        MLHeader    *m_pMLHeader;        // If not ASM'ized, points to
                                         //  marshaling code and info.

        // Embeds a "call NDirectImportThunk" instruction. m_pNDirectTarget
        // initially points to this "call" instruction.
        BYTE        m_ImportThunkGlue[METHOD_CALL_PRESTUB_SIZE];

        // Various attributes needed at runtime
        // !! Ensure there are at least 4 bytes before or after this
        // field inside NDirectMethodDesc. See the implementation of
        // ProbabilisticallyUpdateMarshCategory() if you want to know why. 
        BYTE        m_flags;

        // Size of outgoing arguments (on stack)
        WORD        m_cbDstBufSize;

        LPCUTF8     m_szLibName;
        LPCUTF8     m_szEntrypointName;
        
    } ndirect;

    enum MarshCategory
    {
        kUnknown = 0,       // Not yet cached. !! DO NOT CHANGE THIS VALUE FROM 0!!!
        kNoMarsh = 1,       // All params & retvals are equivalent to 32-bit ints
        kYesMarsh = 2,      // Some nontrivial marshaling is required
    };

    enum SubClassification
    {
        kLateBound = 0,     // standard [sysimport] stuff
        kEarlyBound = 1,    // IJW managed->unmanaged thunk.
    };

    enum Flags
    {
        // There are some very subtle race issues dealing with
        // setting and resetting these bits safely. Pay attention!
        //
        // There are three groups of flag bits here each which gets initialized
        // at different times. Because they all share the same byte, they must
        // follow some very careful rules to avoid losing settings due to multiple
        // threads racing.

        // Group 1: The JIT group.
        //
        //   Remembers the result of a previous JIT inlining candidacy test.
        //   This caching is done to avoid redundant work.
        //
        //   The candidacy test can run concurrently in multiple threads.
        //   It can also run concurrently with the prestub!
        //
        //   If two candicacy tests race, there is no problem as they
        //   use InterlockedCompareExchange to avoid collision, and the
        //   two tests are guaranteed to come up with the same result.
        //
        //   If a candidacy test races with the prestub, the candidacy test
        //   promises not to stomp on the prestub's work; even if it means
        //   failing to cache the test result. The prestub, however,
        //   may stomp on the test result, setting it back to kUnknown.
        //   This is ok - all it means is the JIT will have to do the
        //   test again the next time it hits this method.
        kMarshCategoryMask          = 0x03,
        kMarshCategoryShift = 0,



        // Group 2: The ctor group.
        //
        //   This group is set during MethodDesc construction. No race issues
        //   here since they are initialized before the MD is ever published
        //   and never change after that.
        kSubClassificationMask      = 0x04,
        kSubClassificationShift = 2,

        // Group 3: The prestub group
        //
        //   This group is initialized during the prestub. Once the prestub
        //   completes, these bits never change. It's possible
        //   for multiple threads to race in the prestub or with the JIT.
        //
        //   To avoid races, the prestub composes all the prestub bits in
        //   a local variable: then uses a single write to "publish" the
        //   finished bits in one go.
        //
        //   If the JIT inlining test races with a prestub, there is a chance
        //   the JIT's update may get "lost". However, all this means is that
        //   the JIT group will remain as kUnknown which is ok: all it means
        //   is that the JIT will do some redundant work.
        kNativeLinkTypeMask         = 0x08,

        kNativeLinkFlagsMask        = 0x30,
        kNativeLinkFlagsShift = 4,

        kVarArgsMask                = 0x40,

        kStdCallMask                = 0x80,
    };

    // Retrieves the current known state of the marshcategory.
    // Note that due to known (and accepted) races, the marshcat
    // can spontaneously revert from Yes/No to unknown. It cannot, however,
    // change from Yes to No or No to Yes.
    MarshCategory GetMarshCategory()
    { 
        return (MarshCategory) 
          ((ndirect.m_flags & kMarshCategoryMask)>>kMarshCategoryShift); 
    }


    // Called during MD construction to initialize to kUnknown. Do not
    // call after the MD has been made available to other threads
    // as you may stomp other bits due to races.
    void InitMarshCategory()
    {
        ndirect.m_flags = 
          (ndirect.m_flags&~kMarshCategoryMask) | (kUnknown<<kMarshCategoryShift);
    }

    // Called from the JIT inline test (and ONLY that.)
    //
    // Attempts to store a kNoMarsh or kYesMarsh in the marshcategory field.
    // Due to the need to avoid races with the prestub, there is a
    // small but nonzero chance that this routine may silently fail
    // and leave the marshcategory as "unknown." This is ok since
    // all it means is that the JIT may have to do repeat some work
    // the next time it JIT's a callsite to this NDirect.
    //
    // This routine is guaranteed not to disturb bits being set
    // simultaneously by the prestub.
    void ProbabilisticallyUpdateMarshCategory(MarshCategory value);



    // Called from the prestub (and ONLY the prestub.)
    //
    // Sets all the prestub bits in one go. Will preserve existing
    // SubClassification bits. Will preserve existing MarshCat bits, BUT
    // if some other thread tries to update MarshCat at the same time,
    // its update will probably be lost. This is a known race that the
    // JIT inline is designed to compensate for for.
    void PublishPrestubFlags(BYTE prestubflags)
    {
        _ASSERTE( 0 == (prestubflags & (kMarshCategoryMask | kSubClassificationMask)) );

        // We'll merge the new prestub flags in with the nonprestub flags.
        // The subclassification masks are set once and for all at MethodDesc construction, so
        //    no race issues there.
        // There is a potential race where the MarshCategory may get reset
        //    back to unknown. However, this is an expected race and only
        //    results in some redundant work in the JIT inliner.
        ndirect.m_flags = ( prestubflags | ( ndirect.m_flags & (kMarshCategoryMask | kSubClassificationMask) ) ); 
    }

    SubClassification GetSubClassification()
    { 
        return (SubClassification) 
          ((ndirect.m_flags & kSubClassificationMask)>>kSubClassificationShift); 
    }

    // Called during MD construction. Do not
    // call after the MD has been made available to other threads
    // as you may stomp other bits due to races.
    void InitSubClassification(SubClassification value)
    { 
        ndirect.m_flags = 
          (ndirect.m_flags&~kSubClassificationMask) | (value<<kSubClassificationShift);

        _ASSERTE(GetSubClassification() == value);
    }

    CorNativeLinkType GetNativeLinkType()
    { 
        return (ndirect.m_flags&kNativeLinkTypeMask) ? nltAnsi : nltUnicode;
    }


    static void SetNativeLinkTypeBits(BYTE *pflags, CorNativeLinkType value)
    {                                
        _ASSERTE(value == nltAnsi || value == nltUnicode);

        if (value == nltAnsi)
            (*pflags) |= kNativeLinkTypeMask;
        else
            (*pflags) &= ~kNativeLinkTypeMask;
    }


    CorNativeLinkFlags GetNativeLinkFlags()
    { 
        return (CorNativeLinkFlags) 
          ((ndirect.m_flags & kNativeLinkFlagsMask)>>kNativeLinkFlagsShift); 
    }


    static void SetNativeLinkFlagsBits(BYTE *pflags, CorNativeLinkFlags value)
    {
        (*pflags) = 
          ((*pflags)&~kNativeLinkFlagsMask) | (value<<kNativeLinkFlagsShift);
    }

    BOOL IsVarArgs()
    { 
        return (ndirect.m_flags&kVarArgsMask) != 0;
    }


    static void SetVarArgsBits(BYTE *pflags, BOOL value)
    {
        if (value)
            (*pflags) |= kVarArgsMask;
        else
            (*pflags) &= ~kVarArgsMask;
    }

    BOOL IsStdCall()
    { 
        return (ndirect.m_flags&kStdCallMask) != 0;
    }

     
    static void SetStdCallBits(BYTE *pflags, BOOL value)
    { 
        if (value)
            (*pflags) |= kStdCallMask;
        else
            (*pflags) &= ~kStdCallMask;

    }

    public:

        LPVOID GetNDirectTarget()
        {
            _ASSERTE(IsNDirect());
            return ndirect.m_pNDirectTarget;
        }

        VOID SetNDirectTarget(LPVOID pTarget)
        {
            _ASSERTE(IsNDirect());
            ndirect.m_pNDirectTarget = pTarget;
        }

        VOID InitEarlyBoundNDirectTarget(BYTE *ilBase, DWORD rva);

        MLHeader *GetMLHeader()
        {
            _ASSERTE(IsNDirect());
            return ndirect.m_pMLHeader;
        }

        MLHeader **GetAddrOfMLHeaderField()
        {
            _ASSERTE(IsNDirect());
            return &ndirect.m_pMLHeader;
        }

        static UINT32 GetOffsetofMLHeaderField()
        {
            return (UINT32)offsetof(NDirectMethodDesc, ndirect.m_pMLHeader);
        }

        BOOL InterlockedReplaceMLHeader(MLHeader *pMLHeader, MLHeader *pMLOldHeader);

        static UINT32 GetOffsetofNDirectTarget()
        {
            size_t ofs = offsetof(NDirectMethodDesc, ndirect.m_pNDirectTarget);
            _ASSERTE(ofs == (UINT32)ofs);
            return (UINT32)ofs;
        }
};

class MI_NDirectMethodDesc : public NDirectMethodDesc
{
    friend class MethodImpl;

    MethodImpl m_Overrides;

  public:
    MethodImpl* GetImplData()
    {
        return & m_Overrides;
    }
};


//-----------------------------------------------------------------------
// Operations specific to EEImplCall methods. We use a derived class to get
// the compiler involved in enforcing proper method type usage.
//
// For now, the only EE impl is the delegate Invoke method. If we
// add other EE impl types in the future, may need a discriminator
// field here.
//-----------------------------------------------------------------------
class EEImplMethodDesc : public StoredSigMethodDesc
{
};

class MI_EEImplMethodDesc : public StoredSigMethodDesc
{
    friend class MethodImpl;

    MethodImpl m_Overrides;

  public:
    MethodImpl* GetImplData()
    {
        return & m_Overrides;
    }
};

// Moved ComCallMethodDesc to ComCall.h
class ComCallMethodDesc;


//-----------------------------------------------------------------------
// Operations specific to ComPlusCall methods. We use a derived class to get
// the compiler involved in enforcing proper method type usage.
// DO NOT ADD FIELDS TO THIS CLASS.
//-----------------------------------------------------------------------
class ComPlusCallMethodDesc : public MethodDesc
{
    public:
    
    // the struct below is used if this->IsComPlusCall()
    struct
    {
        Stub*    m_pMLStub; // ml stub for com+ to com call

        // ComSlot() (is cached when we first invoke the method and generate
        // the stubs for it. There's probably a better place to do this
        // caching but I'm not sure I know all the places these things are
        // created.)
        LONG     m_cachedComSlot;

        // method table of the interface which this represents
        MethodTable* m_pInterfaceMT;

        // MethodDesc of the COM event provider to forward the call to.
        // This only applies to COM event interfaces.
        MethodDesc* m_pEventProviderMD;

        // MethodDesc's need to be 8 byte alligned.
        void *m_pUnused;

    } compluscall;

#ifdef _X86_
    BYTE  RetThunk[3];
#else
#pragma message ( "@TODO - COMPlusCallMethodDesc" )
#pragma message ( "RetThunk[3]" )
//#error "X86 dependent code implement me"
#endif

    static DWORD GetOffsetOfReturnThunk()
    {
#ifdef _X86_
        return offsetof(ComPlusCallMethodDesc, RetThunk);
#else
        _ASSERTE(!"@TODO - COMPlusCallMethodDesc::GetOffsetOfReturnThunk (Method.hpp)");
        return 0;
#endif
    }

    void InitRetThunk()
    {
        UINT numStackBytes = CbStackPop();
#ifdef _X86_
        BYTE *pRet = RetThunk;
        if (numStackBytes == 0)
        {
            pRet[0] = 0xc3;
        }
        else
        {
            pRet[0] = 0xc2;
            *(USHORT *)&pRet[1] = (USHORT)numStackBytes;
        }
#else
        _ASSERTE(!"@TODO - COMPlusCallMethodDesc::InitRetThunk (Method.hpp)");
#endif
    }

    void InitComEventCallInfo();

    Stub** GetAddrOfMLStubField()
    {
        //_ASSERTE(IsComPlusCall());
        return &compluscall.m_pMLStub;
    }

    MethodTable* GetInterfaceMethodTable()
    {
        _ASSERTE(compluscall.m_pInterfaceMT != NULL);
        return compluscall.m_pInterfaceMT;
    }

    static UINT32 GetOffsetofInterfaceMTField()
    {
        return (UINT32)offsetof(ComPlusCallMethodDesc, compluscall.m_pInterfaceMT);
    }

    MethodDesc* GetEventProviderMD()
    {
        return compluscall.m_pEventProviderMD;
    }
};

class MI_ComPlusCallMethodDesc : public ComPlusCallMethodDesc
{
    friend class MethodImpl;

    MethodImpl m_Overrides;

public:

    MethodImpl* GetImplData()
    {
        return & m_Overrides;
    }

    MethodDesc* GetInterfaceMD()
    {
        _ASSERTE(GetClass()->IsComImport());
        _ASSERTE(m_Overrides.GetSize() == 1);
        // the first override is our guy
        return m_Overrides.GetFirstImplementedMD(this);
    }

    MethodTable* GetInterfaceForComImportMethod()
    {       
        MethodDesc* pIntfMD = GetInterfaceMD();
        _ASSERTE(pIntfMD != NULL);
        _ASSERTE(pIntfMD->IsInterface());
        return pIntfMD->GetMethodTable();
    }
};

static unsigned g_ClassificationSizeTable[16] = {
    sizeof(MethodDesc) + METHOD_PREPAD,
    sizeof(ECallMethodDesc) + METHOD_PREPAD,
    sizeof(NDirectMethodDesc) + METHOD_PREPAD,
    sizeof(EEImplMethodDesc) + METHOD_PREPAD,
    sizeof(ArrayECallMethodDesc) + METHOD_PREPAD,
    sizeof(ComPlusCallMethodDesc) + METHOD_PREPAD,
        0, 
        0, 

    sizeof(MI_MethodDesc) + METHOD_PREPAD,
    sizeof(MI_ECallMethodDesc) + METHOD_PREPAD,
    sizeof(MI_NDirectMethodDesc) + METHOD_PREPAD,
    sizeof(MI_EEImplMethodDesc) + METHOD_PREPAD,
    sizeof(MI_ArrayECallMethodDesc) + METHOD_PREPAD,
    sizeof(MI_ComPlusCallMethodDesc) + METHOD_PREPAD,
        0, 
        0, 

};  


inline MethodTable* MethodDesc::GetMethodTable()
{
    return *(MethodTable**)((BYTE*)this + (*((char*)this + MDEnums::MD_IndexOffset) * MethodDesc::ALIGNMENT) + MDEnums::MD_SkewOffset);
}

inline mdMethodDef MethodDesc::GetMemberDef()
{
#ifdef TOKEN_IN_PREPAD
    BYTE   tokrange = MethodDescChunk::RecoverChunk(this)->GetTokRange();
    UINT16 tokremainder = GetStubCallInstrs()->m_wTokenRemainder;
    return MergeToken(tokrange, tokremainder) | mdtMethodDef;
#else
    return (m_dwToken & 0x00FFFFFF) | mdtMethodDef;
#endif
}

inline void MethodDesc::SetMemberDef(mdMethodDef mb)
{
    // Note: In order for this assert to work, SetChunkIndex must be called
    // before SetMemberDef.
#ifdef _DEBUG
    SMDDebugCheck(mb);
#endif

#ifdef TOKEN_IN_PREPAD
      BYTE tokrange;
      UINT16 tokremainder;
      SplitToken(mb, &tokrange, &tokremainder);

      GetStubCallInstrs()->m_wTokenRemainder = tokremainder;
      if (mb != 0)
      {
          _ASSERTE(MethodDescChunk::RecoverChunk(this)->GetTokRange() == tokrange);
      }
#else
      m_dwToken &= 0xFF000000;
      m_dwToken |= (mb & 0x00FFFFFF);
#endif
}



#ifdef _DEBUG
inline void MethodDesc::SMDDebugCheck(mdMethodDef mb)
{
    if (TypeFromToken(mb) != 0)
    {
        _ASSERTE( GetTokenRange(mb) == MethodDescChunk::RecoverChunk(this)->GetTokRange() );
    }
}
#endif


//
// Note: no one is allowed to use this mask outside of method.hpp and method.cpp. Don't make this public!
//
#undef METHOD_IS_IL_FLAG

#endif /* _METHOD_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\method.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: Method.CPP
//
// ===========================================================================
// Method is the cache sensitive portion of EEClass (see class.h)
// ===========================================================================

#include "common.h"
#include "COMVariant.h"
#include "remoting.h"
#include "security.h"
#include "verifier.hpp"
#include "wsperf.h"
#include "excep.h"
#include "DbgInterface.h"
#include "ECall.h"
#include "eeconfig.h"
#include "mlinfo.h"
#include "ndirect.h"
#include "utsem.h"

//
// Note: no one is allowed to use this mask outside of method.hpp and method.cpp. Don't make this public! Keep this
// version in sync with the version in the top of method.hpp.
//
#ifdef _IA64_
#define METHOD_IS_IL_FLAG   0xC000000000000000
#else
#define METHOD_IS_IL_FLAG   0xC0000000
#endif

LPCUTF8 MethodDesc::GetName(USHORT slot)
{
    if (GetMethodTable()->IsArray())
    {
        // Array classes don't have metadata tokens
        return ((ArrayECallMethodDesc*) this)->m_pszArrayClassMethodName;
    }
    else
    {
        if(IsMethodImpl()) {
            MethodImpl* pImpl = MethodImpl::GetMethodImplData(this);
            MethodDesc* real = pImpl->FindMethodDesc(slot, this);
            if (real == this || real->IsInterface())
                return (GetMDImport()->GetNameOfMethodDef(GetMemberDef()));
            else 
                return real->GetName();
        }
        else 
            return (GetMDImport()->GetNameOfMethodDef(GetMemberDef()));
    }
}

LPCUTF8 MethodDesc::GetName()
{
    if (GetMethodTable()->IsArray())
    {
        // Array classes don't have metadata tokens
        return ((ArrayECallMethodDesc*) this)->m_pszArrayClassMethodName;
    }
    else
    {
        if(IsMethodImpl()) {
            MethodImpl* pImpl = MethodImpl::GetMethodImplData(this);
            MethodDesc* real = pImpl->FindMethodDesc(GetSlot(), this);
            if (real == this || real->IsInterface())
                return (GetMDImport()->GetNameOfMethodDef(GetMemberDef()));
            else
                return real->GetName();
        }
        else 
            return (GetMDImport()->GetNameOfMethodDef(GetMemberDef()));
    }
}

void MethodDesc::GetSig(PCCOR_SIGNATURE *ppSig, DWORD *pcSig)
{
    if (HasStoredSig())
    {
        StoredSigMethodDesc *pSMD = (StoredSigMethodDesc *) this;
        if (pSMD->m_pSig != NULL)
    {
            *ppSig = pSMD->m_pSig;
            *pcSig = pSMD->m_cSig;
            return;
    }
}

    *ppSig = GetMDImport()->GetSigOfMethodDef(GetMemberDef(), pcSig);
}

PCCOR_SIGNATURE MethodDesc::GetSig()
{

    if (HasStoredSig())
    {
        StoredSigMethodDesc *pSMD = (StoredSigMethodDesc *) this;
        if (pSMD->m_pSig != 0)
            return pSMD->m_pSig;
    }

    ULONG cbsig;
    return GetMDImport()->GetSigOfMethodDef(GetMemberDef(), &cbsig);
}


Stub *MethodDesc::GetStub()
{
#ifdef _X86_
    if (GetStubCallInstrs()->m_op != 0xe8 /* CALL NEAR32 */)
    {
        return NULL;
    }
#endif
    
    UINT32 ofs = getStubDisp(this);
    if (!ofs)
        return NULL;

    Module *pModule = GetModule();
    
    if (ofs + (size_t)this == (size_t) pModule->GetPrestubJumpStub())
        return ThePreStub();
    else
        return Stub::RecoverStub(getStubAddr(this));
}

void MethodDesc::destruct()
{
    Stub *pStub = GetStub();
    if (pStub != NULL && pStub != ThePreStub()) {
        pStub->DecRef();
    }

    if (IsNDirect()) 
    {
        MLHeader *pMLHeader = ((NDirectMethodDesc*)this)->GetMLHeader();
        if (pMLHeader != NULL
            && !GetModule()->IsPreloadedObject(pMLHeader)) 
        {
            Stub *pMLStub = Stub::RecoverStub((BYTE*)pMLHeader);
            pMLStub->DecRef();
        }
    }
    else if (IsComPlusCall()) 
    {
        Stub* pStub = *( ((ComPlusCallMethodDesc*)this)->GetAddrOfMLStubField());
        if (pStub != NULL)
            (pStub)->DecRef();
    }

    EEClass *pClass = GetClass();
    if(pClass->IsMarshaledByRef() || (pClass == g_pObjectClass->GetClass()))
    {
        // Destroy the thunk generated to intercept calls for remoting
        CRemotingServices::DestroyThunk(this);    
    }

    // unload the code
    if (!g_fProcessDetach && IsJitted()) 
    {
        //
        // @todo:
        //
        // We don't really need to do this.  The normal JIT unloads all code in an
        // app domain in one fell swoop.  The FJIT (if we end up using it) would
        // be easy to change to be able to do the same thing.
        //
        IJitManager * pJM = ExecutionManager::FindJitMan((SLOT)GetAddrofCode());
        if (pJM) {
            pJM->Unload(this);
        }
    }
}

BOOL MethodDesc::InterlockedReplaceStub(Stub** ppStub, Stub *pNewStub)
{
    _ASSERTE(ppStub != NULL);
    _ASSERTE(sizeof(LONG) == sizeof(Stub*));

    _ASSERTE(((SIZE_T)ppStub&0x3) == 0);

    Stub *pPrevStub = (Stub*)FastInterlockCompareExchange((void**)ppStub, (void*) pNewStub,
                                                          NULL);

    // Return TRUE if we succeeded.
    return (pPrevStub == NULL);
}


HRESULT MethodDesc::Verify(COR_ILMETHOD_DECODER* ILHeader, 
                            BOOL fThrowException,
                            BOOL fForceVerify)
{
#ifdef _VER_EE_VERIFICATION_ENABLED
    // ForceVerify will force verification if the Verifier is OFF
    if (fForceVerify)
        goto DoVerify;

    // Don't even try to verify if verifier is off.
    if (g_fVerifierOff)
        return S_OK;

    if (IsVerified())
        return S_OK;

    // LazyCanSkipVerification does not reslove the policy.
    // We go ahead with verification if policy is not resolved.
    // In case the verification fails, we resolve policy and
    // fail verification if the Assembly of this method does not have 
    // permission to skip verification.

    if (Security::LazyCanSkipVerification(GetModule()))
    {
        SetIsVerified(TRUE);
        return S_OK;
    }


#ifdef _DEBUG

    if (GetModule()->m_fForceVerify)
    {
        goto DoVerify;
    }

    _ASSERTE(Security::IsSecurityOn());
    _ASSERTE(GetModule() != SystemDomain::SystemModule());

#endif


DoVerify:

    HRESULT hr;

    if (fThrowException)
        hr = Verifier::VerifyMethod(this, ILHeader, NULL,
            fForceVerify ? VER_FORCE_VERIFY : VER_STOP_ON_FIRST_ERROR);
    else
        hr = Verifier::VerifyMethodNoException(this, ILHeader);
        
    if (SUCCEEDED(hr))
        SetIsVerified(TRUE);

    return hr;
#else
    _ASSERTE(!"EE Verification is disabled, should never get here");
    return E_FAIL;
#endif
}

DWORD MethodDesc::SetIntercepted(BOOL set)
{
    DWORD dwResult = IsIntercepted();
    DWORD dwMask = mdcIntercepted;

    // We need to make this operation atomic (multiple threads can play with the
    // flags field while we're calling SetIntercepted). But the flags field is a
    // word and we only have interlock operations over dwords. So we round down
    // the flags field address to the nearest aligned dword (along with the
    // intended bitfield mask). Note that we make the assumption that the flags
    // word is aligned itself, so we only have two possibilites: the field
    // already lies on a dword boundary (no bitmask shift necessary) or it's
    // precisely one word out (a 16 bit left shift required).
    DWORD *pdwFlags = (DWORD*)((ULONG_PTR)&m_wFlags & ~0x3);
    if (pdwFlags != (DWORD*)&m_wFlags)
        dwMask <<= 16;

    if (set)
        FastInterlockOr(pdwFlags, dwMask);
    else
        FastInterlockAnd(pdwFlags, ~dwMask);

    return dwResult;
}


BOOL MethodDesc::IsVoid()
{
    MetaSig sig(GetSig(),GetModule());
    return ELEMENT_TYPE_VOID == sig.GetReturnType();
}

// IL RVA stored in same field as code address, but high bit set to
// discriminate.
ULONG MethodDesc::GetRVA()
{
    // Fetch a local copy to avoid concurrent update problems.
    // TODO: WIN64  Check this casting.
    unsigned CodeOrIL = (unsigned) m_CodeOrIL;
    if (((CodeOrIL & METHOD_IS_IL_FLAG) == METHOD_IS_IL_FLAG) && !IsPrejitted())
        return CodeOrIL & ~METHOD_IS_IL_FLAG;
    else if (GetMemberDef() & 0x00FFFFFF)
    {
        DWORD dwDescrOffset;
        DWORD dwImplFlags;
        GetMDImport()->GetMethodImplProps(GetMemberDef(), &dwDescrOffset, &dwImplFlags);
        BAD_FORMAT_ASSERT(IsMiIL(dwImplFlags) || IsMiOPTIL(dwImplFlags) || dwDescrOffset == 0);
        return dwDescrOffset;
    }
    else
        return 0;
}

BOOL MethodDesc::IsVarArg()
{
    return MetaSig::IsVarArg(GetModule(), GetSig());
}


COR_ILMETHOD* MethodDesc::GetILHeader()
{
    Module *pModule;

    _ASSERTE( IsIL() );

    pModule = GetModule();

   _ASSERTE(IsIL() && GetRVA() != METHOD_MAX_RVA);
    return (COR_ILMETHOD*) pModule->GetILCode(GetRVA());
}

void *MethodDesc::GetPrejittedCode()
{
    _ASSERTE(IsPrejitted());

    // Fetch a local copy to avoid concurrent update problems.
    DWORD_PTR CodeOrIL = m_CodeOrIL;

    if ((CodeOrIL & METHOD_IS_IL_FLAG) == METHOD_IS_IL_FLAG) {
        return (void *) ((CodeOrIL&~METHOD_IS_IL_FLAG) + GetModule()->GetZapBase());
    }

    const BYTE *destAddr;
    if (UpdateableMethodStubManager::CheckIsStub((const BYTE*)CodeOrIL, &destAddr))
        return (void *) destAddr;

    return (void *) CodeOrIL;
}

MethodDesc::RETURNTYPE MethodDesc::ReturnsObject(
#ifdef _DEBUG
    bool supportStringConstructors
#endif    
    )
{
    MetaSig sig(GetSig(),GetModule());
    switch (sig.GetReturnType())
    {
        case ELEMENT_TYPE_STRING:
        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_SZARRAY:
        case ELEMENT_TYPE_ARRAY:
        case ELEMENT_TYPE_OBJECT:
        case ELEMENT_TYPE_VAR:
            return RETOBJ;

        //TYPEDBYREF is a structure.  A function of this return type returns 
        // void.  We drop out of this switch and consider if we have a constructor.
        // Otherwise this function is going to return RETNONOBJ.
        //case ELEMENT_TYPE_TYPEDBYREF:   // TYPEDBYREF is just an OBJECT.
            
        case ELEMENT_TYPE_BYREF:
            return RETBYREF;
    }

    // String constructors return objects.  We should not have any ecall string
    // constructors, except when called from gc coverage codes (which is only
    // done under debug).  We will therefore optimize the retail version of this
    // method to not support string constructors.
#ifdef _DEBUG
    if (IsCtor() && GetClass()->HasVarSizedInstances())
    {
        _ASSERTE(supportStringConstructors);
        return RETOBJ;
    }
#endif

    return RETNONOBJ;
}

BOOL MethodDesc::ReturnsValueType()
{
    MetaSig sig(GetSig(),GetModule());
    return (sig.GetReturnType() == ELEMENT_TYPE_VALUETYPE);
}


LONG MethodDesc::GetComDispid()
{
    ULONG dispid = -1;         
    HRESULT hr = GetMDImport()->GetDispIdOfMemberDef(
                                    GetMemberDef(),   // The member for which to get props.
                                    &dispid // return dispid.
                                    );
    if (FAILED(hr))
        return -1;

    return (LONG)dispid;
}


LONG MethodDesc::GetComSlot()
{
    _ASSERTE(GetMethodTable()->IsInterface());

    // COM slots are biased from MethodTable slots by either 3 or 7, depending
    // on whether the interface is dual or not.
        CorIfaceAttr ItfType = GetMethodTable()->GetComInterfaceType();

    // Normal interfaces are layed out the same way as in the MethodTable, while
    // sparse interfaces need to go through an extra layer of mapping.
    WORD slot;

    // For dispatch only interfaces, the slot is 7 where is the IDispatch::Invoke
    // is placed. Currenly, we are lying to debugger about the target unmanaged 
    // address. GopalK
    //if(ItfType == ifDispatch)
    //  slot = 7;
    //else
    if (IsSparse())
        slot = (ItfType == ifVtable ? 3 : 7) + GetClass()->GetSparseVTableMap()->LookupVTSlot(GetSlot());
    else
        slot = (ItfType == ifVtable ? 3 : 7) + GetSlot();

    return (LONG)slot;
}


DWORD MethodDesc::GetAttrs()
{
    if (IsArray())
        return ((ArrayECallMethodDesc*) this)->m_wAttrs;

    return GetMDImport()->GetMethodDefProps(GetMemberDef());
}
DWORD MethodDesc::GetImplAttrs()
{
    ULONG RVA;
    DWORD props;
    GetMDImport()->GetMethodImplProps(GetMemberDef(), &RVA, &props);
    return props;
}


Module *MethodDesc::GetModule()
{
    MethodDescChunk *chunk = MethodDescChunk::RecoverChunk(this);

    return chunk->GetMethodTable()->GetModule();
}


DWORD MethodDesc::IsUnboxingStub()
{
    return (!IsPrejitted() && !IsJitted() && (GetRVA() == METHOD_MAX_RVA) && GetClass()->IsValueClass());
}


MethodDescChunk *MethodDescChunk::CreateChunk(LoaderHeap *pHeap, DWORD methodDescCount, int flags, BYTE tokrange)
{
    _ASSERTE(methodDescCount <= GetMaxMethodDescs(flags));
    _ASSERTE(methodDescCount > 0);

    SIZE_T mdSize = g_ClassificationSizeTable[flags & (mdcClassification|mdcMethodImpl)];
    SIZE_T presize = sizeof(MethodDescChunk);

    MethodDescChunk *block = (MethodDescChunk *) 
      pHeap->AllocAlignedmem(presize + mdSize * methodDescCount, MethodDesc::ALIGNMENT);
    if (block == NULL)
        return NULL;

    block->m_count = (BYTE) (methodDescCount-1);
    block->m_kind = flags & (mdcClassification|mdcMethodImpl);
    block->m_tokrange = tokrange;

    /*
    // Uncomment if going back to old icecap integration
    // Give the profiler a chance to track methods.
    if (IsIcecapProfiling())
        IcecapProbes::OnNewMethodDescHeap((PBYTE)block + presize,
                                          methodDescCount, mdSize * methodDescCount);
    */

    WS_PERF_UPDATE_DETAIL("MethodDescChunk::CreateChunk", 
                          presize + mdSize * methodDescCount, block);

    return block;
}

void MethodDescChunk::SetMethodTable(MethodTable *pMT)
{
    _ASSERTE(m_methodTable == NULL);
    m_methodTable = pMT;
    pMT->GetClass()->AddChunk(this);
}

//--------------------------------------------------------------------
// Invoke a method. Arguments are packaged up in right->left order
// which each array element corresponding to one argument.
//
// Can throw a COM+ exception.
//
// @todo: Only handles methods using WIL default convention for M2.
// @todo: Only X86 platforms supported.
//--------------------------------------------------------------------

// Currently we only need the "this" pointer to get the Module
INT64 MethodDesc::CallDescr(const BYTE *pTarget, Module *pModule, MetaSig* sig, BOOL fIsStatic, const BYTE *pArguments)
{
//--------------------------------------------------------------------
// PLEASE READ 
// For performance reasons, for X86 platforms COMMember::InvokeMethod does not 
// use MethodDesc::Call and duplicates a lot of code from this method. Please 
// propagate any changes made here to that method also..Thanks !
// PLEASE READ
//--------------------------------------------------------------------
    TRIGGERSGC ();

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(GetAppDomain()->ShouldHaveCode());

#ifdef _DEBUG
    {
        // Check to see that any value type args have been restored.
        // This is because we may be calling a FramedMethodFrame which will use the sig
        // to trace the args, but if any are unloaded we will be stuck if a GC occurs.

        _ASSERTE(GetMethodTable()->IsRestored());
        CorElementType argType;
        while ((argType = sig->NextArg()) != ELEMENT_TYPE_END)
        {
            if (argType == ELEMENT_TYPE_VALUETYPE)
            {
                TypeHandle th = sig->GetTypeHandle(NULL, TRUE, TRUE);
                _ASSERTE(th.IsRestored());
            }
        }
        sig->Reset();
    }
#endif

    BYTE callingconvention = sig->GetCallingConvention();
    if (!isCallConv(callingconvention, IMAGE_CEE_CS_CALLCONV_DEFAULT))
    {
        _ASSERTE(!"This calling convention is not supported.");
        COMPlusThrow(kInvalidProgramException);
    }

#ifdef DEBUGGING_SUPPORTED
    if (CORDebuggerTraceCall())
        g_pDebugInterface->TraceCall(pTarget);
#endif // DEBUGGING_SUPPORTED

#if CHECK_APP_DOMAIN_LEAKS
    if (g_pConfig->AppDomainLeaks())
    {
        // See if we are in the correct domain to call on the object 
        if (!fIsStatic && !GetClass()->IsValueClass())
        {
            Object *pThis = *(Object**)pArguments;
            if (pThis != NULL)
            {
                if (!pThis->AssignAppDomain(GetAppDomain()))
                    _ASSERTE(!"Attempt to call method on object in wrong domain");
            }
        }
    }
#endif

#ifdef _X86_
    UINT   nActualStackBytes = sig->SizeOfActualFixedArgStack(fIsStatic);
    // Create a fake FramedMethodFrame on the stack.
    LPBYTE pAlloc = (LPBYTE)_alloca(FramedMethodFrame::GetNegSpaceSize() + sizeof(FramedMethodFrame) + nActualStackBytes);

    LPBYTE pFrameBase = pAlloc + FramedMethodFrame::GetNegSpaceSize();

    if (!fIsStatic) {
        // If this isn't a value class, verify the objectref
//#ifdef _DEBUG
//        if (GetClass()->IsValueClass() == FALSE)
//            VALIDATEOBJECTREF(ObjectToOBJECTREF(*(Object**) pArguments));
//#endif
        *((void**)(pFrameBase + FramedMethodFrame::GetOffsetOfThis())) = *((void**)pArguments);
    }
    UINT   nVirtualStackBytes = sig->SizeOfVirtualFixedArgStack(fIsStatic);
    pArguments += nVirtualStackBytes;

    ArgIterator argit(pFrameBase, sig, fIsStatic);
    if (sig->HasRetBuffArg()) {
        pArguments -= 4;
        *((INT32*) argit.GetRetBuffArgAddr()) = *((INT32*)pArguments);
    }
    
    BYTE   typ;
    UINT32 structSize;
    int    ofs;
#ifdef _DEBUG
#ifdef _X86_
    int    thisofs = FramedMethodFrame::GetOffsetOfThis();
#endif
#endif
    while (0 != (ofs = argit.GetNextOffsetFaster(&typ, &structSize))) {
#ifdef _DEBUG
#ifdef _X86_
        if ((!fIsStatic &&
            (ofs == thisofs ||
             (ofs == thisofs-4 && StackElemSize(structSize) == 8)))
            || (!fIsStatic && ofs < 0 && StackElemSize(structSize) > 4)
            || (fIsStatic && ofs < 0 && StackElemSize(structSize) > 8))
            _ASSERTE(!"This can not happen! The stack for enregistered args is trashed! Possibly a race condition in MetaSig::ForceSigWalk.");
#endif
#endif

        switch (StackElemSize(structSize)) {
            case 4:
                pArguments -= 4;
                *((INT32*)(pFrameBase + ofs)) = *((INT32*)pArguments);

#if CHECK_APP_DOMAIN_LEAKS
                // Make sure the arg is in the right app domain
                if (g_pConfig->AppDomainLeaks() && typ == ELEMENT_TYPE_CLASS)
                    if (!(*(Object**)pArguments)->AssignAppDomain(GetAppDomain()))
                        _ASSERTE(!"Attempt to pass object in wrong app domain to method");
#endif

                break;

            case 8:
                pArguments -= 8;
                *((INT64*)(pFrameBase + ofs)) = *((INT64*)pArguments);
                break;

            default: {
                pArguments -= StackElemSize(structSize);
                memcpy(pFrameBase + ofs, pArguments, structSize);

#if CHECK_APP_DOMAIN_LEAKS
                // Make sure the arg is in the right app domain
                if (g_pConfig->AppDomainLeaks() && typ == ELEMENT_TYPE_VALUETYPE)
                {
                    TypeHandle th = argit.GetArgType();
                    if (!Object::ValidateValueTypeAppDomain(th.GetClass(), 
                                                            (void*)pArguments))
                        _ASSERTE(!"Attempt to pass object in wrong app domain to method");              }
#endif

                break;
            }

        }
    }
    INT64 retval;

    INSTALL_COMPLUS_EXCEPTION_HANDLER();
    retval = CallDescrWorker(pFrameBase + sizeof(FramedMethodFrame) + nActualStackBytes,
                             nActualStackBytes / STACK_ELEM_SIZE,
                             (ArgumentRegisters*)(pFrameBase + FramedMethodFrame::GetOffsetOfArgumentRegisters()),
                             (LPVOID)pTarget);
    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();

#else   // _X86_
    UINT nStackBytes = sig->SizeOfVirtualFixedArgStack(fIsStatic);

    UINT numSlots = nStackBytes / STACK_ELEM_SIZE;
    INT64 retval;

    retval = CallWorker_WilDefault( pTarget,
                                  numSlots,
                                  GetSig(),
                                  pModule,
                                  pArguments + nStackBytes,
                                  fIsStatic);
#endif  // _X86_

    getFPReturn(sig->GetFPReturnSize(), retval);
    return retval;
}


UINT MethodDesc::SizeOfVirtualFixedArgStack()
{
    return MetaSig::SizeOfVirtualFixedArgStack(GetModule(), GetSig(), IsStatic());
}

UINT MethodDesc::SizeOfActualFixedArgStack()
{
    return MetaSig::SizeOfActualFixedArgStack(GetModule(), GetSig(), IsStatic());
}

UINT MethodDesc::CbStackPop()
{
    return MetaSig::CbStackPop(GetModule(), GetSig(), IsStatic());
}



//--------------------------------------------------------------------
// Invoke a method. Arguments are packaged up in right->left order
// which each array element corresponding to one argument.
//
// Can throw a COM+ exception.
//
// @todo: Only handles methods using WIL default convention for M2.
// @todo: Only X86 platforms supported.
//--------------------------------------------------------------------
INT64 MethodDesc::CallTransparentProxy(const INT64 *pArguments)
{
    THROWSCOMPLUSEXCEPTION();
    
    MethodTable* pTPMT = CTPMethodTable::GetMethodTable();
    _ASSERTE(pTPMT != NULL);

#ifdef _DEBUG
    OBJECTREF oref = Int64ToObj(pArguments[0]);
    MethodTable* pMT = oref->GetMethodTable();
    _ASSERTE(pMT->IsTransparentProxyType());
#endif

    DWORD slot = GetSlot();

    // ensure the slot is within range
    _ASSERTE( slot <= CTPMethodTable::GetCommitedTPSlots());

    const BYTE* pTarget = (const BYTE*)pTPMT->GetVtable()[slot];
    
    return CallDescr(pTarget, GetModule(), GetSig(), IsStatic(), pArguments);
}

//--------------------------------------------------------------------
// Invoke a method. Arguments are packaged up in right->left order
// which each array element corresponding to one argument.
//
// Can throw a COM+ exception.
//
// @todo: Only handles methods using WIL default convention for M2.
// @todo: Only X86 platforms supported.
//--------------------------------------------------------------------
INT64 MethodDesc::Call(const BYTE *pArguments, MetaSig* sig)
{
    // You're not allowed to call a method directly on a MethodDesc that comes from an Interface. If you do, then you're
    // calling through the slot in the Interface's vtable instead of through the slot on the object's vtable.
    
    THROWSCOMPLUSEXCEPTION();

    // For member methods, use the instance to determine the correct (VTable)
    // address to call.
    // REVIEW: Should we just return GetPreStubAddr() always and let that do
    // the right thing ... instead of doing so many checks? Even if the code has
    // been jitted all we will do is an extra "jmp"
    const BYTE *pTarget = (IsComPlusCall() || IsECall() || IsIntercepted() || IsRemotingIntercepted() || IsEnCMethod() ) ? GetPreStubAddr() :
                            ((DontVirtualize() || GetClass()->IsValueClass())
                           ? GetAddrofCode()
                           : GetAddrofCode(ObjectToOBJECTREF(ExtractArg(pArguments, Object*))));

    return CallDescr(pTarget, GetModule(), sig, IsStatic(), pArguments);
}


//--------------------------------------------------------------------
// Invoke a method. Arguments are packaged up in right->left order
// which each array element corresponding to one argument.
//
// Can throw a COM+ exception.
//
// @todo: Only handles methods using WIL default convention for M2.
// @todo: Only X86 platforms supported.
//--------------------------------------------------------------------
INT64 MethodDesc::CallDebugHelper(const BYTE *pArguments, MetaSig* sig)
{
    // You're not allowed to call a method directly on a MethodDesc that comes from an Interface. If you do, then you're
    // calling through the slot in the Interface's vtable instead of through the slot on the object's vtable.
    
    THROWSCOMPLUSEXCEPTION();

    // For member methods, use the instance to determine the correct (VTable)
    // address to call.
    // REVIEW: Should we just return GetPreStubAddr() always and let that do
    // the right thing ... instead of doing so many checks? Even if the code has
    // been jitted all we will do is an extra "jmp"

    const BYTE *pTarget;
    
    // If the method is virutal, do the virtual lookup. 
    if (!DontVirtualize() && !GetClass()->IsValueClass()) 
    {
        OBJECTREF thisPtr = ObjectToOBJECTREF(ExtractArg(pArguments, Object*));
        _ASSERTE(thisPtr);
        pTarget = GetAddrofCode(thisPtr);

#ifdef DEBUG
        // For the cases where we ALWAYS want the Prestub, make certain that 
        // the address we find in the Vtable actually points at the prestub. 
        if (IsComPlusCall() || IsECall() || IsIntercepted() || IsRemotingIntercepted() || IsEnCMethod())
            _ASSERTE(getStubCallAddr(GetClass()->GetUnknownMethodDescForSlotAddress(pTarget)) == pTarget);
#endif
    }
    else 
    {
        if (IsComPlusCall() || IsECall() || IsIntercepted() || IsRemotingIntercepted() || IsEnCMethod())
            pTarget = GetPreStubAddr();
        else
            pTarget = GetAddrofCode();
    }

    // @FUTURE: we should clean up all of the other variation of MethodDesc::CallXXX to use the logic
    // @FUTURE: as above. Right now we are just doing the minimal fix for V1.
    if (pTarget == NULL)
        COMPlusThrow(kArgumentException, L"Argument_CORDBBadAbstract");

    return CallDescr(pTarget, GetModule(), sig, IsStatic(), pArguments);
}

INT64 MethodDesc::Call(const INT64 *pArguments)
{
    // You're not allowed to call a method directly on a MethodDesc that comes from an Interface. If you do, then you're
    // calling through the slot in the Interface's vtable instead of through the slot on the object's vtable.
    _ASSERTE(!IsComPlusCall());
    
    THROWSCOMPLUSEXCEPTION();

    const BYTE *pTarget = (IsComPlusCall() || IsECall() || IsIntercepted() || IsRemotingIntercepted() || IsEnCMethod()) ? GetPreStubAddr() :
                            ((DontVirtualize()|| GetClass()->IsValueClass())
                           ? GetAddrofCode()
                           : GetAddrofCode(Int64ToObj(pArguments[0])));

    return CallDescr(pTarget, GetModule(), GetSig(), IsStatic(), pArguments);
}

// NOTE: This variant exists so that we don't have to touch the metadata for the method being called.
INT64 MethodDesc::Call(const INT64 *pArguments, BinderMethodID sigID)
{
    // You're not allowed to call a method directly on a MethodDesc that comes from an Interface. If you do, then you're
    // calling through the slot in the Interface's vtable instead of through the slot on the object's vtable.
    _ASSERTE(!IsComPlusCall());
    
#ifdef _DEBUG
    PCCOR_SIGNATURE pSig;
    DWORD cSig;
    GetSig(&pSig, &cSig);
    
    _ASSERTE(MetaSig::CompareMethodSigs(g_Mscorlib.GetMethodSig(sigID)->GetBinarySig(), 
                                        g_Mscorlib.GetMethodSig(sigID)->GetBinarySigLength(), 
                                        SystemDomain::SystemModule(),
                                        pSig, cSig, GetModule()));
#endif
    
    THROWSCOMPLUSEXCEPTION();

    MetaSig sig(g_Mscorlib.GetMethodBinarySig(sigID), SystemDomain::SystemModule());

    const BYTE *pTarget = (IsComPlusCall() || IsECall() || IsIntercepted() || IsRemotingIntercepted() || IsEnCMethod()) ? GetPreStubAddr() :
                            ((DontVirtualize()|| GetClass()->IsValueClass())
                           ? GetAddrofCode()
                           : GetAddrofCode(Int64ToObj(pArguments[0])));

    return CallDescr(pTarget, GetModule(), &sig, IsStatic(), pArguments);
}

INT64 MethodDesc::Call(const INT64 *pArguments, MetaSig* sig)
{
    // You're not allowed to call a method directly on a MethodDesc that comes from an Interface. If you do, then you're
    // calling through the slot in the Interface's vtable instead of through the slot on the object's vtable.
    _ASSERTE(!IsComPlusCall());
    
    THROWSCOMPLUSEXCEPTION();

#ifdef _DEBUG
    if ((PVOID)sig > ((struct _NT_TIB *)NtCurrentTeb())->StackBase ||
        (PVOID)sig < ((struct _NT_TIB *)NtCurrentTeb())->StackLimit)
    {
        // Shared MetaSig must have less than MAX_CACHED_SIG_SIZE args
        // to make it thread safe, because it uses cached arg
        // type/size/allocation.  Otherwise we need to walk signiture, and the
        // internal pointer is not thread safe.
        _ASSERTE (sig->NumFixedArgs() <= MAX_CACHED_SIG_SIZE);
    }
#endif
    
    const BYTE *pTarget = (IsComPlusCall() || IsECall() || IsIntercepted() || IsRemotingIntercepted() || IsEnCMethod()) ? GetPreStubAddr() :
                            ((DontVirtualize() || GetClass()->IsValueClass())
                           ? GetAddrofCode()
                           : GetAddrofCode(Int64ToObj(pArguments[0])));

    return CallDescr(pTarget, GetModule(), sig, IsStatic(), pArguments);
}


// This is another unusual case. When calling a COM object using a MD the call needs to
// go through an interface MD. This method must be used to accomplish that.
INT64 MethodDesc::CallOnInterface(const INT64 *pArguments)
{   
    // This should only be used for ComPlusCalls.
    _ASSERTE(IsComPlusCall());

    THROWSCOMPLUSEXCEPTION();

    const BYTE *pTarget = GetPreStubAddr();
    return CallDescr(pTarget, GetModule(), GetSig(), IsStatic(), pArguments);
}

INT64 MethodDesc::CallOnInterface(const BYTE *pArguments, MetaSig* sig)
{   

    THROWSCOMPLUSEXCEPTION();

    const BYTE *pTarget = GetPreStubAddr();
    return CallDescr(pTarget, GetModule(), sig, IsStatic(), pArguments);
}


/*******************************************************************/
/* convert arbitrary IP location in jitted code to a MethodDesc */

MethodDesc* IP2MethodDesc(const BYTE* IP) 
{
    IJitManager* jitMan = ExecutionManager::FindJitMan((SLOT)IP);
    if (jitMan == 0)
        return(0);
    return jitMan->JitCode2MethodDesc((SLOT)IP);
}

//
// convert an entry point into a method desc 
//

MethodDesc* Entry2MethodDesc(const BYTE* entryPoint, MethodTable *pMT) 
{
    MethodDesc* method = IP2MethodDesc(entryPoint);
    if (method)
        return method;

    method = StubManager::MethodDescFromEntry(entryPoint, pMT);
    if (method) {
        return method;
    }
    
    // Is it an FCALL? 
    MethodDesc* ret = MapTargetBackToMethod(entryPoint);
    if (ret != 0) {
        _ASSERTE(ret->GetAddrofJittedCode() == entryPoint);
        return(ret);
    }
    
    // Its a stub
    ret = (MethodDesc*) (entryPoint + METHOD_CALL_PRESTUB_SIZE);
    _ASSERTE(ret->m_pDebugEEClass == ret->m_pDebugMethodTable->GetClass());
    
    return(ret);
}

BOOL MethodDesc::CouldBeFCall() {
    if (!IsECall())
        return(FALSE);
        
        // Still pointing at the prestub
    if (PointAtPreStub())
        return TRUE;

        // Hack remove after Array stubs make direct jump to code
        // should be able to remove after 11/30/00 - vancem
    if (GetClass()->IsArrayClass())
        return TRUE;

#ifdef _X86_
        // an E call that looks like JITTed code is an FCALL 
    return GetStubCallInstrs()->m_op != 0xe8 /* CALL NEAR32 */;   
#else    
    return FALSE;
#endif
}

//
// Returns true if we are still pointing at the prestub.
// Note that there are two cases:
// 1) Prejit:    point to the prestub jump stub
// 2) No-prejit: point directly to the prestub
// Consider looking for the "e9 offset" pattern instead of
// the call to GetPrestubJumpStub if we want to improve
// the performance of this method.
//

BOOL MethodDesc::PointAtPreStub()
{
    const BYTE *stubAddr = getStubAddr(this);

    return ((stubAddr == ThePreStub()->GetEntryPoint()) ||
            (stubAddr == GetModule()->GetPrestubJumpStub()));
}

DWORD MethodDesc::GetSecurityFlags()
{
    DWORD dwMethDeclFlags       = 0;
    DWORD dwMethNullDeclFlags   = 0;
    DWORD dwClassDeclFlags      = 0;
    DWORD dwClassNullDeclFlags  = 0;

    // We're supposed to be caching this bit - make sure it's right.
    _ASSERTE((IsMdHasSecurity(GetAttrs()) != 0) == HasSecurity());

    if (HasSecurity())
    {
        HRESULT hr = Security::GetDeclarationFlags(GetMDImport(),
                                                   GetMemberDef(), 
                                                   &dwMethDeclFlags,
                                                   &dwMethNullDeclFlags);
        _ASSERTE(SUCCEEDED(hr));

        // We only care about runtime actions, here.
        // Don't add security interceptors for anything else!
        dwMethDeclFlags     &= DECLSEC_RUNTIME_ACTIONS;
        dwMethNullDeclFlags &= DECLSEC_RUNTIME_ACTIONS;
    }

    EEClass *pCl = GetClass();
    if (pCl)
    {
        PSecurityProperties pSecurityProperties = pCl->GetSecurityProperties();
        if (pSecurityProperties)
        {
            dwClassDeclFlags    = pSecurityProperties->GetRuntimeActions();
            dwClassNullDeclFlags= pSecurityProperties->GetNullRuntimeActions();
        }
    }

    // Build up a set of flags to indicate the actions, if any,
    // for which we will need to set up an interceptor.

    // Add up the total runtime declarative actions so far.
    DWORD dwSecurityFlags = dwMethDeclFlags | dwClassDeclFlags;

    // Add in a declarative demand for NDirect.
    // If this demand has been overridden by a declarative check
    // on a class or method, then the bit won't change. If it's
    // overridden by an empty check, then it will be reset by the
    // subtraction logic below.
    if (IsNDirect())
    {
        dwSecurityFlags |= DECLSEC_UNMNGD_ACCESS_DEMAND;
    }

    if (dwSecurityFlags)
    {
        // If we've found any declarative actions at this point,
        // try to subtract any actions that are empty.

            // Subtract out any empty declarative actions on the method.
        dwSecurityFlags &= ~dwMethNullDeclFlags;

        // Finally subtract out any empty declarative actions on the class,
        // but only those actions that are not also declared by the method.
        dwSecurityFlags &= ~(dwClassNullDeclFlags & ~dwMethDeclFlags);
    }

    return dwSecurityFlags;
}

DWORD MethodDesc::GetSecurityFlags(IMDInternalImport *pInternalImport, mdToken tkMethod, mdToken tkClass, DWORD *pdwClassDeclFlags, DWORD *pdwClassNullDeclFlags, DWORD *pdwMethDeclFlags, DWORD *pdwMethNullDeclFlags)
{

    HRESULT hr = Security::GetDeclarationFlags(pInternalImport,
                                               tkMethod, 
                                               pdwMethDeclFlags,
                                               pdwMethNullDeclFlags);
    _ASSERTE(SUCCEEDED(hr));

    if (!IsNilToken(tkClass) && (*pdwClassDeclFlags == 0xffffffff || *pdwClassNullDeclFlags == 0xffffffff))
    {
        HRESULT hr = Security::GetDeclarationFlags(pInternalImport,
                                                   tkClass, 
                                                   pdwClassDeclFlags,
                                                   pdwClassNullDeclFlags);
        _ASSERTE(SUCCEEDED(hr));

    }

    // Build up a set of flags to indicate the actions, if any,
    // for which we will need to set up an interceptor.

    // Add up the total runtime declarative actions so far.
    DWORD dwSecurityFlags = *pdwMethDeclFlags | *pdwClassDeclFlags;

    // Add in a declarative demand for NDirect.
    // If this demand has been overridden by a declarative check
    // on a class or method, then the bit won't change. If it's
    // overridden by an empty check, then it will be reset by the
    // subtraction logic below.
    if (IsNDirect())
    {
        dwSecurityFlags |= DECLSEC_UNMNGD_ACCESS_DEMAND;
    }

    if (dwSecurityFlags)
    {
        // If we've found any declarative actions at this point,
        // try to subtract any actions that are empty.

            // Subtract out any empty declarative actions on the method.
        dwSecurityFlags &= ~*pdwMethNullDeclFlags;

        // Finally subtract out any empty declarative actions on the class,
        // but only those actions that are not also declared by the method.
        dwSecurityFlags &= ~(*pdwClassNullDeclFlags & ~*pdwMethDeclFlags);
    }

    return dwSecurityFlags;
}

MethodImpl *MethodDesc::GetMethodImpl()
{
    _ASSERTE(IsMethodImpl());

    switch (GetClassification())
    {
    case mcIL:
        return ((MI_MethodDesc*)this)->GetImplData();
    case mcECall:
        return ((MI_ECallMethodDesc*)this)->GetImplData();
    case mcNDirect:
        return ((MI_NDirectMethodDesc*)this)->GetImplData();
    case mcEEImpl:
        return ((MI_EEImplMethodDesc*)this)->GetImplData();
    case mcArray:
        return ((MI_ArrayECallMethodDesc*)this)->GetImplData();
    case mcComInterop:
        return ((MI_ComPlusCallMethodDesc*)this)->GetImplData();
    default:
        _ASSERTE(!"Unknown MD Kind");
        return NULL;
    }
}

HRESULT MethodDesc::Save(DataImage *image)
{
    HRESULT hr;

#if _DEBUG
    if (!image->IsStored((void*) m_pszDebugMethodName))
        IfFailRet(image->StoreStructure((void *) m_pszDebugMethodName, 
                                        (ULONG)(strlen(m_pszDebugMethodName) + 1),
                                        DataImage::SECTION_DEBUG, 
                                        DataImage::DESCRIPTION_DEBUG, 
                                        mdTokenNil, 1));
    if (!image->IsStored(m_pszDebugClassName))
        IfFailRet(image->StoreStructure((void *) m_pszDebugClassName, 
                                        (ULONG)(strlen(m_pszDebugClassName) + 1),
                                        DataImage::SECTION_DEBUG, 
                                        DataImage::DESCRIPTION_DEBUG, 
                                        mdTokenNil, 1));
    if (!image->IsStored(m_pszDebugMethodSignature))
        IfFailRet(image->StoreStructure((void *) m_pszDebugMethodSignature, 
                                        (ULONG)(strlen(m_pszDebugMethodSignature) + 1),
                                        DataImage::SECTION_DEBUG, 
                                        DataImage::DESCRIPTION_DEBUG, 
                                        mdTokenNil, 1));
#endif

    if (IsMethodImpl() && !IsUnboxingStub())
    {
        MethodImpl *pImpl = GetMethodImpl();

        IfFailRet(pImpl->Save(image, GetMemberDef()));
    }

    if (HasStoredSig())
    {
        StoredSigMethodDesc *pNewSMD = (StoredSigMethodDesc*) this;

        if (pNewSMD->m_pSig != NULL)
        {
            if (!image->IsStored((void *) pNewSMD->m_pSig))
                image->StoreStructure((void *) pNewSMD->m_pSig, 
                                      pNewSMD->m_cSig,
                                      DataImage::SECTION_METHOD_INFO,
                                      DataImage::DESCRIPTION_METHOD_DESC, 
                                      GetMemberDef(), 1);
        }
    }

    if (IsNDirect())
    {
        NDirectMethodDesc *pNMD = (NDirectMethodDesc *)this;

        // Fix up and save the ML stub
        MLHeader *pMLHeader = pNMD->GetMLHeader();

        if (pMLHeader == NULL || pMLHeader->m_Flags & MLHF_NEEDS_RESTORING)
        {
            // Either The ML stub hasn't been computed yet, or it hasn't
            // been restored from a previous prejit run.
            // We need to explicitly compute it or restore it and store 
            // it in the stub. 
            // 
            // (Note that we can't guarantee the normal ndirect fixup logic 
            // will always store an ML stub in the field in the ndirect 
            // method desc, since sometimes a native stub is produced and the 
            // ML stub is thrown away.)

            Stub *pStub = NULL;

            COMPLUS_TRY {
                if (pMLHeader == NULL)
                    pStub = NDirect::ComputeNDirectMLStub(pNMD);
                else
                    pStub = RestoreMLStub(pMLHeader, GetModule());
            } COMPLUS_CATCH {
                // @todo: should to report this as a warning somehow
            } COMPLUS_END_CATCH

            if (pStub != NULL) 
            {
                MLHeader *pNewMLHeader = (MLHeader *) pStub->GetEntryPoint();

                if (!pNMD->InterlockedReplaceMLHeader(pNewMLHeader, pMLHeader))
                {
                    pStub->DecRef();
                    pMLHeader = pNMD->GetMLHeader();
                }
                else
                {
                    // Note that an unrestored ml stub will be static data in the prejit image, 
                    // so there is no need to release it.

                    pMLHeader = pNewMLHeader;
                }
            }
        }

        if (pMLHeader != NULL
            && !image->IsStored((void *) pMLHeader))
            StoreMLStub(pMLHeader, image, GetMemberDef());

        if (pNMD->ndirect.m_szLibName != NULL
            && !image->IsStored((void*) pNMD->ndirect.m_szLibName))
            image->StoreStructure((void*) pNMD->ndirect.m_szLibName, 
                                  (ULONG)strlen(pNMD->ndirect.m_szLibName)+1,
                                  DataImage::SECTION_METHOD_INFO,
                                  DataImage::DESCRIPTION_METHOD_DESC,
                                  GetMemberDef(), 1);

        if (pNMD->ndirect.m_szEntrypointName != NULL
            && !image->IsStored((void*) pNMD->ndirect.m_szEntrypointName))
            image->StoreStructure((void*) pNMD->ndirect.m_szEntrypointName, 
                                  (ULONG)strlen(pNMD->ndirect.m_szEntrypointName)+1,
                                  DataImage::SECTION_METHOD_INFO,
                                  DataImage::DESCRIPTION_METHOD_DESC,
                                  GetMemberDef(), 1);
    }

    return S_OK;
}

HRESULT MethodDesc::Fixup(DataImage *image, DWORD codeRVA)
{
    HRESULT hr;

#if _DEBUG
    IfFailRet(image->FixupPointerField(&m_pszDebugMethodName)); 
    IfFailRet(image->FixupPointerField(&m_pszDebugClassName)); 
    IfFailRet(image->FixupPointerField(&m_pszDebugMethodSignature)); 
    IfFailRet(image->FixupPointerField(&m_pDebugEEClass));
    IfFailRet(image->FixupPointerField(&m_pDebugMethodTable));
#endif

#ifdef _X86_
        //
        // Make sure op is CALL NEAR32
        // 
        StubCallInstrs *pStubCallInstrs = GetStubCallInstrs();
        BYTE *newOP = (BYTE *) image->GetImagePointer(&pStubCallInstrs->m_op);
        if (newOP == NULL)
            return E_POINTER;
        *newOP = 0xe8;
#endif
        BYTE *prestub = GetPreStubAddr();
        IfFailRet(image->FixupPointerField(prestub+1, 
                                           (void *) (GetModule()->GetPrestubJumpStub()
                                                     - (prestub+METHOD_CALL_PRESTUB_SIZE)),
                                           DataImage::REFERENCE_STORE,
                                           DataImage::FIXUP_RELATIVE));

    if (!IsUnboxingStub())
    {
        //
        // Image will fixup this field to be the generated
        // code address if it's prejitting code for this
        // MD; otherwise it will leave it as-is. Note that
        // it's OK to do this even if this MD uses security.
        //

        void *code;
        IfFailRet(image->GetFunctionAddress(this, &code));

        MethodDesc *pNewMD = (MethodDesc*) image->GetImagePointer(this);

        if (code != NULL)
        {
            pNewMD->m_wFlags |= mdcPrejitted;

            IfFailRet(image->FixupPointerField(&m_CodeOrIL, code,
                                               DataImage::REFERENCE_FUNCTION)); 
        }
        else if (IsIL())
        {
            if (codeRVA != 0)
            {
                pNewMD->m_wFlags |= mdcPrejitted;
                IfFailRet(image->FixupPointerField(&m_CodeOrIL, (void*)(size_t)(codeRVA|METHOD_IS_IL_FLAG),
                                                   DataImage::REFERENCE_FUNCTION, 
                                                   DataImage::FIXUP_RVA));
            }
            else if (IsJitted())
            {
                // 
                // Replace RVA if we have already jitted the code here
                //

                pNewMD->m_wFlags &= ~mdcPrejitted;
                *(size_t*)image->GetImagePointer(&m_CodeOrIL) = GetRVA()|METHOD_IS_IL_FLAG; 
            }
        }
        else if (IsECall())
        {
            // Set CodeOrIL to the FCall method ID (or'd with the high bit to mark it
            // as such)
            *(size_t*)image->GetImagePointer(&m_CodeOrIL) = GetIDForMethod(this)|METHOD_IS_IL_FLAG; 

            // Set FCall flag to FALSE, in case we decide at runtime to change it to an ecall
            // (this happens under IPD)
            pNewMD->SetFCall(FALSE);
        }
    }

    if (IsNDirect())
    {
        //
        // For now, set method desc back into its pristine uninitialized state.
        //

        NDirectMethodDesc *pNMD = (NDirectMethodDesc *)this;

        IfFailRet(image->FixupPointerField(&pNMD->ndirect.m_pNDirectTarget, 
                                           pNMD->ndirect.m_ImportThunkGlue));

        MLHeader *pMLHeader = pNMD->GetMLHeader();
        if (pMLHeader != NULL)
        {
            hr = FixupMLStub(pNMD->GetMLHeader(), image);
            IfFailRet(hr);
            if (hr == S_OK)
                IfFailRet(image->FixupPointerField(&pNMD->ndirect.m_pMLHeader));
            else
                IfFailRet(image->ZeroPointerField(&pNMD->ndirect.m_pMLHeader));
        }

        IfFailRet(image->FixupPointerField(pNMD->ndirect.m_ImportThunkGlue+1, 
                                           (void *) (GetModule()->GetNDirectImportJumpStub()
                                                     - (pNMD->ndirect.m_ImportThunkGlue
                                                        +METHOD_CALL_PRESTUB_SIZE)),
                                           DataImage::REFERENCE_STORE,
                                           DataImage::FIXUP_RELATIVE));
        if (pNMD->ndirect.m_szLibName != NULL)
            IfFailRet(image->FixupPointerField(&pNMD->ndirect.m_szLibName));
        if (pNMD->ndirect.m_szEntrypointName != NULL)
            IfFailRet(image->FixupPointerField(&pNMD->ndirect.m_szEntrypointName));
    }

    if (HasStoredSig())
    {
        StoredSigMethodDesc *pNewSMD = (StoredSigMethodDesc*) this;

        IfFailRet(image->FixupPointerField(&pNewSMD->m_pSig));
    }

    if (IsMethodImpl())
    {
        MethodImpl *pImpl = GetMethodImpl();

        IfFailRet(pImpl->Fixup(image, GetModule(), !IsUnboxingStub()));
    }

    if (IsComPlusCall())
    {
        ComPlusCallMethodDesc *pComPlusMD = (ComPlusCallMethodDesc*)this;

        IfFailRet(image->ZERO_FIELD(pComPlusMD->compluscall.m_pMLStub));
        IfFailRet(image->ZERO_FIELD(pComPlusMD->compluscall.m_pInterfaceMT));
    }

    return S_OK;
}

const BYTE* MethodDesc::GetAddrOfCodeForLdFtn()
{
#ifndef NEW_LDFTN
    if (IsRemotingIntercepted2()) 
        return *(BYTE**)CRemotingServices::GetNonVirtualThunkForVirtualMethod(this);
    else
        return GetUnsafeAddrofCode();
#else
    return (const BYTE *) GetClass()->GetMethodSlot(this);
#endif
}


// Attempt to store a kNoMarsh or kYesMarsh in the marshcategory field.
// Due to the need to avoid races with the prestub, there is a
// small but nonzero chance that this routine may silently fail
// and leave the marshcategory as "unknown." This is ok since
// all it means is that the JIT may have to do repeat some work
// the next time it JIT's a callsite to this NDirect.
void NDirectMethodDesc::ProbabilisticallyUpdateMarshCategory(MarshCategory value)
{
    // We can only attempt to go from kUnknown to Yes or No, or from
    // Yes to Yes and No to No.
    _ASSERTE(value == kNoMarsh || value == kYesMarsh);
    _ASSERTE(GetMarshCategory() == kUnknown || GetMarshCategory() == value); 


    // Due to the potential race with the prestub flags stored in the same
    // byte, we'll use InterlockedCompareExchange to ensure we don't
    // disturb those bits. But since InterlockedCompareExhange only
    // works on ULONGs, we'll have to operate on the entire ULONG. Ugh.

    BYTE *pb = &ndirect.m_flags;
    UINT ofs=0;

    // Decrement back until we have a ULONG-aligned address (not
    // sure if this needed for VipInterlocked, but better safe...)
    while (  ((size_t)pb) & (sizeof(ULONG)-1) )
    {
        ofs++;
        pb--;
    }

    // Ensure we won't be reading or writing outside the bounds of the NDirectMethodDesc.
    _ASSERTE(pb >= (BYTE*)this);
    _ASSERTE((pb+sizeof(ULONG)) < (BYTE*)(this+1));

    // Snapshot the existing bits
    ULONG oldulong = *(ULONG*)pb;
    
    // Modify the marshcat (and ONLY the marshcat fields in the snapshot)
    ULONG newulong = oldulong;
    ((BYTE*)&newulong)[ofs] &= ~kMarshCategoryMask;
    ((BYTE*)&newulong)[ofs] |= (value << kMarshCategoryShift);

    // Now, slam all 32 bits back in atomically but only if no other threads
    // have changed those bits since our snapshot. If they have, we will
    // silently throw away the new bits and no update will occur. That's
    // ok because this function's contract says it can throw away the update.
    VipInterlockedCompareExchange((ULONG*)pb, newulong, oldulong);

}

BOOL NDirectMethodDesc::InterlockedReplaceMLHeader(MLHeader *pMLHeader, MLHeader *pOldMLHeader)
{
    _ASSERTE(IsNDirect());
    _ASSERTE(sizeof(LONG) == sizeof(Stub*));
    MLHeader *pPrevML = (MLHeader*)FastInterlockCompareExchange( (void**)&ndirect.m_pMLHeader, 
                                                                 (void*)pMLHeader, (void*)pOldMLHeader );
    return pPrevML == pOldMLHeader;
}

void NDirectMethodDesc::InitEarlyBoundNDirectTarget(BYTE *ilBase, DWORD rva)
{
    _ASSERTE(GetSubClassification() == kEarlyBound);
    _ASSERTE(rva != 0);

    void *target = ilBase + rva;

    if (HeuristicDoesThisLookLikeAGetLastErrorCall((LPBYTE)target))
        target = (void*) FalseGetLastError;

    ndirect.m_pNDirectTarget = target;
}


void ComPlusCallMethodDesc::InitComEventCallInfo()
{
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pItfMT = GetInterfaceMethodTable();
    MethodDesc *pItfMD = this;
    PCCOR_SIGNATURE pSignature;
    DWORD cSignature;
    EEClass *pSrcItfClass = NULL;
    EEClass *pEvProvClass = NULL;

    // If this is a method impl we need to retrieve the interface MD this is
    // an impl for to make sure we have the right name.
    if (IsMethodImpl())
    {
        unsigned cbExtraSlots = pItfMT->GetComInterfaceType() == ifVtable ? 3 : 7;
        pItfMD = (ComPlusCallMethodDesc*)pItfMT->GetMethodDescForSlot(compluscall.m_cachedComSlot - cbExtraSlots);        
    }

    // Retrieve the event provider class.
    pItfMT->GetClass()->GetEventInterfaceInfo(&pSrcItfClass, &pEvProvClass);
    pItfMD->GetSig(&pSignature, &cSignature);

    // Find the method with the same name and sig on the event provider.
    compluscall.m_pEventProviderMD = pEvProvClass->FindMethod(pItfMD->GetName(), pSignature, cSignature, pItfMD->GetModule(), 
                                                              mdTokenNil, pItfMT);

    // If we could not find the method, then the event provider does not support
    // this event. This is a fatal error.
    if (!compluscall.m_pEventProviderMD)
    {
        // Retrieve the event provider class name.
        WCHAR wszEvProvClassName[MAX_CLASSNAME_LENGTH];
        pEvProvClass->_GetFullyQualifiedNameForClass(wszEvProvClassName, MAX_CLASSNAME_LENGTH);

        // Retrieve the COM event interface class name.
        WCHAR wszEvItfName[MAX_CLASSNAME_LENGTH];
        pItfMT->GetClass()->_GetFullyQualifiedNameForClass(wszEvItfName, MAX_CLASSNAME_LENGTH);

        // Convert the method name to unicode.
        WCHAR* wszMethName = (WCHAR*)_alloca(strlen(pItfMD->GetName()) + 1);
        swprintf(wszMethName, L"%S", pItfMD->GetName());

        // Throw the exception.
        COMPlusThrow(kTypeLoadException, IDS_EE_METHOD_NOT_FOUND_ON_EV_PROV, wszMethName, wszEvItfName, wszEvProvClassName);
    }
}


HRESULT MethodDescChunk::Save(DataImage *image)
{
    HRESULT hr;

    IfFailRet(image->StoreStructure(this, Sizeof(),
                                    DataImage::SECTION_METHOD_DESC, 
                                    DataImage::DESCRIPTION_METHOD_DESC, 
                                    GetMethodTable()->GetClass()->GetCl(), 8));

    // Save the debug strings & such.
    // Also need to save MethodImpl data if we're a method impl block.
    //

    for (unsigned int i=0; i<GetCount(); i++)
    {
        // Attribute each method desc individually
        image->ReattributeStructure(GetMethodDescAt(i)->GetMemberDef(), 
                                    GetMethodDescSize(), 
                                    GetMethodTable()->GetClass()->GetCl());

        IfFailRet(GetMethodDescAt(i)->Save(image));
    }

    return S_OK;
}

HRESULT MethodDescChunk::Fixup(DataImage *image, DWORD *pRidToCodeRVAMap)
{
    HRESULT hr;

    IfFailRet(image->FixupPointerField(&m_methodTable));

    //
    // Mark our chunk as no prestub, 
    // if we are omitting stubs
    //

    SIZE_T size = GetMethodDescSize();
    BYTE *p = (BYTE *) GetFirstMethodDesc();
    BYTE *pEnd = p + GetCount() * size;
    while (p < pEnd)
    {
        MethodDesc *md = (MethodDesc *) p;

        DWORD rid = RidFromToken(md->GetMemberDef());

        DWORD codeRVA;
        if (pRidToCodeRVAMap == NULL)
            codeRVA = 0;
        else
            codeRVA = pRidToCodeRVAMap[rid];

        IfFailRet(md->Fixup(image, codeRVA));

        p += size;
    }

    if (m_next != NULL)
        IfFailRet(image->FixupPointerField(&m_next));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\methodimpl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// method.hpp
//
#ifndef _METHODIMPL_H
#define _METHODIMPL_H

class MethodDesc;

// @TODO: This is very bloated. We need to trim this down alot. However, 
// we need to keep it on a 8 byte boundary.
class MethodImpl
{
private: 
    DWORD*       pdwSlots;       // Maintains the slots in sorted order, the first entry is the size
    MethodDesc** pImplementedMD;
public:

    MethodDesc* GetFirstImplementedMD(MethodDesc *pContainer);

    MethodDesc** GetImplementedMDs()
    {
        return pImplementedMD;
    }

    DWORD GetSize()
    {
        if(pdwSlots == NULL) 
            return NULL;
        else
            return *pdwSlots;
    }

    DWORD* GetSlots()
    {
        if(pdwSlots == NULL) 
            return NULL;
        else 
            return &(pdwSlots[1]);
    }

    HRESULT SetSize(LoaderHeap *pHeap, DWORD size)
    {
        if(size > 0) {
            pdwSlots = (DWORD*) pHeap->AllocMem((size + 1) * sizeof(DWORD)); // Add in the size offset
            if(pdwSlots == NULL) return E_OUTOFMEMORY;

            pImplementedMD = (MethodDesc**) pHeap->AllocMem(size * sizeof(MethodDesc*));
            if(pImplementedMD == NULL) return E_OUTOFMEMORY;
            *pdwSlots = size;
        }
        return S_OK;
    }

    HRESULT SetData(DWORD* slots, MethodDesc** md)
    {
        _ASSERTE(pdwSlots);
        DWORD dwSize = *pdwSlots;
        memcpy(&(pdwSlots[1]), slots, dwSize*sizeof(DWORD));
        memcpy(pImplementedMD, md, dwSize*sizeof(MethodDesc*));
        return S_OK;
    }

    // Returns the method desc for the replaced slot;
    MethodDesc* FindMethodDesc(DWORD slot, MethodDesc* defaultReturn);
    MethodDesc* RestoreSlot(DWORD slotIndex, MethodTable *pMT);

    static MethodImpl* GetMethodImplData(MethodDesc* pDesc);

    HRESULT Save(DataImage *image, mdToken attributed);
    HRESULT Fixup(DataImage *image, Module *pContainingModule, BOOL recursive);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\microsoft.comservices.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Mon Jul 17 19:19:10 2000
 */
/* Compiler settings for Z:\urt\inst\v1.x86chk\Microsoft.ComServices.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __Microsoft2EComServices_h__
#define __Microsoft2EComServices_h__

/* Forward Declarations */ 

#ifndef __IRegistrationHelper_FWD_DEFINED__
#define __IRegistrationHelper_FWD_DEFINED__
typedef interface IRegistrationHelper IRegistrationHelper;
#endif 	/* __IRegistrationHelper_FWD_DEFINED__ */


#ifndef __RegistrationHelperTx_FWD_DEFINED__
#define __RegistrationHelperTx_FWD_DEFINED__

#ifdef __cplusplus
typedef class RegistrationHelperTx RegistrationHelperTx;
#else
typedef struct RegistrationHelperTx RegistrationHelperTx;
#endif /* __cplusplus */

#endif 	/* __RegistrationHelperTx_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __Microsoft_ComServices_LIBRARY_DEFINED__
#define __Microsoft_ComServices_LIBRARY_DEFINED__

/* library Microsoft_ComServices */
/* [version][uuid] */ 


typedef /* [public][public][uuid] */  DECLSPEC_UUID("9D667CBC-FE79-3B45-AEBB-6303106B137A") 
enum __MIDL___MIDL_itf_Microsoft2EComServices_0000_0001
    {	InstallationFlags_Default	= 0,
	InstallationFlags_ExpectExistingTypeLib	= 1,
	InstallationFlags_CreateTargetApplication	= 2,
	InstallationFlags_FindOrCreateTargetApplication	= 4,
	InstallationFlags_ReconfigureExistingApplication	= 8,
	InstallationFlags_Register	= 256,
	InstallationFlags_Install	= 512,
	InstallationFlags_Configure	= 1024
    }	InstallationFlags;


EXTERN_C const IID LIBID_Microsoft_ComServices;

#ifndef __IRegistrationHelper_INTERFACE_DEFINED__
#define __IRegistrationHelper_INTERFACE_DEFINED__

/* interface IRegistrationHelper */
/* [object][custom][oleautomation][uuid] */ 


EXTERN_C const IID IID_IRegistrationHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55E3EA25-55CB-4650-8887-18E8D30BB4BC")
    IRegistrationHelper : public IUnknown
    {
    public:
        virtual HRESULT __stdcall InstallAssembly( 
            /* [in] */ BSTR assembly,
            /* [out][in] */ BSTR __RPC_FAR *application,
            /* [out][in] */ BSTR __RPC_FAR *tlb,
            /* [in] */ InstallationFlags installFlags) = 0;
        
        virtual HRESULT __stdcall RegisterAssembly( 
            /* [in] */ BSTR assembly,
            /* [out][in] */ BSTR __RPC_FAR *tlb) = 0;
        
        virtual HRESULT __stdcall ConfigureAssembly( 
            /* [in] */ BSTR assembly,
            /* [in] */ BSTR application) = 0;
        
        virtual HRESULT __stdcall UninstallAssembly( 
            /* [in] */ BSTR assembly,
            /* [in] */ BSTR application) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegistrationHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRegistrationHelper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRegistrationHelper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRegistrationHelper __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *InstallAssembly )( 
            IRegistrationHelper __RPC_FAR * This,
            /* [in] */ BSTR assembly,
            /* [out][in] */ BSTR __RPC_FAR *application,
            /* [out][in] */ BSTR __RPC_FAR *tlb,
            /* [in] */ InstallationFlags installFlags);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterAssembly )( 
            IRegistrationHelper __RPC_FAR * This,
            /* [in] */ BSTR assembly,
            /* [out][in] */ BSTR __RPC_FAR *tlb);
        
        HRESULT ( __stdcall __RPC_FAR *ConfigureAssembly )( 
            IRegistrationHelper __RPC_FAR * This,
            /* [in] */ BSTR assembly,
            /* [in] */ BSTR application);
        
        HRESULT ( __stdcall __RPC_FAR *UninstallAssembly )( 
            IRegistrationHelper __RPC_FAR * This,
            /* [in] */ BSTR assembly,
            /* [in] */ BSTR application);
        
        END_INTERFACE
    } IRegistrationHelperVtbl;

    interface IRegistrationHelper
    {
        CONST_VTBL struct IRegistrationHelperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegistrationHelper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrationHelper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegistrationHelper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegistrationHelper_InstallAssembly(This,assembly,application,tlb,installFlags)	\
    (This)->lpVtbl -> InstallAssembly(This,assembly,application,tlb,installFlags)

#define IRegistrationHelper_RegisterAssembly(This,assembly,tlb)	\
    (This)->lpVtbl -> RegisterAssembly(This,assembly,tlb)

#define IRegistrationHelper_ConfigureAssembly(This,assembly,application)	\
    (This)->lpVtbl -> ConfigureAssembly(This,assembly,application)

#define IRegistrationHelper_UninstallAssembly(This,assembly,application)	\
    (This)->lpVtbl -> UninstallAssembly(This,assembly,application)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IRegistrationHelper_InstallAssembly_Proxy( 
    IRegistrationHelper __RPC_FAR * This,
    /* [in] */ BSTR assembly,
    /* [out][in] */ BSTR __RPC_FAR *application,
    /* [out][in] */ BSTR __RPC_FAR *tlb,
    /* [in] */ InstallationFlags installFlags);


void __RPC_STUB IRegistrationHelper_InstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRegistrationHelper_RegisterAssembly_Proxy( 
    IRegistrationHelper __RPC_FAR * This,
    /* [in] */ BSTR assembly,
    /* [out][in] */ BSTR __RPC_FAR *tlb);


void __RPC_STUB IRegistrationHelper_RegisterAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRegistrationHelper_ConfigureAssembly_Proxy( 
    IRegistrationHelper __RPC_FAR * This,
    /* [in] */ BSTR assembly,
    /* [in] */ BSTR application);


void __RPC_STUB IRegistrationHelper_ConfigureAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRegistrationHelper_UninstallAssembly_Proxy( 
    IRegistrationHelper __RPC_FAR * This,
    /* [in] */ BSTR assembly,
    /* [in] */ BSTR application);


void __RPC_STUB IRegistrationHelper_UninstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegistrationHelper_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_RegistrationHelperTx;

#ifdef __cplusplus

class DECLSPEC_UUID("89A86E7B-C229-4008-9BAA-2F5C8411D7E0")
RegistrationHelperTx;
#endif
#endif /* __Microsoft_ComServices_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ml.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// ML.H -
//
// Marshaling engine.

#ifndef __ML_H__
#define __ML_H__


//=========================================================================
// Support for ML (Marshaling Language.)
//
// ML is a special-purpose interpreted language used for implementing
// parameter-translation thunks between managed and unmanaged code. Its
// main clients are N/Direct, the managed-unmanaged thunks for IAT's
// and exports and COM interop.
//
// ML has an easily JIT-compilable subset so the interpreter is used
// only for thunking calls with complex data types where the basic cost
// of translating the data overwhelms the interpreter overhead.
// Hence, minimizing ML stub size is given priority over speed of
// interpretation.
//
// The ML interpreter state consists of:
//
//   - A "SRC" post-incremented pointer which walks over
//     a buffer containing arguments to be translated.
//
//   - A "DST" pointer which walks over a buffer which receives
//     the translated arguments. Depending on a flag passed to the
//     interpreter (RunML), "DST" is either post-incremented or
//     pre-decremented. This is required since depending on the
//     mutual calling convention, the ML stream may need to reverse
//     the order of the arguments while translating them.
//
//   - A "LOCALWALK" post-incremented pointer which walks over
//     the LOCAL array, an array of bytes that the ML stream can use
//     for temporary storage. Each ML opcode uses a fixed number of local
//     bytes (most of them zero.) Each time an ML opcode is executed,
//     LOCALWALK is incremented by the associated number of bytes.
//
//   - A "LOCAL" pointer which never changes value. This always points
//     to the start of the local space so that locals can be
//     accessed via a fixed offset rather than thru LOCALWALK.
//
//   - A pointer to a CleanupWorkList structure where ML opcodes
//     can throw stuff to be cleaned up on exceptions and exit.
//     The ML opcodes that specifically require a CleanupWorkList
//     are marked as such in the gMLInfo database. If no such instructions
//     appear in the ML stream, you need not provide a CleanupWorkList.
//
// Most ML opcodes perform the following action:
//
//     1. Load some value from *SRC, and increment SRC by the size of
//        that value.
//     2. Perform a conversion on that value.
//     3. If the direction mode is -1, predecrement DST by the size of the
//        result.
//     4. Store the result in *DST.
//     5. If the direction mode is +1, postincrement DST by the size of the
//        value.
//
// Some ML opcodes work in pairs, e.g. one to convert a StringBuffer to
// an LPWSTR prior to a DLL function call, then another to copy any changes
// back to the StringBuffer after the DLL function call. Such opcode pairs
// typically use the LOCAL space to communicate.
//
// The MLOPDEF.H file contains the definitions of all ML opcodes.
//
// ML opcodes should all be designed so that an ML-stream is relocatable
// without fixups. This allows two ML stubs to be compared for equality
// (and thus, reusability) via a simple comparision algorithm.
//=========================================================================



#include "vars.hpp"
#include "util.hpp"
#include "object.h"
#include "comvariant.h"

class CleanupWorkList;


//----------------------------------------------------------------------
// Create the enum for each ML opcode.
//----------------------------------------------------------------------
#undef DEFINE_ML
#define DEFINE_ML(name,operandbytes,frequiredCleanup,cblocals,Hndl) name,
enum _MLOpcode
{
#include "mlopdef.h"
    ML_COUNT,           // defines number of ML opcodes
};


#undef DEFINE_ML
#define DEFINE_ML(name,operandbytes,frequiredCleanup,cblocals,hndl) 
enum _MLArrayMarshaler
{
#include "mlopdef.h"
};




typedef UINT8 MLCode;


#define ML_IN  0x10
#define ML_OUT 0x20


//----------------------------------------------------------------------
// Declare a database of MLCode information.
//----------------------------------------------------------------------
struct MLInfo {
    // Size, in bytes, of the ML instruction not including the opcode byte
    // itself.
    UINT8       m_numOperandBytes;

    // Boolean: does it or does not require a valid CleanupWorkList.
    UINT8       m_frequiresCleanup;

    // Number of bytes of localspace used.
    UINT16      m_cbLocal;

	// Boolean: does it require a handle
	UINT8		m_frequiresHandle;

#ifdef _DEBUG
    // Human-readable name of ML opcode.
    LPCSTR      m_szDebugName;
#endif
};

//----------------------------------------------------------------------
// struct to compute the summary of a series of ML codes
//----------------------------------------------------------------------
struct MLSummary
{
	// whether this stream requires cleanup
	BOOL		m_fRequiresCleanup;
	// total size of the ML Stream
	unsigned	m_cbMLSize;
	// total size of the locals
	unsigned	m_cbTotalLocals;
	// total number of handles needed
	unsigned	m_cbTotalHandles;
	// helper that computes summary info
	VOID ComputeMLSummary(const MLCode *pMLCode);
    MLSummary() : m_fRequiresCleanup(0), m_cbMLSize(0), m_cbTotalLocals(0), m_cbTotalHandles(0) {}
};

extern const MLInfo gMLInfo[];










//----------------------------------------------------------------------
// Computes the length of an MLCode stream in bytes, including
// the terminating ML_END opcode.
//----------------------------------------------------------------------
UINT MLStreamLength(const MLCode * const pMLCode);

//----------------------------------------------------------------------
// checks if MLCode stream requires cleanup
//----------------------------------------------------------------------

BOOL MLStreamRequiresCleanup(const MLCode  *pMLCode);

//----------------------------------------------------------------------
// Executes MLCode up to the next ML_END or ML_INTERRUPT opcode.
//
// Inputs:
//    psrc             - sets initial value of SRC register
//    pdst             - sets initial value of DST register
//    plocals          - pointer to ML local var array
//    pParmInfo		   - (optional) used to gather platform-specific info
//						 during parameter marshalling process in order to 
//						 generate the appropriate call setup.
//    pCleanupWorkList - (optional) pointer to initialized
//                       CleanupWorkList. this pointer may be NULL if none
//                       of the opcodes in the MLCode stream uses it.
//
// Returns: a pointer to the first MLCode opcode _after_ the one
// that terminated execution.
//----------------------------------------------------------------------
const MLCode *
RunML(const  MLCode   *       pMLCode,
      const    VOID   *       pSource,
               VOID   *       pDestination,
             UINT8    * const pLocals,
      CleanupWorkList * const pCleanupWorkList);


//----------------------------------------------------------------------
// An image of the record placed on LOCAL array by the ML_STR_WR_2_CUNI
// instruction.
//----------------------------------------------------------------------
#pragma pack(push, 1)

struct ML_STR_WR_2_CUNI_SR
{
    public:
        LPCWSTR DoConversion(STRINGREF pStringRef, CleanupWorkList *pCleanup);

    private:
        enum {
#ifdef _DEBUG
            kStackBufferSize = 4
#else
            kStackBufferSize = 260
#endif
        };


        // Keep these fields together!!!
        UINT32      m_bstrsize;
        // Stack buffer for storing conversion of short strings.
        WCHAR       m_buf[kStackBufferSize];
};

#pragma pack(pop)









//----------------------------------------------------------------------
// ArrayWithOffset
//----------------------------------------------------------------------
struct ML_ARRAYWITHOFFSET_C2N_SR
{
    public:
        //----------------------------------------------------------------------
        // Convert ArrayWithOffset to native array
        //----------------------------------------------------------------------
        LPVOID DoConversion(BASEARRAYREF *ppProtectedArrayRef, //pointer to GC-protected BASERARRAYREF,
                            UINT32        cbOffset,
                            UINT32        cbCount,
                            CleanupWorkList *pCleanup);


        //----------------------------------------------------------------------
        // Backpropagates changes to the native array back to the COM+ array.
        //----------------------------------------------------------------------
        VOID   BackPropagate();

    private:
    enum {
        //----------------------------------------------------------------------
        // Size in bytes of the stack buffer used for short arrays.
        //----------------------------------------------------------------------
#ifdef _DEBUG
        kStackBufferSize = 4
#else
        kStackBufferSize = 270
#endif
    };

        BASEARRAYREF    *m_ppProtectedArrayRef;
        UINT32           m_cbOffset;
        UINT32           m_cbCount;
        LPVOID           m_pNativeArray;
        BYTE             m_StackBuffer[kStackBufferSize];



};























//----------------------------------------------------------------------
// This marshaling structure is designed specifically to implement VB's
// "ByVal String" rule for DECLAREs.
//
// The rule is tricky because VB programs rely on the unmanaged target
// be able to mutate the strings (which are otherwise immutable in VB.)
//
// So we use a trick where the VB passes us a pointer to the String,
// we convert the string into an Ansi BSTR, and on return, we create
// a new string based on the changed contents of the BSTR and replace
// the original string.
//----------------------------------------------------------------------
struct ML_VBBYVALSTR_SR
{
    public:
        LPSTR DoConversion(STRINGREF *ppStringRef, BYTE fBestFitMapping, BYTE fThrowOnUnmappableChar, CleanupWorkList *pCleanup);
        VOID BackPropagate(BOOL *pfDeferredException);

    private:
        enum {
#ifdef _DEBUG
            kStackBufferSize = 8
#else
            kStackBufferSize = 264
#endif
        };

        // Stack buffer for storing conversion of short strings.
        // (Have to reserve two bytes per character for MBCS compatibility.)
        CHAR       m_buf[kStackBufferSize*2];

        // Pointer to the box where we store a pointer to the String.
        // WARNING: Assumes we pin this reference on GC. 
        STRINGREF *m_ppStringRef;

        // Points either to m_buf or heapallocated memory.
        LPSTR      m_pNative;


        // Hold original managed length of string.
        DWORD      m_ncOriginalLength;
};



//----------------------------------------------------------------------
// A rather hacky way of marshaling byref valuetypes from unmanaged to managed.
// We have to use this backdoor route because the marshaling architecture
// makes it hard to do the necessary GC promoting.
//----------------------------------------------------------------------
struct ML_REFVALUECLASS_N2C_SR
{
    public:
        LPVOID       DoConversion(LPVOID pUmgdVC, BYTE fInOut, MethodTable *pMT, CleanupWorkList *pCleanup);
        VOID         BackPropagate(BOOL *pfDeferredException);

    private:
        OBJECTHANDLE m_pObjHnd;  //handle to boxed valueclass
		LPVOID       m_pUnmgdVC;
        MethodTable *m_pMT;
		BYTE		 m_fInOut;
};




//----------------------------------------------------------------------
// A rather hacky way of marshaling byref Variant from unmanaged to managed.
// We have to use this backdoor route because the marshaling architecture
// makes it hard to do the necessary GC promoting.
//----------------------------------------------------------------------
struct ML_REFVARIANT_N2C_SR
{
    public:
        VariantData *DoConversion(VARIANT* pUmgdVariant, BYTE fInOut, CleanupWorkList *pCleanup);
        VOID         BackPropagate(BOOL *pfDeferredException, HRESULT *pdeferredExceptionHR);

    private:
        OBJECTHANDLE m_pObjHnd;  //handle to boxed Variant
		VARIANT     *m_pUnmgdVariant;
		BYTE		 m_fInOut;
};


//----------------------------------------------------------------------
// A special structure for handling "VARIANT* <--> ref Object" 
// parameter marshaling. This special backdoor is required because
// of some special context-sensitive handling that falls outside
// the normal marshaler's capabilities.
//----------------------------------------------------------------------
struct ML_REFOBJECT_N2C_SR
{
	public:
		OBJECTREF   *DoConversion(VARIANT *pUmgdVariant, BYTE fInOut, CleanupWorkList *pCleanup);
        VOID         BackPropagate(BOOL *pfDeferredException, HRESULT *pdeferredExceptionHR);

	private:
		OBJECTREF*   m_pObjRef; // protected object
		VARIANT		*m_pUnmgdVariant;
		BYTE		 m_fInOut;
};


//----------------------------------------------------------------------
// This marshaling structure is designed specifically to implement VB's
// "ByVal String" rule for DECLAREs.
//
// The rule is tricky because VB programs rely on the unmanaged target
// be able to mutate the strings (which are otherwise immutable in VB.)
//
// So we use a trick where the VB passes us a pointer to the String,
// we convert the string into an Ansi BSTR, and on return, we create
// a new string based on the changed contents of the BSTR and replace
// the original string.
//----------------------------------------------------------------------
struct ML_VBBYVALSTRW_SR
{
    public:
        LPWSTR DoConversion(STRINGREF *ppStringRef, CleanupWorkList *pCleanup);
        VOID BackPropagate(BOOL *pfDeferredException);

    private:
        enum {
#ifdef _DEBUG
            kStackBufferSize = 8
#else
            kStackBufferSize = 264
#endif
        };

        // Stack buffer for storing conversion of short strings.
        WCHAR       m_buf[kStackBufferSize];

        // Pointer to the box where we store a pointer to the String.
        // WARNING: Assumes we pin this reference on GC. 
        STRINGREF *m_ppStringRef;

        // Points either to m_buf or heapallocated memory.
        LPWSTR      m_pNative;

        // Hold original managed length of string.
        DWORD      m_ncOriginalLength;

};







struct ML_REFVALUECLASS_C2N_SR
{
    public:
        LPVOID DoConversion(LPVOID          *ppProtectedData,
                            MethodTable     *pMT,
                            BYTE             fInOut,
                            CleanupWorkList *pCleanup         
                           );
    
    
        VOID BackPropagate(BOOL *pfDeferredException);
    
    private:
        LPVOID      *m_ppProtectedData;
        MethodTable *m_pMT;
        BYTE        *m_buf;
        BYTE        m_inout;
};




//----------------------------------------------------------------------
// For N/Direct "ole" calls, this is the return value buffer that
// the marshaling engine pushes on the stack.
//----------------------------------------------------------------------
union RetValBuffer
{
    UINT32      m_i32;
    UINT64      m_i64;
    LPVOID      m_ptr;
};




//===========================================================================
// Stackrecord for the ML_BYREF* family.
//===========================================================================
struct ML_BYREF_SR
{
    union
    {
        INT8    i8;
        INT16   i16;
        INT32   i32;
        INT64   i64;
        LPVOID  pv;
    };
    const LPVOID *ppRef;  // pointer to (gc-promoted) reference
};


UINT SizeOfML_OBJECT_C2N_SR();



//===========================================================================
// A common header that precedes ML stubs for NDirect & COM interop.
// This doesn't really belong in ml.h but I don't want to create another
// header just for this.
//===========================================================================



#define MLHF_TYPECAT_NORMAL          0    //! This value must stay at zero!!!
#define MLHF_TYPECAT_VALUECLASS      1
#define MLHF_TYPECAT_FPU             2
#define MLHF_TYPECAT_GCREF           3    //Requires GC protection 

#define MLHF_MANAGEDRETVAL_TYPECAT_MASK   0x0003

#define MLHF_UNMANAGEDRETVAL_TYPECAT_MASK 0x000c
#define MLHF_64BITMANAGEDRETVAL           0x0010     // Managed return value is 64 bits
#define MLHF_64BITUNMANAGEDRETVAL         0x0020     // Unmanaged return value is 64 bits
#define MLHF_NATIVERESULT                 0x0040     // com call returns native result (not HRESULT)
#define MLHF_SETLASTERROR                 0x0080     // Must preserve last error (N/Direct only)
#define MLHF_THISCALL                     0x0100     // Requires thiscall mod
#define MLHF_THISCALLHIDDENARG            0x0200     // Requires thiscall and has hidden structure buffer arg
#define MLHF_DISPCALLWITHWRAPPERS         0x0400     // Dispatch call that requires arg wrapping
#define MLHF_NEEDS_RESTORING              0x8000     // ML stub needs restore from prejit state


// MLHeader and the following MLCode double as hash keys
// for the MLStubCache. Thus, it's imperative that there be no
// unused "pad" fields that contain unstable values.
#pragma pack(push)
#pragma pack(1)


struct MLHeader
{
    UINT16        m_cbDstBuffer;  //# of bytes required in the destination buffer
    UINT16        m_cbLocals;     //# of bytes required in the local array
    UINT16        m_cbStackPop;   //# of stack bytes that must be popped off (== CbStackPop)
    UINT16        m_Flags;        //flags (see MLHF_* values)

    const MLCode *GetMLCode() const
    {
        return (const MLCode *)(this+1);
    }


    VOID SetManagedRetValTypeCat(int mlhftypecat)
    {
        m_Flags &= ~3;
        m_Flags |= mlhftypecat;
    }


    VOID SetUnmanagedRetValTypeCat(int mlhftypecat)
    {
        m_Flags &= ~0x0c;
        m_Flags |= (mlhftypecat << 2);
    }


    int GetManagedRetValTypeCat() const
    {
        return m_Flags & 3;
    }

    int GetUnmanagedRetValTypeCat() const
    {
        return (m_Flags >> 2) & 3;
    }



	BOOL ReturnsValueClass() const
	{
		return MLHF_TYPECAT_VALUECLASS == this->GetManagedRetValTypeCat();
	}

	VOID SetReturnValueClass() 
	{
		SetManagedRetValTypeCat(MLHF_TYPECAT_VALUECLASS);
	}


};

#pragma pack(pop)


#pragma pack(push)
#pragma pack(1)

// This ML opcode takes lot of parameters that we post-patch: to keep everyone in sync,
// we capture its format in a structure.
struct ML_CREATE_MARSHALER_CARRAY_OPERANDS
{
    MethodTable     *methodTable;
    VARTYPE         elementType;
    union 
    {
        UINT16      countParamIdx;      //before patching
        INT16       offsetbump;         //after patching
    };
    UINT8           countSize;          //if 0, sizeiz computation disabled: use managed size of array instead
    UINT32          multiplier;
    UINT32          additive;
    BYTE            bestfitmapping;
    BYTE            throwonunmappablechar;
};

#pragma pack(pop)


// Handle return values of structures.
struct ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_SR
{
    public:
        LPVOID DoConversion(const VOID * psrc, UINT32 cbSize);
        VOID BackPropagate(BOOL *pfDeferredException);
	private:
		const VOID *m_psrc;
		LPVOID m_pTempCopy;		// the managed structure can move due to GC, so need temporary fixed buffer
		UINT32 m_cbSize;

};


// Handle BSTR's
struct ML_BSTR_C2N_SR
{
	public:
        LPCWSTR DoConversion(STRINGREF pStringRef, CleanupWorkList *pCleanup);

	private:
#ifdef _DEBUG
		BYTE	m_buf[8];
#else
		BYTE	m_buf[256];
#endif
};

// Handle CSTR's
struct ML_CSTR_C2N_SR
{
	public:
        LPSTR DoConversion(STRINGREF pStringRef, UINT32 fBestFitMapping, UINT32 fThrowOnUnmappableChar, CleanupWorkList *pCleanup);

	private:
#ifdef _DEBUG
		BYTE	m_buf[8];
#else
		BYTE	m_buf[256];
#endif
};


// Managed layout for SRI.HandleRef class
struct HANDLEREF
{
    OBJECTREF m_wrapper;
    LPVOID    m_handle;
};

// Handle WSTR buffers
struct ML_WSTRBUILDER_C2N_SR
{
	public:
		LPWSTR   DoConversion(STRINGBUFFERREF *ppProtectedStringBuffer, CleanupWorkList *pCleanup);
		VOID	 BackPropagate(BOOL *pfDeferredException);
		
	private:
		STRINGBUFFERREF *m_ppProtectedStringBuffer;
		LPWSTR	        m_pNative;
		LPWSTR          m_pSentinel;
};

// Handle CSTR buffers
struct ML_CSTRBUILDER_C2N_SR
{
	public:
		LPSTR    DoConversion(STRINGBUFFERREF *ppProtectedStringBuffer, BYTE fBestFitMapping, BYTE fThrowOnUnmappableChar, CleanupWorkList *pCleanup);
		VOID	 BackPropagate(BOOL *pfDeferredException);
		
	private:
		STRINGBUFFERREF *m_ppProtectedStringBuffer;
		LPSTR	        m_pNative;
		LPSTR          m_pSentinel;
};


// Handle N->C calls to fcns that return structures
struct ML_STRUCTRETN2C_SR
{
    public:
        LPVOID          m_pNativeRetBuf;
        OBJECTREF      *m_ppProtectedBoxedObj;
        MethodTable    *m_pMT;

        void            MarshalRetVal(BOOL *pfDeferredException);
};


// Handle C->N calls to fcns that return structures
struct ML_STRUCTRETC2N_SR
{
    public:
        LPVOID          m_pNativeRetBuf;
        LPVOID         *m_ppProtectedValueTypeBuf;
        MethodTable    *m_pMT;

        void            MarshalRetVal(BOOL *pfDeferredException);
};

// Handle C->N calls to fcns that return currency
struct ML_CURRENCYRETC2N_SR
{
    public:
        CURRENCY        m_cy;
        DECIMAL       **m_ppProtectedValueTypeBuf;

        void            MarshalRetVal(BOOL *pfDeferredException);
};


// Handle N->C calls to fcns that return currencies
struct ML_CURRENCYRETN2C_SR
{
    public:
        CURRENCY       *m_pcy;      //unmanaged 
        DECIMAL         m_decimal;  //managed 

        void            MarshalRetVal(BOOL *pfDeferredException);
};

// Handle N->C calls to fcns that return currencies
struct ML_DATETIMERETN2C_SR
{
    public:
        DATE           *m_pdate; //unmanaged
        INT64           m_datetime; //managed

        void            MarshalRetVal(BOOL *pfDeferredException);
};



VOID STDMETHODCALLTYPE DoMLCreateMarshalerBStr(Frame *pFrame, CleanupWorkList *pCleanup, UINT8 *plocalwalk);
VOID STDMETHODCALLTYPE DoMLCreateMarshalerCStr(Frame *pFrame, CleanupWorkList *pCleanup, UINT8 *plocalwalk, UINT32 fBestFitMapping, UINT32 fThrowOnUnmappableChar);
VOID STDMETHODCALLTYPE DoMLCreateMarshalerWStr(Frame *pFrame, CleanupWorkList *pCleanup, UINT8 *plocalwalk);
VOID STDMETHODCALLTYPE DoMLPrereturnC2N(Marshaler *pMarshaler, LPVOID pstackout);
LPVOID STDMETHODCALLTYPE DoMLReturnC2NRetVal(Marshaler *pMarshaler);

#endif //__ML_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mlcache.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// MLCACHE.H -
//
// Base class for caching ML stubs.
//


#ifndef __mlcache_h__
#define __mlcache_h__


#include "vars.hpp"
#include "util.hpp"
#include "crst.h"

class Stub;
class StubLinker;

class MLStubCache : private CClosedHashBase {

    public:


        //---------------------------------------------------------
        // Describes the compiled state of an ML stub.
        //---------------------------------------------------------
        enum MLStubCompilationMode {
            STANDALONE   = 0, // Completely compiled to a native stub
            SHAREDPROLOG = 1, // Compiled to a Prolog/Epilog-less native stub
            INTERPRETED  = 2  // Not compiled - must interpret the ML code
        };

        //---------------------------------------------------------
        // Constructor
        //---------------------------------------------------------
        MLStubCache(LoaderHeap *heap = 0);

        //---------------------------------------------------------
        // Destructor
        //---------------------------------------------------------
        ~MLStubCache();

        //---------------------------------------------------------
        // Returns the equivalent hashed Stub, creating a new hash
        // entry if necessary. If the latter, will call out to CompileMLStub.
        //
        // On successful exit, *pMode is set to describe
        // the compiled nature of the MLStub.
        //
        // callerContext can be used by the caller to push some context through
        // to the compilation routine.
        //
        // Returns NULL for out of memory or other fatal error.
        //---------------------------------------------------------
        Stub *Canonicalize(const BYTE *pRawMLStub, MLStubCompilationMode *pMode,
                           void *callerContext = 0);


        //---------------------------------------------------------
        // Call this occasionally to get rid of unused stubs.
        //---------------------------------------------------------
        VOID FreeUnusedStubs();

        //-------------------------------------------------------------------
        // ForceDeleteStubs
        //
        // Forces all cached stubs to free themselves. This routine forces the refcount
        // to 1, then does a DecRef. It is not threadsafe, and thus can
        // only be used in shutdown scenarios.
        //-------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
        VOID ForceDeleteStubs();
#endif /* SHOULD_WE_CLEANUP */


    protected:
        //---------------------------------------------------------
        // OVERRIDE.
        // Compile a native (ASM) version of the ML stub.
        //
        // This method should compile into the provided stublinker (but
        // not call the Link method.)
        //
        // It should return the chosen compilation mode.
        //
        // If the method fails for some reason, it should return
        // INTERPRETED so that the EE can fall back on the already
        // created ML code.
        //---------------------------------------------------------
        virtual MLStubCompilationMode CompileMLStub(const BYTE *pRawMLStub,
                                                    StubLinker *psl,
                                                    void *callerContext) = 0;

        //---------------------------------------------------------
        // OVERRIDE
        // Tells the MLStubCache the length of an ML stub.
        //---------------------------------------------------------
        virtual UINT Length(const BYTE *pRawMLStub) = 0;

    private:

        //---------------------------------------------------------
        // Hash entry for CClosedHashBase.
        //---------------------------------------------------------
        struct MLCHASHENTRY {
            // Values:
            //   NULL  = free
            //   -1    = deleted
            //   other = used
            Stub    *m_pMLStub;

            // Offset where the RawMLStub begins (the RawMLStub can be
            // preceded by native stub code.)
            UINT16   m_offsetOfRawMLStub;

            // See MLStubCompilationMode enumeration.
            UINT16   m_compilationMode;
        };


        Stub *FinishLinking(StubLinker *psl,
                            const BYTE *pRawMLStub,
                            UINT32     *poffset);



        static BOOL DeleteLoopFunc(BYTE *pEntry, LPVOID);
        static BOOL ForceDeleteLoopFunc(BYTE *pEntry, LPVOID);


        // *** OVERRIDES FOR CClosedHashBase ***/

        //*****************************************************************************
        // Hash is called with a pointer to an element in the table.  You must override
        // this method and provide a hash algorithm for your element type.
        //*****************************************************************************
            virtual unsigned long Hash(             // The key value.
                void const  *pData);              // Raw data to hash.
        
        //*****************************************************************************
        // Compare is used in the typical memcmp way, 0 is eqaulity, -1/1 indicate
        // direction of miscompare.  In this system everything is always equal or not.
        //*****************************************************************************
            virtual unsigned long Compare(          // 0, -1, or 1.
                void const  *pData,                 // Raw key data on lookup.
                BYTE        *pElement);           // The element to compare data against.
        
        //*****************************************************************************
        // Return true if the element is free to be used.
        //*****************************************************************************
            virtual ELEMENTSTATUS Status(           // The status of the entry.
                BYTE        *pElement);           // The element to check.
        
        //*****************************************************************************
        // Sets the status of the given element.
        //*****************************************************************************
            virtual void SetStatus(
                BYTE        *pElement,              // The element to set status for.
                ELEMENTSTATUS eStatus);           // New status.
        
        //*****************************************************************************
        // Returns the internal key value for an element.
        //*****************************************************************************
            virtual void *GetKey(                   // The data to hash on.
                BYTE        *pElement);           // The element to return data ptr for.




    private:
        Crst        m_crst;
		LoaderHeap	*m_heap;


};


#endif // __mlcache_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ml.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ML.CPP -
//
// Marshaling engine.

#include "common.h"

#include "vars.hpp"
#include "ml.h"
#include "excep.h"
#include "frames.h"
#include "interoputil.h"
#include "ComString.h"
#include "COMStringBuffer.h"
#include "COMVariant.h"

#include "COMClass.h"
#include "COMMember.h"
#include "COMDelegate.h"
#include "COMVarArgs.h"
#include "OleVariant.h"
#include "InvokeUtil.h"
#include "nstruct.h"
#include "COMNDirect.h"
#include "COMVariant.h"

#include "marshaler.h"
#include "PerfCounters.h"




//----------------------------------------------------------------------
// An image of the record placed on LOCAL array by the ML_OBJECT_C2N
// instruction.
//----------------------------------------------------------------------
struct ML_OBJECT_C2N_SR
{
    public:
        LPVOID DoConversion(OBJECTREF       *ppProtectedObjectRef,  
                            BYTE             inout,
                            BYTE             fIsAnsi,
                            BYTE             fBestFitMapping,
                            BYTE             fThrowOnUnmappableChar,
                            CleanupWorkList *pCleanup         
                           );


        VOID BackPropagate(BOOL *pfDeferredException);

    private:
        enum BackPropType {
            BP_NONE,
            BP_UNMARSHAL,
        };


        // DoConversion() delegates to some other conversion code
        // depending on the runtime type of the parameter.
        // Then it saves it away here so that BackPropagate can delegate
        // to the appropriate propagater code without redoing the type
        // analysis.
        UINT8      m_backproptype;
        BYTE       m_inout;
        BYTE       m_fIsAnsi;

        union {
            BYTE                      m_marshaler;
            BYTE                      m_cstrmarshaler[sizeof(CSTRMarshaler)];
            BYTE                      m_wstrmarshaler[sizeof(WSTRMarshaler)];
            BYTE                      m_cstrbuffermarshaler[sizeof(CSTRBufferMarshaler)];
            BYTE                      m_wstrbuffermarshaler[sizeof(WSTRBufferMarshaler)];
            BYTE                      m_nativearraymarshaler[sizeof(NativeArrayMarshaler)];
            BYTE                      m_layoutclassptrmarshaler[sizeof(LayoutClassPtrMarshaler)];

        };
};



UINT SizeOfML_OBJECT_C2N_SR()
{
    return sizeof(ML_OBJECT_C2N_SR);
}




//----------------------------------------------------------------------
// Generate a database of MLCode information.
//----------------------------------------------------------------------
const MLInfo gMLInfo[] = {

#undef DEFINE_ML
#ifdef _DEBUG
#define DEFINE_ML(name,operandbytes,frequiredCleanup,cblocals, hndl) {operandbytes,frequiredCleanup, ((cblocals)+3) & ~3, hndl, #name},
#else
#define DEFINE_ML(name,operandbytes,frequiredCleanup,cblocals, hndl) {operandbytes,frequiredCleanup, ((cblocals)+3) & ~3, hndl},
#endif

#include "mlopdef.h"

};



//----------------------------------------------------------------------
// struct to compute the summary of a series of ML codes
//----------------------------------------------------------------------

VOID MLSummary::ComputeMLSummary(const MLCode *pMLCode)
{
    const MLCode *pml = pMLCode;
    MLCode code;
    while (ML_END != (code = *(pml++))) 
    {
        m_fRequiresCleanup = m_fRequiresCleanup || gMLInfo[code].m_frequiresCleanup; 
        m_cbTotalHandles += (gMLInfo[code].m_frequiresHandle ? 1 : 0);
        pml += gMLInfo[code].m_numOperandBytes; 
        m_cbTotalLocals+= gMLInfo[code].m_cbLocal;
    }
    m_cbMLSize = (unsigned)(pml - pMLCode);
}


//----------------------------------------------------------------------
// Computes the length of an MLCode stream in bytes, including
// the terminating ML_END opcode.
//----------------------------------------------------------------------
UINT MLStreamLength(const MLCode * const pMLCode)
{
    MLSummary summary;
    summary.ComputeMLSummary(pMLCode);
    return summary.m_cbMLSize;
}


//----------------------------------------------------------------------
// checks if MLCode stream requires cleanup
//----------------------------------------------------------------------

BOOL MLStreamRequiresCleanup(const MLCode  *pMLCode)
{
    MLSummary summary;
    summary.ComputeMLSummary(pMLCode);
    return summary.m_fRequiresCleanup;
}


//----------------------------------------------------------------------
// Executes MLCode up to the next ML_END or ML_INTERRUPT opcode.
//
// Inputs:
//    psrc             - sets initial value of SRC register
//    pdst             - sets initial value of DST register
//    plocals          - pointer to ML local var array
//    dstinc           - -1 or +1 depending on direction of DST movement.
//                       (the SRC always moves in the +1 direction)
//    pCleanupWorkList - (optional) pointer to initialized
//                       CleanupWorkList. this pointer may be NULL if none
//                       of the opcodes in the MLCode stream uses it.
//----------------------------------------------------------------------
const MLCode *
RunML(const MLCode    *       pMLCode,
      const VOID      *       psrc,
            VOID      *       pdst,
            UINT8     * const plocals,
      CleanupWorkList * const pCleanupWorkList)
{
    THROWSCOMPLUSEXCEPTION();

// Perf Counter "%Time in marshalling" support
// Implementation note: Pentium counter implementation 
// is too expensive for marshalling. So, we implement
// it as a counter.
    COUNTER_ONLY(GetPrivatePerfCounters().m_Interop.cMarshalling++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Interop.cMarshalling++);


    UINT8 *plocalwalk = plocals;
    BOOL   fDeferredException = FALSE;
    HRESULT deferredExceptionHR = E_OUTOFMEMORY;
    UINT   specialErrorCode = 0;
    enum {
        kSpecialError_InvalidRedim = 1,
    };

    RetValBuffer *ptempRetValBuffer;
    HRESULT   tempHR;
    STRINGREF  tempStr;
    LPVOID pv;
    BYTE        inout;
    UINT16      elemsize;
    INT64       tempFPBuffer;
    UINT32      tempU32;
    Marshaler   *pMarshaler = NULL;
    MethodTable *pMT;
    OBJECTREF   tempOR;
    bool        bVariant = false;
    // We handle a Variant Marshaler differently:  We do not want to have a copy of the VariantData
    // included in the marshaling code.  Instead we put a referrence to the VariantData there.
    // If we meet a Variant Marshaler, we set resetbVariant to 2. The next ML code will use this Variant
    // marshaler.  After it is used (at which time resetbVariant becomes 0), we reset bVariant to false.
    UINT8       resetbVariant = 0;
    MethodDesc* tempMD;
    BYTE        BestFitMapping;
    BYTE        ThrowOnUnmappableChar;


#define PTRSRC(type)    ((type)psrc)
#define LDSRC(type)     (INCSRC(type), *( (type*) (((BYTE*)(psrc))-StackElemSize(sizeof(type))) ))

#define INCSRC(type)     ((BYTE*&)psrc)+=StackElemSize(sizeof(type))

#define INCLOCAL(size)   plocalwalk += ((size)+3) & ~3; 

#define STLOCAL(type, val)    *((type*&)plocalwalk) = (val)
#define LDLOCAL(type)    *((type*&)plocalwalk)
#define PTRLOCAL(type)   (type)plocalwalk

#ifdef _ALPHA_
    DECLARE_ML_PARM_INFO(64,TRUE);
    _ASSERTE(!"@TODO Alpha - MlCode (ml.cpp) fix stack size/srcdst");
#endif // _ALPHA_

    for(;;) {
#ifdef _DEBUG
        const MLCode *pMLCodeSave = pMLCode;
        UINT8 *poldlocalwalk = plocalwalk;
#endif

        switch (*(pMLCode++))
        {
            case ML_COPYI1: // sign extend one byte 
                STDST( SignedI1TargetType, (INT8)LDSRC(SignedParmSourceType) );
                break;
            
            case ML_COPYU1: // zero extend one byte 
                STDST( UnsignedI1TargetType, (UINT8)LDSRC(UnsignedParmSourceType));
                break;
            
            case ML_COPYI2: // sign extend two byte val 
                STDST( SignedI2TargetType, (INT16)LDSRC(SignedParmSourceType) );
                break;

            case ML_COPYU2: // zero extend 2 bytes 
                STDST( UnsignedI2TargetType, (UINT16)LDSRC(UnsignedParmSourceType) );
                break;

            case ML_COPYI4: // sign extend 4 byte val
                STDST( SignedI4TargetType, (INT32)LDSRC(SignedParmSourceType) );
                break;

            case ML_COPYU4: // zero extend 4 byte val
                STDST( UnsignedI4TargetType, (UINT32)LDSRC(UnsignedParmSourceType) );
                break;

            case ML_COPY4:
                STDST( UnsignedI4TargetType, LDSRC(UINT32) );
                break;
    
            case ML_COPY8:
                STDST(UNALIGNED UINT64, LDSRC(UNALIGNED UINT64) );
                break;

            case ML_COPYR4: // copy 4 byte float val
                LDSTR4();
                break;
    
            case ML_COPYR8: // copy 8 byte float val
                LDSTR8();
                break;
    
            case ML_END:  // intentional fallthru
            case ML_INTERRUPT:
                if (fDeferredException) {
					switch (specialErrorCode)
					{
					    case kSpecialError_InvalidRedim:
							COMPlusThrow(kInvalidOperationException, IDS_INVALID_REDIM);

					    default:
							// An ML opcode encountered an error but chose to defer
							// the exception. Normally, this occurs during the backpropagation
							// phase.
							//
							// While it'd be preferable to throw the original exception
							// rather than an uninformative OutOfMemory exception,
							// it would require more overhead than I like to propagate
							// the exception backward in a GC-safe manner.
							COMPlusThrowHR(deferredExceptionHR);
					}
                }
                return pMLCode;

    

            //-------------------------------------------------------------------------
                

            case ML_BOOL_N2C:
                STDST(SignedI4TargetType, LDSRC(BOOL) ? 1 : 0);
                break;



            // Note: For big-endian architectures, you will have to
            // push a pointer to the middle of the RetValBuffer.
            // That's why we have separate ML opcodes for each
            // possible buffer size. 
            case ML_PUSHRETVALBUFFER1: //fallthru
            case ML_PUSHRETVALBUFFER2: //fallthru
            case ML_PUSHRETVALBUFFER4:
                ptempRetValBuffer = PTRLOCAL(RetValBuffer*);
                ptempRetValBuffer->m_i32 = 0;
                STPTRDST( RetValBuffer*, ptempRetValBuffer);
                INCLOCAL(sizeof(RetValBuffer));
                break;

            // Note: For big-endian architectures, you will have to
            // push a pointer to the middle of the RetValBuffer.
            case ML_PUSHRETVALBUFFER8:
                ptempRetValBuffer = PTRLOCAL(RetValBuffer*);
                ptempRetValBuffer->m_i64 = 0;
                STPTRDST( RetValBuffer*, ptempRetValBuffer);
                INCLOCAL(sizeof(RetValBuffer));
                break;

            case ML_SETSRCTOLOCAL:
                psrc = (const VOID *)(plocals + *( ((UINT16*&)pMLCode)++ ));
                break;

            case ML_THROWIFHRFAILED:
                tempHR = LDSRC(HRESULT);
                if (FAILED(tempHR)) 
                    COMPlusThrowHR(tempHR);                    
                break;

            case ML_OBJECT_C2N:
                inout = *((BYTE*&)pMLCode)++;
                BestFitMapping = *((BYTE*&)pMLCode)++;
                ThrowOnUnmappableChar = *((BYTE*&)pMLCode)++;                
                STPTRDST( LPVOID,
                       ((ML_OBJECT_C2N_SR*)plocalwalk)->DoConversion((OBJECTREF*)psrc, inout, (StringType)*(pMLCode++), BestFitMapping, ThrowOnUnmappableChar, pCleanupWorkList) );
                INCSRC(OBJECTREF* &);
                INCLOCAL(sizeof(ML_OBJECT_C2N_SR));
                break;

            case ML_OBJECT_C2N_POST:
                ((ML_OBJECT_C2N_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate(&fDeferredException);
                break;

            case ML_LATEBOUNDMARKER:
                _ASSERTE(!"This ML stub should never be interpreted! This method should always be called using the ComPlusToComLateBoundWorker!");
                break;

            case ML_COMEVENTCALLMARKER:
                _ASSERTE(!"This ML stub should never be interpreted! This method should always be called using the ComEventCallWorker!");
                break;

            case ML_BUMPSRC:
                ((BYTE*&)psrc) += *( ((INT16*&)pMLCode)++ );
                break;

            case ML_BUMPDST:
                ((BYTE*&)pdst) += *( ((INT16*&)pMLCode)++ );
                break;



            case ML_R4_FROM_TOS:
                // BUGBUG: Big endian machines won't work:
                getFPReturnSmall((INT32 *) &tempFPBuffer);
                STDST(INT32, (INT32) tempFPBuffer);
                break;
        
            case ML_R8_FROM_TOS:
                getFPReturn(8, tempFPBuffer);
                STDST(INT64, tempFPBuffer);
                break;



            case ML_ARRAYWITHOFFSET_C2N:
                STPTRDST( LPVOID,
                          ((ML_ARRAYWITHOFFSET_C2N_SR*)plocalwalk)->DoConversion(
                                    &( ((ArrayWithOffsetData*)psrc)->m_Array ),
                                    ((ArrayWithOffsetData*)psrc)->m_cbOffset,
                                    ((ArrayWithOffsetData*)psrc)->m_cbCount,
                                    pCleanupWorkList)
                        );
                INCSRC(ArrayWithOffsetData);
                INCLOCAL(sizeof(ML_ARRAYWITHOFFSET_C2N_SR));
                break;

            case ML_ARRAYWITHOFFSET_C2N_POST:
                ((ML_ARRAYWITHOFFSET_C2N_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate();
                break;


            // 
            // Marshaler opcodes
            //
            // @nice: there is some overlap between the marshaler opcodes &
            // normal ml opcodes.  Need to resolve.
            //
            // @perf: Should find best tradeoff between inlining code and
            // sharing it here. 
            //

            case ML_CREATE_MARSHALER_GENERIC_1:
                pMarshaler = new (plocalwalk) CopyMarshaler1(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(CopyMarshaler1);
                break;

            case ML_CREATE_MARSHALER_GENERIC_U1:
                pMarshaler = new (plocalwalk) CopyMarshalerU1(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(CopyMarshalerU1);
                break;

            case ML_CREATE_MARSHALER_GENERIC_2:
                pMarshaler = new (plocalwalk) CopyMarshaler2(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(CopyMarshaler2);
                break;

            case ML_CREATE_MARSHALER_GENERIC_U2:
                pMarshaler = new (plocalwalk) CopyMarshalerU2(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(CopyMarshalerU2);
                break;

            case ML_CREATE_MARSHALER_GENERIC_4:
                pMarshaler = new (plocalwalk) CopyMarshaler4(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(CopyMarshaler4);
                break;

            case ML_CREATE_MARSHALER_GENERIC_8:
                pMarshaler = new (plocalwalk) CopyMarshaler8(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(CopyMarshaler8);
                break;

            case ML_CREATE_MARSHALER_WINBOOL:
                pMarshaler = new (plocalwalk) WinBoolMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(WinBoolMarshaler);
                break;

            case ML_CREATE_MARSHALER_VTBOOL:
                pMarshaler = new (plocalwalk) VtBoolMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(VtBoolMarshaler);
                break;

            case ML_CREATE_MARSHALER_ANSICHAR:
                pMarshaler = new (plocalwalk) AnsiCharMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((AnsiCharMarshaler*)pMarshaler)->SetBestFitMap(*((UINT8*&)pMLCode)++);
                ((AnsiCharMarshaler*)pMarshaler)->SetThrowOnUnmappableChar(*((UINT8*&)pMLCode)++);
                plocalwalk += sizeof(AnsiCharMarshaler);
                break;

            case ML_CREATE_MARSHALER_FLOAT:
                pMarshaler = new (plocalwalk) FloatMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(FloatMarshaler);
                break;

            case ML_CREATE_MARSHALER_DOUBLE:
                pMarshaler = new (plocalwalk) DoubleMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(DoubleMarshaler);
                break;

            case ML_CREATE_MARSHALER_CURRENCY:
                pMarshaler = new (plocalwalk) CurrencyMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(CurrencyMarshaler);
                break;

            case ML_CREATE_MARSHALER_OLECOLOR:
                pMarshaler = new (plocalwalk) OleColorMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(OleColorMarshaler);
                break;

            case ML_CREATE_MARSHALER_DECIMAL:
                pMarshaler = new (plocalwalk) DecimalMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(DecimalMarshaler);
                break;

            case ML_CREATE_MARSHALER_DECIMAL_PTR:
                pMarshaler = new (plocalwalk) DecimalPtrMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(DecimalPtrMarshaler);
                break;

            case ML_CREATE_MARSHALER_GUID:
                pMarshaler = new (plocalwalk) GuidMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(GuidMarshaler);
                break;

            case ML_CREATE_MARSHALER_GUID_PTR:
                pMarshaler = new (plocalwalk) GuidPtrMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(GuidPtrMarshaler);
                break;

            case ML_CREATE_MARSHALER_DATE:
                pMarshaler = new (plocalwalk) DateMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(DateMarshaler);
                break;

            case ML_CREATE_MARSHALER_VARIANT:
                pMarshaler = new (plocalwalk) VariantMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(VariantMarshaler);
                bVariant = true;
                resetbVariant = 2;
                break;

            case ML_CREATE_MARSHALER_BSTR:
                pMarshaler = new (plocalwalk) BSTRMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(BSTRMarshaler);
                break;

            case ML_CREATE_MARSHALER_WSTR:
                pMarshaler = new (plocalwalk) WSTRMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(WSTRMarshaler);
                break;

            case ML_CREATE_MARSHALER_CSTR:
                pMarshaler = new (plocalwalk) CSTRMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((CSTRMarshaler*)pMarshaler)->SetBestFitMap(*((UINT8*&)pMLCode)++);
                ((CSTRMarshaler*)pMarshaler)->SetThrowOnUnmappableChar(*((UINT8*&)pMLCode)++);
                plocalwalk += sizeof(CSTRMarshaler);
                break;

            case ML_CREATE_MARSHALER_ANSIBSTR:
                pMarshaler = new (plocalwalk) AnsiBSTRMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((AnsiBSTRMarshaler*)pMarshaler)->SetBestFitMap(*((UINT8*&)pMLCode)++);
                ((AnsiBSTRMarshaler*)pMarshaler)->SetThrowOnUnmappableChar(*((UINT8*&)pMLCode)++);
                plocalwalk += sizeof(AnsiBSTRMarshaler);
                break;

            case ML_CREATE_MARSHALER_BSTR_BUFFER:
                pMarshaler = new (plocalwalk) BSTRBufferMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(BSTRBufferMarshaler);
                break;

            case ML_CREATE_MARSHALER_WSTR_BUFFER:
                pMarshaler = new (plocalwalk) WSTRBufferMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(WSTRBufferMarshaler);
                break;

            case ML_CREATE_MARSHALER_CSTR_BUFFER:
                pMarshaler = new (plocalwalk) CSTRBufferMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((CSTRBufferMarshaler*)pMarshaler)->SetBestFitMap(*((UINT8*&)pMLCode)++);
                ((CSTRBufferMarshaler*)pMarshaler)->SetThrowOnUnmappableChar(*((UINT8*&)pMLCode)++);
                plocalwalk += sizeof(CSTRBufferMarshaler);
                break;

            case ML_CREATE_MARSHALER_BSTR_X:
                pMarshaler = new (plocalwalk) BSTRMarshalerEx(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((BSTRMarshalerEx*)pMarshaler)->SetMethodTable(*((MethodTable **&)pMLCode)++);
                plocalwalk += sizeof(BSTRMarshalerEx);
                break;

            case ML_CREATE_MARSHALER_WSTR_X:
                pMarshaler = new (plocalwalk) WSTRMarshalerEx(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((WSTRMarshalerEx*)pMarshaler)->SetMethodTable(*((MethodTable **&)pMLCode)++);
                plocalwalk += sizeof(WSTRMarshalerEx);
                break;

            case ML_CREATE_MARSHALER_CSTR_X:
                pMarshaler = new (plocalwalk) CSTRMarshalerEx(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((CSTRMarshalerEx*)pMarshaler)->SetMethodTable(*((MethodTable **&)pMLCode)++);
                ((CSTRMarshalerEx*)pMarshaler)->SetBestFitMap(*((UINT8*&)pMLCode)++);
                ((CSTRMarshalerEx*)pMarshaler)->SetThrowOnUnmappableChar(*((UINT8*&)pMLCode)++);
                plocalwalk += sizeof(CSTRMarshalerEx);
                break;

            case ML_CREATE_MARSHALER_BSTR_BUFFER_X:
                pMarshaler = new (plocalwalk) BSTRBufferMarshalerEx(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((BSTRBufferMarshalerEx*)pMarshaler)->SetMethodTable(*((MethodTable **&)pMLCode)++);
                plocalwalk += sizeof(BSTRBufferMarshalerEx);
                break;

            case ML_CREATE_MARSHALER_WSTR_BUFFER_X:
                pMarshaler = new (plocalwalk) WSTRBufferMarshalerEx(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((WSTRBufferMarshalerEx*)pMarshaler)->SetMethodTable(*((MethodTable **&)pMLCode)++);
                plocalwalk += sizeof(WSTRBufferMarshalerEx);
                break;

            case ML_CREATE_MARSHALER_CSTR_BUFFER_X:
                pMarshaler = new (plocalwalk) CSTRBufferMarshalerEx(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((CSTRBufferMarshalerEx*)pMarshaler)->SetMethodTable(*((MethodTable **&)pMLCode)++);
                ((CSTRBufferMarshalerEx*)pMarshaler)->SetBestFitMap(*((UINT8*&)pMLCode)++);
                ((CSTRBufferMarshalerEx*)pMarshaler)->SetThrowOnUnmappableChar(*((UINT8*&)pMLCode)++);
                plocalwalk += sizeof(CSTRBufferMarshalerEx);
                break;

            case ML_CREATE_MARSHALER_INTERFACE:
                pMarshaler = new (plocalwalk) InterfaceMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((InterfaceMarshaler*)pMarshaler)->SetClassMT(*((MethodTable **&)pMLCode)++);
                ((InterfaceMarshaler*)pMarshaler)->SetItfMT(*((MethodTable **&)pMLCode)++);
                ((InterfaceMarshaler*)pMarshaler)->SetIsDispatch(*((UINT8 *&)pMLCode)++);
                ((InterfaceMarshaler*)pMarshaler)->SetClassIsHint(*((UINT8 *&)pMLCode)++);
                plocalwalk += sizeof(InterfaceMarshaler);
                break;

            case ML_CREATE_MARSHALER_SAFEARRAY:
                pMarshaler = new (plocalwalk) SafeArrayMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                ((SafeArrayMarshaler*)pMarshaler)->SetElementMethodTable(*((MethodTable **&)pMLCode)++);
                ((SafeArrayMarshaler*)pMarshaler)->SetElementType(*((UINT8 *&)pMLCode)++);
                ((SafeArrayMarshaler*)pMarshaler)->SetRank(*((INT32 *&)pMLCode)++);
                ((SafeArrayMarshaler*)pMarshaler)->SetNoLowerBounds(*((UINT8 *&)pMLCode)++);
                plocalwalk += sizeof(SafeArrayMarshaler);
                break;

            case ML_CREATE_MARSHALER_CARRAY:
                {
                    ML_CREATE_MARSHALER_CARRAY_OPERANDS mops = *((ML_CREATE_MARSHALER_CARRAY_OPERANDS*&)pMLCode)++;
                    pMarshaler = new (plocalwalk) NativeArrayMarshaler(pCleanupWorkList);
                    _ASSERTE(pMarshaler != NULL);
                    ((NativeArrayMarshaler*)pMarshaler)->SetElementMethodTable(mops.methodTable);
                    ((NativeArrayMarshaler*)pMarshaler)->SetElementType(mops.elementType);
                    ((NativeArrayMarshaler*)pMarshaler)->SetBestFitMap(mops.bestfitmapping);
                    ((NativeArrayMarshaler*)pMarshaler)->SetThrowOnUnmappableChar(mops.throwonunmappablechar);

                    DWORD numelems = mops.additive;
                    if (mops.multiplier != 0 && mops.countSize != 0) // don't dereference ofsbump+psrc if countsize is zero!!!  
                    {
                        const BYTE *pCount = mops.offsetbump + (const BYTE *)psrc;
                        switch (mops.countSize)
                        {
                            case 1: numelems += mops.multiplier * (DWORD)*((UINT8*)pCount); break;
                            case 2: numelems += mops.multiplier * (DWORD)*((UINT16*)pCount); break;
                            case 4: numelems += mops.multiplier * (DWORD)*((UINT32*)pCount); break;
                            case 8: numelems += mops.multiplier * (DWORD)*((UINT64*)pCount); break;
                            default:
                                _ASSERTE(0); 
                        }
                    }
                    
                    ((NativeArrayMarshaler*)pMarshaler)->SetElementCount(numelems);
                    plocalwalk += sizeof(NativeArrayMarshaler);
                }
                break;


            case ML_CREATE_MARSHALER_DELEGATE:
                pMarshaler = new (plocalwalk) DelegateMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(DelegateMarshaler);
                break;


            case ML_CREATE_MARSHALER_BLITTABLEPTR:
                pMarshaler = new (plocalwalk) BlittablePtrMarshaler(pCleanupWorkList, *((MethodTable**&)pMLCode)++);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(BlittablePtrMarshaler);
                break;

            case ML_CREATE_MARSHALER_VBBYVALSTR:
                _ASSERTE(!"The ML_CREATE_MARSHALER_VBBYVALSTR marshaler should never be created!");
                break;

            case ML_CREATE_MARSHALER_VBBYVALSTRW:
                _ASSERTE(!"The ML_CREATE_MARSHALER_VBBYVALSTRW marshaler should never be created!");
                break;

            case ML_CREATE_MARSHALER_LAYOUTCLASSPTR:
                pMarshaler = new (plocalwalk) LayoutClassPtrMarshaler(pCleanupWorkList, *((MethodTable**&)pMLCode)++);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(LayoutClassPtrMarshaler);
                break;

            case ML_CREATE_MARSHALER_ARRAYWITHOFFSET:
                _ASSERTE(!"The ML_CREATE_MARSHALER_ARRAYWITHOFFSET marshaler should never be created!");
                break;

            case ML_CREATE_MARSHALER_BLITTABLEVALUECLASS:
                _ASSERTE(!"The ML_CREATE_MARSHALER_BLITTABLEVALUECLASS marshaler should never be created!");
                break;

            case ML_CREATE_MARSHALER_VALUECLASS:
                _ASSERTE(!"The ML_CREATE_MARSHALER_VALUECLASS marshaler should never be created!");
                break;

            case ML_CREATE_MARSHALER_REFERENCECUSTOMMARSHALER:
                pMarshaler = new (plocalwalk) ReferenceCustomMarshaler(pCleanupWorkList, *((CustomMarshalerHelper**&)pMLCode)++);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(ReferenceCustomMarshaler);
                break;

            case ML_CREATE_MARSHALER_VALUECLASSCUSTOMMARSHALER:
                pMarshaler = new (plocalwalk) ValueClassCustomMarshaler(pCleanupWorkList, *((CustomMarshalerHelper**&)pMLCode)++);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(ValueClassCustomMarshaler);
                break;

            case ML_CREATE_MARSHALER_ARGITERATOR:
                _ASSERTE(!"The ML_CREATE_MARSHALER_ARGITERATOR marshaler should never be created!");
                break;

            case ML_CREATE_MARSHALER_BLITTABLEVALUECLASSWITHCOPYCTOR:
                _ASSERTE(!"The ML_CREATE_MARSHALER_BLITTABLEVALUECLASSWITHCOPYCTOR marshaler should never be created!");
                break;

            case ML_CREATE_MARSHALER_OBJECT:
                pMarshaler = new (plocalwalk) ObjectMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);

#if defined(CHECK_FOR_VALID_VARIANTS)
                ((ObjectMarshaler*)pMarshaler)->m_strTypeName = *((LPUTF8*&)pMLCode)++;
                ((ObjectMarshaler*)pMarshaler)->m_strMethodName = *((LPUTF8*&)pMLCode)++;
                ((ObjectMarshaler*)pMarshaler)->m_iArg = *((INT32 *&)pMLCode)++;
#endif

                plocalwalk += sizeof(ObjectMarshaler);
                break;

            case ML_CREATE_MARSHALER_CBOOL:
                pMarshaler = new (plocalwalk) CBoolMarshaler(pCleanupWorkList);
                _ASSERTE(pMarshaler != NULL);
                plocalwalk += sizeof(CBoolMarshaler);
                break;

            case ML_MARSHAL_N2C:
                (BYTE*&)pdst -= pMarshaler->m_cbCom;
                pMarshaler->MarshalNativeToCom((void *)psrc, pdst);
                (BYTE*&)psrc += pMarshaler->m_cbNative;
                break;

            case ML_MARSHAL_N2C_OUT:
                (BYTE*&)pdst -= pMarshaler->m_cbCom;
                pMarshaler->MarshalNativeToComOut((void *)psrc, pdst);
                (BYTE*&)psrc += pMarshaler->m_cbNative;
                break;

            case ML_MARSHAL_N2C_BYREF:
                (BYTE*&)pdst -= sizeof(void*);
                pMarshaler->MarshalNativeToComByref((void *)psrc, pdst);
                (BYTE*&)psrc += sizeof(void*);
                break;

            case ML_MARSHAL_N2C_BYREF_OUT:
                (BYTE*&)pdst -= sizeof(void*);
                pMarshaler->MarshalNativeToComByrefOut((void *)psrc, pdst);
                (BYTE*&)psrc += sizeof(void*);
                break;

            case ML_UNMARSHAL_N2C_IN:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalNativeToComIn();
                break;

            case ML_UNMARSHAL_N2C_OUT:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalNativeToComOut();
                break;

            case ML_UNMARSHAL_N2C_IN_OUT:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalNativeToComInOut();
                break;

            case ML_UNMARSHAL_N2C_BYREF_IN:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalNativeToComByrefIn();
                break;

            case ML_UNMARSHAL_N2C_BYREF_OUT:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalNativeToComByrefOut();
                break;

            case ML_UNMARSHAL_N2C_BYREF_IN_OUT:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalNativeToComByrefInOut();
                break;

            case ML_MARSHAL_C2N:
                (BYTE*&)pdst -= pMarshaler->m_cbNative;
                pMarshaler->MarshalComToNative(bVariant?(void*)(&psrc):(void *)psrc, pdst);
                (BYTE*&)psrc += pMarshaler->m_cbCom;
                break;

            case ML_MARSHAL_C2N_OUT:
                (BYTE*&)pdst -= pMarshaler->m_cbNative;
                pMarshaler->MarshalComToNativeOut(bVariant?(void*)(&psrc):(void *)psrc, pdst);
                (BYTE*&)psrc += pMarshaler->m_cbCom;
                break;

            case ML_MARSHAL_C2N_BYREF:
                (BYTE*&)pdst -= sizeof(void*);
                pMarshaler->MarshalComToNativeByref((void *)psrc, pdst);
                (BYTE*&)psrc += sizeof(void*);
                break;

            case ML_MARSHAL_C2N_BYREF_OUT:
                (BYTE*&)pdst -= sizeof(void*);
                pMarshaler->MarshalComToNativeByrefOut((void *)psrc, pdst);
                (BYTE*&)psrc += sizeof(void*);
                break;

            case ML_UNMARSHAL_C2N_IN:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalComToNativeIn();
                break;

            case ML_UNMARSHAL_C2N_OUT:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalComToNativeOut();
                break;

            case ML_UNMARSHAL_C2N_IN_OUT:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalComToNativeInOut();
                break;

            case ML_UNMARSHAL_C2N_BYREF_IN:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalComToNativeByrefIn();
                break;

            case ML_UNMARSHAL_C2N_BYREF_OUT:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalComToNativeByrefOut();
                break;

            case ML_UNMARSHAL_C2N_BYREF_IN_OUT:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);
                pMarshaler->UnmarshalComToNativeByrefInOut();
                break;

            case ML_PRERETURN_N2C:
                if (pMarshaler->m_fReturnsComByref)
                    (BYTE*&)pdst -= sizeof(void*);

                pMarshaler->PrereturnNativeFromCom((void *)psrc, pdst);
                break;

            case ML_RETURN_N2C:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);

                if (pMarshaler->m_fReturnsNativeByref)
                    (BYTE*&)pdst -= sizeof(void*);
                else
                    (BYTE*&)pdst -= pMarshaler->m_cbNative;

                pMarshaler->ReturnNativeFromCom(pdst, (void *) psrc);

                if (!pMarshaler->m_fReturnsComByref)
                    (BYTE*&)psrc += pMarshaler->m_cbCom;
                break;

            case ML_PRERETURN_N2C_RETVAL:
                if (pMarshaler->m_fReturnsComByref)
                    (BYTE*&)pdst -= sizeof(void*);

                pMarshaler->PrereturnNativeFromComRetval((void *)psrc, pdst);

                (BYTE*&)psrc += sizeof(void*);
                break;

            case ML_RETURN_N2C_RETVAL:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);

                pMarshaler->ReturnNativeFromComRetval(pdst, (void *) psrc);

                if (!pMarshaler->m_fReturnsComByref)
                    (BYTE*&)psrc += pMarshaler->m_cbCom;
                break;

            case ML_PRERETURN_C2N:
                pMarshaler->PrereturnComFromNative((void *)psrc, pdst);
                if (pMarshaler->m_fReturnsComByref)
                    (BYTE*&)psrc += sizeof(void*);
                break;

            case ML_RETURN_C2N:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);

                if (!pMarshaler->m_fReturnsComByref)
                    (BYTE*&)pdst -= pMarshaler->m_cbCom;

                pMarshaler->ReturnComFromNative(pdst, (void *) psrc);

                if (pMarshaler->m_fReturnsNativeByref)
                    (BYTE*&)psrc += sizeof(void*);
                else
                    (BYTE*&)psrc += pMarshaler->m_cbNative;

                break;

            case ML_PRERETURN_C2N_RETVAL:
                (BYTE*&)pdst -= sizeof(void*);
                pMarshaler->PrereturnComFromNativeRetval((void *)psrc, pdst);
                if (pMarshaler->m_fReturnsComByref)
                    (BYTE*&)psrc += sizeof(void*);
                break;

            case ML_RETURN_C2N_RETVAL:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);

                if (!pMarshaler->m_fReturnsComByref)
                    (BYTE*&)pdst -= pMarshaler->m_cbCom;

                pMarshaler->ReturnComFromNativeRetval(pdst, (void *) psrc);

                break;
    
            case ML_SET_COM:
                pMarshaler->SetCom((void *) psrc, pdst);
                break;
    
            case ML_GET_COM:
                pMarshaler->GetCom(pdst, (void *) psrc);
                break;
    
            case ML_PREGET_COM_RETVAL:
                pMarshaler->PregetComRetval((void *) psrc, pdst);
                break;
    


            case ML_PINNEDUNISTR_C2N:
                tempStr = LDSRC(STRINGREF);
                STPTRDST( const WCHAR *, (tempStr == NULL ? NULL : tempStr->GetBuffer()) );
#ifdef TOUCH_ALL_PINNED_OBJECTS
                if (tempStr != NULL) {
                    TouchPages(tempStr->GetBuffer(), sizeof(WCHAR)*(1 + tempStr->GetStringLength()));
                }
#endif
                break;


            case ML_VBBYVALSTR:
                BestFitMapping = *((BYTE*&)pMLCode)++;
                ThrowOnUnmappableChar = *((BYTE*&)pMLCode)++;                
                STPTRDST( LPSTR, ((ML_VBBYVALSTR_SR*)plocalwalk)->DoConversion(LDSRC(STRINGREF*), BestFitMapping, ThrowOnUnmappableChar, pCleanupWorkList) );
                INCLOCAL(sizeof(ML_VBBYVALSTR_SR));
                break;

            case ML_VBBYVALSTR_POST:
                ((ML_VBBYVALSTR_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate(&fDeferredException);
                break;

            case ML_VBBYVALSTRW:
                STPTRDST( LPWSTR, ((ML_VBBYVALSTRW_SR*)plocalwalk)->DoConversion(LDSRC(STRINGREF*), pCleanupWorkList) );
                INCLOCAL(sizeof(ML_VBBYVALSTRW_SR));
                break;

            case ML_VBBYVALSTRW_POST:
                ((ML_VBBYVALSTRW_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate(&fDeferredException);
                break;

            case ML_BLITTABLELAYOUTCLASS_C2N:
                tempOR = LDSRC(OBJECTREF);
                _ASSERTE(tempOR == NULL ||
                         (tempOR->GetClass()->HasLayout() && tempOR->GetClass()->IsBlittable()));

#ifdef TOUCH_ALL_PINNED_OBJECTS
                if (tempOR != NULL) {
                    TouchPages(tempOR->GetData(), tempOR->GetMethodTable()->GetNativeSize());
                }
#endif
                STPTRDST( LPVOID, tempOR == NULL ? NULL : tempOR->GetData() );
                       
                break;


            case ML_BLITTABLEVALUECLASS_C2N:
                tempU32 = (*((UINT32*&)pMLCode)++);
                ((BYTE*&)pdst) -= MLParmSize(tempU32);
                memcpyNoGCRefs(pdst, psrc, tempU32);
                ((BYTE*&)psrc) += StackElemSize(tempU32);
                break;

            case ML_BLITTABLEVALUECLASS_N2C:
                tempU32 = (*((UINT32*&)pMLCode)++);
                ((BYTE*&)pdst) -= StackElemSize(tempU32);
                memcpyNoGCRefs(pdst, psrc, tempU32);
                ((BYTE*&)psrc) += MLParmSize(tempU32);
                break;

            case ML_REFBLITTABLEVALUECLASS_C2N:
                tempU32 = (*((UINT32*&)pMLCode)++);
                pv = LDSRC(LPVOID);
                ((BYTE*&)pdst) -= sizeof(LPVOID);
                *((LPVOID*)pdst) = pv;
#ifdef TOUCH_ALL_PINNED_OBJECTS
                TouchPages(pv, tempU32);
#endif
                break;


            case ML_VALUECLASS_C2N:
                pMT = *((MethodTable**&)pMLCode)++;
                
                _ASSERTE(pMT->GetClass()->IsValueClass());
                pv = pCleanupWorkList->NewScheduleLayoutDestroyNative(pMT);
                FmtValueTypeUpdateNative( (LPVOID)&psrc, pMT, (BYTE*)pv );

                ((BYTE*&)psrc) += StackElemSize(pMT->GetClass()->GetAlignedNumInstanceFieldBytes());
                ((BYTE*&)pdst) -= MLParmSize(pMT->GetNativeSize());

                memcpyNoGCRefs(pdst, pv, pMT->GetNativeSize());

                break;


            case ML_VALUECLASS_N2C:
                pMT = *((MethodTable**&)pMLCode)++;
                _ASSERTE(pMT->GetClass()->IsValueClass());
                ((BYTE*&)pdst) -= MLParmSize(pMT->GetClass()->GetAlignedNumInstanceFieldBytes());
                FmtValueTypeUpdateComPlus( &pdst, pMT, (BYTE*)psrc , FALSE);
                ((BYTE*&)psrc) += StackElemSize(pMT->GetNativeSize());
                break;



            case ML_REFVALUECLASS_C2N:
                inout = *((BYTE*&)pMLCode)++;
                pMT = *((MethodTable**&)pMLCode)++;
                STPTRDST( LPVOID, ((ML_REFVALUECLASS_C2N_SR*)plocalwalk)->DoConversion((VOID**)psrc, pMT, inout, pCleanupWorkList));
                INCLOCAL(sizeof(ML_REFVALUECLASS_C2N_SR));

                ((BYTE*&)psrc) += StackElemSize( sizeof(LPVOID) );
                break;

            case ML_REFVALUECLASS_C2N_POST:
                ((ML_REFVALUECLASS_C2N_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate(&fDeferredException);
                break;



            case ML_REFVALUECLASS_N2C:
                inout = *((BYTE*&)pMLCode)++;
                pMT = *((MethodTable**&)pMLCode)++;
                STPTRDST( LPVOID, ((ML_REFVALUECLASS_N2C_SR*)plocalwalk)->DoConversion(*(LPVOID*)psrc, inout, pMT, pCleanupWorkList));
                INCLOCAL(sizeof(ML_REFVALUECLASS_N2C_SR));

                ((BYTE*&)psrc) += StackElemSize( sizeof(LPVOID) );
                break;

            case ML_REFVALUECLASS_N2C_POST:
                ((ML_REFVALUECLASS_N2C_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate(&fDeferredException);
                break;



            case ML_PINNEDISOMORPHICARRAY_C2N:
                elemsize = *((UINT16*&)pMLCode)++;
                tempOR = LDSRC(OBJECTREF);
                STPTRDST( LPVOID, tempOR == NULL ? NULL : (*(BASEARRAYREF*)&tempOR)->GetDataPtr() );

#ifdef TOUCH_ALL_PINNED_OBJECTS
                if (tempOR != NULL) {
                    TouchPages((*(BASEARRAYREF*)&tempOR)->GetDataPtr(), elemsize * (*(BASEARRAYREF*)&tempOR)->GetNumComponents());
                }
#endif
                break;

            case ML_PINNEDISOMORPHICARRAY_C2N_EXPRESS:
                
#ifdef TOUCH_ALL_PINNED_OBJECTS
                _ASSERTE(!"Shouldn't have gotten here.");
#endif
                elemsize = *((UINT16*&)pMLCode)++;
                _ASSERTE(elemsize != 0);
                tempOR = LDSRC(OBJECTREF);
                STPTRDST( BYTE*, tempOR == NULL ? NULL : (*(BYTE**)&tempOR) + elemsize );

                break;

            case ML_REFVARIANT_N2C:
                inout = *((BYTE*&)pMLCode)++;
                STPTRDST( LPVOID, ((ML_REFVARIANT_N2C_SR*)plocalwalk)->DoConversion(*(VARIANT**)psrc, inout, pCleanupWorkList));
                INCLOCAL(sizeof(ML_REFVARIANT_N2C_SR));

                ((BYTE*&)psrc) += StackElemSize( sizeof(VARIANT*) );
                break;

            case ML_REFVARIANT_N2C_POST:
                ((ML_REFVARIANT_N2C_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate(&fDeferredException, &deferredExceptionHR);
                break;

            case ML_REFOBJECT_N2C:
                inout = *((BYTE*&)pMLCode)++;
                STPTRDST( OBJECTREF*, ((ML_REFOBJECT_N2C_SR*)plocalwalk)->DoConversion(*(VARIANT**)psrc, inout, pCleanupWorkList));
                INCLOCAL(sizeof(ML_REFOBJECT_N2C_SR));

                ((BYTE*&)psrc) += StackElemSize( sizeof(VARIANT*) );
                break;

            case ML_REFOBJECT_N2C_POST:
                ((ML_REFOBJECT_N2C_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate(&fDeferredException, &deferredExceptionHR);
                break;





            case ML_THROWINTEROPPARAM:
                tempU32 = *((UINT32*&)pMLCode)++;
                ThrowInteropParamException((UINT)tempU32, (UINT) (*((UINT32*&)pMLCode)++)); 
                break;

            case ML_ARGITERATOR_C2N:
                STDST(va_list, COMVarArgs::MarshalToUnmanagedVaList((VARARGS*)psrc));
                INCSRC(VARARGS);
                break;

            case ML_ARGITERATOR_N2C:
                ((BYTE*&)pdst) -= StackElemSize( sizeof(VARARGS) );
                COMVarArgs::MarshalToManagedVaList(LDSRC(va_list), (VARARGS*)pdst);
                break;

            case ML_COPYCTOR_C2N:
                pMT = *((MethodTable**&)pMLCode)++;
                tempMD = *((MethodDesc**&)pMLCode)++;
                tempU32 = MLParmSize(pMT->GetNativeSize());
                ((BYTE*&)pdst) -= tempU32;

                pv = *((LPVOID*)psrc);
                if (tempMD) {
                    __int64 args[2] = { (INT64)pv, (INT64)pdst };
                    tempMD->Call(args);
                } else {
					memcpyNoGCRefs(pdst, pv, tempU32);
				}

                pv = LDSRC(LPVOID); //reload again from gc-protected memory - just to be paranoid
                tempMD = *((MethodDesc**&)pMLCode)++;
                if (tempMD) {
                    __int64 arg = (INT64)pv;
                    tempMD->Call(&arg);
                }
                
                break;


            case ML_COPYCTOR_N2C:
                pMT = *((MethodTable**&)pMLCode)++;
                tempU32 = MLParmSize(pMT->GetNativeSize());
                STPTRDST(const VOID *, psrc);
                ((BYTE*&)psrc) += tempU32;
                break;

            case ML_CAPTURE_PSRC:
                tempU32 = (UINT32)(INT32)(*((INT16*&)pMLCode)++);
                *((BYTE**)plocalwalk) = ((BYTE*)psrc) + (INT32)tempU32;
                INCLOCAL(sizeof(BYTE**));
                break;

            case ML_MARSHAL_RETVAL_SMBLITTABLEVALUETYPE_C2N:
                // Note: we only handle blittables here.
                tempU32 = *((UINT32*&)pMLCode)++; // get the size
                memcpyNoGCRefs( **((BYTE***)(plocals + *( ((UINT16*&)pMLCode)++))), psrc, tempU32 );
                break;

            case ML_MARSHAL_RETVAL_SMBLITTABLEVALUETYPE_N2C:
                // Note: we only handle blittables here.
                tempU32 = *((UINT32*&)pMLCode)++; // get the size
                ((BYTE*&)pdst) -= MLParmSize(tempU32);
                memcpyNoGCRefs( pdst, plocals + *( ((UINT16*&)pMLCode)++), tempU32 );
                break;

            case ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N:
                tempU32 = *((UINT32*&)pMLCode)++; // get the size;
                STPTRDST( LPVOID, ((ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_SR*)plocalwalk)->DoConversion(psrc, tempU32));
                INCLOCAL(sizeof(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_SR));

                ((BYTE*&)psrc) += StackElemSize( sizeof(LPVOID) );
                break;

            case ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_POST:
                ((ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate(&fDeferredException);
                break;

            case ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_N2C:
                pv = LDSRC(LPVOID);
                STPTRDST(LPVOID, pv);
                *((LPVOID*)plocalwalk) = pv;
                INCLOCAL(sizeof(LPVOID));
                break;

            case ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_N2C_POST:
                pv = *((LPVOID*)(plocals + *( ((UINT16*&)pMLCode)++ )));
                STPTRDST(LPVOID, pv);
                break;

            case ML_PUSHVASIGCOOKIEEX:
#ifdef _DEBUG
                FillMemory(plocalwalk, sizeof(VASigCookieEx), 0xcc);
#endif
                ((VASigCookieEx*)plocalwalk)->sizeOfArgs = *( ((UINT16*&)pMLCode)++ );
                ((VASigCookieEx*)plocalwalk)->mdVASig = NULL;
                ((VASigCookieEx*)plocalwalk)->m_pArgs = (const BYTE *)psrc;
                STPTRDST(LPVOID, plocalwalk);
                INCLOCAL(sizeof(VASigCookieEx));
                break;

            case ML_BSTR_C2N:
                STPTRDST( LPCWSTR, ((ML_BSTR_C2N_SR*)plocalwalk)->DoConversion(LDSRC(STRINGREF), pCleanupWorkList) );
                INCLOCAL(sizeof(ML_BSTR_C2N_SR));
                break;
                
            case ML_CSTR_C2N:
                BestFitMapping = *((BYTE*&)pMLCode)++;
                ThrowOnUnmappableChar = *((BYTE*&)pMLCode)++;                
                STPTRDST( LPSTR, ((ML_CSTR_C2N_SR*)plocalwalk)->DoConversion(LDSRC(STRINGREF), (UINT32)BestFitMapping, (UINT32)ThrowOnUnmappableChar, pCleanupWorkList) );
                INCLOCAL(sizeof(ML_CSTR_C2N_SR));
                break;

            case ML_HANDLEREF_C2N:
                STPTRDST( LPVOID, LDSRC(HANDLEREF).m_handle );
                break;
            
            case ML_WSTRBUILDER_C2N:
                STPTRDST( LPWSTR, ((ML_WSTRBUILDER_C2N_SR*)plocalwalk)->DoConversion((STRINGBUFFERREF*)psrc, pCleanupWorkList) );
                LDSRC(STRINGBUFFERREF);
                INCLOCAL(sizeof(ML_WSTRBUILDER_C2N_SR));
                break;

            case ML_WSTRBUILDER_C2N_POST:
                ((ML_WSTRBUILDER_C2N_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate(&fDeferredException);
                break;

            case ML_CSTRBUILDER_C2N:
                BestFitMapping = *((BYTE*&)pMLCode)++;
                ThrowOnUnmappableChar = *((BYTE*&)pMLCode)++;                
                STPTRDST( LPSTR, ((ML_CSTRBUILDER_C2N_SR*)plocalwalk)->DoConversion((STRINGBUFFERREF*)psrc, BestFitMapping, ThrowOnUnmappableChar, pCleanupWorkList) );
                LDSRC(STRINGBUFFERREF);
                INCLOCAL(sizeof(ML_CSTRBUILDER_C2N_SR));
                break;

            case ML_CSTRBUILDER_C2N_POST:
                ((ML_CSTRBUILDER_C2N_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->BackPropagate(&fDeferredException);
                break;

            case ML_MARSHAL_SAFEARRAY_N2C_BYREF:
                (BYTE*&)pdst -= sizeof(void*);

				if ( (**(SAFEARRAY***)psrc) &&
					 (**(SAFEARRAY***)psrc)->fFeatures & FADF_STATIC )
				{
					((SafeArrayMarshaler*)pMarshaler)->m_fStatic = TRUE;
					pMarshaler->MarshalNativeToComByref((void *)psrc, pdst);
					StoreObjectInHandle( ((SafeArrayMarshaler*)pMarshaler)->m_combackup, ObjectFromHandle(((SafeArrayMarshaler*)pMarshaler)->m_com) );
				}
				else
				{
					pMarshaler->MarshalNativeToComByref((void *)psrc, pdst);
				}
				(BYTE*&)psrc += sizeof(void*);
                break;

            case ML_UNMARSHAL_SAFEARRAY_N2C_BYREF_IN_OUT:
                pMarshaler = (Marshaler*) (plocals + *((UINT16*&)pMLCode)++);

				if ( ((SafeArrayMarshaler*)pMarshaler)->m_fStatic )
				{
					if (ObjectFromHandle( ((SafeArrayMarshaler*)pMarshaler)->m_combackup ) !=
						ObjectFromHandle( ((SafeArrayMarshaler*)pMarshaler)->m_com ))
					{
						fDeferredException = TRUE;
						specialErrorCode = kSpecialError_InvalidRedim;
					}
					else
					{
					    ((SafeArrayMarshaler*)pMarshaler)->ConvertContentsComToNative();
					}
				}
				else
				{
                    pMarshaler->UnmarshalNativeToComByrefInOut();
				}
				break;

            case ML_CBOOL_C2N:
                STDST(SignedI4TargetType, LDSRC(BYTE) ? 1 : 0);
                break;

            case ML_CBOOL_N2C:
                STDST(SignedI4TargetType, LDSRC(BYTE) ? 1 : 0);
                break;

            case ML_LCID_C2N:
                STDST(LCID, GetThread()->GetCultureId(FALSE));
                break;

            case ML_LCID_N2C:
            {
                BOOL bSuccess = FALSE;
                OBJECTREF OldCulture = GetThread()->GetCulture(FALSE);
                GCPROTECT_BEGIN(OldCulture)
                {
                    EE_TRY_FOR_FINALLY
                    {               
                        GetThread()->SetCultureId(LDSRC(LCID), FALSE);
                        pCleanupWorkList->ScheduleUnconditionalCultureRestore(GetThread()->GetCulture(FALSE));
                        bSuccess = TRUE;
                    }
                    EE_FINALLY
                    {
                        // If we failed to either set the culture or schedule the restore then restore the
                        // thread's culture to the old culture.
                        if (!bSuccess)
                            GetThread()->SetCulture(OldCulture, FALSE);
                    }           
                    EE_END_FINALLY
                }
                GCPROTECT_END();
                break;			
            }


            case ML_STRUCTRETN2C:
                pMT = *((MethodTable**&)pMLCode)++;
                ((ML_STRUCTRETN2C_SR*)plocalwalk)->m_pNativeRetBuf = LDSRC(LPVOID);

                if (! (((ML_STRUCTRETN2C_SR*)plocalwalk)->m_pNativeRetBuf) )
                {
                    COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");
                }

                ((ML_STRUCTRETN2C_SR*)plocalwalk)->m_pMT = pMT;
                ((ML_STRUCTRETN2C_SR*)plocalwalk)->m_ppProtectedBoxedObj = pCleanupWorkList->NewProtectedObjectRef(FastAllocateObject(pMT));
                STDST(LPVOID, (*((ML_STRUCTRETN2C_SR*)plocalwalk)->m_ppProtectedBoxedObj)->GetData()); 
                INCLOCAL(sizeof(ML_STRUCTRETN2C_SR));
                break;

            case ML_STRUCTRETN2C_POST:
                ((ML_STRUCTRETN2C_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->MarshalRetVal(&fDeferredException);
                break;

            case ML_STRUCTRETC2N:
                pMT = *((MethodTable**&)pMLCode)++;
                ((ML_STRUCTRETC2N_SR*)plocalwalk)->m_ppProtectedValueTypeBuf = (LPVOID*)psrc;
                INCSRC(LPVOID);
                ((ML_STRUCTRETC2N_SR*)plocalwalk)->m_pMT = pMT;
                ((ML_STRUCTRETC2N_SR*)plocalwalk)->m_pNativeRetBuf = (LPVOID)(GetThread()->m_MarshalAlloc.Alloc(pMT->GetNativeSize()));
                STDST(LPVOID, ((ML_STRUCTRETC2N_SR*)plocalwalk)->m_pNativeRetBuf);
                INCLOCAL(sizeof(ML_STRUCTRETC2N_SR));
                break;

            case ML_STRUCTRETC2N_POST:
                ((ML_STRUCTRETC2N_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->MarshalRetVal(&fDeferredException);
                break;

            case ML_CURRENCYRETC2N:
                ((ML_CURRENCYRETC2N_SR*)plocalwalk)->m_ppProtectedValueTypeBuf = (DECIMAL**)psrc;
                INCSRC(DECIMAL*);
                STDST(CURRENCY*, &( ((ML_CURRENCYRETC2N_SR*)plocalwalk)->m_cy ));
                INCLOCAL(sizeof(ML_CURRENCYRETC2N_SR));
                break;

            case ML_CURRENCYRETC2N_POST:
                ((ML_CURRENCYRETC2N_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->MarshalRetVal(&fDeferredException);
                break;


            case ML_COPYPINNEDGCREF:
                STDST( LPVOID, LDSRC(LPVOID) );
                break;

            case ML_PUSHVARIANTRETVAL:
                ((VARIANT*)plocalwalk)->vt = VT_EMPTY;
                STDST( VARIANT*, (VARIANT*)plocalwalk );
                INCLOCAL(sizeof(VARIANT));
                break;

            case ML_OBJECTRETC2N_POST:
                tempOR = ObjectToOBJECTREF(OleVariant::MarshalObjectForOleVariantAndClear( ((VARIANT*)(plocals + *( ((UINT16*&)pMLCode)++ ))) ));
                STDST(OBJECTREF, tempOR);
                break;


            case ML_CURRENCYRETN2C:
                ((ML_CURRENCYRETN2C_SR*)plocalwalk)->m_pcy = LDSRC(CURRENCY*);
                if (!(((ML_CURRENCYRETN2C_SR*)plocalwalk)->m_pcy))
                {
                    COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");
                }

                STDST(DECIMAL*, &( ((ML_CURRENCYRETN2C_SR*)plocalwalk)->m_decimal ));
                INCLOCAL(sizeof(ML_CURRENCYRETN2C_SR));
                break;

            case ML_CURRENCYRETN2C_POST:
                ((ML_CURRENCYRETN2C_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->MarshalRetVal(&fDeferredException);
                break;

            case ML_DATETIMERETN2C:
                ((ML_DATETIMERETN2C_SR*)plocalwalk)->m_pdate = LDSRC(DATE*);
                if (!(((ML_DATETIMERETN2C_SR*)plocalwalk)->m_pdate))
                {
                    COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");
                }

                STDST(INT64*, &( ((ML_DATETIMERETN2C_SR*)plocalwalk)->m_datetime ));
                INCLOCAL(sizeof(ML_DATETIMERETN2C_SR));
                break;

            case ML_DATETIMERETN2C_POST:
                ((ML_DATETIMERETN2C_SR*)(plocals + *( ((UINT16*&)pMLCode)++ )))->MarshalRetVal(&fDeferredException);
                break;

			
			default:

#ifndef _DEBUG
                __assume(0);
#endif
                _ASSERTE(!"RunML: Unrecognized ML opcode");
        }
        if (bVariant)
        {
            resetbVariant --;
            if (resetbVariant == 0)
                bVariant = false;
        }
        _ASSERTE(plocalwalk - poldlocalwalk == gMLInfo[*pMLCodeSave].m_cbLocal);
        _ASSERTE(pMLCode - pMLCodeSave == gMLInfo[*pMLCodeSave].m_numOperandBytes + 1);
    }

#undef LDSRC
#undef STDST
#undef INCLOCAL

}






//===========================================================================
// Do conversion for N/Direct parameters of type "Object"
// "Object" is a catch-all type that supports a number of conversions based
// on the runtime type.
//===========================================================================
LPVOID ML_OBJECT_C2N_SR::DoConversion(OBJECTREF       *ppProtectedObjectRef,  
                                      BYTE             inout,
                                      BYTE             fIsAnsi,
                                      BYTE             fBestFitMapping,
                                      BYTE             fThrowOnUnmappableChar,
                                      CleanupWorkList *pCleanup)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(inout == ML_IN || inout == ML_OUT || inout == (ML_IN|ML_OUT));

    m_backproptype = BP_NONE;
    m_inout        = inout;
    m_fIsAnsi      = fIsAnsi;

    if (*ppProtectedObjectRef == NULL) {
        return NULL;
    } else {

        MethodTable *pMT = (*ppProtectedObjectRef)->GetMethodTable();
        if (pMT->IsArray()) {
            CorElementType etyp = ((ArrayClass *) pMT->GetClass())->GetElementType();
            VARTYPE vt = VT_EMPTY;

            switch (etyp)
            {
                case ELEMENT_TYPE_I1:      vt = VT_I1; break;
                case ELEMENT_TYPE_U1:      vt = VT_UI1; break;
                case ELEMENT_TYPE_I2:      vt = VT_I2; break;
                case ELEMENT_TYPE_U2:      vt = VT_UI2; break;
                IN_WIN32(case ELEMENT_TYPE_I:)
                case ELEMENT_TYPE_I4:      vt = VT_I4; break;
                IN_WIN32(case ELEMENT_TYPE_U:)
                case ELEMENT_TYPE_U4:      vt = VT_UI4; break;
                IN_WIN64(case ELEMENT_TYPE_I:)
                case ELEMENT_TYPE_I8:      vt = VT_I8; break;
                IN_WIN64(case ELEMENT_TYPE_U:)
                case ELEMENT_TYPE_U8:      vt = VT_UI8; break;
                case ELEMENT_TYPE_R4:      vt = VT_R4; break;
                case ELEMENT_TYPE_R8:      vt = VT_R8; break;
                case ELEMENT_TYPE_R:       vt = VT_R8; break;
                case ELEMENT_TYPE_CHAR:    vt = m_fIsAnsi ? VTHACK_ANSICHAR : VT_UI2 ; break;
                case ELEMENT_TYPE_BOOLEAN: vt = VTHACK_WINBOOL; break;
                default:
                    COMPlusThrow(kArgumentException, IDS_EE_NDIRECT_BADOBJECT);
            }

            m_backproptype = BP_UNMARSHAL;
            Marshaler *pMarshaler;
            pMarshaler = new (&m_nativearraymarshaler) NativeArrayMarshaler(pCleanup);
            _ASSERTE(pMarshaler != NULL);
            ((NativeArrayMarshaler*)pMarshaler)->SetElementMethodTable(pMT);
            ((NativeArrayMarshaler*)pMarshaler)->SetElementType(vt);
            ((NativeArrayMarshaler*)pMarshaler)->SetElementCount( (*((BASEARRAYREF*)ppProtectedObjectRef))->GetNumComponents() );
            ((NativeArrayMarshaler*)pMarshaler)->SetBestFitMap(fBestFitMapping);
            ((NativeArrayMarshaler*)pMarshaler)->SetThrowOnUnmappableChar(fThrowOnUnmappableChar);


        } else {
            if (pMT == g_pStringClass) {
                m_inout = ML_IN;
                m_backproptype = BP_UNMARSHAL;

                if (m_fIsAnsi) {
                    new (&m_cstrmarshaler) CSTRMarshaler(pCleanup);
                    ((CSTRMarshaler*)m_cstrmarshaler)->SetBestFitMap(fBestFitMapping);
                    ((CSTRMarshaler*)m_cstrmarshaler)->SetThrowOnUnmappableChar(fThrowOnUnmappableChar);
                } else {
                    new (&m_wstrmarshaler) WSTRMarshaler(pCleanup);
                }
            } else {
                if (g_Mscorlib.IsClass(pMT, CLASS__STRING_BUILDER)
                    || GetAppDomain()->IsSpecialStringBuilderClass(pMT)) {
                    if (m_fIsAnsi) {
                        new (&m_cstrbuffermarshaler) CSTRBufferMarshaler(pCleanup);
                       ((CSTRBufferMarshaler*)m_cstrbuffermarshaler)->SetBestFitMap(fBestFitMapping);
                       ((CSTRBufferMarshaler*)m_cstrbuffermarshaler)->SetThrowOnUnmappableChar(fThrowOnUnmappableChar);
                    } else {
                        new (&m_wstrbuffermarshaler) WSTRBufferMarshaler(pCleanup);
                    }
                    m_backproptype = BP_UNMARSHAL;

                } else if (pMT->GetClass()->HasLayout()) {
                    m_backproptype = BP_UNMARSHAL;
                    Marshaler *pMarshaler;
                    pMarshaler = new (&m_layoutclassptrmarshaler) LayoutClassPtrMarshaler(pCleanup, pMT);
                    _ASSERTE(pMarshaler != NULL);
                }

            }
        }

        if (m_backproptype == BP_UNMARSHAL)
        {
            LPVOID nativevalue = NULL;
            switch (m_inout)
            {
                case ML_IN: //fallthru
                case ML_IN|ML_OUT:
                    ((Marshaler*)&m_marshaler)->MarshalComToNative(ppProtectedObjectRef, &nativevalue);
                    break;
                case ML_OUT:
                    ((Marshaler*)&m_marshaler)->MarshalComToNativeOut(ppProtectedObjectRef, &nativevalue);
                    break;
                default:
                    _ASSERTE(0);
            }
            return nativevalue;
        }
    }


    // If we got here, we were passed an unsupported type
    COMPlusThrow(kArgumentException, IDS_EE_NDIRECT_BADOBJECT);
    return NULL;


}



VOID ML_OBJECT_C2N_SR::BackPropagate(BOOL *pfDeferredException)
{
    switch (m_backproptype) {
        case BP_NONE:
            //nothing
            break;

        case BP_UNMARSHAL:
            switch (m_inout)
            {
                case ML_IN:
                    ((Marshaler*)&m_marshaler)->UnmarshalComToNativeIn();
                    break;

                case ML_OUT:
                    ((Marshaler*)&m_marshaler)->UnmarshalComToNativeOut();
                    break;

                case ML_IN|ML_OUT:
                    ((Marshaler*)&m_marshaler)->UnmarshalComToNativeInOut();
                    break;

                default:
                    _ASSERTE(0);

            }
            break;

        default:
            _ASSERTE(0);

    }
}




#ifdef _DEBUG

VOID DisassembleMLStream(const MLCode *pMLCode)
{
    MLCode mlcode;
    while (ML_END != (mlcode = *(pMLCode++)))
    {
        UINT numOperands = gMLInfo[mlcode].m_numOperandBytes;
        printf("  %-20s ", gMLInfo[mlcode].m_szDebugName);
        for (UINT i = 0; i < numOperands; i++)
        {
            printf("%lxh ", (ULONG)*(pMLCode++));
        }
        printf("\n");
    }
    printf("  ML_END\n");
}
#endif



//----------------------------------------------------------------------
// Convert ArrayWithOffset to native array
//----------------------------------------------------------------------
LPVOID ML_ARRAYWITHOFFSET_C2N_SR::DoConversion(BASEARRAYREF    *ppProtectedArrayRef, //pointer to GC-protected BASERARRAYREF,
                                               UINT32           cbOffset,
                                               UINT32           cbCount,
                                               CleanupWorkList *pCleanup)
{
    THROWSCOMPLUSEXCEPTION();

    m_ppProtectedArrayRef = ppProtectedArrayRef;
    if (!*ppProtectedArrayRef) {
        return NULL;
    } else {
        m_cbOffset = cbOffset;
        m_cbCount  = cbCount;
        if (cbCount > kStackBufferSize) {
            m_pNativeArray = GetThread()->m_MarshalAlloc.Alloc(cbCount);
        } else {
            m_pNativeArray = m_StackBuffer;
        }
        memcpyNoGCRefs(m_pNativeArray, cbOffset + (LPBYTE) ((*ppProtectedArrayRef)->GetDataPtr()), cbCount);
        return m_pNativeArray;
    }
}





//----------------------------------------------------------------------
// Backpropagates changes to the native array back to the COM+ array.
//----------------------------------------------------------------------
VOID   ML_ARRAYWITHOFFSET_C2N_SR::BackPropagate()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    if (*m_ppProtectedArrayRef != NULL) {
       memcpyNoGCRefs(m_cbOffset + (LPBYTE) ((*m_ppProtectedArrayRef)->GetDataPtr()), m_pNativeArray, m_cbCount);
    }
}









LPSTR ML_VBBYVALSTR_SR::DoConversion(STRINGREF *ppStringRef, BYTE fBestFitMapping, BYTE fThrowOnUnmappableChar, CleanupWorkList *pCleanup)
{
    THROWSCOMPLUSEXCEPTION();

    m_ppStringRef = ppStringRef;

    STRINGREF pString = *ppStringRef;
    if (!pString) {
        m_pNative = NULL;
        return NULL;
    } else {
        UINT nc = pString->GetStringLength();
        if (nc > 0x7ffffff0)
        {
            COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
        }
        m_ncOriginalLength = nc;
        UINT nbytes = sizeof(DWORD) + (nc+1)*2;
        if (nbytes <= kStackBufferSize) {
            m_pNative = m_buf;
        } else {
            m_pNative = (LPSTR)GetThread()->m_MarshalAlloc.Alloc(nbytes);
        }
        UINT nbytesused;
        if (nc == 0) {
            nbytesused = 1;
            *(m_pNative + sizeof(DWORD)) = '\0';
        } else {
        
            DWORD flags = 0;
            BOOL DefaultCharUsed = FALSE;
        
            if (fBestFitMapping == FALSE)
                flags = WC_NO_BEST_FIT_CHARS;

            nbytesused = WszWideCharToMultiByte(CP_ACP,
                                             flags,
                                             pString->GetBuffer(),
                                             nc+1,
                                             m_pNative + sizeof(DWORD),
                                             nbytes - sizeof(DWORD),
                                             NULL,
                                             &DefaultCharUsed);
            if (!nbytesused) {
                COMPlusThrow(kArgumentException, IDS_UNI2ANSI_FAILURE);
            }

            if (fThrowOnUnmappableChar && DefaultCharUsed)
                COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
            
        }
        *((DWORD*)m_pNative) = nbytesused-1;


        return m_pNative + sizeof(DWORD);

    }
}


VOID ML_VBBYVALSTR_SR::BackPropagate(BOOL *pfDeferredException)
{
//    CANNOTTHROWCOMPLUSEXCEPTION();

    if (m_pNative) {
        STRINGREF pString;
        COMPLUS_TRY {
            pString = COMString::NewString(m_ncOriginalLength);
        } COMPLUS_CATCH {
            *pfDeferredException = TRUE;
        } COMPLUS_END_CATCH
        if (m_ncOriginalLength)
        {
            UINT conf = MultiByteToWideChar(CP_ACP, 0, m_pNative + sizeof(DWORD), m_ncOriginalLength, pString->GetBuffer(), m_ncOriginalLength);
            _ASSERTE(conf);
        }
        SetObjectReferenceUnchecked((OBJECTREF*)m_ppStringRef, (OBJECTREF)pString);
    }

}




LPWSTR ML_VBBYVALSTRW_SR::DoConversion(STRINGREF *ppStringRef, CleanupWorkList *pCleanup)
{
    THROWSCOMPLUSEXCEPTION();

    m_ppStringRef = ppStringRef;

    STRINGREF pString = *ppStringRef;
    if (!pString) {
        m_pNative = NULL;
        return NULL;
    } else {
        UINT nc = pString->GetStringLength();
        if (nc > 0x7ffffff0)
        {
            COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
        }
        m_ncOriginalLength = nc;
        UINT nbytes = sizeof(DWORD) + (nc+1)*2;
        if (nbytes <= sizeof(m_buf)) {
            m_pNative = m_buf;
        } else {
            m_pNative = (LPWSTR)GetThread()->m_MarshalAlloc.Alloc(nbytes);
        }

        memcpyNoGCRefs( ((BYTE*)m_pNative) + sizeof(DWORD), pString->GetBuffer(), ((nc+1)*2));

        *((DWORD*)m_pNative) = nc;

        return (LPWSTR)( ((BYTE*)m_pNative) + sizeof(DWORD) );

    }
}


VOID ML_VBBYVALSTRW_SR::BackPropagate(BOOL *pfDeferredException)
{
//    CANNOTTHROWCOMPLUSEXCEPTION();

    if (m_pNative) {
        STRINGREF pString;
        COMPLUS_TRY {
            pString = COMString::NewString(m_ncOriginalLength);
        } COMPLUS_CATCH {
            *pfDeferredException = TRUE;
        } COMPLUS_END_CATCH
        memcpyNoGCRefs(pString->GetBuffer(), ((BYTE*)m_pNative) + sizeof(DWORD), m_ncOriginalLength*2);

        SetObjectReferenceUnchecked((OBJECTREF*)m_ppStringRef, (OBJECTREF)pString);
    }

}




LPVOID ML_REFVALUECLASS_C2N_SR::DoConversion(LPVOID          *ppProtectedData,
                                             MethodTable     *pMT,
                                             BYTE             fInOut,
                                             CleanupWorkList *pCleanup         
                                           )
{
    m_ppProtectedData = ppProtectedData;
    m_pMT             = pMT;
    m_inout           = fInOut;
    _ASSERTE( fInOut == ML_IN || fInOut == ML_OUT || fInOut == (ML_IN|ML_OUT) );

    m_buf = (BYTE*)(pCleanup->NewScheduleLayoutDestroyNative(pMT));
    if (m_inout & ML_IN)
    {
        FmtValueTypeUpdateNative(ppProtectedData, pMT, m_buf);
    }
    else
    {
        FillMemory(m_buf, pMT->GetNativeSize(), 0);
    }
    return m_buf;

}

VOID ML_REFVALUECLASS_C2N_SR::BackPropagate(BOOL *pfDeferredException)
{
    if (m_inout & ML_OUT)
    {
        COMPLUS_TRY {
            FmtValueTypeUpdateComPlus(m_ppProtectedData, m_pMT, m_buf, FALSE);
        } COMPLUS_CATCH {
            *pfDeferredException = TRUE;
        } COMPLUS_END_CATCH
    }
}




VariantData *ML_REFVARIANT_N2C_SR::DoConversion(VARIANT* pUmgdVariant, BYTE fInOut, CleanupWorkList *pCleanup)
{
    THROWSCOMPLUSEXCEPTION();

    m_fInOut = fInOut;
    m_pUnmgdVariant = pUmgdVariant;

    COMVariant::EnsureVariantInitialized();
    MethodTable *pMT = COMVariant::s_pVariantClass->GetMethodTable();
    OBJECTREF pBoxedVariant = FastAllocateObject(pMT);
    m_pObjHnd = pCleanup->NewScheduledProtectedHandle(pBoxedVariant);

    if (fInOut & ML_IN) {
        OleVariant::MarshalComVariantForOleVariant(pUmgdVariant, (VariantData *)(ObjectFromHandle(m_pObjHnd)->GetData()));
    } else {
        VARIANT vempty;
        vempty.vt = VT_EMPTY;
        OleVariant::MarshalComVariantForOleVariant(&vempty, (VariantData *)(ObjectFromHandle(m_pObjHnd)->GetData()));
    }
    return (VariantData *)(ObjectFromHandle(m_pObjHnd)->GetData());
}
        

VOID ML_REFVARIANT_N2C_SR::BackPropagate(BOOL *pfDeferredException, HRESULT *pdeferredExceptionHR)
{
    if (m_fInOut & ML_OUT) {
        if (!(m_fInOut & ML_IN)) {
            // if [out] only, assume nothing about the incoming variant: set it to VT_EMPTY so that
            // VariantClear() has well-defined behavior.
            m_pUnmgdVariant->vt = VT_EMPTY;
        }
        COMPLUS_TRY {
            if (m_pUnmgdVariant->vt & VT_BYREF)
            {
                // This will also take care of clearing the initial variant.
                OleVariant::MarshalOleRefVariantForComVariant( (VariantData *)(ObjectFromHandle(m_pObjHnd)->GetData()), m_pUnmgdVariant );
            }
            else
            {
                // This call will also do the VariantClear.
                OleVariant::MarshalOleVariantForComVariant( (VariantData *)(ObjectFromHandle(m_pObjHnd)->GetData()), m_pUnmgdVariant );
            }
        } COMPLUS_CATCH {
            *pfDeferredException = TRUE;
        } COMPLUS_END_CATCH
    }
}







OBJECTREF * ML_REFOBJECT_N2C_SR::DoConversion(VARIANT* pUmgdVariant, BYTE fInOut, CleanupWorkList *pCleanup)
{
    THROWSCOMPLUSEXCEPTION();

    m_fInOut = fInOut;
    m_pUnmgdVariant = pUmgdVariant;
    m_pObjRef = pCleanup->NewProtectedObjectRef(NULL);


    if (fInOut & ML_IN)
    {
        OBJECTREF Obj = NULL;
        GCPROTECT_BEGIN(Obj)
        {
            OleVariant::MarshalObjectForOleVariant(pUmgdVariant, &Obj);
            *m_pObjRef = Obj;
        }
        GCPROTECT_END();
    }

    return m_pObjRef;
}
        


VOID ML_REFOBJECT_N2C_SR::BackPropagate(BOOL *pfDeferredException, HRESULT *pdeferredExceptionHR)
{
    if (m_fInOut & ML_OUT) {
        if (!(m_fInOut & ML_IN)) {
            // if [out] only, assume nothing about the incoming variant: set it to VT_EMPTY so that
            // VariantClear() has well-defined behavior.
            m_pUnmgdVariant->vt = VT_EMPTY;
        }
        COMPLUS_TRY {

            OBJECTREF Obj = *m_pObjRef;
            GCPROTECT_BEGIN(Obj)
            {
                if (m_pUnmgdVariant->vt & VT_BYREF)
                {
                    // MarshalOleRefVariantForObject clears what m_pUnmgdVariant pointed at.
                    OleVariant::MarshalOleRefVariantForObject(&Obj, m_pUnmgdVariant);
                }
                else
                {
                    // MarshalOleVariantForObject() performs the VariantClear on m_pUnmgdVariant
                    OleVariant::MarshalOleVariantForObject(&Obj, m_pUnmgdVariant);
                }
            }
            GCPROTECT_END();

        } COMPLUS_CATCH {
            *pfDeferredException = TRUE;
        } COMPLUS_END_CATCH
    }
}







LPVOID ML_REFVALUECLASS_N2C_SR::DoConversion(LPVOID pUmgdVALUECLASS, BYTE fInOut, MethodTable *pMT, CleanupWorkList *pCleanup)
{
    THROWSCOMPLUSEXCEPTION();

    m_fInOut = fInOut;
    m_pMT    = pMT;
    m_pUnmgdVC = pUmgdVALUECLASS;

    OBJECTREF pBoxedVALUECLASS = FastAllocateObject(pMT);
    m_pObjHnd = pCleanup->NewScheduledProtectedHandle(pBoxedVALUECLASS);

    if (fInOut & ML_IN) {
        LayoutUpdateComPlus((VOID**)m_pObjHnd, Object::GetOffsetOfFirstField(), pMT->GetClass(), (BYTE*)pUmgdVALUECLASS, FALSE);
    }
    return (LPVOID)(ObjectFromHandle(m_pObjHnd)->GetData());
}
        

VOID ML_REFVALUECLASS_N2C_SR::BackPropagate(BOOL *pfDeferredException)
{
    if (m_fInOut & ML_OUT) {
        COMPLUS_TRY {
            if (m_fInOut & ML_IN) {
                FmtClassDestroyNative(m_pUnmgdVC, m_pMT->GetClass());
            }
            LayoutUpdateNative((VOID**)m_pObjHnd, Object::GetOffsetOfFirstField(), m_pMT->GetClass(), (BYTE*)m_pUnmgdVC, NULL);
        } COMPLUS_CATCH {
            *pfDeferredException = TRUE;
        } COMPLUS_END_CATCH
    }
}

LPVOID ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_SR::DoConversion(const VOID * psrc, UINT32 cbSize)
{
    THROWSCOMPLUSEXCEPTION();
    m_psrc = psrc;
    m_cbSize = cbSize;
    m_pTempCopy = (LPVOID)(GetThread()->m_MarshalAlloc.Alloc(cbSize));
    return m_pTempCopy;
}

VOID ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_SR::BackPropagate(BOOL *pfDeferredException)
{
    memcpyNoGCRefs(*((VOID**)m_psrc), m_pTempCopy, m_cbSize);
}



LPCWSTR ML_BSTR_C2N_SR::DoConversion(STRINGREF pStringRef, CleanupWorkList *pCleanup)
{
    THROWSCOMPLUSEXCEPTION();

    if (pStringRef == NULL)
    {
        return NULL;
    }
    else
    {
        int    nc;
        WCHAR *pc;
        RefInterpretGetStringValuesDangerousForGC(pStringRef, &pc, &nc);
        int    cb = (nc + 1) * sizeof(WCHAR) + sizeof(DWORD);
        BYTE  *pbuf = m_buf;
        if (cb > sizeof(m_buf))
        {
            pbuf = (BYTE*)CoTaskMemAlloc(cb);
            if (!pbuf)
            {
                COMPlusThrowOM();
            }
            pCleanup->ScheduleCoTaskFree(pbuf);
        }
        *((DWORD*)pbuf) = nc * sizeof(WCHAR);
        memcpyNoGCRefs( pbuf + sizeof(DWORD), pc, (nc + 1) * sizeof(WCHAR) );

        return (LPCWSTR)(pbuf + sizeof(DWORD));
    }
}


LPSTR ML_CSTR_C2N_SR::DoConversion(STRINGREF pStringRef, UINT32 fBestFitMapping, UINT32 fThrowOnUnmappableChar, CleanupWorkList *pCleanup)
{
    THROWSCOMPLUSEXCEPTION();

    if (pStringRef == NULL)
    {
        return NULL;
    }
    else
    {
        int    nc;
        WCHAR *pc;
        RefInterpretGetStringValuesDangerousForGC(pStringRef, &pc, &nc);
        int    cb = (nc + 1) * GetMaxDBCSCharByteSize() + 1;
        BYTE  *pbuf = m_buf;
        if (cb > sizeof(m_buf))
        {
            pbuf = (BYTE*)CoTaskMemAlloc(cb);
            if (!pbuf)
            {
                COMPlusThrowOM();
            }
            pCleanup->ScheduleCoTaskFree(pbuf);
        }
        
        DWORD mblength = 0;

        if (nc+1)
        {
            DWORD flags = 0;
            BOOL DefaultCharUsed = FALSE;
        
            if (fBestFitMapping == FALSE)
                flags = WC_NO_BEST_FIT_CHARS;

            mblength = WszWideCharToMultiByte(CP_ACP, flags,
                                    pStringRef->GetBuffer(), (nc+1),
                                    (LPSTR) pbuf, ((nc+1) * GetMaxDBCSCharByteSize()) + 1,
                                    NULL, &DefaultCharUsed);
            if (mblength == 0)
                COMPlusThrowWin32();

            if (fThrowOnUnmappableChar && DefaultCharUsed)
                COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
                
        }
        ((CHAR*)pbuf)[mblength] = '\0';

        return (LPSTR)(pbuf);
    }
}




LPWSTR ML_WSTRBUILDER_C2N_SR::DoConversion(STRINGBUFFERREF *ppProtectedStringBuffer, CleanupWorkList *pCleanup)
{

    m_ppProtectedStringBuffer = ppProtectedStringBuffer;
    STRINGBUFFERREF stringRef = *m_ppProtectedStringBuffer;


    if (stringRef == NULL)
    {
        m_pNative = NULL;
    }
    else
    {
        UINT32 capacity = (UINT32)COMStringBuffer::NativeGetCapacity(stringRef);
        m_pNative = (LPWSTR)(GetThread()->m_MarshalAlloc.Alloc(max(256, (capacity+3) * sizeof(WCHAR))));
        // HACK: N/Direct can be used to call Win32 apis that don't
        // strictly follow COM+ in/out semantics and thus may leave
        // garbage in the buffer in circumstances that we can't detect.
        // To prevent the marshaler from crashing when converting the
        // contents back to COM, ensure that there's a hidden null terminator
        // past the end of the official buffer.
        m_pNative[capacity+1] = L'\0';
        m_pSentinel = &(m_pNative[capacity+1]);
        m_pSentinel[1] = 0xabab;
#ifdef _DEBUG
        FillMemory(m_pNative, (capacity+1)*sizeof(WCHAR), 0xcc);
#endif
        SIZE_T length = COMStringBuffer::NativeGetLength(stringRef);

        memcpyNoGCRefs((WCHAR *) m_pNative, COMStringBuffer::NativeGetBuffer(stringRef),
                       length * sizeof(WCHAR));
        ((WCHAR*)m_pNative)[length] = 0;

    
    
    }
    return m_pNative;
}



VOID ML_WSTRBUILDER_C2N_SR::BackPropagate(BOOL *pfDeferredException)
{
    THROWSCOMPLUSEXCEPTION();
    if (m_pNative != NULL)
    {
        if (L'\0' != m_pSentinel[0] || 0xabab != m_pSentinel[1])
        {
            // ! Though our normal protocol is to set *pfDeferredException to TRUE and return normally,
            // ! this mechanism doesn't let us return informative exceptions. So we'll throw this one 
            // ! immediately. The excuse for doing this is that this exception's only purpose in
            // ! life is to tell the programmer that he introduced a bug that probably corrupted the heap.
            // ! Hence, assuming the process even survives long enough to deliver our message,
            // ! memory leaks from any other backpropagations bypassed as a result is the least of 
            // ! our problems.
            COMPlusThrow(kIndexOutOfRangeException, IDS_PINVOKE_STRINGBUILDEROVERFLOW);
        }

        COMStringBuffer::ReplaceBuffer(m_ppProtectedStringBuffer,
                                       m_pNative, (INT32)wcslen(m_pNative));
    
    
    }
}






LPSTR ML_CSTRBUILDER_C2N_SR::DoConversion(STRINGBUFFERREF *ppProtectedStringBuffer, BYTE fBestFitMapping, BYTE fThrowOnUnmappableChar, CleanupWorkList *pCleanup)
{

    THROWSCOMPLUSEXCEPTION();

    m_ppProtectedStringBuffer = ppProtectedStringBuffer;
    STRINGBUFFERREF stringRef = *m_ppProtectedStringBuffer;


    if (stringRef == NULL)
    {
        m_pNative = NULL;
    }
    else
    {
        UINT32 capacity = (UINT32)COMStringBuffer::NativeGetCapacity(stringRef);


        // capacity is the count of wide chars, allocate buffer big enough for maximum
        // conversion to DBCS.
        m_pNative = (LPSTR)(GetThread()->m_MarshalAlloc.Alloc(max(256, (capacity * GetMaxDBCSCharByteSize()) + 5)));

        // HACK: N/Direct can be used to call Win32 apis that don't
        // strictly follow COM+ in/out semantics and thus may leave
        // garbage in the buffer in circumstances that we can't detect.
        // To prevent the marshaler from crashing when converting the
        // contents back to COM, ensure that there's a hidden null terminator
        // past the end of the official buffer.
        m_pSentinel = &(m_pNative[capacity+1]);
        ((CHAR*)m_pSentinel)[0] = '\0';
        ((CHAR*)m_pSentinel)[1] = '\0';
        ((CHAR*)m_pSentinel)[2] = '\0';
        ((CHAR*)m_pSentinel)[3] = (CHAR)(SIZE_T)0xab;

#ifdef _DEBUG
        FillMemory(m_pNative, (capacity+1) * sizeof(CHAR), 0xcc);
#endif
        UINT32 length = (UINT32)COMStringBuffer::NativeGetLength(stringRef);
        DWORD mblength = 0;

        if (length)
        {
            DWORD flags = 0;
            BOOL DefaultCharUsed = FALSE;
        
            if (fBestFitMapping == FALSE)
                flags = WC_NO_BEST_FIT_CHARS;

            mblength = WszWideCharToMultiByte(CP_ACP, flags,
                                    COMStringBuffer::NativeGetBuffer(stringRef), length,
                                    (LPSTR) m_pNative, (capacity * GetMaxDBCSCharByteSize()) + 4,
                                    NULL, &DefaultCharUsed);
            if (mblength == 0)
                COMPlusThrowWin32();

            if (fThrowOnUnmappableChar && DefaultCharUsed)
                COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
                
        }
        ((CHAR*)m_pNative)[mblength] = '\0';


    }
    return m_pNative;
}



VOID ML_CSTRBUILDER_C2N_SR::BackPropagate(BOOL *pfDeferredException)
{
    THROWSCOMPLUSEXCEPTION();
    if (m_pNative != NULL)
    {
        if (0 != m_pSentinel[0] || 
            0 != m_pSentinel[1] ||
            0 != m_pSentinel[2]  ||
            (CHAR)(SIZE_T)0xab != m_pSentinel[3])
        {
            // ! Though our normal protocol is to set *pfDeferredException to TRUE and return normally,
            // ! this mechanism doesn't let us return informative exceptions. So we'll throw this one 
            // ! immediately. The excuse for doing this is that this exception's only purpose in
            // ! life is to tell the programmer that he introduced a bug that probably corrupted the heap.
            // ! Hence, assuming the process even survives long enough to deliver our message,
            // ! memory leaks from any other backpropagations bypassed as a result is the least of 
            // ! our problems.
            COMPlusThrow(kIndexOutOfRangeException, IDS_PINVOKE_STRINGBUILDEROVERFLOW);
        }

        COMStringBuffer::ReplaceBufferAnsi(m_ppProtectedStringBuffer,
                                           m_pNative, (INT32)strlen(m_pNative));
    
    
    }
}

//====================================================================
// Helper fcns called from standalone stubs. These don't really belong
// here but I'm not going to include marshaler.h in yet another file.
//====================================================================
VOID STDMETHODCALLTYPE DoMLCreateMarshalerBStr(Frame *pFrame, CleanupWorkList *pCleanup, UINT8 *plocalwalk)
{
    pCleanup->IsVisibleToGc();
    new (plocalwalk) BSTRMarshaler(pCleanup);
}

VOID STDMETHODCALLTYPE DoMLCreateMarshalerCStr(Frame *pFrame, CleanupWorkList *pCleanup, UINT8 *plocalwalk, UINT32 fBestFitMapping, UINT32 fThrowOnUnmappableChar)
{
    pCleanup->IsVisibleToGc();
    new (plocalwalk) CSTRMarshaler(pCleanup);
    ((CSTRMarshaler*)plocalwalk)->SetBestFitMap(fBestFitMapping);
    ((CSTRMarshaler*)plocalwalk)->SetThrowOnUnmappableChar(fThrowOnUnmappableChar);
}

VOID STDMETHODCALLTYPE DoMLCreateMarshalerWStr(Frame *pFrame, CleanupWorkList *pCleanup, UINT8 *plocalwalk)
{
    pCleanup->IsVisibleToGc();
    new (plocalwalk) WSTRMarshaler(pCleanup);
}


VOID STDMETHODCALLTYPE DoMLPrereturnC2N(Marshaler *pMarshaler, LPVOID pstackout)
{
    pMarshaler->PrereturnComFromNativeRetval(NULL, pstackout);
}


LPVOID STDMETHODCALLTYPE DoMLReturnC2NRetVal(Marshaler *pMarshaler)
{
    // WARNING!!!!! "dstobjref" holds an OBJECTREF: Don't add any operations
    // that might cause a GC!
    LPVOID dstobjref;

    pMarshaler->ReturnComFromNativeRetval( (LPVOID)&dstobjref, NULL );
    return dstobjref;
}


void ML_STRUCTRETN2C_SR::MarshalRetVal(BOOL *pfDeferredException)
{
    COMPLUS_TRY {

        LayoutUpdateNative( (LPVOID*)m_ppProtectedBoxedObj, Object::GetOffsetOfFirstField(), m_pMT->GetClass(), (BYTE*)m_pNativeRetBuf, NULL);

    } COMPLUS_CATCH {
        *pfDeferredException = TRUE;
    } COMPLUS_END_CATCH
}




void ML_STRUCTRETC2N_SR::MarshalRetVal(BOOL *pfDeferredException)
{
    COMPLUS_TRY {

        LayoutUpdateComPlus( m_ppProtectedValueTypeBuf, 0, m_pMT->GetClass(), (BYTE*)m_pNativeRetBuf, TRUE);

    } COMPLUS_CATCH {
        *pfDeferredException = TRUE;
    } COMPLUS_END_CATCH
}



void ML_CURRENCYRETC2N_SR::MarshalRetVal(BOOL *pfDeferredException)
{
    HRESULT hr;
    hr = VarDecFromCy(m_cy, *m_ppProtectedValueTypeBuf);
    if (FAILED(hr))
    {
        *pfDeferredException = TRUE;
    }
    DecimalCanonicalize(*m_ppProtectedValueTypeBuf);
}


void ML_CURRENCYRETN2C_SR::MarshalRetVal(BOOL *pfDeferredException)
{
    HRESULT hr;
    hr = VarCyFromDec(&m_decimal, m_pcy);
    if (FAILED(hr))
    {
        *pfDeferredException = TRUE;
    }
}


void ML_DATETIMERETN2C_SR::MarshalRetVal(BOOL *pfDeferredException)
{
    *m_pdate = COMDateTime::TicksToDoubleDate(m_datetime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mlcache.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// MLCACHE.CPP -
//
// Base class for caching ML stubs.
//

#include "common.h"
#include "mlcache.h"
#include "stublink.h"
#include "cgensys.h"
#include "excep.h"

//---------------------------------------------------------
// Constructor
//---------------------------------------------------------
MLStubCache::MLStubCache(LoaderHeap *pHeap) :
    CClosedHashBase(
#ifdef _DEBUG
                      3,
#else
                      17,    // CClosedHashTable will grow as necessary
#endif                      

                      sizeof(MLCHASHENTRY),
                      FALSE
                   ),
    m_crst("MLCache", CrstMLCache),
	m_heap(pHeap)
{
}


//---------------------------------------------------------
// Destructor
//---------------------------------------------------------
MLStubCache::~MLStubCache()
{
    MLCHASHENTRY *phe = (MLCHASHENTRY*)GetFirst();
    while (phe) {
        phe->m_pMLStub->DecRef();
        phe = (MLCHASHENTRY*)GetNext((BYTE*)phe);
    }
}



//---------------------------------------------------------
// Callback function for DeleteLoop.
//---------------------------------------------------------
/*static*/ BOOL MLStubCache::DeleteLoopFunc(BYTE *pEntry, LPVOID)
{
    // WARNING: Inside the MLStubCache lock. Be careful what you do.

    MLCHASHENTRY *phe = (MLCHASHENTRY*)pEntry;
    if (phe->m_pMLStub->HeuristicLooksOrphaned()) {
        phe->m_pMLStub->DecRef();
        return TRUE;
    }
    return FALSE;
}


//---------------------------------------------------------
// Another callback function for DeleteLoop.
//---------------------------------------------------------
/*static*/ BOOL MLStubCache::ForceDeleteLoopFunc(BYTE *pEntry, LPVOID)
{
    // WARNING: Inside the MLStubCache lock. Be careful what you do.

    MLCHASHENTRY *phe = (MLCHASHENTRY*)pEntry;
    phe->m_pMLStub->ForceDelete();
    return TRUE;
}


//---------------------------------------------------------
// Call this occasionally to get rid of unused stubs.
//---------------------------------------------------------
VOID MLStubCache::FreeUnusedStubs()
{
    m_crst.Enter();

    DeleteLoop(DeleteLoopFunc, 0);

    m_crst.Leave();

}




//---------------------------------------------------------
// Returns the equivalent hashed Stub, creating a new hash
// entry if necessary. If the latter, will call out to CompileMLStub.
//
// Refcounting:
//    The caller is responsible for DecRef'ing the returned stub in
//    order to avoid leaks.
//
//
// On successful exit, *pMode is set to describe
// the compiled nature of the MLStub.
//
// callerContext can be used by the caller to push some context through
// to the compilation routine.
//
// Returns NULL for out of memory or other fatal error.
//---------------------------------------------------------
Stub *MLStubCache::Canonicalize(const BYTE * pRawMLStub, MLStubCompilationMode *pMode,
                                void *callerContext)
{
    m_crst.Enter();

    MLCHASHENTRY *phe = (MLCHASHENTRY*)Find((LPVOID)pRawMLStub);
    if (phe) {
        Stub *pstub = phe->m_pMLStub;
        pstub->IncRef();
        *pMode = (MLStubCompilationMode) (phe->m_compilationMode);
        m_crst.Leave();
        return pstub;
    }
    m_crst.Leave();

    {
        CPUSTUBLINKER sl;
        CPUSTUBLINKER slempty;
        CPUSTUBLINKER *psl = &sl;
		MLStubCompilationMode mode;
        mode = CompileMLStub(pRawMLStub, psl, callerContext);
        if (mode == INTERPRETED) {
            // CompileMLStub returns INTERPRETED for error cases:
            // in this case, redirect to the empty stublinker so
            // we don't accidentally pick up any crud that
            // CompileMLStub threw into the stublinker before
            // it ran into the error condition.
            psl = &slempty;
        }

        *pMode = mode;

        UINT32 offset;
        Stub   *pstub;
        if (NULL == (pstub = FinishLinking(psl, pRawMLStub, &offset))) {
            return NULL;
        }

        if (offset > 0xffff) {
            return NULL;
        }

        m_crst.Enter();

        bool bNew;
        phe = (MLCHASHENTRY*)FindOrAdd((LPVOID)pRawMLStub, /*modifies*/bNew);
        if (phe) {
            if (bNew) {
                // Note: FinishLinking already does the IncRef.
                phe->m_pMLStub = pstub;
                phe->m_offsetOfRawMLStub = (UINT16)offset;
                phe->m_compilationMode   = mode;

            } else {

                // If we got here, some other thread got in
                // and enregistered an identical stub during
                // the window in which we were out of the m_crst.

                //Under DEBUG, two identical ML streams can actually compile
                // to different compiled stubs due to the checked build's
                // toggling between inlined TLSGetValue and api TLSGetValue.
                //_ASSERTE(phe->m_offsetOfRawMLStub == (UINT16)offset);
                _ASSERTE(phe->m_compilationMode == mode);
                pstub->DecRef(); // Destroy the stub we just created
                pstub = phe->m_pMLStub; //Use the previously created stub

            }

            // IncRef so that caller has firm ownership of stub.
            pstub->IncRef();
        }

        m_crst.Leave();

        if (phe) {
            return pstub;
        } else {
            // Couldn't grow hash table due to lack of memory.
            // Destroy the stub and return NULL.
            pstub->DecRef();
        }

    }
    
    return NULL;
}


//---------------------------------------------------------
// This function appends the raw ML stub to the native stub
// and links up the stub. It is broken out as a separate function
// only because of the incompatibility between C++ local objects
// and COMPLUS_TRY.
//---------------------------------------------------------
Stub *MLStubCache::FinishLinking(StubLinker *psl,
                    const BYTE *pRawMLStub,
                    UINT32     *poffset)
{
    Stub *pstub = NULL; // CHANGE, VC6.0
    COMPLUS_TRY {

        CodeLabel *plabel = psl->EmitNewCodeLabel();
        psl->EmitBytes(pRawMLStub, Length(pRawMLStub));
        pstub = psl->Link(m_heap); // CHANGE, VC6.0
        *poffset = psl->GetLabelOffset(plabel);

    } COMPLUS_CATCH {
        return NULL;
    } COMPLUS_END_CATCH
    return pstub; // CHANGE, VC6.0
}

//*****************************************************************************
// Hash is called with a pointer to an element in the table.  You must override
// this method and provide a hash algorithm for your element type.
//*****************************************************************************
unsigned long MLStubCache::Hash(             // The key value.
    void const  *pData)                      // Raw data to hash.
{
    const BYTE *pRawMLStub = (const BYTE *)pData;

    UINT cb = Length(pRawMLStub);
    long   hash = 0;
    while (cb--) {
        hash = _rotl(hash,1) + *(pRawMLStub++);
    }
    return hash;
}

//*****************************************************************************
// Compare is used in the typical memcmp way, 0 is eqaulity, -1/1 indicate
// direction of miscompare.  In this system everything is always equal or not.
//*****************************************************************************
unsigned long MLStubCache::Compare(          // 0, -1, or 1.
    void const  *pData,                 // Raw key data on lookup.
    BYTE        *pElement)            // The element to compare data against.
{
    const BYTE *pRawMLStub1  = (const BYTE *)pData;
    const BYTE *pRawMLStub2  = (const BYTE *)GetKey(pElement);
    UINT cb1 = Length(pRawMLStub1);
    UINT cb2 = Length(pRawMLStub2);

    if (cb1 != cb2) {
        return 1; // not equal
    } else {
        while (cb1--) {
            if (*(pRawMLStub1++) != *(pRawMLStub2++)) {
                return 1; // not equal
            }
        }
        return 0;
    }
}

//*****************************************************************************
// Return true if the element is free to be used.
//*****************************************************************************
CClosedHashBase::ELEMENTSTATUS MLStubCache::Status(           // The status of the entry.
    BYTE        *pElement)           // The element to check.
{
    Stub *pStub = ((MLCHASHENTRY*)pElement)->m_pMLStub;
    if (pStub == NULL) {
        return FREE;
    } else if (pStub == (Stub*)(-1)) {
        return DELETED;
    } else {
        return USED;
    }
}

//*****************************************************************************
// Sets the status of the given element.
//*****************************************************************************
void MLStubCache::SetStatus(
    BYTE        *pElement,              // The element to set status for.
    ELEMENTSTATUS eStatus)            // New status.
{
    MLCHASHENTRY *phe = (MLCHASHENTRY*)pElement;
    switch (eStatus) {
        case FREE:    phe->m_pMLStub = NULL;   break;
        case DELETED: phe->m_pMLStub = (Stub*)(-1); break;
        default:
            _ASSERTE(!"MLCacheEntry::SetStatus(): Bad argument.");
    }
}

//*****************************************************************************
// Returns the internal key value for an element.
//*****************************************************************************
void *MLStubCache::GetKey(                   // The data to hash on.
    BYTE        *pElement)           // The element to return data ptr for.
{
    MLCHASHENTRY *phe = (MLCHASHENTRY*)pElement;
    return (void *)( ((BYTE*)(phe->m_pMLStub->GetEntryPoint())) + phe->m_offsetOfRawMLStub ); 
}



//*****************************************************************************
// ForceDeleteStubs
//
// Forces all cached stubs to free themselves. This routine forces the refcount
// to 1, then does a DecRef. It is not threadsafe, and thus can
// only be used in shutdown scenarios.
//*****************************************************************************
#ifdef SHOULD_WE_CLEANUP
VOID MLStubCache::ForceDeleteStubs()
{
    m_crst.Enter();

    DeleteLoop(ForceDeleteLoopFunc, 0);

    m_crst.Leave();
}
#endif /* SHOULD_WE_CLEANUP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mlgen.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// MLGEN.CPP -
//
// Stub generator for ML opcodes.

#include "common.h"

#include "vars.hpp"
#include "ml.h"
#include "stublink.h"
#include "excep.h"
#include "mlgen.h"



//--------------------------------------------------------------
// Emit an opcode.
//--------------------------------------------------------------
VOID MLStubLinker::MLEmit(MLCode opcode)
{
    THROWSCOMPLUSEXCEPTION();
    Emit8(opcode);
}


//--------------------------------------------------------------
// Emit "cb" bytes of uninitialized space.
//--------------------------------------------------------------
VOID MLStubLinker::MLEmitSpace(UINT cb)
{
    THROWSCOMPLUSEXCEPTION();
    while (cb--)
    {
        Emit8(0);
    }
}


//--------------------------------------------------------------
// Reserves "numBytes" bytes of local space and returns the
// offset of the allocated space. Local slots are guaranteed
// to be allocated in increasing order starting from 0. This
// allows ML instructions to use the LOCALWALK ML register
// to implicitly address the locals, rather than burning up
// memory to store a local offset directly in the ML stream.
//--------------------------------------------------------------
UINT16 MLStubLinker::MLNewLocal(UINT16 numBytes)
{
    THROWSCOMPLUSEXCEPTION();

    numBytes = (numBytes + 3) & ~3;
    UINT16 newLocal = m_nextFreeLocal;
    m_nextFreeLocal += numBytes;
    if ( m_nextFreeLocal < newLocal ) {
        COMPlusThrow(kTypeLoadException, IDS_EE_OUTOFLOCALS);
    }
    return newLocal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\microsoft.comservices_i.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Mon Jul 17 19:19:10 2000
 */
/* Compiler settings for Z:\urt\inst\v1.x86chk\Microsoft.ComServices.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_Microsoft_ComServices,0xD7F68C66,0x3833,0x3832,0xB6,0xD0,0xB7,0x96,0xBB,0x7D,0x2D,0xFF);


MIDL_DEFINE_GUID(IID, IID_IRegistrationHelper,0x55E3EA25,0x55CB,0x4650,0x88,0x87,0x18,0xE8,0xD3,0x0B,0xB4,0xBC);


MIDL_DEFINE_GUID(CLSID, CLSID_RegistrationHelperTx,0x89A86E7B,0xC229,0x4008,0x9B,0xAA,0x2F,0x5C,0x84,0x11,0xD7,0xE0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Mon Jul 17 19:19:10 2000
 */
/* Compiler settings for Z:\urt\inst\v1.x86chk\Microsoft.ComServices.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_Microsoft_ComServices,0xD7F68C66,0x3833,0x3832,0xB6,0xD0,0xB7,0x96,0xBB,0x7D,0x2D,0xFF);


MIDL_DEFINE_GUID(IID, IID_IRegistrationHelper,0x55E3EA25,0x55CB,0x4650,0x88,0x87,0x18,0xE8,0xD3,0x0B,0xB4,0xBC);


MIDL_DEFINE_GUID(CLSID, CLSID_RegistrationHelperTx,0x89A86E7B,0xC229,0x4008,0x9B,0xAA,0x2F,0x5C,0x84,0x11,0xD7,0xE0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mlgen.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// MLGEN.H -
//
// Stub generator for ML opcodes.

#ifndef __MLGEN_H__
#define __MLGEN_H__

#include "vars.hpp"
#include "util.hpp"
#include "ml.h"
#include "stublink.h"
#include "excep.h"


//========================================================================
// StubLinker for generating ML. We inherit StubLinker privately
// in order to force emits to go thru the ML-specific code. This
// allows the MLStubLinker to do some simple peephole optimization.
//========================================================================
class MLStubLinker : public StubLinker
{
    public:
        //--------------------------------------------------------------
        // Constructor
        //--------------------------------------------------------------
        MLStubLinker()
        {
            m_nextFreeLocal = 0;
        }

        //--------------------------------------------------------------
        // One-time initialization
        //--------------------------------------------------------------
        VOID Init()
        {
            THROWSCOMPLUSEXCEPTION();
            StubLinker::Init();
        }


        //--------------------------------------------------------------
        // Generate the stub.
        //--------------------------------------------------------------
        Stub *Link()
        {
            THROWSCOMPLUSEXCEPTION();
            return StubLinker::Link();
        }


        //--------------------------------------------------------------
        // Emit an opcode.
        //--------------------------------------------------------------
        VOID MLEmit(MLCode opcode);

        //--------------------------------------------------------------
        // Emit "cb" bytes of uninitialized space.
        //--------------------------------------------------------------
        VOID MLEmitSpace(UINT cb);


        //--------------------------------------------------------------
        // Reserves "numBytes" bytes of local space and returns the
        // offset of the allocated space. Local slots are guaranteed
        // to be allocated in increasing order starting from 0. This
        // allows ML instructions to use the LOCALWALK ML register
        // to implicitly address the locals, rather than burning up
        // memory to store a local offset directly in the ML stream.
        //--------------------------------------------------------------
        UINT16 MLNewLocal(UINT16 numBytes);

        //--------------------------------------------------------------
        // Returns the offset of the next unused local byte.
        //--------------------------------------------------------------
        UINT16 GetLocalSize()
        {
            return m_nextFreeLocal;
        }


    private:
        //--------------------------------------------------------------
        // Keeps track of the next available local.
        //--------------------------------------------------------------
        UINT16      m_nextFreeLocal;
};







#endif  //__MLGEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mngstdinterfaces.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  MngStdInterfaces.cpp
**
**
** Purpose: Contains the implementation of the MngStdInterfaces
**          class. This class is used to determine the associated
**          
**
** 
===========================================================*/

#include "common.h"
#include "MngStdInterfaces.h"
#include "dispex.h"
#include "class.h"
#include "method.hpp"
#include "ComPlusWrapper.h"
#include "excep.h"
#include "COMString.h"
#include "COMCodeAccessSecurityEngine.h"

//
// Declare the static field int the ManagedStdInterfaceMap class.
//

MngStdInterfaceMap MngStdInterfaceMap::m_MngStdItfMap;


//
// Defines used ManagedStdInterfaceMap class implementation.
//

// Use this macro to define an entry in the managed standard interface map.
#define STD_INTERFACE_MAP_ENTRY(TypeName, NativeIID)                                    \
    if (!m_TypeNameToNativeIIDMap.InsertValue((TypeName), (void*)&(NativeIID), TRUE))       \
        _ASSERTE(!"Error inserting an entry in the managed standard interface map")     


//
// Defines used StdMngItfBase class implementation.
//

// The GetInstance method name and signature.
#define GET_INSTANCE_METH_NAME  "GetInstance" 
#define GET_INSTANCE_METH_SIG   &gsig_SM_Str_RetICustomMarshaler

// The initial number of buckets in the managed standard interface map.
#define INITIAL_NUM_BUCKETS     64


//
// This method is used to build the managed standard interface map.
//

MngStdInterfaceMap::MngStdInterfaceMap()
{
    //
    // Initialize the hashtable.
    //

    m_TypeNameToNativeIIDMap.Init(INITIAL_NUM_BUCKETS,NULL,NULL);

    // 
    // Define the mapping for the managed standard interfaces.
    //

#define MNGSTDITF_BEGIN_INTERFACE(FriendlyName, strMngItfName, strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, NativeItfIID, bCanCastOnNativeItfQI) \
    STD_INTERFACE_MAP_ENTRY(strMngItfName, bCanCastOnNativeItfQI ? NativeItfIID : GUID_NULL);

#define MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, ECallMethName, MethName, MethSig)

#define MNGSTDITF_END_INTERFACE(FriendlyName) 

#include "MngStdItfList.h"

#undef MNGSTDITF_BEGIN_INTERFACE
#undef MNGSTDITF_DEFINE_METH_IMPL
#undef MNGSTDITF_END_INTERFACE
}


//
// Helper method to load the types used inside the classes that implement the ECall's for 
// the managed standard interfaces.
//

void MngStdItfBase::InitHelper(
                    LPCUTF8 strUComItfTypeName, 
                    LPCUTF8 strCMTypeName, 
                    LPCUTF8 strCookie, 
                    LPCUTF8 strMngViewTypeName, 
                    TypeHandle *pUComItfType, 
                    TypeHandle *pCustomMarshalerType, 
                    TypeHandle *pManagedViewType, 
                    OBJECTHANDLE *phndMarshaler)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
    {
        // Load the UCom type.
        NameHandle typeName(strUComItfTypeName);
        *pUComItfType = SystemDomain::SystemAssembly()->LookupTypeHandle(&typeName, &Throwable);
        if (pUComItfType->IsNull())
        {
            _ASSERTE(!"Couldn't load the UCOM interface!");
            COMPlusThrow(Throwable);
        }

        // Run the <clinit> for the UCom type.
        if (!pUComItfType->GetMethodTable()->CheckRunClassInit(&Throwable))
        {
            _ASSERTE(!"Couldn't run the <clinit> for the UCOM class!");
            COMPlusThrow(Throwable);
        }

        // Retrieve the custom marshaler type handle.
        *pCustomMarshalerType = SystemDomain::GetCurrentDomain()->FindAssemblyQualifiedTypeHandle(strCMTypeName, false, NULL, NULL, &Throwable);

        // Make sure the class has been loaded properly.
        if (pCustomMarshalerType->IsNull())
        {
            _ASSERTE(!"Couldn't load the custom marshaler class!");
            COMPlusThrow(Throwable);
        }

        // Run the <clinit> for the marshaller.
        if (!pCustomMarshalerType->GetMethodTable()->CheckRunClassInit(&Throwable))
        {
            _ASSERTE(!"Couldn't run the <clinit> for the custom marshaler class!");
            COMPlusThrow(Throwable);
        }

        // Load the managed view.
        *pManagedViewType = SystemDomain::GetCurrentDomain()->FindAssemblyQualifiedTypeHandle(strMngViewTypeName, false, NULL, NULL, &Throwable);
        if (pManagedViewType->IsNull())
        {
            _ASSERTE(!"Couldn't load the managed view class!");
            COMPlusThrow(Throwable);
        }

        // Run the <clinit> for the managed view.
        if (!pManagedViewType->GetMethodTable()->CheckRunClassInit(&Throwable))
        {
            _ASSERTE(!"Couldn't run the <clinit> for the managed view class!");
            COMPlusThrow(Throwable);
        }
    }
    GCPROTECT_END();

    // Retrieve the GetInstance method.
    MethodDesc *pGetInstanceMD = pCustomMarshalerType->GetClass()->FindMethod(GET_INSTANCE_METH_NAME, GET_INSTANCE_METH_SIG);
    _ASSERTE(pGetInstanceMD && "Unable to find specified custom marshaler method");

    // Allocate the string object that will be passed to the GetInstance method.
    STRINGREF strObj = COMString::NewString(strCookie);
    GCPROTECT_BEGIN(strObj);
    {
        // Prepare the arguments that will be passed to GetInstance.
        INT64 GetInstanceArgs[] = { 
            ObjToInt64(strObj)
        };

        // Call the static GetInstance method to retrieve the custom marshaler to use.
        OBJECTREF Marshaler = Int64ToObj(pGetInstanceMD->Call(GetInstanceArgs));

        // Cache the handle to the marshaler for faster access.
        (*phndMarshaler) = SystemDomain::GetCurrentDomain()->CreateHandle(Marshaler);
    }
    GCPROTECT_END();
}


//
// Helper method that forwards the calls to either the managed view or to the native component if it
// implements the managed interface.
//

LPVOID MngStdItfBase::ForwardCallToManagedView(
                    OBJECTHANDLE hndMarshaler, 
                    MethodDesc *pUComItfMD, 
                    MethodDesc *pMarshalNativeToManagedMD, 
                    MethodDesc *pMngViewMD, 
                    IID *pMngItfIID, 
                    IID *pNativeItfIID, 
                    LPVOID pArgs)
{
    INT64 Result = 0;
    ULONG cbRef;
    HRESULT hr;
    IUnknown *pUnk;
    IUnknown *pMngItf;
    IUnknown *pNativeItf;
    OBJECTREF ManagedView;
    BOOL      RetValIsProtected = FALSE;
    struct LocalGcRefs {
        OBJECTREF   Obj;
        OBJECTREF   Result;
    } Lr;
    
    // Retrieve the object that the IExpando call was made on.
    Lr.Obj = ObjectToOBJECTREF(*(Object**)pArgs);
    Lr.Result = NULL;
    GCPROTECT_BEGIN(Lr);
    {
        _ASSERTE(Lr.Obj != NULL);
        _ASSERTE(Lr.Obj->GetMethodTable()->IsComObjectType());

        // We are about to call out to ummanaged code so we need to make a security check.
        COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_UNMANAGED_CODE);

        // Get the IUnknown on the current thread.
        pUnk = ((COMOBJECTREF)Lr.Obj)->GetWrapper()->GetIUnknown();
        _ASSERTE(pUnk);

        EE_TRY_FOR_FINALLY
        {
            // Check to see if the component implements the interface natively.
            hr = SafeQueryInterface(pUnk, *pMngItfIID, &pMngItf);
            LogInteropQI(pUnk, *pMngItfIID, hr, "Custom marshaler fwd call QI for managed interface");
            if (SUCCEEDED(hr))
            {
                // Release our ref-count on the managed interface.
                cbRef = SafeRelease(pMngItf);
                LogInteropRelease(pMngItf, cbRef, "Custom marshaler call releasing managed interface");

                // The component implements the interface natively so we need to dispatch to it directly.
                MetaSig CallMS = MetaSig(pUComItfMD->GetSig(), pUComItfMD->GetModule());
                Result = pUComItfMD->CallOnInterface((BYTE *)pArgs, &CallMS);
                if (CallMS.IsObjectRefReturnType()) {
                    Lr.Result = ObjectToOBJECTREF(*(Object **) &Result);
                    RetValIsProtected = TRUE;
                }
            }
            else
            {
                // QI for the native interface that will be passed to MarshalNativeToManaged.
                hr = SafeQueryInterface(pUnk, *pNativeItfIID, (IUnknown**)&pNativeItf);
                LogInteropQI(pUnk, *pNativeItfIID, hr, "Custom marshaler call QI for native interface");
                _ASSERTE(SUCCEEDED(hr));

                // Prepare the arguments that will be passed to GetInstance.
                INT64 MarshalNativeToManagedArgs[] = { 
                    ObjToInt64(ObjectFromHandle(hndMarshaler)),
                    (INT64)pNativeItf
                };

                // Retrieve the managed view for the current native interface pointer.
                ManagedView = Int64ToObj(pMarshalNativeToManagedMD->Call(MarshalNativeToManagedArgs));
                GCPROTECT_BEGIN(ManagedView);
                {
                    // Release our ref-count on pNativeItf.
                    cbRef = SafeRelease(pNativeItf);
                    LogInteropRelease(pNativeItf, cbRef, "Custom marshaler fwd call releasing native interface");

                    // Replace the this in pArgs by the this of the managed view.
                    (*(Object**)pArgs) = OBJECTREFToObject(ManagedView);

                    // Do the actual call to the method in the managed view passing in the args.
                    MetaSig CallMS = MetaSig(pMngViewMD->GetSig(), pMngViewMD->GetModule());
                    Result = pMngViewMD->Call((BYTE *)pArgs, &CallMS);
                    if (CallMS.IsObjectRefReturnType()) {
                        Lr.Result = ObjectToOBJECTREF(*(Object **) &Result);
                        RetValIsProtected = TRUE;
                    }

                }
                GCPROTECT_END();
            }
        }
        EE_FINALLY
        {
            // Release our ref-count on pUnk.
            // !!! SafeRelease will cause a GC !!!
            cbRef = SafeRelease(pUnk);
            LogInteropRelease(pUnk, cbRef, "Custom marshaler fwd call releasing IUnknown");
        }
        EE_END_FINALLY;
    }
    GCPROTECT_END();

    if (RetValIsProtected)
        Result = (INT64) OBJECTREFToObject(Lr.Result);

    return (void*)Result;
}


#define MNGSTDITF_BEGIN_INTERFACE(FriendlyName, strMngItfName, strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, NativeItfIID, bCanCastOnNativeItfQI) \

#define MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, ECallMethName, MethName, MethSig) \
\
    LPVOID __stdcall FriendlyName::ECallMethName(struct ECallMethName##Args *pArgs) \
    { \
        FriendlyName *pMngStdItfInfo = SystemDomain::GetCurrentDomain()->GetMngStdInterfacesInfo()->Get##FriendlyName(); \
        return ForwardCallToManagedView( \
            pMngStdItfInfo->m_hndCustomMarshaler, \
            pMngStdItfInfo->GetUComItfMD(FriendlyName##Methods_##ECallMethName, #MethName, MethSig), \
            pMngStdItfInfo->GetCustomMarshalerMD(CustomMarshalerMethods_MarshalNativeToManaged), \
            pMngStdItfInfo->GetManagedViewMD(FriendlyName##Methods_##ECallMethName, #MethName, MethSig), \
            &pMngStdItfInfo->m_MngItfIID, \
            &pMngStdItfInfo->m_NativeItfIID, \
            pArgs); \
    }

#define MNGSTDITF_END_INTERFACE(FriendlyName)


#include "MngStdItfList.h"


#undef MNGSTDITF_BEGIN_INTERFACE
#undef MNGSTDITF_DEFINE_METH_IMPL
#undef MNGSTDITF_END_INTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mngstditflist.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  MngStdItfList.h
**
**
** Purpose: This file contains the list of managed standard
**          interfaces. Each standard interface also has the
**          list of method that it contains.
** 
===========================================================*/

//
// Include files.
//

#include "__file__.ver"


//
// Helper macros
//

#define MNGSTDITF_DEFINE_METH(FriendlyName, MethName, MethSig) \
    MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, MethName, MethName, MethSig)

#define MNGSTDITF_DEFINE_METH2(FriendlyName, MethName, MethSig) \
    MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, MethName##_2, MethName, MethSig)

#define MNGSTDITF_DEFINE_METH3(FriendlyName, MethName, MethSig) \
    MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, MethName##_3, MethName, MethSig)
        
#define CUSTOM_MARSHALER_ASM ", CustomMarshalers, Version=" VER_ASSEMBLYVERSION_STR_NO_NULL ", Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"




//
// MNGSTDITF_BEGIN_INTERFACE(FriendlyName, strMngItfName, strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, NativeItfIID) \
//
// This macro defines a new managed standard interface.
//
// FriendlyName             Friendly name for the class that implements the ECall's.
// idMngItf                 BinderClassID of the managed interface.
// idUCOMMngItf             BinderClassID of the UCom version of the managed interface.
// idCustomMarshaler        BinderClassID of the custom marshaler.
// idGetInstMethod          BinderMethodID of the GetInstance method of the custom marshaler.
// strCustomMarshalerCookie String containing the cookie to be passed to the custom marshaler.
// strManagedViewName       String containing the name of the managed view of the native interface.
// NativeItfIID             IID of the native interface.
// bCanCastOnNativeItfQI    If this is true casting to a COM object that supports the native interface
//                          will cause the cast to succeed.
//

//
// MNGSTDITF_DEFINE_METH(FriendlyName, MethName, MethSig)
//
// This macro defines a method of the standard managed interface.
// MNGSTDITF_DEFINE_METH2 and MNGSTDITF_DEFINE_METH3 are used to
// define overloaded versions of the method.
//
// FriendlyName             Friendly name for the class that implements the ECall's.
// MethName                 This is the method name
// MethSig                  This is the method signature.
//


//
// IReflect
//

MNGSTDITF_BEGIN_INTERFACE(StdMngIReflect, "System.Reflection.IReflect", "System.Runtime.InteropServices.UCOMIReflect", "System.Runtime.InteropServices.CustomMarshalers.ExpandoToDispatchExMarshaler" CUSTOM_MARSHALER_ASM, "IReflect", "System.Runtime.InteropServices.CustomMarshalers.ExpandoViewOfDispatchEx" CUSTOM_MARSHALER_ASM, IID_IDispatchEx, TRUE)
    MNGSTDITF_DEFINE_METH(StdMngIReflect, GetMethod, &gsig_IM_Str_BindingFlags_Binder_ArrType_ArrParameterModifier_RetMethodInfo)
    MNGSTDITF_DEFINE_METH2(StdMngIReflect, GetMethod, &gsig_IM_Str_BindingFlags_RetMethodInfo)
    MNGSTDITF_DEFINE_METH(StdMngIReflect, GetMethods, &gsig_IM_BindingFlags_RetArrMethodInfo)
    MNGSTDITF_DEFINE_METH(StdMngIReflect, GetField, &gsig_IM_Str_BindingFlags_RetFieldInfo)
    MNGSTDITF_DEFINE_METH(StdMngIReflect, GetFields, &gsig_IM_BindingFlags_RetArrFieldInfo)
    MNGSTDITF_DEFINE_METH(StdMngIReflect, GetProperty, &gsig_IM_Str_BindingFlags_Binder_RetType_ArrType_ArrParameterModifier_RetPropertyInfo)
    MNGSTDITF_DEFINE_METH2(StdMngIReflect, GetProperty, &gsig_IM_Str_BindingFlags_RetPropertyInfo)
    MNGSTDITF_DEFINE_METH(StdMngIReflect, GetProperties, &gsig_IM_BindingFlags_RetArrPropertyInfo)
    MNGSTDITF_DEFINE_METH(StdMngIReflect, GetMember, &gsig_IM_Str_BindingFlags_RetMemberInfo)
    MNGSTDITF_DEFINE_METH(StdMngIReflect, GetMembers, &gsig_IM_BindingFlags_RetArrMemberInfo)
    MNGSTDITF_DEFINE_METH(StdMngIReflect, InvokeMember, &gsig_IM_Str_BindingFlags_Binder_Obj_ArrObj_ArrParameterModifier_CultureInfo_ArrStr_RetObj)
    MNGSTDITF_DEFINE_METH(StdMngIReflect, get_UnderlyingSystemType, &gsig_IM_RetType)
MNGSTDITF_END_INTERFACE(StdMngIReflect)


//
// IExpando
//

MNGSTDITF_BEGIN_INTERFACE(StdMngIExpando, "System.Runtime.InteropServices.Expando.IExpando", "System.Runtime.InteropServices.UCOMIExpando", "System.Runtime.InteropServices.CustomMarshalers.ExpandoToDispatchExMarshaler" CUSTOM_MARSHALER_ASM, "IExpando", "System.Runtime.InteropServices.CustomMarshalers.ExpandoViewOfDispatchEx" CUSTOM_MARSHALER_ASM, IID_IDispatchEx, TRUE)
    MNGSTDITF_DEFINE_METH(StdMngIExpando, AddField, &gsig_IM_Str_RetFieldInfo)
    MNGSTDITF_DEFINE_METH(StdMngIExpando, AddProperty, &gsig_IM_Str_RetPropertyInfo)
    MNGSTDITF_DEFINE_METH(StdMngIExpando, AddMethod, &gsig_IM_Str_Delegate_RetMethodInfo)
    MNGSTDITF_DEFINE_METH(StdMngIExpando, RemoveMember, &gsig_IM_MemberInfo_RetVoid)
MNGSTDITF_END_INTERFACE(StdMngIExpando)

//
// IEnumerator
//

#define OLD_GETOBJECT GetObject
#undef GetObject

MNGSTDITF_BEGIN_INTERFACE(StdMngIEnumerator, "System.Collections.IEnumerator", "System.Runtime.InteropServices.UCOMIEnumerator", "System.Runtime.InteropServices.CustomMarshalers.EnumeratorToEnumVariantMarshaler" CUSTOM_MARSHALER_ASM, "", "System.Runtime.InteropServices.CustomMarshalers.EnumeratorViewOfEnumVariant" CUSTOM_MARSHALER_ASM, IID_IEnumVARIANT, TRUE)
    MNGSTDITF_DEFINE_METH(StdMngIEnumerator, MoveNext, &gsig_IM_RetBool)
    MNGSTDITF_DEFINE_METH(StdMngIEnumerator, get_Current, &gsig_IM_RetObj)
    MNGSTDITF_DEFINE_METH(StdMngIEnumerator, Reset, &gsig_IM_RetVoid)
MNGSTDITF_END_INTERFACE(StdMngIEnumerator)

#define GetObject OLD_GETOBJECT


//
// IEnumerable
//

MNGSTDITF_BEGIN_INTERFACE(StdMngIEnumerable, "System.Collections.IEnumerable", "System.Runtime.InteropServices.UCOMIEnumerable", "System.Runtime.InteropServices.CustomMarshalers.EnumerableToDispatchMarshaler" CUSTOM_MARSHALER_ASM, "", "System.Runtime.InteropServices.CustomMarshalers.EnumerableViewOfDispatch" CUSTOM_MARSHALER_ASM, IID_IDispatch, FALSE)
    MNGSTDITF_DEFINE_METH(StdMngIEnumerable, GetEnumerator, &gsig_IM_RetIEnumerator)
MNGSTDITF_END_INTERFACE(StdMngIEnumerable)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mngstdinterfaces.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMPlusWrapper.h
**
**
** Purpose: Contains types and method signatures for the Com wrapper class
**
** 
===========================================================*/

#ifndef _MNGSTDINTERFACEMAP_H
#define _MNGSTDINTERFACEMAP_H

#include "vars.hpp"
#include "eehash.h"
#include "class.h"
#include "mlinfo.h"


//
// This class is used to establish a mapping between a managed standard interface and its
// unmanaged counterpart.
//

class MngStdInterfaceMap
{
public:
    // This method retrieves the native IID of the interface that the specified
    // managed type is a standard interface for. If the specified type is not
    // a standard interface then GUIDNULL is returned.
    inline static IID* GetNativeIIDForType(TypeHandle *pType)
    {
    HashDatum Data;
    LPCUTF8 strTypeName;

    // Retrieve the name of the type.
    DefineFullyQualifiedNameForClass();
    strTypeName = GetFullyQualifiedNameForClass(pType->GetClass());

    if (m_MngStdItfMap.m_TypeNameToNativeIIDMap.GetValue(strTypeName, &Data) && (*((GUID*)Data) != GUID_NULL))
    {
        // The type is a standard interface.
        return (IID*)Data;
    }
    else
    {
        // The type is not a standard interface.
        return NULL;
    }
    }

    // This function will free the memory allocated by the structure
    // (This happens normally from the destructors, but we need to expediate
    // the process so our memory leak detection tools work)
#ifdef SHOULD_WE_CLEANUP
    static void FreeMemory()
    {
        m_MngStdItfMap.m_TypeNameToNativeIIDMap.ClearHashTable();
    }
#endif /* SHOULD_WE_CLEANUP */


private:
    // Disalow creation of this class by anybody outside of it.
    MngStdInterfaceMap();

    // The map of type names to native IID's.
    EEUtf8StringHashTable m_TypeNameToNativeIIDMap;

    // The one and only instance of the managed std interface map.
    static MngStdInterfaceMap m_MngStdItfMap;
};


//
// Base class for all the classes that contain the ECall's for the managed standard interfaces.
//

class MngStdItfBase
{
protected:
    static void InitHelper(
                    LPCUTF8 strUComItfTypeName, 
                    LPCUTF8 strCMTypeName, 
                    LPCUTF8 strCookie, 
                    LPCUTF8 strManagedViewName, 
                    TypeHandle *pUComItfType, 
                    TypeHandle *pCustomMarshalerType, 
                    TypeHandle *pManagedViewType, 
                    OBJECTHANDLE *phndMarshaler);

    static LPVOID ForwardCallToManagedView(
                    OBJECTHANDLE hndMarshaler, 
                    MethodDesc *pUComItfMD, 
                    MethodDesc *pMarshalNativeToManagedMD, 
                    MethodDesc *pMngViewMD, 
                    IID *pMngItfIID, 
                    IID *pNativeItfIID, 
                    LPVOID pArgs);
};


//
// Define the enum of methods on the managed standard interface.
//

#define MNGSTDITF_BEGIN_INTERFACE(FriendlyName, strMngItfName, strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, NativeItfIID, bCanCastOnNativeItfQI) \
\
enum FriendlyName##Methods \
{  \
    FriendlyName##Methods_Dummy = -1,


#define MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, ECallMethName, MethName, MethSig) \
    FriendlyName##Methods_##ECallMethName, 


#define MNGSTDITF_END_INTERFACE(FriendlyName) \
    FriendlyName##Methods_LastMember \
}; \


#include "MngStdItfList.h"


#undef MNGSTDITF_BEGIN_INTERFACE
#undef MNGSTDITF_DEFINE_METH_IMPL
#undef MNGSTDITF_END_INTERFACE


//
// Define the class that implements the ECall's for the managed standard interface.
//

#define MNGSTDITF_BEGIN_INTERFACE(FriendlyName, strMngItfName, strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, NativeItfIID, bCanCastOnNativeItfQI) \
\
class FriendlyName : public MngStdItfBase \
{ \
public: \
    FriendlyName() \
    { \
        InitHelper(strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, &m_UComItfType, &m_CustomMarshalerType, &m_ManagedViewType, &m_hndCustomMarshaler); \
        m_NativeItfIID = NativeItfIID; \
        m_UComItfType.GetClass()->GetGuid(&m_MngItfIID, TRUE); \
        memset(m_apCustomMarshalerMD, 0, CustomMarshalerMethods_LastMember * sizeof(MethodDesc *)); \
        memset(m_apManagedViewMD, 0, FriendlyName##Methods_LastMember * sizeof(MethodDesc *)); \
        memset(m_apUComItfMD, 0, FriendlyName##Methods_LastMember * sizeof(MethodDesc *)); \
    } \
\
    OBJECTREF GetCustomMarshaler() \
    { \
        return ObjectFromHandle(m_hndCustomMarshaler); \
    } \
\
    MethodDesc* GetCustomMarshalerMD(EnumCustomMarshalerMethods Method) \
    { \
        MethodDesc *pMD = NULL; \
        \
        if (m_apCustomMarshalerMD[Method]) \
            return m_apCustomMarshalerMD[Method]; \
        \
        pMD = CustomMarshalerInfo::GetCustomMarshalerMD(Method, m_CustomMarshalerType); \
        _ASSERTE(pMD && "Unable to find specified method on the custom marshaler"); \
        MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule()); \
        \
        m_apCustomMarshalerMD[Method] = pMD; \
        return pMD; \
    } \
\
    MethodDesc* GetManagedViewMD(FriendlyName##Methods Method, LPCUTF8 strMethName, LPHARDCODEDMETASIG pSig) \
    { \
        MethodDesc *pMD = NULL; \
        \
        if (m_apManagedViewMD[Method]) \
            return m_apManagedViewMD[Method]; \
        \
        pMD = m_ManagedViewType.GetClass()->FindMethod(strMethName, pSig); \
        _ASSERTE(pMD && "Unable to find specified method on the managed view"); \
        MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule()); \
        \
        m_apManagedViewMD[Method] = pMD; \
        return pMD; \
    } \
\
    MethodDesc* GetUComItfMD(FriendlyName##Methods Method, LPCUTF8 strMethName, LPHARDCODEDMETASIG pSig) \
    { \
        MethodDesc *pMD = NULL; \
        \
        if (m_apUComItfMD[Method]) \
            return m_apUComItfMD[Method]; \
        \
        pMD = m_UComItfType.GetClass()->FindMethod(strMethName, pSig); \
        _ASSERTE(pMD && "Unable to find specified method in UCom interface"); \
        MetaSig::EnsureSigValueTypesLoaded(pMD->GetSig(), pMD->GetModule()); \
        \
        m_apUComItfMD[Method] = pMD; \
        return pMD; \
    } \
    \
private: \
    MethodDesc*     m_apCustomMarshalerMD[CustomMarshalerMethods_LastMember]; \
    MethodDesc*     m_apManagedViewMD[FriendlyName##Methods_LastMember]; \
    MethodDesc*     m_apUComItfMD[FriendlyName##Methods_LastMember]; \
    TypeHandle      m_CustomMarshalerType; \
    TypeHandle      m_ManagedViewType; \
    TypeHandle      m_UComItfType; \
    OBJECTHANDLE    m_hndCustomMarshaler; \
    GUID            m_MngItfIID; \
    GUID            m_NativeItfIID; \
\

#define MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, ECallMethName, MethName, MethSig) \
\
public: \
    static LPVOID __stdcall ECallMethName(struct ECallMethName##Args *pArgs); \
\

#define MNGSTDITF_END_INTERFACE(FriendlyName) \
}; \
\


#include "MngStdItfList.h"


#undef MNGSTDITF_BEGIN_INTERFACE
#undef MNGSTDITF_DEFINE_METH_IMPL
#undef MNGSTDITF_END_INTERFACE


//
// App domain level information on the managed standard interfaces .
//

class MngStdInterfacesInfo
{
public:
    // Constructor and destructor.
    MngStdInterfacesInfo()
    : m_lock("Interop", CrstInterop, FALSE, FALSE)
    {
#define MNGSTDITF_BEGIN_INTERFACE(FriendlyName, strMngItfName, strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, NativeItfIID, bCanCastOnNativeItfQI) \
\
        m_p##FriendlyName = 0; \
\

#define MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, ECallMethName, MethName, MethSig)
#define MNGSTDITF_END_INTERFACE(FriendlyName)


#include "MngStdItfList.h"


#undef MNGSTDITF_BEGIN_INTERFACE
#undef MNGSTDITF_DEFINE_METH_IMPL
#undef MNGSTDITF_END_INTERFACE
    }

    ~MngStdInterfacesInfo()
    {
#define MNGSTDITF_BEGIN_INTERFACE(FriendlyName, strMngItfName, strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, NativeItfIID, bCanCastOnNativeItfQI) \
\
        if (m_p##FriendlyName) \
            delete m_p##FriendlyName; \
\

#define MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, ECallMethName, MethName, MethSig)
#define MNGSTDITF_END_INTERFACE(FriendlyName)


#include "MngStdItfList.h"


#undef MNGSTDITF_BEGIN_INTERFACE
#undef MNGSTDITF_DEFINE_METH_IMPL
#undef MNGSTDITF_END_INTERFACE
    }


    // Accessors for each of the managed standard interfaces.
#define MNGSTDITF_BEGIN_INTERFACE(FriendlyName, strMngItfName, strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, NativeItfIID, bCanCastOnNativeItfQI) \
\
public: \
    FriendlyName *Get##FriendlyName() \
    { \
        if (!m_p##FriendlyName) \
        { \
            EnterLock(); \
            if (!m_p##FriendlyName) \
            { \
                m_p##FriendlyName = new FriendlyName(); \
            } \
            LeaveLock(); \
        } \
        return m_p##FriendlyName; \
    } \
\
private: \
    FriendlyName *m_p##FriendlyName; \
\

#define MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, ECallMethName, MethName, MethSig)
#define MNGSTDITF_END_INTERFACE(FriendlyName)


#include "MngStdItfList.h"


#undef MNGSTDITF_BEGIN_INTERFACE
#undef MNGSTDITF_DEFINE_METH_IMPL
#undef MNGSTDITF_END_INTERFACE

private:
    void EnterLock()
    {
        // Try to enter the lock.
        BEGIN_ENSURE_PREEMPTIVE_GC()
        m_lock.Enter();
        END_ENSURE_PREEMPTIVE_GC()
    }

    void LeaveLock()
    {
        // Simply leave the lock.
        m_lock.Leave();
    }

    Crst m_lock;
};

#endif  _MNGSTDINTERFACEMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mlinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "ml.h"
#include "mlgen.h"
#include "CustomMarshalerInfo.h"

#ifndef _MLINFO_H_
#define _MLINFO_H_

//==========================================================================
// This structure contains the native type information for a given 
// parameter.
//==========================================================================
#define NATIVE_TYPE_DEFAULT NATIVE_TYPE_MAX

struct NativeTypeParamInfo
{
    NativeTypeParamInfo()
    : m_NativeType(NATIVE_TYPE_DEFAULT)
    , m_SafeArrayElementVT(VT_EMPTY)
    , m_strSafeArrayUserDefTypeName(NULL)
    , m_cSafeArrayUserDefTypeNameBytes(0)
    , m_ArrayElementType(NATIVE_TYPE_DEFAULT)
    , m_SizeIsSpecified(FALSE)
    , m_CountParamIdx(0)
    , m_Multiplier(0)
    , m_Additive(1)
    , m_strCMMarshalerTypeName(NULL) 
    , m_cCMMarshalerTypeNameBytes(0)
    , m_strCMCookie(NULL)
    , m_cCMCookieStrBytes(0)
    {
    }   

    // The native type of the parameter.
    CorNativeType           m_NativeType;

    // For NT_SAFEARRAY only.
    VARTYPE                 m_SafeArrayElementVT;
    LPUTF8                  m_strSafeArrayUserDefTypeName;
    DWORD                   m_cSafeArrayUserDefTypeNameBytes;

    // for NT_ARRAY only
    CorNativeType           m_ArrayElementType; // The array element type.

    BOOL                    m_SizeIsSpecified;  // used to do some validation
    UINT16                  m_CountParamIdx;    // index of "sizeis" parameter
    UINT32                  m_Multiplier;       // multipler for "sizeis"
    UINT32                  m_Additive;         // additive for 'sizeis"

    // For NT_CUSTOMMARSHALER only.
    LPUTF8                  m_strCMMarshalerTypeName;
    DWORD                   m_cCMMarshalerTypeNameBytes;
    LPUTF8                  m_strCMCookie;
    DWORD                   m_cCMCookieStrBytes;
};


HRESULT CheckForCompressedData(PCCOR_SIGNATURE pvNativeTypeStart, PCCOR_SIGNATURE pvNativeType, ULONG cbNativeType);


BOOL ParseNativeTypeInfo(mdToken                    token,
                         Module*                    pModule,
                         NativeTypeParamInfo*       pParamInfo
                         );


class DataImage;
class DispParamMarshaler;

#define VARIABLESIZE ((BYTE)(-1))


enum DispatchWrapperType
{
    DispatchWrapperType_Unknown         = 0x00000001,
    DispatchWrapperType_Dispatch        = 0x00000002,
    DispatchWrapperType_Error           = 0x00000008,
    DispatchWrapperType_Currency        = 0x00000010,
    DispatchWrapperType_SafeArray       = 0x00010000
};


union MLOverrideArgs
{
    UINT8           m_arrayMarshalerID;
    UINT16          m_blittablenativesize;
    MethodTable    *m_pMT;
    class MarshalInfo *m_pMLInfo;
    struct {
        VARTYPE         m_vt;
        MethodTable    *m_pMT;
        UINT16          m_optionalbaseoffset; //for fast marshaling, offset of dataptr if known and less than 64k (0 otherwise)
    } na;

    struct {
        MethodTable *m_pMT;
        MethodDesc  *m_pCopyCtor;
        MethodDesc  *m_pDtor;
    } mm;
};


class OleColorMarshalingInfo
{
public:
    // Constructor.
    OleColorMarshalingInfo();

    // OleColorMarshalingInfo's are always allocated on the loader heap so we need to redefine
    // the new and delete operators to ensure this.
    void *operator new(size_t size, LoaderHeap *pHeap);
    void operator delete(void *pMem);

    // Accessors.
    TypeHandle GetColorTranslatorType() { return m_hndColorTranslatorType; }
    TypeHandle GetColorType() { return m_hndColorType; }
    MethodDesc *GetOleColorToSystemColorMD() { return m_OleColorToSystemColorMD; }
    MethodDesc *GetSystemColorToOleColorMD() { return m_SystemColorToOleColorMD; }

private:
    TypeHandle m_hndColorTranslatorType;
    TypeHandle m_hndColorType;
    MethodDesc *m_OleColorToSystemColorMD;
    MethodDesc *m_SystemColorToOleColorMD;
};


class EEMarshalingData
{
public:
    EEMarshalingData(BaseDomain *pDomain, LoaderHeap *pHeap, Crst *pCrst);
    ~EEMarshalingData();

    // EEMarshalingData's are always allocated on the loader heap so we need to redefine
    // the new and delete operators to ensure this.
    void *operator new(size_t size, LoaderHeap *pHeap);
    void operator delete(void *pMem);

    // This method returns the custom marshaling helper associated with the name cookie pair. If the 
    // CM info has not been created yet for this pair then it will be created and returned.
    CustomMarshalerHelper *GetCustomMarshalerHelper(Assembly *pAssembly, TypeHandle hndManagedType, LPCUTF8 strMarshalerTypeName, DWORD cMarshalerTypeNameBytes, LPCUTF8 strCookie, DWORD cCookieStrBytes);

    // This method returns the custom marshaling info associated with shared CM helper.
    CustomMarshalerInfo *GetCustomMarshalerInfo(SharedCustomMarshalerHelper *pSharedCMHelper);

    // This method retrieves OLE_COLOR marshaling info.
    OleColorMarshalingInfo *GetOleColorMarshalingInfo();

private:
    EECMHelperHashTable                 m_CMHelperHashtable;
    EEPtrHashTable                      m_SharedCMHelperToCMInfoMap;
    LoaderHeap *                        m_pHeap;
    BaseDomain *                        m_pDomain;
    CMINFOLIST                          m_pCMInfoList;
    OleColorMarshalingInfo *            m_pOleColorInfo;
};


class MarshalInfo
{
  public:

    enum MarshalType
    {

#define DEFINE_MARSHALER_TYPE(mtype, mclass) mtype,
#include "mtypes.h"

        MARSHAL_TYPE_UNKNOWN
    };

    enum MarshalScenario
    {
        MARSHAL_SCENARIO_NDIRECT,
        MARSHAL_SCENARIO_COMINTEROP
    };

    void *operator new(size_t size, void *pInPlace)
    {
        return pInPlace;
    }

    MarshalInfo() {}


    MarshalInfo(Module* pModule,
                SigPointer sig,
                mdToken token,
                MarshalScenario ms,
                BYTE nlType,
                BYTE nlFlags,
                BOOL isParam,
                UINT paramidx,    // parameter # for use in error messages (ignored if not parameter)
                BOOL BestFit,
                BOOL ThrowOnUnmappableChar

#ifdef CUSTOMER_CHECKED_BUILD
                ,
                MethodDesc* pMD = NULL
#endif
#ifdef _DEBUG
                ,
                LPCUTF8 pDebugName = NULL,
                LPCUTF8 pDebugClassName = NULL,
                LPCUTF8 pDebugNameSpace = NULL,
                UINT    argidx = 0  // 0 for return value, -1 for field
#endif

                );

    // These methods retrieve the information for different element types.
    HRESULT HandleArrayElemType(char *achDbgContext, 
                                NativeTypeParamInfo *pParamInfo, 
                                UINT16 optbaseoffset, 
                                TypeHandle elemTypeHnd, 
                                int iRank, 
                                BOOL fNoLowerBounds, 
                                BOOL isParam, 
                                BOOL isSysArray, 
                                Assembly *pAssembly);

    void GenerateArgumentML(MLStubLinker *psl,
                            MLStubLinker *pslPost,
                            BOOL comToNative);
    void GenerateReturnML(MLStubLinker *psl,
                          MLStubLinker *pslPost,
                          BOOL comToNative,
                          BOOL retval);
    void GenerateSetterML(MLStubLinker *psl,
                          MLStubLinker *pslPost);
    void GenerateGetterML(MLStubLinker *psl,
                          MLStubLinker *pslPost,
                          BOOL retval);
    UINT16 EmitCreateOpcode(MLStubLinker *psl);

    UINT16 GetComArgSize() { return m_comArgSize; }
    UINT16 GetNativeArgSize() { return m_nativeArgSize; }

    UINT16 GetNativeSize() { return nativeSize(m_type); }
    MarshalType GetMarshalType() { return m_type; }

    BYTE    GetBestFitMapping() { return ((m_BestFit == 0) ? 0 : 1); }
    BYTE    GetThrowOnUnmappableChar() { return ((m_ThrowOnUnmappableChar == 0) ? 0 : 1); }

    BOOL   IsFpu()
    {
        return m_type == MARSHAL_TYPE_FLOAT || m_type == MARSHAL_TYPE_DOUBLE;
    }

    BOOL   IsIn()
    {
        return m_in;
    }

    BOOL   IsOut()
    {
        return m_out;
    }

    BOOL   IsByRef()
    {
        return m_byref;
    }

    DispParamMarshaler *GenerateDispParamMarshaler();

    DispatchWrapperType GetDispWrapperType();

  private:

    void GetItfMarshalInfo(MethodTable **ppItfMT, MethodTable **ppClassMT, BOOL *pfDispItf, BOOL *pbClassIsHint);


    MarshalType     m_type;
    BOOL            m_byref;
    BOOL            m_in;
    BOOL            m_out;
    EEClass         *m_pClass;  // Used if this is a true class
    TypeHandle      m_hndArrayElemType;
    VARTYPE         m_arrayElementType;
    int             m_iArrayRank;
    BOOL            m_nolowerbounds;  // if managed type is SZARRAY, don't allow lower bounds

    // for NT_ARRAY only
    UINT16          m_countParamIdx;  // index of "sizeis" parameter
    UINT32          m_multiplier;     // multipler for "sizeis"
    UINT32          m_additive;       // additive for 'sizeis"

    UINT16          m_nativeArgSize;
    UINT16          m_comArgSize;

    MarshalScenario m_ms;
    BYTE            m_nlType;
    BYTE            m_nlFlags;
    BOOL            m_fAnsi;
    BOOL            m_fDispIntf;
    BOOL            m_fErrorNativeType;

    // Information used by NT_CUSTOMMARSHALER.
    CustomMarshalerHelper *m_pCMHelper;
    VARTYPE         m_CMVt;

    MLOverrideArgs  m_args;

    static BYTE     m_localSizes[];


    //static BYTE     m_comSizes[];
    //static BYTE     m_nativeSizes[];
    UINT16          comSize(MarshalType mtype);
    UINT16          nativeSize(MarshalType mtype);

    UINT            m_paramidx;
    UINT            m_resID;     // resource ID for error message (if any)

#if defined(_DEBUG)
     LPCUTF8        m_strDebugMethName;
     LPCUTF8        m_strDebugClassName;
     LPCUTF8        m_strDebugNameSpace;
     UINT           m_iArg;  // 0 for return value, -1 for field
#endif

    static BYTE     m_returnsComByref[];
    static BYTE     m_returnsNativeByref[];
    static BYTE     m_unmarshalN2CNeeded[];
    static BYTE     m_unmarshalC2NNeeded[];
    static BYTE     m_comRepresentationIsImmutable[];





#ifdef _DEBUG
    VOID DumpMarshalInfo(Module* pModule, SigPointer sig, mdToken token, MarshalScenario ms, BYTE nlType, BYTE nlFlags);
#endif

#ifdef CUSTOMER_CHECKED_BUILD
    VOID OutputCustomerCheckedBuildMarshalInfo(MethodDesc* pMD, SigPointer sig, Module* pModule, CorElementType elemType, BOOL fSizeIsSpecified);
    VOID MarshalTypeToString(CQuickArray<WCHAR> *pStrMarshalType, BOOL fSizeIsSpecified);
    VOID VarTypeToString(VARTYPE vt, CQuickArray<WCHAR> *pStrVarType, BOOL fNativeArray);
#endif

    BOOL            m_BestFit;
    BOOL            m_ThrowOnUnmappableChar;
};

//===================================================================================
// Throws an exception indicating a param has invalid element type / native type
// information.
//===================================================================================
VOID ThrowInteropParamException(UINT resID, UINT paramIdx);

//===================================================================================
// Post-patches ML stubs for the sizeis feature.
//===================================================================================
VOID PatchMLStubForSizeIs(BYTE *pMLCode, UINT32 numArgs, MarshalInfo *pMLInfo);

//===================================================================================
// Support routines for storing ML stubs in prejit files
//===================================================================================
HRESULT StoreMLStub(MLHeader *pMLStub, DataImage *image, mdToken attribute);
HRESULT FixupMLStub(MLHeader *pMLStub, DataImage *image);
Stub *RestoreMLStub(MLHeader *pMLStub, Module *pModule);

VOID CollateParamTokens(IMDInternalImport *pInternalImport, mdMethodDef md, ULONG numargs, mdParamDef *aParams);

#endif // _MLINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\monitor.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: Monitor.cpp
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.Monitor
**
** Date:  January, 2000
** 
===========================================================*/

#include "common.h"
#include "object.h"
#include "excep.h"
#include "Monitor.h"

//******************************************************************************
//				Critical Section routines
//******************************************************************************
void __stdcall MonitorNative::Enter(EnterArgs *pArgs)
{
	_ASSERTE(pArgs);

	OBJECTREF pObj = pArgs->pObj;
    THROWSCOMPLUSEXCEPTION();

    if (pObj == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

    // Disallow value types as arguments, since they don't do what users might
    // expect (value types don't have stable identities, so they're hard to lock
    // against).
    if (pObj->GetMethodTable()->GetClass()->IsValueClass())
        COMPlusThrow(kArgumentException, L"Argument_StructMustNotBeValueClass");

    pObj->EnterObjMonitor();
}

void __stdcall MonitorNative::Exit(ExitArgs *pArgs)
{
	_ASSERTE(pArgs);

    THROWSCOMPLUSEXCEPTION();

    OBJECTREF pObj = pArgs->pObj;
    if (pObj == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

    // Disallow value types as arguments, since they don't do what users might
    // expect (value types don't have stable identities, so they're hard to lock
    // against).
    if (pObj->GetMethodTable()->GetClass()->IsValueClass())
        COMPlusThrow(kArgumentException, L"Argument_StructMustNotBeValueClass");


    // Better check that the object in question has a sync block and that we
    // currently own the critical section we're trying to leave.
    if (!pObj->HasSyncBlockIndex() ||
        !pObj->GetSyncBlock()->DoesCurrentThreadOwnMonitor())
        COMPlusThrow(kSynchronizationLockException);

    pObj->LeaveObjMonitor();
}

INT32/*bool*/ __stdcall MonitorNative::TryEnter(TryEnterArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF pObj = pArgs->pObj;

    if (pObj == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

    // Disallow value types as arguments, since they don't do what users might
    // expect (value types don't have stable identities, so they're hard to lock
    // against).
    if (pObj->GetMethodTable()->GetClass()->IsValueClass())
        COMPlusThrow(kArgumentException, L"Argument_StructMustNotBeValueClass");

    if ((pArgs->m_Timeout < 0) && (pArgs->m_Timeout != INFINITE_TIMEOUT))
        COMPlusThrow(kArgumentOutOfRangeException, L"ArgumentOutOfRange_NeedNonNegOrNegative1");


    return pObj->TryEnterObjMonitor(pArgs->m_Timeout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mlinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "ml.h"
#include "marshaler.h"
#include "mlinfo.h"
#include "olevariant.h"
#include "ndirect.h"
#include "commember.h"
#include "SigFormat.h"
#include "eeconfig.h"
#include "utilcode.h"
#include "eehash.h"
#include "ComCallWrapper.h"
#include "DispParamMarshaler.h"
#include "..\dlls\mscorrc\resource.h"
#include "dataimage.h"

#include "__file__.ver"

#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"

    BOOL CheckForPrimitiveType(CorElementType elemType, CQuickArray<WCHAR> *pStrPrimitiveType);
#endif

#ifndef lengthof
#define lengthof(rg)    (sizeof(rg)/sizeof(rg[0]))
#endif


#define INITIAL_NUM_CMHELPER_HASHTABLE_BUCKETS 32
#define INITIAL_NUM_CMINFO_HASHTABLE_BUCKETS 32
        
#define DEFINE_ASM_QUAL_TYPE_NAME(varname, typename, asmname, version)              static const char varname##[] = { typename##", "##asmname##", Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Version="##version };

DEFINE_ASM_QUAL_TYPE_NAME(ENUMERATOR_TO_ENUM_VARIANT_CM_NAME, g_EnumeratorToEnumClassName, "CustomMarshalers", VER_ASSEMBLYVERSION_STR);

static const int        ENUMERATOR_TO_ENUM_VARIANT_CM_NAME_LEN    = lengthof(ENUMERATOR_TO_ENUM_VARIANT_CM_NAME);

static const char       ENUMERATOR_TO_ENUM_VARIANT_CM_COOKIE[]    = {""};
static const int        ENUMERATOR_TO_ENUM_VARIANT_CM_COOKIE_LEN  = lengthof(ENUMERATOR_TO_ENUM_VARIANT_CM_COOKIE);

DEFINE_ASM_QUAL_TYPE_NAME(COLOR_TRANSLATOR_ASM_QUAL_TYPE_NAME, g_ColorTranslatorClassName, "System.Drawing", VER_ASSEMBLYVERSION_STR);

DEFINE_ASM_QUAL_TYPE_NAME(COLOR_ASM_QUAL_TYPE_NAME, g_ColorClassName, "System.Drawing", VER_ASSEMBLYVERSION_STR);

#define OLECOLOR_TO_SYSTEMCOLOR_METH_NAME   "FromOle"
#define SYSTEMCOLOR_TO_OLECOLOR_METH_NAME   "ToOle"

BYTE MarshalInfo::m_localSizes[] =
{
#define DEFINE_MARSHALER_TYPE(mtype, mclass) sizeof(mclass),
#include "mtypes.h"
};



UINT16 MarshalInfo::comSize(MarshalType mtype)
{
    static const BYTE comSizes[]=
    {
    #define DEFINE_MARSHALER_TYPE(mtype, mclass) mclass::c_comSize,
    #include "mtypes.h"
    };

    BYTE comSize = comSizes[mtype];

    if (comSize == VARIABLESIZE)
    {
        switch (mtype)
        {

            case MARSHAL_TYPE_BLITTABLEVALUECLASS:
            case MARSHAL_TYPE_VALUECLASS:
                return (UINT16) StackElemSize( m_pClass->GetAlignedNumInstanceFieldBytes() );
                break;

            case MARSHAL_TYPE_VALUECLASSCUSTOMMARSHALER:
                return (UINT16) StackElemSize( m_pCMHelper->GetManagedSize() );

            default:
                _ASSERTE(0);
        }
    }

    return StackElemSize((UINT16)comSize);

}


UINT16 MarshalInfo::nativeSize(MarshalType mtype)
{
    static const BYTE nativeSizes[]=
    {
    #define DEFINE_MARSHALER_TYPE(mtype, mclass) mclass::c_nativeSize,
    #include "mtypes.h"
    };

    BYTE nativeSize = nativeSizes[mtype];

    if (nativeSize == VARIABLESIZE)
    {
        switch (mtype)
        {
            case MARSHAL_TYPE_BLITTABLEVALUECLASS:
            case MARSHAL_TYPE_VALUECLASS:
            case MARSHAL_TYPE_BLITTABLEVALUECLASSWITHCOPYCTOR:
                return (UINT16) StackElemSize( m_pClass->GetMethodTable()->GetNativeSize() );
                break;

            case MARSHAL_TYPE_VALUECLASSCUSTOMMARSHALER:
                return (UINT16) StackElemSize( m_pCMHelper->GetNativeSize() );

            default:
                _ASSERTE(0);
        }
    }

    return MLParmSize((UINT16)nativeSize);
}



BYTE MarshalInfo::m_returnsComByref[]=
{
#define DEFINE_MARSHALER_TYPE(mtype, mclass) mclass::c_fReturnsComByref,
#include "mtypes.h"
};

BYTE MarshalInfo::m_returnsNativeByref[]=
{
#define DEFINE_MARSHALER_TYPE(mtype, mclass) mclass::c_fReturnsNativeByref,
#include "mtypes.h"
};





typedef Marshaler::ArgumentMLOverrideStatus (*MLOVERRIDEPROC)(MLStubLinker *psl,
                                             MLStubLinker *pslPost,
                                             BOOL        byref,
                                             BOOL        fin,
                                             BOOL        fout,
                                             BOOL        comToNative,
                                             MLOverrideArgs *pargs,
                                             UINT       *pResID);

typedef Marshaler::ArgumentMLOverrideStatus (*RETURNMLOVERRIDEPROC)(MLStubLinker *psl,
                                             MLStubLinker *pslPost,
                                             BOOL        comToNative,
                                             BOOL        fThruBuffer,
                                             MLOverrideArgs *pargs,
                                             UINT       *pResID);

static MLOVERRIDEPROC gArgumentMLOverride[] =
{
#define DEFINE_MARSHALER_TYPE(mtype, mclass) mclass::ArgumentMLOverride,
#include "mtypes.h"
};

static RETURNMLOVERRIDEPROC gReturnMLOverride[] =
{
#define DEFINE_MARSHALER_TYPE(mtype, mclass) mclass::ReturnMLOverride,
#include "mtypes.h"
};


#define UNMARSHAL_NATIVE_TO_COM_NEEDED(c)               \
    (NEEDS_UNMARSHAL_NATIVE_TO_COM_IN(c)                \
     | (NEEDS_UNMARSHAL_NATIVE_TO_COM_OUT(c) << 1)      \
     | (NEEDS_UNMARSHAL_NATIVE_TO_COM_IN_OUT(c) << 2)   \
     | (NEEDS_UNMARSHAL_NATIVE_TO_COM_BYREF_IN(c) << 3) \
     | (1 << 4)                                         \
     | (1 << 5))

BYTE MarshalInfo::m_unmarshalN2CNeeded[] =
{
#define DEFINE_MARSHALER_TYPE(mtype, mclass) UNMARSHAL_NATIVE_TO_COM_NEEDED(mclass),
#include "mtypes.h"
};

#define UNMARSHAL_COM_TO_NATIVE_NEEDED(c)                \
    (NEEDS_UNMARSHAL_COM_TO_NATIVE_IN(c)                 \
     | (NEEDS_UNMARSHAL_COM_TO_NATIVE_OUT(c) << 1)       \
     | (NEEDS_UNMARSHAL_COM_TO_NATIVE_IN_OUT(c) << 2)    \
     | (NEEDS_UNMARSHAL_COM_TO_NATIVE_BYREF_IN(c) << 3)  \
     | (1 << 4)                                          \
     | (1 << 5))

BYTE MarshalInfo::m_unmarshalC2NNeeded[] =
{
#define DEFINE_MARSHALER_TYPE(mtype, mclass) UNMARSHAL_COM_TO_NATIVE_NEEDED(mclass),
#include "mtypes.h"
};

static BYTE gInOnly[] =
{
#define DEFINE_MARSHALER_TYPE(mtype, mclass) mclass::c_fInOnly,
#include "mtypes.h"
};




//-------------------------------------------------------------------------------------
// Return the copy ctor for a VC class (if any exists)
//-------------------------------------------------------------------------------------
HRESULT FindCopyCtor(Module *pModule, MethodTable *pMT, MethodDesc **pMDOut)
{
    *pMDOut = NULL;

    IMDInternalImport *pInternalImport = pModule->GetMDImport();
    HENUMInternal      hEnumMethod;
    HRESULT hr = pInternalImport->EnumGlobalFunctionsInit( &hEnumMethod );
    if (FAILED(hr)) {
        return hr;
    }

    mdMethodDef tk;
    mdTypeDef cl = pMT->GetClass()->GetCl();

    while (pInternalImport->EnumNext(&hEnumMethod, &tk)) {
        _ASSERTE(TypeFromToken(tk) == mdtMethodDef);
        DWORD dwMemberAttrs = pInternalImport->GetMethodDefProps(tk);
        if (IsMdSpecialName(dwMemberAttrs)) {
            ULONG cSig;
            PCCOR_SIGNATURE pSig;
            LPCSTR pName = pInternalImport->GetNameAndSigOfMethodDef(tk, &pSig, &cSig);     
            const char *pBaseName = ".__ctor";
            int ncBaseName = (int)strlen(pBaseName);
            int nc = (int)strlen(pName);
            if (nc >= ncBaseName && 0 == strcmp(pName + nc - ncBaseName, pBaseName)) {
                MetaSig msig(pSig, pModule);
                
                // Looking for the prototype   Ptr VC __ctor(Ptr VC, ByRef VC);
                if (msig.NumFixedArgs() == 2) {
                    if (msig.GetReturnType() == ELEMENT_TYPE_PTR) {
                        SigPointer spret = msig.GetReturnProps();
                        spret.GetElemType();
                        if (spret.GetElemType() == ELEMENT_TYPE_VALUETYPE) {
                            mdToken tk0 = spret.GetToken();
                            if (CompareTypeTokens(tk0, cl, pModule, pModule)) {
                                if (msig.NextArg() == ELEMENT_TYPE_PTR) {
                                    SigPointer sp1 = msig.GetArgProps();
                                    sp1.GetElemType();
///                                    if (sp1.GetElemType() == ELEMENT_TYPE_PTR) {
                                        if (sp1.GetElemType() == ELEMENT_TYPE_VALUETYPE) {
                                            mdToken tk1 = sp1.GetToken();
                                            if (tk1 == tk0 || CompareTypeTokens(tk1, cl, pModule, pModule)) {
                                                if (msig.NextArg() == ELEMENT_TYPE_PTR &&
                                                    msig.GetArgProps().HasCustomModifier(pModule, "Microsoft.VisualC.IsCXXReferenceModifier", ELEMENT_TYPE_CMOD_OPT)) {
                                                    SigPointer sp2 = msig.GetArgProps();
                                                    sp2.GetElemType();
                                                    if (sp2.GetElemType() == ELEMENT_TYPE_VALUETYPE) {
                                                        mdToken tk2 = sp2.GetToken();
                                                        if (tk2 == tk0 || CompareTypeTokens(tk2, cl, pModule, pModule)) {
                                                            *pMDOut = pModule->LookupMethodDef(tk);
                                                            break;                                 
                                                        }
                                                    }
                                                }
                                            }
////                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    pInternalImport->EnumClose(&hEnumMethod);
    return S_OK;
}







//-------------------------------------------------------------------------------------
// Return the destructor for a VC class (if any exists)
//-------------------------------------------------------------------------------------
HRESULT FindDtor(Module *pModule, MethodTable *pMT, MethodDesc **pMDOut)
{
    *pMDOut = NULL;

    IMDInternalImport *pInternalImport = pModule->GetMDImport();
    HENUMInternal      hEnumMethod;
    HRESULT hr = pInternalImport->EnumGlobalFunctionsInit( &hEnumMethod );
    if (FAILED(hr)) {
        return hr;
    }

    mdMethodDef tk;
    mdTypeDef cl = pMT->GetClass()->GetCl();

    while (pInternalImport->EnumNext(&hEnumMethod, &tk)) {
        _ASSERTE(TypeFromToken(tk) == mdtMethodDef);
        ULONG cSig;
        PCCOR_SIGNATURE pSig;
        LPCSTR pName = pInternalImport->GetNameAndSigOfMethodDef(tk, &pSig, &cSig);     
        const char *pBaseName = ".__dtor";
        int ncBaseName = (int)strlen(pBaseName);
        int nc = (int)strlen(pName);
        if (nc >= ncBaseName && 0 == strcmp(pName + nc - ncBaseName, pBaseName)) {
            MetaSig msig(pSig, pModule);
            
            // Looking for the prototype   void __dtor(Ptr VC);
            if (msig.NumFixedArgs() == 1) {
                if (msig.GetReturnType() == ELEMENT_TYPE_VOID) {
                    if (msig.NextArg() == ELEMENT_TYPE_PTR) {
                        SigPointer sp1 = msig.GetArgProps();
                        sp1.GetElemType();
///                         if (sp1.GetElemType() == ELEMENT_TYPE_PTR) {
                            if (sp1.GetElemType() == ELEMENT_TYPE_VALUETYPE) {
                                mdToken tk1 = sp1.GetToken();
                                if (CompareTypeTokens(tk1, cl, pModule, pModule)) {
                                    *pMDOut = pModule->LookupMethodDef(tk);
                                    break;
                                }
                            }
///                         }
                    }
                }
            }
        }
    }
    pInternalImport->EnumClose(&hEnumMethod);
    return S_OK;
}




#ifdef _DEBUG
VOID MarshalInfo::DumpMarshalInfo(Module* pModule, SigPointer sig, mdToken token, MarshalScenario ms, BYTE nlType, BYTE nlFlags)
{
    if (LoggingOn(LF_MARSHALER, LL_INFO10))
    {
        char logbuf[3000];

        IMDInternalImport *pInternalImport = pModule->GetMDImport();

        strcpy(logbuf, "------------------------------------------------------------\n");
        LOG((LF_MARSHALER, LL_INFO10, logbuf));
        *logbuf = '\0';

        strcat(logbuf, "Managed type: ");

        if (m_byref) {
            strcat(logbuf, "Byref ");
        }

        SigFormat sigfmt;
        TypeHandle th;
        OBJECTREF throwable = NULL;
        GCPROTECT_BEGIN(throwable);
        th = sig.GetTypeHandle(pModule, &throwable);
        if (throwable != NULL)
        {
            strcat(logbuf, "<error>");
        }
        else
        {
            sigfmt.AddType(th);
            strcat(logbuf, sigfmt.GetCString());
        }
        GCPROTECT_END();

        strcat(logbuf, "\n");
        LOG((LF_MARSHALER, LL_INFO10, logbuf));
        *logbuf = '\0';

        strcat(logbuf, "NativeType  : ");
        PCCOR_SIGNATURE pvNativeType;
        ULONG           cbNativeType;
        if (token == mdParamDefNil
            || pInternalImport->GetFieldMarshal(token,
                                                 &pvNativeType,
                                                 &cbNativeType) != S_OK)
        {
            strcat(logbuf, "<absent>");
        }
        else
        {

            while (cbNativeType--)
            {
                char num[100];
                sprintf(num, "0x%lx ", (ULONG)*pvNativeType);
                strcat(logbuf, num);
                switch (*(pvNativeType++))
                {
#define XXXXX(nt) case nt: strcat(logbuf, "(" #nt ")"); break;

                    XXXXX(NATIVE_TYPE_BOOLEAN)     
                    XXXXX(NATIVE_TYPE_I1)          

                    XXXXX(NATIVE_TYPE_U1)
                    XXXXX(NATIVE_TYPE_I2)          
                    XXXXX(NATIVE_TYPE_U2)          
                    XXXXX(NATIVE_TYPE_I4)          

                    XXXXX(NATIVE_TYPE_U4)
                    XXXXX(NATIVE_TYPE_I8)          
                    XXXXX(NATIVE_TYPE_U8)          
                    XXXXX(NATIVE_TYPE_R4)          

                    XXXXX(NATIVE_TYPE_R8)
                    XXXXX(NATIVE_TYPE_BSTR)        

                    XXXXX(NATIVE_TYPE_LPSTR)
                    XXXXX(NATIVE_TYPE_LPWSTR)      
                    XXXXX(NATIVE_TYPE_LPTSTR)      
                    XXXXX(NATIVE_TYPE_FIXEDSYSSTRING)

                    XXXXX(NATIVE_TYPE_IUNKNOWN)
                    XXXXX(NATIVE_TYPE_IDISPATCH)

                    XXXXX(NATIVE_TYPE_STRUCT)      

                    XXXXX(NATIVE_TYPE_INTF)
                    XXXXX(NATIVE_TYPE_SAFEARRAY)   
                    XXXXX(NATIVE_TYPE_INT)         
                    XXXXX(NATIVE_TYPE_FIXEDARRAY)

                    XXXXX(NATIVE_TYPE_UINT)
                    XXXXX(NATIVE_TYPE_BYVALSTR)    
                    XXXXX(NATIVE_TYPE_ANSIBSTR)    
                
                    XXXXX(NATIVE_TYPE_TBSTR)
                    XXXXX(NATIVE_TYPE_VARIANTBOOL)
                    XXXXX(NATIVE_TYPE_FUNC)
                
                    XXXXX(NATIVE_TYPE_ASANY)

                    XXXXX(NATIVE_TYPE_ARRAY)
                    XXXXX(NATIVE_TYPE_LPSTRUCT)

#undef XXXXX

                    
                    case NATIVE_TYPE_CUSTOMMARSHALER:
                    {
                        int strLen = 0;
                        int oldbuflen;
                        strcat(logbuf, "(NATIVE_TYPE_CUSTOMMARSHALER)");

                        // Skip the typelib guid.
                        strLen = CPackedLen::GetLength(pvNativeType, (void const **)&pvNativeType);
                        oldbuflen = (int)strlen(logbuf);
                        logbuf[oldbuflen] = ' ';
                        memcpyNoGCRefs(logbuf + oldbuflen + 1, pvNativeType, strLen);
                        logbuf[oldbuflen + 1 + strLen] = '\0';
                        pvNativeType += strLen;
                        cbNativeType -= strLen + 1;

                        // Skip the name of the native type.
                        strLen = CPackedLen::GetLength(pvNativeType, (void const **)&pvNativeType);
                        oldbuflen = (int)strlen(logbuf);
                        logbuf[oldbuflen] = ' ';
                        memcpyNoGCRefs(logbuf + oldbuflen + 1, pvNativeType, strLen);
                        logbuf[oldbuflen + 1 + strLen] = '\0';
                        pvNativeType += strLen;
                        cbNativeType -= strLen + 1;
        
                        // Extract the name of the custom marshaler.
                        strLen = CPackedLen::GetLength(pvNativeType, (void const **)&pvNativeType);
                        oldbuflen = (int)strlen(logbuf);
                        logbuf[oldbuflen] = ' ';
                        memcpyNoGCRefs(logbuf + oldbuflen + 1, pvNativeType, strLen);
                        logbuf[oldbuflen + 1 + strLen] = '\0';
                        pvNativeType += strLen;
                        cbNativeType -= strLen + 1;
        
                        // Extract the cookie string.
                        strLen = CPackedLen::GetLength(pvNativeType, (void const **)&pvNativeType);
                        oldbuflen = (int)strlen(logbuf);
                        logbuf[oldbuflen] = ' ';
                        memcpyNoGCRefs(logbuf + oldbuflen + 1, pvNativeType, strLen);
                        logbuf[oldbuflen + 1 + strLen] = '\0';
                        pvNativeType += strLen;
                        cbNativeType -= strLen + 1;
                        break;
                    }

                    default:
                        strcat(logbuf, "(?)");
                }

                strcat(logbuf, "   ");
            }
        }
        strcat(logbuf, "\n");
        LOG((LF_MARSHALER, LL_INFO10, logbuf));
        *logbuf = '\0';

        strcat(logbuf, "MarshalType : ");
        {
            char num[100];
            sprintf(num, "0x%lx ", (ULONG)m_type);
            strcat(logbuf, num);
        }
        switch (m_type)
        {
#define DEFINE_MARSHALER_TYPE(mt, mc) case mt: strcat(logbuf, #mt " (" #mc ")"); break;
#include "mtypes.h"
#undef DEFINE_MARSHALER_TYPE
            case MARSHAL_TYPE_UNKNOWN:
                strcat(logbuf, "MARSHAL_TYPE_UNKNOWN (illegal combination)");
                break;
            default:
                strcat(logbuf, "MARSHAL_TYPE_???");
                break;
        }

        strcat(logbuf, "\n");


        strcat(logbuf, "Metadata In/Out     : ");
        if (TypeFromToken(token) != mdtParamDef || token == mdParamDefNil)
        {
            strcat(logbuf, "<absent>");
        }
        else
        {
            DWORD dwAttr = 0;
            USHORT usSequence;
            pInternalImport->GetParamDefProps(token, &usSequence, &dwAttr);
            if (IsPdIn(dwAttr))
            {
                strcat(logbuf, "In ");
            }
            if (IsPdOut(dwAttr))
            {
                strcat(logbuf, "Out ");
            }
        }

        strcat(logbuf, "\n");


        strcat(logbuf, "Effective In/Out     : ");
        if (m_in)
        {
            strcat(logbuf, "In ");
        }
        if (m_out)
        {
            strcat(logbuf, "Out ");
        }
        strcat(logbuf, "\n");


        LOG((LF_MARSHALER, LL_INFO10, logbuf));
        *logbuf = '\0';

    }
}
#endif



//==========================================================================
// Set's up the custom marshaler information.
//==========================================================================
CustomMarshalerHelper *SetupCustomMarshalerHelper(LPCUTF8 strMarshalerTypeName, DWORD cMarshalerTypeNameBytes, LPCUTF8 strCookie, DWORD cCookieStrBytes, Assembly *pAssembly, TypeHandle hndManagedType)
{
    EEMarshalingData *pMarshalingData = NULL;

    // Retrieve the marshalling data for the current app domain.
    if (pAssembly->IsShared())
    {
        // If the assembly is shared, then it should only reference other shared assemblies.
        // This assumption MUST be true for the current custom marshaling scheme to work.
        // This implies that the type of the managed parameter must be a shared type.
        _ASSERTE(hndManagedType.GetAssembly()->IsShared());

        // The assembly is shared so we need to use the system domain's marshaling data.
        pMarshalingData = SystemDomain::System()->GetMarshalingData();
    }
    else
    {
        // The assembly is not shared so we use the current app domain's marshaling data.
        pMarshalingData = GetThread()->GetDomain()->GetMarshalingData();
    }

    // Retrieve the custom marshaler helper from the EE marshaling data.
    return pMarshalingData->GetCustomMarshalerHelper(pAssembly, hndManagedType, strMarshalerTypeName, cMarshalerTypeNameBytes, strCookie, cCookieStrBytes);
}


OleColorMarshalingInfo::OleColorMarshalingInfo()
: m_OleColorToSystemColorMD(NULL)
, m_SystemColorToOleColorMD(NULL)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF pThrowable = NULL;
    GCPROTECT_BEGIN(pThrowable)
    {
        // Load the color translator class.
        m_hndColorTranslatorType = SystemDomain::GetCurrentDomain()->FindAssemblyQualifiedTypeHandle(COLOR_TRANSLATOR_ASM_QUAL_TYPE_NAME, true, NULL, NULL, &pThrowable);
        _ASSERTE(!m_hndColorTranslatorType.IsNull() && "Unable to find the translator class to convert an OLE_COLOR to a System.Drawing.Color!");
        if (m_hndColorTranslatorType.IsNull())
                COMPlusThrow(pThrowable);

        // Load the color class.
        m_hndColorType = SystemDomain::GetCurrentDomain()->FindAssemblyQualifiedTypeHandle(COLOR_ASM_QUAL_TYPE_NAME, true, NULL, NULL, &pThrowable);
        _ASSERTE(!m_hndColorType.IsNull() && "Unable to find the System.Drawing.Color class!");
        if (m_hndColorType.IsNull())
                COMPlusThrow(pThrowable);
    }
    GCPROTECT_END();

    // Retrieve the method to convert an OLE_COLOR to a System.Drawing.Color.
    m_OleColorToSystemColorMD = m_hndColorTranslatorType.GetClass()->FindMethodByName(OLECOLOR_TO_SYSTEMCOLOR_METH_NAME);
    _ASSERTE(m_OleColorToSystemColorMD && "Unable to find the translator method to convert an OLE_COLOR to a System.Drawing.Color!");
    _ASSERTE(m_OleColorToSystemColorMD->IsStatic() && "The translator method to convert an OLE_COLOR to a System.Drawing.Color must be static!");

    // Retrieve the method to convert a System.Drawing.Color to an OLE_COLOR.
    m_SystemColorToOleColorMD = m_hndColorTranslatorType.GetClass()->FindMethodByName(SYSTEMCOLOR_TO_OLECOLOR_METH_NAME);
    _ASSERTE(m_SystemColorToOleColorMD && "Unable to find the translator method to convert a System.Drawing.Color to an OLE_COLOR!");
    _ASSERTE(m_SystemColorToOleColorMD->IsStatic() && "The translator method to convert a System.Drawing.Color to an OLE_COLOR must be static!");
}


void *OleColorMarshalingInfo::operator new(size_t size, LoaderHeap *pHeap)
{
    return pHeap->AllocMem(sizeof(EEMarshalingData));
}


void OleColorMarshalingInfo::operator delete(void *pMem)
{
    // Instances of this class are always allocated on the loader heap so
    // the delete operator has nothing to do.
}


EEMarshalingData::EEMarshalingData(BaseDomain *pDomain, LoaderHeap *pHeap, Crst *pCrst)
: m_pDomain(pDomain)
, m_pHeap(pHeap)
, m_pOleColorInfo(NULL)
{
    LockOwner lock = {pCrst, IsOwnerOfCrst};
    m_CMHelperHashtable.Init(INITIAL_NUM_CMHELPER_HASHTABLE_BUCKETS, &lock);
    m_SharedCMHelperToCMInfoMap.Init(INITIAL_NUM_CMINFO_HASHTABLE_BUCKETS, &lock);
}


EEMarshalingData::~EEMarshalingData()
{
    CustomMarshalerInfo *pCMInfo;

    // @TODO(DM): Remove the linked list of CMInfo's and instead hang the OBJECTHANDLE 
    // contained inside the CMInfo off the AppDomain directly. The AppDomain can have
    // a list of tasks to do when it gets teared down and we could leverage that
    // to release the object handles.

    // Walk through the linked list and delete all the custom marshaler info's.
    while ((pCMInfo = m_pCMInfoList.RemoveHead()) != NULL)
        delete pCMInfo;
}


void *EEMarshalingData::operator new(size_t size, LoaderHeap *pHeap)
{
    return pHeap->AllocMem(sizeof(EEMarshalingData));
}


void EEMarshalingData::operator delete(void *pMem)
{
    // Instances of this class are always allocated on the loader heap so
    // the delete operator has nothing to do.
}


CustomMarshalerHelper *EEMarshalingData::GetCustomMarshalerHelper(Assembly *pAssembly, TypeHandle hndManagedType, LPCUTF8 strMarshalerTypeName, DWORD cMarshalerTypeNameBytes, LPCUTF8 strCookie, DWORD cCookieStrBytes)
{
    THROWSCOMPLUSEXCEPTION();

    CustomMarshalerHelper *pCMHelper = NULL;
    CustomMarshalerHelper *pNewCMHelper = NULL;
    CustomMarshalerInfo *pNewCMInfo = NULL;
    BOOL bSharedHelper = pAssembly->IsShared();
    TypeHandle hndCustomMarshalerType;
    OBJECTREF throwable = NULL;

    // Create the key that will be used to lookup in the hashtable.
    EECMHelperHashtableKey Key(cMarshalerTypeNameBytes, strMarshalerTypeName, cCookieStrBytes, strCookie, bSharedHelper);

    // Lookup the custom marshaler helper in the hashtable.
    if (m_CMHelperHashtable.GetValue(&Key, (HashDatum*)&pCMHelper))
        return pCMHelper;

    // Switch to cooperative GC mode if we are not already in cooperative.
    Thread *pThread = SetupThread();
    BOOL bToggleGC = !pThread->PreemptiveGCDisabled();
    if (bToggleGC)
        pThread->DisablePreemptiveGC();

    GCPROTECT_BEGIN(throwable)
    {
        // Validate the arguments.
        _ASSERTE(strMarshalerTypeName && strCookie && !hndManagedType.IsNull());

        // Append a NULL terminator to the marshaler type name.
        CQuickArray<char> strCMMarshalerTypeName;
        strCMMarshalerTypeName.ReSize(cMarshalerTypeNameBytes + 1);
        memcpy(strCMMarshalerTypeName.Ptr(), strMarshalerTypeName, cMarshalerTypeNameBytes);
        strCMMarshalerTypeName[cMarshalerTypeNameBytes] = 0;

        // Load the custom marshaler class. 
        BOOL fNameIsAsmQualified = FALSE;
        hndCustomMarshalerType = SystemDomain::GetCurrentDomain()->FindAssemblyQualifiedTypeHandle(strCMMarshalerTypeName.Ptr(), true, pAssembly, &fNameIsAsmQualified, &throwable);
        if (hndCustomMarshalerType.IsNull())
            COMPlusThrow(throwable);

        if (fNameIsAsmQualified)
        {
            // Set the assembly to null to indicate that the custom marshaler name is assembly
            // qualified.        
            pAssembly = NULL;
        }
    }
    GCPROTECT_END();


    if (bSharedHelper)
    {
        // Create the custom marshaler helper in the specified heap.
        pNewCMHelper = new (m_pHeap) SharedCustomMarshalerHelper(pAssembly, hndManagedType, strMarshalerTypeName, cMarshalerTypeNameBytes, strCookie, cCookieStrBytes);
    }
    else
    {
        // Create the custom marshaler info in the specified heap.
        pNewCMInfo = new (m_pHeap) CustomMarshalerInfo(m_pDomain, hndCustomMarshalerType, hndManagedType, strCookie, cCookieStrBytes);

        // Create the custom marshaler helper in the specified heap.
        pNewCMHelper = new (m_pHeap) NonSharedCustomMarshalerHelper(pNewCMInfo);
    }

    // Switch the GC mode back to the original mode.
    if (bToggleGC)
        pThread->EnablePreemptiveGC();

    // Take the app domain lock before we insert the custom marshaler info into the hashtable.
    m_pDomain->EnterLock();

    // Verify that the custom marshaler helper has not already been added by another thread.
    if (m_CMHelperHashtable.GetValue(&Key, (HashDatum*)&pCMHelper))
    {
        m_pDomain->LeaveLock();
        if (pNewCMHelper)
            pNewCMHelper->Dispose();
        if (pNewCMInfo)
            delete pNewCMInfo;
        return pCMHelper;
    }

    // Add the custom marshaler helper to the hash table.
    m_CMHelperHashtable.InsertValue(&Key, pNewCMHelper, FALSE);

    // If we create the CM info, then add it to the linked list.
    if (pNewCMInfo)
        m_pCMInfoList.InsertHead(pNewCMInfo);

    // Release the lock and return the custom marshaler info.
    m_pDomain->LeaveLock();
    return pNewCMHelper;
}

CustomMarshalerInfo *EEMarshalingData::GetCustomMarshalerInfo(SharedCustomMarshalerHelper *pSharedCMHelper)
{
    THROWSCOMPLUSEXCEPTION();

    CustomMarshalerInfo *pCMInfo = NULL;
    CustomMarshalerInfo *pNewCMInfo = NULL;
    TypeHandle hndCustomMarshalerType;
    OBJECTREF throwable = NULL;

    // Lookup the custom marshaler helper in the hashtable.
    if (m_SharedCMHelperToCMInfoMap.GetValue(pSharedCMHelper, (HashDatum*)&pCMInfo))
        return pCMInfo;

    GCPROTECT_BEGIN(throwable)
    {
        // Append a NULL terminator to the marshaler type name.
        CQuickArray<char> strCMMarshalerTypeName;
        DWORD strLen = pSharedCMHelper->GetMarshalerTypeNameByteCount();
        strCMMarshalerTypeName.ReSize(pSharedCMHelper->GetMarshalerTypeNameByteCount() + 1);
        memcpy(strCMMarshalerTypeName.Ptr(), pSharedCMHelper->GetMarshalerTypeName(), strLen);
        strCMMarshalerTypeName[strLen] = 0;

        // Load the custom marshaler class. 
        hndCustomMarshalerType = SystemDomain::GetCurrentDomain()->FindAssemblyQualifiedTypeHandle(strCMMarshalerTypeName.Ptr(), true, pSharedCMHelper->GetAssembly(), NULL, &throwable);
        if (hndCustomMarshalerType.IsNull())
            COMPlusThrow(throwable);
    }
    GCPROTECT_END();

    // Create the custom marshaler info in the specified heap.
    pNewCMInfo = new (m_pHeap) CustomMarshalerInfo(m_pDomain, 
                                                   hndCustomMarshalerType, 
                                                   pSharedCMHelper->GetManagedType(), 
                                                   pSharedCMHelper->GetCookieString(), 
                                                   pSharedCMHelper->GetCookieStringByteCount());

    // Take the app domain lock before we insert the custom marshaler info into the hashtable.
    m_pDomain->EnterLock();

    // Verify that the custom marshaler info has not already been added by another thread.
    if (m_SharedCMHelperToCMInfoMap.GetValue(pSharedCMHelper, (HashDatum*)&pCMInfo))
    {
        m_pDomain->LeaveLock();
        delete pNewCMInfo;
        return pCMInfo;
    }

    // Add the custom marshaler helper to the hash table.
    m_SharedCMHelperToCMInfoMap.InsertValue(pSharedCMHelper, pNewCMInfo, FALSE);

    // Add the custom marshaler into the linked list.
    m_pCMInfoList.InsertHead(pNewCMInfo);

    // Release the lock and return the custom marshaler info.
    m_pDomain->LeaveLock();
    return pNewCMInfo;
}

OleColorMarshalingInfo *EEMarshalingData::GetOleColorMarshalingInfo()
{
    if (m_pOleColorInfo)
        return m_pOleColorInfo;

    // Take the app domain lock before we allocate the OLE_COLOR marshaling info.
    m_pDomain->EnterLock();

    // Make sure some other thread has not already allocated the info.
    if (!m_pOleColorInfo)
    {
        m_pOleColorInfo = new (m_pHeap) OleColorMarshalingInfo();
    }

    // Release the lock and return the OLE_COLOR marshaling info.
    m_pDomain->LeaveLock();
    return m_pOleColorInfo;
}

//==========================================================================
// Return: S_OK if there is valid data to compress
//         S_FALSE if at end of data block
//         E_FAIL if corrupt data found
//==========================================================================
HRESULT CheckForCompressedData(PCCOR_SIGNATURE pvNativeTypeStart, PCCOR_SIGNATURE pvNativeType, ULONG cbNativeType)
{
    if ( ((ULONG)(pvNativeType - pvNativeTypeStart)) == cbNativeType )
    {
        return S_FALSE;  //no more data
    }
    PCCOR_SIGNATURE pvProjectedEnd = pvNativeType + CorSigUncompressedDataSize(pvNativeType);
    if (pvProjectedEnd <= pvNativeType || ((ULONG)(pvProjectedEnd - pvNativeTypeStart)) > cbNativeType)
    {
        return E_FAIL; //corrupted data
    }
    return S_OK;
}

//==========================================================================
// Parse and validate the NATIVE_TYPE_ metadata.
// Note! NATIVE_TYPE_ metadata is optional. If it's not present, this
// routine sets NativeTypeParamInfo->m_NativeType to NATIVE_TYPE_DEFAULT. 
//==========================================================================
BOOL ParseNativeTypeInfo(mdToken                    token,
                         Module*                    pModule,
                         NativeTypeParamInfo*       pParamInfo
                         )
{
    PCCOR_SIGNATURE pvNativeType;
    ULONG           cbNativeType;
    HRESULT hr;

    if (token == mdParamDefNil || pModule->GetMDImport()->GetFieldMarshal(token, &pvNativeType, &cbNativeType) != S_OK)
    {
        return TRUE;
    }
    else
    {
        PCCOR_SIGNATURE pvNativeTypeStart = pvNativeType;

        if (cbNativeType == 0)
        {
            return FALSE;  // Zero-length NATIVE_TYPE block
        }

        pParamInfo->m_NativeType = (CorNativeType)*(pvNativeType++);

        // Retrieve any extra information associated with the native type.
        switch (pParamInfo->m_NativeType)
        {
            case NATIVE_TYPE_SAFEARRAY:
                // Check for the safe array element type.
                hr = CheckForCompressedData(pvNativeTypeStart, pvNativeType, cbNativeType);
                if (FAILED(hr))
                {
                    return FALSE;
                }
                if (hr == S_OK)
                {
                    pParamInfo->m_SafeArrayElementVT = (VARTYPE) (CorSigUncompressData(/*modifies*/pvNativeType));
                }

                // Extract the name of the record type's.
                if (S_OK == CheckForCompressedData(pvNativeTypeStart, pvNativeType, cbNativeType))
                {
                    int strLen = CPackedLen::GetLength(pvNativeType, (void const **)&pvNativeType);
                    if (pvNativeType + strLen < pvNativeType ||
                        pvNativeType + strLen > pvNativeTypeStart + cbNativeType)
                        return FALSE;
                    pParamInfo->m_strSafeArrayUserDefTypeName = (LPUTF8)pvNativeType;
                    pParamInfo->m_cSafeArrayUserDefTypeNameBytes = strLen;
                    _ASSERTE((ULONG)(pvNativeType + strLen - pvNativeTypeStart) == cbNativeType);
                }
                break;

            case NATIVE_TYPE_ARRAY:
                hr = CheckForCompressedData(pvNativeTypeStart, pvNativeType, cbNativeType);
                if (FAILED(hr))
                {
                    return FALSE;
                }
                if (hr == S_OK)
                {
                    pParamInfo->m_ArrayElementType = (CorNativeType) (CorSigUncompressData(/*modifies*/pvNativeType));
                }

                // Check for "sizeis" param index
                hr = CheckForCompressedData(pvNativeTypeStart, pvNativeType, cbNativeType);
                if (FAILED(hr))
                {
                    return FALSE;
                }
                if (hr == S_OK)
                {
                    pParamInfo->m_SizeIsSpecified = TRUE;
                    pParamInfo->m_CountParamIdx = (UINT16)(CorSigUncompressData(/*modifies*/pvNativeType));

                    // If an "sizeis" param index is present, the defaults for multiplier and additive change
                    pParamInfo->m_Multiplier = 1;
                    pParamInfo->m_Additive   = 0;

                    // Check for "sizeis" additive
                    hr = CheckForCompressedData(pvNativeTypeStart, pvNativeType, cbNativeType);
                    if (FAILED(hr))
                    {
                        return FALSE;
                    }
                    if (hr == S_OK)
                    {
                        pParamInfo->m_Additive = CorSigUncompressData(/*modifies*/pvNativeType);
                    }    
                }

                break;

            case NATIVE_TYPE_CUSTOMMARSHALER:
                int strLen = 0;

                // Skip the typelib guid.
                if (S_OK != CheckForCompressedData(pvNativeTypeStart, pvNativeType, cbNativeType))
                    return FALSE;
                strLen = CPackedLen::GetLength(pvNativeType, (void const **)&pvNativeType);

                if (pvNativeType + strLen < pvNativeType ||
                    pvNativeType + strLen > pvNativeTypeStart + cbNativeType)
                    return FALSE;

                pvNativeType += strLen;
                _ASSERTE((ULONG)(pvNativeType - pvNativeTypeStart) < cbNativeType);                

                // Skip the name of the native type.
                if (S_OK != CheckForCompressedData(pvNativeTypeStart, pvNativeType, cbNativeType))
                    return FALSE;
                strLen = CPackedLen::GetLength(pvNativeType, (void const **)&pvNativeType);
                if (pvNativeType + strLen < pvNativeType ||
                    pvNativeType + strLen > pvNativeTypeStart + cbNativeType)
                    return FALSE;
                pvNativeType += strLen;
                _ASSERTE((ULONG)(pvNativeType - pvNativeTypeStart) < cbNativeType);

                // Extract the name of the custom marshaler.
                if (S_OK != CheckForCompressedData(pvNativeTypeStart, pvNativeType, cbNativeType))
                    return FALSE;
                strLen = CPackedLen::GetLength(pvNativeType, (void const **)&pvNativeType);
                if (pvNativeType + strLen < pvNativeType ||
                    pvNativeType + strLen > pvNativeTypeStart + cbNativeType)
                    return FALSE;
                pParamInfo->m_strCMMarshalerTypeName = (LPUTF8)pvNativeType;
                pParamInfo->m_cCMMarshalerTypeNameBytes = strLen;
                pvNativeType += strLen;
                _ASSERTE((ULONG)(pvNativeType - pvNativeTypeStart) < cbNativeType);

                // Extract the cookie string.
                if (S_OK != CheckForCompressedData(pvNativeTypeStart, pvNativeType, cbNativeType))
                    return FALSE;
                strLen = CPackedLen::GetLength(pvNativeType, (void const **)&pvNativeType);
                if (pvNativeType + strLen < pvNativeType ||
                    pvNativeType + strLen > pvNativeTypeStart + cbNativeType)
                    return FALSE;
                pParamInfo->m_strCMCookie = (LPUTF8)pvNativeType;
                pParamInfo->m_cCMCookieStrBytes = strLen;
                _ASSERTE((ULONG)(pvNativeType + strLen - pvNativeTypeStart) == cbNativeType);
                break;
        }

        return TRUE;
    }
}



#ifdef _DEBUG
#define REDUNDANCYWARNING(when) if (when) LOG((LF_SLOP, LL_INFO100, "%s: Redundant nativetype metadata.\n", achDbgContext))
#else
#define REDUNDANCYWARNING(when)
#endif

//==========================================================================
// Constructs MarshalInfo. 
//==========================================================================
MarshalInfo::MarshalInfo(Module* pModule,
                         SigPointer sig,
                         mdToken token,
                         MarshalScenario ms,
                         BYTE nlType,
                         BYTE nlFlags,
                         BOOL isParam,
                         UINT paramidx,   // parameter # for use in error messages (ignored if not parameter)
                         BOOL BestFit,
                         BOOL ThrowOnUnmappableChar

#ifdef CUSTOMER_CHECKED_BUILD
                         ,
                         MethodDesc* pMD
#endif
#ifdef _DEBUG
                         ,
                         LPCUTF8 pDebugName,
                         LPCUTF8 pDebugClassName,
                         LPCUTF8 pDebugNameSpace,
                         UINT    argidx  // 0 for return value, -1 for field
#endif
)
{
    m_BestFit = BestFit;
    m_ThrowOnUnmappableChar = ThrowOnUnmappableChar;

    m_paramidx = paramidx;
    m_resID    = IDS_EE_BADPINVOKE_GENERIC;  // if no one overwrites this with a better message, we'll still at least say something

    CorNativeType nativeType = NATIVE_TYPE_DEFAULT;
    HRESULT hr;
    NativeTypeParamInfo ParamInfo;
    Assembly *pAssembly = pModule->GetAssembly();

    BOOL fNeedsCopyCtor = FALSE;

#ifdef _DEBUG
    CHAR achDbgContext[2000] = "";
    if (!pDebugName)
    {
        strcpy(achDbgContext, "<Unknown>");
    }
    else
    {
        if (pDebugNameSpace)
        {
            strcpy(achDbgContext, pDebugNameSpace);
            strcat(achDbgContext, NAMESPACE_SEPARATOR_STR);
        }
        strcat(achDbgContext, pDebugClassName);
        strcat(achDbgContext, NAMESPACE_SEPARATOR_STR);
        strcat(achDbgContext, pDebugName);
        strcat(achDbgContext, " ");
        switch (argidx)
        {
            case -1:
                strcat(achDbgContext, "field");
                break;
            case 0:
                strcat(achDbgContext, "return value");
                break;
            default:
                {
                    char buf[30];
                    sprintf(buf, "param #%lu", (ULONG)argidx);
                    strcat(achDbgContext, buf);
                }
        }
    }

     m_strDebugMethName = pDebugName;
     m_strDebugClassName = pDebugClassName;
     m_strDebugNameSpace = pDebugNameSpace;
     m_iArg = argidx;
#else
    CHAR *achDbgContext = NULL;
#endif

#ifdef _DEBUG
    m_in = m_out = FALSE;
    m_byref = TRUE;
#endif

    CorElementType mtype        = ELEMENT_TYPE_END;
#ifdef CUSTOMER_CHECKED_BUILD
    CorElementType corElemType  = ELEMENT_TYPE_END;
#endif // CUSTOMER_CHECKED_BUILD

    // Retrieve the native type for the current parameter.
    if (!ParseNativeTypeInfo(token, pModule, &ParamInfo))
    {
        IfFailGoto(E_FAIL, lFail);
    }
   
    nativeType = ParamInfo.m_NativeType;

    m_ms      = ms;
    m_nlType  = nlType;
    m_nlFlags = nlFlags;
    m_fAnsi   = (ms == MARSHAL_SCENARIO_NDIRECT) && (nlType == nltAnsi);
    m_fDispIntf = FALSE;
    m_fErrorNativeType = FALSE;

    m_comArgSize = 0;
    m_nativeArgSize = 0;
    m_pCMHelper = NULL;
    m_CMVt = VT_EMPTY;

    m_args.m_pMLInfo = this;

#ifdef CUSTOMER_CHECKED_BUILD
    corElemType = (CorElementType) sig.Normalize(pModule);
    mtype       = corElemType;
#else
    mtype       = (CorElementType) sig.Normalize(pModule);
#endif // CUSTOMER_CHECKED_BUILD

    if (mtype == ELEMENT_TYPE_BYREF)
    {
        m_byref = TRUE;

        SigPointer sigtmp = sig;

        sig.GetElemType();
        mtype = (CorElementType) sig.Normalize(pModule);

        if (mtype == ELEMENT_TYPE_VALUETYPE) 
        {
            sigtmp.GetByte(); // Skip ET_BYREF;
            if (sigtmp.HasCustomModifier(pModule, "Microsoft.VisualC.NeedsCopyConstructorModifier", ELEMENT_TYPE_CMOD_REQD))
            {
                fNeedsCopyCtor = TRUE;
                m_byref = FALSE;
            }
        }
    
    }
    else
    {
        m_byref = FALSE;
    }

    if (mtype == ELEMENT_TYPE_PTR)
    {
        SigPointer sigtmp = sig;

        sigtmp.GetElemType();
        CorElementType mtype2 = (CorElementType) sigtmp.Normalize(pModule);

        if (mtype2 == ELEMENT_TYPE_VALUETYPE) 
        {
            EEClass *pClass = sigtmp.GetTypeHandle(pModule).GetClass();
            if (pClass && !pClass->IsBlittable())
            {
                m_resID = IDS_EE_BADPINVOKE_PTRNONBLITTABLE;
                IfFailGoto(E_FAIL, lFail);
            }
            if (sigtmp.HasCustomModifier(pModule, "Microsoft.VisualC.NeedsCopyConstructorModifier", ELEMENT_TYPE_CMOD_REQD))
            {
                sig.GetElemType();   // Skip ET_PTR
                mtype = (CorElementType) sig.Normalize(pModule);
                fNeedsCopyCtor = TRUE;
                m_byref = FALSE;
            }
        } else {

            if (!(mtype2 != ELEMENT_TYPE_CLASS &&
                  mtype2 != ELEMENT_TYPE_STRING &&
                  mtype2 != ELEMENT_TYPE_CLASS &&
                  mtype2 != ELEMENT_TYPE_OBJECT &&
                  mtype2 != ELEMENT_TYPE_SZARRAY))
            {
                m_resID = IDS_EE_BADPINVOKE_PTRSUBTYPE;
                IfFailGoto(E_FAIL, lFail);
            }
        }
    }


    if (m_byref && ParamInfo.m_SizeIsSpecified)
    {
        m_resID = IDS_EE_PINVOKE_NOREFFORSIZEIS;
        IfFailGoto(E_FAIL, lFail);
    }

    
    // Hack to get system primitive types (System.Int32, et.al.)
    // to marshal as expected. If those system prims were implemented as
    // enums, this wouldn't be necessary.
    if (mtype == ELEMENT_TYPE_VALUETYPE)
    {
        BEGIN_ENSURE_COOPERATIVE_GC()
        {
            OBJECTREF pException = NULL;
            GCPROTECT_BEGIN(pException)
            {    
                TypeHandle thnd = sig.GetTypeHandle(pModule, &pException);
                if (!(thnd.IsNull()))
                {  
                    CorElementType realmtype = thnd.GetNormCorElementType();

                    if (CorTypeInfo::IsPrimitiveType(realmtype))
                        mtype = realmtype;
                }
            }
            GCPROTECT_END();
        }
        END_ENSURE_COOPERATIVE_GC();
    }

    // Handle the custom marshaler native type seperately.
    if (nativeType == NATIVE_TYPE_CUSTOMMARSHALER)
    {
        IfFailGoto(QuickCOMStartup(), lFail);

        switch (mtype)
        {
            case ELEMENT_TYPE_VAR:
            case ELEMENT_TYPE_CLASS:
            case ELEMENT_TYPE_OBJECT:
                m_CMVt = VT_UNKNOWN;
                break;

            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_SZARRAY:
            case ELEMENT_TYPE_ARRAY:
                m_CMVt = VT_I4;
                break;

            default:    
                m_resID = IDS_EE_BADPINVOKE_CUSTOMMARSHALER;
                IfFailGoto(E_FAIL, lFail);
        }

        // Set up the custom marshaler info.
        m_type = MARSHAL_TYPE_UNKNOWN; // in case SetupCustomMarshalerHelper throws
        m_pCMHelper = SetupCustomMarshalerHelper(ParamInfo.m_strCMMarshalerTypeName, 
                                                 ParamInfo.m_cCMMarshalerTypeNameBytes,
                                                 ParamInfo.m_strCMCookie, 
                                                 ParamInfo.m_cCMCookieStrBytes,
                                                 pAssembly,
                                                 sig.GetTypeHandle(pModule));

        // Determine which custom marshaler to use.
        m_type = m_pCMHelper->IsDataByValue() ? MARSHAL_TYPE_VALUECLASSCUSTOMMARSHALER : 
                                              MARSHAL_TYPE_REFERENCECUSTOMMARSHALER;
        goto lExit;
    }

    m_type = MARSHAL_TYPE_UNKNOWN; // flag for uninitialized type
    switch (mtype)
    {
        case ELEMENT_TYPE_BOOLEAN:
            switch (nativeType)
            {
                case NATIVE_TYPE_BOOLEAN:
                    REDUNDANCYWARNING(m_ms == MARSHAL_SCENARIO_NDIRECT);
                    m_type = MARSHAL_TYPE_WINBOOL;
                    break;

                case NATIVE_TYPE_VARIANTBOOL:
                    REDUNDANCYWARNING(m_ms != MARSHAL_SCENARIO_NDIRECT);
                    m_type = MARSHAL_TYPE_VTBOOL;
                    break;

                case NATIVE_TYPE_U1:
                case NATIVE_TYPE_I1:
                    m_type = MARSHAL_TYPE_CBOOL;
                    break;

                case NATIVE_TYPE_DEFAULT:
                    m_type = ( (m_ms == MARSHAL_SCENARIO_NDIRECT) ? MARSHAL_TYPE_WINBOOL : MARSHAL_TYPE_VTBOOL );
                    break;
                default:
                    m_resID = IDS_EE_BADPINVOKE_BOOLEAN;
                    IfFailGoto(E_FAIL, lFail);
            }
            break;

        case ELEMENT_TYPE_CHAR:
            switch (nativeType)
            {
                case NATIVE_TYPE_I1: //fallthru
                case NATIVE_TYPE_U1:
                    REDUNDANCYWARNING(m_ms == MARSHAL_SCENARIO_NDIRECT && m_fAnsi);
                    m_type = MARSHAL_TYPE_ANSICHAR;
                    break;

                case NATIVE_TYPE_I2: //fallthru
                case NATIVE_TYPE_U2:
                    REDUNDANCYWARNING(!(m_ms == MARSHAL_SCENARIO_NDIRECT && m_fAnsi));
                    m_type = MARSHAL_TYPE_GENERIC_U2;
                    break;

                case NATIVE_TYPE_DEFAULT:
                    m_type = ( (m_ms == MARSHAL_SCENARIO_NDIRECT && m_fAnsi) ? MARSHAL_TYPE_ANSICHAR : MARSHAL_TYPE_GENERIC_U2 );
                    break;

                default:
                    m_resID = IDS_EE_BADPINVOKE_CHAR;
                    IfFailGoto(E_FAIL, lFail);

            }
            break;

        case ELEMENT_TYPE_I1:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_I1 || nativeType == NATIVE_TYPE_U1 || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_I1;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_GENERIC_1;
            break;

        case ELEMENT_TYPE_U1:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_U1 || nativeType == NATIVE_TYPE_I1 || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_I1;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_GENERIC_U1;
            break;

        case ELEMENT_TYPE_I2:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_I2 || nativeType == NATIVE_TYPE_U2 || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_I2;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_GENERIC_2;
            break;

        case ELEMENT_TYPE_U2:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_U2 || nativeType == NATIVE_TYPE_I2 || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_I2;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_GENERIC_U2;
            break;

        case ELEMENT_TYPE_I4:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT || nativeType != NATIVE_TYPE_ERROR);
            switch (nativeType)
            {
                case NATIVE_TYPE_I4:
                case NATIVE_TYPE_U4:
                case NATIVE_TYPE_DEFAULT:
                    break;

                case NATIVE_TYPE_ERROR:
                    m_fErrorNativeType = TRUE;
                    break;

                default:
                m_resID = IDS_EE_BADPINVOKE_I4;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_GENERIC_4;
            break;

        case ELEMENT_TYPE_U4:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT || nativeType != NATIVE_TYPE_ERROR);
            switch (nativeType)
            {
                case NATIVE_TYPE_I4:
                case NATIVE_TYPE_U4:
                case NATIVE_TYPE_DEFAULT:
                    break;

                case NATIVE_TYPE_ERROR:
                    m_fErrorNativeType = TRUE;
                    break;

                default:
                m_resID = IDS_EE_BADPINVOKE_I4;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_GENERIC_4;
            break;

        case ELEMENT_TYPE_I8:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_I8 || nativeType == NATIVE_TYPE_U8 || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_I8;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_GENERIC_8;
            break;

        case ELEMENT_TYPE_U8:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_U8 || nativeType == NATIVE_TYPE_I8 || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_I8;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_GENERIC_8;
            break;

        case ELEMENT_TYPE_I:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_INT || nativeType == NATIVE_TYPE_UINT || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_I;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = (sizeof(LPVOID) == 4 ? MARSHAL_TYPE_GENERIC_4 : MARSHAL_TYPE_GENERIC_8);
            break;

        case ELEMENT_TYPE_U:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_UINT || nativeType == NATIVE_TYPE_INT || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_I;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = (sizeof(LPVOID) == 4 ? MARSHAL_TYPE_GENERIC_4 : MARSHAL_TYPE_GENERIC_8);
            break;


        case ELEMENT_TYPE_R4:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_R4 || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_R4;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_FLOAT;
            break;

        case ELEMENT_TYPE_R8:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_R8 || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_R8;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_DOUBLE;
            break;

        case ELEMENT_TYPE_R:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (nativeType != NATIVE_TYPE_DEFAULT)
            {
                m_resID = IDS_EE_BADPINVOKE_R;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = MARSHAL_TYPE_DOUBLE;
            break;

        case ELEMENT_TYPE_PTR:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (nativeType != NATIVE_TYPE_DEFAULT)
            {
                m_resID = IDS_EE_BADPINVOKE_PTR;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = ( (sizeof(void*)==4) ? MARSHAL_TYPE_GENERIC_4 : MARSHAL_TYPE_GENERIC_8 );
            break;

        case ELEMENT_TYPE_FNPTR:
            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
            if (!(nativeType == NATIVE_TYPE_FUNC || nativeType == NATIVE_TYPE_DEFAULT))
            {
                m_resID = IDS_EE_BADPINVOKE_FNPTR;
                IfFailGoto(E_FAIL, lFail);
            }
            m_type = ( (sizeof(void*)==4) ? MARSHAL_TYPE_GENERIC_4 : MARSHAL_TYPE_GENERIC_8 );
            break;

        case ELEMENT_TYPE_OBJECT:
        case ELEMENT_TYPE_STRING:
        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_VAR:
            {                
                IfFailGoto(QuickCOMStartup(), lFail);

                m_pClass = sig.GetTypeHandle(pModule).GetClass();
                if (m_pClass == NULL)
                {
                    IfFailGoto(COR_E_TYPELOAD, lFail);
                }

                if (nativeType == NATIVE_TYPE_INTF)
                {
                    // whatever...
                    if (sig.IsStringType(pModule))
                    {
                        m_resID = IDS_EE_BADPINVOKE_STRING;
                        IfFailGoto(E_FAIL, lFail);
                    }

                    REDUNDANCYWARNING(m_pClass->IsInterface());
                    m_type = MARSHAL_TYPE_INTERFACE;
                }
                else
                {
                    bool builder = false;
                    if (sig.IsStringType(pModule)
                        || ((builder = true), 0)
                        || sig.IsClass(pModule, g_StringBufferClassName)
                        || GetAppDomain()->IsSpecialStringClass(m_pClass->GetMethodTable())
                        || GetAppDomain()->IsSpecialStringBuilderClass(m_pClass->GetMethodTable())
                        )
                    {
                        BOOL            vbByValStr = FALSE; // specialcase
                        StringType      stype = enum_BSTR;


                        REDUNDANCYWARNING( (m_ms == MARSHAL_SCENARIO_NDIRECT && m_fAnsi && nativeType == NATIVE_TYPE_LPSTR) ||
                                           (m_ms == MARSHAL_SCENARIO_NDIRECT && !m_fAnsi && nativeType == NATIVE_TYPE_LPWSTR) ||
                                           (m_ms != MARSHAL_SCENARIO_NDIRECT && nativeType == NATIVE_TYPE_BSTR) );
        
                        switch ( nativeType )
                        {
                            case NATIVE_TYPE_BSTR:
                                if (builder)
                                {
                                    m_resID = IDS_EE_BADPINVOKE_STRINGBUILDER;
                                    IfFailGoto(E_FAIL, lFail);
                                }
                                stype = enum_BSTR;
                                break;
        
                            case NATIVE_TYPE_LPSTR:
                                stype = enum_CSTR;
                                break;
        
                            case NATIVE_TYPE_LPWSTR:
                                stype = enum_WSTR;
                                break;
        
                            case NATIVE_TYPE_ANSIBSTR:
                                if (builder)
                                {
                                    m_resID = IDS_EE_BADPINVOKE_STRINGBUILDER;
                                    IfFailGoto(E_FAIL, lFail);
                                }
                                stype = enum_AnsiBSTR;
                                break;
                               
                            case NATIVE_TYPE_TBSTR:
                                {
                                    static BOOL init = FALSE;
                                    static BOOL onUnicode;
        
                                    if (!init)
                                    {
                                        onUnicode = NDirectOnUnicodeSystem();
                                        init = TRUE;
                                    }
        
                                    if (builder)
                                    {
                                        m_resID = IDS_EE_BADPINVOKE_STRINGBUILDER;
                                        IfFailGoto(E_FAIL, lFail);
                                    }

        
                                    if (onUnicode)
                                        stype = enum_BSTR;
                                    else
                                        stype = enum_AnsiBSTR;
        
                                    break;
                                }
         
                            case NATIVE_TYPE_LPTSTR:
                                {
                                    if (m_ms == MARSHAL_SCENARIO_COMINTEROP)
                                    {
                                        // We disallow NATIVE_TYPE_LPTSTR for COM. 
                                        IfFailGoto(E_FAIL, lFail);
                                    }
                                    else
                                    {
                                        static BOOL init = FALSE;
                                        static BOOL onUnicode;
        
                                        if (!init)
                                        {
                                            onUnicode = NDirectOnUnicodeSystem();
                                            init = TRUE;
                                        }
        
                                        if (onUnicode)
                                            stype = enum_WSTR;
                                        else
                                            stype = enum_CSTR;
                                    }

                                    break;
                                }
        
                            case NATIVE_TYPE_BYVALSTR:
                                {
                                    if (!builder)
                                        vbByValStr = TRUE;
                                    else
                                        _ASSERTE(!"Error path needs fixing.");
                                    break;
                                }
        
                            case NATIVE_TYPE_DEFAULT:
                                switch (m_ms)
                                {
                                    case MARSHAL_SCENARIO_COMINTEROP:
                                        stype = builder ? enum_WSTR : enum_BSTR;
                                        break;
            
                                    case MARSHAL_SCENARIO_NDIRECT:
                                        stype = m_fAnsi ? enum_CSTR : enum_WSTR;
                                        break;
            
                                    default:
                                        _ASSERTE(0);
            
                                }
                                break;
        
                            default:
                                m_resID = builder ? IDS_EE_BADPINVOKE_STRINGBUILDER : IDS_EE_BADPINVOKE_STRING;
                                IfFailGoto(E_FAIL, lFail);
                                break;
                        }
        
                        if (vbByValStr)
                        {
                            m_type = m_fAnsi ? MARSHAL_TYPE_VBBYVALSTR : MARSHAL_TYPE_VBBYVALSTRW;
                        }
                        else
                        {
        
                            _ASSERTE(MARSHAL_TYPE_BSTR + enum_BSTR == (int) MARSHAL_TYPE_BSTR);
                            _ASSERTE(MARSHAL_TYPE_BSTR + enum_WSTR == (int) MARSHAL_TYPE_LPWSTR);
                            _ASSERTE(MARSHAL_TYPE_BSTR + enum_CSTR == (int) MARSHAL_TYPE_LPSTR);
                            _ASSERTE(MARSHAL_TYPE_BSTR + enum_AnsiBSTR == (int) MARSHAL_TYPE_ANSIBSTR);
        
                            _ASSERTE(MARSHAL_TYPE_BSTR_BUFFER + enum_BSTR == (int) MARSHAL_TYPE_BSTR_BUFFER);
                            _ASSERTE(MARSHAL_TYPE_BSTR_BUFFER + enum_WSTR == (int) MARSHAL_TYPE_LPWSTR_BUFFER);
                            _ASSERTE(MARSHAL_TYPE_BSTR_BUFFER + enum_CSTR == (int) MARSHAL_TYPE_LPSTR_BUFFER);
    
                            
                            if (GetAppDomain()->IsSpecialStringBuilderClass(m_pClass->GetMethodTable()))
                                m_type = (MarshalType) (MARSHAL_TYPE_BSTR_BUFFER_X + stype);
                            else 
                            if (GetAppDomain()->IsSpecialStringClass(m_pClass->GetMethodTable()))
                                m_type = (MarshalType) (MARSHAL_TYPE_BSTR_X + stype);
                            else 
                            if (builder)
                                m_type = (MarshalType) (MARSHAL_TYPE_BSTR_BUFFER + stype);
                            else
                                m_type = (MarshalType) (MARSHAL_TYPE_BSTR + stype);
                                
           
                            //if (m_byref) { m_type = MARSHAL_TYPE_VBBYVALSTR;  } 
                        }
                    }

                    else if (sig.IsClass(pModule, g_CollectionsEnumeratorClassName) && 
                             nativeType == NATIVE_TYPE_DEFAULT)
                    {
                        m_CMVt = VT_UNKNOWN;
                        m_type = MARSHAL_TYPE_REFERENCECUSTOMMARSHALER;
                        m_pCMHelper = SetupCustomMarshalerHelper(ENUMERATOR_TO_ENUM_VARIANT_CM_NAME, 
                                                                 ENUMERATOR_TO_ENUM_VARIANT_CM_NAME_LEN,
                                                                 ENUMERATOR_TO_ENUM_VARIANT_CM_COOKIE, 
                                                                 ENUMERATOR_TO_ENUM_VARIANT_CM_COOKIE_LEN, 
                                                                 pAssembly, sig.GetTypeHandle(pModule));
                    }
                    else if (m_pClass->IsInterface())
                    {
                        REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);

                        if (!(nativeType == NATIVE_TYPE_DEFAULT ||
                              nativeType == NATIVE_TYPE_INTF))
                        {
                            m_resID = IDS_EE_BADPINVOKE_INTERFACE;
                            IfFailGoto(E_FAIL, lFail);
                        }
                        m_type = MARSHAL_TYPE_INTERFACE;
                    }
                    else if (COMDelegate::IsDelegate(m_pClass))
                    {
                        switch (nativeType)
                        {
                            case NATIVE_TYPE_FUNC:
                                REDUNDANCYWARNING(m_ms == MARSHAL_SCENARIO_NDIRECT);
                                m_type = MARSHAL_TYPE_DELEGATE;
                                break;

                            case NATIVE_TYPE_DEFAULT:
                                m_type = (m_ms == MARSHAL_SCENARIO_NDIRECT) ? MARSHAL_TYPE_DELEGATE : MARSHAL_TYPE_INTERFACE;
                                break;

                            default:
                            m_resID = IDS_EE_BADPINVOKE_DELEGATE;
                            IfFailGoto(E_FAIL, lFail);
                                break;
                        }
                    }
                    else if (m_pClass->IsBlittable())
                    {
                        REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
    
                        if (!(nativeType == NATIVE_TYPE_DEFAULT || nativeType == NATIVE_TYPE_LPSTRUCT))
                        {
                            m_resID = IDS_EE_BADPINVOKE_CLASS;
                            IfFailGoto(E_FAIL, lFail);
                        }
                        m_type = MARSHAL_TYPE_BLITTABLEPTR;
                    }
                    else if (m_pClass->HasLayout())
                    {
                        REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);

                        if (!(nativeType == NATIVE_TYPE_DEFAULT || nativeType == NATIVE_TYPE_LPSTRUCT))
                        {
                            m_resID = IDS_EE_BADPINVOKE_CLASS;
                            IfFailGoto(E_FAIL, lFail);
                        }
                        m_type = MARSHAL_TYPE_LAYOUTCLASSPTR;
                    }    
    
                    else if (m_pClass->IsObjectClass()
                             || GetAppDomain()->IsSpecialObjectClass(m_pClass->GetMethodTable()))
                    {
                        switch(nativeType)
                        {
                            case NATIVE_TYPE_DEFAULT:
                            case NATIVE_TYPE_STRUCT:
                                REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                                m_type = MARSHAL_TYPE_OBJECT;
                                break;

                            case NATIVE_TYPE_INTF:
                            case NATIVE_TYPE_IUNKNOWN:
                                m_type = MARSHAL_TYPE_INTERFACE;
                                break;

                            case NATIVE_TYPE_IDISPATCH:
                                m_fDispIntf = TRUE;
                                m_type = MARSHAL_TYPE_INTERFACE;
                                break;

                            case NATIVE_TYPE_ASANY:
                                m_type = m_fAnsi ? MARSHAL_TYPE_ASANYA : MARSHAL_TYPE_ASANYW;
                                break;

                            default:
                                m_resID = IDS_EE_BADPINVOKE_OBJECT;
                                IfFailGoto(E_FAIL, lFail);
                        }
                    }
                   
                    else if (sig.IsClass(pModule, "System.Array"))
                    {
                        switch(nativeType)
                        {
                            case NATIVE_TYPE_DEFAULT:
                            case NATIVE_TYPE_INTF:
                                REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                                m_type = MARSHAL_TYPE_INTERFACE;
                                break;

                            case NATIVE_TYPE_SAFEARRAY:
                                // Handle retrieving the information for the array type.
                                IfFailGoto(HandleArrayElemType(achDbgContext, &ParamInfo, 0, TypeHandle(g_pObjectClass), -1, FALSE, isParam, TRUE, pAssembly), lFail);
                                break;

                            default:
                                IfFailGoto(E_FAIL, lFail);
                        }
                    }

                    else if (m_pClass->IsArrayClass())
                    {
                        _ASSERTE(!"This invalid signature should never be hit!");
                        IfFailGoto(E_FAIL, lFail);
                    }

                    else if (!m_pClass->IsValueClass())
                    {
                        if (!(nativeType == NATIVE_TYPE_INTF ||
                              (nativeType == NATIVE_TYPE_DEFAULT && m_ms == MARSHAL_SCENARIO_COMINTEROP))) 
                        {
                            m_resID = IDS_EE_BADPINVOKE_NOLAYOUT;
                            IfFailGoto(E_FAIL, lFail);
                        }
    
                        // default marshalling is interface
                        m_type = MARSHAL_TYPE_INTERFACE;
                    }

                    else
                    {
                        _ASSERTE(m_pClass->IsValueClass());
                        goto lValueClass;
                    }
                }
            }
            break;
    
        case ELEMENT_TYPE_VALUETYPE:
          lValueClass:
            {
                IfFailGoto(QuickCOMStartup(), lFail);

                if (sig.IsClass(pModule, g_DecimalClassName))
                {
                    switch (nativeType)
                    {
                        case NATIVE_TYPE_DEFAULT:
                        case NATIVE_TYPE_STRUCT:
                            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                            m_type = MARSHAL_TYPE_DECIMAL;
                            break;

                        case NATIVE_TYPE_LPSTRUCT:
                            m_type = MARSHAL_TYPE_DECIMAL_PTR;
                            break;

                        case NATIVE_TYPE_CURRENCY:
                            m_type = MARSHAL_TYPE_CURRENCY;
                            break;

                        default:
                            m_resID = IDS_EE_BADPINVOKE_DECIMAL;
                            IfFailGoto(E_FAIL, lFail);
                    }
                }
                else if (sig.IsClass(pModule, g_GuidClassName))
                {
                    switch (nativeType)
                    {
                        case NATIVE_TYPE_DEFAULT:
                        case NATIVE_TYPE_STRUCT:
                            REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                            m_type = MARSHAL_TYPE_GUID;
                            break;

                        case NATIVE_TYPE_LPSTRUCT:
                            m_type = MARSHAL_TYPE_GUID_PTR;
                            break;

                        default:
                            m_resID = IDS_EE_BADPINVOKE_GUID;
                            IfFailGoto(E_FAIL, lFail);
                    }
                }
                else if (sig.IsClass(pModule, g_DateClassName))
                {
                    REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                    if (!(nativeType == NATIVE_TYPE_DEFAULT || nativeType == NATIVE_TYPE_STRUCT))
                    {
                        m_resID = IDS_EE_BADPINVOKE_DATETIME;
                        IfFailGoto(E_FAIL, lFail);
                    }
                    m_type = MARSHAL_TYPE_DATE;
                }
                else if (sig.IsClass(pModule, "System.Runtime.InteropServices.ArrayWithOffset"))
                {
                    REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                    if (!(nativeType == NATIVE_TYPE_DEFAULT))
                    {
                        IfFailGoto(E_FAIL, lFail);
                    }
                    m_type = MARSHAL_TYPE_ARRAYWITHOFFSET;
                }
                else if (sig.IsClass(pModule, "System.Runtime.InteropServices.HandleRef"))
                {
                    REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                    if (!(nativeType == NATIVE_TYPE_DEFAULT))
                    {
                        IfFailGoto(E_FAIL, lFail);
                    }
                    m_type = MARSHAL_TYPE_HANDLEREF;
                }
                else if (sig.IsClass(pModule, "System.ArgIterator"))
                {
                    REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                    if (!(nativeType == NATIVE_TYPE_DEFAULT))
                    {
                        IfFailGoto(E_FAIL, lFail);
                    }
                    m_type = MARSHAL_TYPE_ARGITERATOR;
                }
                else if (sig.IsClass(pModule, "System.Drawing.Color"))
                {
                    REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                    if (!(nativeType == NATIVE_TYPE_DEFAULT))
                    {
                        IfFailGoto(E_FAIL, lFail);
                    }

                    // This is only supported for COM interop.
                    if (m_ms != MARSHAL_SCENARIO_COMINTEROP)
                    {
                        IfFailGoto(E_FAIL, lFail);
                    }

                    m_type = MARSHAL_TYPE_OLECOLOR;
                }
                else
                {
                    m_pClass = sig.GetTypeHandle(pModule).GetClass();
                    if (m_pClass == NULL)
                        break;

                    if (m_pClass->GetMethodTable()->GetNativeSize() > 0xfff0 ||
                        m_pClass->GetAlignedNumInstanceFieldBytes() > 0xfff0)
                    {
                        m_resID = IDS_EE_STRUCTTOOCOMPLEX;
                        IfFailGoto(E_FAIL, lFail);
                    }

    
                    if (m_pClass->IsBlittable())
                    {
                        REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                        if (!(nativeType == NATIVE_TYPE_DEFAULT || nativeType == NATIVE_TYPE_STRUCT))
                        {
                            m_resID = IDS_EE_BADPINVOKE_VALUETYPE;
                            IfFailGoto(E_FAIL, lFail);
                        }

                        if (m_byref && !isParam)
                        {
                            // Override the prohibition on byref returns so that IJW works
                            m_byref = FALSE;
                            m_type = ( (sizeof(void*)==4) ? MARSHAL_TYPE_GENERIC_4 : MARSHAL_TYPE_GENERIC_8 );
                        }
                        else
                        {
                            if (fNeedsCopyCtor)
                            {
                                MethodDesc *pCopyCtor;
                                MethodDesc *pDtor;
                                HRESULT hr = FindCopyCtor(pModule, m_pClass->GetMethodTable(), &pCopyCtor);
                                IfFailGoto(hr, lFail);
                                hr = FindDtor(pModule, m_pClass->GetMethodTable(), &pDtor);
                                IfFailGoto(hr, lFail);
    
                                m_args.mm.m_pMT = m_pClass->GetMethodTable();
                                m_args.mm.m_pCopyCtor = pCopyCtor;
                                m_args.mm.m_pDtor = pDtor;
                                m_type = MARSHAL_TYPE_BLITTABLEVALUECLASSWITHCOPYCTOR;
                            }
                            else
                            {
                                m_args.m_pMT = m_pClass->GetMethodTable();
                                m_type = MARSHAL_TYPE_BLITTABLEVALUECLASS;
                            }
                        }
                    }
                    else if (m_pClass->HasLayout())
                    {
                        REDUNDANCYWARNING(nativeType != NATIVE_TYPE_DEFAULT);
                        if (!(nativeType == NATIVE_TYPE_DEFAULT || nativeType == NATIVE_TYPE_STRUCT))
                        {
                            m_resID = IDS_EE_BADPINVOKE_VALUETYPE;
                            IfFailGoto(E_FAIL, lFail);
                        }

                        m_args.m_pMT = m_pClass->GetMethodTable();
                        m_type = MARSHAL_TYPE_VALUECLASS;
                    }
    
                }
                break;
            }
    
        case ELEMENT_TYPE_SZARRAY:
        case ELEMENT_TYPE_ARRAY:
            {
                // Get class info from array.
                TypeHandle arrayTypeHnd = sig.GetTypeHandle(pModule);
                if (arrayTypeHnd.IsNull())
                    IfFailGoto(COR_E_TYPELOAD, lFail);

                ArrayTypeDesc* asArray = arrayTypeHnd.AsArray();
                if (asArray == NULL)
                    IfFailGoto(E_FAIL, lFail);

                TypeHandle elemTypeHnd = asArray->GetTypeParam();

                unsigned ofs = 0;
                if (arrayTypeHnd.GetMethodTable())
                {
                    ofs = ArrayBase::GetDataPtrOffset(arrayTypeHnd.GetMethodTable());
                    if (ofs > 0xffff)
                    {
                        ofs = 0;   // can't represent it, so pass on magic value (which causes fallback to regular ML code)
                    }
                }

                // Handle retrieving the information for the array type.
                IfFailGoto(HandleArrayElemType(achDbgContext, &ParamInfo, (UINT16)ofs, elemTypeHnd, asArray->GetRank(), mtype == ELEMENT_TYPE_SZARRAY, isParam, FALSE, pAssembly), lFail);
            }
            break;
    
    
        default:
            m_resID = IDS_EE_BADPINVOKE_BADMANAGED;
            //     _ASSERTE(!"Unsupported type!");
    }

  lExit:

    if (m_byref && !isParam)
    {
        // byref returns don't work: the thing pointed to lives on
        // a stack that disappears!
        m_type = MARSHAL_TYPE_UNKNOWN;
        goto lReallyExit;
    }
    

    //---------------------------------------------------------------------
    // Now, figure out the IN/OUT status.
    //---------------------------------------------------------------------
    if (m_type != MARSHAL_TYPE_UNKNOWN && gInOnly[m_type] && !m_byref)
    {
        // If we got here, the parameter is something like an "int" where
        // [in] is the only semantically valid choice. Since there is no
        // possible way to interpret an [out] for such a type, we will ignore
        // the metadata and force the bits to "in". We could have defined
        // it as an error instead but this is less likely to cause problems
        // with metadata autogenerated from typelibs and poorly
        // defined C headers.
        // 
        m_in = TRUE;
        m_out = FALSE;
    }
    else
    {

        // Capture and save away "In/Out" bits. If none is present, set both to FALSE (they will be properly defaulted downstream)
        if (TypeFromToken(token) != mdtParamDef || token == mdParamDefNil)
        {
            m_in = FALSE;
            m_out = FALSE;
        }
        else
        {
            IMDInternalImport *pInternalImport = pModule->GetMDImport();
            USHORT             usSequence;
            DWORD              dwAttr;
        
            pInternalImport->GetParamDefProps(token, &usSequence, &dwAttr);
            m_in = IsPdIn(dwAttr) != 0;
            m_out = IsPdOut(dwAttr) != 0;
        }
        
        // If neither IN nor OUT are true, this signals the URT to use the default
        // rules.
        if (!m_in && !m_out)
        {
            if (m_byref || (mtype == ELEMENT_TYPE_CLASS && !(sig.IsStringType(pModule)) && sig.IsClass(pModule, g_StringBufferClassName)))
            {
                m_in = TRUE;
                m_out = TRUE;
            }
            else
            {
                m_in = TRUE;
                m_out = FALSE;
            }
        
        }
    }

#ifdef CUSTOMER_CHECKED_BUILD
    if (pMD != NULL)
        OutputCustomerCheckedBuildMarshalInfo(pMD, sig, pModule, corElemType, ParamInfo.m_SizeIsSpecified);
#endif

lReallyExit:

#ifdef _DEBUG
    DumpMarshalInfo(pModule, sig, token, ms, nlType, nlFlags); 
#endif
    return;


  lFail:
    // We got here because of an illegal ELEMENT_TYPE/NATIVE_TYPE combo.
    m_type = MARSHAL_TYPE_UNKNOWN;
    //_ASSERTE(!"Invalid ELEMENT_TYPE/NATIVE_TYPE combination");
    goto lExit;
}

HRESULT MarshalInfo::HandleArrayElemType(char *achDbgContext, NativeTypeParamInfo *pParamInfo, UINT16 optbaseoffset,  TypeHandle elemTypeHnd, int iRank, BOOL fNoLowerBounds, BOOL isParam, BOOL isSysArray, Assembly *pAssembly)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;

    _ASSERTE(pParamInfo && !elemTypeHnd.IsNull());


    //
    // Store the element type handle and determine the element type from the type handle.
    //

    m_hndArrayElemType = elemTypeHnd;
    m_iArrayRank = iRank;
    CorElementType elemType = elemTypeHnd.GetNormCorElementType();
    m_nolowerbounds = fNoLowerBounds;


    //
    // The marshaling code doesn't deal with nested array's.
    //

    if (elemTypeHnd.IsArray())
    {
        m_resID = IDS_EE_BADPINVOKE_ARRAY;
        IfFailGo(E_FAIL);
    }


    //
    // Determine which type of marshaler to use.
    //

    if (pParamInfo->m_NativeType == NATIVE_TYPE_ARRAY)
    {
        REDUNDANCYWARNING(m_ms == MARSHAL_SCENARIO_NDIRECT);
        m_type = MARSHAL_TYPE_NATIVEARRAY;
    }
    else if (pParamInfo->m_NativeType == NATIVE_TYPE_SAFEARRAY)
    {
        REDUNDANCYWARNING(m_ms == MARSHAL_SCENARIO_COMINTEROP);
        m_type = MARSHAL_TYPE_SAFEARRAY;
    }
    else if (pParamInfo->m_NativeType == NATIVE_TYPE_DEFAULT)
    {
        switch (m_ms)
        {
            case MARSHAL_SCENARIO_COMINTEROP:
                m_type = MARSHAL_TYPE_SAFEARRAY;
                break;

            case MARSHAL_SCENARIO_NDIRECT:
                m_type = MARSHAL_TYPE_NATIVEARRAY;
                break;

            default:
                _ASSERTE(0);
        }
    }
    else
    {
        m_resID = IDS_EE_BADPINVOKE_ARRAY;
        IfFailGo(E_FAIL);
    }


    //
    // Determine the VARTYPE of the elements in the array.
    //

    if (pParamInfo->m_SafeArrayElementVT != VT_EMPTY)
    {
        _ASSERTE(m_type == MARSHAL_TYPE_SAFEARRAY);
        m_arrayElementType = pParamInfo->m_SafeArrayElementVT;

        if ((pParamInfo->m_cSafeArrayUserDefTypeNameBytes > 0) && isSysArray)
        {
            // Append a NULL terminator to the user defined type name.
            CQuickArray<char> strUserDefTypeName;
            strUserDefTypeName.ReSize(pParamInfo->m_cSafeArrayUserDefTypeNameBytes + 1);
            memcpy(strUserDefTypeName.Ptr(), pParamInfo->m_strSafeArrayUserDefTypeName, pParamInfo->m_cSafeArrayUserDefTypeNameBytes);
            strUserDefTypeName[pParamInfo->m_cSafeArrayUserDefTypeNameBytes] = 0;

            // Load the user defined type. 
            OBJECTREF Throwable = NULL;
            GCPROTECT_BEGIN(Throwable)
            {
                m_hndArrayElemType = SystemDomain::GetCurrentDomain()->FindAssemblyQualifiedTypeHandle(strUserDefTypeName.Ptr(), true, pAssembly, NULL, &Throwable);
                if (m_hndArrayElemType.IsNull())
                    COMPlusThrow(Throwable);
            }
            GCPROTECT_END();

            _ASSERTE(m_hndArrayElemType.IsEnum() || m_arrayElementType == VT_RECORD || m_arrayElementType == VT_DISPATCH || m_arrayElementType == VT_UNKNOWN);
        }
    }
    else
    {
        if (elemType <= ELEMENT_TYPE_R8)
        {
            static const BYTE map [] =
            {
                VT_NULL,    // ELEMENT_TYPE_END
                VT_NULL,    // ELEMENT_TYPE_VOID
                VT_BOOL,    // ELEMENT_TYPE_BOOLEAN
                VT_UI2,     // ELEMENT_TYPE_CHAR // todo: ???
                VT_I1,      // ELEMENT_TYPE_I1
                VT_UI1,     // ELEMENT_TYPE_U1
                VT_I2,      // ELEMENT_TYPE_I2
                VT_UI2,     // ELEMENT_TYPE_U2
                VT_I4,      // ELEMENT_TYPE_I4
                VT_UI4,     // ELEMENT_TYPE_U4
                VT_I8,      // ELEMENT_TYPE_I8
                VT_UI8,     // ELEMENT_TYPE_U8
                VT_R4,      // ELEMENT_TYPE_R4
                VT_R8       // ELEMENT_TYPE_R8

            };
            m_arrayElementType = map[elemType];

            if (m_ms == MARSHAL_SCENARIO_NDIRECT && m_type == MARSHAL_TYPE_NATIVEARRAY)
            {
                if (m_arrayElementType == VT_BOOL)
                {
                    m_arrayElementType = VTHACK_WINBOOL;
                }
                else if (elemType == ELEMENT_TYPE_CHAR && m_fAnsi)
                {
                    m_arrayElementType = VTHACK_ANSICHAR;

                    if (!isParam)
                    {
                        // This char[]->ansichar[] thing can only work as a
                        // parameter (and in the managed->unmanaged direction at that.)
                        // This puppy really is a ill-defined pairing and we should
                        // try to shoot it if we can.
                        IfFailGo(E_FAIL);
                    }
                }
            }
        }
        else if (elemType == ELEMENT_TYPE_I)
        {
            m_arrayElementType = (sizeof(LPVOID) == 4) ? VT_I4 : VT_I8;
        }
        else if (elemType == ELEMENT_TYPE_U)
        {
            m_arrayElementType = (sizeof(LPVOID) == 4) ? VT_UI4 : VT_UI8;
        }
        else
        {
            if (elemTypeHnd == TypeHandle(g_pStringClass))
            {           
                switch (pParamInfo->m_ArrayElementType)
                {
                    case NATIVE_TYPE_DEFAULT:
                        if (m_type == MARSHAL_TYPE_SAFEARRAY || m_ms == MARSHAL_SCENARIO_COMINTEROP)
                            m_arrayElementType = VT_BSTR;
                        else
                            m_arrayElementType = m_fAnsi ? VT_LPSTR : VT_LPWSTR;
                        break;
                    case NATIVE_TYPE_BSTR:
                        m_arrayElementType = VT_BSTR;
                        break;
                    case NATIVE_TYPE_LPSTR:
                        m_arrayElementType = VT_LPSTR;
                        break;
                    case NATIVE_TYPE_LPWSTR:
                        m_arrayElementType = VT_LPWSTR;
                        break;
                    case NATIVE_TYPE_LPTSTR:
                        {
                            if (m_ms == MARSHAL_SCENARIO_COMINTEROP)
                            {
                                // We disallow NATIVE_TYPE_LPTSTR for COM. 
                                IfFailGo(E_FAIL);
                            }
                            else
                            {
                                static BOOL init = FALSE;
                                static BOOL onUnicode;
                    
                                if (!init)
                                {
                                    onUnicode = NDirectOnUnicodeSystem();
                                    init = TRUE;
                                }
                    
                                if (onUnicode)
                                    m_arrayElementType = VT_LPWSTR;
                                else
                                    m_arrayElementType = VT_LPSTR;
                            }
                        }
                        break;
                    default:
                        m_arrayElementType = VT_NULL;
                }
            }
            else if (elemTypeHnd == TypeHandle(g_pObjectClass))
            {
                switch(pParamInfo->m_ArrayElementType)
                {
                    case NATIVE_TYPE_DEFAULT:
                    case NATIVE_TYPE_STRUCT:
                        REDUNDANCYWARNING(pParamInfo->m_ArrayElementType != NATIVE_TYPE_DEFAULT);
                        m_arrayElementType = VT_VARIANT;
                        break;

                    case NATIVE_TYPE_INTF:
                    case NATIVE_TYPE_IUNKNOWN:
                        m_arrayElementType = VT_UNKNOWN;
                        break;

                    case NATIVE_TYPE_IDISPATCH:
                        m_arrayElementType = VT_DISPATCH;
                        break;

                    default:
                        IfFailGo(E_FAIL);
                }

                // We are going to do VARIANT or IP marshalling so we need to start COM up.
                IfFailGo(QuickCOMStartup());
            }
            else if (elemType == ELEMENT_TYPE_VALUETYPE) 
            {
                m_arrayElementType = OleVariant::GetVarTypeForTypeHandle(elemTypeHnd);
            }
            else
            {
                m_arrayElementType = VT_UNKNOWN;

                // We are going to do IP marshalling so we need to start COM up.
                IfFailGo(QuickCOMStartup());
            }
        }
    }


    //
    // Do any extra work required by the array type.
    //

    if (m_type == MARSHAL_TYPE_NATIVEARRAY)
    {
        // Retrieve the extra information associated with the native array marshaling.
        m_args.na.m_vt  = m_arrayElementType;
        m_args.na.m_pMT = elemTypeHnd.IsUnsharedMT() ? elemTypeHnd.AsMethodTable() : NULL;   
        m_args.na.m_optionalbaseoffset = optbaseoffset;
        m_countParamIdx = pParamInfo->m_CountParamIdx;
        m_multiplier    = pParamInfo->m_Multiplier;
        m_additive      = pParamInfo->m_Additive;
    }
    else
    {
        // We are going to do SAFEARRAY marshalling so we need to start COM up.
        IfFailGo(QuickCOMStartup());
    }

ErrExit:
    return hr;
}



VOID ThrowInteropParamException(UINT resID, UINT paramIdx)
{
    THROWSCOMPLUSEXCEPTION();

    if (paramIdx == 0)
    {
        COMPlusThrow(kMarshalDirectiveException, resID, L"return value");
    }
    else
    {
        WCHAR buf[50];
        Wszwsprintf(buf, L"parameter #%u", paramIdx);

        COMPlusThrow(kMarshalDirectiveException, resID, buf);
    }
}


void MarshalInfo::GenerateArgumentML(MLStubLinker *psl,
                                       MLStubLinker *pslPost,
                                       BOOL comToNative)
{

    THROWSCOMPLUSEXCEPTION();
    if (m_type == MARSHAL_TYPE_UNKNOWN)
    {
        if (m_ms != MARSHAL_SCENARIO_COMINTEROP)
        {
            ThrowInteropParamException(m_resID, m_paramidx);
        }
        if (psl)
        {
            psl->MLEmit(ML_THROWINTEROPPARAM);
            psl->Emit32(m_resID);
            psl->Emit32(m_paramidx);
        }
        return;

    }

    //
    // Use simple copy opcodes if possible.
    //

    if (!m_byref && m_type <= MARSHAL_TYPE_DOUBLE)
    {
        UINT16 size = 0;
        int opcode = 0;

        switch (m_type)
        {
        case MARSHAL_TYPE_GENERIC_1:
            if (!comToNative)
            {
                opcode = ML_COPYI1;
                size = 1;
                break;
            }
            // fall through

        case MARSHAL_TYPE_GENERIC_U1:
            if (!comToNative)
            {
                opcode = ML_COPYU1;
                size = 1;
                break;
            }
            // fall through

        case MARSHAL_TYPE_GENERIC_2:
            if (!comToNative)
            {
                opcode = ML_COPYI2;
                size = 2;
                break;
            }
            // fall through

        case MARSHAL_TYPE_GENERIC_U2:
            if (!comToNative)
            {
                opcode = ML_COPYU2;
                size = 2;
                break;
            }
            // fall through

    
        case MARSHAL_TYPE_GENERIC_4:
        case MARSHAL_TYPE_FLOAT:
            opcode = ML_COPY4;
            size = 4;
            break;

        case MARSHAL_TYPE_GENERIC_8:
        case MARSHAL_TYPE_DOUBLE:
            opcode = ML_COPY8;
            size = 8;
            break;

        case MARSHAL_TYPE_CBOOL:
            opcode = comToNative ? ML_CBOOL_C2N : ML_CBOOL_N2C;
            size = 1;
        }


        if (size != 0)
        {
            if (psl)
            psl->MLEmit(opcode);
            m_comArgSize = StackElemSize(size);
            m_nativeArgSize = MLParmSize(size);
            return;
        }
    }



    if (m_byref)
    {
        m_comArgSize = StackElemSize(sizeof(void*));
        m_nativeArgSize = MLParmSize(sizeof(void*));
    }
    else
    {
        m_comArgSize = StackElemSize(comSize(m_type));
        m_nativeArgSize = MLParmSize(nativeSize(m_type));
    }

    if (! psl)
        return;

    Marshaler::ArgumentMLOverrideStatus amostat;
    UINT resID = IDS_EE_BADPINVOKE_RESTRICTION;
    amostat = (gArgumentMLOverride[m_type]) (psl,
                                             pslPost,
                                             m_byref,
                                             m_in,
                                             m_out,
                                             comToNative,
                                             &m_args,
                                             &resID);
    
    if (amostat == Marshaler::DISALLOWED)
    {
        if (m_ms != MARSHAL_SCENARIO_COMINTEROP)
        {
            ThrowInteropParamException(resID, m_paramidx);
        }
        if (psl)
        {
            psl->MLEmit(ML_THROWINTEROPPARAM);
            psl->Emit32(resID);
            psl->Emit32(m_paramidx);
        }
        return;
    }

    if (amostat == Marshaler::HANDLEASNORMAL)
    {
        //
        // Emit marshaler creation opcode
        //
    
        UINT16 local = EmitCreateOpcode(psl);
    
        //
        // Emit Marshal opcode
        //
    
        BYTE marshal = (comToNative ? ML_MARSHAL_C2N : ML_MARSHAL_N2C);
        if (m_byref)
            marshal += 2;
        if (!m_in)
            marshal++;
    
        psl->MLEmit(marshal);
    
    
        //
        // Emit Unmarshal opcode
        //
    
        int index = 0;
        if (m_byref)
            index += 3;
        if (m_out)
        {
            index++;
            if (m_in)
                index++;
        }
    
        if (comToNative
            ? ((m_unmarshalC2NNeeded[m_type])&(1<<index))
            : ((m_unmarshalN2CNeeded[m_type])&(1<<index)))
        {
            BYTE unmarshal = (comToNative ? ML_UNMARSHAL_C2N_IN : ML_UNMARSHAL_N2C_IN) + index;
    
            pslPost->MLEmit(unmarshal);
            pslPost->Emit16(local);
        }
    }
}

void MarshalInfo::GenerateReturnML(MLStubLinker *psl,
                                     MLStubLinker *pslPost,
                                     BOOL comToNative,
                                     BOOL retval)
{
    THROWSCOMPLUSEXCEPTION();

    Marshaler::ArgumentMLOverrideStatus amostat;
    UINT resID = IDS_EE_BADPINVOKE_RESTRICTION;

    if (m_type == MARSHAL_TYPE_UNKNOWN)
    {
       amostat = Marshaler::HANDLEASNORMAL;
    }
    else
    {
       amostat = (gReturnMLOverride[m_type]) (psl,
                                              pslPost,
                                              comToNative,
                                              retval,
                                              &m_args,
                                              &resID);
    }

    if (amostat == Marshaler::DISALLOWED)
    {
        if (m_ms != MARSHAL_SCENARIO_COMINTEROP)
        {
            ThrowInteropParamException(resID, 0);
        }
        if (psl)
        {
            psl->MLEmit(ML_THROWINTEROPPARAM);
            psl->Emit32(resID);
            psl->Emit32(0);
        }
        return;
    }
    else if (amostat == Marshaler::OVERRIDDEN)
    {
        if (retval)
            m_nativeArgSize = MLParmSize(sizeof(void *));
    
        if (m_returnsComByref[m_type])
            m_comArgSize = StackElemSize(sizeof(void *));
    }
    else
    {
        _ASSERTE(amostat == Marshaler::HANDLEASNORMAL);

    
        if (m_type == MARSHAL_TYPE_UNKNOWN || m_type == MARSHAL_TYPE_NATIVEARRAY)
        {
            if (m_ms != MARSHAL_SCENARIO_COMINTEROP)
            {
                ThrowInteropParamException(m_resID, 0);
            }
            if (psl)
            {
                psl->MLEmit(ML_THROWINTEROPPARAM);
                psl->Emit32(m_resID);
                psl->Emit32(0);
            }
            return;
        }
    
    
        //
        // Use simple copy opcodes if possible.
        //
    
        if (m_type <= MARSHAL_TYPE_DOUBLE)
        {
            if (retval)
            {
                if (comToNative)
                {
    
                    // Calling from COM to Native: getting returnval thru buffer.
                    _ASSERTE(comToNative && retval);
    
                    int pushOpcode = ML_END;
                    int copyOpcode = 0;
    
                    switch (m_type)
                    {
                    case MARSHAL_TYPE_GENERIC_1:
                        pushOpcode = ML_PUSHRETVALBUFFER1;
                        copyOpcode = ML_COPYI1;
                        break;
    
                    case MARSHAL_TYPE_GENERIC_U1:
                        pushOpcode = ML_PUSHRETVALBUFFER1;
                        copyOpcode = ML_COPYU1;
                        break;
    
                    case MARSHAL_TYPE_GENERIC_2:
                        pushOpcode = ML_PUSHRETVALBUFFER2;
                        copyOpcode = ML_COPYI2;
                        break;
    
                    case MARSHAL_TYPE_GENERIC_U2:
                        pushOpcode = ML_PUSHRETVALBUFFER2;
                        copyOpcode = ML_COPYU2;
                        break;
    
                    case MARSHAL_TYPE_GENERIC_4:
                        pushOpcode = ML_PUSHRETVALBUFFER4;
                        copyOpcode = ML_COPY4;
                        break;
    
                    case MARSHAL_TYPE_GENERIC_8:
                        pushOpcode = ML_PUSHRETVALBUFFER8;
                        copyOpcode = ML_COPY8;
                        break;
    
                    case MARSHAL_TYPE_WINBOOL:
                        pushOpcode = ML_PUSHRETVALBUFFER4;
                        copyOpcode = ML_BOOL_N2C;
                        break;
    
                    case MARSHAL_TYPE_CBOOL:
                        pushOpcode = ML_PUSHRETVALBUFFER1;
                        copyOpcode = ML_CBOOL_N2C;
                        break;
    
    
                    default:
                        break;
                    }
    
                    if (pushOpcode != ML_END)
                    {
                        if (psl)
                        {
                        psl->MLEmit(pushOpcode);
                        UINT16 local = psl->MLNewLocal(sizeof(RetValBuffer));
    
                        pslPost->MLEmit(ML_SETSRCTOLOCAL);
                        pslPost->Emit16(local);
                        pslPost->MLEmit(copyOpcode);
                        }
    
                        m_nativeArgSize = MLParmSize(sizeof(void*));
    
                        return;
                    }
                }
                else
                {
    
                    // Calling from Native to COM: getting returnval thru buffer.
                    _ASSERTE(!comToNative && retval);
    
                    int copyOpcode = ML_END;
    
                    switch (m_type)
                    {
                    case MARSHAL_TYPE_GENERIC_4:
                        copyOpcode = ML_COPY4;
                        break;
    
                    case MARSHAL_TYPE_GENERIC_8:
                        copyOpcode = ML_COPY8;
                        break;
    
                    case MARSHAL_TYPE_FLOAT:
                        copyOpcode = ML_COPY4;
                        break;
    
                    case MARSHAL_TYPE_DOUBLE:
                        copyOpcode = ML_COPY8;
                        break;
    
                    case MARSHAL_TYPE_CBOOL:
                        copyOpcode = ML_CBOOL_C2N;
                        break;
    
                    default:
                        break;
                    }
    
                    if (copyOpcode != ML_END)
                    {
                        if (pslPost)
                        pslPost->MLEmit(copyOpcode);
    
                        m_nativeArgSize = MLParmSize(sizeof(void*));
    
                        return;
                    }
                }
            }
            else if (!retval)
            {
                // Getting return value thru eax:edx. This code path handles
                // both COM->Native && Native->COM.
                _ASSERTE(!retval);
    
                if (!psl)
                    return;
    
                switch (m_type)
                {
    
    #ifdef WRONGCALLINGCONVENTIONHACK
                case MARSHAL_TYPE_GENERIC_1:
                    pslPost->MLEmit(comToNative ? ML_COPYI1 : ML_COPY4);
                    return;
    
                case MARSHAL_TYPE_GENERIC_U1:
                    pslPost->MLEmit(comToNative ? ML_COPYU1 : ML_COPY4);
                    return;
    
                case MARSHAL_TYPE_GENERIC_2:
                    pslPost->MLEmit(comToNative ? ML_COPYI2 : ML_COPY4);
                    return;
    
                case MARSHAL_TYPE_GENERIC_U2:
                    pslPost->MLEmit(comToNative ? ML_COPYU2 : ML_COPY4);
                    return;
    
    #else
                case MARSHAL_TYPE_GENERIC_1:
                case MARSHAL_TYPE_GENERIC_U1:
                case MARSHAL_TYPE_GENERIC_2:
                case MARSHAL_TYPE_GENERIC_U2:
                    pslPost->MLEmit(ML_COPY4);
                    return;
    #endif
    
                case MARSHAL_TYPE_WINBOOL:
                    pslPost->MLEmit(ML_BOOL_N2C);
                    return;
    
                case MARSHAL_TYPE_CBOOL:
                    pslPost->MLEmit(comToNative ? ML_CBOOL_N2C : ML_CBOOL_C2N);
                    return;
    
                case MARSHAL_TYPE_GENERIC_4:
                    pslPost->MLEmit(ML_COPY4);
                    return;
    
                case MARSHAL_TYPE_GENERIC_8:
                    pslPost->MLEmit(ML_COPY8);
                    return;
    
                case MARSHAL_TYPE_FLOAT:
                    pslPost->MLEmit(ML_COPY4);
                    return;
    
                case MARSHAL_TYPE_DOUBLE:
                    pslPost->MLEmit(ML_COPY8);
                    return;
                }
            }
        }
    
        //
        // Compute sizes
        //
    
        if (retval)
            m_nativeArgSize = MLParmSize(sizeof(void *));
    
        if (m_returnsComByref[m_type])
            m_comArgSize = StackElemSize(sizeof(void *));
    
        if (!psl)
            return;
    
        //
        // Emit marshaler creation opcode
        //
    
        UINT16 local = EmitCreateOpcode(psl);
    
        //
        // Emit prereturn opcode, if necessary
        //
    
        if (retval || m_returnsComByref[m_type])
        {
            BYTE prereturn = comToNative ? ML_PRERETURN_C2N : ML_PRERETURN_N2C;
            if (retval)
                prereturn++;
    
            psl->MLEmit(prereturn);
        }
    
        //
        // Emit return opcode
        //
    
        BYTE return_ = comToNative ? ML_RETURN_C2N : ML_RETURN_N2C;
        if (retval)
            return_++;
        pslPost->MLEmit(return_);
        pslPost->Emit16(local);
    }
}

void MarshalInfo::GenerateSetterML(MLStubLinker *psl,
                                   MLStubLinker *pslPost)
{
    THROWSCOMPLUSEXCEPTION();
    if (m_type == MARSHAL_TYPE_UNKNOWN)
    {
        COMPlusThrow(kMarshalDirectiveException, IDS_EE_COM_UNSUPPORTED_SIG);
    }

    if (psl)
    {
        EmitCreateOpcode(psl);
        psl->MLEmit(ML_SET_COM);
    }

    m_nativeArgSize = MLParmSize(nativeSize(m_type));
}

void MarshalInfo::GenerateGetterML(MLStubLinker *psl,
                                   MLStubLinker *pslPost,
                                   BOOL retval)
{
    THROWSCOMPLUSEXCEPTION();
    if (m_type == MARSHAL_TYPE_UNKNOWN)
    {
        COMPlusThrow(kMarshalDirectiveException, IDS_EE_COM_UNSUPPORTED_SIG);
    }

    if (retval)
    {
        if (psl)
        {
            EmitCreateOpcode(psl);
            psl->MLEmit(ML_PREGET_COM_RETVAL);
        }
        m_nativeArgSize = MLParmSize(sizeof(void*));
    }
    else if (psl)
    {
        EmitCreateOpcode(pslPost);
        pslPost->MLEmit(ML_GET_COM);
    }
}

UINT16 MarshalInfo::EmitCreateOpcode(MLStubLinker *psl)
{
    THROWSCOMPLUSEXCEPTION();

    psl->MLEmit(ML_CREATE_MARSHALER_GENERIC_1 + m_type);
    UINT16 local = psl->MLNewLocal(m_localSizes[m_type]);

    switch (m_type)
    {
    default:
        break;


    // Fall through to include the mapping info.
    case MARSHAL_TYPE_LPSTR_X :
    case MARSHAL_TYPE_LPSTR_BUFFER_X :
        psl->Emit32((INT32)(size_t)m_pClass->GetMethodTable());

    case MARSHAL_TYPE_ANSICHAR:
    case MARSHAL_TYPE_LPSTR:
    case MARSHAL_TYPE_ANSIBSTR:
    case MARSHAL_TYPE_LPSTR_BUFFER:
        psl->Emit8((UINT8) (m_BestFit));
        psl->Emit8((UINT8) (m_ThrowOnUnmappableChar));
        break;
    
#if defined(CHECK_FOR_VALID_VARIANTS)
    case MARSHAL_TYPE_OBJECT:
        psl->Emit32((INT32)(size_t)m_strDebugClassName);
        psl->Emit32((INT32)(size_t)m_strDebugMethName);
        psl->Emit32((INT32)m_iArg);
        break;
#endif

    case MARSHAL_TYPE_INTERFACE:
    {
        MethodTable *pItfMT = NULL;
        MethodTable *pClassMT = NULL;
        BOOL fDispItf = FALSE;
        BOOL fClassIsHint = FALSE;
        GetItfMarshalInfo(&pItfMT, &pClassMT, &fDispItf, &fClassIsHint);
        psl->Emit32((INT32)(size_t)pClassMT);
        psl->Emit32((INT32)(size_t)pItfMT);
        psl->Emit8((UINT8)fDispItf);
        psl->Emit8((UINT8)fClassIsHint);
        break;
    }

    case MARSHAL_TYPE_SAFEARRAY:
        psl->Emit32((INT32)(size_t)m_hndArrayElemType.AsMethodTable());
        psl->Emit8((UINT8) m_arrayElementType);
        psl->Emit32((INT32) m_iArrayRank);
        psl->Emit8((UINT8) !!m_nolowerbounds);
        break;

    case MARSHAL_TYPE_NATIVEARRAY:
        ML_CREATE_MARSHALER_CARRAY_OPERANDS mops;
        mops.methodTable = m_hndArrayElemType.AsMethodTable();
        mops.elementType = m_arrayElementType;
        mops.countParamIdx = m_countParamIdx;
        mops.countSize   = 0; //placeholder for later patching (if left unpatched, this value signals marshaler to use managed size of array)
        mops.multiplier  = m_multiplier;
        mops.additive    = m_additive;
        mops.bestfitmapping = m_BestFit;
        mops.throwonunmappablechar = m_ThrowOnUnmappableChar;
        psl->EmitBytes((const BYTE*)&mops, sizeof(mops));
        break;
     
    case MARSHAL_TYPE_BLITTABLEPTR:
    case MARSHAL_TYPE_LAYOUTCLASSPTR:
    case MARSHAL_TYPE_BSTR_X :
    case MARSHAL_TYPE_LPWSTR_X :
    case MARSHAL_TYPE_BSTR_BUFFER_X :
    case MARSHAL_TYPE_LPWSTR_BUFFER_X :
        psl->Emit32((INT32)(size_t)m_pClass->GetMethodTable());
        break;

    case MARSHAL_TYPE_REFERENCECUSTOMMARSHALER:
    case MARSHAL_TYPE_VALUECLASSCUSTOMMARSHALER:
        psl->Emit32((INT32)(size_t)m_pCMHelper);
        break;

    case MARSHAL_TYPE_UNKNOWN:
        COMPlusThrow(kMarshalDirectiveException, IDS_EE_COM_UNSUPPORTED_SIG);
    }

    return local;
}

DispParamMarshaler *MarshalInfo::GenerateDispParamMarshaler()
{
    DispParamMarshaler *pDispParamMarshaler = NULL;

    switch (m_type)
    {
        case MARSHAL_TYPE_OLECOLOR:
            pDispParamMarshaler = new DispParamOleColorMarshaler();
            break;

        case MARSHAL_TYPE_CURRENCY:
            pDispParamMarshaler = new DispParamCurrencyMarshaler();
            break;

        case MARSHAL_TYPE_GENERIC_4:
            if (m_fErrorNativeType)
                pDispParamMarshaler = new DispParamErrorMarshaler();
            break;

        case MARSHAL_TYPE_INTERFACE:
            {
                MethodTable *pItfMT = NULL;
                MethodTable *pClassMT = NULL;
                BOOL fDispItf = FALSE;
                BOOL fClassIsHint = FALSE;
                GetItfMarshalInfo(&pItfMT, &pClassMT, &fDispItf, &fClassIsHint);
                pDispParamMarshaler = new DispParamInterfaceMarshaler(fDispItf, pItfMT, pClassMT, fClassIsHint);
                break;
            }

        case MARSHAL_TYPE_VALUECLASS:
        case MARSHAL_TYPE_BLITTABLEVALUECLASS:
        case MARSHAL_TYPE_BLITTABLEPTR:
        case MARSHAL_TYPE_LAYOUTCLASSPTR:
        case MARSHAL_TYPE_BLITTABLEVALUECLASSWITHCOPYCTOR:
            pDispParamMarshaler = new DispParamRecordMarshaler(m_pClass->GetMethodTable());
            break;

        case MARSHAL_TYPE_SAFEARRAY:
            pDispParamMarshaler = new DispParamArrayMarshaler(m_arrayElementType, m_hndArrayElemType.GetMethodTable());
            break;

        case MARSHAL_TYPE_REFERENCECUSTOMMARSHALER:
        case MARSHAL_TYPE_VALUECLASSCUSTOMMARSHALER:
            pDispParamMarshaler = new DispParamCustomMarshaler(m_pCMHelper, m_CMVt);
            break;
    }

    return pDispParamMarshaler;
}


DispatchWrapperType MarshalInfo::GetDispWrapperType()
{
    DispatchWrapperType WrapperType = (DispatchWrapperType)0;

    switch (m_type)
    {
        case MARSHAL_TYPE_CURRENCY:
            WrapperType = DispatchWrapperType_Currency;
            break;

        case MARSHAL_TYPE_GENERIC_4:
            if (m_fErrorNativeType)
                WrapperType = DispatchWrapperType_Error;
            break;

        case MARSHAL_TYPE_INTERFACE:
            if (m_pClass->IsObjectClass() || GetAppDomain()->IsSpecialObjectClass(m_pClass->GetMethodTable()))
                WrapperType = m_fDispIntf ? DispatchWrapperType_Dispatch : DispatchWrapperType_Unknown;
            break;

        case MARSHAL_TYPE_SAFEARRAY:
            switch (m_arrayElementType)
            {
                case VT_CY:
                    WrapperType = (DispatchWrapperType)(DispatchWrapperType_SafeArray | DispatchWrapperType_Currency);
                    break;
                case VT_UNKNOWN:
                    WrapperType = (DispatchWrapperType)(DispatchWrapperType_SafeArray | DispatchWrapperType_Unknown);
                    break;
                case VT_DISPATCH:
                    WrapperType = (DispatchWrapperType)(DispatchWrapperType_SafeArray | DispatchWrapperType_Dispatch);
                    break;
                case VT_ERROR:
                    WrapperType = (DispatchWrapperType)(DispatchWrapperType_SafeArray | DispatchWrapperType_Error);
                    break;
            }
            break;
    }

    return WrapperType;
}

void MarshalInfo::GetItfMarshalInfo(MethodTable **ppItfMT, MethodTable **ppClassMT, BOOL *pfDispItf, BOOL *pfClassIsHint)
{
    _ASSERTE(ppItfMT);
    _ASSERTE(ppClassMT);
    _ASSERTE(pfDispItf);
    _ASSERTE(pfClassIsHint);
    _ASSERTE(m_type == MARSHAL_TYPE_INTERFACE);

    // Initialize the output parameters.
    *ppItfMT = NULL;
    *ppClassMT = NULL;
    *pfDispItf = FALSE;
    *pfClassIsHint = FALSE;

    if (!m_pClass->IsInterface())
    {
        // Set the class method table.
        *ppClassMT = m_pClass->GetMethodTable();

        // If the parameter is not System.Object.
        if (!m_pClass->IsObjectClass())
        {
            // Retrieve the default interface method table.
            TypeHandle hndDefItfClass;
            DefaultInterfaceType DefItfType = GetDefaultInterfaceForClass(TypeHandle(m_pClass), &hndDefItfClass);
            switch (DefItfType)
            {
                case DefaultInterfaceType_Explicit:
                {
                    *ppItfMT = hndDefItfClass.GetMethodTable();
                    *pfDispItf = (hndDefItfClass.GetMethodTable()->GetComInterfaceType() != ifVtable);
                    break;
                }

                case DefaultInterfaceType_AutoDual:
                {
                    *ppItfMT = hndDefItfClass.GetMethodTable();
                    *pfDispItf = TRUE;
                    break;
                }

                case DefaultInterfaceType_IUnknown:
                case DefaultInterfaceType_BaseComClass:
                {
                    *pfDispItf = FALSE;
                    break;
                }

                case DefaultInterfaceType_AutoDispatch:
                {
                    *pfDispItf = TRUE;
                    break;
                }

                default:
                {
                    _ASSERTE(!"Invalid default interface type!");
                    break;
                }
            }
        }
        else
        {
            // For System.Object, we already determined if we are dealing with IUnknown
            // or IDispatch based on the native type.
            *pfDispItf = m_fDispIntf;
        }
    }
    else
    {
        // Set the interface method table and the flag indicating if we are dealing with 
        // a disp interface.
        if (m_pClass->IsComClassInterface())
        {
            *ppItfMT = m_pClass->GetDefItfForComClassItf()->GetMethodTable();
            *pfDispItf = ((*ppItfMT)->GetComInterfaceType() != ifVtable); 
        }
        else
        {
            *ppItfMT = m_pClass->GetMethodTable();
            *pfDispItf = (m_pClass->GetMethodTable()->GetComInterfaceType() != ifVtable); 
        }

        // Look to see if the interface has a coclass defined
        EEClass* pClass = m_pClass->GetCoClassForInterface();
        if (pClass != NULL)
        {
            *pfClassIsHint = TRUE;
            *ppClassMT = pClass->GetMethodTable();
        }
    }
}

//===================================================================================
// Post-patches ML stubs for the sizeis feature.
//===================================================================================
VOID PatchMLStubForSizeIs(BYTE *pMLCode, UINT numArgs, MarshalInfo *pMLInfo)
{
    THROWSCOMPLUSEXCEPTION();

    INT16 *offsets = (INT16*)_alloca(numArgs * sizeof(INT16));
    
    INT16 srcofs = 0;
    for (UINT i = 0; i < numArgs; i++) 
    {
        offsets[i] = srcofs;
        srcofs += MLParmSize(pMLInfo[i].GetNativeArgSize());
    }

    BYTE *pMLWalk = pMLCode;
    for (i = 0; i < numArgs; i++) 
    {
        if (pMLInfo[i].GetMarshalType() == MarshalInfo::MARSHAL_TYPE_NATIVEARRAY)
        {
            MLCode mlcode;
            while ((mlcode = *(pMLWalk++)) != ML_CREATE_MARSHALER_CARRAY)
            {
                _ASSERTE(mlcode != ML_END && mlcode != ML_INTERRUPT);
                pMLWalk += gMLInfo[mlcode].m_numOperandBytes;
            }

            ML_CREATE_MARSHALER_CARRAY_OPERANDS *pmops = (ML_CREATE_MARSHALER_CARRAY_OPERANDS*)pMLWalk;
            pMLWalk += gMLInfo[mlcode].m_numOperandBytes;
            if (pmops->multiplier != 0) 
            {
            
                UINT16 countParamIdx = pmops->countParamIdx;
                if (countParamIdx >= numArgs)
                {
                    COMPlusThrow(kIndexOutOfRangeException, IDS_EE_SIZECONTROLOUTOFRANGE);
                }
                pmops->offsetbump = offsets[countParamIdx] - offsets[i];
                switch (pMLInfo[countParamIdx].GetMarshalType())
                {
                    case MarshalInfo::MARSHAL_TYPE_GENERIC_1:
                    case MarshalInfo::MARSHAL_TYPE_GENERIC_U1:
                        pmops->countSize = 1;
                        break;

                    case MarshalInfo::MARSHAL_TYPE_GENERIC_2:
                    case MarshalInfo::MARSHAL_TYPE_GENERIC_U2:
                        pmops->countSize = 2;
                        break;

                    case MarshalInfo::MARSHAL_TYPE_GENERIC_4:
                        pmops->countSize = 4;
                        break;

                    case MarshalInfo::MARSHAL_TYPE_GENERIC_8:
                        pmops->countSize = 8;
                        break;

                    default:
                        COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIZECONTROLBADTYPE);
                }
            }
        }
    }
}

//===================================================================================
// Support routines for storing ML stubs in prejit files
//===================================================================================
HRESULT StoreMLStub(MLHeader *pMLStub, DataImage *image, mdToken attribute)
{
    BYTE *pMLCode = (BYTE *) (pMLStub + 1);
    BYTE *pMLWalk = pMLCode;

    while (TRUE)
    {
        BYTE op = *pMLWalk++;

        switch (op)
        {
        case ML_END:
            return image->StoreInternedStructure(pMLStub, pMLWalk - pMLCode + sizeof(MLHeader), 
                                                 DataImage::SECTION_METHOD_INFO,
                                                 DataImage::DESCRIPTION_METHOD_DESC,
                                                 attribute);

        case ML_CREATE_MARSHALER_REFERENCECUSTOMMARSHALER:
        case ML_CREATE_MARSHALER_VALUECLASSCUSTOMMARSHALER:
            // This one's too complicated to fix up.
            // Just bail & we'll build it at runtime.
            return S_FALSE;

#if defined(CHECK_FOR_VALID_VARIANTS)
        // 2 strings
        case ML_CREATE_MARSHALER_OBJECT:
            {
                LPCUTF8 *ppStr = (LPCUTF8*)pMLWalk;
                if (!image->IsStored((void *) *ppStr))
                    image->StoreStructure((void *) *ppStr, (ULONG)strlen(*ppStr)+1, 
                                          DataImage::SECTION_DEBUG,
                                          DataImage::DESCRIPTION_DEBUG,
                                          attribute);

                ppStr++;
                if (!image->IsStored((void *) *ppStr))
                    image->StoreStructure((void *) *ppStr, (ULONG)strlen(*ppStr)+1, 
                                          DataImage::SECTION_DEBUG,
                                          DataImage::DESCRIPTION_DEBUG,
                                          attribute);

            }
            break;
#endif

        default:
            break;
        }

        pMLWalk += gMLInfo[op].m_numOperandBytes;
    }

}

HRESULT FixupMLStub(MLHeader *pMLStub, DataImage *image)
{
    HRESULT hr;
    
    // We don't store 100% of stubs, so check first.
    if (!image->IsStored(pMLStub))
        return S_FALSE;

    MLHeader *pNewMLStub = (MLHeader *) image->GetImagePointer(pMLStub);
    _ASSERTE(pNewMLStub);

    // See if it's already been fixed up (since we share these stubs)
    // Note we don't need to worry about atomicity since we're single
    // threaded during prejitting.
    if ((pNewMLStub->m_Flags & MLHF_NEEDS_RESTORING) != 0)
        return S_OK;

    BOOL fixups = FALSE;

    // Walk the code & fix up pointers
    BYTE *pMLCode = (BYTE *) (pMLStub + 1);
    BYTE *pMLWalk = pMLCode;

    while (TRUE)
    {
        BYTE op = *pMLWalk++;
        switch (op)
        {
        case ML_END:
            if (fixups)
                pNewMLStub->m_Flags |= MLHF_NEEDS_RESTORING;
            return S_OK;

        // MethodTable:
        case ML_VALUECLASS_C2N:
        case ML_VALUECLASS_N2C:
        case ML_COPYCTOR_N2C:
        case ML_CREATE_MARSHALER_BSTR_X:
        case ML_CREATE_MARSHALER_WSTR_X:
        case ML_CREATE_MARSHALER_CSTR_X:

        case ML_CREATE_MARSHALER_BSTR_BUFFER_X:
        case ML_CREATE_MARSHALER_WSTR_BUFFER_X:
        case ML_CREATE_MARSHALER_CSTR_BUFFER_X:

        case ML_CREATE_MARSHALER_SAFEARRAY:
        case ML_CREATE_MARSHALER_CARRAY:

        case ML_CREATE_MARSHALER_BLITTABLEPTR:
        case ML_CREATE_MARSHALER_LAYOUTCLASSPTR:
            {
                MethodTable **ppMT = (MethodTable**)pMLWalk;
                if (*ppMT != NULL)
                    IfFailRet(image->FixupPointerFieldToToken(ppMT, *ppMT, (*ppMT)->GetModule(),
                                                              mdtTypeDef));
                fixups = TRUE;
            }
            break;


        // BYTE + MethodTable
        case ML_REFVALUECLASS_C2N:
        case ML_REFVALUECLASS_N2C:
            {
                MethodTable **ppMT = (MethodTable**)(pMLWalk+1);
                if (*ppMT != NULL)
                    IfFailRet(image->FixupPointerFieldToToken(ppMT, *ppMT, (*ppMT)->GetModule(),
                                                              mdtTypeDef));
                fixups = TRUE;
            }
            break;

        // MethodTable + MethodDesc
        case ML_COPYCTOR_C2N:
            {
                MethodTable **ppMT = (MethodTable**)pMLWalk;
                if (*ppMT != NULL)
                    IfFailRet(image->FixupPointerFieldToToken(ppMT, *ppMT, (*ppMT)->GetModule(),
                                                              mdtTypeDef));

                MethodDesc **ppMD = (MethodDesc**)(ppMT+1);
                if (*ppMD != NULL)
                  IfFailRet(image->FixupPointerFieldToToken(ppMD, *ppMD, (*ppMD)->GetModule(),
                                                            mdtMethodDef));

                ppMD = (MethodDesc**)(ppMT+2);
                if (*ppMD != NULL)
                  IfFailRet(image->FixupPointerFieldToToken(ppMD, *ppMD, (*ppMD)->GetModule(),
                                                            mdtMethodDef));

                fixups = TRUE;
            }
            break;

        // MethodTable + MethodTable
        case ML_CREATE_MARSHALER_INTERFACE:
            {
                MethodTable **ppMT = (MethodTable**)pMLWalk;
                if (*ppMT != NULL)
                    IfFailRet(image->FixupPointerFieldToToken(ppMT, *ppMT, (*ppMT)->GetModule(),
                                                              mdtTypeDef));
                ppMT++;
                if (*ppMT != NULL)
                    IfFailRet(image->FixupPointerFieldToToken(ppMT, *ppMT, (*ppMT)->GetModule(),
                                                              mdtTypeDef));
                fixups = TRUE;
            }
            break;

        // CustomMarshalerInfo *
        case ML_CREATE_MARSHALER_REFERENCECUSTOMMARSHALER:
        case ML_CREATE_MARSHALER_VALUECLASSCUSTOMMARSHALER:
            _ASSERTE(!"We're supposed to not store stubs with custom marshalers");
            break;

#if defined(CHECK_FOR_VALID_VARIANTS)
        // 2 strings
        case ML_CREATE_MARSHALER_OBJECT:
            {
                LPCUTF8 *ppStr = (LPCUTF8*)pMLWalk;
                IfFailRet(image->FixupPointerField(ppStr));
                ppStr++;
                IfFailRet(image->FixupPointerField(ppStr));
                fixups = TRUE;
            }
            break;
#endif

        default:
            break;
        }

        pMLWalk += gMLInfo[op].m_numOperandBytes;
    }
}

Stub *RestoreMLStub(MLHeader *pMLStub, Module *pModule)
{
    StubLinker sl;

    // 
    // Copy bytes to new stub linker.  Note that we really would like to avoid 
    // this - however fixing up the stub in place causes difficult 
    // synchronization issues.
    // @perf: possibly revisit sync issues later
    //

    BYTE *pMLCode = (BYTE *) (pMLStub + 1);
    BYTE *pMLWalk = pMLCode;

    BYTE op = *pMLWalk++;

    while (op != ML_END)
    {
        pMLWalk += gMLInfo[op].m_numOperandBytes;
        op = *pMLWalk++;
    }

    sl.EmitBytes((BYTE*) pMLStub, pMLWalk - (BYTE*) pMLStub);

    Stub *pStub = sl.Link();

    pMLStub = (MLHeader *) pStub->GetEntryPoint();
    pMLStub->m_Flags &= ~MLHF_NEEDS_RESTORING;

    // Walk the new code & fix up pointers
    pMLCode = (BYTE *) (pMLStub + 1);
    pMLWalk = pMLCode;

    while (TRUE)
    {
        BYTE op = *pMLWalk++;
        switch (op)
        {
        case ML_END:
            return pStub;

        // MethodTable:
        case ML_VALUECLASS_C2N:
        case ML_VALUECLASS_N2C:
        case ML_COPYCTOR_N2C:
        case ML_CREATE_MARSHALER_BSTR_X:
        case ML_CREATE_MARSHALER_WSTR_X:
        case ML_CREATE_MARSHALER_CSTR_X:

        case ML_CREATE_MARSHALER_BSTR_BUFFER_X:
        case ML_CREATE_MARSHALER_WSTR_BUFFER_X:
        case ML_CREATE_MARSHALER_CSTR_BUFFER_X:

        case ML_CREATE_MARSHALER_SAFEARRAY:
        case ML_CREATE_MARSHALER_CARRAY:

        case ML_CREATE_MARSHALER_BLITTABLEPTR:
        case ML_CREATE_MARSHALER_LAYOUTCLASSPTR:
            {
                BOOL bQuickCOMStartupRequired = FALSE;
                MethodTable **ppMT = (MethodTable**)pMLWalk;
                DWORD rva = (DWORD)(size_t)*ppMT; // @todo WIN64 - Pointer truncation
                if (rva != 0)
                {
                    Module *pContainingModule = pModule->GetBlobModule(rva);
                    TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                                  pModule->GetZapBase() + rva);
                    *ppMT = type.AsMethodTable();
                }

                // Determine if we need to call QuickCOMStartup.
                if (op == ML_CREATE_MARSHALER_SAFEARRAY)
                {
                    bQuickCOMStartupRequired = TRUE;
                }
                else if (op == ML_CREATE_MARSHALER_CARRAY)
                {
                    ML_CREATE_MARSHALER_CARRAY_OPERANDS mops = *((ML_CREATE_MARSHALER_CARRAY_OPERANDS*&)pMLWalk);
                    if (mops.elementType == VT_UNKNOWN || mops.elementType == VT_DISPATCH || mops.elementType == VT_VARIANT)
                        bQuickCOMStartupRequired = TRUE;
                }

                // Call QuickCOMStartup if required.
                if (bQuickCOMStartupRequired)
                {
                    if (FAILED(QuickCOMStartup()))
                        return NULL;
                }
            }
            break;


        // BYTE + MethodTable
        case ML_REFVALUECLASS_C2N:
        case ML_REFVALUECLASS_N2C:
            {
                MethodTable **ppMT = (MethodTable**)(pMLWalk+1);
                DWORD rva = (DWORD)(size_t)*ppMT; // @todo WIN64 - Pointer truncation
                if (rva != 0)
                {
                    Module *pContainingModule = pModule->GetBlobModule(rva);
                    TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                                  pModule->GetZapBase() + rva);
                    *ppMT = type.AsMethodTable();
                }
            }
            break;

        // MethodTable + MethodDesc
        case ML_COPYCTOR_C2N:
            {
                MethodTable **ppMT = (MethodTable**)pMLWalk;
                DWORD rva = (DWORD)(size_t)*ppMT; // @todo WIN64 - Pointer truncation
                if (rva != 0)
                {
                    Module *pContainingModule = pModule->GetBlobModule(rva);
                    TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                                  pModule->GetZapBase() + rva);
                    *ppMT = type.AsMethodTable();
                }

                MethodDesc **ppMD = (MethodDesc**)(ppMT+1);
                rva = (DWORD)(size_t)*ppMD; // @todo WIN64 - Pointer truncation
                if (rva != 0)
                {
                    Module *pContainingModule = pModule->GetBlobModule(rva);
                    MethodDesc *pMD = CEECompileInfo::DecodeMethod(pContainingModule, 
                                                                   pModule->GetZapBase() + rva);
                    *ppMD = pMD;
                }

                ppMD = (MethodDesc**)(ppMT+2);
                rva = (DWORD)(size_t)*ppMD; // @todo WIN64 - Pointer truncation
                if (rva != 0)
                {
                    Module *pContainingModule = pModule->GetBlobModule(rva);
                    MethodDesc *pMD = CEECompileInfo::DecodeMethod(pContainingModule, 
                                                                   pModule->GetZapBase() + rva);
                    *ppMD = pMD;
                }
            }
            break;

        // MethodTable + MethodTable
        case ML_CREATE_MARSHALER_INTERFACE:
            {
                if (FAILED(QuickCOMStartup()))
                    return NULL;

                MethodTable **ppMT = (MethodTable**)pMLWalk;
                DWORD rva = (DWORD)(size_t)*ppMT; // @todo WIN64 - Pointer truncation
                if (rva != 0)
                {
                    Module *pContainingModule = pModule->GetBlobModule(rva);
                    TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                                  pModule->GetZapBase() + rva);
                    *ppMT = type.AsMethodTable();
                }

                ppMT++;
                rva = (DWORD)(size_t)*ppMT; // @todo WIN64 - Pointer truncation
                if (rva != 0)
                {
                    Module *pContainingModule = pModule->GetBlobModule(rva);
                    TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                                  pModule->GetZapBase() + rva);
                    *ppMT = type.AsMethodTable();
                }
            }
            break;

        // CustomMarshalerInfo *
        case ML_CREATE_MARSHALER_REFERENCECUSTOMMARSHALER:
        case ML_CREATE_MARSHALER_VALUECLASSCUSTOMMARSHALER:
            _ASSERTE(!"We're supposed to not store stubs with custom marshalers");
            break;

        // ML opcodes that require QuickCOMStartup to have been called to work.
        case ML_CREATE_MARSHALER_OBJECT:
        case ML_MARSHAL_SAFEARRAY_N2C_BYREF:
        case ML_UNMARSHAL_SAFEARRAY_N2C_BYREF_IN_OUT:
            {
                // We need to start COM up in these cases.
                if (FAILED(QuickCOMStartup()))
                    return NULL;
            }

        default:
            break;
        }

        pMLWalk += gMLInfo[op].m_numOperandBytes;
    }
}



//===============================================================
// Collects paraminfo's in an indexed array so that:
//
//   aParams[0] == param token for return value
//   aParams[1] == param token for argument #1...
//   aParams[numargs] == param token for argument #n...
//
// If no param token exists, the corresponding array element
// is set to mdParamDefNil.
//
// Inputs:
//    pInternalImport  -- ifc for metadata api
//    md       -- token of method. If token is mdMethodNil,
//                all aParam elements will be set to mdParamDefNil.
//    numargs  -- # of arguments in mdMethod
//    aParams  -- uninitialized array with numargs+1 elements.
//                on exit, will be filled with param tokens.
//===============================================================
VOID CollateParamTokens(IMDInternalImport *pInternalImport, mdMethodDef md, ULONG numargs, mdParamDef *aParams)
{
    THROWSCOMPLUSEXCEPTION();

    for (ULONG i = 0; i < numargs + 1; i++)
    {
        aParams[i] = mdParamDefNil;
    }
    if (md != mdMethodDefNil)
    {
        HENUMInternal hEnumParams;
        HRESULT hr = pInternalImport->EnumInit(mdtParamDef, md, &hEnumParams);
        if (FAILED(hr))
        {
            // no param info: nothing left to do here
        }
        else
        {
            mdParamDef CurrParam = mdParamDefNil;
            while (pInternalImport->EnumNext(&hEnumParams, &CurrParam))
            {
                USHORT usSequence;
                DWORD dwAttr;
                pInternalImport->GetParamDefProps(CurrParam, &usSequence, &dwAttr);
                _ASSERTE(usSequence <= numargs);
                _ASSERTE(aParams[usSequence] == mdParamDefNil);
                aParams[usSequence] = CurrParam; 
            }
        }

    }

}



#ifdef CUSTOMER_CHECKED_BUILD

VOID MarshalInfo::OutputCustomerCheckedBuildMarshalInfo(MethodDesc* pMD, SigPointer sig, Module* pModule, CorElementType elemType, BOOL fSizeIsSpecified)
{
    CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

    if (pMD != NULL)
    {
        // Get method name
        CQuickArray<WCHAR> strMethodName;
        UINT iMethodNameLength = (UINT)strlen(pMD->GetName()) + 1;
        strMethodName.Alloc(iMethodNameLength);
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pMD->GetName(),
                             -1, strMethodName.Ptr(), iMethodNameLength );

        // Get namespace.class name
        DefineFullyQualifiedNameForClassW();
        GetFullyQualifiedNameForClassW(pMD->GetClass());

        static WCHAR strNameFormat[] = {L"%s::%s"};
        CQuickArray<WCHAR> strNamespaceClassMethodName;
        strNamespaceClassMethodName.Alloc((UINT)strMethodName.Size() + (UINT)wcslen(_wszclsname_) + lengthof(strNameFormat));
        Wszwsprintf((LPWSTR)strNamespaceClassMethodName.Ptr(), strNameFormat, _wszclsname_, strMethodName.Ptr());

        if ( pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_Marshaling, strNamespaceClassMethodName.Ptr()) )
        {
            // Collect information for marshal type on managed side

            CQuickArray<WCHAR> strManagedMarshalType;

            if (!CheckForPrimitiveType(elemType, &strManagedMarshalType))
            {
                SigFormat sigfmt;
                TypeHandle th;
                OBJECTREF throwable = NULL;
                GCPROTECT_BEGIN(throwable);
                th = sig.GetTypeHandle(pModule, &throwable);
                if (throwable != NULL)
                {
                    static WCHAR strErrorMsg[] = {L"<error>"};
                    strManagedMarshalType.Alloc(lengthof(strErrorMsg));
                    wcscpy(strManagedMarshalType.Ptr(), strErrorMsg);
                }
                else
                {
                    sigfmt.AddType(th);
                    UINT iManagedMarshalTypeLength = (UINT)strlen(sigfmt.GetCString()) + 1;
                    strManagedMarshalType.Alloc(iManagedMarshalTypeLength);
                    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, sigfmt.GetCString(),
                                         -1, strManagedMarshalType.Ptr(), iManagedMarshalTypeLength);
                }
                GCPROTECT_END();
            }

            // Collect information for marshal type on native side

            CQuickArray<WCHAR> strNativeMarshalType;
            MarshalTypeToString(&strNativeMarshalType, fSizeIsSpecified);

            static WCHAR strMessageFormat[] = 
                {L"Marshaling from %s to %s in method %s."};

            CQuickArray<WCHAR> strMessage;
            strMessage.Alloc( lengthof(strMessageFormat) + 
                              (UINT) strManagedMarshalType.Size() + 
                              (UINT) strNativeMarshalType.Size() + 
                              strMethodName.Size() );
            Wszwsprintf( strMessage.Ptr(), strMessageFormat, strManagedMarshalType.Ptr(), 
                         strNativeMarshalType.Ptr(), strMethodName.Ptr() );
            pCdh->LogInfo(strMessage.Ptr(), CustomerCheckedBuildProbe_Marshaling);
        }
    }
}


VOID MarshalInfo::MarshalTypeToString(CQuickArray<WCHAR> *pStrMarshalType, BOOL fSizeIsSpecified)
{
    LPWSTR strRetVal;

    // Some MarshalTypes have extra information and require special handling
    if (m_type == MARSHAL_TYPE_INTERFACE)
    {
        MethodTable *pItfMT = NULL;
        MethodTable *pClassMT = NULL;
        BOOL fDispItf = FALSE;
        BOOL fClassIsHint = FALSE;
        GetItfMarshalInfo(&pItfMT, &pClassMT, &fDispItf, &fClassIsHint);

        if (pItfMT)
        {
            DefineFullyQualifiedNameForClassW();
            GetFullyQualifiedNameForClassW(pItfMT->GetClass());

            if (fDispItf)
            {
                static WCHAR strTemp[] = {L"IDispatch %s"};
                pStrMarshalType->Alloc(lengthof(strTemp) + wcslen(_wszclsname_));
                Wszwsprintf(pStrMarshalType->Ptr(), strTemp, _wszclsname_);
                return;
            }
            else
            {
                static WCHAR strTemp[] = {L"IUnknown %s"};
                pStrMarshalType->Alloc(lengthof(strTemp) + wcslen(_wszclsname_));
                Wszwsprintf(pStrMarshalType->Ptr(), strTemp, _wszclsname_);
                return;
            }
        }
        else
        {
            if (fDispItf)
                strRetVal = L"IDispatch";
            else
                strRetVal = L"IUnknown";
        }
    }
    else if (m_type == MARSHAL_TYPE_SAFEARRAY) {
        static WCHAR strTemp[] = {L"SafeArray of %s"};
        CQuickArray<WCHAR> strVarType;
        VarTypeToString(m_arrayElementType, &strVarType, FALSE);

        pStrMarshalType->Alloc(lengthof(strTemp) + strVarType.Size());
        Wszwsprintf(pStrMarshalType->Ptr(), strTemp, strVarType.Ptr());
        return;
    }
    else if (m_type == MARSHAL_TYPE_NATIVEARRAY) {
        CQuickArray<WCHAR> strVarType;
        VarTypeToString(m_arrayElementType, &strVarType, TRUE);

        if (!fSizeIsSpecified)
        {
            static WCHAR strTemp[] = {L"native array of %s (size not specified by a parameter)"};
            pStrMarshalType->Alloc(lengthof(strTemp) + strVarType.Size());
            Wszwsprintf(pStrMarshalType->Ptr(), strTemp, strVarType.Ptr());
        }
        else
        {
            static WCHAR strTemp[] = {L"native array of %s (size specified by parameter %i)"};
            pStrMarshalType->Alloc(lengthof(strTemp) + strVarType.Size() + MAX_INT32_DECIMAL_CHAR_LEN);
            Wszwsprintf(pStrMarshalType->Ptr(), strTemp, strVarType.Ptr(), m_countParamIdx);
        }

        return;
    }
    else if (m_type == MARSHAL_TYPE_REFERENCECUSTOMMARSHALER ||
             m_type == MARSHAL_TYPE_VALUECLASSCUSTOMMARSHALER ) {        
        OBJECTHANDLE objHandle = m_pCMHelper->GetCustomMarshalerInfo()->GetCustomMarshaler();
        BEGIN_ENSURE_COOPERATIVE_GC()
        {
            OBJECTREF pObjRef = ObjectFromHandle(objHandle);
            DefineFullyQualifiedNameForClassW();
            GetFullyQualifiedNameForClassW(pObjRef->GetClass());

            static WCHAR strTemp[] = {L"custom marshaler (%s)"};
            pStrMarshalType->Alloc(lengthof(strTemp) + wcslen(_wszclsname_));
            Wszwsprintf(pStrMarshalType->Ptr(), strTemp, _wszclsname_);
        }        
        END_ENSURE_COOPERATIVE_GC();
        return;
    }
    else
    {
        // All other MarshalTypes with no special handling
        switch (m_type)
        {
            case MARSHAL_TYPE_GENERIC_1:
                strRetVal = L"BYTE";
                break;
            case MARSHAL_TYPE_GENERIC_U1:
                strRetVal = L"unsigned BYTE";
                break;
            case MARSHAL_TYPE_GENERIC_2:
                strRetVal = L"WORD";
                break;
            case MARSHAL_TYPE_GENERIC_U2:
                strRetVal = L"unsigned WORD";
                break;
            case MARSHAL_TYPE_GENERIC_4:
                strRetVal = L"DWORD";
                break;
            case MARSHAL_TYPE_GENERIC_8:
                strRetVal = L"QUADWORD";
                break;
            case MARSHAL_TYPE_WINBOOL:
                strRetVal = L"Windows Bool";
                break;
            case MARSHAL_TYPE_VTBOOL:
                strRetVal = L"VARIANT Bool";
                break;
            case MARSHAL_TYPE_ANSICHAR:
                strRetVal = L"Ansi character";
                break;
            case MARSHAL_TYPE_CBOOL:
                strRetVal = L"CBool";
                break;
            case MARSHAL_TYPE_FLOAT:
                strRetVal = L"float";
                break;
            case MARSHAL_TYPE_DOUBLE:
                strRetVal = L"double";
                break;
            case MARSHAL_TYPE_CURRENCY:
                strRetVal = L"CURRENCY";
                break;
            case MARSHAL_TYPE_DECIMAL:
                strRetVal = L"DECIMAL";
                break;
            case MARSHAL_TYPE_DECIMAL_PTR:
                strRetVal = L"DECIMAL pointer";
                break;
            case MARSHAL_TYPE_GUID:
                strRetVal = L"GUID";
                break;
            case MARSHAL_TYPE_GUID_PTR:
                strRetVal = L"GUID pointer";
                break;
            case MARSHAL_TYPE_DATE:
                strRetVal = L"DATE";
                break;
            case MARSHAL_TYPE_VARIANT:
                strRetVal = L"VARIANT";
                break;
            case MARSHAL_TYPE_BSTR:
                strRetVal = L"BSTR";
                break;
            case MARSHAL_TYPE_LPWSTR:
                strRetVal = L"LPWSTR";
                break;
            case MARSHAL_TYPE_LPSTR:
                strRetVal = L"LPSTR";
                break;
            case MARSHAL_TYPE_ANSIBSTR:
                strRetVal = L"AnsiBStr";
                break;
            case MARSHAL_TYPE_BSTR_BUFFER:
                strRetVal = L"BSTR buffer";
                break;
            case MARSHAL_TYPE_LPWSTR_BUFFER:
                strRetVal = L"LPWSTR buffer";
                break;
            case MARSHAL_TYPE_LPSTR_BUFFER:
                strRetVal = L"LPSTR buffer";
                break;
            case MARSHAL_TYPE_BSTR_X:
                strRetVal = L"MARSHAL_TYPE_BSTR_X";
                break;
            case MARSHAL_TYPE_LPWSTR_X:
                strRetVal = L"MARSHAL_TYPE_LPWSTR_X";
                break;
            case MARSHAL_TYPE_LPSTR_X:
                strRetVal = L"MARSHAL_TYPE_LPSTR_X";
                break;
            case MARSHAL_TYPE_BSTR_BUFFER_X:
                strRetVal = L"MARSHAL_TYPE_BSTR_BUFFER_X";
                break;
            case MARSHAL_TYPE_LPWSTR_BUFFER_X:
                strRetVal = L"MARSHAL_TYPE_LPWSTR_BUFFER_X";
                break;
            case MARSHAL_TYPE_LPSTR_BUFFER_X:
                strRetVal = L"MARSHAL_TYPE_LPSTR_BUFFER_X";
                break;

//          case MARSHAL_TYPE_INTERFACE:
//          case MARSHAL_TYPE_SAFEARRAY:
//          case MARSHAL_TYPE_NATIVEARRAY:
//              (see above)

            case MARSHAL_TYPE_ASANYA:
                strRetVal = L"AsAnyA";
                break;
            case MARSHAL_TYPE_ASANYW:
                strRetVal = L"AsAnyW";
                break;
            case MARSHAL_TYPE_DELEGATE:
                strRetVal = L"Delegate";
                break;
            case MARSHAL_TYPE_BLITTABLEPTR:
                strRetVal = L"blittable pointer";
                break;
            case MARSHAL_TYPE_VBBYVALSTR:
                strRetVal = L"VBByValStr";
                break;
            case MARSHAL_TYPE_VBBYVALSTRW:
                strRetVal = L"VBByRefStr";
                break;
            case MARSHAL_TYPE_LAYOUTCLASSPTR:
                strRetVal = L"Layout class pointer";
                break;
            case MARSHAL_TYPE_ARRAYWITHOFFSET:
                strRetVal = L"ArrayWithOffset";
                break;
            case MARSHAL_TYPE_BLITTABLEVALUECLASS:
                strRetVal = L"blittable value class";
                break;
            case MARSHAL_TYPE_VALUECLASS:
                strRetVal = L"value class";
                break;

//          case MARSHAL_TYPE_REFERENCECUSTOMMARSHALER:
//          case MARSHAL_TYPE_VALUECLASSCUSTOMMARSHALER:
//              (see above)

            case MARSHAL_TYPE_ARGITERATOR:
                strRetVal = L"ArgIterator";
                break;
            case MARSHAL_TYPE_BLITTABLEVALUECLASSWITHCOPYCTOR:
                strRetVal = L"blittable value class with copy constructor";
                break;
            case MARSHAL_TYPE_OBJECT:
                strRetVal = L"VARIANT";
                break;
            case MARSHAL_TYPE_HANDLEREF:
                strRetVal = L"HandleRef";
                break;
            case MARSHAL_TYPE_OLECOLOR:
                strRetVal = L"OLE_COLOR";
                break;
            default:
                strRetVal = L"<UNKNOWN>";
                break;
        }
    }

    pStrMarshalType->Alloc((UINT)wcslen(strRetVal) + 1);
    wcscpy(pStrMarshalType->Ptr(), strRetVal);
    return;
}


VOID MarshalInfo::VarTypeToString(VARTYPE vt, CQuickArray<WCHAR> *pStrVarType, BOOL fNativeArray)
{
    LPWSTR strRetVal;
    
    switch(vt)
    {
        case VT_I2:
            strRetVal = L"2-byte signed int";
            break;
        case VT_I4:
            strRetVal = L"4-byte signed int";
            break;
        case VT_R4:
            strRetVal = L"4-byte real";
            break;
        case VT_R8:
            strRetVal = L"8-byte real";
            break;
        case VT_CY:
            strRetVal = L"currency";
            break;
        case VT_DATE:
            strRetVal = L"date";
            break;
        case VT_BSTR:
            strRetVal = L"binary string";
            break;
        case VT_DISPATCH:
            strRetVal = L"IDispatch *";
            break;
        case VT_ERROR:
            strRetVal = L"Scode";
            break;
        case VT_BOOL:
            strRetVal = L"boolean";
            break;
        case VT_VARIANT:
            strRetVal = L"VARIANT *";
            break;
        case VT_UNKNOWN:
            strRetVal = L"IUnknown *";
            break;
        case VT_DECIMAL:
            strRetVal = L"16-byte fixed point";
            break;
        case VT_RECORD:
            strRetVal = L"user defined type";
            break;
        case VT_I1:
            strRetVal = L"signed char";
            break;
        case VT_UI1:
            strRetVal = L"unsigned char";
            break;
        case VT_UI2:
            strRetVal = L"unsigned short";
            break;
        case VT_UI4:
            strRetVal = L"unsigned short";
            break;
        case VT_INT:
            strRetVal = L"signed int";
            break;
        case VT_UINT:
            strRetVal = L"unsigned int";
            break;
        case VT_LPSTR:
            if (fNativeArray)
                strRetVal = L"LPSTR";
            else
                strRetVal = L"unknown";
            break;
        case VT_LPWSTR:
            if (fNativeArray)
                strRetVal = L"LPWSTR";
            else
                strRetVal = L"unknown";
            break;
        case VTHACK_WINBOOL:
            strRetVal = L"boolean";
            break;
        case VTHACK_ANSICHAR:
            strRetVal = L"char";
            break;
        default:
            strRetVal = L"unknown";
            break;
    }

    pStrVarType->Alloc((UINT)wcslen(strRetVal) + 1);
    wcscpy(pStrVarType->Ptr(), strRetVal);
    return;
}

#endif // CUSTOMER_CHECKED_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\nativeoverlapped.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMNativeOverlapped.h
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods for allocating and freeing NativeOverlapped
**
** Date:  January, 2000
** 
===========================================================*/

#ifndef _OVERLAPPED_H
#define _OVERLAPPED_H

// IMPORTANT: This struct is mirrored in Overlapped.cool. If it changes in either 
// place the other file must be modified as well

typedef struct  { 
    DWORD  Internal; 
    DWORD  InternalHigh; 
    DWORD  Offset; 
    DWORD  OffsetHigh; 
    HANDLE hEvent; 
	void*  CORReserved1;
	void*  CORReserved2;
	void*  CORReserved3;
	void*  ClasslibReserved;
} NATIVE_OVERLAPPED; 

FCDECL0(BYTE*, AllocNativeOverlapped);

FCDECL1(void, FreeNativeOverlapped, BYTE* pOverlapped);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\monitor.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: Monitor.h
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.Monitor
**
** Date:  January, 2000
** 
===========================================================*/

#ifndef _MONITOR_H
#define _MONITOR_H

class MonitorNative
{
    // Each function that we call through native only gets one
    // argument, which is actually a pointer to it's stack of
    // arguments. Our structs for accessing these are defined below.

    struct EnterArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pObj);
    };

    struct ExitArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pObj);
    };

    struct TryEnterArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, m_Timeout);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pObj);
    };


  public:

    static void				__stdcall Enter(EnterArgs *pArgs);
    static void				__stdcall Exit(ExitArgs *pArgs);
    static INT32/*bool*/	__stdcall TryEnter(TryEnterArgs *pArgs);
	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mlopdef.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// MLOPDEF.H -
//
// Defines ML opcodes.
//
//
// Columns:
//
//  op   -- size in bytes of the instruction, excluding the opcode byte.
//          variable-length instructions not allowed.
//
//  fC   -- 1 if instruction makes use of the CleanupWorkList passed to
//          RunML. The EE optimizes out the creation of a CleanupWorkList
//          if the ML stream for a method makes no use of it.
//
//  loc  -- # of bytes of localspace required by instruction.
//          Currently, this is stored only for _DEBUG builds.
//
//  XHndl - requires extra handles for GC protection
// 
//        Name                      op fC loc XHndl
//        -----------------         -- -- --- ----
DEFINE_ML(ML_END,                   0, 0, 0,	0)        // End of ML stream
DEFINE_ML(ML_INTERRUPT,             0, 0, 0,	0)        // Ends interpretation w/out ending stream
DEFINE_ML(ML_COPYI1,                0, 0, 0,	0)        // copy 1 byte and sign extend it 
DEFINE_ML(ML_COPYU1,                0, 0, 0,	0)        // copy 1 byte and zero extend it 
DEFINE_ML(ML_COPYI2,                0, 0, 0,	0)        // copy 2 byte and sign extend it
DEFINE_ML(ML_COPYU2,                0, 0, 0,	0)        // copy 2 byte and mask the high bytes
DEFINE_ML(ML_COPYI4,                0, 0, 0,	0)        // copy 4 byte and sign extend it 
DEFINE_ML(ML_COPYU4,                0, 0, 0,	0)        // copy 4 byte and mask the high bytes
DEFINE_ML(ML_COPY4,                 0, 0, 0,	0)        // Copy 4 bytes from source to destination
DEFINE_ML(ML_COPY8,                 0, 0, 0,	0)        // Copy 8 bytes from source to destination
DEFINE_ML(ML_COPYR4,                0, 0, 0,	0)        // Copy 4 float bytes from source to destination 
DEFINE_ML(ML_COPYR8,                0, 0, 0,	0)        // Copy 8 float bytes from source to destination 

DEFINE_ML(ML_BOOL_N2C,              0, 0, 0, 0)        // 32-bit BOOL -> boolean


DEFINE_ML(ML_PUSHRETVALBUFFER1,     0, 0, sizeof(RetValBuffer), 0)  // Push ptr to 1-byte retval buffer
DEFINE_ML(ML_PUSHRETVALBUFFER2,     0, 0, sizeof(RetValBuffer), 0)  // Push ptr to 2-byte retval buffer
DEFINE_ML(ML_PUSHRETVALBUFFER4,     0, 0, sizeof(RetValBuffer), 0)  // Push ptr to 4-byte retval buffer
DEFINE_ML(ML_PUSHRETVALBUFFER8,     0, 0, sizeof(RetValBuffer), 0)  // Push ptr to 8-byte retval buffer
DEFINE_ML(ML_SETSRCTOLOCAL,         2, 0, 0, 0)        // Redirect psrc to local
DEFINE_ML(ML_THROWIFHRFAILED,       0, 0, 0, 0)        // Throw if FAILED(hr)
DEFINE_ML(ML_OBJECT_C2N,            4, 1, sizeof(ML_OBJECT_C2N_SR), 0)  // Do an "any"-style parameter
DEFINE_ML(ML_OBJECT_C2N_POST,       2, 0, 0, 0)        // Backpropagation for "any"-style parameter
//COM TO COM+ stuff

DEFINE_ML(ML_LATEBOUNDMARKER,       0, 0, 0,      0)      // Marker to indicate the ML stub is for a late bound call
DEFINE_ML(ML_COMEVENTCALLMARKER,    0, 0, 0,      0)      // Marker to indicate the ML stub is for a COM event call

DEFINE_ML(ML_BUMPSRC,               2, 0, 0,      0)      // Increment source pointer by 16-bit signed value
DEFINE_ML(ML_BUMPDST,               2, 0, 0,      0)      // Increment destination pointer by 16-bit signed value

DEFINE_ML(ML_R4_FROM_TOS,           0, 0, 0,      0)      // grab R4 from top of floating point stack
DEFINE_ML(ML_R8_FROM_TOS,           0, 0, 0,      0)      // grab R8 from top of floating point stack


DEFINE_ML(ML_ARRAYWITHOFFSET_C2N, 0, 1, sizeof(ML_ARRAYWITHOFFSET_C2N_SR), 0) // Convert a StringBuilder to BSTR
DEFINE_ML(ML_ARRAYWITHOFFSET_C2N_POST,     2, 0, 0, 0)        // Backpropagate changes


//==========================================================================
// !! These must appear in the same order that marshalers are defined in
// mtypes.h. That's because mlinfo uses opcode arithmetic to find
// the correct ML_CREATE.
//==========================================================================


DEFINE_ML(ML_CREATE_MARSHALER_GENERIC_1, 0, 0, sizeof(CopyMarshaler1), 0)
DEFINE_ML(ML_CREATE_MARSHALER_GENERIC_U1, 0, 0, sizeof(CopyMarshalerU1), 0)
DEFINE_ML(ML_CREATE_MARSHALER_GENERIC_2, 0, 0, sizeof(CopyMarshaler2), 0)
DEFINE_ML(ML_CREATE_MARSHALER_GENERIC_U2, 0, 0, sizeof(CopyMarshalerU2), 0)
DEFINE_ML(ML_CREATE_MARSHALER_GENERIC_4, 0, 0, sizeof(CopyMarshaler4), 0)
DEFINE_ML(ML_CREATE_MARSHALER_GENERIC_8, 0, 0, sizeof(CopyMarshaler8), 0)
DEFINE_ML(ML_CREATE_MARSHALER_WINBOOL, 0, 0, sizeof(WinBoolMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_VTBOOL, 0, 0, sizeof(VtBoolMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_ANSICHAR, 2 * sizeof(UINT8), 1, sizeof(AnsiCharMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_CBOOL, 0, 1, sizeof(CBoolMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_FLOAT, 0, 0, sizeof(FloatMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_DOUBLE, 0, 0, sizeof(DoubleMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_CURRENCY, 0, 0, sizeof(CurrencyMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_DECIMAL, 0, 0, sizeof(DecimalMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_DECIMAL_PTR, 0, 0, sizeof(DecimalPtrMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_GUID, 0, 0, sizeof(GuidMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_GUID_PTR, 0, 0, sizeof(GuidPtrMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_DATE, 0, 0, sizeof(DateMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_VARIANT, 0, 1, sizeof(VariantMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_BSTR, 0, 1, sizeof(BSTRMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_WSTR, 0, 1, sizeof(WSTRMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_CSTR, 2 * sizeof(UINT8), 1, sizeof(CSTRMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_ANSIBSTR, 2 * sizeof(UINT8), 1, sizeof(AnsiBSTRMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_BSTR_BUFFER, 0, 1, sizeof(BSTRBufferMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_WSTR_BUFFER, 0, 1, sizeof(WSTRBufferMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_CSTR_BUFFER, 2 * sizeof(UINT8), 1, sizeof(CSTRBufferMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_BSTR_X, sizeof(MethodTable*), 1, sizeof(BSTRMarshalerEx), 0)
DEFINE_ML(ML_CREATE_MARSHALER_WSTR_X, sizeof(MethodTable*), 1, sizeof(WSTRMarshalerEx), 0)
DEFINE_ML(ML_CREATE_MARSHALER_CSTR_X, 2 * sizeof(UINT8) + sizeof(MethodTable*), 1, sizeof(CSTRMarshalerEx), 0)
DEFINE_ML(ML_CREATE_MARSHALER_BSTR_BUFFER_X, sizeof(MethodTable*), 1, sizeof(BSTRBufferMarshalerEx), 0)
DEFINE_ML(ML_CREATE_MARSHALER_WSTR_BUFFER_X, sizeof(MethodTable*), 1, sizeof(WSTRBufferMarshalerEx), 0)
DEFINE_ML(ML_CREATE_MARSHALER_CSTR_BUFFER_X, 2 * sizeof(UINT8) + sizeof(MethodTable*), 1, sizeof(CSTRBufferMarshalerEx), 0)
DEFINE_ML(ML_CREATE_MARSHALER_INTERFACE, 2 * sizeof(MethodTable*) + 2 * sizeof(UINT8), 1, sizeof(InterfaceMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_SAFEARRAY, sizeof(MethodTable*) + sizeof(UINT8) + sizeof(INT32) + sizeof(UINT8), 1, sizeof(SafeArrayMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_CARRAY, sizeof(ML_CREATE_MARSHALER_CARRAY_OPERANDS), 1, sizeof(NativeArrayMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_ASANYA,     0, 1, sizeof(AsAnyAMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_ASANYW,     0, 1, sizeof(AsAnyWMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_DELEGATE,   0, 1, sizeof(DelegateMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_BLITTABLEPTR, 4, 1, sizeof(BlittablePtrMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_VBBYVALSTR, 0,0,0,0)
DEFINE_ML(ML_CREATE_MARSHALER_VBBYVALSTRW, 0,0,0,0)
DEFINE_ML(ML_CREATE_MARSHALER_LAYOUTCLASSPTR, 4, 1, sizeof(LayoutClassPtrMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_ARRAYWITHOFFSET, 0, 0, 0, 0)
DEFINE_ML(ML_CREATE_MARSHALER_BLITTABLEVALUECLASS, 0, 1, sizeof(BlittableValueClassMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_VALUECLASS, 0, 1, sizeof(ValueClassMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_REFERENCECUSTOMMARSHALER, sizeof(CustomMarshalerInfo*), 1, sizeof(ReferenceCustomMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_VALUECLASSCUSTOMMARSHALER, sizeof(CustomMarshalerInfo*), 1, sizeof(ValueClassCustomMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_ARGITERATOR, 0, 1, sizeof(ArgIteratorMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_BLITTABLEVALUECLASSWITHCOPYCTOR, 0, 1, sizeof(BlittableValueClassWithCopyCtorMarshaler), 0)
#if defined(CHECK_FOR_VALID_VARIANTS)
DEFINE_ML(ML_CREATE_MARSHALER_OBJECT, sizeof(LPCUTF8) * 2 + sizeof(INT32), 1, sizeof(ObjectMarshaler), 0)
#else
DEFINE_ML(ML_CREATE_MARSHALER_OBJECT, 0, 1, sizeof(ObjectMarshaler), 0)
#endif
DEFINE_ML(ML_CREATE_MARSHALER_HANDLEREF, 0, 1, sizeof(HandleRefMarshaler), 0)
DEFINE_ML(ML_CREATE_MARSHALER_OLECOLOR, 0, 1, sizeof(OleColorMarshaler), 0)

//==========================================================================


DEFINE_ML(ML_MARSHAL_N2C, 0, 0, 0, 0)
DEFINE_ML(ML_MARSHAL_N2C_OUT, 0, 0, 0, 0)
DEFINE_ML(ML_MARSHAL_N2C_BYREF, 0, 0, 0, 0)
DEFINE_ML(ML_MARSHAL_N2C_BYREF_OUT, 0, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_N2C_IN, 2, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_N2C_OUT, 2, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_N2C_IN_OUT, 2, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_N2C_BYREF_IN, 2, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_N2C_BYREF_OUT, 2, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_N2C_BYREF_IN_OUT, 2, 0, 0, 0)

DEFINE_ML(ML_MARSHAL_C2N, 0, 0, 0, 0)
DEFINE_ML(ML_MARSHAL_C2N_OUT, 0, 0, 0, 0)
DEFINE_ML(ML_MARSHAL_C2N_BYREF, 0, 0, 0, 0)
DEFINE_ML(ML_MARSHAL_C2N_BYREF_OUT, 0, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_C2N_IN, 2, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_C2N_OUT, 2, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_C2N_IN_OUT, 2, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_C2N_BYREF_IN, 2, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_C2N_BYREF_OUT, 2, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_C2N_BYREF_IN_OUT, 2, 0, 0, 0)

DEFINE_ML(ML_PRERETURN_N2C, 0, 0, 0, 0)
DEFINE_ML(ML_PRERETURN_N2C_RETVAL, 0, 0, 0, 0)
DEFINE_ML(ML_RETURN_N2C, 2, 0, 0, 0)
DEFINE_ML(ML_RETURN_N2C_RETVAL, 2, 0, 0, 0)

DEFINE_ML(ML_PRERETURN_C2N, 0, 0, 0, 0)
DEFINE_ML(ML_PRERETURN_C2N_RETVAL, 0, 0, 0, 0)
DEFINE_ML(ML_RETURN_C2N, 2, 0, 0, 0)
DEFINE_ML(ML_RETURN_C2N_RETVAL, 2, 0, 0, 0)

DEFINE_ML(ML_SET_COM, 0, 0, 0, 0)
DEFINE_ML(ML_GET_COM, 0, 0, 0, 0)
DEFINE_ML(ML_PREGET_COM_RETVAL, 0, 0, 0, 0)





DEFINE_ML(ML_PINNEDUNISTR_C2N, 0, 0, 0, 0)

DEFINE_ML(ML_VBBYVALSTR,  2, 1, sizeof(ML_VBBYVALSTR_SR), 0)
DEFINE_ML(ML_VBBYVALSTR_POST,     2, 0, 0, 0)
DEFINE_ML(ML_VBBYVALSTRW,  0, 1, sizeof(ML_VBBYVALSTRW_SR), 0)
DEFINE_ML(ML_VBBYVALSTRW_POST,     2, 0, 0, 0)


DEFINE_ML(ML_BLITTABLELAYOUTCLASS_C2N,    0, 0, 0, 0)        // Marshal a blittable layoutclass

DEFINE_ML(ML_BLITTABLEVALUECLASS_C2N,  sizeof(UINT32), 0, 0, 0)
DEFINE_ML(ML_BLITTABLEVALUECLASS_N2C,  sizeof(UINT32), 0, 0, 0)
DEFINE_ML(ML_REFBLITTABLEVALUECLASS_C2N,  sizeof(UINT32), 0, 0, 0)

DEFINE_ML(ML_VALUECLASS_C2N,    sizeof(MethodTable*), 1, 0, 0)
DEFINE_ML(ML_VALUECLASS_N2C,    sizeof(MethodTable*), 0, 0, 0)
DEFINE_ML(ML_REFVALUECLASS_C2N, 1+sizeof(MethodTable*), 1, sizeof(ML_REFVALUECLASS_C2N_SR), 0)
DEFINE_ML(ML_REFVALUECLASS_C2N_POST, sizeof(UINT16), 0, 0, 0)
DEFINE_ML(ML_REFVALUECLASS_N2C,      1+sizeof(MethodTable*), 1, sizeof(ML_REFVALUECLASS_N2C_SR), 0)
DEFINE_ML(ML_REFVALUECLASS_N2C_POST, sizeof(UINT16), 0, 0, 0)

DEFINE_ML(ML_PINNEDISOMORPHICARRAY_C2N, 2, 0, 0, 0)
DEFINE_ML(ML_PINNEDISOMORPHICARRAY_C2N_EXPRESS, 2, 0, 0, 0)

DEFINE_ML(ML_REFVARIANT_N2C,      1, 1, sizeof(ML_REFVARIANT_N2C_SR), 0)
DEFINE_ML(ML_REFVARIANT_N2C_POST, sizeof(UINT16), 0, 0, 0)

DEFINE_ML(ML_REFOBJECT_N2C,      1, 1, sizeof(ML_REFVARIANT_N2C_SR), 0)
DEFINE_ML(ML_REFOBJECT_N2C_POST,       sizeof(UINT16), 0, 0, 0)


DEFINE_ML(ML_THROWINTEROPPARAM,   8, 0, 0, 0)

DEFINE_ML(ML_ARGITERATOR_C2N,	  0, 0, 0, 0)
DEFINE_ML(ML_ARGITERATOR_N2C,	  0, 0, 0, 0)

DEFINE_ML(ML_COPYCTOR_C2N,        sizeof(MethodTable*) + sizeof(MethodDesc*) + sizeof(MethodDesc*), 0, 0, 0)
DEFINE_ML(ML_COPYCTOR_N2C,        sizeof(MethodTable*), 0, 0, 0)

DEFINE_ML(ML_CAPTURE_PSRC,		  2, 0, sizeof(BYTE*), 0)
DEFINE_ML(ML_MARSHAL_RETVAL_SMBLITTABLEVALUETYPE_C2N, 6, 0, 0, 0)
DEFINE_ML(ML_MARSHAL_RETVAL_SMBLITTABLEVALUETYPE_N2C, 6, 0, 0, 0)

DEFINE_ML(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N, 4, 1, sizeof(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_SR), 0)
DEFINE_ML(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_POST, sizeof(UINT16), 0, 0, 0)

DEFINE_ML(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_N2C, 0, 0, sizeof(LPVOID), 0)
DEFINE_ML(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_N2C_POST, sizeof(UINT16), 0, 0, 0)

DEFINE_ML(ML_PUSHVASIGCOOKIEEX,   sizeof(UINT16), 0, sizeof(VASigCookieEx), 0)
DEFINE_ML(ML_BSTR_C2N,            0, 1, sizeof(ML_BSTR_C2N_SR), 0)
DEFINE_ML(ML_CSTR_C2N,            2, 1, sizeof(ML_CSTR_C2N_SR), 0)

DEFINE_ML(ML_HANDLEREF_C2N,       0, 0, 0, 0)


DEFINE_ML(ML_WSTRBUILDER_C2N,            0, 1, sizeof(ML_WSTRBUILDER_C2N_SR), 0)  // Do an "any"-style parameter
DEFINE_ML(ML_WSTRBUILDER_C2N_POST,       2, 0, 0, 0)        // Backpropagation for "any"-style parameter

DEFINE_ML(ML_CSTRBUILDER_C2N,            2, 1, sizeof(ML_CSTRBUILDER_C2N_SR), 0)  // Do an "any"-style parameter
DEFINE_ML(ML_CSTRBUILDER_C2N_POST,       2, 0, 0, 0)        // Backpropagation for "any"-style parameter

DEFINE_ML(ML_MARSHAL_SAFEARRAY_N2C_BYREF, 0, 0, 0, 0)
DEFINE_ML(ML_UNMARSHAL_SAFEARRAY_N2C_BYREF_IN_OUT, 2, 0, 0, 0)
DEFINE_ML(ML_CBOOL_C2N, 0,0,0,0)
DEFINE_ML(ML_CBOOL_N2C, 0,0,0,0)

DEFINE_ML(ML_LCID_C2N, 0, 0, 0, 0)
DEFINE_ML(ML_LCID_N2C, 0, 0, 0, 0)


DEFINE_ML(ML_STRUCTRETN2C, sizeof(MethodTable*), 1, sizeof(ML_STRUCTRETN2C_SR), 0)
DEFINE_ML(ML_STRUCTRETN2C_POST, sizeof(UINT16), 0, 0, 0)

DEFINE_ML(ML_STRUCTRETC2N, sizeof(MethodTable*), 1, sizeof(ML_STRUCTRETC2N_SR), 0)
DEFINE_ML(ML_STRUCTRETC2N_POST, sizeof(UINT16), 0, 0, 0)

DEFINE_ML(ML_CURRENCYRETC2N, 0, 0, sizeof(ML_CURRENCYRETC2N_SR), 0)
DEFINE_ML(ML_CURRENCYRETC2N_POST, sizeof(UINT16), 0, 0, 0)

DEFINE_ML(ML_COPYPINNEDGCREF, 0, 0, 0, 0)

DEFINE_ML(ML_PUSHVARIANTRETVAL, 0, 0, sizeof(VARIANT), 0)
DEFINE_ML(ML_OBJECTRETC2N_POST, sizeof(UINT16), 0, 0, 0)

DEFINE_ML(ML_CURRENCYRETN2C, 0, 1, sizeof(ML_CURRENCYRETN2C_SR), 0)
DEFINE_ML(ML_CURRENCYRETN2C_POST, sizeof(UINT16), 0, 0, 0)

DEFINE_ML(ML_DATETIMERETN2C, 0, 1, sizeof(ML_DATETIMERETN2C_SR), 0)
DEFINE_ML(ML_DATETIMERETN2C_POST, sizeof(UINT16), 0, 0, 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\nativeoverlapped.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMNativeOverlapped.h
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods for allocating and freeing NativeOverlapped
**
** Date:  January, 2000
** 
===========================================================*/
#include "common.h"
#include "fcall.h"
#include "NativeOverlapped.h"
	
#define structsize sizeof(NATIVE_OVERLAPPED)

FCIMPL0(BYTE*, AllocNativeOverlapped)
	BYTE* pOverlapped = new BYTE[structsize];
	LOG((LF_SLOP, LL_INFO10000, "In AllocNativeOperlapped thread 0x%x overlap 0x%x\n", GetThread(), pOverlapped));
	return (pOverlapped);
FCIMPLEND




FCIMPL1(void, FreeNativeOverlapped, BYTE* pOverlapped)
	LOG((LF_SLOP, LL_INFO10000, "In FreeNativeOperlapped thread 0x%x overlap 0x%x\n", GetThread(), pOverlapped));
	//_ASSERTE(pOverlapped);
	delete []  pOverlapped;
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mscorlib.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This file contains the classes, methods, and field used by the EE from mscorlib

//
// To use this, define one of the following 3 macros & include the file like so
//
// #define DEFINE_CLASS(i,n,s)         CLASS__ ## i,
// #define DEFINE_METHOD(c,i,s,g)
// #define DEFINE_FIELD(c,i,s,g,o)
// #include "mscorlib.h"
//

#ifndef DEFINE_CLASS
#define DEFINE_CLASS(i,n,s)
#endif

#ifndef DEFINE_METHOD
#define DEFINE_METHOD(c,i,s,g)
#endif

#ifndef DEFINE_FIELD
#define DEFINE_FIELD(c,i,s,g)
#endif

#ifndef DEFINE_CLASS_U
#define DEFINE_CLASS_U(i,n,s,uc)        DEFINE_CLASS(i,n,s)
#endif

#ifndef DEFINE_FIELD_U
#define DEFINE_FIELD_U(c,i,s,g,uc,uf)
#endif

#ifndef DEFINE_PROPERTY
#define DEFINE_PROPERTY(c,i,s,g)        DEFINE_METHOD(c, GET_ ## i, get_ ## s, IM_Ret ## g)
#endif

#ifndef DEFINE_STATIC_PROPERTY
#define DEFINE_STATIC_PROPERTY(c,i,s,g)        DEFINE_METHOD(c, GET_ ## i, get_ ## s, SM_Ret ## g)
#endif

#ifndef DEFINE_SET_PROPERTY
#define DEFINE_SET_PROPERTY(c,i,s,g) \
    DEFINE_PROPERTY(c,i,s,g) \
    DEFINE_METHOD(c, SET_ ## i, set_ ## s, IM_## g ## _RetVoid)
#endif

// NOTE: Make this window really wide if you want to read the table...

DEFINE_CLASS(ACTIVATOR,             System,                 Activator)

DEFINE_CLASS(APP_DOMAIN,            System,                 AppDomain)
DEFINE_METHOD(APP_DOMAIN,           GET_SERVER_OBJECT,      GetServerObject,            SM_Obj_RetObj)
DEFINE_METHOD(APP_DOMAIN,           ON_UNLOAD,              OnUnloadEvent,              IM_RetVoid)
DEFINE_METHOD(APP_DOMAIN,           ON_ASSEMBLY_LOAD,       OnAssemblyLoadEvent,        IM_Assembly_RetVoid)
DEFINE_METHOD(APP_DOMAIN,           ON_UNHANDLED_EXCEPTION, OnUnhandledExceptionEvent,  IM_Obj_Bool_RetVoid)
DEFINE_METHOD(APP_DOMAIN,           ON_EXIT_PROCESS,        OnExitProcess,              SM_RetVoid)
DEFINE_METHOD(APP_DOMAIN,           ON_RESOURCE_RESOLVE,    OnResourceResolveEvent,     IM_Str_RetAssembly)
DEFINE_METHOD(APP_DOMAIN,           ON_TYPE_RESOLVE,        OnTypeResolveEvent,         IM_Str_RetAssembly)
DEFINE_METHOD(APP_DOMAIN,           ON_ASSEMBLY_RESOLVE,    OnAssemblyResolveEvent,     IM_Str_RetAssembly)
DEFINE_METHOD(APP_DOMAIN,           GET_DATA,               GetData,                    IM_Str_RetObj)
DEFINE_METHOD(APP_DOMAIN,           SET_DATA,               SetData,                    IM_Str_Obj_RetVoid)
DEFINE_METHOD(APP_DOMAIN,           SETUP_DOMAIN,           SetupDomain,                IM_LoaderOptimization_Str_Str_RetVoid)
DEFINE_METHOD(APP_DOMAIN,           CREATE_DOMAIN,          CreateDomain,               SM_Str_Evidence_AppDomainSetup_RetAppDomain)
DEFINE_METHOD(APP_DOMAIN,           CREATE_DOMAINEX,        CreateDomain,               SM_Str_Evidence_Str_Str_Bool_RetAppDomain)
DEFINE_METHOD(APP_DOMAIN,           VAL_CREATE_DOMAIN,      InternalCreateDomain,       SM_Str_RetAppDomain)
DEFINE_METHOD(APP_DOMAIN,           SET_DOMAIN_CONTEXT,     InternalSetDomainContext,   IM_Str_RetVoid)
DEFINE_METHOD(APP_DOMAIN,           UNLOAD,                 Unload,                     SM_AppDomain_RetVoid)
DEFINE_METHOD(APP_DOMAIN,           MARSHAL_OBJECT,         MarshalObject,              SM_Obj_RetArrByte)
DEFINE_METHOD(APP_DOMAIN,           MARSHAL_OBJECTS,        MarshalObjects,             SM_Obj_Obj_RefArrByte_RetArrByte)
DEFINE_METHOD(APP_DOMAIN,           UNMARSHAL_OBJECT,       UnmarshalObject,            SM_ArrByte_RetObj)
DEFINE_METHOD(APP_DOMAIN,           UNMARSHAL_OBJECTS,      UnmarshalObjects,           SM_ArrByte_ArrByte_RefObj_RetObj)
DEFINE_METHOD(APP_DOMAIN,           CREATE_SECURITY_IDENTITY,CreateSecurityIdentity,    IM_Evidence_Evidence_RetEvidence)
DEFINE_METHOD(APP_DOMAIN,           RESET_BINDING_REDIRECTS, ResetBindingRedirects,     IM_RetVoid)

DEFINE_CLASS(APPDOMAIN_SETUP,       System,                 AppDomainSetup)
DEFINE_CLASS(ARGUMENT_HANDLE,       System,                 RuntimeArgumentHandle)

DEFINE_CLASS(ARRAY,                 System,                 Array)

DEFINE_CLASS(ARRAY_LIST,            Collections,            ArrayList)
DEFINE_METHOD(ARRAY_LIST,           CTOR,                   .ctor,                      IM_RetVoid)
DEFINE_METHOD(ARRAY_LIST,           ADD,                    Add,                        IM_Obj_RetInt)

DEFINE_CLASS(ASSEMBLY_BUILDER,      ReflectionEmit,         AssemblyBuilder)

DEFINE_CLASS(ASSEMBLY_HASH_ALGORITHM, Assemblies,           AssemblyHashAlgorithm)

DEFINE_CLASS(ASSEMBLY_NAME,         Reflection,             AssemblyName)
DEFINE_METHOD(ASSEMBLY_NAME,        CTOR,                   .ctor,                      IM_Str_ArrB_Str_AHA_Ver_CI_ANF_RetV)
DEFINE_FIELD_U(ASSEMBLY_NAME,       CODE_BASE,              _CodeBase,                  Str,                            AssemblyNameBaseObject, m_pCodeBase)
DEFINE_FIELD_U(ASSEMBLY_NAME,       NAME,                   _Name,                      Str,                            AssemblyNameBaseObject, m_pSimpleName)

DEFINE_CLASS(ASSEMBLY_NAME_FLAGS,   Reflection,             AssemblyNameFlags)

DEFINE_CLASS(ASSEMBLY,              Reflection,             Assembly)
DEFINE_METHOD(ASSEMBLY,             GET_NAME,               GetName,                    IM_RetAssemblyName)
DEFINE_METHOD(ASSEMBLY,             ON_MODULE_RESOLVE,      OnModuleResolveEvent,       IM_Str_RetModule)
DEFINE_METHOD(ASSEMBLY,             CREATE_SECURITY_IDENTITY,CreateSecurityIdentity,    IM_Str_ArrByte_Int_ArrByte_ArrByte_Evidence_RetEvidence)
DEFINE_METHOD(ASSEMBLY,             DEMAND_PERMISSION,      DemandPermission,           SM_Str_Bool_Int_RetV)
DEFINE_FIELD_U(ASSEMBLY,            FIELD,                  _DontTouchThis,             IntPtr,                         AssemblyBaseObject,       m_pAssembly)

DEFINE_CLASS(ASSEMBLY_REGISTRATION_FLAGS, Interop,          AssemblyRegistrationFlags)

DEFINE_CLASS(ACTIVATION_SERVICES,   Activation,             ActivationServices)
DEFINE_METHOD(ACTIVATION_SERVICES,  IS_CURRENT_CONTEXT_OK,  IsCurrentContextOK,         SM_Type_ArrObject_Bool_RetMarshalByRefObject)
DEFINE_METHOD(ACTIVATION_SERVICES,  CREATE_OBJECT_FOR_COM,  CreateObjectForCom,         SM_Type_ArrObject_Bool_RetMarshalByRefObject)

DEFINE_CLASS(ASYNCCALLBACK,         System,                 AsyncCallback)

DEFINE_CLASS(BINDER,                Reflection,             Binder)
DEFINE_METHOD(BINDER,               CHANGE_TYPE,            ChangeType,                 IM_Obj_Type_CultureInfo_RetObj)

DEFINE_CLASS(BINDING_FLAGS,         Reflection,             BindingFlags)

DEFINE_CLASS(BOOLEAN,               System,                 Boolean)

DEFINE_CLASS(BYTE,                  System,                 Byte)

DEFINE_CLASS(CHAR,                  System,                 Char)

DEFINE_CLASS_U(CLASS,               System,                 RuntimeType,                ReflectClassBaseObject)
DEFINE_METHOD(CLASS,                GET_PROPERTIES,         GetProperties,              IM_BindingFlags_RetArrPropertyInfo)
DEFINE_METHOD(CLASS,                GET_FIELDS,             GetFields,                  IM_BindingFlags_RetArrFieldInfo)
DEFINE_METHOD(CLASS,                GET_METHODS,            GetMethods,                 IM_BindingFlags_RetArrMethodInfo)
DEFINE_METHOD(CLASS,                INVOKE_MEMBER,          InvokeMember,               IM_Str_BindingFlags_Binder_Obj_ArrObj_ArrParameterModifier_CultureInfo_ArrStr_RetObj)
DEFINE_METHOD(CLASS,                FORWARD_CALL_TO_INVOKE, ForwardCallToInvokeMember,  IM_Str_BindingFlags_Obj_ArrInt_RefMessageData_RetObj)

DEFINE_CLASS(CLASS_FILTER,          Reflection,             TypeFilter)
DEFINE_METHOD(CLASS_FILTER,         INVOKE,                 Invoke,                     IM_Type_Obj_RetBool)      

DEFINE_CLASS(CODE_ACCESS_PERMISSION, Security,              CodeAccessPermission)

DEFINE_CLASS_U(COM_OBJECT,          System,                 __ComObject,                                                ComObject)
DEFINE_METHOD(COM_OBJECT,           RELEASE_ALL_DATA,       ReleaseAllData,             IM_RetVoid)
DEFINE_METHOD(COM_OBJECT,           GET_EVENT_PROVIDER,     GetEventProvider,           IM_Type_RetObj)
DEFINE_FIELD_U(COM_OBJECT,          OBJ_TO_DATA_MAP,        m_ObjectToDataMap,          Hashtable,                      ComObject,            m_ObjectToDataMap)
DEFINE_FIELD_U(COM_OBJECT,          WRAP,                   m_wrap,                     IntPtr,                         ComObject,            m_pWrap)

DEFINE_CLASS_U(CONSTRUCTOR,         Reflection,             RuntimeConstructorInfo,     ReflectBaseObject)

DEFINE_CLASS(CONSTRUCTOR_INFO,      Reflection,             ConstructorInfo)

DEFINE_CLASS(CONTEXT,               Contexts,               Context)
DEFINE_FIELD_U(CONTEXT,             PROPS,                  _ctxProps,                  ContextPropertyArray,       ContextBaseObject, m_ctxProps)
DEFINE_FIELD_U(CONTEXT,             DPH,                    _dphCtx,                    DynamicPropertyHolder,      ContextBaseObject, m_dphCtx)
DEFINE_FIELD_U(CONTEXT,             LOCAL_DATA_STORE,       _localDataStore,            LocalDataStore,             ContextBaseObject, m_localDataStore)
DEFINE_FIELD_U(CONTEXT,             SERVER_CONTEXT_CHAIN,   _serverContextChain,        IMessageSink,               ContextBaseObject, m_serverContextChain)
DEFINE_FIELD_U(CONTEXT,             CLIENT_CONTEXT_CHAIN,   _clientContextChain,        IMessageSink,               ContextBaseObject, m_clientContextChain)
DEFINE_FIELD_U(CONTEXT,             APP_DOMAIN,             _appDomain,                 AppDomain,                  ContextBaseObject, m_exposedAppDomain)
DEFINE_FIELD_U(CONTEXT,             CONTEXT_STATICS,        _ctxStatics,                ArrObj,                     ContextBaseObject, m_ctxStatics)
DEFINE_FIELD_U(CONTEXT,             INTERNAL_CONTEXT,       _internalContext,           IntPtr,                     ContextBaseObject, m_internalContext)
DEFINE_METHOD(CONTEXT,              CALLBACK,               DoCallBackFromEE,           SM_Int_Int_Int_RetVoid)
DEFINE_METHOD(CONTEXT,              RESERVE_SLOT,            ReserveSlot,               IM_RetInt)

DEFINE_CLASS(CONTEXT_BOUND_OBJECT,  System,                 ContextBoundObject)


DEFINE_CLASS(CSP_PARAMETERS,        Cryptography,           CspParameters)
DEFINE_FIELD(CSP_PARAMETERS,        PROVIDER_TYPE,          ProviderType,               Int)
DEFINE_FIELD(CSP_PARAMETERS,        PROVIDER_NAME,          ProviderName,               Str)
DEFINE_FIELD(CSP_PARAMETERS,        KEY_CONTAINER_NAME,     KeyContainerName,           Str)
DEFINE_FIELD(CSP_PARAMETERS,        FLAGS,                  cspFlags,                   Int)

DEFINE_CLASS(CULTURE_INFO,          Globalization,          CultureInfo)
DEFINE_METHOD(CULTURE_INFO,         STR_CTOR,               .ctor,                      IM_Str_RetVoid)
DEFINE_METHOD(CULTURE_INFO,         INT_CTOR,               .ctor,                      IM_Int_RetVoid)
DEFINE_FIELD(CULTURE_INFO,          CURRENT_CULTURE,        m_userDefaultCulture,       CultureInfo)
DEFINE_PROPERTY(CULTURE_INFO,       NAME,                   Name,                       Str)
DEFINE_PROPERTY(CULTURE_INFO,       ID,                     LCID,                       Int)
DEFINE_PROPERTY(CULTURE_INFO,       PARENT,                Parent,                      CultureInfo)

DEFINE_CLASS(CURRENCY,              System,                 Currency)

DEFINE_CLASS(CURRENCY_WRAPPER,      Interop,                CurrencyWrapper)

DEFINE_CLASS(CUSTOM_ATTRIBUTE,      Reflection,             CustomAttribute)
DEFINE_FIELD_U(CUSTOM_ATTRIBUTE,    NEXT,           m_next,         CustomAttribute,    CustomAttributeClass,   m_next)
DEFINE_FIELD_U(CUSTOM_ATTRIBUTE,    CA_TYPE,        m_caType,       Type,               CustomAttributeClass,   m_caType)
DEFINE_FIELD_U(CUSTOM_ATTRIBUTE,    TOKEN,          m_ctorToken,    Int,                CustomAttributeClass,   m_ctorToken)
DEFINE_FIELD_U(CUSTOM_ATTRIBUTE,    BLOB,           m_blob,         IntPtr,             CustomAttributeClass,   m_blob)
DEFINE_FIELD_U(CUSTOM_ATTRIBUTE,    BLOB_COUNT,     m_blobCount,    Int,                CustomAttributeClass,   m_blobCount)
DEFINE_FIELD_U(CUSTOM_ATTRIBUTE,    CURRENT_POS,    m_currPos,      Int,                CustomAttributeClass,   m_currPos)
DEFINE_FIELD_U(CUSTOM_ATTRIBUTE,    MODULE,         m_module,       IntPtr,             CustomAttributeClass,   m_module)
DEFINE_FIELD_U(CUSTOM_ATTRIBUTE,    INHERIT_LEVEL,  m_inheritLevel, Int,                CustomAttributeClass,   m_inheritLevel)

DEFINE_CLASS(DATE_TIME,             System,                 DateTime)

DEFINE_CLASS(DECIMAL,               System,                 Decimal)      

DEFINE_CLASS(DELEGATE,              System,                 Delegate)
DEFINE_FIELD(DELEGATE,              METHOD,                 _method,                    RuntimeMethodInfo)
DEFINE_FIELD(DELEGATE,              METHOD_PTR,             _methodPtr,                 IntPtr)
DEFINE_FIELD(DELEGATE,              TARGET,                 _target,                    Obj)
DEFINE_FIELD(DELEGATE,              METHOD_PTR_AUX,         _methodPtrAux,              IntPtr)

DEFINE_CLASS(DISPATCH_WRAPPER,      Interop,                DispatchWrapper)

DEFINE_CLASS(DOUBLE,                System,                 Double)

DEFINE_CLASS(DSA_CSP,               Cryptography,           DSACryptoServiceProvider)
DEFINE_FIELD(DSA_CSP,               KEY_SIZE,               _dwKeySize,                 Int)

DEFINE_CLASS(DYNAMIC_PROPERTY_HOLDER, Contexts,             DynamicPropertyHolder)

DEFINE_CLASS(EMPTY,                 System,                 Empty)

DEFINE_CLASS(ENC_HELPER,            Diagnostics,            EditAndContinueHelper)
DEFINE_FIELD(ENC_HELPER,            OBJECT_REFERENCE,       _objectReference,           Obj)

DEFINE_CLASS(ENCODING,              Text,                   Encoding)

DEFINE_CLASS(ENUM,                  System,                 Enum)

DEFINE_CLASS(ENVIRONMENT,           System,                 Environment)
DEFINE_METHOD(ENVIRONMENT,          INIT_RESOURCE_MANAGER,  InitResourceManager,        SM_RetResourceManager)

DEFINE_CLASS(ERROR_WRAPPER,         Interop,                ErrorWrapper)

DEFINE_CLASS_U(EVENT,               Reflection,             RuntimeEventInfo,           ReflectTokenBaseObject)

DEFINE_CLASS(EVENT_INFO,            Reflection,             EventInfo)

DEFINE_CLASS(EVIDENCE,              Policy,                 Evidence)

DEFINE_CLASS(EXCEPTION,             System,                 Exception)
DEFINE_METHOD(EXCEPTION,            GET_CLASS_NAME,         GetClassName,               IM_RetStr)
DEFINE_PROPERTY(EXCEPTION,          MESSAGE,                Message,                    Str)
DEFINE_PROPERTY(EXCEPTION,          STACK_TRACE,            StackTrace,                 Str)
DEFINE_PROPERTY(EXCEPTION,          SOURCE,                 Source,                     Str)
DEFINE_PROPERTY(EXCEPTION,          HELP_LINK,              HelpLink,                   Str)
DEFINE_FIELD(EXCEPTION,             HRESULT,                _HResult,                   Int)
DEFINE_FIELD(EXCEPTION,             MESSAGE,                _message,                   Str)
DEFINE_FIELD(EXCEPTION,             HELP_URL,               _helpURL,                   Str)
DEFINE_FIELD(EXCEPTION,             STACK_TRACE,            _stackTrace,                Obj)
DEFINE_FIELD(EXCEPTION,             STACK_TRACE_STRING,     _stackTraceString,          Str)
DEFINE_FIELD(EXCEPTION,             SOURCE,                 _source,                    Str)
DEFINE_FIELD(EXCEPTION,             XCODE,                  _xcode,                     Int)
DEFINE_FIELD(EXCEPTION,             XPTRS,                  _xptrs,                     IntPtr)
DEFINE_FIELD(EXCEPTION,             INNER_EXCEPTION,        _innerException,            Exception)
DEFINE_METHOD(EXCEPTION,            INTERNAL_TO_STRING,     InternalToString,           IM_RetStr)

DEFINE_CLASS_U(FIELD,               Reflection,             RuntimeFieldInfo,           ReflectBaseObject)
DEFINE_METHOD(FIELD,                SET_VALUE,              SetValue,                   IM_Obj_Obj_BindingFlags_Binder_CultureInfo_RetVoid)
DEFINE_METHOD(FIELD,                GET_VALUE,              GetValue,                   IM_Obj_RetObj)

DEFINE_CLASS(FIELD_INFO,            Reflection,             FieldInfo)

DEFINE_CLASS(FIELD_HANDLE,          System,                 RuntimeFieldHandle)

DEFINE_CLASS(FILE_MODE,             IO,                     FileMode)

DEFINE_CLASS(FILE_ACCESS,           IO,                     FileAccess)

DEFINE_CLASS(FILE_SHARE,            IO,                     FileShare)

DEFINE_CLASS(FRAME_SECURITY_DESCRIPTOR, Security,           FrameSecurityDescriptor)
DEFINE_FIELD(FRAME_SECURITY_DESCRIPTOR, ASSERT_PERMSET,     m_assertions,               PMS)
DEFINE_FIELD(FRAME_SECURITY_DESCRIPTOR, DENY_PERMSET,       m_denials,                  PMS)
DEFINE_FIELD(FRAME_SECURITY_DESCRIPTOR, RESTRICTION_PERMSET, m_restriction,             PMS)

DEFINE_CLASS(GUID,                  System,                 Guid)

DEFINE_CLASS(IASYNCRESULT,          System,                 IAsyncResult)

DEFINE_CLASS(ICONFIG_HELPER,        System,                 IConfigHelper)    

DEFINE_CLASS(ICONTEXT_PROPERTY,     Contexts,               IContextProperty)

DEFINE_CLASS(ICUSTOM_ATTR_PROVIDER, Reflection,             ICustomAttributeProvider)
DEFINE_METHOD(ICUSTOM_ATTR_PROVIDER,GET_CUSTOM_ATTRIBUTES,  GetCustomAttributes,        IM_Type_RetArrObj)

DEFINE_CLASS(ICUSTOM_MARSHALER,     Interop,                ICustomMarshaler)
DEFINE_METHOD(ICUSTOM_MARSHALER,    MARSHAL_NATIVE_TO_MANAGED,MarshalNativeToManaged,   IM_Ptr_RetObj)
DEFINE_METHOD(ICUSTOM_MARSHALER,    MARSHAL_MANAGED_TO_NATIVE,MarshalManagedToNative,   IM_Obj_RetPtr)
DEFINE_METHOD(ICUSTOM_MARSHALER,    CLEANUP_NATIVE_DATA,    CleanUpNativeData,          IM_Ptr_RetVoid)
DEFINE_METHOD(ICUSTOM_MARSHALER,    CLEANUP_MANAGED_DATA,   CleanUpManagedData,         IM_Obj_RetVoid)
DEFINE_METHOD(ICUSTOM_MARSHALER,    GET_NATIVE_DATA_SIZE,   GetNativeDataSize,         IM_RetInt)

DEFINE_CLASS(IDENTITY,              Remoting,               Identity)
DEFINE_FIELD(IDENTITY,              TP_OR_OBJECT,           _tpOrObject,                     Obj)

DEFINE_CLASS(IENUMERATOR,           Collections,            IEnumerator)

DEFINE_CLASS(IENUMERABLE,           Collections,            IEnumerable)

DEFINE_CLASS(IEVIDENCE_FACTORY,     Security,               IEvidenceFactory)

DEFINE_CLASS(IEXPANDO,              Expando,                IExpando)
DEFINE_METHOD(IEXPANDO,             ADD_FIELD,              AddField,                   IM_Str_RetFieldInfo)
DEFINE_METHOD(IEXPANDO,             REMOVE_MEMBER,          RemoveMember,               IM_MemberInfo_RetVoid)

DEFINE_CLASS(ISSEXCEPTION,          IsolatedStorage,        IsolatedStorageException)

DEFINE_CLASS(ILLOGICAL_CALL_CONTEXT,Messaging,              IllogicalCallContext)

DEFINE_CLASS(IMESSAGE,              Messaging,              IMessage)

DEFINE_CLASS(IMESSAGE_SINK,         Messaging,              IMessageSink)

DEFINE_CLASS(INT16,                 System,                 Int16)

DEFINE_CLASS(INT32,                 System,                 Int32)

DEFINE_CLASS(INT64,                 System,                 Int64)

DEFINE_CLASS(IPERMISSION,           Security,               IPermission)

DEFINE_CLASS(IPRINCIPAL,            Principal,              IPrincipal)

DEFINE_CLASS(IREFLECT,              Reflection,             IReflect)
DEFINE_METHOD(IREFLECT,             GET_PROPERTIES,         GetProperties,              IM_BindingFlags_RetArrPropertyInfo)
DEFINE_METHOD(IREFLECT,             GET_FIELDS,             GetFields,                  IM_BindingFlags_RetArrFieldInfo)
DEFINE_METHOD(IREFLECT,             GET_METHODS,            GetMethods,                 IM_BindingFlags_RetArrMethodInfo)
DEFINE_METHOD(IREFLECT,             INVOKE_MEMBER,          InvokeMember,               IM_Str_BindingFlags_Binder_Obj_ArrObj_ArrParameterModifier_CultureInfo_ArrStr_RetObj)

DEFINE_CLASS(ISS_STORE,             IsolatedStorage,        IsolatedStorage)
DEFINE_CLASS(ISS_STORE_FILE,        IsolatedStorage,        IsolatedStorageFile)
DEFINE_CLASS(ISS_STORE_FILE_STREAM, IsolatedStorage,        IsolatedStorageFileStream)

DEFINE_CLASS(LCID_CONVERSION_TYPE,  Interop,                LCIDConversionAttribute)

DEFINE_CLASS(HASHTABLE,             Collections,            Hashtable)

DEFINE_CLASS(LOADER_OPTIMIZATION,   System,                 LoaderOptimization)

DEFINE_CLASS(LOCAL_DATA_STORE,      System,                 LocalDataStore)

DEFINE_CLASS(LOGICAL_CALL_CONTEXT,  Messaging,              LogicalCallContext)

DEFINE_CLASS(MARSHAL,               Interop,                Marshal)
DEFINE_METHOD(MARSHAL,              LOAD_LICENSE_MANAGER,   LoadLicenseManager,         SM_Void_RetRuntimeTypeHandle)

DEFINE_CLASS(MARSHAL_BY_REF_OBJECT, System,                 MarshalByRefObject)
DEFINE_FIELD(MARSHAL_BY_REF_OBJECT, IDENTITY,               __identity,                 Obj)
//DEFINE_METHOD(MARSHAL_BY_REF_OBJECT,GET_COM_IP,             GetComIP,                   IM_RetInt)

DEFINE_CLASS(MCM_DICTIONARY,        Messaging,              MCMDictionary)

DEFINE_CLASS(MEMBER,                Reflection,             MemberInfo)

DEFINE_CLASS(MEMBER_FILTER,         Reflection,             MemberFilter)
DEFINE_METHOD(MEMBER_FILTER,        INVOKE,                 Invoke,                     IM_MemberInfo_Obj_RetBool)

DEFINE_CLASS(MESSAGE,               Messaging,              Message)
DEFINE_FIELD_U(MESSAGE,             METHOD_NAME,            _MethodName,                Str,                        MessageObject,       pMethodName)
DEFINE_FIELD_U(MESSAGE,             METHOD_SIG,             _MethodSignature,           ArrType,                    MessageObject,       pMethodSig)
DEFINE_FIELD_U(MESSAGE,             METHOD_BASE,            _MethodBase,                MethodBase,                 MessageObject,       pMethodBase)
DEFINE_FIELD_U(MESSAGE,             HASH_TABLE,             _properties,                Obj,                        MessageObject,       pHashTable)
DEFINE_FIELD_U(MESSAGE,             URI,                    _URI,                       Str,                        MessageObject,       pURI)
DEFINE_FIELD_U(MESSAGE,             FRAME,                  _frame,                     IntPtr,                     MessageObject,       pFrame)
DEFINE_FIELD_U(MESSAGE,             METHOD_DESC,            _methodDesc,                IntPtr,                     MessageObject,       pMethodDesc)
DEFINE_FIELD_U(MESSAGE,             LAST,                   _last,                      Int,                        MessageObject,       iLast)
DEFINE_FIELD_U(MESSAGE,             METASIG_HOLDER,         _metaSigHolder,             IntPtr,                     MessageObject,       pMetaSigHolder)
DEFINE_FIELD_U(MESSAGE,             TYPE_NAME,              _typeName,                  Str,                        MessageObject,       pTypeName)
DEFINE_FIELD_U(MESSAGE,             INIT_DONE,              _initDone,                  Bool,                       MessageObject,       initDone)

DEFINE_CLASS(MESSAGE_DATA,          Proxies,              MessageData)

DEFINE_CLASS_U(METHOD,              Reflection,             RuntimeMethodInfo,          ReflectBaseObject)
DEFINE_METHOD(METHOD,               INVOKE,                 Invoke,                     IM_Obj_BindingFlags_Binder_ArrObj_CultureInfo_RetObj)
DEFINE_METHOD(METHOD,               GET_PARAMETERS,         GetParameters,              IM_RetArrParameterInfo)

DEFINE_CLASS(METHOD_BASE,           Reflection,             MethodBase)
DEFINE_METHOD(METHOD_BASE,          GET_CURRENT_METHOD,     GetCurrentMethod,           SM_RetMethodBase)

DEFINE_CLASS(METHOD_INFO,           Reflection,             MethodInfo)

DEFINE_CLASS(METHOD_HANDLE,         System,                 RuntimeMethodHandle)

DEFINE_CLASS(METHOD_RENTAL,         ReflectionEmit,         MethodRental)

DEFINE_CLASS(MISSING,               Reflection,             Missing)
DEFINE_FIELD(MISSING,               VALUE,                  Value,                      Missing)

DEFINE_CLASS_U(MODULE,              Reflection,             Module,                     ReflectModuleBaseObject)
DEFINE_FIELD(MODULE,                FILTER_CLASS_NAME,      FilterTypeName,             TypeFilter)
DEFINE_FIELD(MODULE,                FILTER_CLASS_NAME_IC,   FilterTypeNameIgnoreCase,   TypeFilter)

DEFINE_CLASS(MODULE_BUILDER,        ReflectionEmit,         ModuleBuilder)

DEFINE_CLASS(MULTICAST_DELEGATE,    System,                 MulticastDelegate)
DEFINE_FIELD(MULTICAST_DELEGATE,    NEXT,                   _prev,                      MulticastDelegate)

DEFINE_CLASS(NULL,                  System,                 DBNull)

// Keep this in sync with System.Globalization.NumberFormatInfo
DEFINE_CLASS(NUMBERFORMATINFO,         Globalization,       NumberFormatInfo)
DEFINE_FIELD_U(NUMBERFORMATINFO,       NUMBERGROUPSIZES,    numberGroupSizes,       ArrInt, NumberFormatInfo,   cNumberGroup)
DEFINE_FIELD_U(NUMBERFORMATINFO,       CURRENCYGROUPSIZES,  currencyGroupSizes,     ArrInt, NumberFormatInfo,   cCurrencyGroup)
DEFINE_FIELD_U(NUMBERFORMATINFO,       PERCENTGROUPSIZS,    percentGroupSizes,      ArrInt, NumberFormatInfo,   cPercentGroup)
DEFINE_FIELD_U(NUMBERFORMATINFO,       POSITIVESIGN,        positiveSign,           Str,    NumberFormatInfo,   sPositive)
DEFINE_FIELD_U(NUMBERFORMATINFO,       NEGATIVESIGN,        negativeSign,           Str,    NumberFormatInfo,   sNegative)
DEFINE_FIELD_U(NUMBERFORMATINFO,       NUMBERDECIMALSEP,    numberDecimalSeparator, Str,    NumberFormatInfo,   sNumberDecimal)
DEFINE_FIELD_U(NUMBERFORMATINFO,       NUMBERGROUPSEP,      numberGroupSeparator,   Str,    NumberFormatInfo,   sNumberGroup)
DEFINE_FIELD_U(NUMBERFORMATINFO,       CURRENCYGROUPSEP,    currencyGroupSeparator, Str,    NumberFormatInfo,   sCurrencyGroup)
DEFINE_FIELD_U(NUMBERFORMATINFO,       CURRENCYDECIMALSEP,  currencyDecimalSeparator,Str,   NumberFormatInfo,   sCurrencyDecimal)
DEFINE_FIELD_U(NUMBERFORMATINFO,       CURRENCYSYMBOL,      currencySymbol,         Str,    NumberFormatInfo,   sCurrency)
DEFINE_FIELD_U(NUMBERFORMATINFO,       ANSICURRENCYSYMBOL,  ansiCurrencySymbol,     Str,    NumberFormatInfo,   sAnsiCurrency)
DEFINE_FIELD_U(NUMBERFORMATINFO,       NANSYMBOL,           nanSymbol,              Str,    NumberFormatInfo,   sNaN)
DEFINE_FIELD_U(NUMBERFORMATINFO,       POSITIVEINFINITYSYM, positiveInfinitySymbol, Str,    NumberFormatInfo,   sPositiveInfinity)
DEFINE_FIELD_U(NUMBERFORMATINFO,       NEGATIVEEINFINITYSYM,negativeInfinitySymbol, Str,    NumberFormatInfo,   sNegativeInfinity)
DEFINE_FIELD_U(NUMBERFORMATINFO,       PERCENTDECIMALSEP,   percentDecimalSeparator,Str,    NumberFormatInfo,   sPercentDecimal)
DEFINE_FIELD_U(NUMBERFORMATINFO,       PERCENTGROUPSEP,     percentGroupSeparator,  Str,    NumberFormatInfo,   sPercentGroup)
DEFINE_FIELD_U(NUMBERFORMATINFO,       PERCENTSYMBOL,       percentSymbol,          Str,    NumberFormatInfo,   sPercent)
DEFINE_FIELD_U(NUMBERFORMATINFO,       PERMILLESYMBOL,      perMilleSymbol,         Str,    NumberFormatInfo,   sPerMille)
DEFINE_FIELD_U(NUMBERFORMATINFO,       DATAITEM,            m_dataItem,             Int,  NumberFormatInfo,   iDataItem)
DEFINE_FIELD_U(NUMBERFORMATINFO,       NUMBERDECIMALDIGITS, numberDecimalDigits,    Int,  NumberFormatInfo,   cNumberDecimals)
DEFINE_FIELD_U(NUMBERFORMATINFO,       CURRENCYDECIMALDIGITS,currencyDecimalDigits, Int,  NumberFormatInfo,   cCurrencyDecimals)
DEFINE_FIELD_U(NUMBERFORMATINFO,       CURRENCYPOSPATTERN,  currencyPositivePattern,Int,  NumberFormatInfo,   cPosCurrencyFormat)
DEFINE_FIELD_U(NUMBERFORMATINFO,       CURRENCYNEGPATTERN,  currencyNegativePattern,Int,  NumberFormatInfo,   cNegCurrencyFormat)
DEFINE_FIELD_U(NUMBERFORMATINFO,       NUMBERNEGPATTERN,    numberNegativePattern,  Int,  NumberFormatInfo,   cNegativeNumberFormat) 
DEFINE_FIELD_U(NUMBERFORMATINFO,       PERCENTPOSPATTERN,   percentPositivePattern, Int,  NumberFormatInfo,   cPositivePercentFormat)
DEFINE_FIELD_U(NUMBERFORMATINFO,       PERCENTNEGPATTERN,   percentNegativePattern, Int,  NumberFormatInfo,   cNegativePercentFormat)
DEFINE_FIELD_U(NUMBERFORMATINFO,       PERCENTDECIMALDIGITS,percentDecimalDigits,   Int,  NumberFormatInfo,   cPercentDecimals)
DEFINE_FIELD_U(NUMBERFORMATINFO,       ISREADONLY,          isReadOnly,             Bool, NumberFormatInfo,   bIsReadOnly)
DEFINE_FIELD_U(NUMBERFORMATINFO,       USEROVERRIDE,        m_useUserOverride,      Bool, NumberFormatInfo,   bUseUserOverride)
DEFINE_FIELD_U(NUMBERFORMATINFO,       PARSENUMBERFLAG,     validForParseAsNumber,  Bool, NumberFormatInfo,   bValidForParseAsNumber)
DEFINE_FIELD_U(NUMBERFORMATINFO,       PARSECURRENCYFLAG,   validForParseAsCurrency,Bool, NumberFormatInfo,   bValidForParseAsCurrency)



DEFINE_CLASS(OBJECT,                System,                 Object)
DEFINE_METHOD(OBJECT,               FINALIZE,               Finalize,                   IM_RetVoid)
DEFINE_METHOD(OBJECT,               TO_STRING,              ToString,                   IM_RetStr)
DEFINE_METHOD(OBJECT,               GET_TYPE,               GetType,                    IM_RetType)
DEFINE_METHOD(OBJECT,               FAST_GET_TYPE,          FastGetExistingType,        IM_RetType)
DEFINE_METHOD(OBJECT,               INTERNAL_GET_TYPE,      InternalGetType,            IM_RetType)
DEFINE_METHOD(OBJECT,               FIELD_SETTER,           FieldSetter,                IM_Str_Str_Obj_RetVoid)
DEFINE_METHOD(OBJECT,               FIELD_GETTER,           FieldGetter,                IM_Str_Str_RefObj_RetVoid)


DEFINE_CLASS(OLE_AUT_BINDER,        System,                 OleAutBinder)    

DEFINE_CLASS(PARAM_ARRAY_ATTRIBUTE, System,                 ParamArrayAttribute)

DEFINE_CLASS(PARAMETER,             Reflection,             ParameterInfo)
DEFINE_FIELD(PARAMETER,             IMPORTER,               _importer,                  IntPtr)
DEFINE_FIELD(PARAMETER,             TOKEN,                  _token,                     Int)

DEFINE_CLASS(PARAMETER_MODIFIER,    Reflection,             ParameterModifier)

DEFINE_CLASS(TOKEN_BASED_SET,       Util,                   TokenBasedSet)
DEFINE_CLASS(PERMISSION_SET,        Security,               PermissionSet)
DEFINE_METHOD(PERMISSION_SET,       CTOR,                   .ctor,                      IM_Bool_RetVoid)
DEFINE_METHOD(PERMISSION_SET,       CONVERT,                ConvertPermissionSet,       SM_Str_ArrByte_Str_RetArrByte)
DEFINE_METHOD(PERMISSION_SET,       CREATE_SERIALIZED,      CreateSerialized,           SM_ArrObj_RefArrByte_RetArrByte)
DEFINE_METHOD(PERMISSION_SET,       SETUP_SECURITY,         SetupSecurity,              SM_RetVoid)
DEFINE_METHOD(PERMISSION_SET,       GET_SAFE_PERMISSION_SET,GetSafePermissionSet,       SM_Int_RetArrByte)
DEFINE_METHOD(PERMISSION_SET,       CONTAINS,               Contains,                   IM_IPermission_RetBool)
DEFINE_METHOD(PERMISSION_SET,       DEMAND,                 Demand,                     IM_RetVoid)
DEFINE_METHOD(PERMISSION_SET,       DECODE_XML,             DecodeXml,                  IM_ArrByte_RefInt_RetBool)
DEFINE_METHOD(PERMISSION_SET,       ENCODE_BINARY,          EncodeBinary,               IM_RetArrByte)
DEFINE_METHOD(PERMISSION_SET,       ENCODE_XML,             EncodeXml,               IM_RetArrByte)
DEFINE_METHOD(PERMISSION_SET,       ENCODE_SPECIFICATION,   EncodePermissionSpecification,SM_ArrByte_RetArrByte)
DEFINE_METHOD(PERMISSION_SET,       IS_UNRESTRICTED,        IsUnrestricted,             IM_RetBool)
DEFINE_METHOD(PERMISSION_SET,       IS_SUBSET_OF,           IsSubsetOf,                 IM_PMS_RetBool)
DEFINE_METHOD(PERMISSION_SET,       ADD_PERMISSION,         AddPermission,              IM_IPermission_RetIPermission)
DEFINE_METHOD(PERMISSION_SET,       INPLACE_UNION,          InplaceUnion,               IM_PMS_RetVoid)
DEFINE_METHOD(PERMISSION_SET,       IS_EMPTY,               IsEmpty,                    IM_RetBool)
DEFINE_FIELD(PERMISSION_SET,        NORMAL_PERM_SET,        m_normalPermSet,            TokenBasedSet)

DEFINE_CLASS(PERMISSION_LIST_SET,   Security,               PermissionListSet)
DEFINE_METHOD(PERMISSION_LIST_SET,  CTOR,                   .ctor,                      IM_RetVoid)
DEFINE_METHOD(PERMISSION_LIST_SET,  APPEND_STACK,           AppendStack,                IM_PermissionListSet_RetVoid)
DEFINE_METHOD(PERMISSION_LIST_SET,  CHECK_DEMAND,           CheckDemand,                IM_CodeAccessPermission_RetBool)
DEFINE_METHOD(PERMISSION_LIST_SET,  CHECK_DEMAND_TOKEN,     CheckDemand,                IM_CodeAccessPermission_PermissionToken_RetBool)
DEFINE_METHOD(PERMISSION_LIST_SET,  CHECK_SET_DEMAND,       CheckSetDemand,             IM_PMS_OutPMS_RetBool)
DEFINE_METHOD(PERMISSION_LIST_SET,  CHECK_DEMAND_NO_THROW,  CheckDemandNoThrow,         IM_CodeAccessPermission_RetBool)
DEFINE_METHOD(PERMISSION_LIST_SET,  CHECK_DEMAND_TOKEN_NO_THROW, CheckDemandNoThrow,    IM_CodeAccessPermission_PermissionToken_RetBool)
DEFINE_METHOD(PERMISSION_LIST_SET,  CHECK_SET_DEMAND_NO_THROW, CheckSetDemandNoThrow,   IM_PMS_RetBool)
DEFINE_METHOD(PERMISSION_LIST_SET,  GET_ZONE_AND_ORIGIN,    GetZoneAndOrigin,           IM_ArrayList_ArrayList_RetVoid)

DEFINE_CLASS(PERMISSION_TOKEN,      Security,               PermissionToken)
DEFINE_CLASS(ALLOW_PARTIALLY_TRUSTED_CALLER, Security,              AllowPartiallyTrustedCallersAttribute)

DEFINE_CLASS(PLATFORM_ID,           System,                 PlatformID)

DEFINE_CLASS(POINTER,               Reflection,             Pointer)
DEFINE_FIELD(POINTER,               VALUE,                  _ptr,                       PtrVoid)
DEFINE_FIELD(POINTER,               TYPE,                   _ptrType,                   Type)

DEFINE_CLASS_U(PROPERTY,            Reflection,             RuntimePropertyInfo,        ReflectBaseObject)
DEFINE_METHOD(PROPERTY,             SET_VALUE,              SetValue,                   IM_Obj_Obj_BindingFlags_Binder_ArrObj_CultureInfo_RetVoid)
DEFINE_METHOD(PROPERTY,             GET_VALUE,              GetValue,                   IM_Obj_BindingFlags_Binder_ArrObj_CultureInfo_RetObj)
DEFINE_METHOD(PROPERTY,             GET_INDEX_PARAMETERS,  GetIndexParameters,          IM_RetArrParameterInfo)

DEFINE_CLASS(PROPERTY_INFO,         Reflection,             PropertyInfo)

DEFINE_CLASS(PROXY_ATTRIBUTE,       Proxies,                ProxyAttribute)

DEFINE_CLASS(REAL_PROXY,            Proxies,                RealProxy)
DEFINE_FIELD(REAL_PROXY,            TP,                     _tp,                        Obj)                      
DEFINE_FIELD(REAL_PROXY,            IDENTITY,               _identity,                  Obj)
DEFINE_FIELD(REAL_PROXY,            SERVER,                 _serverObject,              MarshalByRefObject)
DEFINE_METHOD(REAL_PROXY,           PRIVATE_INVOKE,         PrivateInvoke,              IM_RefMessageData_Int_RetVoid)
DEFINE_METHOD(REAL_PROXY,           GETDCOMPROXY,           GetCOMIUnknown,             IM_Bool_RetPtr)
DEFINE_METHOD(REAL_PROXY,           SETDCOMPROXY,           SetCOMIUnknown,             IM_Ptr_RetVoid)
DEFINE_METHOD(REAL_PROXY,           SUPPORTSINTERFACE,      SupportsInterface,          IM_RefGuid_RetIntPtr)

DEFINE_CLASS(REFLECTION_PERMISSION, Permissions,            ReflectionPermission)
DEFINE_METHOD(REFLECTION_PERMISSION,  CTOR,                   .ctor,                    IM_ReflectionPermissionFlag_RetVoid)

DEFINE_CLASS(REFLECTION_PERMISSION_FLAG, Permissions,       ReflectionPermissionFlag)

DEFINE_CLASS(REGISTRATION_SERVICES, Interop,                RegistrationServices)
DEFINE_METHOD(REGISTRATION_SERVICES,REGISTER_ASSEMBLY,      RegisterAssembly,           IM_Assembly_AssemblyRegistrationFlags_RetBool)
DEFINE_METHOD(REGISTRATION_SERVICES,UNREGISTER_ASSEMBLY,    UnregisterAssembly,         IM_Assembly_RetBool)

DEFINE_CLASS(REMOTING_PROXY,        Proxies,                RemotingProxy)
DEFINE_METHOD(REMOTING_PROXY,       INVOKE,                 Invoke,                     SM_Obj_RefMessageData_RetVoid)

DEFINE_CLASS(REMOTING_SERVICES,     Remoting,               RemotingServices)
DEFINE_METHOD(REMOTING_SERVICES,    CHECK_CAST,             CheckCast,                  SM_RealProxy_Type_RetBool)
DEFINE_METHOD(REMOTING_SERVICES,    GET_TYPE,               GetType,                    SM_Obj_RetObj)
DEFINE_METHOD(REMOTING_SERVICES,    WRAP,                   Wrap,                       SM_ContextBoundObject_RetObj)
DEFINE_METHOD(REMOTING_SERVICES,    CREATE_PROXY_FOR_DOMAIN,CreateProxyForDomain,       SM_Int_Int_RetObj)
DEFINE_METHOD(REMOTING_SERVICES,    GET_SERVER_CONTEXT_FOR_PROXY,GetServerContextForProxy,  SM_Obj_RetInt)        
DEFINE_METHOD(REMOTING_SERVICES,    GET_SERVER_DOMAIN_ID_FOR_PROXY,GetServerDomainIdForProxy,  SM_Obj_RetInt)        
DEFINE_METHOD(REMOTING_SERVICES,    MARSHAL_TO_BUFFER,      MarshalToBuffer,            SM_Obj_RetArrByte)
DEFINE_METHOD(REMOTING_SERVICES,    UNMARSHAL_FROM_BUFFER,  UnmarshalFromBuffer,        SM_ArrByte_RetObj)

DEFINE_CLASS(RESOURCE_MANAGER,      Resources,              ResourceManager)
DEFINE_METHOD(RESOURCE_MANAGER,     GET_STRING,             GetString,                  IM_Str_RetStr)

DEFINE_CLASS(SBYTE,                 System,                 SByte)

DEFINE_CLASS(SECURITY_ACTION,       Permissions,            SecurityAction)

DEFINE_CLASS(SECURITY_ELEMENT,      Security,               SecurityElement)
DEFINE_METHOD(SECURITY_ELEMENT,     TO_STRING,              ToString,                   IM_RetStr)

DEFINE_CLASS(SECURITY_ENGINE,       Security,               CodeAccessSecurityEngine)
DEFINE_METHOD(SECURITY_ENGINE,      CHECK_HELPER,           CheckHelper,                SM_PMS_PMS_CodeAccessPermission_PermissionToken_RetVoid)
DEFINE_METHOD(SECURITY_ENGINE,      LAZY_CHECK_SET_HELPER,  LazyCheckSetHelper,         SM_PMS_IntPtr_RetVoid)
DEFINE_METHOD(SECURITY_ENGINE,      CHECK_SET_HELPER,       CheckSetHelper,             SM_PMS_PMS_PMS_RetVoid)
DEFINE_METHOD(SECURITY_ENGINE,      STACK_COMPRESS_WALK_HELPER, StackCompressWalkHelper,SM_PermissionListSet_Bool_PMS_PMS_FrameSecurityDescriptor_RetBool)    
DEFINE_METHOD(SECURITY_ENGINE,      GET_COMPRESSED_STACK,   GetCompressedStack,         IM_RefStackCrawlMark_RetPermissionListSet)
DEFINE_METHOD(SECURITY_ENGINE,      GET_ZONE_AND_ORIGIN_HELPER, GetZoneAndOriginHelper, SM_PMS_PMS_ArrayList_ArrayList_RetVoid)

DEFINE_CLASS(SECURITY_EXCEPTION,    Security,               SecurityException)
DEFINE_METHOD(SECURITY_EXCEPTION,   CTOR,                   .ctor,                      IM_Str_Type_Str_RetVoid)
DEFINE_METHOD(SECURITY_EXCEPTION,   CTOR2,                  .ctor,                      IM_PMS_PMS_RetVoid)

DEFINE_CLASS(SECURITY_MANAGER,      Security,               SecurityManager)
DEFINE_METHOD(SECURITY_MANAGER,     GET_DEFAULT_MY_COMPUTER_POLICY,GetDefaultMyComputerPolicy,SM_RefPMS_RetPMS)
DEFINE_METHOD(SECURITY_MANAGER,     GET_SECURITY_ENGINE,    GetCodeAccessSecurityEngine,SM_RetCodeAccessSecurityEngine)
DEFINE_METHOD(SECURITY_MANAGER,     RESOLVE_POLICY,         ResolvePolicy,              SM_Evidence_PMS_PMS_PMS_PMS_int_Bool_RetPMS)
DEFINE_METHOD(SECURITY_MANAGER,     CHECK_GRANT_SETS,       CheckGrantSets,             SM_Evidence_PMS_PMS_PMS_PMS_PMS_RetBool)
DEFINE_METHOD(SECURITY_MANAGER,     CHECK_PERMISSION_TO_SET_GLOBAL_FLAGS,CheckPermissionToSetGlobalFlags,SM_Int_RetVoid)

DEFINE_CLASS(SECURITY_PERMISSION,   Permissions,            SecurityPermission)
DEFINE_METHOD(SECURITY_PERMISSION,  CTOR,                   .ctor,                      IM_SecurityPermissionFlag_RetVoid)
DEFINE_METHOD(SECURITY_PERMISSION,  TOXML,                  ToXml,                      IM_RetSecurityElement)

DEFINE_CLASS(SECURITY_PERMISSION_FLAG,Permissions,          SecurityPermissionFlag)

DEFINE_CLASS(SECURITY_RUNTIME,      Security,               SecurityRuntime)
DEFINE_METHOD(SECURITY_RUNTIME,     FRAME_DESC_HELPER,      FrameDescHelper,            SM_FrameSecurityDescriptor_IPermission_PermissionToken_RetBool)
DEFINE_METHOD(SECURITY_RUNTIME,     FRAME_DESC_SET_HELPER,  FrameDescSetHelper,         SM_FrameSecurityDescriptor_PMS_PMS_RetBool)
DEFINE_METHOD(SECURITY_RUNTIME,     OVERRIDES_HELPER,       OverridesHelper,            SM_FrameSecurityDescriptor_RetInt)

DEFINE_CLASS(SERVER_IDENTITY,       Remoting,               ServerIdentity)
DEFINE_FIELD(SERVER_IDENTITY,       SERVER_CONTEXT,         _srvCtx,                    Context)


DEFINE_CLASS(SHARED_STATICS,        System,                 SharedStatics)
DEFINE_FIELD(SHARED_STATICS,        SHARED_STATICS,         _sharedStatics,             SharedStatics)

DEFINE_CLASS(SINGLE,                System,                 Single)

DEFINE_CLASS(STACK_BUILDER_SINK,    Messaging,              StackBuilderSink)
DEFINE_METHOD(STACK_BUILDER_SINK,   PRIVATE_PROCESS_MESSAGE,PrivateProcessMessage,      IM_MethodBase_ArrObj_Obj_Int_Bool_RefArrObj_RetObj)

DEFINE_CLASS(STACK_FRAME_HELPER,    Diagnostics,            StackFrameHelper)

DEFINE_CLASS(STACKCRAWL_MARK,       Threading,              StackCrawlMark)

DEFINE_CLASS(STREAM,                IO,                     Stream)

DEFINE_CLASS(STRING,                System,                 String)
DEFINE_FIELD(STRING,                EMPTY,                  Empty,                      Str)
DEFINE_METHOD(STRING,               CREATE_STRING,          CreateString,               SM_PtrSByt_Int_Int_Encoding_RetStr)

DEFINE_CLASS_U(STRING_BUILDER,      Text,                   StringBuilder,              StringBufferObject)

DEFINE_CLASS(STRONG_NAME_KEY_PAIR,  Reflection,             StrongNameKeyPair)
DEFINE_METHOD(STRONG_NAME_KEY_PAIR, GET_KEY_PAIR,           GetKeyPair,                 IM_RefObject_RetBool) 

DEFINE_CLASS(TCE_EVENT_ITF_INFO,    InteropTCE,             EventItfInfo)
DEFINE_METHOD(TCE_EVENT_ITF_INFO,   CTOR,                   .ctor,                      IM_Str_Str_Str_Assembly_Assembly_RetVoid)

DEFINE_CLASS(TEXT_READER,           IO,                     TextReader)

DEFINE_CLASS(TEXT_WRITER,           IO,                     TextWriter)

DEFINE_CLASS(THREAD,                Threading,              Thread)
DEFINE_METHOD(THREAD,               SET_PRINCIPAL_INTERNAL, SetPrincipalInternal,       IM_IPrincipal_RetVoid)
DEFINE_METHOD(THREAD,               REMOVE_DLS,             RemoveDomainLocalStore,     SM_LocalDataStore_RetVoid)
DEFINE_STATIC_PROPERTY(THREAD,      CURRENT_CONTEXT,        CurrentContext,             Context)
DEFINE_METHOD(THREAD,               RESERVE_SLOT,           ReserveSlot,                IM_RetInt)
DEFINE_SET_PROPERTY(THREAD,         CULTURE,                CurrentCulture,             CultureInfo)
DEFINE_SET_PROPERTY(THREAD,         UI_CULTURE,             CurrentUICulture,           CultureInfo)
DEFINE_FIELD_U(THREAD,              CONTEXT,                m_Context,                  Context,                        ThreadBaseObject,     m_ExposedContext)
DEFINE_FIELD_U(THREAD,              LOGICAL_CALL_CONTEXT,   m_LogicalCallContext,       LogicalCallContext,             ThreadBaseObject,     m_LogicalCallContext)
DEFINE_FIELD_U(THREAD,              ILLOGICAL_CALL_CONTEXT, m_IllogicalCallContext,     IllogicalCallContext,           ThreadBaseObject,     m_IllogicalCallContext)
DEFINE_FIELD_U(THREAD,              THREAD_STATICS,         m_ThreadStatics,            ArrObj,                         ThreadBaseObject,     m_ThreadStatics)
DEFINE_FIELD_U(THREAD,              THREAD_STATICS_BITS,    m_ThreadStaticsBits,        ArrInt,                     ThreadBaseObject,     m_ThreadStaticsBits)
DEFINE_FIELD_U(THREAD,              UI_CULTURE,             m_CurrentUICulture,         CultureInfo,                    ThreadBaseObject,     m_CurrentUICulture)
DEFINE_FIELD_U(THREAD,              PRIORITY,               m_Priority,                 Int,                            ThreadBaseObject,     m_Priority)
DEFINE_FIELD_U(THREAD,              INTERNAL_THREAD,        DONT_USE_InternalThread,    IntPtr,                         ThreadBaseObject,     m_InternalThread)

DEFINE_CLASS(TIMESPAN,              System,                 TimeSpan)

DEFINE_CLASS(TRANSPARENT_PROXY,     Proxies,                __TransparentProxy)
DEFINE_FIELD(TRANSPARENT_PROXY,     RP,                     _rp,                        RealProxy)
DEFINE_FIELD(TRANSPARENT_PROXY,     MT,                     _pMT,                       IntPtr)
DEFINE_FIELD(TRANSPARENT_PROXY,     INTERFACE_MT,           _pInterfaceMT,              IntPtr)
DEFINE_FIELD(TRANSPARENT_PROXY,     STUB,                   _stub,                      IntPtr)
DEFINE_FIELD(TRANSPARENT_PROXY,     STUB_DATA,              _stubData,                  Obj)

DEFINE_CLASS(TYPE,                  System,                 Type)

DEFINE_CLASS(TYPE_DELEGATOR,        Reflection,             TypeDelegator)

DEFINE_CLASS(TYPE_HANDLE,           System,                 RuntimeTypeHandle)

DEFINE_CLASS(TYPED_REFERENCE,       System,                 TypedReference)

DEFINE_CLASS(UINT16,                System,                 UInt16)

DEFINE_CLASS(UINT32,                System,                 UInt32)

DEFINE_CLASS(UINT64,                System,                 UInt64)

DEFINE_CLASS(UNKNOWN_WRAPPER,       Interop,                UnknownWrapper)

DEFINE_CLASS(UNLOAD_WORKER,         System,                 UnloadWorker)
DEFINE_CLASS(UNLOAD_THREAD_WORKER,  System,                 UnloadThreadWorker)

DEFINE_CLASS(VARIANT,               System,                 Variant)
DEFINE_METHOD(VARIANT,              CONVERT_OBJECT_TO_VARIANT,MarshalHelperConvertObjectToVariant,SM_Obj_RefVariant_RetVoid)
DEFINE_METHOD(VARIANT,              CAST_VARIANT,           MarshalHelperCastVariant,   SM_Obj_Int_RefVariant_RetVoid)
DEFINE_METHOD(VARIANT,              CONVERT_VARIANT_TO_OBJECT,MarshalHelperConvertVariantToObject,SM_RefVariant_RetObject)

DEFINE_CLASS(VALUE_TYPE,            System,                 ValueType)

DEFINE_CLASS(VERSION,               System,                 Version)
DEFINE_METHOD(VERSION,              CTOR,                   .ctor,                      IM_Int_Int_Int_Int_RetVoid)
DEFINE_METHOD(VERSION,              CTOR2,                  .ctor,                      IM_Int_Int_RetVoid)
DEFINE_FIELD_U(VERSION,             BUILD,                  _Build,                     Int,                            VersionBaseObject,    m_Build)

DEFINE_CLASS(VOID,                  System,                 Void)

DEFINE_CLASS(X509_CERTIFICATE,      X509,                   X509Certificate)
DEFINE_METHOD(X509_CERTIFICATE,     CTOR,                   .ctor,                      IM_ArrByte_RetVoid)
DEFINE_FIELD(X509_CERTIFICATE,      DATA,                   rawCertData,                ArrByte)
DEFINE_FIELD(X509_CERTIFICATE,      NAME,                   name,                       Str)
DEFINE_FIELD(X509_CERTIFICATE,      CA_NAME,                caName,                     Str)
DEFINE_FIELD(X509_CERTIFICATE,      SERIAL_NUMBER,          serialNumber,               ArrByte)
DEFINE_FIELD(X509_CERTIFICATE,      EFFECTIVE_DATE,         effectiveDate,              Long)
DEFINE_FIELD(X509_CERTIFICATE,      EXPIRATION_DATE,        expirationDate,             Long)
DEFINE_FIELD(X509_CERTIFICATE,      KEY_ALGORITHM,          keyAlgorithm,               Str)
DEFINE_FIELD(X509_CERTIFICATE,      KEY_ALGORITHM_PARAMS,   keyAlgorithmParameters,     ArrByte)
DEFINE_FIELD(X509_CERTIFICATE,      PUBLIC_KEY,             publicKey,                  ArrByte)
DEFINE_FIELD(X509_CERTIFICATE,      CERT_HASH,              certHash,                   ArrByte)


DEFINE_CLASS(GC,                    System,                 GC)
DEFINE_METHOD(GC,                   FIRE_CACHE_EVENT,       FireCacheEvent,             SM_RetVoid)

DEFINE_CLASS(INTPTR,                System,                 IntPtr)
DEFINE_FIELD(INTPTR,                VALUE,                  m_value,                    PtrVoid)

DEFINE_CLASS(UINTPTR,                System,                 UIntPtr)
DEFINE_FIELD(UINTPTR,                VALUE,                  m_value,                   PtrVoid)


#undef DEFINE_CLASS
#undef DEFINE_METHOD
#undef DEFINE_FIELD
#undef DEFINE_CLASS_U
#undef DEFINE_FIELD_U
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ndirect.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// NDIRECT.CPP -
//
// N/Direct support.


#include "common.h"

#include "vars.hpp"
#include "ml.h"
#include "stublink.h"
#include "threads.h"
#include "excep.h"
#include "mlgen.h"
#include "ndirect.h"
#include "cgensys.h"
#include "method.hpp"
#include "siginfo.hpp"
#include "mlcache.h"
#include "security.h"
#include "COMDelegate.h"
#include "compluswrapper.h"
#include "compluscall.h"
#include "ReflectWrap.h"
#include "ceeload.h"
#include "utsem.h"
#include "mlinfo.h"
#include "eeconfig.h"
#include "CorMap.hpp"
#include "eeconfig.h"
#include "cgensys.h"
#include "COMUtilNative.h"
#include "ReflectUtil.h"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED


#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"
#endif // CUSTOMER_CHECKED_BUILD

VOID NDirect_Prelink(MethodDesc *pMeth);

ArgBasedStubCache    *NDirect::m_pNDirectGenericStubCache = NULL;
ArgBasedStubCache    *NDirect::m_pNDirectSlimStubCache    = NULL;


#ifdef _SH3_
INT32 __stdcall PInvokeCalliWorker(Thread *pThread, PInvokeCalliFrame* pFrame);
#else
INT64 __stdcall PInvokeCalliWorker(Thread *pThread,
                                   PInvokeCalliFrame* pFrame);
#endif

// support for Pinvoke Calli instruction
BOOL SetupGenericPInvokeCalliStub();
LPVOID GetEntryPointForPInvokeCalliStub();

BOOL NDirectOnUnicodeSystem()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    //@nice: also need to check registry key and cache the result and merge the
    //       resulting code with GetTLSAccessMode in tls.cpp.
    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (! WszGetVersionEx(&osverinfo))
        return FALSE;

    if(osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        return TRUE;
    else
        return FALSE;
}




NDirectMLStubCache *NDirect::m_pNDirectMLStubCache = NULL;


class NDirectMLStubCache : public MLStubCache
{
    public:
        NDirectMLStubCache(LoaderHeap *heap = 0) : MLStubCache(heap) {}

    private:
        //---------------------------------------------------------
        // Compile a native (ASM) version of the ML stub.
        //
        // This method should compile into the provided stublinker (but
        // not call the Link method.)
        //
        // It should return the chosen compilation mode.
        //
        // If the method fails for some reason, it should return
        // INTERPRETED so that the EE can fall back on the already
        // created ML code.
        //---------------------------------------------------------
        virtual MLStubCompilationMode CompileMLStub(const BYTE *pRawMLStub,
                                                    StubLinker *pstublinker,
                                                    void *callerContext);

        //---------------------------------------------------------
        // Tells the MLStubCache the length of an ML stub.
        //---------------------------------------------------------
        virtual UINT Length(const BYTE *pRawMLStub)
        {
            CANNOTTHROWCOMPLUSEXCEPTION();
            MLHeader *pmlstub = (MLHeader *)pRawMLStub;
            return sizeof(MLHeader) + MLStreamLength(pmlstub->GetMLCode());
        }


};


//---------------------------------------------------------
// Compile a native (ASM) version of the ML stub.
//
// This method should compile into the provided stublinker (but
// not call the Link method.)
//
// It should return the chosen compilation mode.
//
// If the method fails for some reason, it should return
// INTERPRETED so that the EE can fall back on the already
// created ML code.
//---------------------------------------------------------
MLStubCache::MLStubCompilationMode NDirectMLStubCache::CompileMLStub(const BYTE *pRawMLStub,
                     StubLinker *pstublinker, void *callerContext)
{
    MLStubCompilationMode ret = INTERPRETED;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(callerContext == 0);


    COMPLUS_TRY {
        CPUSTUBLINKER *psl = (CPUSTUBLINKER *)pstublinker;
        const MLHeader *pheader = (const MLHeader *)pRawMLStub;

#ifdef _DEBUG
        if (LoggingEnabled() && (g_pConfig->GetConfigDWORD(L"LogFacility",0) & LF_IJW)) {
            __leave;
            }
#endif

        if (!(MonDebugHacksOn() || TueDebugHacksOn())) {
            if (NDirect::CreateStandaloneNDirectStubSys(pheader, (CPUSTUBLINKER*)psl, FALSE)) {
                ret = STANDALONE;
                __leave;
            }
        }


    } COMPLUS_CATCH {
        ret = INTERPRETED;
    } COMPLUS_END_CATCH

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

#ifdef CUSTOMER_CHECKED_BUILD
    CustomerDebugHelper* pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_StackImbalance))
    {
        // Force a GenericNDirectStub if we are checking for stack imbalance
        ret = INTERPRETED;
    }
#endif // CUSTOMER_CHECKED_BUILD

    return ret;
}


/*static*/
LPVOID NDirect::NDirectGetEntryPoint(NDirectMethodDesc *pMD, HINSTANCE hMod, UINT16 numParamBytes)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    // GetProcAddress cannot be called while preemptive GC is disabled.
    // It requires the OS to take the loader lock.
    _ASSERTE(!(GetThread()->PreemptiveGCDisabled()));


    // Handle ordinals.
    if (pMD->ndirect.m_szEntrypointName[0] == '#') {
        long ordinal = atol(pMD->ndirect.m_szEntrypointName+1);
        return GetProcAddress(hMod, (LPCSTR)((UINT16)ordinal));
    }

    LPVOID pFunc, pFuncW;

    // Just look for the unmanagled name.  If nlType != nltAnsi, we are going
    // to need to check for the 'W' API because it takes precedence over the
    // unmangled one (on NT some APIs have unmangled ANSI exports).
    if (((pFunc = GetProcAddress(hMod, pMD->ndirect.m_szEntrypointName)) != NULL && pMD->GetNativeLinkType() == nltAnsi) ||
        (pMD->GetNativeLinkFlags() & nlfNoMangle))
        return pFunc;

    // Allocate space for a copy of the entry point name.
    int dstbufsize = (int)(sizeof(char) * (strlen(pMD->ndirect.m_szEntrypointName) + 1 + 20)); // +1 for the null terminator
                                                                         // +20 for various decorations
    LPSTR szAnsiEntrypointName = (LPSTR)_alloca(dstbufsize);

    // Make room for the preceeding '_' we might try adding.
    szAnsiEntrypointName++;

    // Copy the name so we can mangle it.
    strcpy(szAnsiEntrypointName,pMD->ndirect.m_szEntrypointName);
    DWORD nbytes = (DWORD)(strlen(pMD->ndirect.m_szEntrypointName) + 1);
    szAnsiEntrypointName[nbytes] = '\0'; // Add an extra '\0'.

    // If the program wants the ANSI api or if Unicode APIs are unavailable.
    if (pMD->GetNativeLinkType() == nltAnsi) {
        szAnsiEntrypointName[nbytes-1] = 'A';
        pFunc = GetProcAddress(hMod, szAnsiEntrypointName);
    }
    else {
        szAnsiEntrypointName[nbytes-1] = 'W';
        pFuncW = GetProcAddress(hMod, szAnsiEntrypointName);

        // This overrides the unmangled API. See the comment above.
        if (pFuncW != NULL)
            pFunc = pFuncW;
    }

    if (!pFunc) {
        if (hMod == WszGetModuleHandle(L"KERNEL32")) {
            szAnsiEntrypointName[nbytes-1] = '\0';
            if (0==strcmp(szAnsiEntrypointName, "MoveMemory") ||
                0==strcmp(szAnsiEntrypointName, "CopyMemory")) {
                pFunc = GetProcAddress(hMod, "RtlMoveMemory");
            } else if (0==strcmp(szAnsiEntrypointName, "FillMemory")) {
                pFunc = GetProcAddress(hMod, "RtlFillMemory");
            } else if (0==strcmp(szAnsiEntrypointName, "ZeroMemory")) {
                pFunc = GetProcAddress(hMod, "RtlZeroMemory");
            }
        }
        /* try mangled names only for __stdcalls */

        if (!pFunc && (numParamBytes != 0xffff)) {
            szAnsiEntrypointName[-1] = '_';
            sprintf(szAnsiEntrypointName + nbytes - 1, "@%ld", (ULONG)numParamBytes);
            pFunc = GetProcAddress(hMod, szAnsiEntrypointName - 1);
        }
    }

    return pFunc;

}

static BOOL AbsolutePath(LPCWSTR wszLibName, DWORD* pdwSize)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    // check for UNC or a drive
    WCHAR* ptr = (WCHAR*) wszLibName;
    WCHAR* start = ptr;
    *pdwSize = 0;
    start = ptr;

    // Check for UNC path 
    while(*ptr) {
        if(*ptr != L'\\')
            break;
        ptr++;
    }

    if((ptr - wszLibName) == 2)
        return TRUE;
    else {
        // Check to see if there is a colon indicating a drive or protocal
        for(ptr = start; *ptr; ptr++) {
            if(*ptr == L':')
                break;
        }
        if(*ptr != NULL)
            return TRUE;
    }
    
    // We did not find a 
    *pdwSize = (DWORD)(ptr - wszLibName);
    return FALSE;
}

//---------------------------------------------------------
// Loads the DLL and finds the procaddress for an N/Direct call.
//---------------------------------------------------------
/* static */
VOID NDirect::NDirectLink(NDirectMethodDesc *pMD, UINT16 numParamBytes)
{
    THROWSCOMPLUSEXCEPTION();

    Thread *pThread = GetThread();
    pThread->EnablePreemptiveGC();
    BOOL fSuccess = FALSE;
    HINSTANCE hmod = NULL;
    AppDomain* pDomain = pThread->GetDomain();
    
    #define MAKE_TRANSLATIONFAILED COMPlusThrow(kDllNotFoundException, IDS_EE_NDIRECT_LOADLIB, L"");
    MAKE_WIDEPTR_FROMUTF8(wszLibName, pMD->ndirect.m_szLibName);
    #undef MAKE_TRANSLATIONFAILED

    hmod = pDomain->FindUnmanagedImageInCache(wszLibName);
    if(hmod == NULL) {

        // A big mistake if we load mscorwks or mscorsvr by name.  This
        // will cause two versions of the runtime to be loaded into the
        // process.  The runtime will die.
        //
        _ASSERTE(_wcsicmp(wszLibName, L"mscorwks") != 0 && "Bad NDirect call");
        _ASSERTE(_wcsicmp(wszLibName, L"mscorsvr") != 0 && "Bad NDirect call");

        DWORD dwSize = 0;

        if(AbsolutePath(wszLibName, &dwSize)) {
            hmod = WszLoadLibraryEx(wszLibName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        }
        else { 
            WCHAR buffer[_MAX_PATH];
            DWORD dwLength = _MAX_PATH;
            LPWSTR pCodeBase;
            Assembly* pAssembly = pMD->GetClass()->GetAssembly();
            
            if(SUCCEEDED(pAssembly->GetCodeBase(&pCodeBase, &dwLength)) &&
               dwSize + dwLength < _MAX_PATH) 
            {
                WCHAR* ptr;
                // Strip off the protocol
                for(ptr = pCodeBase; *ptr && *ptr != L':'; ptr++);

                // If we have a code base then prepend it to the library name
                if(*ptr) {
                    WCHAR* pBuffer = buffer;

                    // After finding the colon move forward until no more forward slashes
                    for(ptr++; *ptr && *ptr == L'/'; ptr++);
                    if(*ptr) {
                        // Calculate the number of charachters we are interested in
                        dwLength -= (DWORD)(ptr - pCodeBase);
                        if(dwLength > 0) {
                            // Back up to the last slash (forward or backwards)
                            WCHAR* tail;
                            for(tail = ptr+(dwLength-1); tail > ptr && *tail != L'/' && *tail != L'\\'; tail--);
                            if(tail > ptr) {
                                for(;ptr <= tail; ptr++, pBuffer++) {
                                    if(*ptr == L'/') 
                                        *pBuffer = L'\\';
                                    else
                                        *pBuffer = *ptr;
                                }
                            }
                        }
                    }
                    wcsncpy(pBuffer, wszLibName, dwSize+1);
                    hmod = WszLoadLibraryEx(buffer, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
                }
            }
        }

        // Do we really need to do this. This call searches the application directory 
        // instead of the location for the library.
        if(hmod == NULL) 
            hmod = WszLoadLibrary(wszLibName);
            
#if defined(PLATFORM_WIN32) && !defined(_IA64_)
        // Can be removed once Com+ files work with LoadLibrary() on Win9X
        if ((!hmod) && (RunningOnWin95())) {
            HCORMODULE pbMapAddress;
            if (SUCCEEDED(CorMap::OpenFile(wszLibName, CorLoadImageMap, &pbMapAddress)))
                hmod = (HINSTANCE) pbMapAddress;
        }
#endif // defined(PLATFORM_WIN32) && !defined(_IA64_)

        // This may be an assembly name
        if (!hmod) {
            // Format is "fileName, assemblyDisplayName"
            #define MAKE_TRANSLATIONFAILED COMPlusThrow(kDllNotFoundException, IDS_EE_NDIRECT_LOADLIB, wszLibName);
            MAKE_UTF8PTR_FROMWIDE(szLibName, wszLibName);
            #undef MAKE_TRANSLATIONFAILED
            char *szComma = strchr(szLibName, ',');
            if (szComma) {
                *szComma = '\0';
                while (COMCharacter::nativeIsWhiteSpace(*(++szComma)));

                AssemblySpec spec;
                if (SUCCEEDED(spec.Init(szComma))) {
                    Assembly *pAssembly;
                    if (SUCCEEDED(spec.LoadAssembly(&pAssembly, NULL /*pThrowable*/, NULL))) {

                        HashDatum datum;
                        if (pAssembly->m_pAllowedFiles->GetValue(szLibName, &datum)) {
                            const BYTE* pHash;
                            DWORD dwFlags = 0;
                            ULONG dwHashLength = 0;
                            pAssembly->GetManifestImport()->GetFileProps((mdFile)(size_t)datum, // @TODO WIN64 - pointer truncation
                                                                         NULL, //&szModuleName,
                                                                         (const void**) &pHash,
                                                                         &dwHashLength,
                                                                         &dwFlags);
                            
                            WCHAR pPath[MAX_PATH];
                            Module *pModule;
                            if (SUCCEEDED(pAssembly->LoadInternalModule(szLibName,
                                                                        NULL, // mdFile
                                                                        pAssembly->m_ulHashAlgId,
                                                                        pHash,
                                                                        dwHashLength,
                                                                        dwFlags,
                                                                        pPath,
                                                                        MAX_PATH,
                                                                        &pModule,
                                                                        NULL /*pThrowable*/)))
                                hmod = WszLoadLibraryEx(pPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
                        }
                    }
                }
            }
        }
    
        // After all this, if we have a handle add it to the cache.
        if(hmod) {
            HRESULT hrResult = pDomain->AddUnmanagedImageToCache(wszLibName, hmod);
            if(hrResult == S_FALSE) 
                FreeLibrary(hmod);
        }
    }

    if (hmod)
    {
        LPVOID pvTarget = NDirectGetEntryPoint(pMD, hmod, numParamBytes);
        if (pvTarget) {
            pMD->SetNDirectTarget(pvTarget);
            fSuccess = TRUE;
        }
    }

    pThread->DisablePreemptiveGC();


    if (!fSuccess) {
        if (!hmod) {
            COMPlusThrow(kDllNotFoundException, IDS_EE_NDIRECT_LOADLIB, wszLibName);
        }

        WCHAR wszEPName[50];
        if(WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, (LPCSTR)pMD->ndirect.m_szEntrypointName, -1, wszEPName, sizeof(wszEPName)/sizeof(WCHAR)) == 0)
        {
            wszEPName[0] = L'?';
            wszEPName[1] = L'\0';
        }

        COMPlusThrow(kEntryPointNotFoundException, IDS_EE_NDIRECT_GETPROCADDRESS, wszLibName, wszEPName);
    }


}





//---------------------------------------------------------
// One-time init
//---------------------------------------------------------
/*static*/ BOOL NDirect::Init()
{

    if ((m_pNDirectMLStubCache = new NDirectMLStubCache(SystemDomain::System()->GetStubHeap())) == NULL) {
        return FALSE;
    }
    if ((m_pNDirectGenericStubCache = new ArgBasedStubCache()) == NULL) {
        return FALSE;
    }
    if ((m_pNDirectSlimStubCache = new ArgBasedStubCache()) == NULL) {
        return FALSE;
    }
    // Compute stack size of generic worker
    NDirectGenericStubWorker(NULL, NULL);

    BOOL fSuccess = SetupGenericPInvokeCalliStub();
    if (fSuccess)
    {
        PInvokeCalliWorker(NULL, NULL);
    }
    return fSuccess;
}

//---------------------------------------------------------
// One-time cleanup
//---------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
/*static*/ VOID NDirect::Terminate()
{
    delete m_pNDirectMLStubCache;
    delete m_pNDirectGenericStubCache;
    delete m_pNDirectSlimStubCache;
}
#endif /* SHOULD_WE_CLEANUP */

//---------------------------------------------------------
// Computes an ML stub for the ndirect method, and fills
// in the corresponding fields of the method desc. Note that
// this does not set the m_pMLHeader field of the method desc,
// since the stub may end up being replaced by a compiled one
//---------------------------------------------------------
/* static */
Stub* NDirect::ComputeNDirectMLStub(NDirectMethodDesc *pMD) 
{
    THROWSCOMPLUSEXCEPTION();
    
    if (pMD->IsSynchronized()) {
        COMPlusThrow(kTypeLoadException, IDS_EE_NOSYNCHRONIZED);
    }

    BYTE ndirectflags = 0;
    BOOL fVarArg = pMD->MethodDesc::IsVarArg();
    NDirectMethodDesc::SetVarArgsBits(&ndirectflags, fVarArg);


    if (fVarArg && pMD->ndirect.m_szEntrypointName != NULL)
        return NULL;

    CorNativeLinkType type;
    CorNativeLinkFlags flags;
    LPCUTF8 szLibName = NULL;
    LPCUTF8 szEntrypointName = NULL;
    Stub *pMLStub = NULL;
    BOOL BestFit;
    BOOL ThrowOnUnmappableChar;
    
    CorPinvokeMap unmanagedCallConv;

    CalculatePinvokeMapInfo(pMD, &type, &flags, &unmanagedCallConv, &szLibName, &szEntrypointName, &BestFit, &ThrowOnUnmappableChar);

    NDirectMethodDesc::SetNativeLinkTypeBits(&ndirectflags, type);
    NDirectMethodDesc::SetNativeLinkFlagsBits(&ndirectflags, flags);
    NDirectMethodDesc::SetStdCallBits(&ndirectflags, unmanagedCallConv == pmCallConvStdcall);

    // Call this exactly ONCE per thread. Do not publish incomplete prestub flags
    // or you will introduce a race condition.
    pMD->PublishPrestubFlags(ndirectflags);


    pMD->ndirect.m_szLibName = szLibName;
    pMD->ndirect.m_szEntrypointName = szEntrypointName;

    if (pMD->IsVarArgs())
        return NULL;

    OBJECTREF pThrowable;

    PCCOR_SIGNATURE pMetaSig;
    DWORD       cbMetaSig;
    pMD->GetSig(&pMetaSig, &cbMetaSig);

    pMLStub = CreateNDirectMLStub(pMetaSig, pMD->GetModule(), pMD->GetMemberDef(),
                                  type, flags, unmanagedCallConv,
                                  &pThrowable, FALSE, BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                                  ,pMD
#endif
#ifdef _DEBUG
                                  ,
                                  pMD->m_pszDebugMethodName,
                                  pMD->m_pszDebugClassName,
                                  NULL
#endif
                                  );
    if (!pMLStub)
    {
        COMPlusThrow(pThrowable);
    }

    MLHeader *pMLHeader = (MLHeader*) pMLStub->GetEntryPoint();

    pMD->ndirect.m_cbDstBufSize = pMLHeader->m_cbDstBuffer;

    return pMLStub;
}

//---------------------------------------------------------
// Either creates or retrieves from the cache, a stub to
// invoke NDirect methods. Each call refcounts the returned stub.
// This routines throws a COM+ exception rather than returning
// NULL.
//---------------------------------------------------------
/* static */
Stub* NDirect::GetNDirectMethodStub(StubLinker *pstublinker, NDirectMethodDesc *pMD)
{
    THROWSCOMPLUSEXCEPTION();

    LPCUTF8 szLibName = NULL;
    LPCUTF8 szEntrypointName = NULL;
    MLHeader *pOldMLHeader = NULL;
    MLHeader *pMLHeader = NULL;
    Stub  *pTempMLStub = NULL;
    Stub  *pReturnStub = NULL;

    EE_TRY_FOR_FINALLY {

        // the ML header will already be set if we were prejitted
        pOldMLHeader = pMD->GetMLHeader();
        pMLHeader = pOldMLHeader;

        if (pMLHeader == NULL) {
            pTempMLStub = ComputeNDirectMLStub(pMD);
            if (pTempMLStub != NULL)
                pMLHeader = (MLHeader *) pTempMLStub->GetEntryPoint();
        }
        else if (pMLHeader->m_Flags & MLHF_NEEDS_RESTORING) {
            pTempMLStub = RestoreMLStub(pMLHeader, pMD->GetModule());
            pMLHeader = (MLHeader *) pTempMLStub->GetEntryPoint();
        }

        if (pMD->GetSubClassification() == NDirectMethodDesc::kLateBound)
        {
            NDirectLink(pMD, pMD->IsStdCall() ? pMLHeader->m_cbDstBuffer : 0xffff);
        }

        MLStubCache::MLStubCompilationMode mode;

        Stub *pCanonicalStub;
        if (pMLHeader == NULL) {
            pCanonicalStub = NULL;
            mode = MLStubCache::INTERPRETED;
        } else {
            pCanonicalStub = NDirect::m_pNDirectMLStubCache->Canonicalize((const BYTE *) pMLHeader,
                                                                          &mode);
            if (!pCanonicalStub) {
                COMPlusThrowOM();
            }
        }

#ifdef CUSTOMER_CHECKED_BUILD
        CustomerDebugHelper* pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
#endif

        switch (mode) {

            case MLStubCache::INTERPRETED:
                if (pCanonicalStub != NULL) // it will be null for varags case
                {
                    if (!pMD->InterlockedReplaceMLHeader((MLHeader*)pCanonicalStub->GetEntryPoint(),
                                                         pOldMLHeader))
                        pCanonicalStub->DecRef();
                }

                if (pMLHeader == NULL || MonDebugHacksOn() || WedDebugHacksOn()
#ifdef _DEBUG
                    || (LoggingEnabled() && (LF_IJW & g_pConfig->GetConfigDWORD(L"LogFacility", 0)))
#endif

                    ) {
                    pReturnStub = NULL;
                } else {

#ifdef CUSTOMER_CHECKED_BUILD
                    if (!pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_StackImbalance)) {
                        pReturnStub = CreateSlimNDirectStub(pstublinker, pMD,
                                                            pMLHeader->m_cbStackPop);
                    }
                    else {
                        // Force a GenericNDirectStub if we are checking for stack imbalance
                        pReturnStub = NULL;
                    }
#else
                        pReturnStub = CreateSlimNDirectStub(pstublinker, pMD,
                                                            pMLHeader->m_cbStackPop);
#endif // CUSTOMER_CHECKED_BUILD

                }
                if (!pReturnStub) {
                    // Note that we don't want to call CbStackBytes unless
                    // strictly necessary since this will touch metadata.  
                    // Right now it will only happen for the varags case,
                    // which probably needs other tuning anyway.
                    pReturnStub = CreateGenericNDirectStub(pstublinker,
                                                           pMLHeader != NULL ? 
                                                           pMLHeader->m_cbStackPop :
                                                           pMD->CbStackPop());
                }
                break;

            case MLStubCache::SHAREDPROLOG:
                if (!pMD->InterlockedReplaceMLHeader((MLHeader*)pCanonicalStub->GetEntryPoint(),
                                                     pOldMLHeader))
                    pCanonicalStub->DecRef();
                _ASSERTE(!"NYI");
                pReturnStub = NULL;
                break;

            case MLStubCache::STANDALONE:
                pReturnStub = pCanonicalStub;
                break;

            default:
                _ASSERTE(0);
        }

    } EE_FINALLY {
        if (pTempMLStub) {
            pTempMLStub->DecRef();
        }
    } EE_END_FINALLY;

    return pReturnStub;

}


//---------------------------------------------------------
// Creates or retrives from the cache, the generic NDirect stub.
//---------------------------------------------------------
/* static */
Stub* NDirect::CreateGenericNDirectStub(StubLinker *pstublinker, UINT numStackBytes)
{
    THROWSCOMPLUSEXCEPTION();

    Stub *pStub = m_pNDirectGenericStubCache->GetStub(numStackBytes);
    if (pStub) {
        return pStub;
    } else {
        CPUSTUBLINKER *psl = (CPUSTUBLINKER*)pstublinker;

        psl->EmitMethodStubProlog(NDirectMethodFrameGeneric::GetMethodFrameVPtr());

        CreateGenericNDirectStubSys(psl);

        psl->EmitMethodStubEpilog(numStackBytes, kNoTripStubStyle);

        Stub *pCandidate = psl->Link(SystemDomain::System()->GetStubHeap());
        Stub *pWinner = m_pNDirectGenericStubCache->AttemptToSetStub(numStackBytes,pCandidate);
        pCandidate->DecRef();
        if (!pWinner) {
            COMPlusThrowOM();
        }
        return pWinner;
    }

}


//---------------------------------------------------------
// Call at strategic times to discard unused stubs.
//---------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
/*static*/ VOID  NDirect::FreeUnusedStubs()
{
    m_pNDirectMLStubCache->FreeUnusedStubs();
}
#endif /* SHOULD_WE_CLEANUP */


//---------------------------------------------------------
// Helper function to checkpoint the thread allocator for cleanup.
//---------------------------------------------------------
VOID __stdcall DoCheckPointForCleanup(NDirectMethodFrameEx *pFrame, Thread *pThread)
{
        THROWSCOMPLUSEXCEPTION();

        CleanupWorkList *pCleanup = pFrame->GetCleanupWorkList();
        if (pCleanup) {
            // Checkpoint the current thread's fast allocator (used for temporary
            // buffers over the call) and schedule a collapse back to the checkpoint in
            // the cleanup list. Note that if we need the allocator, it is
            // guaranteed that a cleanup list has been allocated.
            void *pCheckpoint = pThread->m_MarshalAlloc.GetCheckpoint();
            pCleanup->ScheduleFastFree(pCheckpoint);
            pCleanup->IsVisibleToGc();
        }
}



//---------------------------------------------------------
// Performs an N/Direct call. This is a generic version
// that can handly any N/Direct call but is not as fast
// as more specialized versions.
//---------------------------------------------------------

static int g_NDirectGenericWorkerStackSize = 0;
static void *g_NDirectGenericWorkerReturnAddress = NULL;


#ifdef _SH3_
INT32 __stdcall NDirectGenericStubWorker(Thread *pThread, NDirectMethodFrame *pFrame)
#else
INT64 __stdcall NDirectGenericStubWorker(Thread *pThread, NDirectMethodFrame *pFrame)
#endif
{
    if (pThread == NULL) // Special case called during initialization
    {
        // Compute information about the worker function for the debugger to
        // use.  Note that this information could theoretically be
        // computed statically, except that the compiler provides no means to
        // do so.
#ifdef _X86_
        __asm
        {
            lea eax, pFrame + 4
            sub eax, esp
            mov g_NDirectGenericWorkerStackSize, eax

            lea eax, RETURN_FROM_CALL
            mov g_NDirectGenericWorkerReturnAddress, eax

        }
#elif defined(_IA64_)   // !_X86_
    //
    //  @TODO_IA64: implement this
    //
    g_NDirectGenericWorkerStackSize     = 0xBAAD;
    g_NDirectGenericWorkerReturnAddress = (void*)0xBAAD;
#else // !_X86_ && !_IA64_
        _ASSERTE(!"@TODO Alpha - NDirectGenericStubWorker (Ndirect.cpp)");
#endif // _X86_
        return 0;
    }

#if defined(_DEBUG) && defined(_X86_)
    DWORD PreESP;
    DWORD PostESP;
    __asm mov [PreESP], esp
#endif
#ifdef _DEBUG           // Flush object ref tracking.
        Thread::ObjectRefFlush(pThread);
#endif

    INT64 returnValue=0;
    THROWSCOMPLUSEXCEPTION();
    NDirectMethodDesc *pMD = (NDirectMethodDesc*)(pFrame->GetFunction());
    LPVOID target          = pMD->GetNDirectTarget();
    MLHeader *pheader;

    LOG((LF_STUBS, LL_INFO1000, "Calling NDirectGenericStubWorker %s::%s \n", pMD->m_pszDebugClassName, pMD->m_pszDebugMethodName));

    if (pMD->IsVarArgs()) {

        VASigCookie *pVASigCookie = pFrame->GetVASigCookie();

        Stub *pTempMLStub;

        if (pVASigCookie->pNDirectMLStub != NULL) {
            pTempMLStub = pVASigCookie->pNDirectMLStub;
        } else {
            OBJECTREF pThrowable;
            CorNativeLinkType type;
            CorNativeLinkFlags flags;
            LPCUTF8 szLibName = NULL;
            LPCUTF8 szEntrypointName = NULL;
            CorPinvokeMap unmanagedCallConv;
            BOOL BestFit;
            BOOL ThrowOnUnmappableChar;

            CalculatePinvokeMapInfo(pMD, &type, &flags, &unmanagedCallConv, &szLibName, &szEntrypointName, &BestFit, &ThrowOnUnmappableChar);

            // We are screwed here because the VASigCookie doesn't hash on or store the NATIVE_TYPE metadata.
            // Right now, we just pass the bogus value "mdMethodDefNil" which will cause CreateNDirectMLStub to use
            // the defaults.
            pTempMLStub = CreateNDirectMLStub(pVASigCookie->mdVASig, pVASigCookie->pModule, mdMethodDefNil, type, flags, unmanagedCallConv, &pThrowable, FALSE,
                                                BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                                              ,pMD
#endif
                                              );
            if (!pTempMLStub)
            {
                COMPlusThrow(pThrowable);
            }

            if (NULL != VipInterlockedCompareExchange( (void*volatile*)&(pVASigCookie->pNDirectMLStub),
                                                       pTempMLStub,
                                                       NULL )) {
                pTempMLStub->DecRef();
                pTempMLStub = pVASigCookie->pNDirectMLStub;
            }
        }
        pheader = (MLHeader*)(pTempMLStub->GetEntryPoint());

    } else {
        pheader = pMD->GetMLHeader();
    }

        // Allocate enough memory to store both the destination buffer and
        // the locals.
        UINT   cbAlloc         = pheader->m_cbDstBuffer + pheader->m_cbLocals;
        BYTE *pAlloc           = (BYTE*)_alloca(cbAlloc);
    #ifdef _DEBUG
        FillMemory(pAlloc, cbAlloc, 0xcc);
    #endif

        BYTE   *pdst    = pAlloc;
        BYTE   *plocals = pdst + pheader->m_cbDstBuffer;
        pdst += pheader->m_cbDstBuffer;

        VOID   *psrc          = (VOID*)pFrame;

        CleanupWorkList *pCleanup = pFrame->GetCleanupWorkList();

        if (pCleanup) {

            // Checkpoint the current thread's fast allocator (used for temporary
            // buffers over the call) and schedule a collapse back to the checkpoint in
            // the cleanup list. Note that if we need the allocator, it is
            // guaranteed that a cleanup list has been allocated.
            void *pCheckpoint = pThread->m_MarshalAlloc.GetCheckpoint();
            pCleanup->ScheduleFastFree(pCheckpoint);
            pCleanup->IsVisibleToGc();
        }

        // Call the ML interpreter to translate the arguments. Assuming
        // it returns, we get back a pointer to the succeeding code stream
        // which we will save away for post-call execution.
        const MLCode *pMLCode = RunML(pheader->GetMLCode(),
                                      psrc,
                                      pdst,
                                      (UINT8*const) plocals, // CHANGE, VC6.0
                                      pCleanup);

        LOG((LF_IJW, LL_INFO1000, "P/Invoke call (\"%s.%s%s\")\n", pMD->m_pszDebugClassName, pMD->m_pszDebugMethodName, pMD->m_pszDebugMethodSignature));

#ifdef CUSTOMER_CHECKED_BUILD
    CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_ObjNotKeptAlive))
    {
        g_pGCHeap->GarbageCollect();
        g_pGCHeap->FinalizerThreadWait(1000);
    }
#endif // CUSTOMER_CHECKED_BUILD

        // Call the target.
        pThread->EnablePreemptiveGC();

#ifdef PROFILING_SUPPORTED
        // Notify the profiler of call out of the runtime
        if (CORProfilerTrackTransitions())
        {
            g_profControlBlock.pProfInterface->
                ManagedToUnmanagedTransition((FunctionID) pMD,
                                                   COR_PRF_TRANSITION_CALL);
        }
#endif // PROFILING_SUPPORTED

#if defined(_DEBUG) && defined(_X86_)
        UINT    mismatch;
        __asm {
            mov     eax,[pAlloc]
            sub     eax,esp
            mov     [mismatch],eax

        }
        if (mismatch != 0) {
            // Slimy as this trick is, it's required to implement copy ctor calling correctly -

            _ASSERTE(!"Compiler assumption broken: _alloca'd buffer not on bottom of stack.");
        }
#endif // _DEBUG && _X86_
        BOOL    fThisCall = pheader->m_Flags & MLHF_THISCALL;
        BOOL    fHasHiddenArg = pheader->m_Flags & MLHF_THISCALLHIDDENARG;
        LPVOID  pvFn      = pMD->GetNDirectTarget();
        INT64   nativeReturnValue;


#if _DEBUG
        //
        // Call through debugger routines to double check their
        // implementation
        //
        pvFn = (void*) Frame::CheckExitFrameDebuggerCalls;
#endif


#ifdef _X86_

#ifdef CUSTOMER_CHECKED_BUILD
    DWORD cdh_EspAfterPushedArgs;
#endif
    
    __asm {
            cmp     dword ptr fThisCall, 0
            jz      doit

            cmp     dword ptr fHasHiddenArg, 0
            jz      regularthiscall

            pop     eax
            pop     ecx
            push    eax
            jmp     doit

    regularthiscall:
            pop     ecx


    doit:

#ifdef CUSTOMER_CHECKED_BUILD
            mov     [cdh_EspAfterPushedArgs], esp
#endif
            call    dword ptr [pvFn]
        }
#else
        _ASSERTE(!"NYI for non-x86");
#endif


#ifdef _X86_

RETURN_FROM_CALL:

        __asm {
            mov     dword ptr [nativeReturnValue], eax
            mov     dword ptr [nativeReturnValue + 4], edx
        }
#else
        _ASSERTE(!"NYI for non-x86");
#endif // _X86_


#if defined(CUSTOMER_CHECKED_BUILD) && defined(_X86_)

    DWORD cdh_EspBeforePushedArgs;
    DWORD cdh_PostEsp;

    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_StackImbalance))
    {
        __asm mov [cdh_PostEsp], esp

        // Get expected calling convention

        CorNativeLinkType   type;
        CorNativeLinkFlags  flags;
        CorPinvokeMap       unmanagedCallConv;
        LPCUTF8             szLibName = NULL;
        LPCUTF8             szEntrypointName = NULL;
        BOOL BestFit;
        BOOL ThrowOnUnmappableChar;

        CalculatePinvokeMapInfo(pMD, &type, &flags, &unmanagedCallConv, &szLibName, &szEntrypointName, &BestFit, &ThrowOnUnmappableChar);

        BOOL bStackImbalance = false;

        switch( unmanagedCallConv )
        {

            // Caller cleans stack
            case pmCallConvCdecl:

                if (cdh_PostEsp != cdh_EspAfterPushedArgs)
                    bStackImbalance = true;
                break;

            // Callee cleans stack
            case pmCallConvThiscall:
                cdh_EspBeforePushedArgs = cdh_EspAfterPushedArgs + pheader->m_cbDstBuffer - sizeof(void*);
                if (cdh_PostEsp != cdh_EspBeforePushedArgs)
                    bStackImbalance = true;
                break;

            // Callee cleans stack
            case pmCallConvWinapi:
            case pmCallConvStdcall:
                cdh_EspBeforePushedArgs = cdh_EspAfterPushedArgs + pheader->m_cbDstBuffer;
                if (cdh_PostEsp != cdh_EspBeforePushedArgs)
                    bStackImbalance = true;
                break;

            // Unsupported calling convention
            case pmCallConvFastcall:
            default:
                _ASSERTE(!"Unsupported calling convention");
                break;
        }

        if (bStackImbalance)
        {
            CQuickArray<WCHAR> strMessage;

            if (szEntrypointName && szLibName)
            {
                CQuickArray<WCHAR> strEntryPointName;
                UINT32 iEntryPointNameLength = (UINT32) strlen(szEntrypointName) + 1;
                strEntryPointName.Alloc(iEntryPointNameLength);

                MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szEntrypointName,
                                    -1, strEntryPointName.Ptr(), iEntryPointNameLength );

                CQuickArray<WCHAR> strLibName;
                UINT32 iLibNameLength = (UINT32) strlen(szLibName) + 1;
                strLibName.Alloc(iLibNameLength);

                MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szLibName,
                                    -1, strLibName.Ptr(), iLibNameLength );

                static WCHAR strMessageFormat[] = {L"Stack imbalance may be caused by incorrect calling convention for method %s (%s)"};

                strMessage.Alloc(lengthof(strMessageFormat) + iEntryPointNameLength + iLibNameLength);
                Wszwsprintf(strMessage.Ptr(), strMessageFormat, strEntryPointName.Ptr(), strLibName.Ptr());
            }
            else if (pMD->GetName())
            {
                CQuickArray<WCHAR> strMethName;
                LPCUTF8 szMethName = pMD->GetName();
                UINT32 iMethNameLength = (UINT32) strlen(szMethName) + 1;
                strMethName.Alloc(iMethNameLength);

                MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szMethName,
                                    -1, strMethName.Ptr(), iMethNameLength );

                static WCHAR strMessageFormat[] = {L"Stack imbalance may be caused by incorrect calling convention for method %s"};

                strMessage.Alloc(lengthof(strMessageFormat) + iMethNameLength);
                Wszwsprintf(strMessage.Ptr(), strMessageFormat, strMethName.Ptr());
            }
            else
            {
                static WCHAR strMessageFormat[] = {L"Stack imbalance may be caused by incorrect calling convention for unknown method"};

                strMessage.Alloc(lengthof(strMessageFormat));
                Wszwsprintf(strMessage.Ptr(), strMessageFormat);
            }

            pCdh->ReportError(strMessage.Ptr(), CustomerCheckedBuildProbe_StackImbalance);
        }
    }

#endif // _X86_ && CUSTOMER_CHECKED_BUILD


#if defined(_DEBUG) && defined(_X86_)
        // Sometimes the signiture of the PInvoke call does not correspond
        // to the unmanaged function, due to user error.  If this happens,
        // we will trash saved registers.
        __asm mov [PostESP], esp
        _ASSERTE (PreESP >= PostESP 
                  ||!"esp is trashed by PInvoke call, possibly wrong signiture");
#endif

        if (pheader->GetUnmanagedRetValTypeCat() == MLHF_TYPECAT_FPU) {
            int fpNativeSize;
            if (pheader->m_Flags & MLHF_64BITUNMANAGEDRETVAL) {
                fpNativeSize = 8;
            } else {
                fpNativeSize = 4;
            }
            getFPReturn(fpNativeSize, nativeReturnValue);
        }

        if (pheader->m_Flags & MLHF_SETLASTERROR) {
            pThread->m_dwLastError = GetLastError();
        }

#ifdef PROFILING_SUPPORTED
        // Notify the profiler of return from call out of the runtime
        if (CORProfilerTrackTransitions())
        {
            g_profControlBlock.pProfInterface->
                UnmanagedToManagedTransition((FunctionID) pMD,
                                                   COR_PRF_TRANSITION_RETURN);
        }
#endif // PROFILING_SUPPORTED

        pThread->DisablePreemptiveGC();
        if (g_TrapReturningThreads)
            pThread->HandleThreadAbort();

#ifdef CUSTOMER_CHECKED_BUILD
        if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_BufferOverrun))
        {
            g_pGCHeap->GarbageCollect();
            g_pGCHeap->FinalizerThreadWait(1000);
        }
#endif // CUSTOMER_CHECKED_BUILD

        int managedRetValTypeCat = pheader->GetManagedRetValTypeCat();

        if( managedRetValTypeCat == MLHF_TYPECAT_GCREF) {            
         GCPROTECT_BEGIN(*(OBJECTREF *)&returnValue);           

            // Marshal the return value and propagate any [out] parameters back.
            // Assumes a little-endian architecture!
            RunML(pMLCode,
                  &nativeReturnValue,
                  ((BYTE*)&returnValue) + ((pheader->m_Flags & MLHF_64BITMANAGEDRETVAL) ? 8 : 4),
                  (UINT8*const)plocals,
                  pCleanup); // CHANGE, VC6.0        
            GCPROTECT_END();                 
        }
        else {
            // Marshal the return value and propagate any [out] parameters back.
            // Assumes a little-endian architecture!
            RunML(pMLCode,
                  &nativeReturnValue,
                  ((BYTE*)&returnValue) + ((pheader->m_Flags & MLHF_64BITMANAGEDRETVAL) ? 8 : 4),
                  (UINT8*const)plocals,
                  pCleanup); // CHANGE, VC6.0                   
        }


        if (pCleanup) {

            if (managedRetValTypeCat == MLHF_TYPECAT_GCREF) {

                OBJECTREF or;
                or = ObjectToOBJECTREF(*(Object**)&returnValue);
                GCPROTECT_BEGIN(or);
                pCleanup->Cleanup(FALSE);
                *((OBJECTREF*)&returnValue) = or;
                GCPROTECT_END();

            } else {
                pCleanup->Cleanup(FALSE);
            }
        }

        if (managedRetValTypeCat == MLHF_TYPECAT_FPU) {
            int fpComPlusSize;
            if (pheader->m_Flags & MLHF_64BITMANAGEDRETVAL) {
                fpComPlusSize = 8;
            } else {
                fpComPlusSize = 4;
            }
            setFPReturn(fpComPlusSize, returnValue);
        }


        return returnValue;
}






//---------------------------------------------------------
// Creates a new stub for a N/Direct call. Return refcount is 1.
// This Worker() routine is broken out as a separate function
// for purely logistical reasons: our COMPLUS exception mechanism
// can't handle the destructor call for StubLinker so this routine
// has to return the exception as an outparam.
//---------------------------------------------------------
static Stub * CreateNDirectMLStubWorker(MLStubLinker *psl,
                                        MLStubLinker *pslPost,
                                        MLStubLinker *pslRet,
                                        PCCOR_SIGNATURE szMetaSig,
                                        Module*    pModule,
                                        mdMethodDef md,
                                        BYTE       nlType,
                                        BYTE       nlFlags,
                                                                                CorPinvokeMap unmgdCallConv,
                                        OBJECTREF *ppException,
                                        BOOL    fConvertSigAsVarArg,
                                        BOOL    BestFit,
                                        BOOL    ThrowOnUnmappableChar
                                        
#ifdef CUSTOMER_CHECKED_BUILD
                                        ,MethodDesc* pMD
#endif
#ifdef _DEBUG
                                        ,
                                        LPCUTF8 pDebugName,
                                        LPCUTF8 pDebugClassName,
                                        LPCUTF8 pDebugNameSpace
#endif
                                        )
{

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(nlType == nltAnsi || nlType == nltUnicode);

    Stub* pstub = NULL;

        if (unmgdCallConv != pmCallConvStdcall &&
                unmgdCallConv != pmCallConvCdecl &&
                unmgdCallConv != pmCallConvThiscall) {
                COMPlusThrow(kTypeLoadException, IDS_INVALID_PINVOKE_CALLCONV);
        }

    IMDInternalImport *pInternalImport = pModule->GetMDImport();


    BOOL fDoHRESULTSwapping = FALSE;

    if (md != mdMethodDefNil) {

        DWORD           dwDescrOffset;
        DWORD           dwImplFlags;
        pInternalImport->GetMethodImplProps(md,
                                            &dwDescrOffset,
                                            &dwImplFlags
                                           );
        fDoHRESULTSwapping = !IsMiPreserveSig(dwImplFlags);
    }

    COMPLUS_TRY
    {
        THROWSCOMPLUSEXCEPTION();

        //
        // Set up signature walking objects.
        //

        MetaSig msig(szMetaSig, pModule, fConvertSigAsVarArg);
        MetaSig sig = msig;
        ArgIterator ai( NULL, &sig, TRUE);

        if (sig.HasThis())
        {                
            COMPlusThrow(kInvalidProgramException, VLDTR_E_FMD_PINVOKENOTSTATIC);
        }

        //
        // Set up the ML header.
        //

        MLHeader header;

        header.m_cbDstBuffer = 0;
        header.m_cbLocals    = 0;
        header.m_cbStackPop = msig.CbStackPop(TRUE);
        header.m_Flags       = 0;



        if (msig.Is64BitReturn())
        {
            header.m_Flags |= MLHF_64BITMANAGEDRETVAL;
        }

        if (nlFlags & nlfLastError)
        {
            header.m_Flags |= MLHF_SETLASTERROR;
        }

                if (unmgdCallConv == pmCallConvThiscall)
                {
                        header.m_Flags |= MLHF_THISCALL;
                }


        switch (msig.GetReturnType())
        {
            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_OBJECT:
            case ELEMENT_TYPE_CLASS:
            case ELEMENT_TYPE_SZARRAY:
            case ELEMENT_TYPE_ARRAY:
            case ELEMENT_TYPE_VAR:
         // case ELEMENT_TYPE_PTR:  -- cwb. PTR is unmanaged & should not be GC promoted
                header.SetManagedRetValTypeCat(MLHF_TYPECAT_GCREF);
                break;

        }

        psl->MLEmitSpace(sizeof(header));


        //
        // Get a list of the COM+ argument offsets.  We
        // need this since we have to iterate the arguments
        // backwards.
        // Note that the first argument listed may
        // be a byref for a value class return value
        //

        int numArgs = msig.NumFixedArgs();

        int *offsets = (int*)_alloca(numArgs * sizeof(int));
        int *o = offsets;
        int *oEnd = o + numArgs;
        while (o < oEnd)
        {
            *o++ = ai.GetNextOffset();
        }


        mdParamDef *params = (mdParamDef*)_alloca((numArgs+1) * sizeof(mdParamDef));
        CollateParamTokens(pInternalImport, md, numArgs, params);


        //
        // Now, emit the ML.
        //

        int argOffset = 0;
        int lastArgSize = 0;


        MarshalInfo::MarshalType marshalType = (MarshalInfo::MarshalType) 0xcccccccc;

        //
        // Marshal the return value.
        //

        if (msig.GetReturnType() != ELEMENT_TYPE_VOID)
        {
            SigPointer pSig;
            pSig = msig.GetReturnProps();
    
            MarshalInfo returnInfo(pModule,
                                   pSig,
                                   params[0],
                                   MarshalInfo::MARSHAL_SCENARIO_NDIRECT,
                                   nlType,
                                   nlFlags,
                                   FALSE,
                                   0,
                                   BestFit,
                                   ThrowOnUnmappableChar
    #ifdef CUSTOMER_CHECKED_BUILD
                                   ,pMD
    #endif
    #ifdef _DEBUG
                                   ,
                                   pDebugName,
                                   pDebugClassName,
                                   pDebugNameSpace,
                                   0
    #endif
    
                                   );
    
            marshalType = returnInfo.GetMarshalType();

            if (msig.HasRetBuffArg())
            {
                if (marshalType == MarshalInfo::MARSHAL_TYPE_BLITTABLEVALUECLASS ||
                    marshalType == MarshalInfo::MARSHAL_TYPE_GUID ||
                    marshalType == MarshalInfo::MARSHAL_TYPE_DECIMAL)
                {
    
                    if (fDoHRESULTSwapping)
                    {
                        // V1 restriction: we could implement this but it's late in the game to do so.
                        COMPlusThrow(kMarshalDirectiveException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                    }
    
                    MethodTable *pMT = msig.GetRetTypeHandle().AsMethodTable();
                    UINT         managedSize = msig.GetRetTypeHandle().GetSize();
                    UINT         unmanagedSize = pMT->GetNativeSize();
    
                    if (header.m_Flags & MLHF_THISCALL)
                    {
                        header.m_Flags |= MLHF_THISCALLHIDDENARG;
                    }
    
                    if (IsManagedValueTypeReturnedByRef(managedSize) && !( (header.m_Flags & MLHF_THISCALL) || IsUnmanagedValueTypeReturnedByRef(unmanagedSize)) )
                    {
                        psl->MLEmit(ML_CAPTURE_PSRC);
                        psl->Emit16((UINT16)(ai.GetRetBuffArgOffset()));
                        pslRet->MLEmit(ML_MARSHAL_RETVAL_SMBLITTABLEVALUETYPE_C2N);
                        pslRet->Emit32(managedSize);
                        pslRet->Emit16(psl->MLNewLocal(sizeof(BYTE*)));
                    }
                }
                else if (marshalType == MarshalInfo::MARSHAL_TYPE_CURRENCY)
                {
                    if (fDoHRESULTSwapping)
                    {
                        // V1 restriction: we could implement this but it's late in the game to do so.
                        COMPlusThrow(kMarshalDirectiveException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                    }
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                }
                else
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                }
            }   
            else
            {
            
                 if (marshalType == MarshalInfo::MARSHAL_TYPE_OBJECT && !fDoHRESULTSwapping)
                 {
                     // No support for returning variants. This is a V1 restriction, due to the late date,
                     // don't want to add the special-case code to support this in light of low demand.
                     COMPlusThrow(kMarshalDirectiveException, IDS_EE_NOVARIANTRETURN);
                 }
                 returnInfo.GenerateReturnML(psl, pslRet,
                                             TRUE,
                                             fDoHRESULTSwapping
                                            );
    
                 if (returnInfo.IsFpu())
                 {
                     // Ugh - should set this more uniformly or rename the flag.
                     if (returnInfo.GetMarshalType() == MarshalInfo::MARSHAL_TYPE_DOUBLE && !fDoHRESULTSwapping)
                     {
                         header.m_Flags |= MLHF_64BITUNMANAGEDRETVAL;
                     }
    
                     
                     header.SetManagedRetValTypeCat(MLHF_TYPECAT_FPU);
                     if (!fDoHRESULTSwapping) 
                     {
                         header.SetUnmanagedRetValTypeCat(MLHF_TYPECAT_FPU);
                 
                     }
                 }
    
                 if (!SafeAddUINT16(&header.m_cbDstBuffer, returnInfo.GetNativeArgSize()))
                 {
                     COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                 }
    
                 lastArgSize = returnInfo.GetComArgSize();
            }
        }

        msig.GotoEnd();


        //
        // Marshal the arguments
        //

        // Check to see if we need to do LCID conversion.
        int iLCIDArg = GetLCIDParameterIndex(pInternalImport, md);
        if (iLCIDArg != (UINT)-1 && iLCIDArg > numArgs)
            COMPlusThrow(kIndexOutOfRangeException, IDS_EE_INVALIDLCIDPARAM);

        int argidx = msig.NumFixedArgs();
        while (o > offsets)
        {
            --o;


            //
            // Check to see if this is the parameter after which we need to insert the LCID.
            //

            if (argidx == iLCIDArg)
            {
                psl->MLEmit(ML_LCID_C2N);
                if (!SafeAddUINT16(&header.m_cbDstBuffer, sizeof(LCID)))
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                }

            }


            //
            // Adjust src pointer if necessary (for register params or
            // for return value order differences)
            //

            int fixup = *o - (argOffset + lastArgSize);
            argOffset = *o;

            if (!FitsInI2(fixup))
            {
                COMPlusThrow(kTypeLoadException, IDS_EE_SIGTOOCOMPLEX);
            }
            if (fixup != 0)
            {
                psl->Emit8(ML_BUMPSRC);
                psl->Emit16((INT16)fixup);
            }

            msig.PrevArg();

            MarshalInfo info(pModule,
                             msig.GetArgProps(),
                             params[argidx],
                             MarshalInfo::MARSHAL_SCENARIO_NDIRECT,
                             nlType,
                             nlFlags,
                             TRUE,
                             argidx,
                             BestFit,
                             ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                             ,pMD
#endif
#ifdef _DEBUG
                             ,
                             pDebugName,
                             pDebugClassName,
                             pDebugNameSpace,
                             argidx
#endif
);
            info.GenerateArgumentML(psl, pslPost, TRUE);
            if (!SafeAddUINT16(&header.m_cbDstBuffer, info.GetNativeArgSize()))
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
            }


            lastArgSize = info.GetComArgSize();

            --argidx;
        }

        // Check to see if this is the parameter after which we need to insert the LCID.
        if (argidx == iLCIDArg)
        {
            psl->MLEmit(ML_LCID_C2N);
            if (!SafeAddUINT16(&header.m_cbDstBuffer, sizeof(LCID)))
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
            }

        }

        if (msig.GetReturnType() != ELEMENT_TYPE_VOID)
        {
            if (msig.HasRetBuffArg())
            {
                if (marshalType == MarshalInfo::MARSHAL_TYPE_BLITTABLEVALUECLASS ||
                    marshalType == MarshalInfo::MARSHAL_TYPE_GUID ||
                    marshalType == MarshalInfo::MARSHAL_TYPE_DECIMAL)
                {
    
                    // Checked for this above.
                    _ASSERTE(!fDoHRESULTSwapping);
    
                    MethodTable *pMT = msig.GetRetTypeHandle().AsMethodTable();
                    UINT         managedSize = msig.GetRetTypeHandle().GetSize();
                    UINT         unmanagedSize = pMT->GetNativeSize();
        
                    if (IsManagedValueTypeReturnedByRef(managedSize) && ((header.m_Flags & MLHF_THISCALL) || IsUnmanagedValueTypeReturnedByRef(unmanagedSize)))
                    {
                        int fixup = ai.GetRetBuffArgOffset() - (argOffset + lastArgSize);
                        argOffset = ai.GetRetBuffArgOffset();
        
                        if (!FitsInI2(fixup))
                        {
                            COMPlusThrow(kTypeLoadException, IDS_EE_SIGTOOCOMPLEX);
                        }
                        if (fixup != 0)
                        {   
                            psl->Emit8(ML_BUMPSRC);
                            psl->Emit16((INT16)fixup);
                        }
                        psl->MLEmit(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N);
                        psl->Emit32(managedSize);
                        pslPost->MLEmit(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_POST);
                        pslPost->Emit16(psl->MLNewLocal(sizeof(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_C2N_SR)));
                        if (!SafeAddUINT16(&header.m_cbDstBuffer, MLParmSize(sizeof(LPVOID))))
                        {
                            COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                        }
                    }
                    else if (IsManagedValueTypeReturnedByRef(managedSize) && !((header.m_Flags & MLHF_THISCALL) || IsUnmanagedValueTypeReturnedByRef(unmanagedSize)))
                    {
                        // nothing to do here: already taken care of above
                    }
                    else
                    {
                        COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                    }
                }
            }
        }

        // This marker separates the pre from the post work.
        psl->MLEmit(ML_INTERRUPT);

        // First emit code to do any backpropagation/cleanup work (this
        // was generated into a separate stublinker during the argument phase.)
        // Then emit the code to do the return value marshaling.
        pslPost->MLEmit(ML_END);
        pslRet->MLEmit(ML_END);
        Stub *pStubPost = pslPost->Link();
        COMPLUS_TRY {
            Stub *pStubRet = pslRet->Link();
            COMPLUS_TRY {
                if (fDoHRESULTSwapping) {
                    psl->MLEmit(ML_THROWIFHRFAILED);
                }
                psl->EmitBytes(pStubPost->GetEntryPoint(), MLStreamLength((const UINT8 *)(pStubPost->GetEntryPoint())) - 1);
                psl->EmitBytes(pStubRet->GetEntryPoint(), MLStreamLength((const UINT8 *)(pStubRet->GetEntryPoint())) - 1);
            } COMPLUS_CATCH {
                pStubRet->DecRef();
                COMPlusThrow(GETTHROWABLE());
            } COMPLUS_END_CATCH
            pStubRet->DecRef();
        } COMPLUS_CATCH {
            pStubPost->DecRef();
            COMPlusThrow(GETTHROWABLE());
        } COMPLUS_END_CATCH
        pStubPost->DecRef();

        psl->MLEmit(ML_END);

        pstub = psl->Link();

        header.m_cbLocals = psl->GetLocalSize();

        *((MLHeader *)(pstub->GetEntryPoint())) = header;

#ifdef _DEBUG
        {
            MLHeader *pheader = (MLHeader*)(pstub->GetEntryPoint());
            UINT16 locals = 0;
            MLCode opcode;
            const MLCode *pMLCode = pheader->GetMLCode();


            VOID DisassembleMLStream(const MLCode *pMLCode);
            //DisassembleMLStream(pMLCode);

            while (ML_INTERRUPT != (opcode = *(pMLCode++))) {
                locals += gMLInfo[opcode].m_cbLocal;
                pMLCode += gMLInfo[opcode].m_numOperandBytes;
            }
            _ASSERTE(locals == pheader->m_cbLocals);
        }
#endif //_DEBUG


    }
    COMPLUS_CATCH
    {
        *ppException = GETTHROWABLE();
        return NULL;
    }
    COMPLUS_END_CATCH

    return pstub; // CHANGE, VC6.0

}


//---------------------------------------------------------
// Creates a new stub for a N/Direct call. Return refcount is 1.
// If failed, returns NULL and sets *ppException to an exception
// object.
//---------------------------------------------------------
Stub * CreateNDirectMLStub(PCCOR_SIGNATURE szMetaSig,
                           Module*    pModule,
                           mdMethodDef md,
                           CorNativeLinkType       nlType,
                           CorNativeLinkFlags       nlFlags,
                           CorPinvokeMap unmgdCallConv,
                           OBJECTREF *ppException,
                           BOOL fConvertSigAsVarArg,
                           BOOL BestFit,
                           BOOL ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                           ,MethodDesc* pMD
#endif
#ifdef _DEBUG
                           ,
                           LPCUTF8 pDebugName,
                           LPCUTF8 pDebugClassName,
                           LPCUTF8 pDebugNameSpace
#endif


                           )
{
    THROWSCOMPLUSEXCEPTION();
    

    MLStubLinker sl;
    MLStubLinker slPost;
    MLStubLinker slRet;
    return CreateNDirectMLStubWorker(&sl,
                                     &slPost,
                                     &slRet,
                                     szMetaSig,
                                     pModule,
                                     md,
                                     nlType,
                                     nlFlags,
                                     unmgdCallConv,
                                     ppException,
                                     fConvertSigAsVarArg,
                                     BestFit,
                                     ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                                     ,pMD
#endif
#ifdef _DEBUG
                                     ,
                                     pDebugName,
                                     pDebugClassName,
                                     pDebugNameSpace
#endif
                                     );
};


//---------------------------------------------------------
// Extracts the effective NAT_L CustomAttribute for a method.
//---------------------------------------------------------
VOID CalculatePinvokeMapInfo(MethodDesc *pMD,
                             /*out*/ CorNativeLinkType  *pLinkType,
                             /*out*/ CorNativeLinkFlags *pLinkFlags,
                             /*out*/ CorPinvokeMap      *pUnmgdCallConv,
                             /*out*/ LPCUTF8             *pLibName,
                             /*out*/ LPCUTF8             *pEntryPointName,
                             /*out*/ BOOL                *fBestFit,
                             /*out*/ BOOL                *fThrowOnUnmappableChar)
{
    THROWSCOMPLUSEXCEPTION();

    BOOL fHasNatL = NDirect::ReadCombinedNAT_LAttribute(pMD, pLinkType, pLinkFlags, pUnmgdCallConv, pLibName, pEntryPointName, fBestFit, fThrowOnUnmappableChar);
    if (!fHasNatL)
    {
        *pLinkType = nltAnsi;
        *pLinkFlags = nlfNone;

        if (pMD->IsNDirect() && 
            ((NDirectMethodDesc*)pMD)->GetSubClassification() == NDirectMethodDesc::kEarlyBound &&
            HeuristicDoesThisLooksLikeAnApiCall( (LPBYTE) (((NDirectMethodDesc*)pMD)->ndirect.m_pNDirectTarget )) )
        {
            *pLinkFlags = (CorNativeLinkFlags) (*pLinkFlags | nlfLastError);
        }
        
        PCCOR_SIGNATURE pSig;
        DWORD           cSig;
        pMD->GetSig(&pSig, &cSig);
        CorPinvokeMap unmanagedCallConv = MetaSig::GetUnmanagedCallingConvention(pMD->GetModule(), pSig, cSig);
        if (unmanagedCallConv == (CorPinvokeMap)0 || unmanagedCallConv == (CorPinvokeMap)pmCallConvWinapi)
        {
            unmanagedCallConv = pMD->IsVarArg() ? pmCallConvCdecl : pmCallConvStdcall;
        }
        *pUnmgdCallConv = unmanagedCallConv;
        *pLibName = NULL;
        *pEntryPointName = NULL;
    }
}



//---------------------------------------------------------
// Extracts the effective NAT_L CustomAttribute for a method,
// taking into account default values and inheritance from
// the global NAT_L CustomAttribute.
//
// Returns TRUE if a NAT_L CustomAttribute exists and is valid.
// Returns FALSE if no NAT_L CustomAttribute exists.
// Throws an exception otherwise.
//---------------------------------------------------------
/*static*/
BOOL NDirect::ReadCombinedNAT_LAttribute(MethodDesc       *pMD,
                                 CorNativeLinkType        *pLinkType,
                                 CorNativeLinkFlags       *pLinkFlags,
                                 CorPinvokeMap            *pUnmgdCallConv,
                                 LPCUTF8                   *pLibName,
                                 LPCUTF8                   *pEntrypointName,
                                 BOOL                      *BestFit,
                                 BOOL                      *ThrowOnUnmappableChar)
{
    THROWSCOMPLUSEXCEPTION();

    IMDInternalImport  *pInternalImport = pMD->GetMDImport();
    mdToken             token           = pMD->GetMemberDef();


    BOOL fVarArg = pMD->IsVarArg();

    *pLibName        = NULL;
    *pEntrypointName = NULL;

    *BestFit = TRUE;
    *ThrowOnUnmappableChar = FALSE;

    DWORD   mappingFlags = 0xcccccccc;
    LPCSTR  pszImportName = (LPCSTR)POISONC;
    mdModuleRef modref = 0xcccccccc;

    if (SUCCEEDED(pInternalImport->GetPinvokeMap(token, &mappingFlags, &pszImportName, &modref)))
    {
        *pLibName = (LPCUTF8)POISONC;
        pInternalImport->GetModuleRefProps(modref, pLibName);

        *pLinkFlags = nlfNone;

        if (mappingFlags & pmSupportsLastError)
        {
            (*pLinkFlags) = (CorNativeLinkFlags) ((*pLinkFlags) | nlfLastError);
        }

        if (mappingFlags & pmNoMangle)
        {
            (*pLinkFlags) = (CorNativeLinkFlags) ((*pLinkFlags) | nlfNoMangle);
        }

        // Check for Assembly & Interface Attributes
        ReadBestFitCustomAttribute(pMD, BestFit, ThrowOnUnmappableChar);
   
        // Check for PInvoke flags
        switch (mappingFlags & pmBestFitMask)
        {
            case pmBestFitEnabled:
                *BestFit = TRUE;
                break;
                
            case pmBestFitDisabled:
                *BestFit = FALSE;
                break;

            default:
                break;
        }

        switch (mappingFlags & pmThrowOnUnmappableCharMask)
        {
            case pmThrowOnUnmappableCharEnabled:
                *ThrowOnUnmappableChar = TRUE;
                break;

            case pmThrowOnUnmappableCharDisabled:
                *ThrowOnUnmappableChar = FALSE;

            default:
                break;
        }

        
        switch (mappingFlags & (pmCharSetNotSpec|pmCharSetAnsi|pmCharSetUnicode|pmCharSetAuto))
        {
        case pmCharSetNotSpec: //fallthru to Ansi
        case pmCharSetAnsi:
            *pLinkType = nltAnsi;
            break;
        case pmCharSetUnicode:
            *pLinkType = nltUnicode;
            break;
        case pmCharSetAuto:
            *pLinkType = (NDirectOnUnicodeSystem() ? nltUnicode : nltAnsi);
            break;
        default:
            COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_BADNATL); // charset illegal

        }


        *pUnmgdCallConv = (CorPinvokeMap)(mappingFlags & pmCallConvMask);
        PCCOR_SIGNATURE pSig;
        DWORD           cSig;
        pMD->GetSig(&pSig, &cSig);
        CorPinvokeMap sigCallConv = MetaSig::GetUnmanagedCallingConvention(pMD->GetModule(), pSig, cSig);

        if (sigCallConv != 0 &&
            *pUnmgdCallConv != 0 &&
            sigCallConv != *pUnmgdCallConv)
        {
            // non-matching calling conventions
            COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_BADNATL_CALLCONV);
        }
        if (*pUnmgdCallConv == 0)
        {
            *pUnmgdCallConv = sigCallConv;
        }

        if (*pUnmgdCallConv == pmCallConvWinapi ||
            *pUnmgdCallConv == 0
            ) {


            if (*pUnmgdCallConv == 0 && fVarArg)
            {
                *pUnmgdCallConv = pmCallConvCdecl;
            }
            else
            {
                *pUnmgdCallConv = pmCallConvStdcall;
            }
        }

        if (fVarArg && *pUnmgdCallConv != pmCallConvCdecl)
        {
            COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_BADNATL_CALLCONV);
        }

        if (mappingFlags & ~((DWORD)(pmCharSetNotSpec |
                                     pmCharSetAnsi |
                                     pmCharSetUnicode |
                                     pmCharSetAuto |
                                     pmSupportsLastError |
                                     pmCallConvWinapi |
                                     pmCallConvCdecl |
                                     pmCallConvStdcall |
                                     pmCallConvThiscall |
                                     pmCallConvFastcall |
                                     pmNoMangle |
                                     pmBestFitEnabled |
                                     pmBestFitDisabled |
                                     pmBestFitUseAssem |
                                     pmThrowOnUnmappableCharEnabled |
                                     pmThrowOnUnmappableCharDisabled |
                                     pmThrowOnUnmappableCharUseAssem
                                     )))
        {
            COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_BADNATL); // mapping flags illegal
        }


        if (pszImportName == NULL)
            *pEntrypointName = pMD->GetName();
        else
            *pEntrypointName = pszImportName;

        return TRUE;
    }

    return FALSE;
}




//---------------------------------------------------------
// Does a class or method have a NAT_L CustomAttribute?
//
// S_OK    = yes
// S_FALSE = no
// FAILED  = unknown because something failed.
//---------------------------------------------------------
/*static*/
HRESULT NDirect::HasNAT_LAttribute(IMDInternalImport *pInternalImport, mdToken token)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(TypeFromToken(token) == mdtMethodDef);

    // Check method flags first before trying to find the custom value
    DWORD           dwAttr;
    dwAttr = pInternalImport->GetMethodDefProps(token);
    if (!IsReallyMdPinvokeImpl(dwAttr))
    {
        return S_FALSE;
    }

    DWORD   mappingFlags = 0xcccccccc;
    LPCSTR  pszImportName = (LPCSTR)POISONC;
    mdModuleRef modref = 0xcccccccc;


    if (SUCCEEDED(pInternalImport->GetPinvokeMap(token, &mappingFlags, &pszImportName, &modref)))
    {
        return S_OK;
    }

    return S_FALSE;
}



struct _NDirect_NumParamBytes_Args {
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refMethod);
};


//
// NumParamBytes
// Counts # of parameter bytes
INT32 __stdcall NDirect_NumParamBytes(struct _NDirect_NumParamBytes_Args *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (!(args->refMethod)) 
        COMPlusThrowArgumentNull(L"m");
    if (args->refMethod->GetMethodTable() != g_pRefUtil->GetClass(RC_Method))
        COMPlusThrowArgumentException(L"m", L"Argument_MustBeRuntimeMethodInfo");

    ReflectMethod* pRM = (ReflectMethod*) args->refMethod->GetData();
    MethodDesc* pMD = pRM->pMethod;

    if (!(pMD->IsNDirect()))
        COMPlusThrow(kArgumentException, IDS_EE_NOTNDIRECT);

    // This is revolting but the alternative is even worse. The unmanaged param count
    // isn't stored anywhere permanent so the only way to retrieve this value is
    // to recreate the MLStream. So this api will have horrible perf but almost
    // nobody uses it anyway.

    CorNativeLinkType type;
    CorNativeLinkFlags flags;
    LPCUTF8 szLibName = NULL;
    LPCUTF8 szEntrypointName = NULL;
    Stub  *pTempMLStub = NULL;
    CorPinvokeMap unmgdCallConv;
    BOOL BestFit;
    BOOL ThrowOnUnmappableChar;

    CalculatePinvokeMapInfo(pMD, &type, &flags, &unmgdCallConv, &szLibName, &szEntrypointName, &BestFit, &ThrowOnUnmappableChar);

    OBJECTREF pThrowable;

    // @nice: The code to get the new-style signatures should be
    // encapsulated in the MethodDesc class.
    PCCOR_SIGNATURE pMetaSig;
    DWORD       cbMetaSig;
    pMD->GetSig(&pMetaSig, &cbMetaSig);


    pTempMLStub = CreateNDirectMLStub(pMetaSig, pMD->GetModule(), pMD->GetMemberDef(), type, flags, unmgdCallConv, &pThrowable, FALSE, BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                                      ,pMD
#endif
                                      );
    if (!pTempMLStub)
    {
        COMPlusThrow(pThrowable);
    }
    UINT cbParamBytes = ((MLHeader*)(pTempMLStub->GetEntryPoint()))->m_cbDstBuffer;
    pTempMLStub->DecRef();
    return cbParamBytes;

}



struct _NDirect_Prelink_Args {
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refMethod);
};



// Prelink
// Does advance loading of an N/Direct library
VOID __stdcall NDirect_Prelink_Wrapper(struct _NDirect_Prelink_Args *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (!(args->refMethod)) 
        COMPlusThrowArgumentNull(L"m");
    if (args->refMethod->GetMethodTable() != g_pRefUtil->GetClass(RC_Method))
        COMPlusThrowArgumentException(L"m", L"Argument_MustBeRuntimeMethodInfo");

    ReflectMethod* pRM = (ReflectMethod*) args->refMethod->GetData();
    MethodDesc* pMeth = pRM->pMethod;

    NDirect_Prelink(pMeth);
}


VOID NDirect_Prelink(MethodDesc *pMeth)
{
    THROWSCOMPLUSEXCEPTION();

    // If the prestub has already been executed, no need to do it again.
    // This is a perf thing since it's safe to execute the prestub twice.
    if (!(pMeth->PointAtPreStub())) {
        return;
    }

    // Silently ignore if not N/Direct and not ECall.
    if (!(pMeth->IsNDirect()) && !(pMeth->IsECall())) {
        return;
    }

    pMeth->DoPrestub(NULL);
}


//==========================================================================
// This function is reached only via NDirectImportThunk. It's purpose
// is to ensure that the target DLL is fully loaded and ready to run.
//
// FUN FACTS: Though this function is actually entered in unmanaged mode,
// it can reenter managed mode and throw a COM+ exception if the DLL linking
// fails.
//==========================================================================
LPVOID NDirectImportWorker(LPVOID pBiasedNDirectMethodDesc)
{
    size_t fixup = offsetof(NDirectMethodDesc,ndirect.m_ImportThunkGlue) + METHOD_CALL_PRESTUB_SIZE;
    NDirectMethodDesc *pMD = (NDirectMethodDesc*)( ((LPBYTE)pBiasedNDirectMethodDesc) - fixup );

    if (pMD->GetSubClassification() == pMD->kEarlyBound)
    {
        // 
        // This is a prejitted early bound MD - compute the destination from
        // the RVA and the managed IL base.
        //
        pMD->InitEarlyBoundNDirectTarget(pMD->GetModule()->GetILBase(),
                                         pMD->GetRVA());
    }
    else
    {
        //
        // Otherwise we're in an inlined pinvoke late bound MD
        //

        Thread *pThread = GetThread();
        pThread->DisablePreemptiveGC();

        _ASSERTE( *((LPVOID*) (pThread->GetFrame())) == InlinedCallFrame::GetInlinedCallFrameFrameVPtr() );

        THROWSCOMPLUSEXCEPTION();
        NDirect_Prelink(pMD);

        pThread->EnablePreemptiveGC();
    }
    
    return pMD->GetNDirectTarget();
}


//==========================================================================
// This function is reached only via the embedded ImportThunkGlue code inside
// an NDirectMethodDesc. It's purpose is to load the DLL associated with an
// N/Direct method, then backpatch the DLL target into the methoddesc.
//
// Initial state:
//
//      Preemptive GC is *enabled*: we are actually in an unmanaged state.
//
//
//      [esp+...]   - The *unmanaged* parameters to the DLL target.
//      [esp+4]     - Return address back into the JIT'ted code that made
//                    the DLL call.
//      [esp]       - Contains the "return address." Because we got here
//                    thru a call embedded inside a MD, this "return address"
//                    gives us an easy to way to find the MD (which was the
//                    whole purpose of the embedded call manuever.)
//
//
//
//==========================================================================
#ifndef _ALPHA_ // Alpha doesn't understand naked
__declspec(naked)
#endif // !_ALPHA_
VOID NDirectImportThunk()
{
#ifdef _X86_
    __asm{

        // NDirectImportWorkertakes a single argument: the bogus return address that lets us
        // find the MD. Pop it into eax so we can pass it later.
        pop     eax

        // Preserve argument registers
        push    ecx
        push    edx

        // Invoke the function that does the real work. 
        push    eax
        call    NDirectImportWorker

        // Restore argument registers
        pop     edx
        pop     ecx

        // If we got back from NDirectImportWorker, the MD has been successfully
        // linked and "eax" contains the DLL target. Proceed to execute the
        // original DLL call.
        jmp     eax     // Jump to DLL target

    }
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - NDirectImportThunk (Ndirect.cpp)");
#endif // _X86_
}

//==========================================================================
// NDirect debugger support
//==========================================================================

void NDirectMethodFrameGeneric::GetUnmanagedCallSite(void **ip,
                                                     void **returnIP,
                                                     void **returnSP)
{

    if (ip != NULL)
        AskStubForUnmanagedCallSite(ip, NULL, NULL);

    NDirectMethodDesc *pMD = (NDirectMethodDesc*)GetFunction();

    //
    // Get ML header
    //

    MLHeader *pheader;

    DWORD cbLocals;
    DWORD cbDstBuffer;
    DWORD cbThisCallInfo;

    if (pMD->IsVarArgs())
    {
        VASigCookie *pVASigCookie = GetVASigCookie();

        Stub *pTempMLStub;

        if (pVASigCookie->pNDirectMLStub != NULL)
        {
            pTempMLStub = pVASigCookie->pNDirectMLStub;

            pheader = (MLHeader*)(pTempMLStub->GetEntryPoint());

            cbLocals = pheader->m_cbLocals;
            cbDstBuffer = pheader->m_cbDstBuffer;
            cbThisCallInfo = (pheader->m_Flags & MLHF_THISCALL) ? 4 : 0;
        }
        else
        {
            // If we don't have a stub when we get here then we simply can't compute the return SP below. However, we
            // never actually ask for the return IP or SP when we don't have a stub yet anyway, so this is just fine.
            pheader = NULL;
            cbLocals = 0;
            cbDstBuffer = 0;
            cbThisCallInfo = 0;
        }
    }
    else
    {
        pheader = pMD->GetMLHeader();

        cbLocals = pheader->m_cbLocals;
        cbDstBuffer = pheader->m_cbDstBuffer;
        cbThisCallInfo = (pheader->m_Flags & MLHF_THISCALL) ? 4 : 0;
    }

    //
    // Compute call site info for NDirectGenericStubWorker
    //

    if (returnIP != NULL)
        *returnIP = g_NDirectGenericWorkerReturnAddress;

    //
    // !!! yow, this is a bit fragile...
    //

    if (returnSP != NULL)
        *returnSP = (void*) (((BYTE*) this)
                            - GetNegSpaceSize()
                            - g_NDirectGenericWorkerStackSize
                            - cbLocals
                            - cbDstBuffer
                            + cbThisCallInfo
                            - sizeof(void *));
}



void NDirectMethodFrameSlim::GetUnmanagedCallSite(void **ip,
                                                  void **returnIP,
                                                  void **returnSP)
{

    AskStubForUnmanagedCallSite(ip, returnIP, returnSP);

    if (returnSP != NULL)
    {
        //
        // The slim worker pushes extra stack space, so
        // adjust our result obtained directly from the stub.
        //

        //
        // Get ML header
        //

        NDirectMethodDesc *pMD = (NDirectMethodDesc*)GetFunction();

        MLHeader *pheader;
        if (pMD->IsVarArgs())
        {
            VASigCookie *pVASigCookie = GetVASigCookie();

            Stub *pTempMLStub = NULL;

            if (pVASigCookie->pNDirectMLStub != NULL) {
                pTempMLStub = pVASigCookie->pNDirectMLStub;
            } else {
                //
                // We don't support generating an ML stub inside the debugger
                // callback right now.
                //
                _ASSERTE(!"NYI");
            }

            pheader = (MLHeader*)(pTempMLStub->GetEntryPoint());
            *(BYTE**)returnSP -= pheader->m_cbLocals;
        }
        else
        {
            pheader = pMD->GetMLHeader();
           *(BYTE**)returnSP -= pheader->m_cbLocals;
        }
    }
}





void FramedMethodFrame::AskStubForUnmanagedCallSite(void **ip,
                                                     void **returnIP,
                                                     void **returnSP)
{

    MethodDesc *pMD = GetFunction();

    // If we were purists, we'd create a new subclass that parents NDirect and ComPlus method frames
    // so we don't have these funky methods that only work for a subset. 
    _ASSERTE(pMD->IsNDirect() || pMD->IsComPlusCall());

    if (returnIP != NULL || returnSP != NULL)
    {

        //
        // We need to get a pointer to the NDirect stub.
        // Unfortunately this is a little more difficult than
        // it might be...
        //

        //
        // Read destination out of prestub
        //

        BYTE *prestub = (BYTE*) pMD->GetPreStubAddr();
        INT32 stubOffset = *((UINT32*)(prestub+1));
        const BYTE *code = prestub + METHOD_CALL_PRESTUB_SIZE + stubOffset;

        //
        // Recover stub from code address
        //

        Stub *stub = Stub::RecoverStub(code);

        //
        // NDirect stub may have interceptors - skip them
        //

        while (stub->IsIntercept())
            stub = *((InterceptStub*)stub)->GetInterceptedStub();

        //
        // This should be the NDirect stub.
        //

        code = stub->GetEntryPoint();
        _ASSERTE(StubManager::IsStub(code));

        //
        // Compute the pointers from the call site info in the stub
        //

        if (returnIP != NULL)
            *returnIP = (void*) (code + stub->GetCallSiteReturnOffset());

        if (returnSP != NULL)
            *returnSP = (void*)
              (((BYTE*)this)+GetOffsetOfNextLink()+sizeof(Frame*)
               - stub->GetCallSiteStackSize()
               - sizeof(void*));
    }

    if (ip != NULL)
    {
        if (pMD->IsNDirect())
        {
            NDirectMethodDesc *pNMD = (NDirectMethodDesc *)pMD;
    
            *ip = pNMD->GetNDirectTarget();

            if (*ip == pNMD->ndirect.m_ImportThunkGlue)
            {
                // We may not have already linked during inline pinvoke

                _ASSERTE(pNMD->GetSubClassification() == pNMD->kEarlyBound);

                pNMD->InitEarlyBoundNDirectTarget(pNMD->GetModule()->GetILBase(),
                                                  pNMD->GetRVA());

                *ip = pNMD->GetNDirectTarget();
            }
    
            _ASSERTE(*ip != pNMD->ndirect.m_ImportThunkGlue);
        }
        else if (pMD->IsComPlusCall())
            *ip = ComPlusCall::GetFrameCallIP(this);
        else
            _ASSERTE(0);
    }
}


BOOL NDirectMethodFrame::TraceFrame(Thread *thread, BOOL fromPatch,
                                    TraceDestination *trace, REGDISPLAY *regs)
{

    //
    // Get the call site info
    //

    void *ip, *returnIP, *returnSP;
    GetUnmanagedCallSite(&ip, &returnIP, &returnSP);

    //
    // If we've already made the call, we can't trace any more.
    //
    // !!! Note that this test isn't exact.
    //

    if (!fromPatch
        && (thread->GetFrame() != this
            || !thread->m_fPreemptiveGCDisabled
            || *(void**)returnSP == returnIP))
    {
        LOG((LF_CORDB, LL_INFO10000,
             "NDirectMethodFrame::TraceFrame: can't trace...\n"));
        return FALSE;
    }

    //
    // Otherwise, return the unmanaged destination.
    //

    trace->type = TRACE_UNMANAGED;
    trace->address = (const BYTE *) ip;

    LOG((LF_CORDB, LL_INFO10000,
         "NDirectMethodFrame::TraceFrame: ip=0x%08x\n", ip));

    return TRUE;
}

//===========================================================================
//  Support for Pinvoke Calli instruction
//
//===========================================================================


Stub  * GetMLStubForCalli(VASigCookie *pVASigCookie)
{
        // could throw exception
    THROWSCOMPLUSEXCEPTION();
    Stub  *pTempMLStub;
    OBJECTREF pThrowable;

        CorPinvokeMap unmgdCallConv = pmNoMangle;

        switch (MetaSig::GetCallingConvention(pVASigCookie->pModule, pVASigCookie->mdVASig)) {
                case IMAGE_CEE_CS_CALLCONV_C:
                        unmgdCallConv = pmCallConvCdecl;
                        break;
                case IMAGE_CEE_CS_CALLCONV_STDCALL:
                        unmgdCallConv = pmCallConvStdcall;
                        break;
                case IMAGE_CEE_CS_CALLCONV_THISCALL:
                        unmgdCallConv = pmCallConvThiscall;
                        break;
                case IMAGE_CEE_CS_CALLCONV_FASTCALL:
                        unmgdCallConv = pmCallConvFastcall;
                        break;
                default:
                        COMPlusThrow(kTypeLoadException, IDS_INVALID_PINVOKE_CALLCONV);
        }


        pTempMLStub = CreateNDirectMLStub(pVASigCookie->mdVASig, pVASigCookie->pModule, mdMethodDefNil, nltAnsi, nlfNone, unmgdCallConv, &pThrowable, TRUE, TRUE, FALSE
#ifdef CUSTOMER_CHECKED_BUILD
                                          ,NULL // wants MethodDesc*
#endif
                                          );
    if (!pTempMLStub)
    {
        COMPlusThrow(pThrowable);
    }
        if (NULL != VipInterlockedCompareExchange( (void*volatile*)&(pVASigCookie->pNDirectMLStub),
                                                       pTempMLStub,
                                                       NULL ))
        {
                pTempMLStub->DecRef();
                pTempMLStub = pVASigCookie->pNDirectMLStub;
    }
        return pTempMLStub;
}


static int g_PInvokeCalliGenericWorkerStackSize = 0;
static void *g_PInvokeCalliGenericWorkerReturnAddress = NULL;


Stub* g_pGenericPInvokeCalliStub = NULL;
/*static*/
#ifdef _SH3_
INT32 __stdcall PInvokeCalliWorker(Thread *pThread, PInvokeCalliFrame* pFrame)
#else
INT64 __stdcall PInvokeCalliWorker(Thread *pThread,
                                   PInvokeCalliFrame* pFrame)
#endif
{


    if (pThread == NULL) // Special case called during initialization
    {
        // Compute information about the worker function for the debugger to
        // use.  Note that this information could theoretically be
        // computed statically, except that the compiler provides no means to
        // do so.
#ifdef _X86_
        __asm
        {
            lea eax, pFrame + 4
            sub eax, esp
            mov g_PInvokeCalliGenericWorkerStackSize, eax

            lea eax, RETURN_FROM_CALL
            mov g_PInvokeCalliGenericWorkerReturnAddress, eax

        }
#elif defined(_IA64_)   // !_X86_
        //
        // @TODO_IA64: implement this
        //
        g_PInvokeCalliGenericWorkerStackSize        = 0xBAAD;
        g_PInvokeCalliGenericWorkerReturnAddress    = (void*)0xBAAD;
#else // !_X86_ && !_IA64_
        _ASSERTE(!"@TODO Alpha - PInvokeCalliWorker (Ndirect.cpp)");
#endif // _X86_
        return 0;
    }

    // could throw exception
    THROWSCOMPLUSEXCEPTION();
    INT64 returnValue   =0;
    LPVOID target       = pFrame->NonVirtual_GetPInvokeCalliTarget();


        VASigCookie *pVASigCookie = (VASigCookie *)pFrame->NonVirtual_GetCookie();

    Stub *pTempMLStub;

    if (pVASigCookie->pNDirectMLStub != NULL)
        {
        pTempMLStub = pVASigCookie->pNDirectMLStub;
    }
        else
        {
                pTempMLStub = GetMLStubForCalli(pVASigCookie);
        }

    // get the header for this MLStub
    MLHeader *pheader = (MLHeader*)pTempMLStub->GetEntryPoint() ;

    // Allocate enough memory to store both the destination buffer and
    // the locals.

        // the locals.
        UINT   cbAlloc         = pheader->m_cbDstBuffer + pheader->m_cbLocals;
        BYTE *pAlloc           = (BYTE*)_alloca(cbAlloc);

    // Sanity check on stack layout computation

    #ifdef _DEBUG
        FillMemory(pAlloc, cbAlloc, 0xcc);
    #endif

    BYTE   *pdst    = pAlloc;
    BYTE   *plocals = pdst + pheader->m_cbDstBuffer;
    pdst += pheader->m_cbDstBuffer;

    // psrc and pdst are the pointers to the source and destination
    // from/to where the arguments are marshalled

    VOID   *psrc          = (VOID*)pFrame;
    CleanupWorkList *pCleanup = pFrame->GetCleanupWorkList();
    if (pCleanup) {
        // Checkpoint the current thread's fast allocator (used for temporary
        // buffers over the call) and schedule a collapse back to the checkpoint in
        // the cleanup list. Note that if we need the allocator, it is
        // guaranteed that a cleanup list has been allocated.
        void *pCheckpoint = pThread->m_MarshalAlloc.GetCheckpoint();
        pCleanup->ScheduleFastFree(pCheckpoint);
        pCleanup->IsVisibleToGc();
    }

        // Call the ML interpreter to translate the arguments. Assuming
        // it returns, we get back a pointer to the succeeding code stream
        // which we will save away for post-call execution.
    const MLCode *pMLCode = RunML(pheader->GetMLCode(),
                                  psrc,
                                  pdst,
                                  (UINT8*const)plocals,
                                  pCleanup);
#ifdef CUSTOMER_CHECKED_BUILD
    CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_ObjNotKeptAlive))
    {
        g_pGCHeap->GarbageCollect();
        g_pGCHeap->FinalizerThreadWait(1000);
    }
#endif // CUSTOMER_CHECKED_BUILD

    // enable gc
    pThread->EnablePreemptiveGC();

#ifdef PROFILING_SUPPORTED
    // If the profiler wants notifications of transitions, let it know we're
    // going into unmanaged code.  Unfortunately, for calli there is no
    // associated MethodDesc so we can't provide a valid FunctionID.
    if (CORProfilerTrackTransitions())
        g_profControlBlock.pProfInterface->
            ManagedToUnmanagedTransition((FunctionID)0, COR_PRF_TRANSITION_CALL);
#endif // PROFILLING_SUPPORTED

#if defined(_DEBUG) && defined(_X86_)
        UINT    mismatch;
        __asm {
            mov     eax,[pAlloc]
            sub     eax,esp
            mov     [mismatch],eax

        }
        if (mismatch != 0) {
            // Slimy as this trick is, it's required to implement copy ctor calling correctly -

            _ASSERTE(!"Compiler assumption broken: _alloca'd buffer not on bottom of stack.");
        }
#endif _DEBUG && _X86_

    BOOL    fThisCall = pheader->m_Flags & MLHF_THISCALL;
    BOOL    fHasHiddenArg = pheader->m_Flags & MLHF_THISCALLHIDDENARG;
    LPVOID  pvFn      = target;
    INT64   nativeReturnValue;

#if _DEBUG
        //
        // Call through debugger routines to double check their
        // implementation
        //
        pvFn = (void*) Frame::CheckExitFrameDebuggerCalls;
#endif


#ifdef _X86_
        __asm {
            cmp     dword ptr fThisCall, 0
            jz      doit

            cmp     dword ptr fHasHiddenArg, 0
            jz      regularthiscall

            pop     eax
            pop     ecx
            push    eax
            jmp     doit

    regularthiscall:
            pop     ecx
    doit:
            call    dword ptr [pvFn]
        }
#else
        _ASSERTE(!"NYI for non-x86");
#endif


#ifdef _X86_

RETURN_FROM_CALL:

        __asm {
            mov     dword ptr [nativeReturnValue], eax
            mov     dword ptr [nativeReturnValue + 4], edx
        }
#else
        _ASSERTE(!"NYI for non-x86");
#endif // _X86_

    int managedRetValTypeCat = pheader->GetManagedRetValTypeCat();
    if (managedRetValTypeCat == MLHF_TYPECAT_FPU)
    {
        int fpNativeSize;
        if (pheader->m_Flags & MLHF_64BITUNMANAGEDRETVAL)
        {
            fpNativeSize = 8;
        }
        else
        {
            fpNativeSize = 4;
        }
        getFPReturn(fpNativeSize, nativeReturnValue);
    }

#ifdef PROFILING_SUPPORTED
    // If the profiler wants notifications of transitions, let it know we're
    // returning from unmanaged code.  Unfortunately, for calli there is no
    // associated MethodDesc so we can't provide a valid FunctionID.
    if (CORProfilerTrackTransitions())
        g_profControlBlock.pProfInterface->
            UnmanagedToManagedTransition((FunctionID)0, COR_PRF_TRANSITION_RETURN);
#endif // PROFILING_SUPPORTED

    pThread->DisablePreemptiveGC();

#ifdef CUSTOMER_CHECKED_BUILD
    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_BufferOverrun))
    {
        g_pGCHeap->GarbageCollect();
        g_pGCHeap->FinalizerThreadWait(1000);
    }
#endif // CUSTOMER_CHECKED_BUILD

    // Marshal the return value and propagate any [out] parameters back.
    // Assumes a little-endian architecture!
    RunML(pMLCode,
          &nativeReturnValue,
          ((BYTE*)&returnValue) + ((pheader->m_Flags & MLHF_64BITMANAGEDRETVAL) ? 8 : 4),
          (UINT8*const)plocals,
          pCleanup); // CHANGE, VC6.0
    if (pCleanup) {

        if (managedRetValTypeCat == MLHF_TYPECAT_GCREF) {

            void* refOrByrefValue = (void*) returnValue;
            GCPROTECT_BEGININTERIOR(refOrByrefValue);
            pCleanup->Cleanup(FALSE);
            returnValue = (INT64) refOrByrefValue;
            GCPROTECT_END();

        } else {
            pCleanup->Cleanup(FALSE);
        }
    }



    if (managedRetValTypeCat == MLHF_TYPECAT_FPU)
    {
        int fpComPlusSize;
        if (pheader->m_Flags & MLHF_64BITMANAGEDRETVAL)
        {
            fpComPlusSize = 8;
        } else
        {
            fpComPlusSize = 4;
        }
        setFPReturn(fpComPlusSize, returnValue);
    }

#ifdef _X86_
        // Set the number of bytes to pop
    pFrame->NonVirtual_SetFunction((void *)(size_t)(pVASigCookie->sizeOfArgs+sizeof(int)));
#else
    _ASSERTE(!"@TODO Alpha - PInvokeCalliWorker (Ndirect.cpp)");
#endif

    return returnValue;
}

void PInvokeCalliFrame::GetUnmanagedCallSite(void **ip, void **returnIP,
                                                     void **returnSP)
{
    if (ip != NULL)
    {
        *ip = NonVirtual_GetPInvokeCalliTarget();
    }

    //
    // Compute call site info for NDirectGenericStubWorker
    //

    if (returnIP != NULL)
        *returnIP = g_PInvokeCalliGenericWorkerReturnAddress;

    //
    // !!! yow, this is a bit fragile...
    //

        if (returnSP != NULL)
        {
                VASigCookie *pVASigCookie = (VASigCookie *)NonVirtual_GetCookie();

                Stub *pTempMLStub;

                if (pVASigCookie->pNDirectMLStub != NULL)
                {
                        pTempMLStub = pVASigCookie->pNDirectMLStub;
                }
                else
                {
                        pTempMLStub = GetMLStubForCalli(pVASigCookie);
                }

        // get the header for this MLStub
        MLHeader *pheader = (MLHeader*)pTempMLStub->GetEntryPoint() ;

        *returnSP = (void*) (((BYTE*) this)
                             - GetNegSpaceSize()
                             // GenericWorker
                             - g_PInvokeCalliGenericWorkerStackSize
                             - pheader->m_cbLocals      // _alloca
                             - pheader->m_cbDstBuffer   // _alloca
                             + ( (pheader->m_Flags & MLHF_THISCALL) ? 4 : 0 )
                             - sizeof(void *));         // return address
    }
}

BOOL PInvokeCalliFrame::TraceFrame(Thread *thread, BOOL fromPatch,
                                    TraceDestination *trace, REGDISPLAY *regs)
{

    //
    // Get the call site info
    //

    void *ip, *returnIP, *returnSP;
    GetUnmanagedCallSite(&ip, &returnIP, &returnSP);

    //
    // If we've already made the call, we can't trace any more.
    //
    // !!! Note that this test isn't exact.
    //

    if (!fromPatch
        && (thread->GetFrame() != this
            || !thread->m_fPreemptiveGCDisabled
            || *(void**)returnSP == returnIP))
        return FALSE;

    //
    // Otherwise, return the unmanaged destination.
    //

    trace->type = TRACE_UNMANAGED;
    trace->address = (const BYTE *) ip;
    return TRUE;
}

#ifdef _X86_
/*static*/ Stub* CreateGenericPInvokeCalliHelper(CPUSTUBLINKER *psl)
{
    BEGINCANNOTTHROWCOMPLUSEXCEPTION();


    Stub* pCandidate = NULL;
    COMPLUS_TRY
    {
        psl->X86EmitPushReg(kEAX);      // push unmanaged target
        psl->EmitMethodStubProlog(PInvokeCalliFrame::GetMethodFrameVPtr());
        // pushes a CleanupWorkList.
        psl->X86EmitPushImm32(0);

        psl->X86EmitPushReg(kESI);       // push esi (push new frame as ARG)
        psl->X86EmitPushReg(kEBX);       // push ebx (push current thread as ARG)

    #ifdef _DEBUG
        // push IMM32 ; push ComPlusToComWorker
        psl->Emit8(0x68);
        psl->EmitPtr((LPVOID)PInvokeCalliWorker);
        // in CE pop 8 bytes or args on return from call
        psl->X86EmitCall(psl->NewExternalCodeLabel(WrapCall),8);
    #else
        psl->X86EmitCall(psl->NewExternalCodeLabel((LPVOID)PInvokeCalliWorker),8);
    #endif

        psl->X86EmitPopReg(kECX);       //pop off the cleanupworklist


        psl->EmitMethodStubEpilog(-1, kNoTripStubStyle);

        pCandidate = psl->Link(SystemDomain::System()->GetStubHeap());
    }
    COMPLUS_CATCH
    {
    }
    COMPLUS_END_CATCH
    return pCandidate;

    ENDCANNOTTHROWCOMPLUSEXCEPTION();
}
#elif defined(_IA64_)   // !_X86_
/*static*/ Stub* CreateGenericPInvokeCalliHelper(CPUSTUBLINKER *psl)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    //
    // @TODO_IA64: implement this for IA64
    //
    return (Stub*)0xBAAD;
}
#else // !_X86_ && !_IA64_
/*static*/ Stub* CreateGenericPInvokeCalliHelper(CPUSTUBLINKER *psl)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

        _ASSERTE(!"Implement me for non X86");
        return NULL;
}
#endif // _X86_


BOOL SetupGenericPInvokeCalliStub()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    StubLinker sl;
    g_pGenericPInvokeCalliStub = CreateGenericPInvokeCalliHelper((CPUSTUBLINKER *)&sl);
    return g_pGenericPInvokeCalliStub != NULL;
}

LPVOID GetEntryPointForPInvokeCalliStub()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    _ASSERTE(g_pGenericPInvokeCalliStub != NULL);
    return (LPVOID)(g_pGenericPInvokeCalliStub->GetEntryPoint());
}



// This attempts to guess whether a target is an API call that uses SetLastError to communicate errors.
static BOOL HeuristicDoesThisLooksLikeAnApiCallHelper(LPBYTE pTarget)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
#ifdef _X86_
    static struct SysDllInfo
    {
        LPCWSTR pName;
        LPBYTE pImageBase;
        DWORD  dwImageSize;
    } gSysDllInfo[] =  {{L"KERNEL32",       0, 0},
                        {L"GDI32",           0, 0},
                        {L"USER32",          0, 0},
                        {L"ADVAPI32",        0, 0}
                       };


    for (int i = 0; i < sizeof(gSysDllInfo)/sizeof(*gSysDllInfo); i++)
    {
        if (gSysDllInfo[i].pImageBase == 0)
        {
            IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)WszGetModuleHandle(gSysDllInfo[i].pName);
            if (pDos)
            {
                if (pDos->e_magic == IMAGE_DOS_SIGNATURE)
                {
                    IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*) (((LPBYTE)pDos) + pDos->e_lfanew);
                    if (pNT->Signature == IMAGE_NT_SIGNATURE &&
                        pNT->FileHeader.SizeOfOptionalHeader == IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
                        pNT->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC)
                    {
                        gSysDllInfo[i].dwImageSize = pNT->OptionalHeader.SizeOfImage;
                    }

                }


                gSysDllInfo[i].pImageBase = (LPBYTE)pDos;
            }
        }
        if (gSysDllInfo[i].pImageBase != 0 &&
            pTarget >= gSysDllInfo[i].pImageBase &&
            pTarget < gSysDllInfo[i].pImageBase + gSysDllInfo[i].dwImageSize)
        {
            return TRUE;
        }
    }
    return FALSE;

#else
    // Non-x86: Either implement the equivalent or forget about it (IJW probably not so important on non-x86 platforms.)
    return FALSE;
#endif
}

#ifdef _X86_
LPBYTE FollowIndirect(LPBYTE pTarget)
{
    BEGINCANNOTTHROWCOMPLUSEXCEPTION();
    __try {

        if (pTarget == NULL)
        {
            return NULL;
        }
        if (pTarget[0] == 0xff && pTarget[1] == 0x25)
        {
            return **(LPBYTE**)(pTarget + 2);
        }
        return NULL;
    } __except(COMPLUS_EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
}
#endif

// This attempts to guess whether a target is an API call that uses SetLastError to communicate errors.
BOOL HeuristicDoesThisLooksLikeAnApiCall(LPBYTE pTarget)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    if (pTarget == NULL)
    {
        return FALSE;
    }
    if (HeuristicDoesThisLooksLikeAnApiCallHelper(pTarget))
    {
        return TRUE;
    }
#ifdef _X86_
    LPBYTE pTarget2 = FollowIndirect(pTarget);
    if (pTarget2)
    {
        // jmp [xxxx] - could be an import thunk
        return HeuristicDoesThisLooksLikeAnApiCallHelper( pTarget2 );
    }
#endif
    return FALSE;
}


BOOL HeuristicDoesThisLookLikeAGetLastErrorCall(LPBYTE pTarget)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    static LPBYTE pGetLastError = NULL;
    if (!pGetLastError)
    {
        HMODULE hMod = WszGetModuleHandle(L"KERNEL32");
        if (hMod)
        {
            pGetLastError = (LPBYTE)GetProcAddress(hMod, "GetLastError");
            if (!pGetLastError)
            {
                // This should never happen but better to be cautious.
                pGetLastError = (LPBYTE)-1;
            }
        }
        else
        {
            // We failed to get the module handle for kernel32.dll. This is almost impossible
            // however better to err on the side of caution.
            pGetLastError = (LPBYTE)-1;
        }
    }

    if (pTarget == pGetLastError)
    {
        return TRUE;
    }

    if (pTarget == NULL)
    {
        return FALSE;
    }


#ifdef _X86_
    LPBYTE pTarget2 = FollowIndirect(pTarget);
    if (pTarget2)
    {
        // jmp [xxxx] - could be an import thunk
        return pTarget2 == pGetLastError;
    }
#endif
    return FALSE;
}

DWORD __stdcall FalseGetLastError()
{
    return GetThread()->m_dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\namespace.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// This file defines namespaces used by the runtime.
//

#define g_SystemNS          "System"

#define g_RuntimeNS         g_SystemNS ".Runtime"
#define g_IONS              g_SystemNS ".IO"
#define g_ThreadingNS       g_SystemNS ".Threading"
#define g_CollectionsNS     g_SystemNS ".Collections"
#define g_ResourcesNS       g_SystemNS ".Resources"
#define g_DiagnosticsNS     g_SystemNS ".Diagnostics"
#define g_AssembliesNS      g_SystemNS ".Configuration.Assemblies"
#define g_GlobalizationNS   g_SystemNS ".Globalization"
#define g_IsolatedStorageNS g_SystemNS ".IO.IsolatedStorage"
#define g_TextNS            g_SystemNS ".Text"    

#define g_ReflectionNS      g_SystemNS ".Reflection"
#define g_ReflectionEmitNS  g_ReflectionNS ".Emit"

#define g_InteropNS         g_RuntimeNS ".InteropServices"
#define g_InteropTCENS      g_InteropNS ".TCEAdapterGen"
#define g_ExpandoNS         g_InteropNS ".Expando"

#define g_SecurityNS        g_SystemNS ".Security"
#define g_UtilNS            g_SecurityNS ".Util"
#define g_PublicKeyNS       g_SecurityNS ".PublicKey"
#define g_PermissionsNS     g_SecurityNS ".Permissions"
#define g_CryptographyNS    g_SecurityNS ".Cryptography"
#define g_PrincipalNS       g_SecurityNS ".Principal"
#define g_PolicyNS          g_SecurityNS ".Policy"
#define g_X509NS            g_CryptographyNS ".X509Certificates"

#define g_SerializationNS   g_RuntimeNS ".Serialization"
#define g_RemotingNS        g_RuntimeNS ".Remoting"
#define g_ActivationNS      g_RemotingNS ".Activation"
#define g_ProxiesNS         g_RemotingNS ".Proxies"
#define g_ContextsNS        g_RemotingNS ".Contexts"
#define g_MessagingNS       g_RemotingNS ".Messaging"
#define g_RemotingServicesNS g_RemotingNS ".Services"

#define g_MicrosoftNS       "Microsoft"

#define g_Win32NS           g_MicrosoftNS ".Win32"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\mtypes.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// MTYPES.H -
//
// Defines the mapping between MARSHAL_TYPE constants and their Marshaler
// classes. Used to generate all the enums and tables.
//





DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_GENERIC_1,   CopyMarshaler1)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_GENERIC_U1,  CopyMarshalerU1)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_GENERIC_2,   CopyMarshaler2)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_GENERIC_U2,  CopyMarshalerU2)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_GENERIC_4,   CopyMarshaler4)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_GENERIC_8,   CopyMarshaler8)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_WINBOOL,     WinBoolMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_VTBOOL,      VtBoolMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_ANSICHAR,    AnsiCharMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_CBOOL,       CBoolMarshaler)


DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_FLOAT,       FloatMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_DOUBLE,      DoubleMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_CURRENCY,    CurrencyMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_DECIMAL,     DecimalMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_DECIMAL_PTR, DecimalPtrMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_GUID,        GuidMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_GUID_PTR,    GuidPtrMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_DATE,        DateMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_VARIANT,     VariantMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_BSTR,        BSTRMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_LPWSTR,      WSTRMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_LPSTR,       CSTRMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_ANSIBSTR,    AnsiBSTRMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_BSTR_BUFFER, BSTRBufferMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_LPWSTR_BUFFER, WSTRBufferMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_LPSTR_BUFFER,  CSTRBufferMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_BSTR_X,        BSTRMarshalerEx)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_LPWSTR_X,      WSTRMarshalerEx)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_LPSTR_X,       CSTRMarshalerEx)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_BSTR_BUFFER_X, BSTRBufferMarshalerEx)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_LPWSTR_BUFFER_X, WSTRBufferMarshalerEx)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_LPSTR_BUFFER_X,  CSTRBufferMarshalerEx)


DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_INTERFACE,   InterfaceMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_SAFEARRAY,   SafeArrayMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_NATIVEARRAY, NativeArrayMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_ASANYA,      AsAnyAMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_ASANYW,      AsAnyWMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_DELEGATE,    DelegateMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_BLITTABLEPTR,BlittablePtrMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_VBBYVALSTR,  VBByValStrMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_VBBYVALSTRW, VBByValStrWMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_LAYOUTCLASSPTR, LayoutClassPtrMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_ARRAYWITHOFFSET,  ArrayWithOffsetMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_BLITTABLEVALUECLASS, BlittableValueClassMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_VALUECLASS,  ValueClassMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_REFERENCECUSTOMMARSHALER,  ReferenceCustomMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_VALUECLASSCUSTOMMARSHALER,  ValueClassCustomMarshaler)
DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_ARGITERATOR, ArgIteratorMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_BLITTABLEVALUECLASSWITHCOPYCTOR, BlittableValueClassWithCopyCtorMarshaler) 

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_OBJECT, ObjectMarshaler)


DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_HANDLEREF, HandleRefMarshaler)

DEFINE_MARSHALER_TYPE(MARSHAL_TYPE_OLECOLOR, OleColorMarshaler)


#undef DEFINE_MARSHALER_TYPE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ndphlpr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*******************************************************************************
//
//  (C)
//
//  TITLE:       NDPHLPR.H
//
//  AUTHOR:      Frank Peschel-Gallee (minor updates for NDP by Rudi Martin)
//
//  DATE:        20 January 1997
//
********************************************************************************/

#ifndef _NDPHLPR_
#define _NDPHLPR_

// Dev IO command definitions
#define NDPHLPR_Init                    0x86427531
#define NDPHLPR_GetThreadContext        0x86421357
#define NDPHLPR_SetThreadContext        0x8642135A

// Dev IO special error return (thread context not in win32 space)
#define NDPHLPR_BadContext              0x4647

// Current version number (returned by NDPHLPR_Init)
#define NDPHLPR_Version                 0x40

// Dev IO packet for Set/GetThreadContext
typedef struct {
    unsigned NDPHLPR_status;    // reserved for driver
    unsigned NDPHLPR_data;      // reserved for driver
    unsigned NDPHLPR_threadId;  // target thread
    CONTEXT  NDPHLPR_ctx;       // win32 context
} NDPHLPR_CONTEXT, *PNDPHLPR_CONTEXT;

// Device name in Win32 space
#define NDPHLPR_DEVNAME "\\\\.\\NDPHLPR.VXD"

#endif //ifndef _NDPHLPR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\nexport.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"


#include "threads.h"
#include "excep.h"
#include "object.h"
#include "nexport.h"
#include "mlgen.h"
#include "ml.h"
#include "mlinfo.h"
#include "mlcache.h"
#include "comdelegate.h"
#include "ceeload.h"
#include "utsem.h"
#include "eeconfig.h"
#include "DbgInterface.h"
#include "tls.h"

#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"
#endif


UMEntryThunk* UMEntryThunk::CreateUMEntryThunk()
{
    void *p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(UMEntryThunk));
    if (p == NULL) FailFast(GetThread(), FatalOutOfMemory);
    return (UMEntryThunk *)new (p) UMEntryThunk;
}

VOID UMEntryThunk::FreeUMEntryThunk(UMEntryThunk* p)
{
#ifdef CUSTOMER_CHECKED_BUILD
    
    CustomerDebugHelper* pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_CollectedDelegate))
    {
        // Intentional memory leak to allow debugging
        p->m_pManagedTarget     = NULL;
        p->m_pUMThunkMarshInfo  = NULL;
        if (p->GetObjectHandle())
        {
            DestroyLongWeakHandle(p->GetObjectHandle());
        }
    }
    else 
    {
        delete p;
        HeapFree(GetProcessHeap(), 0, p);
    }

#else

    delete p;
    HeapFree(GetProcessHeap(), 0, p);

#endif //CUSTOMER_CHECKED_BUILD
}
        
struct UM2MThunk_Args {
    UMEntryThunk *pEntryThunk;
    void *pAddr;
    void *pThunkArgs;
    int argLen;
    void *retVal;
};

// This is used as target of callback from DoADCallBack. It sets up the environment and effectively
// calls back into the thunk that needed to switch ADs. 
void UM2MThunk_Wrapper(UM2MThunk_Args *pArgs)
{
    Thread* pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());
    UMEntryThunk *pEntryThunk = pArgs->pEntryThunk;
    void *pAddr = pArgs->pAddr;
    void *retVal;
    // copy the args to the stack, they will be released when we return from the thunk
    // because we are coming from unmanaged to managed, any objectref args must have already
    // been pinned so don't have to worry about them moving in the copy we make.
    void *argDest = alloca(pArgs->argLen);
    memcpy(argDest, pArgs->pThunkArgs, pArgs->argLen);
    __asm {
        mov eax, pEntryThunk
        mov ecx, pThread
        call pAddr
        mov retVal, eax
    }

    pArgs->retVal = retVal;

    // We made the call in cooperative mode, but the epilog will return us to preemptive
    // on exit.
    pThread->DisablePreemptiveGC();
}

void * __stdcall UM2MDoADCallBack(UMEntryThunk *pEntryThunk, void *pAddr, void *pArgs, int argLen)
{
    THROWSCOMPLUSEXCEPTION();

    UM2MThunk_Args args = { pEntryThunk, pAddr, pArgs, argLen };
    AppDomain *pTgtDomain = SystemDomain::System()->GetAppDomainAtId(pEntryThunk->GetDomainId());
    if (!pTgtDomain)
        COMPlusThrow(kAppDomainUnloadedException);

    GetThread()->DoADCallBack(pTgtDomain->GetDefaultContext(), UM2MThunk_Wrapper, &args);
    return args.retVal;
}

// Makes actual method call. This is somewhat complicated due to the need
// to accomodate jitting, backpatching, code pitching, etc.
//
// Assumes SCRATCH points to UMEntryThunk. No other registers are trashed.
VOID UMEntryThunk::EmitUMEntryThunkCall(CPUSTUBLINKER *psl)
{
    THROWSCOMPLUSEXCEPTION();

#ifdef _X86_

    CodeLabel *pDoMethodLessCall = psl->NewCodeLabel();
    CodeLabel *pDone             = psl->NewCodeLabel();

    // cmp dword ptr [SCRATCH+UMEntryThunk.m_pManagedTarget],0
    psl->X86EmitOp(0x81, (X86Reg)7, SCRATCH_REGISTER_X86REG, offsetof(UMEntryThunk, m_pManagedTarget));
    psl->Emit32(0);

    // jnz DoMethodLessCall
    psl->X86EmitCondJump(pDoMethodLessCall, X86CondCode::kJNZ);


    // mov SCRATCH, [SCRATCH + UMENTRYTHUNK.m_pMD]
    psl->X86EmitOp(0x8b, SCRATCH_REGISTER_X86REG, SCRATCH_REGISTER_X86REG, offsetof(UMEntryThunk, m_pMD));

    // lea SCRATCH, [SCRATCH - METHOD_CALL_PRESTUB_SIZE]
    psl->X86EmitOp(0x8d, SCRATCH_REGISTER_X86REG, SCRATCH_REGISTER_X86REG, 0 - METHOD_CALL_PRESTUB_SIZE);
    
    // call eax
    psl->X86EmitR2ROp(0xff, (X86Reg)2, SCRATCH_REGISTER_X86REG);
    INDEBUG(psl->Emit8(0x90));          // Emit a NOP so we know that we can call managed code

    // jmp done
    psl->X86EmitNearJump(pDone);

    
    psl->EmitLabel(pDoMethodLessCall);
    // call [SCRATCH+UMEntryThunk.m_pManagedTarget]
    psl->X86EmitOp(0xff, (X86Reg)2, SCRATCH_REGISTER_X86REG, offsetof(UMEntryThunk, m_pManagedTarget));
    INDEBUG(psl->Emit8(0x90));          // Emit a NOP so we know that we can call managed code

    // DONE:
    psl->EmitLabel(pDone);

#else
    _ASSERTE(!"NYI X86");
#endif
}



static class UMThunkStubCache *g_pUMThunkStubCache = NULL;
static class ArgBasedStubRetainer *g_pUMThunkInterpretedStubCache;


#ifdef _X86_

extern VOID UMThunkStubRareDisableWorker(Thread *pThread, UMEntryThunk *pUMEntryThunk, Frame *pFrame);

//
// @todo: this is very similar to StubRareDisable in cgenx86.cpp.
//
__declspec(naked)
static VOID __cdecl UMThunkStubRareDisable()
{
    __asm
    {
        push eax
        push ecx

        push esi  // Push frame
        push eax  // Push the UMEntryThunk
        push ecx  // Push thread
        call UMThunkStubRareDisableWorker

        pop  ecx
        pop  eax
        retn
    }
}


#endif // _X86_

EXCEPTION_DISPOSITION __cdecl FastNExportExceptHandler(EXCEPTION_RECORD *pExceptionRecord, 
                         EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                         CONTEXT *pContext,
                         void *pDispatcherContext)
{
    // We have our own handler here to work around a debug build check where excep.cpp
    // asserts that a buffer of sentinel values below the SEH frame hasn't been overwritten
    // Having our own handler may also come in handy for future flexibility.
    return  COMPlusFrameHandler(pExceptionRecord, pEstablisherFrame, pContext, pDispatcherContext);
}

BOOL FastNExportSEH(EXCEPTION_REGISTRATION_RECORD* pEHR)
{
    if (pEHR->Handler == FastNExportExceptHandler)
        return TRUE;
    return FALSE;
}

EXCEPTION_DISPOSITION __cdecl NExportExceptHandler(EXCEPTION_RECORD *pExceptionRecord, 
                         EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                         CONTEXT *pContext,
                         void *pDispatcherContext)
{
    // We have our own handler here to work around a debug build check where excep.cpp
    // asserts that a buffer of sentinel values below the SEH frame hasn't been overwritten
    // Having our own handler may also come in handy for future flexibility.
    return  COMPlusFrameHandler(pExceptionRecord, pEstablisherFrame, pContext, pDispatcherContext);
}

// Just like a regular NExport handler -- except it pops an extra frame on unwind.  A handler
// like this is needed by the COMMethodStubProlog code.  It first pushes a frame -- and then
// pushes a handler.  When we unwind, we need to pop the extra frame to avoid corrupting the
// frame chain in the event of an unmanaged catcher.
// 
EXCEPTION_DISPOSITION __cdecl UMThunkPrestubHandler(EXCEPTION_RECORD *pExceptionRecord, 
                         EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                         CONTEXT *pContext,
                         void *pDispatcherContext)
{
    EXCEPTION_DISPOSITION result = COMPlusFrameHandler(pExceptionRecord, pEstablisherFrame, pContext, pDispatcherContext);
    if (IS_UNWINDING(pExceptionRecord->ExceptionFlags)) {

        // Pops an extra frame on unwind.
        //

        BEGIN_ENSURE_COOPERATIVE_GC();        // Must be cooperative to modify frame chain.

        Thread *pThread = GetThread();
        _ASSERTE(pThread);
        Frame *pFrame = pThread->GetFrame();
        pFrame->ExceptionUnwind();
        pFrame->Pop(pThread);
        END_ENSURE_COOPERATIVE_GC();
    }
    return result;
}

BOOL NExportSEH(EXCEPTION_REGISTRATION_RECORD* pEHR)
{
    if (   pEHR->Handler == NExportExceptHandler
        || pEHR->Handler == UMThunkPrestubHandler)
        return TRUE;
    return FALSE;
}

#ifdef _DEBUG
void LogUMTransition(UMEntryThunk* thunk) 
{
    void** retESP = ((void**) &thunk) + 4;

    MethodDesc* method = thunk->GetMethod();
    if (method)
    {
        LOG((LF_STUBS, LL_INFO10000, "UNMANAGED -> MANAGED Stub To Method = %s::%s SIG %s Ret Address ESP = 0x%x ret = 0x%x\n", 
            method->m_pszDebugClassName,
            method->m_pszDebugMethodName,
            method->m_pszDebugMethodSignature, retESP, *retESP));
    }

    if(GetThread() != NULL)
        _ASSERTE(!GetThread()->PreemptiveGCDisabled());
}
#endif

//--------------------------------------------------------------------------
// Cache ML & compiled stubs for UMThunks.
//--------------------------------------------------------------------------
class UMThunkStubCache : public MLStubCache
{
    private:
        virtual MLStubCompilationMode CompileMLStub(const BYTE *pRawMLStub,
                                                    StubLinker *psl,
                                                    void *callerContext)
        {
            THROWSCOMPLUSEXCEPTION();

#ifndef _X86_
            return INTERPRETED;
#else

            UMThunkMLStub *pheader = (UMThunkMLStub *)pRawMLStub;
            CPUSTUBLINKER *pcpusl = (CPUSTUBLINKER*)psl;
            UINT           psrcofsregs[NUM_ARGUMENT_REGISTERS];
            UINT          *psrcofs = (UINT*)_alloca(sizeof(UINT) * (pheader->m_cbDstStack/STACK_ELEM_SIZE));



#ifdef _DEBUG
            if (LoggingEnabled() && (g_pConfig->GetConfigDWORD(L"LogFacility",0) & LF_IJW))
            {
               return INTERPRETED;
            }
#endif
            if (pheader->m_fpu)
            {
                return INTERPRETED;
            }

            // Always use the slow stubs if a debugger is attached. This provides for optimal stepping and stack tracing
            // behavior, since these optimized stubs don't push nice Frame objects like the debugger needs.
            //
            // @todo: we need to revisit this in V2. There may be better solutions than this to solve our interop stack
            // tracing problems. -- mikemag Tue May 08 16:07:31 2001
            if (CORDebuggerAttached())
                return INTERPRETED;

#ifdef CUSTOMER_CHECKED_BUILD

            CustomerDebugHelper* pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
            if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_CollectedDelegate))
                return INTERPRETED;
#endif

#ifdef _DEBUG
            pcpusl->X86EmitPushReg(kEAX);
            pcpusl->X86EmitPushReg(kECX);
            pcpusl->X86EmitPushReg(kEDX);
            
            pcpusl->X86EmitPushReg(kEAX);
            pcpusl->X86EmitCall(pcpusl->NewExternalCodeLabel(LogUMTransition), 4);
            
            pcpusl->X86EmitPopReg(kEDX);
            pcpusl->X86EmitPopReg(kECX);
            pcpusl->X86EmitPopReg(kEAX);
#endif
            for (int i = 0; i < NUM_ARGUMENT_REGISTERS; i++)
            {
                psrcofsregs[i] = (UINT)(-1);
            }
            {
                const MLCode  *pMLCode = pheader->GetMLCode();


                MLCode opcode;
                int    dstofs = 0;
                int    srcofs = 0;
                while ((opcode = *(pMLCode++)) != ML_INTERRUPT)
                {
                    switch (opcode)
                    {
                        case ML_COPY4:
                            dstofs -= StackElemSize(4);
                            if (dstofs > 0)
                            {
                                psrcofs[(dstofs - sizeof(FramedMethodFrame))/STACK_ELEM_SIZE] = srcofs;
                            }
                            else
                            {
                                psrcofsregs[ (dstofs - FramedMethodFrame::GetOffsetOfArgumentRegisters()) / STACK_ELEM_SIZE ] = srcofs;
                            }
                            srcofs += MLParmSize(4);
                            break;
                        case ML_BUMPDST:
                            dstofs += *( ((INT16*&)pMLCode)++ );
                            break;
                        default:
                            return INTERPRETED;
                    }
                }

                if (pMLCode[0] == ML_END ||
                    (pMLCode[0] == ML_COPY4 && pMLCode[1] == ML_END))
                {
                    // continue onward
                }
                else
                {
                    return INTERPRETED;
                }
            }

            {

                CodeLabel* pSetupThreadLabel    = pcpusl->NewCodeLabel();
                CodeLabel* pRejoinThreadLabel   = pcpusl->NewCodeLabel();
                CodeLabel* pDisableGCLabel      = pcpusl->NewCodeLabel();
                CodeLabel* pRejoinGCLabel       = pcpusl->NewCodeLabel();
                CodeLabel* pDoADCallBackLabel = pcpusl->NewCodeLabel();
                CodeLabel* pDoneADCallBackLabel = pcpusl->NewCodeLabel();
                CodeLabel* pDoADCallBackTargetLabel = pcpusl->NewAbsoluteCodeLabel();
                CodeLabel* pDoADCallBackStartLabel = pcpusl->NewCodeLabel();

                if (!(pSetupThreadLabel || pRejoinThreadLabel || pDisableGCLabel
                    || pRejoinGCLabel || pDoADCallBackLabel || pDoneADCallBackLabel
                    || pDoADCallBackTargetLabel || pDoADCallBackStartLabel))
                {
                    // oops out of memory
                    COMPlusThrowOM();
                }

                // We come into this code with UMEntryThunk in EAX

                if (pheader->m_fThisCall)
                {
                    if (pheader->m_fThisCallHiddenArg)
                    {
                        // pop off the return address
                        pcpusl->X86EmitPopReg(kEDX);

                        // exchange ecx (this "this") with the hidden structure return buffer
                        //  xchg ecx, [esp]
                        pcpusl->X86EmitOp(0x87, kECX, (X86Reg)4 /*ESP*/);

                        // push ecx
                        pcpusl->X86EmitPushReg(kECX);

                        // push edx
                        pcpusl->X86EmitPushReg(kEDX);
                    }
                    else
                    {
                        // pop off the return address
                        pcpusl->X86EmitPopReg(kEDX);

                        // jam ecx (the "this" param onto stack. Now it looks like a normal stdcall.)
                        pcpusl->X86EmitPushReg(kECX);

                        // repush
                        pcpusl->X86EmitPushReg(kEDX);
                    }
                }


                // Load thread descriptor into ECX
                pcpusl->X86EmitTLSFetch(GetThreadTLSIndex(), kECX, (1<<kEAX)|(1<<kEDX));

                // test ecx,ecx
                pcpusl->Emit16(0xc985);

                // jz SetupThread
                pcpusl->X86EmitCondJump(pSetupThreadLabel, X86CondCode::kJZ);
                pcpusl->EmitLabel(pRejoinThreadLabel);

#ifdef PROFILING_SUPPORTED
                // Notify profiler of transition into runtime, before we disable preemptive GC
                if (CORProfilerTrackTransitions())
                {
                    // Save EBX and use it to hold on to the MethodDesc
                    pcpusl->X86EmitPushReg(kEBX);

                    // Load the methoddesc into EBX (UMEntryThunk->m_pMD)
                    pcpusl->X86EmitIndexRegLoad(kEBX, kEAX, UMEntryThunk::GetOffsetOfMethodDesc());

                    // Save registers
                    pcpusl->X86EmitPushReg(kEAX);
                    pcpusl->X86EmitPushReg(kECX);
                    pcpusl->X86EmitPushReg(kEDX);

                    // Push arguments and notify profiler
                    pcpusl->X86EmitPushImm32(COR_PRF_TRANSITION_CALL);    // Reason
                    pcpusl->X86EmitPushReg(kEBX);                         // MethodDesc*
                    pcpusl->X86EmitCall(pcpusl->NewExternalCodeLabel(ProfilerUnmanagedToManagedTransitionMD), 8);

                    // Restore registers
                    pcpusl->X86EmitPopReg(kEDX);
                    pcpusl->X86EmitPopReg(kECX);
                    pcpusl->X86EmitPopReg(kEAX);
                }
#endif // PROFILING_SUPPORTED

                // move byte ptr [ecx + Thread.m_fPreemptiveGCDisabled],1
                pcpusl->X86EmitOffsetModRM(0xc6, (X86Reg)0, kECX, offsetof(Thread, m_fPreemptiveGCDisabled));
                pcpusl->Emit8(1);

                // we load and test g_TrapReturningThreads instead of a cmp instruction as
                // a decoder group optimization for Pentium II and up

                // mov edx,dword ptr g_TrapReturningThreads
                pcpusl->Emit16(0x158b);
                pcpusl->EmitPtr(&g_TrapReturningThreads);

                // test edx,edx
                pcpusl->Emit16(0xd285);

                // jnz DisableGC
                pcpusl->X86EmitCondJump(pDisableGCLabel, X86CondCode::kJNZ);

                pcpusl->EmitLabel(pRejoinGCLabel);

                // It's important that the "restart" after an AppDomain switch will skip
                // the check for g_TrapReturningThreads.  That's because, during shutdown,
                // we can only go through the UMThunkStubRareDisable pathway if we have
                // not yet pushed a frame.  (Once pushed, the frame cannot be popped
                // without coordinating with the GC.  During shutdown, such coordination
                // would deadlock).
                pcpusl->EmitLabel(pDoADCallBackStartLabel);

                // push [ECX]Thread.m_pFrame
                pcpusl->X86EmitOffsetModRM(0xff, (X86Reg)6, kECX, offsetof(Thread, m_pFrame));                
                // push offset FastNExportExceptHandler
                pcpusl->X86EmitPushImm32((INT32)(size_t)FastNExportExceptHandler);

                // push fs:[0]
                static BYTE codeSEH1[] = { 0x64, 0xFF, 0x35, 0x0, 0x0, 0x0, 0x0};
                pcpusl->EmitBytes(codeSEH1, sizeof(codeSEH1));

                // link in the exception frame 
                // mov dword ptr fs:[0], esp
                static BYTE codeSEH2[] = { 0x64, 0x89, 0x25, 0x0, 0x0, 0x0, 0x0};
                pcpusl->EmitBytes(codeSEH2, sizeof(codeSEH2));

                // save the thread pointer
                pcpusl->X86EmitPushReg(kECX);

                // Load pThread->m_pDomain into edx
                // mov edx,[ecx + offsetof(Thread, m_pAppDomain)]
                pcpusl->X86EmitIndexRegLoad(kEDX, kECX, Thread::GetOffsetOfAppDomain());

                // Load pThread->m_pAppDomain->m_dwId into edx
                // mov edx,[edx + offsetof(AppDomain, m_dwId)]
                pcpusl->X86EmitIndexRegLoad(kEDX, kEDX, AppDomain::GetOffsetOfId());

                // check if the app domain of the thread matches that of delegate
                // cmp edx,[eax + offsetof(UMEntryThunk, m_dwDomainId))]
                pcpusl->X86EmitOffsetModRM(0x3b, kEDX, kEAX, offsetof(UMEntryThunk, m_dwDomainId));

                // jne pWrongAppDomain ; mismatch. This will call back into the stub with the
                // correct AppDomain through DoADCallBack
                pcpusl->X86EmitCondJump(pDoADCallBackLabel, X86CondCode::kJNE);

                // repush any stack arguments
                int i = pheader->m_cbDstStack/STACK_ELEM_SIZE;
                // return address + thread + exception frame + (optionally) the saved MethodDesc*
                int argStartOfs = 4 + 4 + 12 +
#ifdef PROFILING_SUPPORTED
                                (CORProfilerTrackTransitions() ? 4 : 
#endif // PROFILING_SUPPORTED
                                0);
                int argOfs = argStartOfs;

                while (i--)
                {
                    // push dword ptr [esp + ofs]
                    pcpusl->X86EmitEspOffset(0xff, (X86Reg)6, argOfs + psrcofs[i]);
                    argOfs += 4;
                }

                // load register arguments
                int regidx = 0;
#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname) \
                if (psrcofsregs[regidx] != (UINT)(-1)) \
                { \
                    pcpusl->X86EmitEspOffset(0x8b, k##regname, argOfs + psrcofsregs[regidx]); \
                } \
                regidx++; 

#include "eecallconv.h"

                // load this
                if (!(pheader->m_fIsStatic))
                {
                    // mov THIS, [EAX + UMEntryThunk.m_pObjectHandle]
                    pcpusl->X86EmitOp(0x8b, THIS_kREG, kEAX, offsetof(UMEntryThunk, m_pObjectHandle));

                    // mov THIS, [THIS]
                    pcpusl->X86EmitOp(0x8b, THIS_kREG, THIS_kREG);
                }

                UMEntryThunk::EmitUMEntryThunkCall(pcpusl);

                // restore the thread pointer
                pcpusl->X86EmitPopReg(kECX);

                // move byte ptr [ecx + Thread.m_fPreemptiveGCDisabled],0
                pcpusl->X86EmitOffsetModRM(0xc6, (X86Reg)0, kECX, offsetof(Thread, m_fPreemptiveGCDisabled));
                pcpusl->Emit8(0);

                pcpusl->EmitLabel(pDoneADCallBackLabel);

                // *** unhook SEH frame
                // mov edx,[esp]  ;;pointer to the next exception record
                pcpusl->X86EmitEspOffset(0x8B, kEDX, 0);

                // mov dword ptr fs:[0], edx
                static BYTE codeSEH[] = { 0x64, 0x89, 0x15, 0x0, 0x0, 0x0, 0x0 };
                pcpusl->EmitBytes(codeSEH, sizeof(codeSEH));

                // deallocate SEH frame
                pcpusl->X86EmitAddEsp(12);

#ifdef PROFILING_SUPPORTED
                if (CORProfilerTrackTransitions())
                {
                    // if ebx is 0, then we're here on the inner part of the AD transition callback
                    // so don't want to track the transition as aren't leaving.
                    // test ebx,ebx
                    pcpusl->Emit16(0xdb85);

                    // jz SetupThread
                    CodeLabel* pSkipOnInnerADCallback = pcpusl->NewCodeLabel();
                    _ASSERTE(pSkipOnInnerADCallback);
                    pcpusl->X86EmitCondJump(pSkipOnInnerADCallback, X86CondCode::kJZ);

                    // Save registers
                    pcpusl->X86EmitPushReg(kEAX);
                    pcpusl->X86EmitPushReg(kECX);
                    pcpusl->X86EmitPushReg(kEDX);

                    // Push arguments and notify profiler
                    pcpusl->X86EmitPushImm32(COR_PRF_TRANSITION_RETURN);    // Reason
                    pcpusl->X86EmitPushReg(kEBX);                           // MethodDesc*
                    pcpusl->X86EmitCall(pcpusl->NewExternalCodeLabel(ProfilerManagedToUnmanagedTransitionMD), 8);

                    // Restore registers
                    pcpusl->X86EmitPopReg(kEDX);
                    pcpusl->X86EmitPopReg(kECX);
                    pcpusl->X86EmitPopReg(kEAX);

                    pcpusl->EmitLabel(pSkipOnInnerADCallback);

                    // Restore EBX, which was saved in prolog
                    pcpusl->X86EmitPopReg(kEBX);
                }
#endif // PROFILING_SUPPORTED

                //retn n
                pcpusl->X86EmitReturn(pheader->m_cbRetPop);

                // coming here if the thread is not set up yet
                pcpusl->EmitLabel(pSetupThreadLabel);

                // save UMEntryThunk
                pcpusl->X86EmitPushReg(kEAX);

                // call CreateThreadBlock
                pcpusl->X86EmitCall(pcpusl->NewExternalCodeLabel(SetupThread), 0);

                // mov ecx,eax
                pcpusl->Emit16(0xc189);

                // restore UMEntryThunk
                pcpusl->X86EmitPopReg(kEAX);

                // jump back into the main code path
                pcpusl->X86EmitNearJump(pRejoinThreadLabel);


                // coming here if g_TrapReturningThreads was true
                pcpusl->EmitLabel(pDisableGCLabel);

                // call UMThunkStubRareDisable.  This may throw if we are not allowed
                // to enter.  Note that we have not set up our SEH yet (deliberately).
                // This is important to handle the case where we cannot enter the CLR
                // during shutdown and cannot coordinate with the GC because of
                // deadlocks.
                pcpusl->X86EmitCall(pcpusl->NewExternalCodeLabel(UMThunkStubRareDisable), 0);

                // jump back into the main code path
                pcpusl->X86EmitNearJump(pRejoinGCLabel);

                // coming here if appdomain didn't match
                pcpusl->EmitLabel(pDoADCallBackLabel);
                                
                // we will call DoADCallBack which calls into managed code to switch ADs and then calls us
                // back. So when come in the second time the ADs will match and just keep processing.
                // So we need to setup the parms to pass to DoADCallBack one of which is an address inside
                // the stub that will branch back to the top of the stub to start again. Need to setup
                // the parms etc so that when we return from the 2nd call we pop things properly.

                // push values for UM2MThunk_Args

                // mov edx, esp ; get stack pointer
                pcpusl->Emit16(0xD48b);
               
                // push address of args
                pcpusl->X86EmitAddReg(kEDX, argStartOfs);    

                // size of args
                pcpusl->X86EmitPushImm32(pheader->m_cbSrcStack);

                // address of args
                pcpusl->X86EmitPushReg(kEDX);
                
                // addr to call
                pcpusl->X86EmitPushImm32(*pDoADCallBackTargetLabel);

                // UMEntryThunk
                pcpusl->X86EmitPushReg(kEAX);

                // call UM2MDoADCallBack
                pcpusl->X86EmitCall(pcpusl->NewExternalCodeLabel(UM2MDoADCallBack), 8);

                // restore the thread pointer
                pcpusl->X86EmitPopReg(kECX);

                // move byte ptr [ecx + Thread.m_fPreemptiveGCDisabled],0
                pcpusl->X86EmitOffsetModRM(0xc6, (X86Reg)0, kECX, offsetof(Thread, m_fPreemptiveGCDisabled));
                pcpusl->Emit8(0);

                // return to mainline of function
                pcpusl->X86EmitNearJump(pDoneADCallBackLabel);

                // coming here on DoADCallBack
                pcpusl->EmitLabel(pDoADCallBackTargetLabel);

                if (CORProfilerTrackTransitions())
                {
                    // Save EBX and set it to null so know that when return
                    // we should not track profiler call - leave it until the outer return
                    // code assumes that EBX has been saved already anyway
                    pcpusl->X86EmitPushReg(kEBX);
                    // xor ebx, ebx
                    pcpusl->Emit16(0xDB33);
                }

                // eax will contain the UMThunkEntry
                pcpusl->X86EmitNearJump(pDoADCallBackStartLabel);
            }

            return STANDALONE;
#endif
        }
        
        virtual UINT Length(const BYTE *pRawMLStub)
        {
            UMThunkMLStub *pmlstub = (UMThunkMLStub *)pRawMLStub;
            return sizeof(UMThunkMLStub) + MLStreamLength(pmlstub->GetMLCode());
        }
        
};




//-------------------------------------------------------------------------
// One-time creation of special prestub to initialize UMEntryThunks.
//-------------------------------------------------------------------------
Stub *GenerateUMThunkPrestub()
{
    THROWSCOMPLUSEXCEPTION();

    CPUSTUBLINKER sl;
#ifdef _X86_
    CodeLabel* rgRareLabels[] = { sl.NewCodeLabel(),
                                  sl.NewCodeLabel(),
                                  sl.NewCodeLabel()
                                };


    CodeLabel* rgRejoinLabels[] = { sl.NewCodeLabel(),
                                    sl.NewCodeLabel(),
                                    sl.NewCodeLabel()
                                };


    CodeLabel *pWrapLabel = sl.NewCodeLabel();

    //    push eax   // push UMEntryThunk
    sl.X86EmitPushReg(kEAX);

    //    push ecx      (in case this is a _thiscall: need to protect this register)
    sl.X86EmitPushReg(kECX);

    // Wrap puts a fake return address and a duplicate copy
    // of pUMEntryThunk on the stack, then falls thru to the regular
    // stub prolog. The stub prolog is fooled into thinkin this duplicate
    // copy is the real return address and UMEntryThunk.
    //
    //    call wrap. 
    sl.X86EmitCall(pWrapLabel, 0);


    //    pop  ecx
    sl.X86EmitPopReg(kECX);

    // Now we've executed the prestub and fixed up UMEntryThunk. The
    // duplicate data has been popped off.
    //
    //    pop eax   // pop UMEntryThunk
    sl.X86EmitPopReg(kEAX);

    //    lea eax, [eax + UMEntryThunk.m_code]  // point to fixedup UMEntryThunk
    sl.X86EmitOp(0x8d, kEAX, kEAX, offsetof(UMEntryThunk, m_code));

    //    jmp eax //reexecute!
    sl.X86EmitR2ROp(0xff, (X86Reg)4, kEAX);

    sl.EmitLabel(pWrapLabel);

    // Wrap:
    //
    //   push [esp+8]  //repush UMEntryThunk
    sl.X86EmitEspOffset(0xff, (X86Reg)6, 8);

    // emit the initial prolog
    sl.EmitComMethodStubProlog(UMThkCallFrame::GetUMThkCallFrameVPtr(), rgRareLabels, rgRejoinLabels,
                               UMThunkPrestubHandler, FALSE /*Don't profile*/);

    // mov ecx, [esi+UMThkCallFrame.pUMEntryThunk]
    sl.X86EmitIndexRegLoad(kECX, kESI, UMThkCallFrame::GetOffsetOfUMEntryThunk());


    VOID (UMEntryThunk::*dummy)() = UMEntryThunk::RunTimeInit;

    // call UMEntryThunk::RuntimeInit
    sl.X86EmitCall(sl.NewExternalCodeLabel(*(LPVOID*)&dummy), 0);

    sl.EmitComMethodStubEpilog(UMThkCallFrame::GetUMThkCallFrameVPtr(), 0, rgRareLabels, rgRejoinLabels,
                               UMThunkPrestubHandler, FALSE /*Don't profile*/);

#else
    _ASSERTE(!"NYI");
#endif

    return sl.Link();
}

struct DoUMThunkCall_Args {
    Thread *pThread;
    UMThkCallFrame *pFrame;
    INT64 *retVal;
};

INT64 __stdcall DoUMThunkCall(Thread *pThread, UMThkCallFrame *pFrame);
void DoUMThunkCall_Wrapper(DoUMThunkCall_Args *args)
{
    EE_TRY_FOR_FINALLY
    {
        *(args->retVal) = DoUMThunkCall(args->pThread, args->pFrame);
    }
    EE_FINALLY
    {
        // in non-exception case, this will have already been cleaned up
        // at the end of the DoUMThunkCall function. This will handle
        // cleanup for the exception case so that we get cleaned up before
        // we leave the domain.
        _ASSERTE(args->pFrame->GetCleanupWorkList());
        args->pFrame->GetCleanupWorkList()->Cleanup(GOT_EXCEPTION());
    }
    EE_END_FINALLY;
}

//--------------------------------------------------------------------------
// For non-compiled UMThunk calls, this C routine does most of the work.
//--------------------------------------------------------------------------
INT64 __stdcall DoUMThunkCall(Thread *pThread, UMThkCallFrame *pFrame)
{
    _ASSERTE (pThread->PreemptiveGCDisabled());
    
    THROWSCOMPLUSEXCEPTION();

    INT64                   nativeRetVal = 0;
    const UMEntryThunk     *pUMEntryThunk = pFrame->GetUMEntryThunk();
    const UMThunkMarshInfo *pUMThunkMarshInfo = pUMEntryThunk->GetUMThunkMarshInfo();

#ifdef CUSTOMER_CHECKED_BUILD

    CustomerDebugHelper* pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_CollectedDelegate))
    {
        if (pUMEntryThunk->DeadTarget() && pUMThunkMarshInfo == NULL)
        {
            static WCHAR strMessageFormat[] = 
                {L"Unmanaged callback to garbage collected delegate: %s"};

            CQuickArray<WCHAR> strMessage;
            strMessage.Alloc(MAX_CLASSNAME_LENGTH + lengthof(strMessageFormat));

            DefineFullyQualifiedNameForClassW();
            GetFullyQualifiedNameForClassW(pUMEntryThunk->GetMethod()->GetClass());

            Wszwsprintf((LPWSTR)strMessage.Ptr(), strMessageFormat, _wszclsname_);
            pCdh->ReportError((LPWSTR)strMessage.Ptr(), CustomerCheckedBuildProbe_CollectedDelegate);
        }
    }

#endif

    // verify we are in the correct app domain

    _ASSERTE(pThread);
    
    AppDomain *pTargetDomain = SystemDomain::System()->GetAppDomainAtId(pUMEntryThunk->GetDomainId());
    if (!pTargetDomain)
        COMPlusThrow(kAppDomainUnloadedException);
    if (pThread->GetDomain() != pTargetDomain) 
    {
        DoUMThunkCall_Args args = {pThread, pFrame, &nativeRetVal};
        // call ourselves again through DoCallBack with a domain transition
        pThread->DoADCallBack(pTargetDomain->GetDefaultContext(), DoUMThunkCall_Wrapper, &args);
        return nativeRetVal;
    }

    CleanupWorkList     *pCleanup     = pFrame->GetCleanupWorkList();

    UMThunkMLStub *pheader = (UMThunkMLStub*)(pUMThunkMarshInfo->GetMLStub()->GetEntryPoint());

    BOOL   fIsStatic = pheader->m_fIsStatic;
    UINT   sizeOfActualArgStack = pUMThunkMarshInfo->GetCbActualArgSize();
    UINT   cbDstBuffer = FramedMethodFrame::GetNegSpaceSize() + sizeof(FramedMethodFrame) + sizeOfActualArgStack;

    UINT cbAlloc = cbDstBuffer + pheader->m_cbLocals;
    BYTE *pAlloc = (BYTE*)_alloca(cbAlloc);
    // Must zero-initialize since pFrame gcscan's part of this array.
    FillMemory(pAlloc, cbAlloc, 0);


    if (pCleanup) {
        // Checkpoint the current thread's fast allocator (used for temporary
        // buffers over the call) and schedule a collapse back to the checkpoint in
        // the cleanup list. Note that if we need the allocator, it is
        // guaranteed that a cleanup list has been allocated.
        void *pCheckpoint = pThread->m_MarshalAlloc.GetCheckpoint();
        pCleanup->ScheduleFastFree(pCheckpoint);
        pCleanup->IsVisibleToGc();
    }

    BYTE *pDst = pAlloc + FramedMethodFrame::GetNegSpaceSize();
    BYTE *pLoc = pAlloc + cbDstBuffer;

    pFrame->SetDstArgsPointer(pDst);

    pFrame->SetGCArgsProtectionState(TRUE);

    const MLCode *pMLCode = pheader->GetMLCode();
    pMLCode = RunML(pMLCode,
                    pFrame->GetPointerToArguments(),
                    pDst,
                    (UINT8*)pLoc,
                    pCleanup);


    if (!fIsStatic) {
        *((OBJECTREF*) (pDst + FramedMethodFrame::GetOffsetOfThis()) ) = ObjectFromHandle(pUMEntryThunk->GetObjectHandle());
    }

    pFrame->SetGCArgsProtectionState(FALSE);

    LOG((LF_IJW, LL_INFO1000, "UM transition to 0x%lx\n", (size_t)(pUMEntryThunk->GetManagedTarget())));;

#ifdef DEBUGGING_SUPPORTED
    // Notify the debugger, if present, that we're calling into
    // managed code.
    if (CORDebuggerTraceCall())
        g_pDebugInterface->TraceCall(pUMEntryThunk->GetManagedTarget());
#endif // DEBUGGING_SUPPORTED


    LPVOID pTarget = (LPVOID)(pUMEntryThunk->GetManagedTarget());
#ifdef _X86_
    INT64 ComPlusRetVal;

    if (pheader->m_cbRetPop == 0) {
        INSTALL_COMPLUS_EXCEPTION_HANDLER();
        ComPlusRetVal = CallVADescrWorker( pDst + sizeof(FramedMethodFrame) + sizeOfActualArgStack,
                                           sizeOfActualArgStack/STACK_ELEM_SIZE,
                                           (ArgumentRegisters*)(pDst + FramedMethodFrame::GetOffsetOfArgumentRegisters()),
                                           pTarget );
        UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
    }
    else
    {
        INSTALL_COMPLUS_EXCEPTION_HANDLER();
        ComPlusRetVal = CallDescrWorker( pDst + sizeof(FramedMethodFrame) + sizeOfActualArgStack,
                                         sizeOfActualArgStack/STACK_ELEM_SIZE,
                                         (ArgumentRegisters*)(pDst + FramedMethodFrame::GetOffsetOfArgumentRegisters()),
                                         pTarget );
        UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
    }

    if (pheader->m_fpu) {
        getFPReturn(pheader->m_cbRetValSize, ComPlusRetVal);
    }

#else
    INT64 ComPlusRetVal = 0;
    _ASSERTE(!"NYI");
#endif


    if (pheader->m_fRetValRequiredGCProtect) {
        GCPROTECT_BEGIN( *(OBJECTREF*)&ComPlusRetVal );
        RunML(pMLCode,
              &ComPlusRetVal,
              (BYTE*)(&nativeRetVal) + pheader->m_cbRetValSize,
              (UINT8*)pLoc,
              NULL);
        GCPROTECT_END();


    } else {
        RunML(pMLCode,
              &ComPlusRetVal,
              (BYTE*)(&nativeRetVal) + pheader->m_cbRetValSize,
              (UINT8*)pLoc,
              NULL);
    }



    pCleanup->Cleanup(FALSE);


    if (pheader->m_fpu) {
        setFPReturn(pheader->m_cbRetValSize, nativeRetVal);
    }

    return nativeRetVal;
}





//---------------------------------------------------------
// Creates a new ML stub for a UMThunk call. Return refcount is 1.
// This Worker() routine is broken out as a separate function
// for purely logistical reasons: our COMPLUS exception mechanism
// can't handle the destructor call for StubLinker so this routine
// has to return the exception as an outparam. 
//---------------------------------------------------------
static Stub * CreateUMThunkMLStubWorker(MLStubLinker *psl,
                                        MLStubLinker *pslPost,
                                        MLStubLinker *pslRet,
                                        PCCOR_SIGNATURE szMetaSig,
                                        Module* pModule,
                                        BOOL    fIsStatic,
                                        BYTE    nltType,
                                        CorPinvokeMap unmgdCallConv,
                                        mdMethodDef mdForNativeTypes,
                                        OBJECTREF *ppException)
{
    Stub* pstub = NULL; // CHANGE, VC6.0
    COMPLUS_TRY {

        MetaSig msig(szMetaSig, pModule);
        MetaSig msig2(szMetaSig, pModule);
        ArgIterator argit(NULL, &msig2, fIsStatic);
        UMThunkMLStub header;

        UINT numargs = msig.NumFixedArgs();


        header.m_cbRetPop    = 0;
        header.m_cbSrcStack  = 0;
        UINT cbDstStack = msig.SizeOfActualFixedArgStack(fIsStatic);
        if (cbDstStack != (UINT16)cbDstStack)
        {
            COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
        }
        header.m_cbDstStack  = (UINT16) cbDstStack;
        header.m_cbLocals    = 0;
        header.m_fIsStatic   = (fIsStatic ? 1 : 0);
        header.m_fThisCall   = (unmgdCallConv == pmCallConvThiscall);
        header.m_fThisCallHiddenArg = 0;
        header.m_fpu         = 0;
        header.m_fRetValRequiredGCProtect = msig.IsObjectRefReturnType() ? 1 : 0;

        if (unmgdCallConv != pmCallConvCdecl &&
            unmgdCallConv != pmCallConvStdcall &&
            unmgdCallConv != pmCallConvThiscall) {
            COMPlusThrow(kNotSupportedException, IDS_INVALID_PINVOKE_CALLCONV);
        }


        // Now, grab the param tokens if any. We'll get NATIVE_TYPE_* and [in,out] information
        // this way.
        IMDInternalImport *pInternalImport = pModule->GetMDImport();

        mdParamDef *params = (mdParamDef*)_alloca( (numargs + 1) * sizeof(mdParamDef));
        CollateParamTokens(pInternalImport, mdForNativeTypes, numargs, params);


        // Emit space for the header. We'll go back and fill it in later.
        psl->MLEmitSpace(sizeof(header));

        int curofs = 0;

        MarshalInfo::MarshalType marshaltype = (MarshalInfo::MarshalType) 0xcccccccc;

        MarshalInfo *pReturnMLInfo = NULL;

        if (msig.GetReturnType() != ELEMENT_TYPE_VOID) {
            MarshalInfo mlinfo(pModule,
                               msig.GetReturnProps(),
                               params[0],
                               MarshalInfo::MARSHAL_SCENARIO_NDIRECT,
                               nltType,
                               0,FALSE,0, TRUE, FALSE
#ifdef CUSTOMER_CHECKED_BUILD
                               ,NULL // wants MethodDesc*
#endif
                               );
            marshaltype = mlinfo.GetMarshalType();
            pReturnMLInfo = &mlinfo;

            if (marshaltype == MarshalInfo::MARSHAL_TYPE_OBJECT)
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_NOVARIANTRETURN);
            }

        }


        if (msig.HasRetBuffArg()) {

            if (marshaltype == MarshalInfo::MARSHAL_TYPE_BLITTABLEVALUECLASS)
            {

                MethodTable *pMT = msig.GetRetTypeHandle().AsMethodTable();
                UINT         managedSize = msig.GetRetTypeHandle().GetSize();
                UINT         unmanagedSize = pMT->GetNativeSize();
    
                if (header.m_fThisCall)
                {
                    header.m_fThisCallHiddenArg = 1;
                }
                
                if (IsManagedValueTypeReturnedByRef(managedSize) && (header.m_fThisCall || IsUnmanagedValueTypeReturnedByRef(unmanagedSize)))
                {
                    int desiredofs = argit.GetRetBuffArgOffset();
                    desiredofs += StackElemSize(sizeof(LPVOID));
                    if (curofs != desiredofs) {
                        psl->MLEmit(ML_BUMPDST);
                        psl->Emit16( (INT16)(desiredofs - curofs) );
                        curofs = desiredofs;
                    }
                    // propagate the hidden retval buffer pointer argument
                    psl->MLEmit(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_N2C);
                    pslPost->MLEmit(ML_MARSHAL_RETVAL_LGBLITTABLEVALUETYPE_N2C_POST);
                    pslPost->Emit16(psl->MLNewLocal(sizeof(LPVOID)));
                    curofs -= StackElemSize(sizeof(LPVOID));
    
                    header.m_cbSrcStack += MLParmSize(sizeof(LPVOID));
            
                }
            }
            else
            {
                COMPlusThrow(kMarshalDirectiveException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
            }
        }

        MarshalInfo *pMarshalInfo = (MarshalInfo*)_alloca(sizeof(MarshalInfo) * numargs);

        CorElementType mtype;
        UINT argidx = 0;
        while (ELEMENT_TYPE_END != (mtype = (msig.NextArg()))) {
            UINT32 comargsize;
            BYTE   type;
            int desiredofs = argit.GetNextOffset(&type, &comargsize);
            desiredofs += StackElemSize(comargsize);
            if (curofs != desiredofs) {
                psl->MLEmit(ML_BUMPDST);
                psl->Emit16( (INT16)(desiredofs - curofs) );
                curofs = desiredofs;
            }
            new (pMarshalInfo + argidx) MarshalInfo(pModule,
                                                    msig.GetArgProps(),
                                                    params[argidx+1],
                                                    MarshalInfo::MARSHAL_SCENARIO_NDIRECT,
                                                    nltType,
                                                    0, TRUE, argidx+1, TRUE, FALSE
#ifdef CUSTOMER_CHECKED_BUILD
                                                    ,NULL // wants MethodDesc*
#endif
                                                    );
            pMarshalInfo[argidx].GenerateArgumentML(psl, pslPost, FALSE);
            header.m_cbSrcStack += pMarshalInfo[argidx].GetNativeArgSize();
            curofs -= StackElemSize(comargsize);
            argidx++;
        }



        if (msig.GetReturnType() != ELEMENT_TYPE_VOID) {
            if (msig.HasRetBuffArg()) {
                if (marshaltype == MarshalInfo::MARSHAL_TYPE_BLITTABLEVALUECLASS)
                {
                    MethodTable *pMT = msig.GetRetTypeHandle().AsMethodTable();
                    UINT         managedSize = msig.GetRetTypeHandle().GetSize();
                    UINT         unmanagedSize = pMT->GetNativeSize();
    
                    if (!(pMT->GetClass()->IsBlittable()))
                    {
                        COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                    }
                    if (IsManagedValueTypeReturnedByRef(managedSize) && (header.m_fThisCall || IsUnmanagedValueTypeReturnedByRef(unmanagedSize)))
                    {
                        header.m_cbRetValSize = MLParmSize(sizeof(LPVOID));
                        // do nothing here: we propagated the hidden pointer argument above
                    } 
                    else if (IsManagedValueTypeReturnedByRef(managedSize) &&    !(header.m_fThisCall || IsUnmanagedValueTypeReturnedByRef(unmanagedSize)))
                    {
                        int desiredofs = argit.GetRetBuffArgOffset();
                        desiredofs += StackElemSize(sizeof(LPVOID));
                        if (curofs != desiredofs) {
                            psl->MLEmit(ML_BUMPDST);
                            psl->Emit16( (INT16)(desiredofs - curofs) );
                            curofs = desiredofs;
                        }
                        // Push a return buffer large enough to hold the largest possible valuetype returned as
                        // a normal return value.
                        psl->MLEmit(ML_PUSHRETVALBUFFER8);
                        _ASSERTE(managedSize <= 8);
                        curofs -= StackElemSize(sizeof(LPVOID));
    
                        pslPost->MLEmit(ML_MARSHAL_RETVAL_SMBLITTABLEVALUETYPE_N2C);
                        pslPost->Emit32(managedSize);
                        pslPost->Emit16(psl->MLNewLocal(8));
    
                        header.m_cbRetValSize = MLParmSize(unmanagedSize);
                    
                    }
                    else
                    {
                        COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                    }
                } else {
                    COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                }

            } else {
                pReturnMLInfo->GenerateReturnML(psl, pslPost, FALSE, FALSE);
                header.m_cbRetValSize = MLParmSize(pReturnMLInfo->GetNativeSize());
                if (pReturnMLInfo->IsFpu())
                {
                    header.m_fpu = 1;
                }
            }
        } else {
            header.m_cbRetValSize = 0;
        }


        if (msig.IsVarArg())
        {
            psl->MLEmit(ML_PUSHVASIGCOOKIEEX);
            psl->Emit16(header.m_cbDstStack);
            psl->MLNewLocal(sizeof(VASigCookieEx));
        }


        psl->MLEmit(ML_INTERRUPT);


        pslPost->MLEmit(ML_END);
        Stub *pStubPost = pslPost->Link();
        COMPLUS_TRY {
            psl->EmitBytes(pStubPost->GetEntryPoint(), MLStreamLength((const UINT8 *)(pStubPost->GetEntryPoint())) - 1);
        } COMPLUS_CATCH {
            pStubPost->DecRef();
            COMPlusThrow(GETTHROWABLE());
        } COMPLUS_END_CATCH
        pStubPost->DecRef();

        psl->MLEmit(ML_END);

        pstub = psl->Link();

        header.m_cbLocals = psl->GetLocalSize();
        if (unmgdCallConv == pmCallConvCdecl) {
            header.m_cbRetPop = 0;
        } else {
            header.m_cbRetPop = header.m_cbSrcStack;
        }


        *((UMThunkMLStub *)(pstub->GetEntryPoint())) = header;
        PatchMLStubForSizeIs( sizeof(header) + (BYTE*)pstub->GetEntryPoint(),
                              numargs,
                              pMarshalInfo);


        {
            VOID DisassembleMLStream(const MLCode *pMLCode);
            //DisassembleMLStream(  ((UMThunkMLStub *)(pstub->GetEntryPoint()))->GetMLCode() );
        }


    } COMPLUS_CATCH {
        *ppException = GETTHROWABLE();
        return NULL;
    } COMPLUS_END_CATCH

    return pstub; // CHANGE, VC6.0
}



//---------------------------------------------------------
// Creates a new stub for a N/Export call. Return refcount is 1.
// If failed, returns NULL and sets *ppException to an exception
// object.
//---------------------------------------------------------
Stub * CreateUMThunkMLStub(PCCOR_SIGNATURE szMetaSig,
                           Module*    pModule,
                           BOOL       fIsStatic,
                           BYTE       nltType,
                           CorPinvokeMap unmgdCallConv,
                           mdMethodDef mdForNativeTypes,
                           OBJECTREF *ppException)
{
    MLStubLinker sl;
    MLStubLinker slPost;
    MLStubLinker slRet;
    return CreateUMThunkMLStubWorker(&sl, &slPost, &slRet, szMetaSig, pModule, fIsStatic, nltType, unmgdCallConv, mdForNativeTypes, ppException);
}





UMThunkMarshInfo::~UMThunkMarshInfo()
{
    _ASSERTE(IsAtLeastLoadTimeInited() || m_state == 0);

    if (m_pMLStub)
    {
        m_pMLStub->DecRef();
    }
    if (m_pExecStub)
    {
        m_pExecStub->DecRef();
    }

#ifdef _DEBUG
    FillMemory(this, sizeof(*this), 0xcc);
#endif
}







//----------------------------------------------------------
// This initializer can be called during load time.
// It does not do any ML stub initialization or sigparsing.
// The RunTimeInit() must be called subsequently before this
// can safely be used.
//----------------------------------------------------------
VOID UMThunkMarshInfo::LoadTimeInit(PCCOR_SIGNATURE          pSig,
                                    DWORD                    cSig,
                                    Module                  *pModule,
                                    BOOL                     fIsStatic,
                                    BYTE                     nlType,
                                    CorPinvokeMap            unmgdCallConv,
                                    mdMethodDef              mdForNativeTypes /*= mdMethodDefNil*/)
{
    _ASSERTE(!IsCompletelyInited());

    FillMemory(this, sizeof(UMThunkMarshInfo), 0); // Prevent problems with partial deletes
    m_pSig = pSig;
    m_cSig = cSig;

    m_pModule    = pModule;
    m_fIsStatic  = fIsStatic;
    m_nlType     = nlType;
    m_unmgdCallConv = unmgdCallConv;

    // These fields must be explicitly NULL'd out for the atomic
    // VipInterlockedExchangeCompare update to work during the runtime init.
    m_pMLStub   = NULL;
    m_pExecStub = NULL;


#ifdef _DEBUG
    m_cbRetPop        = 0xcccccccc;
    m_cbActualArgSize = 0xcccccccc;

#endif

    m_mdForNativeTypes = mdForNativeTypes;


    // Must be the last thing we set!
    m_state        = kLoadTimeInited;
}


//----------------------------------------------------------
// This initializer finishes the init started by LoadTimeInit.
// It does all the ML stub creation, and can throw a COM+
// exception.
//
// It can safely be called multiple times and by concurrent
// threads.
//----------------------------------------------------------
VOID UMThunkMarshInfo::RunTimeInit()
{

    _ASSERTE(IsAtLeastLoadTimeInited());

    THROWSCOMPLUSEXCEPTION();


    if (m_state != kRunTimeInited)
    {

        // do the unmanaged calling convention
        CorPinvokeMap sigCallConv = (CorPinvokeMap)0;
        if (m_pModule) 
        {
            sigCallConv = MetaSig::GetUnmanagedCallingConvention(m_pModule, m_pSig, m_cSig);
        }

        if (m_unmgdCallConv != 0 &&
            sigCallConv     != 0 &&
            m_unmgdCallConv != sigCallConv)
        {
            COMPlusThrow(kTypeLoadException, IDS_INVALID_PINVOKE_CALLCONV);
        }
        if (m_unmgdCallConv == 0)
        {
            m_unmgdCallConv = sigCallConv;
        }
        if (m_unmgdCallConv == 0 || m_unmgdCallConv == pmCallConvWinapi)
        {
            m_unmgdCallConv = pmCallConvStdcall;
        }



        m_cbActualArgSize = MetaSig::SizeOfActualFixedArgStack(m_pModule, m_pSig, m_fIsStatic);

        // This allows us to do a LoadInit even before MSCorLib has loaded.
        if (m_pModule == NULL)
        {
            m_pModule = SystemDomain::SystemModule();
        }

    
        OBJECTREF pException = NULL;
        Stub     *pMLStream;
        pMLStream = CreateUMThunkMLStub(m_pSig,
                                        m_pModule,
                                        m_fIsStatic,
                                        m_nlType,
                                        m_unmgdCallConv,
                                        m_mdForNativeTypes,
                                        &pException);
        if (!pMLStream) {
            COMPlusThrow(pException);
        }
    
        m_cbRetPop = ( (UMThunkMLStub*)(pMLStream->GetEntryPoint()) )->m_cbRetPop;
    
        Stub *pCanonicalStub;
        MLStubCache::MLStubCompilationMode mode;
        pCanonicalStub = g_pUMThunkStubCache->Canonicalize(
                                    (const BYTE *)(pMLStream->GetEntryPoint()),
                                    &mode);
        pMLStream->DecRef();
        if (!pCanonicalStub) {
            COMPlusThrowOM();
        }
    
    
        Stub *pFinalMLStub = NULL;
        Stub *pFinalExecStub = NULL;
    
        switch (mode) {
            case MLStubCache::INTERPRETED:
    
                pFinalMLStub = pCanonicalStub;
    #ifdef _X86_
                {
                    UINT cbRetPop = ((UMThunkMLStub*)(pCanonicalStub->GetEntryPoint()))->m_cbRetPop;

                    _ASSERTE(0 == (cbRetPop & 0x3)); // We reserve the lower two bits for flags
                    enum {
                        kHashThisCallAdjustment   = 0x1,
                        kHashThisCallHiddenArg = 0x2
                        
                    };

                    UINT hash = cbRetPop;


                    if ( ((UMThunkMLStub*)(pFinalMLStub->GetEntryPoint()))->m_fThisCall ) {
                        hash |= kHashThisCallAdjustment;
                        if (((UMThunkMLStub*)(pFinalMLStub->GetEntryPoint()))->m_fThisCallHiddenArg) {
                            hash |= kHashThisCallHiddenArg;
                        }
                    }

                    Stub *pStub = g_pUMThunkInterpretedStubCache->GetStub(hash);
                    if (!pStub) {
    
        
                        CPUSTUBLINKER *pcpusl = NewCPUSTUBLINKER();
                        if (!pcpusl) {
                            COMPlusThrowOM();
                        }
                        Stub *pCandidate = NULL;
                        EE_TRY_FOR_FINALLY
                        {
    
                            CodeLabel* rgRareLabels[] = { pcpusl->NewCodeLabel(),
                                                          pcpusl->NewCodeLabel(),
                                                          pcpusl->NewCodeLabel()
                                                        };
                        
                        
                            CodeLabel* rgRejoinLabels[] = { pcpusl->NewCodeLabel(),
                                                            pcpusl->NewCodeLabel(),
                                                            pcpusl->NewCodeLabel()
                                                        };
                        
                            if (hash & kHashThisCallAdjustment) {
                                if (hash & kHashThisCallHiddenArg) { 
                                           
                                    // pop off the return address
                                    pcpusl->X86EmitPopReg(kEDX);
        
                                    // exchange ecx (this "this") with the hidden structure return buffer
                                    //  xchg ecx, [esp]
                                    pcpusl->X86EmitOp(0x87, kECX, (X86Reg)4 /*ESP*/);
        
                                    // push ecx
                                    pcpusl->X86EmitPushReg(kECX);
        
                                    // push edx
                                    pcpusl->X86EmitPushReg(kEDX);
                                    }
                                else
                                {
                                    // pop off the return address
                                    pcpusl->X86EmitPopReg(kEDX);
        
                                    // jam ecx (the "this" param onto stack. Now it looks like a normal stdcall.)
                                    pcpusl->X86EmitPushReg(kECX);
        
                                    // repush
                                    pcpusl->X86EmitPushReg(kEDX);
                                }
                            }
            
                            // push UMEntryThunk
                            pcpusl->X86EmitPushReg(kEAX);

                            // emit the initial prolog
                            pcpusl->EmitComMethodStubProlog(UMThkCallFrame::GetUMThkCallFrameVPtr(), rgRareLabels, rgRejoinLabels,
                                                            UMThunkPrestubHandler, TRUE /*Profile*/);
                                        
                            pcpusl->X86EmitPushReg(kESI);       // push frame as an ARG
                            pcpusl->X86EmitPushReg(kEBX);       // push ebx (push current thread as ARG)
                        
                            pcpusl->X86EmitCall(pcpusl->NewExternalCodeLabel(DoUMThunkCall), 8); // on CE pop 8 bytes or args on return

                            pcpusl->EmitComMethodStubEpilog(UMThkCallFrame::GetUMThkCallFrameVPtr(), cbRetPop, rgRareLabels,
                                                            rgRejoinLabels, UMThunkPrestubHandler, TRUE /*Profile*/);
            
                            pCandidate = pcpusl->Link();
                        }
                        EE_FINALLY {
                            delete pcpusl;
                        } EE_END_FINALLY
                        Stub *pWinner = g_pUMThunkInterpretedStubCache->AttemptToSetStub(hash, pCandidate);
                        pCandidate->DecRef();
                        if (!pWinner) {
                            COMPlusThrowOM();
                        }
                        pStub = pWinner;
                    }
    
                    pFinalExecStub = pStub;
                }
    #else
                _ASSERTE(!"NYI");
    #endif
                break;
    
    
            case MLStubCache::STANDALONE:
                pFinalMLStub = NULL;
                pFinalExecStub = pCanonicalStub;
                break;
    
            default:
                _ASSERTE(0);
        }
    
    
        if (VipInterlockedCompareExchange((void*volatile*) &m_pMLStub,
                                          pFinalMLStub,
                                          NULL) != NULL)
        {
    
            // Some thread swooped in and set us. Our stub is now a
            // duplicate, so throw it away.
            if (pFinalMLStub)
            {
                pFinalMLStub->DecRef();
            }
        }
    
    
        if (VipInterlockedCompareExchange((void*volatile*) &m_pExecStub,
                                          pFinalExecStub,
                                          NULL) != NULL)
        {
    
            // Some thread swooped in and set us. Our stub is now a
            // duplicate, so throw it away.
            if (pFinalExecStub)
            {
                pFinalExecStub->DecRef();
            }
        }
    
    
        // Must be the last thing we set!
        m_state        = kRunTimeInited;
    }
}



//----------------------------------------------------------
// Combines LoadTime & RunTime inits for convenience.
//----------------------------------------------------------
VOID UMThunkMarshInfo::CompleteInit(PCCOR_SIGNATURE          pSig,
                                    DWORD                    cSig,
                                    Module                  *pModule,
                                    BOOL                     fIsStatic,
                                    BYTE                     nlType,
                                    CorPinvokeMap            unmgdCallConv,
                                    mdMethodDef              mdForNativeTypes /*= mdMethodDefNil*/)
{
    THROWSCOMPLUSEXCEPTION();
    LoadTimeInit(pSig, cSig, pModule, fIsStatic, nlType, unmgdCallConv, mdForNativeTypes);
    RunTimeInit();

}









//==========================================================================
// This stuff has nothing to do with UMThunk implementation other than
// that it requires initialization early, but after UMThunks have initialized,
// and that it's too small to be worth making another Init/Term pair for.
//==========================================================================


const BYTE       *gpCorEATBootstrapperFcn = NULL;

UMEntryThunk     *gCorEATBootstrapperUMEntryThunk = NULL;
UMThunkMarshInfo *gCorEATBootstrapperUMThunkMarshInfo = NULL;



//----------------------------------------------------------------------
// We got here because an unmanaged caller made a first-time call to
// a thunked managed method exported thru the EAT.
//
// This routine installs the containing DLL as a proper COM+ module.
// Then we backpatch the EAT's so we don't wind up here
// again.
//
// WARNING: Because this code is actually called using managed calling conventions,
// we have to pick a VC calling convention that "matches" it. This is both
// inherently CPU-dependent and hardcodes both the managed calling convention.
// The FCIMPL* macros in fcall.h are actually designed to encapsulate this nicely.
// Unfortunately, we can't use those because they also prevent you from
// doing stack crawling: an FCall-specific restriction that we don't have
// here.
//----------------------------------------------------------------------
static VOID __fastcall CorEATBootstrapManaged(PEFile *pFile)
{
#ifndef _X86_
    _ASSERTE(!"NYI");
#else
    THROWSCOMPLUSEXCEPTION();
    Module   *pModule = NULL;
    Assembly *pAssembly = NULL;
    IMAGE_COR20_HEADER *pCORHeader = NULL;
    HRESULT   hr;

    // Find the EATJ table and the cor header.
    DWORD numEATJEntries;
    BYTE *pEATJArray = FindExportAddressTableJumpArray(pFile->GetBase(), &numEATJEntries, NULL, &pCORHeader);

    // If there was an entry point, then the module has already been plugged into an
    // assembly, and therefore the v-table slots have been filled with thunks.
    if (pEATJArray && pCORHeader) {
        if (TypeFromToken(pCORHeader->EntryPointToken) != mdtMethodDef || IsNilToken(pCORHeader->EntryPointToken)) {
            hr = SystemDomain::GetCurrentDomain()->LoadAssembly(pFile, 
                                                                NULL,
                                                                &pModule, 
                                                                &pAssembly,
                                                                NULL,
                                                                FALSE,
                                                                NULL);
            if (FAILED(hr)) {
                // If this failed, there's not much we can do to be friendly because
                // we got here thru a UM thunk, and the ultimate caller has no idea
                // that we're secretly initializing an entire Module as a part of
                // his function call. Throw the best exception we can and hope
                // the um thunk turns it into a semiinformative RaiseException.
                COMPlusThrow(kTypeLoadException);
            }
        }
        
    
        // Now that the module is completely loaded, we can safely backpatch.
        // We'll just backpatch everyone now.
        while (numEATJEntries--) {
            EATThunkBuffer *pEATThunkBuffer = (EATThunkBuffer*) pEATJArray;
            pEATThunkBuffer->Backpatch(pFile->GetBase());
            pEATJArray = pEATJArray + IMAGE_COR_EATJ_THUNK_SIZE;
        }
    }
#endif
}






//--------------------------------------------------------------------------
// Onetime Init
//--------------------------------------------------------------------------
BOOL UMThunkInit()
{
    g_pUMThunkStubCache = new UMThunkStubCache();
    if (!g_pUMThunkStubCache) {
        return FALSE;
    }
    g_pUMThunkInterpretedStubCache = new ArgBasedStubRetainer();
    if (!g_pUMThunkInterpretedStubCache) {
        return FALSE;
    }

    gCorEATBootstrapperUMEntryThunk = UMEntryThunk::CreateUMEntryThunk();
    if (!gCorEATBootstrapperUMEntryThunk) {
        return FALSE;
    }
    FillMemory(gCorEATBootstrapperUMEntryThunk, sizeof(*gCorEATBootstrapperUMEntryThunk), 0);

    gCorEATBootstrapperUMThunkMarshInfo = new UMThunkMarshInfo();
    if (!gCorEATBootstrapperUMThunkMarshInfo) {
        return FALSE;
    }
    FillMemory(gCorEATBootstrapperUMThunkMarshInfo, sizeof(*gCorEATBootstrapperUMThunkMarshInfo), 0);

    // Gotta handcraft a signature for "(PTR)V" (static) because it's too early
    // to use the MetaSig.h abstractions.
    static const COR_SIGNATURE bSig[] = {IMAGE_CEE_CS_CALLCONV_DEFAULT, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_U4 /*@todo IA64: Needs to be ELEMENT_TYPE_PTR or the type adjusted for platform bitness */};

    gCorEATBootstrapperUMThunkMarshInfo->LoadTimeInit(bSig,
                                                      sizeof(bSig),
                                                      NULL, //"MSCORLIB",
                                                      TRUE, //fIsStatic,
                                                      nltAnsi,
                                                      pmCallConvStdcall);
    gCorEATBootstrapperUMEntryThunk->LoadTimeInit((const BYTE *)CorEATBootstrapManaged,
                                                  NULL,
                                                  gCorEATBootstrapperUMThunkMarshInfo,
                                                  NULL,
                                                  SystemDomain::System()->DefaultDomain()->GetId());
    gpCorEATBootstrapperFcn = gCorEATBootstrapperUMEntryThunk->GetCode(); 
    return TRUE;
}

//--------------------------------------------------------------------------
// Onetime Shutdown
//--------------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
VOID UMThunkTerminate()
{
    delete gCorEATBootstrapperUMEntryThunk;
    delete gCorEATBootstrapperUMThunkMarshInfo;
    
    if (g_pUMThunkInterpretedStubCache) {
        g_pUMThunkInterpretedStubCache->ForceDeleteStubs();
        delete g_pUMThunkInterpretedStubCache;
    }

    if (g_pUMThunkStubCache) {
        g_pUMThunkStubCache->ForceDeleteStubs();
        delete g_pUMThunkStubCache;
    }
}
#endif /* SHOULD_WE_CLEANUP */




//==========================================================================
// The following is a lightweight PE-file parser that serves to find
// the ExportAddressTableJumps array and nothing else. This code MUST
// run without assuming anything else in the EE being initialized. That's
// why it's a separate piece.
//
// @nice: this should really be shared code that the PELoader stuff can
// leverage.
//==========================================================================
BYTE* FindExportAddressTableJumpArray(BYTE *pBase, DWORD *pNumEntries, BOOL *pHasFixups, IMAGE_COR20_HEADER **ppCORHeader)
{
    BYTE* pEATJArray = NULL;

    if (pHasFixups)
        *pHasFixups = FALSE;

    __try {

        if (ppCORHeader)
            *ppCORHeader = NULL;

        IMAGE_DOS_HEADER *pDOS = (IMAGE_DOS_HEADER *)pBase;
        if (pDOS->e_magic != IMAGE_DOS_SIGNATURE ||
            pDOS->e_lfanew == 0) {
            return NULL;
        }
        IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*)(pBase + pDOS->e_lfanew);
        if (pNT->Signature != IMAGE_NT_SIGNATURE ||
            pNT->FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER ||
            pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC ||
            pNT->OptionalHeader.NumberOfRvaAndSizes <= IMAGE_DIRECTORY_ENTRY_COMHEADER
            ) {
            return NULL;
        }
        IMAGE_DATA_DIRECTORY *entry = &pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER];
        if (entry->VirtualAddress == 0 || entry->Size < sizeof(IMAGE_COR20_HEADER)) {
            return NULL;
        }
        IMAGE_COR20_HEADER *pCORHeader = (IMAGE_COR20_HEADER*)(pBase + entry->VirtualAddress);
        if (ppCORHeader)
            *ppCORHeader = pCORHeader;

        pEATJArray = pBase + pCORHeader->ExportAddressTableJumps.VirtualAddress;

        if (pHasFixups &&
            pCORHeader->VTableFixups.VirtualAddress != 0 &&
            pCORHeader->VTableFixups.Size != 0)
        {
            *pHasFixups = TRUE;
        }

        DWORD numEntries = pCORHeader->ExportAddressTableJumps.Size / IMAGE_COR_EATJ_THUNK_SIZE;
        if (numEntries == 0 || pEATJArray == NULL || 
                    pCORHeader->ExportAddressTableJumps.Size % IMAGE_COR_EATJ_THUNK_SIZE) {
            return NULL;
        }

        *pNumEntries = numEntries;
    } __except(COMPLUS_EXCEPTION_EXECUTE_HANDLER) {
        pEATJArray = NULL;
    }
    return pEATJArray;
}



VOID EATThunkBuffer::InitForBootstrap(PEFile *pFile)
{
#ifdef _X86_
    _ASSERTE(sizeof(*this) <= IMAGE_COR_EATJ_THUNK_SIZE);

    DWORD pFixupRVA = Before.m_VTableFixupRva;
    BYTE *pWalk = (BYTE*)this;

    // Must pad with enough NOP's so that the backpatch address
    // is DWORD-aligned.
    while ( ( ((size_t)pWalk) & 3) != 3 ) {
        *(pWalk++) = 0x90;  //nop
    }
    Code *pCode = (Code*)pWalk;


    // Make sure we don't overrun the buffer even in the worst
    // case.
    _ASSERTE(sizeof(Code) + 3 < IMAGE_COR_EATJ_THUNK_SIZE); 

    pCode->m_VTableFixupRva = pFixupRVA;

    pCode->m_jmp32           = 0xe9;
    pCode->m_jmpofs32        = 0;
    pCode->m_pusheax         = 0x50;
    pCode->m_pushecx         = 0x51;
    pCode->m_pushedx         = 0x52;
    pCode->m_pushimm32       = 0x68;
    pCode->m_pFile           = pFile;
    pCode->m_call            = 0xe8;
    pCode->m_bootstrapper    = (UINT32)(size_t)((size_t)gpCorEATBootstrapperFcn - (1 + (size_t)&pCode->m_bootstrapper));
    pCode->m_popedx          = 0x5a;
    pCode->m_popecx          = 0x59;
    pCode->m_popeax          = 0x58;
    pCode->m_jmp8            = 0xeb;
    pCode->m_jmpofs8         = (BYTE)(size_t)((size_t)pCode - (1 + (size_t)&pCode->m_jmpofs8));
    


#endif
}

#include <pshpack1.h>
struct LinkerJumpThunk
{
    BYTE        Jump[2];                // jmp ds:[address]
    UINT32      *pSlot;                 // Pointer with address
};
#include <poppack.h>

VOID EATThunkBuffer::Backpatch(BYTE *pBase)
{
#ifdef _X86_
    BYTE *pWalk = (BYTE*)this;

    // Skip over nops.
    while ( (((size_t)pWalk) & 3) != 3 ) {
        ++pWalk;
    }
    Code *pCode = (Code*)pWalk;

    if (Beta1Hack_LooksLikeAMethodDef(pCode->m_VTableFixupRva))
    {
        // don't do anything: vtablefixup code already properly backpatched jumpbuffer.
    }
    else
    {

        // For M10, the RVA points to a linker generated fixup jump thunk.
        // The target of this jump is the pointer to the u->m transition thunk
        // built before the backpatch.
        LinkerJumpThunk *pThunk = (LinkerJumpThunk *) (pBase + pCode->m_VTableFixupRva);
        _ASSERTE(pThunk->Jump[0] == 0xff);
        _ASSERTE(pThunk->Jump[1] == 0x25);
        
        _ASSERTE( 0 == ( ((size_t) &pCode->m_jmpofs32 ) & 3 ));
        pCode->m_jmpofs32 = (UINT32)(size_t)((size_t)(*pThunk->pSlot) - (1 + (size_t)&pCode->m_jmpofs32));
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\notifyexternals.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// Author: Dave Driver (ddriver)
// Date: Monday, Nov 08, 1999
////////////////////////////////////////////////////////////////////////////////

#ifndef _NOTIFY_EXTERNALS_H
#define _NOTIFY_EXTERNALS_H

extern BOOL g_fComStarted;
BOOL SystemHasNewOle32();

HRESULT SetupTearDownNotifications();
VOID RemoveTearDownNotifications();

ULONG_PTR GetFastContextCookie();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\new.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _NEW_HPP_
#define _NEW_HPP_

#include "exceptmacros.h"

class NoThrow { };
extern const NoThrow nothrow;

class Throws { };
extern const Throws throws;

static inline void * __cdecl operator new(size_t n, const NoThrow&) { 
    return ::operator new(n); 
}
static inline void * __cdecl operator new[](size_t n, const NoThrow&) { 
    return ::operator new[](n);  
}
static inline void __cdecl operator delete(void *p, const NoThrow&) { 
    ::operator delete(p);
}
static inline void __cdecl operator delete[](void *p, const NoThrow&) { 
    ::operator delete[](p);
}

static inline void * __cdecl operator new(size_t n, const Throws&) { 
    THROWSCOMPLUSEXCEPTION();
    void *p = ::operator new(n); 
    if (!p) COMPlusThrowOM();
    return p;
}
static inline void * __cdecl operator new[](size_t n, const Throws&) { 
    THROWSCOMPLUSEXCEPTION();
    void *p = ::operator new[](n);  
    if (!p) COMPlusThrowOM();
    return p;
}
static inline void __cdecl operator delete(void *p, const Throws&) { 
    ::operator delete(p);
}
static inline void __cdecl operator delete[](void *p, const Throws&) { 
    ::operator delete[](p);
}

#endif // _NEW_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ndirect.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// NDIRECT.H -
//
//

#ifndef __ndirect_h__
#define __ndirect_h__

#include "util.hpp"
#include "ml.h"


class NDirectMLStubCache;
class ArgBasedStubCache;





//=======================================================================
// Collects code and data pertaining to the NDirect interface.
//=======================================================================
class NDirect
{
    friend NDirectMethodDesc;
    
    public:
        //---------------------------------------------------------
        // One-time init
        //---------------------------------------------------------
        static BOOL Init();

        //---------------------------------------------------------
        // One-time cleanup
        //---------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
        static VOID Terminate();
#endif /* SHOULD_WE_CLEANUP */

        //---------------------------------------------------------
        // Handles system specfic portion of generic NDirect stub creation
        //---------------------------------------------------------
        static void CreateGenericNDirectStubSys(CPUSTUBLINKER *psl);


        //---------------------------------------------------------
        // Handles system specfic portion of fully optimized NDirect stub creation
        //
        // Results:
        //     TRUE     - was able to create a standalone asm stub (generated into
        //                psl)
        //     FALSE    - decided not to create a standalone asm stub due to
        //                to the method's complexity. Stublinker remains empty!
        //
        //     COM+ exception - error - don't trust state of stublinker.
        //---------------------------------------------------------
        static BOOL CreateStandaloneNDirectStubSys(const MLHeader *pheader, CPUSTUBLINKER *psl, BOOL fDoComInterop); 


        //---------------------------------------------------------
        // Call at strategic times to discard unused stubs.
        //---------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
        static VOID  FreeUnusedStubs();
#endif /* SHOULD_WE_CLEANUP */


        //---------------------------------------------------------
        // Does a class or method have a NAT_L CustomAttribute?
        //
        // S_OK    = yes
        // S_FALSE = no
        // FAILED  = unknown because something failed.
        //---------------------------------------------------------
        static HRESULT HasNAT_LAttribute(IMDInternalImport *pInternalImport, mdToken token);

        //---------------------------------------------------------
        // Extracts the effective NAT_L CustomAttribute for a method,
        // taking into account default values and inheritance from
        // the global NAT_L CustomAttribute.
        //
        // On exit, *pLibName and *pEntrypointName may contain
        // allocated strings that have to be freed using "delete."
        //
        // Returns TRUE if a NAT_L CustomAttribute exists and is valid.
        // Returns FALSE if no NAT_L CustomAttribute exists.
        // Throws an exception otherwise.
        //---------------------------------------------------------
        static BOOL ReadCombinedNAT_LAttribute(MethodDesc *pMD,
                                               CorNativeLinkType *pLinkType,
                                               CorNativeLinkFlags *pLinkFlags,
                                               CorPinvokeMap *pUnmgdCallConv,
                                               LPCUTF8     *pLibName,
                                               LPCUTF8     *pEntrypointName,
                                               BOOL        *BestFit,
                                               BOOL        *ThrowOnUnmappableChar
                                               );



		static UINT GetCallDllFunctionReturnOffset();

        static LPVOID NDirectGetEntryPoint(NDirectMethodDesc *pMD, HINSTANCE hMod, UINT16 numParamBytes);
        static VOID NDirectLink(NDirectMethodDesc *pMD, UINT16 numParamBytes);
        static Stub* ComputeNDirectMLStub(NDirectMethodDesc *pMD);
        static Stub* GetNDirectMethodStub(StubLinker *pstublinker, NDirectMethodDesc *pMD);
        static Stub* CreateGenericNDirectStub(StubLinker *pstublinker, UINT cbStackPop);
        static Stub* CreateSlimNDirectStub(StubLinker *psl, NDirectMethodDesc *pMD, UINT cbStackPop);

    private:
        NDirect() {};     // prevent "new"'s on this class



        static NDirectMLStubCache *m_pNDirectMLStubCache;



        //---------------------------------------------------------
        // Stub caches for NDirect Method stubs
        //---------------------------------------------------------
        static ArgBasedStubCache *m_pNDirectGenericStubCache;  
        static ArgBasedStubCache *m_pNDirectSlimStubCache;


};


//---------------------------------------------------------
// Extracts the effective NAT_L CustomAttribute for a method.
//
// On exit, *pLibName and *pEntrypointName may contain
// allocated strings that have to be freed using "delete."
//
//---------------------------------------------------------
VOID CalculatePinvokeMapInfo(MethodDesc *pMD,
                            /*out*/ CorNativeLinkType   *pLinkType,
                            /*out*/ CorNativeLinkFlags  *pLinkFlags,
                            /*out*/ CorPinvokeMap       *pUnmgdCallConv,
                            /*out*/ LPCUTF8             *pLibName,
                            /*out*/ LPCUTF8             *pEntryPointName,
                            /*out*/ BOOL                *BestFit,
                            /*out*/ BOOL                *ThrowOnUnmappableChar);


//=======================================================================
// The ML stub for N/Direct begins with this header. Immediately following
// this header are the ML codes for marshaling the arguments, terminated
// by ML_INTERRUPT. Immediately following that are the ML codes for
// marshaling the return value, terminated by ML_END.
//=======================================================================



VOID NDirectImportThunk();




BOOL NDirectOnUnicodeSystem();


Stub * CreateNDirectMLStub(PCCOR_SIGNATURE szMetaSig,
                           Module*    pModule,
                           mdMethodDef md,
                           CorNativeLinkType nlType,
                           CorNativeLinkFlags nlFlags,
                           CorPinvokeMap unmgdCallConv,
                           OBJECTREF *ppException,
                           BOOL fConvSigAsVarArg = FALSE,
                           BOOL BestFit = TRUE,
                           BOOL ThrowOnUnmappableChar = FALSE
#ifdef CUSTOMER_CHECKED_BUILD
                           ,MethodDesc* pMD = NULL
#endif
#ifdef _DEBUG
                           ,
                           LPCUTF8 pDebugName = NULL,
                           LPCUTF8 pDebugClassName = NULL,
                           LPCUTF8 pDebugNameSpace = NULL
#endif


                           );



VOID __stdcall NDirect_Prelink_Wrapper(struct _NDirect_Prelink_Args *args);
VOID NDirect_Prelink(MethodDesc *pMeth);
INT32 __stdcall NDirect_NumParamBytes(struct _NDirect_NumParamBytes_Args *args);

//---------------------------------------------------------
// Helper function to checkpoint the thread allocator for cleanup.
//---------------------------------------------------------
VOID __stdcall DoCheckPointForCleanup(NDirectMethodFrameEx *pFrame, Thread *pThread);

// This attempts to guess whether a target is an API call that uses SetLastError to communicate errors.
BOOL HeuristicDoesThisLooksLikeAnApiCall(LPBYTE pTarget);
BOOL HeuristicDoesThisLookLikeAGetLastErrorCall(LPBYTE pTarget);
DWORD __stdcall FalseGetLastError();

#endif // __ndirect_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\nexport.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// NEXPORT.H -
//
//


#ifndef __nexport_h__
#define __nexport_h__

#include "object.h"
#include "stublink.h"
#include "ml.h"
#include "ceeload.h"
#include "class.h"


#pragma pack(push, 1)
//--------------------------------------------------------------------------
// This structure forms a header for the marshaling code for an UMThunk.
//--------------------------------------------------------------------------
struct UMThunkMLStub
{
    UINT16        m_cbDstStack;   //# of bytes of stack portion of managed args
    UINT16        m_cbSrcStack;   //# of bytes of stack portion of unmanaged args
    UINT16        m_cbRetPop;     //# of bytes to pop on return to unmanaged
    UINT16        m_cbLocals;     //# of bytes required in the local array
    UINT16        m_cbRetValSize; //# of bytes of retval (including stack promotion)
    BYTE          m_fIsStatic;    //Is method static?
    BYTE          m_fThisCall;
	BYTE		  m_fThisCallHiddenArg; //Has hidden arg for returning structures (triggers special case in thiscall adjustment)
    BYTE          m_fpu;
    BYTE          m_fRetValRequiredGCProtect;

    const MLCode *GetMLCode() const
    {
        return (const MLCode *)(this+1);
    }
};

#pragma pack(pop)


//----------------------------------------------------------------------
// This structure collects all information needed to marshal an
// unmanaged->managed thunk. The only information missing is the
// managed target and the "this" object (if any.) Those two pieces
// are broken out into a small UMEntryThunk.
//
// The idea is to share UMThunkMarshInfo's between multiple thunks
// that have the same signature while the UMEntryThunk contains the
// minimal info needed to distinguish between actual function pointers.
//----------------------------------------------------------------------
class UMThunkMarshInfo
{
    friend class UMThunkStubCache;


    public:



        //----------------------------------------------------------
        // This initializer can be called during load time.
        // It does not do any ML stub initialization or sigparsing.
        // The RunTimeInit() must be called subsequently before this
        // can safely be used.
        //----------------------------------------------------------
        VOID LoadTimeInit(PCCOR_SIGNATURE          pSig,
                          DWORD                    cSig,
                          Module                  *pModule,
                          BOOL                     fIsStatic,
                          BYTE                     nlType,
                          CorPinvokeMap            unmgdCallConv,
                          mdMethodDef              mdForNativeTypes = mdMethodDefNil);



        //----------------------------------------------------------
        // This initializer finishes the init started by LoadTimeInit.
        // It does all the ML stub creation, and can throw a COM+
        // exception.
        //
        // It can safely be called multiple times and by concurrent
        // threads.
        //----------------------------------------------------------
        VOID RunTimeInit();


        //----------------------------------------------------------
        // Combines LoadTime & RunTime inits for convenience.
        //----------------------------------------------------------
        VOID CompleteInit(PCCOR_SIGNATURE          pSig,
                          DWORD                    cSig,
                          Module                  *pModule,
                          BOOL                     fIsStatic,
                          BYTE                     nlType,
                          CorPinvokeMap            unmgdCallConv,
                          mdMethodDef              mdForNativeTypes = mdMethodDefNil);


        //----------------------------------------------------------
        // Destructor.
        //----------------------------------------------------------
        ~UMThunkMarshInfo();

        //----------------------------------------------------------
        // Accessor functions
        //----------------------------------------------------------
        PCCOR_SIGNATURE GetSig() const
        {
            _ASSERTE(IsAtLeastLoadTimeInited());
            return m_pSig;
        }

        Module *GetModule() const
        {
            _ASSERTE(IsAtLeastLoadTimeInited());
            return m_pModule;
        }

        BOOL IsStatic() const
        {
            _ASSERTE(IsAtLeastLoadTimeInited());
            return m_fIsStatic;
        }

        Stub *GetMLStub() const
        {
            _ASSERTE(IsCompletelyInited());
            return m_pMLStub;
        }

        Stub *GetExecStub() const
        {
            _ASSERTE(IsCompletelyInited());
            return m_pExecStub;
        }

        UINT32 GetCbRetPop() const
        {
            _ASSERTE(IsCompletelyInited());
            return m_cbRetPop;
        }

        UINT32 GetCbActualArgSize() const
        {
            _ASSERTE(IsCompletelyInited());
            return m_cbActualArgSize;
        }

        CorPinvokeMap GetUnmanagedCallConv() const
        {
            // In the future, we'll derive the unmgdCallConv from the signature
            // rather than having it passed in separately. To avoid having
            // to parse the signature at loadtimeinit (not necessarily a problem
            // but we want to keep the amount of loadtimeinit processing at
            // a minimum), we'll be extra-strict here to prevent other code
            // from depending on the callconv being available at loadtime.
            _ASSERTE(IsCompletelyInited());
            return m_unmgdCallConv;
        }

        BYTE GetNLType() const
        {
            _ASSERTE(IsAtLeastLoadTimeInited());
            return m_nlType;
        }

#ifdef _DEBUG
        BOOL IsAtLeastLoadTimeInited() const
        {
            return m_state == kLoadTimeInited || m_state == kRunTimeInited;
        }


        BOOL IsCompletelyInited() const
        {
            return m_state == kRunTimeInited;
        }


#endif




    private:
        size_t            m_state;        // the initialization state 

        enum {
            kLoadTimeInited = 0x4c55544d,   //'LUTM'
            kRunTimeInited  = 0x5255544d,   //'RUTM'
        };


        PCCOR_SIGNATURE   m_pSig;         // signature
        DWORD             m_cSig;         // signature size
        Module           *m_pModule;      // module
        BOOL              m_fIsStatic;    // static or virtual?
        Stub             *m_pMLStub;      // if interpreted, UmThunkMLHeader-prefixed ML stub for marshaling - NULL otherwise
        Stub             *m_pExecStub;    // UMEntryThunk jumps directly here
        UINT32            m_cbRetPop;     // stack bytes popped by callee (for UpdateRegDisplay)
        UINT32            m_cbActualArgSize; // caches m_pSig.SizeOfActualFixedArgStack()
        BYTE              m_nlType;       // charset
        CorPinvokeMap     m_unmgdCallConv; //calling convention
        mdMethodDef       m_mdForNativeTypes;  // (optional) nativetype metadata

};










//----------------------------------------------------------------------
// This structure contains the minimal information required to
// distinguish one function pointer from another, with the rest
// being stored in a shared UMThunkMarshInfo.
//
// This structure also contains the actual code bytes that form the
// front end of the thunk. A pointer to the m_code[] byte array is
// what is actually handed to unmanaged client code.
//----------------------------------------------------------------------
class UMEntryThunk
{
    friend class UMThunkStubCache;
    friend class Stub *GenerateUMThunkPrestub();

    public:
    	static UMEntryThunk* CreateUMEntryThunk();
    	static VOID FreeUMEntryThunk(UMEntryThunk* p);

	 void* operator new(size_t size, void* spot) {   return (spot); }
    void operator delete(void* spot) {}
    	
        VOID LoadTimeInit(const BYTE             *pManagedTarget,
                          OBJECTHANDLE            pObjectHandle,
                          UMThunkMarshInfo       *pUMThunkMarshInfo,
                          MethodDesc             *pMD, 
                          DWORD                   dwDomainId)
        {

            _ASSERTE(pUMThunkMarshInfo->IsAtLeastLoadTimeInited());
            _ASSERTE(pManagedTarget != NULL || pMD != NULL);

            m_pManagedTarget    = pManagedTarget;
            m_pObjectHandle     = pObjectHandle;
            m_pUMThunkMarshInfo = pUMThunkMarshInfo;
            m_dwDomainId        = dwDomainId;

            m_pMD = pMD;    // For debugging and profiling, so they can identify the target

#ifdef _X86_
            m_code.m_movEAX = 0xb8;
            m_code.m_uet    = this;
            m_code.m_jmp    = 0xe9;
            m_code.m_execstub = (BYTE*) (((BYTE*)(TheUMThunkPreStub()->GetEntryPoint())) - (4+((BYTE*)&m_code.m_execstub)));
#elif defined(_IA64_)
            //
            // @TODO_IA64: implement this
            //
#else
            _ASSERTE(!"NYI");
#endif


#ifdef _DEBUG
            m_state = kLoadTimeInited;
#endif

        }

        ~UMEntryThunk()
        {
            if (GetObjectHandle())
            {
                DestroyLongWeakHandle(GetObjectHandle());
            }
#ifdef _DEBUG
            FillMemory(this, sizeof(*this), 0xcc);
#endif
        }

        VOID RunTimeInit()
        {
            THROWSCOMPLUSEXCEPTION();

            m_pUMThunkMarshInfo->RunTimeInit();
#ifdef _X86_
            m_code.m_execstub = (BYTE*) (((BYTE*)(m_pUMThunkMarshInfo->GetExecStub()->GetEntryPoint())) - (4+((BYTE*)&m_code.m_execstub)));
#else // !_X86_
            _ASSERTE(!"NYI");
#endif // _X86

#ifdef _DEBUG
            m_state = kRunTimeInited;
#endif
            
        }

        VOID CompleteInit(const BYTE             *pManagedTarget,
                          OBJECTHANDLE            pObjectHandle,
                          UMThunkMarshInfo       *pUMThunkMarshInfo,
                          MethodDesc             *pMD,
                          DWORD                   dwAppDomainId)
        {
            THROWSCOMPLUSEXCEPTION();

            LoadTimeInit(pManagedTarget, pObjectHandle, pUMThunkMarshInfo, pMD, dwAppDomainId);
            RunTimeInit();
        }

        const BYTE *GetManagedTarget() const
        {
            _ASSERTE(m_state == kRunTimeInited || m_state == kLoadTimeInited);
            if (m_pManagedTarget)
            {
                return m_pManagedTarget;
            }
            else
            {
                return m_pMD->GetAddrofCode();
            }
        }

        OBJECTHANDLE GetObjectHandle() const
        {
            _ASSERTE(m_state == kRunTimeInited || m_state == kLoadTimeInited);
            return m_pObjectHandle;
        }

        const UMThunkMarshInfo *GetUMThunkMarshInfo() const
        {
            _ASSERTE(m_state == kRunTimeInited || m_state == kLoadTimeInited);
            return m_pUMThunkMarshInfo;
        }

        const BYTE *GetCode() const
        {
            _ASSERTE(m_state == kRunTimeInited || m_state == kLoadTimeInited);
            return (const BYTE *)&m_code;
        }

        static UMEntryThunk *RecoverUMEntryThunk(const VOID* pCode)
        {
            return (UMEntryThunk*)( ((LPBYTE)pCode) - offsetof(UMEntryThunk, m_code) );
        }


        MethodDesc *GetMethod() const
        {
            _ASSERTE(m_state == kRunTimeInited || m_state == kLoadTimeInited);
            return m_pMD;
        }

        DWORD GetDomainId() const
        {
            _ASSERTE(m_state == kRunTimeInited);
            return m_dwDomainId;
        }

        static const DWORD GetOffsetOfMethodDesc()
        {
            return ((DWORD) offsetof(class UMEntryThunk, m_pMD));
        }

        static VOID EmitUMEntryThunkCall(CPUSTUBLINKER *psl);

#ifdef CUSTOMER_CHECKED_BUILD

        BOOL DeadTarget() const
        {
            return (m_pManagedTarget == NULL);
        }
#endif

    private:
#ifdef _DEBUG
        size_t            m_state;        // the initialization state 

        enum {
            kLoadTimeInited = 0x4c554554,   //'LUET'
            kRunTimeInited  = 0x52554554,   //'RUET'
        };
#endif
        
        // The start of the managed code
        const BYTE             *m_pManagedTarget;

        // This is used for profiling.
        MethodDesc             *m_pMD;

        // Object handle holding "this" reference. May be a strong or weak handle.
        // Field is NULL for a static method.
        OBJECTHANDLE            m_pObjectHandle;

        // Pointer to the shared structure containing everything else
        UMThunkMarshInfo       *m_pUMThunkMarshInfo;

        DWORD                   m_dwDomainId;   // appdomain of module (cached for fast access)


#pragma pack(push,1)

#ifdef _X86_
        // make sure the backpatched portion is dword aligned.
        BYTE                    m_alignpad[2];
#else
#endif


        // The actual executable code that begins the thunk.
        struct
        {
#ifdef _X86_
            BYTE           m_movEAX;   //MOV EAX,imm32
            UMEntryThunk  *m_uet;      // pointer to start of this structure
            BYTE           m_jmp;      //JMP NEAR32 (0xe9)
            const BYTE *   m_execstub; // pointer to m_pVMThunkMarshInfo's exec stub

#else
            int nyi;
#endif
        } m_code;
#pragma pack(pop)


};











//--------------------------------------------------------------------------
// Onetime Init
//--------------------------------------------------------------------------
BOOL UMThunkInit();


//--------------------------------------------------------------------------
// Onetime Shutdown
//--------------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
VOID UMThunkTerminate();
#endif /* SHOULD_WE_CLEANUP */




//-------------------------------------------------------------------------
// One-time creation of special prestub to initialize UMEntryThunks.
//-------------------------------------------------------------------------
Stub *GenerateUMThunkPrestub();

//-------------------------------------------------------------------------
// Recognize special SEH handler for NExport
//-------------------------------------------------------------------------
BOOL NExportSEH(EXCEPTION_REGISTRATION_RECORD* pEHR);
BOOL FastNExportSEH(EXCEPTION_REGISTRATION_RECORD* pEHR);

//-------------------------------------------------------------------------
// Special bootstrapper u->m thunk for bootstrapping EAT's
//-------------------------------------------------------------------------
extern const BYTE       *gpCorEATBootstrapperFcn;




//==========================================================================
// The following is a lightweight PE-file parser that serves to find
// the ExportAddressTableJumps array and nothing else. This code MUST
// run without assuming anything else in the EE being initialized. That's
// why it's a separate piece.
//
// @todo: this should really be shared code that the PELoader stuff can
// leverage.
//==========================================================================
BYTE* FindExportAddressTableJumpArray(BYTE *pBase, DWORD *pNumEntries, BOOL *pHasFixups = NULL, IMAGE_COR20_HEADER **ppCORHeader = NULL);

#pragma pack(push, 1)

struct EATThunkBuffer
{
    public:
        VOID InitForBootstrap(PEFile *pFile);
        VOID Backpatch(BYTE *pBase);


        LPVOID GetTarget()
        {
            Code *pCode = GetCode();
            return (LPVOID)(size_t)( pCode->m_jmpofs32 + (1 + &(pCode->m_jmpofs32)) );
        }

        VOID SetTarget(LPVOID pTarget)
        {
            Code *pCode = GetCode();
            pCode->m_jmpofs32 = (UINT32)((size_t)pTarget - (1 + (size_t)&(pCode->m_jmpofs32)));
        }

        mdToken GetToken()
        {
            return (mdToken)(GetCode()->m_VTableFixupRva);
        }


    private:
        struct Code {
            BYTE    m_jmp32;        //0xe9
   volatile UINT32  m_jmpofs32;     //this is the backpatched address
            BYTE    m_pusheax;      //0x50
            BYTE    m_pushecx;      //0x51
            BYTE    m_pushedx;      //0x52
            BYTE    m_pushimm32;    //0x68
            PEFile* m_pFile;        // file
            BYTE    m_call;         //0xe8
            UINT32  m_bootstrapper; // bootstrapper
            BYTE    m_popedx;       //0x5a
            BYTE    m_popecx;       //0x59
            BYTE    m_popeax;       //0x58
            BYTE    m_jmp8;         //0xeb
            BYTE    m_jmpofs8;      //back to start

            DWORD   m_VTableFixupRva;
       };
        
    public:
       Code *GetCode()
       {
           BYTE *pWalk = (BYTE*)this;
           while ( (((size_t)pWalk) & 3) != 3 ) {
               ++pWalk;
           }
           return (Code*)pWalk;

       }

    private:


       union {

           struct {
               DWORD   m_VTableFixupRva;
           } Before;
           BYTE   After[32];


       };
};
#pragma pack(pop)

// Hack macro for Beta-1 integration switchover to new EAT jump buffer
// format.
//
// The old format sticks an RVA to a linker jump thunk in the EAT jump buffer.
// The new format sticks a mdtMethodDef there.
//
// For the few weeks between the two integration builds, we'll use
// heuristics to guess which format is in use. As long as we don't test
// the EE on PE's larger than 100 Mb, this should work.

#define Beta1Hack_LooksLikeAMethodDef(rvaOrMethodDef) ( (rvaOrMethodDef), TRUE )


#endif //__nexport_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\notifyexternals.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: EXTERNALS.CPP
// 
// ===========================================================================

#include "common.h"
#include "excep.h"
#include "interoputil.h"
#include "comcache.h"

#define INITGUID
#include <guiddef.h>
#include "ctxtcall.h"
#include "notifyexternals.h"

DEFINE_GUID(CLSID_ComApartmentState, 0x00000349, 0, 0, 0xC0,0,0,0,0,0,0,0x46);


static const GUID IID_ITeardownNotification = { 0xa85e0fb6, 0x8bf4, 0x4614, { 0xb1, 0x64, 0x7b, 0x43, 0xef, 0x43, 0xf5, 0xbe } };
static const GUID IID_IComApartmentState = { 0x7e220139, 0x8dde, 0x47ef, { 0xb1, 0x81, 0x08, 0xbe, 0x60, 0x3e, 0xfd, 0x75 } };


HRESULT (*OLE32CoGetContextToken)(ULONG_PTR* pToken);
// type pointer to CoGetObjectContext function in ole32
HRESULT (__stdcall *OLE32CoGetObjectContext)(REFIID riid, void **ppv);

HRESULT HandleApartmentShutDown()
{
    Thread* pThread = GetThread();
    if (pThread != NULL)
    {
         _ASSERTE(!"NYI");
        //ComCache::OnThreadTerminate(pThread);
        
        // reset the apartment state
        pThread->ResetApartment();
    }
	return S_OK;
}

// ---------------------------------------------------------------------------
// %%Class EEClassFactory
// IClassFactory implementation for COM+ objects
// ---------------------------------------------------------------------------
class ApartmentTearDownHandler : public ITeardownNotification
{ 
    ULONG                   m_cbRefCount;
    IUnknown*               m_pMarshalerObj;
    
public:
    ApartmentTearDownHandler(HRESULT& hr)
    {
        m_pMarshalerObj = NULL;
        m_cbRefCount = 1;     
        hr = CoCreateFreeThreadedMarshaler(this, &m_pMarshalerObj);
        if (hr == S_OK)
        {
            m_cbRefCount = 0;
        }
        else
        {
            // this would delete this object
            Release();
        }
        
    }

    virtual ~ApartmentTearDownHandler()
    {
        if (m_pMarshalerObj != NULL)
        {
            DWORD cbRef = SafeRelease(m_pMarshalerObj);
            LogInteropRelease(m_pMarshalerObj, cbRef, "pMarshaler object");
        }
    }

    STDMETHODIMP    QueryInterface( REFIID iid, void **ppv);
    
    STDMETHODIMP_(ULONG)    AddRef()
    {
        INTPTR      l = FastInterlockIncrement((LONG*)&m_cbRefCount);
        return l;
    }
    STDMETHODIMP_(ULONG)    Release()
    {
        INTPTR      l = FastInterlockDecrement((LONG*)&m_cbRefCount);
        if (l == 0)
            delete this;
        return l;
    }

    STDMETHODIMP TeardownHint(void)
    {
        return HandleApartmentShutDown();
    }
};

// ---------------------------------------------------------------------------
// %%Function: QueryInterface   
// ---------------------------------------------------------------------------
STDMETHODIMP ApartmentTearDownHandler::QueryInterface(
    REFIID iid,
    void **ppv)
{
    if (ppv == NULL)
        return E_POINTER;

    *ppv = NULL;

    if (iid == IID_ITeardownNotification || 
        iid == IID_IUnknown)
    {
        *ppv = (IClassFactory2 *)this;
        AddRef();
    }
    else
    if (iid == IID_IMarshal)
    {
        // delegate the IMarshal Queries
        return m_pMarshalerObj->QueryInterface(iid, ppv);
    }

    return (*ppv != NULL) ? S_OK : E_NOINTERFACE;
}  // ApartmentTearDownHandler::QueryInterface


//----------------------------------------------------------------------------
// %%Function: SystemHasNewOle32()
// 
// Parameters:
//   none
//
// Returns:
//  TRUE if new ole32, false otherwise
//
// Description:
//  Used to see if system has dave's ole32 api additions.
//----------------------------------------------------------------------------
BOOL SystemHasNewOle32()
{
    static BOOL called = FALSE;
    static BOOL hasNew = FALSE;
    if(RunningOnWinNT5() && !called)
    {
        HMODULE hMod = WszLoadLibrary(L"ole32.dll");
        if(!hMod)
        {
            hasNew = FALSE;
        }
        else
        {

            //OLE32CoGetIdentity = (HRESULT (*)(IUnknown*, IUnknown**, IUnknown**))GetProcAddress(hMod,"CoGetIdentity");
			OLE32CoGetContextToken = (HRESULT (*)(ULONG_PTR*))GetProcAddress(hMod, "CoGetContextToken");			
           
            if(OLE32CoGetContextToken)
            {            
                hasNew = TRUE;                
            }
            else
            {
                hasNew = FALSE;
            }
            
            FreeLibrary(hMod);
        }

        // setup tear-down notification
        
        
        called = TRUE;
    }
    return(hasNew);
}



//----------------------------------------------------------------------------
// %%Function: GetFastContextCookie()
// 
// Parameters:
//   none
//
// Returns:
//  Nothing
//
//----------------------------------------------------------------------------

ULONG_PTR GetFastContextCookie()
{

    ULONG_PTR ctxptr = 0;
    HRESULT hr = S_OK;
    if (SystemHasNewOle32())
    {    
        _ASSERTE(OLE32CoGetContextToken);    
        hr = OLE32CoGetContextToken(&ctxptr);
        if (hr != S_OK)
        {           
            ctxptr = 0;
        }
    }    
    return ctxptr;
}


static IComApartmentState* g_pApartmentState = NULL;
static ULONG_PTR      g_TDCookie = 0;
    
HRESULT SetupTearDownNotifications()
{
	HRESULT hr =  S_OK;
    static BOOL fTearDownCalled = FALSE;
    // check if we already have setup a notification
    if (fTearDownCalled == TRUE)
    {
        return S_OK;
    }
        
    fTearDownCalled = TRUE;        

	if (SystemHasNewOle32())
	{
        BEGIN_ENSURE_PREEMPTIVE_GC();
        {
		    IComApartmentState* pAptState = NULL;
		    //  instantiate the notifier
		    hr = CoCreateInstance(CLSID_ComApartmentState, NULL, CLSCTX_ALL, IID_IComApartmentState, (VOID **)&pAptState);
		    if (hr == S_OK)
		    {
			    IComApartmentState* pPrevAptState = (IComApartmentState*)FastInterlockCompareExchange((void**)&g_pApartmentState, (void*) pAptState, NULL);
			    if (pPrevAptState == NULL)
			    {
				    _ASSERTE(g_pApartmentState);
				    ApartmentTearDownHandler* pTDHandler = new ApartmentTearDownHandler(hr);
				    if (hr == S_OK)
				    {
					    ITeardownNotification* pITD = NULL;
					    hr = pTDHandler->QueryInterface(IID_ITeardownNotification, (void **)&pITD);
					    _ASSERTE(hr == S_OK && pITD != NULL);
					    g_pApartmentState->RegisterForTeardownHint(pITD, 0, &g_TDCookie); 
					    pITD->Release();
				    }         
				    else
				    {
					    // oops we couldn't create our handler
					    // release the global apstate pointer
					    if (g_pApartmentState != NULL)
					    {
						    g_pApartmentState->Release();
						    g_pApartmentState = NULL;
					    }
				    }
			    }
			    else
			    {
				    // somebody beat us to it
				    if (pAptState)
					    pAptState->Release();        
			    }
    		}
        }
        END_ENSURE_PREEMPTIVE_GC();
    }        
    return S_OK;
}

VOID RemoveTearDownNotifications()
{
    if (g_pApartmentState != NULL)
    {
        _ASSERTE(g_TDCookie != 0);
        g_pApartmentState->UnregisterForTeardownHint(g_TDCookie);
        g_pApartmentState->Release();
        g_pApartmentState = NULL;
        g_TDCookie = 0;
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\nsenums.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// NSENUMS.H -
//
// Defines NStruct-related enums
//

// NStruct Field Type's
//
// Columns:
//    Name            - name of enum
//    Size            - the native size (in bytes) of the field.
//                      for some fields, this value cannot be computed
//                      without more information. if so, put a zero here
//                      and make sure CollectNStructFieldMetadata()
//                      has code to compute the size.
//
//         Name (COM+ - Native)   Size
DEFINE_NFT(NFT_NONE,              0)

DEFINE_NFT(NFT_BSTR,              sizeof(BSTR))
DEFINE_NFT(NFT_STRINGUNI,         sizeof(LPVOID))
DEFINE_NFT(NFT_STRINGANSI,        sizeof(LPVOID))
DEFINE_NFT(NFT_FIXEDSTRINGUNI,    0)

DEFINE_NFT(NFT_FIXEDSTRINGANSI,   0)
DEFINE_NFT(NFT_FIXEDCHARARRAYANSI,0)
DEFINE_NFT(NFT_FIXEDBOOLARRAY    ,0)
DEFINE_NFT(NFT_FIXEDBSTRARRAY,    0)
DEFINE_NFT(NFT_FIXEDSCALARARRAY,  0)
DEFINE_NFT(NFT_SAFEARRAY,         0)

DEFINE_NFT(NFT_DELEGATE,          sizeof(LPVOID))
DEFINE_NFT(NFT_INTERFACE,         sizeof(IUnknown*))
DEFINE_NFT(NFT_VARIANT,           sizeof(VARIANT))

DEFINE_NFT(NFT_COPY1,             1)
DEFINE_NFT(NFT_COPY2,             2)
DEFINE_NFT(NFT_COPY4,             4)
DEFINE_NFT(NFT_COPY8,             8)

DEFINE_NFT(NFT_ANSICHAR,          1)
DEFINE_NFT(NFT_WINBOOL,           sizeof(BOOL))

DEFINE_NFT(NFT_NESTEDLAYOUTCLASS, 0)
DEFINE_NFT(NFT_NESTEDVALUECLASS,  0)

DEFINE_NFT(NFT_CBOOL,             1)

DEFINE_NFT(NFT_DECIMAL,           sizeof(DECIMAL))
DEFINE_NFT(NFT_DATE,              sizeof(DATE))
DEFINE_NFT(NFT_VARIANTBOOL,       sizeof(VARIANT_BOOL))

DEFINE_NFT(NFT_CURRENCY,          sizeof(CURRENCY))

DEFINE_NFT(NFT_ILLEGAL,           1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\object.inl ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// OBJECT.INL
//
// Definitions inline functions of a Com+ Object
//

#ifndef _OBJECT_INL_
#define _OBJECT_INL_

#include "object.h"

inline DWORD Object::GetAppDomainIndex()
{
#ifndef _DEBUG
    // ok to cast to AppDomain because we know it's a real AppDomain if it's not shared
    if (!GetMethodTable()->IsShared())
        return ((AppDomain*)GetMethodTable()->GetModule()->GetDomain())->GetIndex();
#endif
        return GetHeader()->GetAppDomainIndex();
}

#endif _OBJECT_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\nstruct.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*  NSTRUCT.CPP:
 *
 */

#include "common.h"
#include "vars.hpp"
#include "class.h"
#include "ceeload.h"
#include "excep.h"
#include "nstruct.h"
#include "corjit.h"
#include "ComString.h"
#include "field.h"
#include "frames.h"
#include "gcscan.h"
#include "ndirect.h"
#include "COMDelegate.h"
#include "EEConfig.h"
#include "comdatetime.h"
#include "olevariant.h"

#include <cor.h>
#include <corpriv.h>
#include <CorError.h>

#ifdef CUSTOMER_CHECKED_BUILD
    #include "SigFormat.h"
    #include "CustomerDebugHelper.h"

    // forward declaration
    VOID OutputCustomerCheckedBuildNStructFieldType(FieldSig fSig, LayoutRawFieldInfo *const pFWalk, CorElementType elemType,
                                                    LPCUTF8 szNamespace, LPCUTF8 szStructName, LPCUTF8 szFieldName);
    VOID NStructFieldTypeToString(LayoutRawFieldInfo *const pFWalk, CorElementType elemType, CQuickArray<WCHAR> *pStrNStructFieldType);
    BOOL CheckForPrimitiveType(CorElementType elemType, CQuickArray<WCHAR> *pStrPrimitiveType);
#endif // CUSTOMER_CHECKED_BUILD

BOOL IsStructMarshalable(EEClass *pcls);  //From COMNDirect.cpp


//=======================================================================
// A database of NFT types.
//=======================================================================
struct NFTDataBaseEntry {
    UINT32            m_cbNativeSize;     // native size of field (0 if not constant)
};

NFTDataBaseEntry NFTDataBase[] =
{
#undef DEFINE_NFT
#define DEFINE_NFT(name, nativesize) { nativesize },
#include "nsenums.h"
};




//=======================================================================
// This is invoked from the class loader while building a EEClass.
// This function should check if explicit layout metadata exists.
//
// Returns:
//  S_OK    - yes, there's layout metadata
//  S_FALSE - no, there's no layout.
//  fail    - couldn't tell because of metadata error
//
// If S_OK,
//   *pNLType            gets set to nltAnsi or nltUnicode
//   *pPackingSize       declared packing size
//   *pfExplicitoffsets  offsets explicit in metadata or computed?
//=======================================================================
HRESULT HasLayoutMetadata(IMDInternalImport *pInternalImport, mdTypeDef cl, EEClass *pParentClass, BYTE *pPackingSize, BYTE *pNLTType, BOOL *pfExplicitOffsets, BOOL *pfIsBlob)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    *pfIsBlob = FALSE;

//    if (pParentClass && pParentClass->HasLayout()) {
//       *pPackingSize      = pParentClass->GetLayoutInfo()->GetDeclaredPackingSize();
//        *pNLTType          = pParentClass->GetLayoutInfo()->GetNLType();
//        *pfExplicitOffsets = !(pParentClass->GetLayoutInfo()->IsAutoOffset());
//        return S_OK;
//    }


    HRESULT hr;
    ULONG clFlags;
#ifdef _DEBUG
    clFlags = 0xcccccccc;
#endif


    pInternalImport->GetTypeDefProps(
        cl,     
        &clFlags,
        NULL);

    if (IsTdAutoLayout(clFlags)) {


        {
            // HACK for B#104780 - VC fails to set SequentialLayout on some classes
            // with ClassSize. Too late to fix compiler for V1.
            //
            // To compensate, we treat AutoLayout classes as Sequential if they
            // meet all of the following criteria:
            //
            //    - ClassSize present and nonzero.
            //    - No instance fields declared
            //    - Base class is System.ValueType.
            //
            ULONG cbTotalSize = 0;
            if (SUCCEEDED(pInternalImport->GetClassTotalSize(cl, &cbTotalSize)) && cbTotalSize != 0)
            {
                if (pParentClass && pParentClass->IsValueTypeClass())
                {
                    HENUMInternal hEnumField;
                    HRESULT hr;
                    hr = pInternalImport->EnumInit(mdtFieldDef, cl, &hEnumField);
                    if (SUCCEEDED(hr))
                    {
                        ULONG numFields = pInternalImport->EnumGetCount(&hEnumField);
                        pInternalImport->EnumClose(&hEnumField);
                        if (numFields == 0)
                        {
                            *pfExplicitOffsets = FALSE;
                            *pNLTType = nltAnsi;
                            *pPackingSize = 1;
                            return S_OK;
                        }
                    }
                }
            }
        }

        return S_FALSE;
    } else if (IsTdSequentialLayout(clFlags)) {
        *pfExplicitOffsets = FALSE;
    } else if (IsTdExplicitLayout(clFlags)) {
        *pfExplicitOffsets = TRUE;
    } else {
        BAD_FORMAT_ASSERT(!"Wrapper classes must be SequentialLayout or ExplicitLayout");
        return COR_E_TYPELOAD;
    }

    // We now know this class has seq. or explicit layout. Ensure the parent does too.
    if (pParentClass && !(pParentClass->IsObjectClass() || pParentClass->IsValueTypeClass()) && !(pParentClass->HasLayout()))
    {
        BAD_FORMAT_ASSERT(!"Layout class must derive from Object or another layout class");
        return COR_E_TYPELOAD;
    }

    if (IsTdAnsiClass(clFlags)) {
        *pNLTType = nltAnsi;
    } else if (IsTdUnicodeClass(clFlags)) {
        *pNLTType = nltUnicode;
    } else if (IsTdAutoClass(clFlags)) {
        *pNLTType = (NDirectOnUnicodeSystem() ? nltUnicode : nltAnsi);
    } else {
        BAD_FORMAT_ASSERT(!"Bad stringformat value in wrapper class.");
        return COR_E_TYPELOAD;
    }

    DWORD dwPackSize;
    hr = pInternalImport->GetClassPackSize(cl, &dwPackSize);
    if (FAILED(hr) || dwPackSize == 0) {
        dwPackSize = DEFAULT_PACKING_SIZE;
    }
    *pPackingSize = (BYTE)dwPackSize;
    //printf("Packsize = %lu\n", dwPackSize);

    return S_OK;
}


HRESULT GetCoClassForInterfaceHelper(EEClass *pItfClass, EEClass **ppClass)
{
    HRESULT hr = S_FALSE;

    _ASSERTE(pItfClass);
    _ASSERTE(ppClass);

    COMPLUS_TRY {
        *ppClass = pItfClass->GetCoClassForInterface();
        if (*ppClass)
            hr = S_OK;
    } COMPLUS_CATCH {
        hr = SetupErrorInfo(GETTHROWABLE());
    } COMPLUS_END_CATCH

    return hr;
}


#ifdef _DEBUG
#define REDUNDANCYWARNING(when) if (when) LOG((LF_SLOP, LL_INFO100, "%s.%s: Redundant nativetype metadata.\n", szClassName, szFieldName))
#else
#define REDUNDANCYWARNING(when)
#endif



HRESULT ParseNativeType(Module *pModule,
                        PCCOR_SIGNATURE     pCOMSignature,
                        BYTE nlType,      // nltype (from @dll.struct)
                        LayoutRawFieldInfo * const pfwalk,
                        PCCOR_SIGNATURE     pNativeType,
                        ULONG               cbNativeType,
                        IMDInternalImport  *pInternalImport,
                        mdTypeDef           cl,
                        OBJECTREF          *pThrowable
#ifdef _DEBUG
                        ,
                        LPCUTF8             szNamespace,
                        LPCUTF8             szClassName,
                        LPCUTF8             szFieldName
#endif

)
{
    CANNOTTHROWCOMPLUSEXCEPTION();


#define INITFIELDMARSHALER(nfttype, fmtype, args) \
do {\
_ASSERTE(sizeof(fmtype) <= MAXFIELDMARSHALERSIZE);\
pfwalk->m_nft = (nfttype); \
new ( &(pfwalk->m_FieldMarshaler) ) fmtype args;\
} while(0)

    BOOL fAnsi      = (nlType == nltAnsi);

#ifdef CUSTOMER_CHECKED_BUILD
    CorElementType corElemType  = ELEMENT_TYPE_END;  // initialize it something we will not use
#endif // CUSTOMER_CHECKED_BUILD

    pfwalk->m_nft = NFT_NONE;

    PCCOR_SIGNATURE pNativeTypeStart = pNativeType;
    ULONG cbNativeTypeStart = cbNativeType;

    BYTE ntype;
    BOOL  fDefault;
    if (cbNativeType == 0) {
        ntype = NATIVE_TYPE_MAX;
        fDefault = TRUE;
    } else {
        ntype = *( ((BYTE*&)pNativeType)++ );
        cbNativeType--;
        fDefault = FALSE;
    }


    FieldSig fsig(pCOMSignature, pModule);
#ifdef CUSTOMER_CHECKED_BUILD
    corElemType = fsig.GetFieldTypeNormalized();
    switch (corElemType) {
#else
    switch (fsig.GetFieldTypeNormalized()) {
#endif

        case ELEMENT_TYPE_CHAR:
            if (fDefault) {
                    if (fAnsi) {
                        BOOL BestFit;
                        BOOL ThrowOnUnmappableChar;
                        ReadBestFitCustomAttribute(pInternalImport, cl, &BestFit, &ThrowOnUnmappableChar);
                        
                        INITFIELDMARSHALER(NFT_ANSICHAR, FieldMarshaler_Ansi, (BestFit, ThrowOnUnmappableChar));
                    } else {
                        INITFIELDMARSHALER(NFT_COPY2, FieldMarshaler_Copy2, ());
                    }
            } else if (ntype == NATIVE_TYPE_I1 || ntype == NATIVE_TYPE_U1) {

                    REDUNDANCYWARNING( fAnsi );
                    BOOL BestFit;
                    BOOL ThrowOnUnmappableChar;
                    ReadBestFitCustomAttribute(pInternalImport, cl, &BestFit, &ThrowOnUnmappableChar);

                    INITFIELDMARSHALER(NFT_ANSICHAR, FieldMarshaler_Ansi, (BestFit, ThrowOnUnmappableChar));
            } else if (ntype == NATIVE_TYPE_I2 || ntype == NATIVE_TYPE_U2) {
                    REDUNDANCYWARNING( !fAnsi );
                    INITFIELDMARSHALER(NFT_COPY2, FieldMarshaler_Copy2, ());
            } else {
                    INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_CHAR));
            }
            break;

        case ELEMENT_TYPE_BOOLEAN:
            if (fDefault) {
                    INITFIELDMARSHALER(NFT_WINBOOL, FieldMarshaler_WinBool, ());
            } else if (ntype == NATIVE_TYPE_BOOLEAN) {
                    REDUNDANCYWARNING(TRUE);
                    INITFIELDMARSHALER(NFT_WINBOOL, FieldMarshaler_WinBool, ());
            } else if (ntype == NATIVE_TYPE_VARIANTBOOL) {
                    INITFIELDMARSHALER(NFT_VARIANTBOOL, FieldMarshaler_VariantBool, ());
            } else if (ntype == NATIVE_TYPE_U1 || ntype == NATIVE_TYPE_I1) {
                    INITFIELDMARSHALER(NFT_CBOOL, FieldMarshaler_CBool, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_BOOLEAN));
            }
            break;


        case ELEMENT_TYPE_I1:
            if (fDefault || ntype == NATIVE_TYPE_I1 || ntype == NATIVE_TYPE_U1) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY1, FieldMarshaler_Copy1, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_I1));
            }
            break;

        case ELEMENT_TYPE_U1:
            if (fDefault || ntype == NATIVE_TYPE_U1 || ntype == NATIVE_TYPE_I1) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY1, FieldMarshaler_Copy1, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_I1));
            }
            break;

        case ELEMENT_TYPE_I2:
            if (fDefault || ntype == NATIVE_TYPE_I2 || ntype == NATIVE_TYPE_U2) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY2, FieldMarshaler_Copy2, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_I2));
            }
            break;

        case ELEMENT_TYPE_U2:
            if (fDefault || ntype == NATIVE_TYPE_U2 || ntype == NATIVE_TYPE_I2) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY2, FieldMarshaler_Copy2, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_I2));
            }
            break;

        case ELEMENT_TYPE_I4:
            if (fDefault || ntype == NATIVE_TYPE_I4 || ntype == NATIVE_TYPE_U4 || ntype == NATIVE_TYPE_ERROR) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY4, FieldMarshaler_Copy4, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_I4));
            }
            break;
        case ELEMENT_TYPE_U4:
            if (fDefault || ntype == NATIVE_TYPE_U4 || ntype == NATIVE_TYPE_I4 || ntype == NATIVE_TYPE_ERROR) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY4, FieldMarshaler_Copy4, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_I4));
            }
            break;

        case ELEMENT_TYPE_I8:
            if (fDefault || ntype == NATIVE_TYPE_I8 || ntype == NATIVE_TYPE_U8) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY8, FieldMarshaler_Copy8, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_I8));
            }
            break;

        case ELEMENT_TYPE_U8:
            if (fDefault || ntype == NATIVE_TYPE_U8 || ntype == NATIVE_TYPE_I8) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY8, FieldMarshaler_Copy8, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_I8));
            }
            break;

        case ELEMENT_TYPE_I: //fallthru
        case ELEMENT_TYPE_U:
            if (fDefault || ntype == NATIVE_TYPE_INT || ntype == NATIVE_TYPE_UINT) {
                REDUNDANCYWARNING(!fDefault);
                if (sizeof(LPVOID)==4) {
                    INITFIELDMARSHALER(NFT_COPY4, FieldMarshaler_Copy4, ());
                } else {
                    INITFIELDMARSHALER(NFT_COPY8, FieldMarshaler_Copy8, ());
                }
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_I));
            }
            break;

        case ELEMENT_TYPE_R4:
            if (fDefault || ntype == NATIVE_TYPE_R4) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY4, FieldMarshaler_Copy4, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_R4));
            }
            break;
        case ELEMENT_TYPE_R8:
            if (fDefault || ntype == NATIVE_TYPE_R8) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY8, FieldMarshaler_Copy8, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_R8));
            }
            break;

        case ELEMENT_TYPE_R:
            if (fDefault) {
                REDUNDANCYWARNING(!fDefault);
                INITFIELDMARSHALER(NFT_COPY8, FieldMarshaler_Copy8, ());
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_R));
            }
            break;

        case ELEMENT_TYPE_PTR:
            if (fDefault) {
                REDUNDANCYWARNING(!fDefault);
                switch (sizeof(LPVOID)) {
                    case 4:
                            INITFIELDMARSHALER(NFT_COPY4, FieldMarshaler_Copy4, ());
                        break;
                    case 8:
                            INITFIELDMARSHALER(NFT_COPY8, FieldMarshaler_Copy8, ());
                        break;
                    default:
                        ;
                }
            } else {
                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_PTR));
            }
            break;

        case ELEMENT_TYPE_VALUETYPE: {
                EEClass *pNestedClass = fsig.GetTypeHandle(pThrowable).GetClass();
                if (!pNestedClass) {
                    return E_OUTOFMEMORY;
                } else {
                    if ((fDefault || ntype == NATIVE_TYPE_STRUCT) && fsig.IsClass(g_DateClassName)) {
                        REDUNDANCYWARNING(!fDefault);
                        INITFIELDMARSHALER(NFT_DATE, FieldMarshaler_Date, ());
                    } else if ((fDefault || ntype == NATIVE_TYPE_STRUCT || ntype == NATIVE_TYPE_CURRENCY) && fsig.IsClass(g_DecimalClassName)) {
                        REDUNDANCYWARNING(!fDefault && ntype == NATIVE_TYPE_STRUCT);
                        if (ntype == NATIVE_TYPE_CURRENCY)
                        {
                            INITFIELDMARSHALER(NFT_CURRENCY, FieldMarshaler_Currency, ());
                        }
                        else
                        {
                            INITFIELDMARSHALER(NFT_DECIMAL, FieldMarshaler_Decimal, ());
                        }
                    } else if ((fDefault || ntype == NATIVE_TYPE_STRUCT) && pNestedClass->HasLayout() && IsStructMarshalable(pNestedClass)) {
                        REDUNDANCYWARNING(!fDefault);
                        INITFIELDMARSHALER(NFT_NESTEDVALUECLASS, FieldMarshaler_NestedValueClass, (pNestedClass->GetMethodTable()));
                    } else {
                        if (!(pNestedClass->HasLayout()) || !IsStructMarshalable(pNestedClass)) {
                            INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_NOLAYOUT));
                        } else {
                            INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (ntype == NATIVE_TYPE_LPSTRUCT ? IDS_EE_BADPINVOKEFIELD_NOLPSTRUCT : IDS_EE_BADPINVOKEFIELD_CLASS));
                        }
                    }
                }
            }
            break;

        case ELEMENT_TYPE_CLASS: {
                // review is this correct for arrays?
                TypeHandle pNestedTH = fsig.GetTypeHandle(pThrowable);
                EEClass *pNestedClass = pNestedTH.GetClass();
                if (!pNestedClass) {
                    if (pThrowableAvailable(pThrowable))
                        *pThrowable = NULL;
                    INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD));
                } else {

                    if ((pNestedClass->IsObjectClass() || GetAppDomain()->IsSpecialObjectClass(pNestedClass->GetMethodTable())) && 
                        (fDefault || ntype == NATIVE_TYPE_IDISPATCH || ntype == NATIVE_TYPE_IUNKNOWN)) {

                        INITFIELDMARSHALER(NFT_INTERFACE, FieldMarshaler_Interface, (NULL, NULL, ntype == NATIVE_TYPE_IDISPATCH, FALSE));
                    }

                    else if (ntype == NATIVE_TYPE_INTF || pNestedClass->IsInterface()) {

                        MethodTable *pClassMT = NULL;
                        MethodTable *pItfMT = NULL;
                        BOOL fDispItf = FALSE;
                        BOOL fClassIsHint = FALSE;

                        if (!pNestedClass->IsInterface()) {

                            // Set the class method table.
                            pClassMT = pNestedClass->GetMethodTable();

                            // Retrieve the default interface method table.
                            TypeHandle hndDefItfClass;
                            DefaultInterfaceType DefItfType;
                            HRESULT hr = TryGetDefaultInterfaceForClass(TypeHandle(pNestedClass), &hndDefItfClass, &DefItfType);

                            // If we failed to retrieve the default interface, then we can't
                            // marshal this struct.
                            if (FAILED(hr))  
                            {
                                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD));
                                break;
                            }

                            // Retrieve the interace MT and the type of the default interface.
                            switch (DefItfType) {

                                case DefaultInterfaceType_Explicit: {
                                    pItfMT = hndDefItfClass.GetMethodTable();
                                    fDispItf = (hndDefItfClass.GetMethodTable()->GetComInterfaceType() != ifVtable);
                                    break;
                                }

                                case DefaultInterfaceType_AutoDual: {
                                    pItfMT = hndDefItfClass.GetMethodTable();
                                    fDispItf = TRUE;
                                    break;
                                }

                                case DefaultInterfaceType_IUnknown:
                                case DefaultInterfaceType_BaseComClass: {
                                    fDispItf = FALSE;
                                    break;
                                }

                                case DefaultInterfaceType_AutoDispatch: {
                                    fDispItf = TRUE;
                                    break;
                                }

                                default: {
                                    _ASSERTE(!"Invalid default interface type!");
                                    break;
                                }
                            }
                        }
                        else {

                            // Set the interface method table and the flag indicating if we are dealing with 
                            // a disp interface.
                            if (pNestedClass->IsComClassInterface())
                            {
                                pItfMT = pNestedClass->GetDefItfForComClassItf()->GetMethodTable();
                                fDispItf = (pItfMT->GetComInterfaceType() != ifVtable); 
                            }
                            else
                            {
                                pItfMT = pNestedClass->GetMethodTable();
                                fDispItf = (pItfMT->GetComInterfaceType() != ifVtable); 
                            }

                            // Look to see if the interface has a coclass defined
                            EEClass *pClass = NULL;
                            HRESULT hr = GetCoClassForInterfaceHelper(pNestedClass, &pClass);
                            if (hr == S_OK) {
                                _ASSERTE(pClass);
                                fClassIsHint = TRUE;
                                pClassMT = pClass->GetMethodTable();
                            } else if (FAILED(hr)) {
                                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD));
                            }
                        }

                        INITFIELDMARSHALER(NFT_INTERFACE, FieldMarshaler_Interface, (pClassMT, pItfMT, fDispItf, fClassIsHint));

                    } else {
    
                        if (ntype == NATIVE_TYPE_CUSTOMMARSHALER)
                        {
                            INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_NOCUSTOM));
                        }
    
                        if (pNestedClass == g_pStringClass->GetClass()) {
                            if (fDefault) {
                                if (fAnsi) {
                                    BOOL BestFit;
                                    BOOL ThrowOnUnmappableChar;
                                    ReadBestFitCustomAttribute(pInternalImport, cl, &BestFit, &ThrowOnUnmappableChar);

                                    INITFIELDMARSHALER(NFT_STRINGANSI, FieldMarshaler_StringAnsi, (BestFit, ThrowOnUnmappableChar));
                                } else {
                                    INITFIELDMARSHALER(NFT_STRINGUNI, FieldMarshaler_StringUni, ());
                                }
                            } else {
                                switch (ntype) {
                                    case NATIVE_TYPE_LPSTR:
                                        REDUNDANCYWARNING(fAnsi);
                                        
                                        BOOL BestFit;
                                        BOOL ThrowOnUnmappableChar;
                                        ReadBestFitCustomAttribute(pInternalImport, cl, &BestFit, &ThrowOnUnmappableChar);

                                        INITFIELDMARSHALER(NFT_STRINGANSI, FieldMarshaler_StringAnsi, (BestFit, ThrowOnUnmappableChar));
                                        break;
                                    case NATIVE_TYPE_LPWSTR:
                                        REDUNDANCYWARNING(!fAnsi);
                                        INITFIELDMARSHALER(NFT_STRINGUNI, FieldMarshaler_StringUni, ());
                                        break;
                                    case NATIVE_TYPE_LPTSTR:
                                        if (NDirectOnUnicodeSystem()) {
                                            INITFIELDMARSHALER(NFT_STRINGUNI, FieldMarshaler_StringUni, ());
                                        } else {
                                            BOOL BestFit;
                                            BOOL ThrowOnUnmappableChar;
                                            ReadBestFitCustomAttribute(pInternalImport, cl, &BestFit, &ThrowOnUnmappableChar);
           
                                            INITFIELDMARSHALER(NFT_STRINGANSI, FieldMarshaler_StringAnsi, (BestFit, ThrowOnUnmappableChar));
                                        }
                                        break;
                                    case NATIVE_TYPE_BSTR:
                                        INITFIELDMARSHALER(NFT_BSTR, FieldMarshaler_BSTR, ());
                                        break;
                                    case NATIVE_TYPE_FIXEDSYSSTRING:
                                        {
                                            ULONG nchars;
                                            ULONG udatasize = CorSigUncompressedDataSize(pNativeType);

                                            if (cbNativeType < udatasize) {
                                                return E_FAIL;
                                            }
                                            nchars = CorSigUncompressData(pNativeType);
                                            cbNativeType -= udatasize;
        
                                            if (nchars == 0) {
                                                return E_FAIL;
                                            }
        
            
                                            if (fAnsi) {
                                                BOOL BestFit;
                                                BOOL ThrowOnUnmappableChar;
                                                ReadBestFitCustomAttribute(pInternalImport, cl, &BestFit, &ThrowOnUnmappableChar);
                                                
                                                INITFIELDMARSHALER(NFT_FIXEDSTRINGANSI, FieldMarshaler_FixedStringAnsi, (nchars, BestFit, ThrowOnUnmappableChar));
                                            } else {
                                                INITFIELDMARSHALER(NFT_FIXEDSTRINGUNI, FieldMarshaler_FixedStringUni, (nchars));
                                            }
                                        }
                                        break;
                                    default:
                                        INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_STRING));
                                        break;
                                }
                            }
                        } else if (pNestedClass->IsObjectClass() && ntype == NATIVE_TYPE_STRUCT) {
                            INITFIELDMARSHALER(NFT_VARIANT, FieldMarshaler_Variant, ());
                        } else if (pNestedClass->GetMethodTable() == g_pArrayClass)  {           
                            if (ntype == NATIVE_TYPE_SAFEARRAY)
                            {
                                NativeTypeParamInfo ParamInfo;

                                CorElementType etyp = ELEMENT_TYPE_OBJECT;
                                MethodTable* pMT = NULL;

                                // If we have no native type data, assume default behavior
                                if (cbNativeType == 0)
                                {
                                    INITFIELDMARSHALER(NFT_SAFEARRAY, FieldMarshaler_SafeArray, (etyp, VT_EMPTY, NULL));
                                    break;
                                }
              
                                // Check for the safe array element type.
                                if (S_OK != CheckForCompressedData(pNativeTypeStart, pNativeType, cbNativeTypeStart))
                                    break;

                                ParamInfo.m_SafeArrayElementVT = (VARTYPE) (CorSigUncompressData(/*modifies*/pNativeType));

                                // Extract the name of the record type's.
                                if (S_OK == CheckForCompressedData(pNativeTypeStart, pNativeType, cbNativeTypeStart))
                                {
                                    int strLen = CPackedLen::GetLength(pNativeType, (void const **)&pNativeType);
                                    if (pNativeType + strLen < pNativeType ||
                                        pNativeType + strLen > pNativeTypeStart + cbNativeTypeStart)
                                    {
                                        INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_BADMETADATA)); 
                                        break;
                                    }
                                    
                                    ParamInfo.m_strSafeArrayUserDefTypeName = (LPUTF8)pNativeType;
                                    ParamInfo.m_cSafeArrayUserDefTypeNameBytes = strLen;
                                    _ASSERTE((ULONG)(pNativeType + strLen - pNativeTypeStart) == cbNativeTypeStart);
                                }

                                // If we have a record type name, try to load it.
                                if (ParamInfo.m_cSafeArrayUserDefTypeNameBytes > 0)
                                {
                                    pMT = ArraySubTypeLoadWorker(ParamInfo, pModule->GetAssembly());
                                    if (!pMT)
                                    {
                                        INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_CANTLOADSUBTYPE)); 
                                        break;
                                    }
                                    etyp = pMT->GetNormCorElementType();
                                }

                                INITFIELDMARSHALER(NFT_SAFEARRAY, FieldMarshaler_SafeArray, (etyp, ParamInfo.m_SafeArrayElementVT, pMT));
                            }
                            else if (ntype == NATIVE_TYPE_FIXEDARRAY)
                            {
                                ULONG NumElements;
                                CorNativeType ElementType;
                                
                                // If we have no native type data, we fail.
                                if (cbNativeType == 0)
                                    break;
                                    
                                // Check for the number of elements
                                if (S_OK != CheckForCompressedData(pNativeTypeStart, pNativeType, cbNativeTypeStart))
                                    break;
                                NumElements = CorSigUncompressData(/*modifies*/pNativeType);

                                // Extract the element type
                                if (S_OK != CheckForCompressedData(pNativeTypeStart, pNativeType, cbNativeTypeStart))
                                    break;
                                ElementType = (CorNativeType)CorSigUncompressData(/*modifies*/pNativeType);

                                INITFIELDMARSHALER(NFT_FIXEDBSTRARRAY, FieldMarshaler_FixedBSTRArray, (NumElements));
                            }

                        } else if (COMDelegate::IsDelegate(pNestedClass)) {
                            if ( (fDefault || ntype == NATIVE_TYPE_FUNC ) ) {
                                REDUNDANCYWARNING(!fDefault);
                                INITFIELDMARSHALER(NFT_DELEGATE, FieldMarshaler_Delegate, ());
                            } else {
                                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_DELEGATE));
                            }
                        } else if (pNestedClass->HasLayout() && IsStructMarshalable(pNestedClass)) {
                            if ( (fDefault || ntype == NATIVE_TYPE_STRUCT ) ) {
                                INITFIELDMARSHALER(NFT_NESTEDLAYOUTCLASS, FieldMarshaler_NestedLayoutClass, (pNestedClass->GetMethodTable()));
                            } else {
                                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (ntype == NATIVE_TYPE_LPSTRUCT ? IDS_EE_BADPINVOKEFIELD_NOLPSTRUCT : IDS_EE_BADPINVOKEFIELD_CLASS));
                            }
                        } else {
                            if (fsig.IsClass("System.Text.StringBuilder"))
                            {
                                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_NOSTRINGBUILDERFIELD));
                            }
                            else
                            {
                                INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD_NOLAYOUT));
                            }
                        }
                    }
                }
            }
            break;

        case ELEMENT_TYPE_SZARRAY: {
            SigPointer elemType;
            ULONG      elemCount;
            fsig.GetProps().GetSDArrayElementProps(&elemType, &elemCount);
            CorElementType etyp = elemType.PeekElemType();

            if ((ntype == NATIVE_TYPE_SAFEARRAY) || (ntype == NATIVE_TYPE_MAX)){

                VARTYPE vt = VT_EMPTY;
                TypeHandle th;
                
                th = elemType.GetTypeHandle(pModule, pThrowable);
                if (th.IsNull())
                    break;
                    
                MethodTable* pMT = th.GetMethodTable();

                // Check for data remaining in the signature before we attempt to grab some.
                if (S_OK == CheckForCompressedData(pNativeTypeStart, pNativeType, cbNativeTypeStart))
                {
                    vt = (VARTYPE) (CorSigUncompressData(/*modifies*/pNativeType));
                    if (vt == VT_EMPTY)
                        break;
                }

                if (vt == VT_EMPTY)
                    vt = ArrayVarTypeFromTypeHandleWorker(th);

                INITFIELDMARSHALER(NFT_SAFEARRAY, FieldMarshaler_SafeArray, (etyp, vt, pMT));
                break;
            }
            

            else if (ntype == NATIVE_TYPE_FIXEDARRAY) {

                ULONG nelems;
                ULONG udatasize = CorSigUncompressedDataSize(pNativeType);

                if (cbNativeType < udatasize) {
                    return E_FAIL;
                }
                nelems = CorSigUncompressData(pNativeType);
                cbNativeType -= udatasize;

                if (nelems == 0) {
                    return E_FAIL;
                }

                switch (etyp) {
                    case ELEMENT_TYPE_I1:
                        INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_I1, nelems, 0));
                        break;

                    case ELEMENT_TYPE_U1:
                        INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_U1, nelems, 0));
                        break;

                    case ELEMENT_TYPE_I2:
                        INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_I2, nelems, 1));
                        break;

                    case ELEMENT_TYPE_U2:
                        INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_U2, nelems, 1));
                        break;

                    IN_WIN32(case ELEMENT_TYPE_I:)
                    case ELEMENT_TYPE_I4:
                        INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_I4, nelems, 2));
                        break;

                    IN_WIN32(case ELEMENT_TYPE_U:)
                    case ELEMENT_TYPE_U4:
                        INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_U4, nelems, 2));
                        break;

                    IN_WIN64(case ELEMENT_TYPE_I:)
                    case ELEMENT_TYPE_I8:
                        INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_I8, nelems, 3));
                        break;

                    IN_WIN64(case ELEMENT_TYPE_U:)
                    case ELEMENT_TYPE_U8:
                        INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_U8, nelems, 3));
                        break;

                    case ELEMENT_TYPE_R4:
                        INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_R4, nelems, 2));
                        break;

                    case ELEMENT_TYPE_R8:
                        INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_R8, nelems, 3));
                        break;

                    case ELEMENT_TYPE_BOOLEAN:
                        INITFIELDMARSHALER(NFT_FIXEDBOOLARRAY, FieldMarshaler_FixedBoolArray, (nelems));
                        break;

                    case ELEMENT_TYPE_CHAR:
                        if (fAnsi) {
                            BOOL BestFit;
                            BOOL ThrowOnUnmappableChar;
                            ReadBestFitCustomAttribute(pInternalImport, cl, &BestFit, &ThrowOnUnmappableChar);
                            
                            INITFIELDMARSHALER(NFT_FIXEDCHARARRAYANSI, FieldMarshaler_FixedCharArrayAnsi, (nelems, BestFit, ThrowOnUnmappableChar));
                        } else {
                            INITFIELDMARSHALER(NFT_FIXEDSCALARARRAY, FieldMarshaler_FixedScalarArray, (ELEMENT_TYPE_CHAR, nelems, 1));
                        }
                        break;
                        
                    case ELEMENT_TYPE_CLASS:
                    {
                        CorElementType realType = elemType.GetElemType();
                        CorNativeType subType;

                        if (realType == ELEMENT_TYPE_STRING)
                        {
                            if (S_OK == CheckForCompressedData(pNativeTypeStart, pNativeType, cbNativeTypeStart))
                            {
                                subType = (CorNativeType)CorSigUncompressData(pNativeType);

                                if (subType == NATIVE_TYPE_BSTR)
                                    INITFIELDMARSHALER(NFT_FIXEDBSTRARRAY, FieldMarshaler_FixedBSTRArray, (nelems));

                                break;
                            }
                        }
                        break;                        
                    }
                    
                    default:
                        break;
                }
            }
            break;
        }
            

        case ELEMENT_TYPE_OBJECT:
        case ELEMENT_TYPE_STRING:
        case ELEMENT_TYPE_ARRAY:
            break;

        default:
            // let it fall thru as NFT_NONE
            break;

    }

    if (pfwalk->m_nft == NFT_NONE) {
        INITFIELDMARSHALER(NFT_ILLEGAL, FieldMarshaler_Illegal, (IDS_EE_BADPINVOKEFIELD));
    }

#ifdef CUSTOMER_CHECKED_BUILD

#ifndef _DEBUG
    // Refer to CollectLayoutFieldMetadata for how these strings are initialized.
    LPCUTF8 szNamespace, szClassName; 
    LPCUTF8 szFieldName; 

    pInternalImport->GetNameOfTypeDef(cl, &szClassName, &szNamespace);
    szFieldName = pInternalImport->GetNameOfFieldDef(pfwalk->m_MD);
#endif

    OutputCustomerCheckedBuildNStructFieldType(fsig, pfwalk, corElemType, szNamespace, szClassName, szFieldName);
#endif // CUSTOMER_CHECKED_BUILD

    return S_OK;
#undef INITFIELDMARSHALER
}



MethodTable* ArraySubTypeLoadWorker(NativeTypeParamInfo ParamInfo, Assembly* pAssembly)
{
    TypeHandle th;

    // We might come in in either gc mode.  We need to be in cooperative mode to setup a GC Frame for the throwable
    // The throwable is required to be protected by a GC Frame.
    BEGIN_ENSURE_COOPERATIVE_GC();
    
    // Make sure pThrowable is not NULL temporarily (required by call to FindAssemblyQualifiedTypeHandle)    
    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
   
    // Append a NULL terminator to the user defined type name.
    CQuickArrayNoDtor<char> strUserDefTypeName;
    strUserDefTypeName.ReSize(ParamInfo.m_cSafeArrayUserDefTypeNameBytes + 1);
    memcpy(strUserDefTypeName.Ptr(), ParamInfo.m_strSafeArrayUserDefTypeName, ParamInfo.m_cSafeArrayUserDefTypeNameBytes);
    strUserDefTypeName[ParamInfo.m_cSafeArrayUserDefTypeNameBytes] = 0;
    
    COMPLUS_TRY
    {
        // Load the user defined type.
        th = SystemDomain::GetCurrentDomain()->FindAssemblyQualifiedTypeHandle(strUserDefTypeName.Ptr(), true, pAssembly, NULL, &Throwable);
    }
    COMPLUS_CATCH
    {
    } 
    COMPLUS_END_CATCH
  
    strUserDefTypeName.Destroy();
    GCPROTECT_END();
    
    END_ENSURE_COOPERATIVE_GC();
    
    return th.GetMethodTable();
}



VARTYPE ArrayVarTypeFromTypeHandleWorker(TypeHandle th)
{
    VARTYPE vt = VT_EMPTY;

    COMPLUS_TRY
    {
        vt = OleVariant::GetVarTypeForTypeHandle(th);
    }
    COMPLUS_CATCH
    {
    }
    COMPLUS_END_CATCH

    return vt;
}


//=======================================================================
// Called from the clsloader to load up and summarize the field metadata
// for layout classes.
//
// Warning: This function can load other classes (esp. for nested structs.)
//=======================================================================
HRESULT CollectLayoutFieldMetadata(
   mdTypeDef cl,                // cl of the NStruct being loaded
   BYTE packingSize,            // packing size (from @dll.struct)
   BYTE nlType,                 // nltype (from @dll.struct)
   BOOL fExplicitOffsets,       // explicit offsets?
   EEClass *pParentClass,       // the loaded superclass
   ULONG cMembers,              // total number of members (methods + fields)
   HENUMInternal *phEnumField,  // enumerator for field
   Module* pModule,             // Module that defines the scope, loader and heap (for allocate FieldMarshalers)
   EEClassLayoutInfo *pEEClassLayoutInfoOut,  // caller-allocated structure to fill in.
   LayoutRawFieldInfo *pInfoArrayOut, // caller-allocated array to fill in.  Needs room for cMember+1 elements
   OBJECTREF *pThrowable
)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT hr;
    MD_CLASS_LAYOUT classlayout;
    mdFieldDef      fd;
    ULONG           ulOffset;
    ULONG           cFields = 0;

    _ASSERTE(pModule);
    ClassLoader* pLoader = pModule->GetClassLoader();

    _ASSERTE(pLoader);
    LoaderHeap *pLoaderHeap = pLoader->GetHighFrequencyHeap();     // heap to allocate FieldMarshalers out of

    IMDInternalImport *pInternalImport = pModule->GetMDImport();    // Internal interface for the NStruct being loaded.


#ifdef _DEBUG
    LPCUTF8 szName; 
    LPCUTF8 szNamespace; 
    pInternalImport->GetNameOfTypeDef(cl, &szName, &szNamespace);
#endif

    BOOL fHasNonTrivialParent = pParentClass &&
                                !pParentClass->IsObjectClass() &&
                                !GetAppDomain()->IsSpecialObjectClass(pParentClass->GetMethodTable()) &&
                                !pParentClass->IsValueTypeClass();


    //====================================================================
    // First, some validation checks.
    //====================================================================
    if (fHasNonTrivialParent && !(pParentClass->HasLayout()))
    {
        pModule->GetAssembly()->PostTypeLoadException(pInternalImport, cl,
                                                      IDS_CLASSLOAD_NSTRUCT_PARENT, pThrowable);
        return COR_E_TYPELOAD;
    }




    hr = pInternalImport->GetClassLayoutInit(
                                     cl,
                                     &classlayout);
    if (FAILED(hr)) {
        BAD_FORMAT_ASSERT(!"Couldn't get classlayout.");
        return hr;
    }

    

    pEEClassLayoutInfoOut->m_DeclaredPackingSize = packingSize;
    pEEClassLayoutInfoOut->m_nlType              = nlType;
    pEEClassLayoutInfoOut->m_fAutoOffset         = !fExplicitOffsets;
    pEEClassLayoutInfoOut->m_numCTMFields        = fHasNonTrivialParent ? ((LayoutEEClass*)pParentClass)->GetLayoutInfo()->m_numCTMFields : 0;
    pEEClassLayoutInfoOut->m_pFieldMarshalers    = NULL;
    pEEClassLayoutInfoOut->m_fBlittable          = TRUE;
    if (fHasNonTrivialParent)
    {
        pEEClassLayoutInfoOut->m_fBlittable = (pParentClass->IsBlittable());
    }

    LayoutRawFieldInfo *pfwalk = pInfoArrayOut;

    LayoutRawFieldInfo **pSortArray = (LayoutRawFieldInfo**)_alloca(cMembers * sizeof(LayoutRawFieldInfo*));
    LayoutRawFieldInfo **pSortArrayEnd = pSortArray;

    ULONG   maxRid = pInternalImport->GetCountWithTokenKind(mdtFieldDef);
    //=====================================================================
    // Phase 1: Figure out the NFT of each field based on both the COM+
    // signature of the field and the NStruct metadata. 
    //=====================================================================
    for (ULONG i = 0; pInternalImport->EnumNext(phEnumField, &fd); i++) {
        DWORD       dwFieldAttrs;
        // MD Val.check: token validity
        ULONG       rid = RidFromToken(fd);
        if((rid == 0)||(rid > maxRid))
        {
            BAD_FORMAT_ASSERT(!"Invalid Field Token");
            return COR_E_TYPELOAD;
        }

        dwFieldAttrs = pInternalImport->GetFieldDefProps(fd);

        PCCOR_SIGNATURE pNativeType = NULL;
        ULONG       cbNativeType;
        if ( !(IsFdStatic(dwFieldAttrs)) ) {
            PCCOR_SIGNATURE pCOMSignature;
            ULONG       cbCOMSignature;

            if (IsFdHasFieldMarshal(dwFieldAttrs)) {
                hr = pInternalImport->GetFieldMarshal(fd, &pNativeType, &cbNativeType);
                if (FAILED(hr)) {
                    cbNativeType = 0;
                }
            } else {
                cbNativeType = 0;
            }


            pCOMSignature = pInternalImport->GetSigOfFieldDef(fd,&cbCOMSignature);

            hr = ::validateTokenSig(fd,pCOMSignature,cbCOMSignature,dwFieldAttrs,pInternalImport);
            if(FAILED(hr)) return hr;

            // fill the appropriate entry in pInfoArrayOut
            pfwalk->m_MD = fd;
            pfwalk->m_nft = NULL;
            pfwalk->m_offset = -1;
            pfwalk->m_sequence = 0;

#ifdef _DEBUG
            LPCUTF8 szFieldName = pInternalImport->GetNameOfFieldDef(fd);
#endif

            hr = ParseNativeType(pModule,
                                 pCOMSignature,
                                 nlType,
                                 pfwalk,
                                 pNativeType,
                                 cbNativeType,
                                 pInternalImport,
                                 cl,
                                 pThrowable

#ifdef _DEBUG
                                 ,
                                 szNamespace,
                                 szName,
                                 szFieldName
#endif
                                );

            if (FAILED(hr)) {
                return hr;
            }

            //@nice: This is obviously not the place to bury this logic.
            // We're replacing NFT's with MARSHAL_TYPES_* in the near future
            // so this isn't worth perfecting.

            BOOL    resetBlittable = TRUE;

            // if it's a simple copy...
            if (pfwalk->m_nft == NFT_COPY1    ||
                pfwalk->m_nft == NFT_COPY2    ||
                pfwalk->m_nft == NFT_COPY4    ||
                pfwalk->m_nft == NFT_COPY8)
            {
                resetBlittable = FALSE;
            }

            // Or if it's a nested value class that is itself blittable...
            if (pfwalk->m_nft == NFT_NESTEDVALUECLASS)
            {
                FieldMarshaler *pFM = (FieldMarshaler*)&(pfwalk->m_FieldMarshaler);
                _ASSERTE(pFM->IsNestedValueClassMarshaler());
                if (((FieldMarshaler_NestedValueClass *) pFM)->IsBlittable())
                {
                    resetBlittable = FALSE;
                }
            }

            // ...Otherwise, this field prevents blitting
            if (resetBlittable)
                pEEClassLayoutInfoOut->m_fBlittable          = FALSE;

            cFields++;
            pfwalk++;
        }
    }

    _ASSERTE(i == cMembers);

    // NULL out the last entry
    pfwalk->m_MD = mdFieldDefNil;
    
    
    //
    // fill in the layout information 
    //
    
    // pfwalk points to the beginging of the array
    pfwalk = pInfoArrayOut;

    while (SUCCEEDED(hr = pInternalImport->GetClassLayoutNext(
                                     &classlayout,
                                     &fd,
                                     &ulOffset)) &&
                                     fd != mdFieldDefNil)
    {
        // watch for the last entry: must be mdFieldDefNil
        while ((mdFieldDefNil != pfwalk->m_MD)&&(pfwalk->m_MD < fd))
        {
            pfwalk++;
        }
        if(pfwalk->m_MD != fd) continue;
        // if we haven't found a matching token, it must be a static field with layout -- ignore it
        _ASSERTE(pfwalk->m_MD == fd);
        if (!fExplicitOffsets) {
            // ulOffset is the sequence
            pfwalk->m_sequence = ulOffset;
        }
        else {

            // ulOffset is the explicit offset
            pfwalk->m_offset = ulOffset;
            pfwalk->m_sequence = -1;

            if (pParentClass && pParentClass->HasLayout()) {
                // Treat base class as an initial member.
                if (!SafeAddUINT32(&(pfwalk->m_offset), pParentClass->GetLayoutInfo()->GetNativeSize()))
                {
                    return E_OUTOFMEMORY;
                }
            }


        }

    }
    if (FAILED(hr)) {
        return hr;
    }

    
    // now sort the array
    if (!fExplicitOffsets) { // sort sequential by ascending sequence
        for (i = 0; i < cFields; i++) {
            LayoutRawFieldInfo**pSortWalk = pSortArrayEnd;
            while (pSortWalk != pSortArray) {
                if (pInfoArrayOut[i].m_sequence >= (*(pSortWalk-1))->m_sequence) {
                    break;
                }
                pSortWalk--;
            }
            // pSortWalk now points to the target location for new FieldInfo.
            MoveMemory(pSortWalk + 1, pSortWalk, (pSortArrayEnd - pSortWalk) * sizeof(LayoutRawFieldInfo*));
            *pSortWalk = &pInfoArrayOut[i];
            pSortArrayEnd++;
        }
    }
    else // no sorting for explicit layout
    {
        for (i = 0; i < cFields; i++) {
            if(pInfoArrayOut[i].m_MD != mdFieldDefNil && pInfoArrayOut[i].m_offset == -1) {

                LPCUTF8 szFieldName;
                szFieldName = pInternalImport->GetNameOfFieldDef(pInfoArrayOut[i].m_MD);

                pModule->GetAssembly()->PostTypeLoadException(pInternalImport, 
                                                              cl,
                                                              szFieldName,
                                                              IDS_CLASSLOAD_NSTRUCT_EXPLICIT_OFFSET, 
                                                              pThrowable);
                return COR_E_TYPELOAD;
            }
                
            *pSortArrayEnd = &pInfoArrayOut[i];
            pSortArrayEnd++;
        }
    }

    //=====================================================================
    // Phase 2: Compute the native size (in bytes) of each field.
    // Store this in pInfoArrayOut[].cbNativeSize;
    //=====================================================================


    // Now compute the native size of each field
    for (pfwalk = pInfoArrayOut; pfwalk->m_MD != mdFieldDefNil; pfwalk++) {
        UINT8 nft = pfwalk->m_nft;
        pEEClassLayoutInfoOut->m_numCTMFields++;

        // If the NFT's size never changes, it is stored in the database.
        UINT32 cbNativeSize = NFTDataBase[nft].m_cbNativeSize;

        if (cbNativeSize == 0) {
            // Size of 0 means NFT's size is variable, so we have to figure it
            // out case by case.
            cbNativeSize = ((FieldMarshaler*)&(pfwalk->m_FieldMarshaler))->NativeSize();
        }
        pfwalk->m_cbNativeSize = cbNativeSize;
    }

    if (pEEClassLayoutInfoOut->m_numCTMFields) {
        pEEClassLayoutInfoOut->m_pFieldMarshalers = (FieldMarshaler*)(pLoaderHeap->AllocMem(MAXFIELDMARSHALERSIZE * pEEClassLayoutInfoOut->m_numCTMFields));
        if (!pEEClassLayoutInfoOut->m_pFieldMarshalers) {
            return E_OUTOFMEMORY;
        }

        // Bring in the parent's fieldmarshalers
        if (fHasNonTrivialParent)
        {
            EEClassLayoutInfo *pParentLayoutInfo = ((LayoutEEClass*)pParentClass)->GetLayoutInfo();
            UINT numChildCTMFields = pEEClassLayoutInfoOut->m_numCTMFields - pParentLayoutInfo->m_numCTMFields;
            memcpyNoGCRefs( ((BYTE*)pEEClassLayoutInfoOut->m_pFieldMarshalers) + MAXFIELDMARSHALERSIZE*numChildCTMFields,
                            pParentLayoutInfo->m_pFieldMarshalers,
                            MAXFIELDMARSHALERSIZE * (pParentLayoutInfo->m_numCTMFields) );
        }

    }

    //=====================================================================
    // Phase 3: If NStruct requires autooffsetting, compute the offset
    // of each field and the size of the total structure. We do the layout
    // according to standard VC layout rules:
    //
    //   Each field has an alignment requirement. The alignment-requirement
    //   of a scalar field is the smaller of its size and the declared packsize.
    //   The alighnment-requirement of a struct field is the smaller of the
    //   declared packsize and the largest of the alignment-requirement
    //   of its fields. The alignment requirement of an array is that
    //   of one of its elements.
    //
    //   In addition, each struct gets padding at the end to ensure
    //   that an array of such structs contain no unused space between
    //   elements.
    //=====================================================================
    BYTE   LargestAlignmentRequirement = 1;
    UINT32 cbCurOffset = 0;

    if (pParentClass && pParentClass->HasLayout()) {
        // Treat base class as an initial member.
        if (!SafeAddUINT32(&cbCurOffset, pParentClass->GetLayoutInfo()->GetNativeSize()))
        {
            return E_OUTOFMEMORY;
        }


        BYTE alignmentRequirement = min(packingSize, pParentClass->GetLayoutInfo()->GetLargestAlignmentRequirementOfAllMembers());
        LargestAlignmentRequirement = max(LargestAlignmentRequirement, alignmentRequirement);
                                          
    }
    unsigned calcTotalSize = 1;         // The current size of the structure as a whole, we start at 1, because we 
                                        // disallow 0 sized structures. 
    LayoutRawFieldInfo **pSortWalk;
    for (pSortWalk = pSortArray, i=cFields; i; i--, pSortWalk++) {
        pfwalk = *pSortWalk;
        UINT8 nft = pfwalk->m_nft;

        BYTE alignmentRequirement = ((FieldMarshaler*)&(pfwalk->m_FieldMarshaler))->AlignmentRequirement();
        _ASSERTE(alignmentRequirement == 1 ||
                 alignmentRequirement == 2 ||
                 alignmentRequirement == 4 ||
                 alignmentRequirement == 8);

        alignmentRequirement = min(alignmentRequirement, packingSize);
        LargestAlignmentRequirement = max(LargestAlignmentRequirement, alignmentRequirement);

        // This assert means I forgot to special-case some NFT in the
        // above switch.
        _ASSERTE(alignmentRequirement <= 8);

        // Check if this field is overlapped with other(s)
        pfwalk->m_fIsOverlapped = FALSE;
        if (fExplicitOffsets) {
            LayoutRawFieldInfo *pfwalk1;
            DWORD dwBegin = pfwalk->m_offset;
            DWORD dwEnd = dwBegin+pfwalk->m_cbNativeSize;
            for (pfwalk1 = pInfoArrayOut; pfwalk1 < pfwalk; pfwalk1++) {
                if((pfwalk1->m_offset >= dwEnd) || (pfwalk1->m_offset+pfwalk1->m_cbNativeSize <= dwBegin)) continue;
                pfwalk->m_fIsOverlapped = TRUE;
                pfwalk1->m_fIsOverlapped = TRUE;
            }
        }
        else {
            // Insert enough padding to align the current data member.
            while (cbCurOffset % alignmentRequirement) {
                if (!SafeAddUINT32(&cbCurOffset, 1))
                    return E_OUTOFMEMORY;
            }

            // Insert current data member.
            pfwalk->m_offset = cbCurOffset;
            cbCurOffset += pfwalk->m_cbNativeSize;      // if we overflow we will catch it below
        } 

        unsigned fieldEnd = pfwalk->m_offset + pfwalk->m_cbNativeSize;
        if (fieldEnd < pfwalk->m_offset)
            return E_OUTOFMEMORY;

            // size of the structure is the size of the last field.  
        if (fieldEnd > calcTotalSize)
            calcTotalSize = fieldEnd;
    }

    ULONG clstotalsize = 0;
    pInternalImport->GetClassTotalSize(cl, &clstotalsize);

    if (clstotalsize != 0) {

        if (pParentClass && pParentClass->HasLayout()) {
            // Treat base class as an initial member.

            UINT32 parentSize = pParentClass->GetLayoutInfo()->GetNativeSize();
            if (clstotalsize + parentSize < clstotalsize)
            {
                return E_OUTOFMEMORY;
            }
            clstotalsize += parentSize;
        }

            // they can't give us a bad size (too small).
        if (clstotalsize < calcTotalSize)
        {
            pModule->GetAssembly()->PostTypeLoadException(pInternalImport, cl,
                                                          IDS_CLASSLOAD_BADFORMAT, pThrowable);
            return COR_E_TYPELOAD;
        }
        calcTotalSize = clstotalsize;   // use the size they told us 
    } 
    else {
            // The did not give us an explict size, so lets round up to a good size (for arrays) 
        while (calcTotalSize % LargestAlignmentRequirement) {
            if (!SafeAddUINT32(&calcTotalSize, 1))
                return E_OUTOFMEMORY;
        }
    }

    // We'll cap the total native size at a (somewhat) arbitrary limit to ensure
    // that we don't expose some overflow bug later on.
    if (calcTotalSize >= 0x7ffffff0)
        return E_OUTOFMEMORY;

    pEEClassLayoutInfoOut->m_cbNativeSize = calcTotalSize;

        // The packingSize acts as a ceiling on all individual alignment
    // requirements so it follows that the largest alignment requirement
    // is also capped.
    _ASSERTE(LargestAlignmentRequirement <= packingSize);
    pEEClassLayoutInfoOut->m_LargestAlignmentRequirementOfAllMembers = LargestAlignmentRequirement;

#if 0
#ifdef _DEBUG
    {
        printf("\n\n");
        printf("Packsize = %lu\n", (ULONG)packingSize);
        printf("Max align req        = %lu\n", (ULONG)(pEEClassLayoutInfoOut->m_LargestAlignmentRequirementOfAllMembers));
        printf("----------------------------\n");
        for (pfwalk = pInfoArrayOut; pfwalk->m_MD != mdFieldDefNil; pfwalk++) {
            UINT8 nft = pfwalk->m_nft;
            LPCUTF8 fieldname = "??";
            fieldname = pInternalImport->GetNameOfFieldDef(pfwalk->m_MD);
            printf("+%-5lu  ", (ULONG)(pfwalk->m_offset));
            printf("%s", fieldname);
            printf("\n");
        }
        printf("+%-5lu   EOS\n", (ULONG)(pEEClassLayoutInfoOut->m_cbNativeSize));
    }
#endif
#endif
    return S_OK;
}

//=======================================================================
// For each reference-typed NStruct field, marshals the current COM+ value
// to a new native instance and stores it in the fixed portion of the NStruct.
//
// This function does not attempt to delete the native value that it overwrites.
//
// If pOptionalCleanupWorkList is non-null, this function also schedules
// (unconditionally) a nativedestroy on that field (note that if the
// contents of that field changes before the cleanupworklist fires,
// the new value is what will be destroyed. This is by design, as it
// unifies cleanup for [in,out] parameters.)
//=======================================================================
VOID LayoutUpdateNative(LPVOID *ppProtectedManagedData, UINT offsetbias, EEClass *pcls, BYTE* pNativeData, CleanupWorkList *pOptionalCleanupWorkList)
{
    THROWSCOMPLUSEXCEPTION();

    pcls->CheckRestore();

    const FieldMarshaler *pFieldMarshaler = pcls->GetLayoutInfo()->GetFieldMarshalers();
    UINT  numReferenceFields              = pcls->GetLayoutInfo()->GetNumCTMFields();

    while (numReferenceFields--) {

        DWORD internalOffset = pFieldMarshaler->m_pFD->GetOffset();

        if (pFieldMarshaler->IsScalarMarshaler()) {
            pFieldMarshaler->ScalarUpdateNative( internalOffset + offsetbias + (BYTE*)( *ppProtectedManagedData ),
                                                 pNativeData + pFieldMarshaler->m_dwExternalOffset );
        } else if (pFieldMarshaler->IsNestedValueClassMarshaler()) {
            pFieldMarshaler->NestedValueClassUpdateNative((const VOID **)ppProtectedManagedData, internalOffset + offsetbias, pNativeData + pFieldMarshaler->m_dwExternalOffset);
        } else {
            pFieldMarshaler->UpdateNative(
                                ObjectToOBJECTREF (*(Object**)(internalOffset + offsetbias + (BYTE*)( *ppProtectedManagedData ))),
                                pNativeData + pFieldMarshaler->m_dwExternalOffset
                             );
    
        }
        if (pOptionalCleanupWorkList) {
            pOptionalCleanupWorkList->ScheduleUnconditionalNStructDestroy(pFieldMarshaler, pNativeData + pFieldMarshaler->m_dwExternalOffset);
        }


        ((BYTE*&)pFieldMarshaler) += MAXFIELDMARSHALERSIZE;
    }



}



VOID FmtClassUpdateNative(OBJECTREF *ppProtectedManagedData, BYTE *pNativeData)
{
    THROWSCOMPLUSEXCEPTION();

    EEClass *pcls = (*ppProtectedManagedData)->GetClass();
    _ASSERTE(pcls->IsBlittable() || pcls->HasLayout());
    UINT32   cbsize = pcls->GetMethodTable()->GetNativeSize();

    if (pcls->IsBlittable()) {
        memcpyNoGCRefs(pNativeData, (*ppProtectedManagedData)->GetData(), cbsize);
    } else {
        // This allows us to do a partial LayoutDestroyNative in the case of
        // a marshaling error on one of the fields.
        FillMemory(pNativeData, cbsize, 0);
        EE_TRY_FOR_FINALLY {
            LayoutUpdateNative( (VOID**)ppProtectedManagedData,
                                Object::GetOffsetOfFirstField(),
                                pcls,
                                pNativeData,
                                NULL
                              );
        } EE_FINALLY {
            if (GOT_EXCEPTION()) {
                LayoutDestroyNative(pNativeData, pcls);
                FillMemory(pNativeData, cbsize, 0);
            }
        } EE_END_FINALLY;
    }

}

VOID FmtClassUpdateNative(OBJECTREF pObj, BYTE *pNativeData)
{
    THROWSCOMPLUSEXCEPTION();

    EEClass *pcls = pObj->GetClass();
    _ASSERTE(pcls->IsBlittable() || pcls->HasLayout());
    UINT32   cbsize = pcls->GetMethodTable()->GetNativeSize();

    if (pcls->IsBlittable()) {
        memcpyNoGCRefs(pNativeData, pObj->GetData(), cbsize);
    } else {
        GCPROTECT_BEGIN(pObj);
        FmtClassUpdateNative(&pObj, pNativeData);
        GCPROTECT_END();
    }
}



VOID FmtClassUpdateComPlus(OBJECTREF *ppProtectedManagedData, BYTE *pNativeData, BOOL fDeleteOld)
{
    THROWSCOMPLUSEXCEPTION();

    EEClass *pcls = (*ppProtectedManagedData)->GetClass();
    _ASSERTE(pcls->IsBlittable() || pcls->HasLayout());
    UINT32   cbsize = pcls->GetMethodTable()->GetNativeSize();

    if (pcls->IsBlittable()) {
        memcpyNoGCRefs((*ppProtectedManagedData)->GetData(), pNativeData, cbsize);
    } else {
        LayoutUpdateComPlus((VOID**)ppProtectedManagedData,
                            Object::GetOffsetOfFirstField(),
                            pcls,
                            (BYTE*)pNativeData,
                            fDeleteOld
                           );
    }
}


VOID FmtClassUpdateComPlus(OBJECTREF pObj, BYTE *pNativeData, BOOL fDeleteOld)
{
    THROWSCOMPLUSEXCEPTION();

    EEClass *pcls = pObj->GetClass();
    _ASSERTE(pcls->IsBlittable() || pcls->HasLayout());
    UINT32   cbsize = pcls->GetMethodTable()->GetNativeSize();

    if (pcls->IsBlittable()) {
        memcpyNoGCRefs(pObj->GetData(), pNativeData, cbsize);
    } else {
        GCPROTECT_BEGIN(pObj);
        LayoutUpdateComPlus((VOID**)&pObj,
                            Object::GetOffsetOfFirstField(),
                            pcls,
                            (BYTE*)pNativeData,
                            fDeleteOld
                           );
        GCPROTECT_END();
    }
}





     


//=======================================================================
// For each reference-typed NStruct field, marshals the current COM+ value
// to a new COM+ instance and stores it in the GC portion of the NStruct.
//
// If fDeleteNativeCopies is true, it will also destroy the native version.
//
// NOTE: To avoid error-path leaks, this function attempts to destroy
// all of the native fields even if one or more of the conversions fail.
//=======================================================================
VOID LayoutUpdateComPlus(LPVOID *ppProtectedManagedData, UINT offsetbias, EEClass *pcls, BYTE *pNativeData, BOOL fDeleteNativeCopies)
{
    THROWSCOMPLUSEXCEPTION();

    pcls->CheckRestore();

    const FieldMarshaler *pFieldMarshaler = pcls->GetLayoutInfo()->GetFieldMarshalers();
    UINT  numReferenceFields              = pcls->GetLayoutInfo()->GetNumCTMFields();

    struct _gc {
        OBJECTREF pException;
        OBJECTREF pComPlusValue;
    } gc;
    gc.pException    = NULL;
    gc.pComPlusValue = NULL;
    GCPROTECT_BEGIN(gc);


    while (numReferenceFields--) {

        DWORD internalOffset = pFieldMarshaler->m_pFD->GetOffset();


        // Wrap UpdateComPlus in a catch block - even if this fails,
        // we have to destroy all of the native fields.
        COMPLUS_TRY {
            if (pFieldMarshaler->IsScalarMarshaler()) {
                pFieldMarshaler->ScalarUpdateComPlus( pNativeData + pFieldMarshaler->m_dwExternalOffset,
                                                      internalOffset + offsetbias + (BYTE*)(*ppProtectedManagedData) );
            } else if (pFieldMarshaler->IsNestedValueClassMarshaler()) {
                pFieldMarshaler->NestedValueClassUpdateComPlus(pNativeData + pFieldMarshaler->m_dwExternalOffset, ppProtectedManagedData, internalOffset + offsetbias);
            } else {
                pFieldMarshaler->UpdateComPlus(
                                    pNativeData + pFieldMarshaler->m_dwExternalOffset,
                                    &gc.pComPlusValue
                                 );
    
    
                SetObjectReferenceUnchecked( (OBJECTREF*) (internalOffset + offsetbias + (BYTE*)(*ppProtectedManagedData)), 
                                             gc.pComPlusValue );
    
            }
        } COMPLUS_CATCH {
            gc.pException = GETTHROWABLE();
        } COMPLUS_END_CATCH

        if (fDeleteNativeCopies) {
            pFieldMarshaler->DestroyNative(pNativeData + pFieldMarshaler->m_dwExternalOffset);
        }

        ((BYTE*&)pFieldMarshaler) += MAXFIELDMARSHALERSIZE;
    }

    if (gc.pException != NULL) {
        COMPlusThrow(gc.pException);
    }

    GCPROTECT_END();


}









VOID LayoutDestroyNative(LPVOID pNative, EEClass *pcls)
{
    const FieldMarshaler *pFieldMarshaler = pcls->GetLayoutInfo()->GetFieldMarshalers();
    UINT  numReferenceFields              = pcls->GetLayoutInfo()->GetNumCTMFields();
    BYTE *pNativeData                     = (BYTE*)pNative;

    while (numReferenceFields--) {
        pFieldMarshaler->DestroyNative( pNativeData + pFieldMarshaler->m_dwExternalOffset );
        ((BYTE*&)pFieldMarshaler) += MAXFIELDMARSHALERSIZE;
    }
}

VOID FmtClassDestroyNative(LPVOID pNative, EEClass *pcls)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    if (pNative)
    {
        if (!(pcls->IsBlittable()))
        {
            _ASSERTE(pcls->HasLayout());
            LayoutDestroyNative(pNative, pcls);
        }
    }
}



VOID FmtValueTypeUpdateNative(LPVOID pProtectedManagedData, MethodTable *pMT, BYTE *pNativeData)
{
    THROWSCOMPLUSEXCEPTION();

    EEClass *pcls = pMT->GetClass();
    _ASSERTE(pcls->IsValueClass() && (pcls->IsBlittable() || pcls->HasLayout()));
    UINT32   cbsize = pcls->GetMethodTable()->GetNativeSize();

    if (pcls->IsBlittable()) {
        memcpyNoGCRefs(pNativeData, pProtectedManagedData, cbsize);
    } else {
        // This allows us to do a partial LayoutDestroyNative in the case of
        // a marshaling error on one of the fields.
        FillMemory(pNativeData, cbsize, 0);
        EE_TRY_FOR_FINALLY {
            LayoutUpdateNative( (VOID**)pProtectedManagedData,
                                0,
                                pcls,
                                pNativeData,
                                NULL
                              );
        } EE_FINALLY {
            if (GOT_EXCEPTION()) {
                LayoutDestroyNative(pNativeData, pcls);
                FillMemory(pNativeData, cbsize, 0);
            }
        } EE_END_FINALLY;
    }

}

VOID FmtValueTypeUpdateComPlus(LPVOID pProtectedManagedData, MethodTable *pMT, BYTE *pNativeData, BOOL fDeleteOld)
{
    THROWSCOMPLUSEXCEPTION();

    EEClass *pcls = pMT->GetClass();
    _ASSERTE(pcls->IsValueClass() && (pcls->IsBlittable() || pcls->HasLayout()));
    UINT32   cbsize = pcls->GetMethodTable()->GetNativeSize();

    if (pcls->IsBlittable()) {
        memcpyNoGCRefs(pProtectedManagedData, pNativeData, cbsize);
    } else {
        LayoutUpdateComPlus((VOID**)pProtectedManagedData,
                            0,
                            pcls,
                            (BYTE*)pNativeData,
                            fDeleteOld
                           );
    }
}

//=======================================================================
// BSTR <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_BSTR::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString;
    *((OBJECTREF*)&pString) = pComPlusValue;
    if (pString == NULL) {
        *((BSTR*)pNativeValue) = NULL;
    } else {
        *((BSTR*)pNativeValue) = SysAllocStringLen(pString->GetBuffer(), pString->GetStringLength());
        if (!*((BSTR*)pNativeValue)) {
            COMPlusThrowOM();
        }
        //printf("Created BSTR %lxh\n", *(BSTR*)pNativeValue);
    }
}


//=======================================================================
// BSTR <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_BSTR::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString;
    BSTR pBSTR = *((BSTR*)pNativeValue);
    if (!pBSTR) {
        pString = NULL;
    } else {
        pString = COMString::NewString(pBSTR, SysStringLen(pBSTR));
    }
    *((STRINGREF*)ppProtectedComPlusValue) = pString;

}


//=======================================================================
// BSTR <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_BSTR::DestroyNative(LPVOID pNativeValue) const 
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    BSTR pBSTR = *((BSTR*)pNativeValue);
    *((BSTR*)pNativeValue) = NULL;
    if (pBSTR) {
        //printf("Destroyed BSTR: %lxh\n", pBSTR);
        SysFreeString(pBSTR);
    }
}








//=======================================================================
// Nested structure conversion
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_NestedLayoutClass::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    UINT32     cbNativeSize = m_pNestedMethodTable->GetNativeSize();


    if (pComPlusValue == NULL) {
        ZeroMemory(pNativeValue, cbNativeSize);
    } else {
        GCPROTECT_BEGIN(pComPlusValue);
        LayoutUpdateNative((LPVOID*)&pComPlusValue, Object::GetOffsetOfFirstField(), m_pNestedMethodTable->GetClass(), (BYTE*)pNativeValue, NULL);
        GCPROTECT_END();
    }

}


//=======================================================================
// Nested structure conversion
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_NestedLayoutClass::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    UINT32 cbNativeSize = m_pNestedMethodTable->GetNativeSize();

    *ppProtectedComPlusValue = AllocateObject(m_pNestedMethodTable);


    LayoutUpdateComPlus( (LPVOID*)ppProtectedComPlusValue,
                         Object::GetOffsetOfFirstField(),
                         m_pNestedMethodTable->GetClass(),
                         (BYTE *)pNativeValue,
                         FALSE);

}


//=======================================================================
// Nested structure conversion
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_NestedLayoutClass::DestroyNative(LPVOID pNativeValue) const 
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    LayoutDestroyNative(pNativeValue, m_pNestedMethodTable->GetClass());

}



//=======================================================================
// Nested structure conversion
// See FieldMarshaler for details.
//=======================================================================
UINT32 FieldMarshaler_NestedLayoutClass::NativeSize()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    return m_pNestedMethodTable->GetClass()->GetLayoutInfo()->GetNativeSize();
}

//=======================================================================
// Nested structure conversion
// See FieldMarshaler for details.
//=======================================================================
UINT32 FieldMarshaler_NestedLayoutClass::AlignmentRequirement()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    return m_pNestedMethodTable->GetClass()->GetLayoutInfo()->GetLargestAlignmentRequirementOfAllMembers();
}






//=======================================================================
// Nested structure conversion
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_NestedValueClass::NestedValueClassUpdateNative(const VOID **ppProtectedComPlus, UINT startoffset, LPVOID pNative) const
{
    THROWSCOMPLUSEXCEPTION();

    // would be better to detect this at class load time (that have a nested value
    // class with no layout) but don't have a way to know
    if (! m_pNestedMethodTable->GetClass()->GetLayoutInfo())
        COMPlusThrow(kArgumentException, IDS_NOLAYOUT_IN_EMBEDDED_VALUECLASS);

    UINT32     cbNativeSize = m_pNestedMethodTable->GetNativeSize();

    LayoutUpdateNative((LPVOID*)ppProtectedComPlus, startoffset, m_pNestedMethodTable->GetClass(), (BYTE*)pNative, NULL);


}


//=======================================================================
// Nested structure conversion
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_NestedValueClass::NestedValueClassUpdateComPlus(const VOID *pNative, LPVOID *ppProtectedComPlus, UINT startoffset) const
{
    THROWSCOMPLUSEXCEPTION();

    // would be better to detect this at class load time (that have a nested value
    // class with no layout) but don't have a way to know
    if (! m_pNestedMethodTable->GetClass()->GetLayoutInfo())
        COMPlusThrow(kArgumentException, IDS_NOLAYOUT_IN_EMBEDDED_VALUECLASS);

    LayoutUpdateComPlus( (LPVOID*)ppProtectedComPlus,
                         startoffset,
                         m_pNestedMethodTable->GetClass(),
                         (BYTE *)pNative,
                         FALSE);
    

}


//=======================================================================
// Nested structure conversion
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_NestedValueClass::DestroyNative(LPVOID pNativeValue) const 
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    LayoutDestroyNative(pNativeValue, m_pNestedMethodTable->GetClass());
}



//=======================================================================
// Nested structure conversion
// See FieldMarshaler for details.
//=======================================================================
UINT32 FieldMarshaler_NestedValueClass::NativeSize()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    // this can't be marshalled as native type if no layout, so we allow the 
    // native size info to be created if available, but the size will only
    // be valid for native, not unions. Marshaller will throw exception if
    // try to marshall a value class with no layout
    if (m_pNestedMethodTable->GetClass()->HasLayout())
        return m_pNestedMethodTable->GetClass()->GetLayoutInfo()->GetNativeSize();
    return 0;
}

//=======================================================================
// Nested structure conversion
// See FieldMarshaler for details.
//=======================================================================
UINT32 FieldMarshaler_NestedValueClass::AlignmentRequirement()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    // this can't be marshalled as native type if no layout, so we allow the 
    // native size info to be created if available, but the alignment will only
    // be valid for native, not unions. Marshaller will throw exception if
    // try to marshall a value class with no layout
    if (m_pNestedMethodTable->GetClass()->HasLayout())
        return m_pNestedMethodTable->GetClass()->GetLayoutInfo()->GetLargestAlignmentRequirementOfAllMembers();
    return 1;
}








//=======================================================================
// CoTask Uni <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_StringUni::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString;
    *((OBJECTREF*)&pString) = pComPlusValue;
    if (pString == NULL) {
        *((LPWSTR*)pNativeValue) = NULL;
    } else {
        DWORD nc   = pString->GetStringLength();
        if (nc > 0x7ffffff0)
        {
            COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
        }
        LPWSTR wsz = (LPWSTR)CoTaskMemAlloc( (nc + 1) * sizeof(WCHAR) );
        if (!wsz) {
            COMPlusThrowOM();
        }
        CopyMemory(wsz, pString->GetBuffer(), nc*sizeof(WCHAR));
        wsz[nc] = L'\0';
        *((LPWSTR*)pNativeValue) = wsz;

        //printf("Created UniString %lxh\n", *(LPWSTR*)pNativeValue);
    }
}


//=======================================================================
// CoTask Uni <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_StringUni::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString;
    LPCWSTR wsz = *((LPCWSTR*)pNativeValue);
    if (!wsz) {
        pString = NULL;
    } else {
        DWORD length = (DWORD)wcslen(wsz);
        if (length > 0x7ffffff0)
        {
            COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
        }

        pString = COMString::NewString(wsz, length);
    }
    *((STRINGREF*)ppProtectedComPlusValue) = pString;

}


//=======================================================================
// CoTask Uni <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_StringUni::DestroyNative(LPVOID pNativeValue) const 
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    LPWSTR wsz = *((LPWSTR*)pNativeValue);
    *((LPWSTR*)pNativeValue) = NULL;
    if (wsz) {
        CoTaskMemFree(wsz);
    }
}










//=======================================================================
// CoTask Ansi <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_StringAnsi::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString;
    *((OBJECTREF*)&pString) = pComPlusValue;
    if (pString == NULL) {
        *((LPSTR*)pNativeValue) = NULL;
    } else {

        DWORD nc   = pString->GetStringLength();
        if (nc > 0x7ffffff0)
        {
            COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
        }
        LPSTR sz = (LPSTR)CoTaskMemAlloc( (nc + 1) * 2 /* 2 for MBCS */ );
        if (!sz) {
            COMPlusThrowOM();
        }

        if (nc == 0) {
            *sz = '\0';
        } else {
            
            DWORD flags = 0;
            BOOL DefaultCharUsed = FALSE;
        
            if (m_BestFitMap == FALSE)
                flags = WC_NO_BEST_FIT_CHARS;

            int nbytes = WszWideCharToMultiByte(CP_ACP,
                                     flags,
                                     pString->GetBuffer(),
                                     nc,   // # of wchars in inbuffer
                                     sz,
                                     nc*2, // size in bytes of outbuffer
                                     NULL,
                                     &DefaultCharUsed);
            if (!nbytes) {
                COMPlusThrow(kArgumentException, IDS_UNI2ANSI_FAILURE_IN_NSTRUCT);
            }

            if ( DefaultCharUsed && m_ThrowOnUnmappableChar ) {
                COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
            }
                
                
            sz[nbytes] = '\0';
        }



        *((LPSTR*)pNativeValue) = sz;

        //printf("Created AnsiString %lxh\n", *(LPSTR*)pNativeValue);
    }
}


//=======================================================================
// CoTask Ansi <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_StringAnsi::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString = NULL;
    LPCSTR sz = *((LPCSTR*)pNativeValue);
    if (!sz) {
        pString = NULL;
    } else {

        int cwsize = MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,
                                         sz,
                                         -1,  
                                         NULL,
                                         0);
        if (cwsize == 0) {
            COMPlusThrow(kArgumentException, IDS_ANSI2UNI_FAILURE_IN_NSTRUCT);
        } else if (cwsize < 0 || cwsize > 0x7ffffff0) {
            COMPlusThrow(kMarshalDirectiveException, IDS_EE_STRING_TOOLONG);
        } else {
            CQuickBytes qb;
            //printf("MB2W returned %lu\n", cwsize);
            LPWSTR wsztemp = (LPWSTR)qb.Alloc(cwsize*sizeof(WCHAR));
            if (!wsztemp)
            {
                COMPlusThrowOM();
            }
            MultiByteToWideChar(CP_ACP,
                                MB_PRECOMPOSED,
                                sz,     
                                -1,     // # CHARs in inbuffer
                                wsztemp,
                                cwsize  // size (in WCHAR's) of outbuffer
                                );
            pString = COMString::NewString(wsztemp, (cwsize - 1));
        }


    }
    *((STRINGREF*)ppProtectedComPlusValue) = pString;

}


//=======================================================================
// CoTask Ansi <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_StringAnsi::DestroyNative(LPVOID pNativeValue) const 
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    LPSTR sz = *((LPSTR*)pNativeValue);
    *((LPSTR*)pNativeValue) = NULL;
    if (sz) {
        CoTaskMemFree(sz);
    }
}










//=======================================================================
// FixedString <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedStringUni::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString;
    *((OBJECTREF*)&pString) = pComPlusValue;
    if (pString == NULL) {
        *((WCHAR*)pNativeValue) = L'\0';
    } else {
        DWORD nc = pString->GetStringLength();
        if (nc >= m_numchar) {
            nc = m_numchar - 1;
        }
        CopyMemory(pNativeValue, pString->GetBuffer(), nc*sizeof(WCHAR));
        ((WCHAR*)pNativeValue)[nc] = L'\0';
    }

}


//=======================================================================
// FixedString <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedStringUni::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString;
    DWORD     ncActual;
    for (ncActual = 0; *(ncActual + (WCHAR*)pNativeValue) != L'\0' && ncActual < m_numchar; ncActual++) {
        //nothing
    }
    pString = COMString::NewString((const WCHAR *)pNativeValue, ncActual);
    *((STRINGREF*)ppProtectedComPlusValue) = pString;

}







//=======================================================================
// FixedString <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedStringAnsi::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString;
    *((OBJECTREF*)&pString) = pComPlusValue;
    if (pString == NULL) {
        *((CHAR*)pNativeValue) = L'\0';
    } else {
        DWORD nc = pString->GetStringLength();
        if (nc >= m_numchar) {
            nc = m_numchar - 1;
        }

        DWORD flags = 0;
        BOOL DefaultCharUsed = FALSE;
    
        if (m_BestFitMap == FALSE)
            flags = WC_NO_BEST_FIT_CHARS;
        
        int cbwritten = WszWideCharToMultiByte(CP_ACP,
                                            flags,
                                            pString->GetBuffer(),
                                            nc,         // # WCHAR's in inbuffer
                                            (CHAR*)pNativeValue,
                                            m_numchar,  // size (in CHAR's) out outbuffer
                                            NULL,
                                            &DefaultCharUsed);
        if ((!cbwritten) && (nc > 0)) {
            COMPlusThrow(kArgumentException, IDS_UNI2ANSI_FAILURE_IN_NSTRUCT);
        }
        
        if (DefaultCharUsed && m_ThrowOnUnmappableChar) {
            COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
        }
            
        
        ((CHAR*)pNativeValue)[cbwritten] = '\0';
    }

}


//=======================================================================
// FixedString <--> System.String
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedStringAnsi::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF pString;

    _ASSERTE(m_numchar != 0);  // should not have slipped past the metadata
    if (m_numchar == 0)
    {
        // but if it does, better to throw an exception tardily rather than
        // allow a memory corrupt.
        COMPlusThrow(kMarshalDirectiveException);
    }

    LPSTR tempbuf = (LPSTR)(_alloca(m_numchar + 2));
    if (!tempbuf) {
        COMPlusThrowOM();
    }
    memcpyNoGCRefs(tempbuf, pNativeValue, m_numchar);
    tempbuf[m_numchar-1] = '\0';
    tempbuf[m_numchar] = '\0';
    tempbuf[m_numchar+1] = '\0';

    LPWSTR    wsztemp = (LPWSTR)_alloca( m_numchar * sizeof(WCHAR) );
    int ncwritten = MultiByteToWideChar(CP_ACP,
                                        MB_PRECOMPOSED,
                                        tempbuf,
                                        -1,  // # of CHAR's in inbuffer
                                        wsztemp,
                                        m_numchar                       // size (in WCHAR) of outbuffer
                                        );

    if (!ncwritten)
    {
        // intentionally not throwing for MB2WC failure. We don't always know
        // whether to expect a valid string in the buffer and we don't want
        // to throw exceptions randomly.
        ncwritten++;
    }

    pString = COMString::NewString((const WCHAR *)wsztemp, ncwritten-1);
    *((STRINGREF*)ppProtectedComPlusValue) = pString;

}





                                                 





//=======================================================================
// CHAR[] <--> char[]
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedCharArrayAnsi::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    I2ARRAYREF pArray;
    *((OBJECTREF*)&pArray) = pComPlusValue;

    if (pArray == NULL) {
        FillMemory(pNativeValue, m_numElems * sizeof(CHAR), 0);
    } else {
        if (pArray->GetNumComponents() < m_numElems) {
            COMPlusThrow(kArgumentException, IDS_WRONGSIZEARRAY_IN_NSTRUCT);
        } else {

            DWORD flags = 0;
            BOOL DefaultCharUsed = FALSE;
        
            if (m_BestFitMap == FALSE)
                flags = WC_NO_BEST_FIT_CHARS;
        
            int cbwritten = WszWideCharToMultiByte(
                CP_ACP,
                flags,
                (const WCHAR *)pArray->GetDataPtr(),
                m_numElems,   //# of WCHAR's in input buffer
                (CHAR*)pNativeValue,
                m_numElems * sizeof(CHAR), // size in bytes of outbuffer
                NULL,
                &DefaultCharUsed);

            if ((!cbwritten) && (m_numElems > 0)) {
                COMPlusThrow(kArgumentException, IDS_UNI2ANSI_FAILURE_IN_NSTRUCT);
            }

            if (DefaultCharUsed && m_ThrowOnUnmappableChar) {
                COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
            }
            
        }
    }
}


//=======================================================================
// CHAR[] <--> char[]
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedCharArrayAnsi::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    *ppProtectedComPlusValue = AllocatePrimitiveArray(ELEMENT_TYPE_CHAR, m_numElems);
    if (!*ppProtectedComPlusValue) {
        COMPlusThrowOM();
    }
    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        (const CHAR *)pNativeValue,
                        m_numElems * sizeof(CHAR), // size, in bytes, of in buffer
                        (WCHAR*) ((*((I2ARRAYREF*)ppProtectedComPlusValue))->GetDirectPointerToNonObjectElements()),
                        m_numElems                 // size, in WCHAR's of outbuffer
                        );


}






//=======================================================================
// BOOL <--> boolean[]
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedBoolArray::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    I1ARRAYREF pArray;
    *((OBJECTREF*)&pArray) = pComPlusValue;

    if (pArray == NULL) {
        FillMemory(pNativeValue, m_numElems * sizeof(BOOL), 0);
    } else {
        if (pArray->GetNumComponents() < m_numElems) {
            COMPlusThrow(kArgumentException, IDS_WRONGSIZEARRAY_IN_NSTRUCT);
        } else {
            UINT32 nElems   = m_numElems;
            const I1 *pI1   = (const I1 *)(pArray->GetDirectPointerToNonObjectElements());
            BOOL     *pBool = (BOOL*)pNativeValue;
            while (nElems--) {
                *(pBool++) = (*(pI1++)) ? 1 : 0;
            }
        }
    }
}


//=======================================================================
// BOOL <--> boolean[]
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedBoolArray::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    *ppProtectedComPlusValue = AllocatePrimitiveArray(ELEMENT_TYPE_I1, m_numElems);
    if (!*ppProtectedComPlusValue) {
        COMPlusThrowOM();
    }
    UINT32 nElems     = m_numElems;
    const BOOL *pBool = (const BOOL*)pNativeValue;
    I1         *pI1   = (I1 *)((*(I1ARRAYREF*)ppProtectedComPlusValue)->GetDirectPointerToNonObjectElements());
    while (nElems--) {
        (*(pI1++)) = *(pBool++) ? 1 : 0;
    }


}




//=======================================================================
// BSTR array <--> string[]
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedBSTRArray::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    BASEARRAYREF pArray;
    *((OBJECTREF*)&pArray) = pComPlusValue;

    if (pArray == NULL)
    {
        FillMemory(pNativeValue, m_numElems * sizeof(BSTR), 0);
        return;
    }

    if (pArray->GetNumComponents() != m_numElems)
    {
        COMPlusThrow(kArgumentException, IDS_WRONGSIZEARRAY_IN_NSTRUCT);
    }
    else
    {
        GCPROTECT_BEGIN(pArray);
        OleVariant::MarshalBSTRArrayComToOleWrapper(&pArray, pNativeValue);
        GCPROTECT_END();
    }
}


//=======================================================================
// BSTR array <--> string[]
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedBSTRArray::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    if (pNativeValue == NULL)
    {
        *ppProtectedComPlusValue = NULL;
        return;
    }

    TypeHandle th(g_pStringClass->GetClass());
    _ASSERTE(!th.IsNull());

    *ppProtectedComPlusValue = AllocateObjectArray(m_numElems, th);

    OleVariant::MarshalBSTRArrayOleToComWrapper((LPVOID)pNativeValue, (BASEARRAYREF*)ppProtectedComPlusValue);

    if (((BASEARRAYREF)*ppProtectedComPlusValue)->GetNumComponents() != m_numElems)
        COMPlusThrow(kArgumentException, IDS_WRONGSIZEARRAY_IN_NSTRUCT);
}


//=======================================================================
// BSTR array <--> string[]
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedBSTRArray::DestroyNative(LPVOID pNativeValue) const 
{
    CANNOTTHROWCOMPLUSEXCEPTION();
  
    if (pNativeValue)
        OleVariant::ClearBSTRArrayWrapper(pNativeValue, m_numElems);
}


//=======================================================================
// SafeArray
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_SafeArray::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();
  
    BASEARRAYREF pArray;
    *((OBJECTREF*)&pArray) = pComPlusValue;
    if ((pArray == NULL) || (OBJECTREFToObject(pArray) == NULL))
    {
        FillMemory(pNativeValue, sizeof(LPSAFEARRAY*), 0);
        return;
    }
    
    LPSAFEARRAY* pSafeArray;
    pSafeArray = (LPSAFEARRAY*)pNativeValue;

    VARTYPE         vt = m_vt;
    MethodTable*    pMT = m_pMT;    
    
    GCPROTECT_BEGIN(pArray)
    {
        // If we have an empty vartype, get it from the array subtype
        if (vt == VT_EMPTY)
            vt = OleVariant::GetElementVarTypeForArrayRef(pArray);
            
        // Get the methodtable if we need to
        if (!pMT)
            pMT = OleVariant::GetArrayElementTypeWrapperAware(&pArray).GetMethodTable();          

        // OleVariant calls throw on error.
        *pSafeArray = OleVariant::CreateSafeArrayForArrayRef(&pArray, vt, pMT);
        OleVariant::MarshalSafeArrayForArrayRef(&pArray, *pSafeArray, vt, pMT);
    }
    GCPROTECT_END();
}


//=======================================================================
// SafeArray
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_SafeArray::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    LPSAFEARRAY* pSafeArray;
    pSafeArray = (LPSAFEARRAY*)pNativeValue;

    if ((pSafeArray == NULL) || (*pSafeArray == NULL))
    {
        *ppProtectedComPlusValue = NULL;
        return;
    }

    VARTYPE         vt = m_vt;
    MethodTable*    pMT = m_pMT;

    // If we have an empty vartype, get it from the safearray vartype
    if (vt == VT_EMPTY)
    {
        if (FAILED(ClrSafeArrayGetVartype(*pSafeArray, &vt)))
            COMPlusThrow(kArgumentException, IDS_EE_INVALID_SAFEARRAY);
    }

    // Get the method table if we need to.
    if ((vt == VT_RECORD) && (!pMT))
        pMT = OleVariant::GetElementTypeForRecordSafeArray(*pSafeArray).GetMethodTable();

    // If we have a single dimension safearray, it will be converted into a SZArray.
    // SZArray must have a lower bound of zero.
    long LowerBound = -1;
    if ( (SafeArrayGetDim( (SAFEARRAY*)*pSafeArray ) == 1) && ( (FAILED(SafeArrayGetLBound((SAFEARRAY*)*pSafeArray, 1, &LowerBound))) || LowerBound != 0 ) )
    {
       COMPlusThrow(kSafeArrayRankMismatchException, IDS_EE_SAFEARRAYSZARRAYMISMATCH);
    }

    // OleVariant calls throw on error.
    *ppProtectedComPlusValue = OleVariant::CreateArrayRefForSafeArray(*pSafeArray, vt, pMT);
    OleVariant::MarshalArrayRefForSafeArray(*pSafeArray, (BASEARRAYREF*)ppProtectedComPlusValue, vt, pMT);
}


//=======================================================================
// SafeArray
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_SafeArray::DestroyNative(LPVOID pNativeValue) const 
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    LPSAFEARRAY* pSafeArray = (LPSAFEARRAY*)pNativeValue;
    HRESULT hr;
    
    if (pSafeArray)
    {
        hr = SafeArrayDestroy(*pSafeArray);
        _ASSERTE(!FAILED(hr));
        pSafeArray = NULL;
    }
}


//=======================================================================
// scalar array
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedScalarArray::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    BASEARRAYREF pArray;
    *((OBJECTREF*)&pArray) = pComPlusValue;

    if (pArray == NULL) {
        FillMemory(pNativeValue, m_numElems << m_componentShift, 0);
    } else {
        if (pArray->GetNumComponents() < m_numElems) {
            COMPlusThrow(kArgumentException, IDS_WRONGSIZEARRAY_IN_NSTRUCT);
        } else {
            CopyMemory(pNativeValue,
                       pArray->GetDataPtr(),
                       m_numElems << m_componentShift);
        }
    }
}


//=======================================================================
// scalar array
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_FixedScalarArray::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    *ppProtectedComPlusValue = AllocatePrimitiveArray(m_arrayType, m_numElems);
    if (!*ppProtectedComPlusValue) {
        COMPlusThrowOM();
    }
    memcpyNoGCRefs((*(BASEARRAYREF*)ppProtectedComPlusValue)->GetDataPtr(),
               pNativeValue,
               m_numElems << m_componentShift);


}






//=======================================================================
// function ptr <--> Delegate
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Delegate::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    *((VOID**)pNativeValue) = COMDelegate::ConvertToCallback(pComPlusValue);

}


//=======================================================================
// function ptr <--> Delegate
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Delegate::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    *ppProtectedComPlusValue = COMDelegate::ConvertToDelegate(*(LPVOID*)pNativeValue);

}






//=======================================================================
// COM IP <--> interface
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Interface::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    GCPROTECT_BEGIN(pComPlusValue);
    if (m_pItfMT != NULL)
    {
        *((IUnknown**)pNativeValue) = GetComIPFromObjectRef(&pComPlusValue, m_pItfMT);
    }
    else
    {
        ComIpType ReqIpType = m_fDispItf ? ComIpType_Dispatch : ComIpType_Unknown;
        *((IUnknown**)pNativeValue) = GetComIPFromObjectRef(&pComPlusValue, ReqIpType, NULL);
    }
    GCPROTECT_END();

}


//=======================================================================
// COM IP <--> interface
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Interface::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    *ppProtectedComPlusValue = GetObjectRefFromComIP(*((IUnknown**)pNativeValue), m_pClassMT, m_fClassIsHint);
}


//=======================================================================
// COM IP <--> interface
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Interface::DestroyNative(LPVOID pNativeValue) const 
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    IUnknown *punk = *((IUnknown**)pNativeValue);
    *((IUnknown**)pNativeValue) = NULL;
    ULONG cbRef = SafeRelease(punk);
    LogInteropRelease(punk, cbRef, "Field marshaler destroy native");
}




//=======================================================================
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Date::ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
{
    *((DATE*)pNative) =  COMDateTime::TicksToDoubleDate(*((INT64*)pComPlus));
}


//=======================================================================
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Date::ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
{
    *((INT64*)pComPlus) = COMDateTime::DoubleDateToTicks(*((DATE*)pNative));
}



//=======================================================================
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Currency::ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
{
    THROWSCOMPLUSEXCEPTION();
    HRESULT hr = VarCyFromDec( (DECIMAL *)pComPlus, (CURRENCY*)pNative);
    if (FAILED(hr))
        COMPlusThrowHR(hr);

}


//=======================================================================
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Currency::ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
{
    THROWSCOMPLUSEXCEPTION();
    HRESULT hr = VarDecFromCy( *(CURRENCY*)pNative, (DECIMAL *)pComPlus );
    if (FAILED(hr))
        COMPlusThrowHR(hr);
    DecimalCanonicalize((DECIMAL*)pComPlus);
}




//=======================================================================
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Illegal::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    DefineFullyQualifiedNameForClassW();
    GetFullyQualifiedNameForClassW(m_pFD->GetEnclosingClass());

    LPCUTF8 szFieldName = m_pFD->GetName();
    MAKE_WIDEPTR_FROMUTF8(wszFieldName, szFieldName);

    COMPlusThrow(kTypeLoadException, m_resIDWhy, _wszclsname_, wszFieldName);

}


//=======================================================================
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Illegal::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    DefineFullyQualifiedNameForClassW();
    GetFullyQualifiedNameForClassW(m_pFD->GetEnclosingClass());

    LPCUTF8 szFieldName = m_pFD->GetName();
    MAKE_WIDEPTR_FROMUTF8(wszFieldName, szFieldName);

    COMPlusThrow(kTypeLoadException, m_resIDWhy, _wszclsname_, wszFieldName);
}


//=======================================================================
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Illegal::DestroyNative(LPVOID pNativeValue) const 
{
    CANNOTTHROWCOMPLUSEXCEPTION();
}




//=======================================================================
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Variant::UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    GCPROTECT_BEGIN(pComPlusValue)
    {
        OleVariant::MarshalOleVariantForObject(&pComPlusValue, (VARIANT*)pNativeValue);
    }
    GCPROTECT_END();

}


//=======================================================================
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Variant::UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
{
    THROWSCOMPLUSEXCEPTION();

    OleVariant::MarshalObjectForOleVariant((VARIANT*)pNativeValue, ppProtectedComPlusValue);
}


//=======================================================================
// See FieldMarshaler for details.
//=======================================================================
VOID FieldMarshaler_Variant::DestroyNative(LPVOID pNativeValue) const 
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    SafeVariantClear( (VARIANT*)pNativeValue );

}



FieldMarshaler *FieldMarshaler::RestoreConstruct(MethodTable* pMT, void *space, Module *pModule)
{
    BOOL BestFit;
    BOOL ThrowOnUnmappableChar;

    THROWSCOMPLUSEXCEPTION();
    switch (*(int*)space)
    {
    case CLASS_BSTR:
        return new (space) FieldMarshaler_BSTR(pModule);
    case CLASS_NESTED_LAYOUT_CLASS:
        return new (space) FieldMarshaler_NestedLayoutClass(pModule);
    case CLASS_NESTED_VALUE_CLASS:
        return new (space) FieldMarshaler_NestedValueClass(pModule);
    case CLASS_STRING_UNI:
        return new (space) FieldMarshaler_StringUni(pModule);
    case CLASS_STRING_ANSI:
        ReadBestFitCustomAttribute(pMT->GetModule()->GetMDImport(), pMT->GetClass()->GetCl(), &BestFit, &ThrowOnUnmappableChar);
        return new (space) FieldMarshaler_StringAnsi(pModule, BestFit, ThrowOnUnmappableChar);
    case CLASS_FIXED_STRING_UNI:
        return new (space) FieldMarshaler_FixedStringUni(pModule);
    case CLASS_FIXED_STRING_ANSI:
        ReadBestFitCustomAttribute(pMT->GetModule()->GetMDImport(), pMT->GetClass()->GetCl(), &BestFit, &ThrowOnUnmappableChar);
        return new (space) FieldMarshaler_FixedStringAnsi(pModule, BestFit, ThrowOnUnmappableChar);
    case CLASS_FIXED_CHAR_ARRAY_ANSI:
        ReadBestFitCustomAttribute(pMT->GetModule()->GetMDImport(), pMT->GetClass()->GetCl(), &BestFit, &ThrowOnUnmappableChar);
        return new (space) FieldMarshaler_FixedCharArrayAnsi(pModule, BestFit, ThrowOnUnmappableChar);
    case CLASS_FIXED_BOOL_ARRAY:
        return new (space) FieldMarshaler_FixedBoolArray(pModule);
    case CLASS_FIXED_BSTR_ARRAY:
        return new (space) FieldMarshaler_FixedBSTRArray(pModule);
    case CLASS_FIXED_SCALAR_ARRAY:
        return new (space) FieldMarshaler_FixedScalarArray(pModule);
    case CLASS_SAFEARRAY:
        return new (space) FieldMarshaler_SafeArray(pModule);
    case CLASS_DELEGATE:
        return new (space) FieldMarshaler_Delegate(pModule);
    case CLASS_INTERFACE:
        return new (space) FieldMarshaler_Interface(pModule);
    case CLASS_VARIANT:
        return new (space) FieldMarshaler_Variant(pModule);
    case CLASS_ILLEGAL:
        return new (space) FieldMarshaler_Illegal(pModule);
    case CLASS_COPY1:
        return new (space) FieldMarshaler_Copy1(pModule);
    case CLASS_COPY2:
        return new (space) FieldMarshaler_Copy2(pModule);
    case CLASS_COPY4:
        return new (space) FieldMarshaler_Copy4(pModule);
    case CLASS_COPY8:
        return new (space) FieldMarshaler_Copy8(pModule);
    case CLASS_ANSI:
        ReadBestFitCustomAttribute(pMT->GetModule()->GetMDImport(), pMT->GetClass()->GetCl(), &BestFit, &ThrowOnUnmappableChar);
        return new (space) FieldMarshaler_Ansi(pModule, BestFit, ThrowOnUnmappableChar);
    case CLASS_WINBOOL:
        return new (space) FieldMarshaler_WinBool(pModule);
    case CLASS_CBOOL:
        return new (space) FieldMarshaler_CBool(pModule);
    case CLASS_DECIMAL:
        return new (space) FieldMarshaler_Decimal(pModule);
    case CLASS_DATE:
        return new (space) FieldMarshaler_Date(pModule);
    case CLASS_VARIANTBOOL:
        return new (space) FieldMarshaler_VariantBool(pModule);
    case CLASS_CURRENCY:
        return new (space) FieldMarshaler_Currency(pModule);
    default:
        _ASSERTE(!"Unknown FieldMarshaler type");
        return NULL;
    }
}



#ifdef CUSTOMER_CHECKED_BUILD


VOID OutputCustomerCheckedBuildNStructFieldType(FieldSig             fSig, 
                                                LayoutRawFieldInfo  *const pFWalk, 
                                                CorElementType       elemType,
                                                LPCUTF8              szNamespace,
                                                LPCUTF8              szStructName,
                                                LPCUTF8              szFieldName)
{
    UINT                iFullStructNameLen, iFieldNameLen;
    CQuickArray<WCHAR>  strFullStructName, strFieldName, strFullFieldName;
    static WCHAR        strFullFieldNameFormat[] = {L"%s::%s"};

    CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_Marshaling))
        return;
        
    // Convert the fully qualified struct name.
    iFullStructNameLen = (UINT)strlen(szNamespace) + 1 + (UINT)strlen(szStructName) + 1;
    ns::MakePath(strFullStructName, szNamespace, szStructName);  // MakePath call Alloc for the CQuickArray<WCHAR> strFullStructName

    // Convert the field name.
    iFieldNameLen = (UINT)strlen(szFieldName) + 1;
    strFieldName.Alloc(iFieldNameLen);
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szFieldName, -1, strFieldName.Ptr(), iFieldNameLen);

    // Concatenate all names together.
    strFullFieldName.Alloc((UINT)strFullStructName.Size() + (UINT)strFieldName.Size() + lengthof(strFullFieldNameFormat));
    Wszwsprintf((LPWSTR)strFullFieldName.Ptr(), strFullFieldNameFormat, strFullStructName.Ptr(), strFieldName.Ptr());

    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_Marshaling, strFullFieldName.Ptr()))
    {
        // Collect information for marshal type on the managed side.

        CQuickArray<WCHAR>  strManagedType, strUnmanagedType;
        CQuickArray<WCHAR>  strMessage;
        static WCHAR        strMessageFormat[] = {L"Marshaling from %s to %s for field %s."};


        if (!CheckForPrimitiveType(elemType, &strManagedType))
        {
            // The following hack is added to avoid a recursion caused by calling GetTypeHandle on
            // the m_value field of the UIntPtr class.
            if (strcmp(szNamespace, "System") == 0 && strcmp(szStructName, "UIntPtr") == 0)
            {
                static LPWSTR strRetVal = L"Void*";
                strManagedType.Alloc((UINT)wcslen(strRetVal) + 1);
                wcscpy(strManagedType.Ptr(), strRetVal);
            }
            else
            {
                UINT        iManagedTypeLen; 
                OBJECTREF   throwable = NULL;
                TypeHandle  th;
                SigFormat   sigFmt;

                BEGIN_ENSURE_COOPERATIVE_GC();

                    GCPROTECT_BEGIN(throwable);

                        th = fSig.GetTypeHandle(&throwable);
                        if (throwable != NULL)
                        {
                            static WCHAR strErrorMsg[] = {L"<error>"};
                            strManagedType.Alloc(lengthof(strErrorMsg));
                            wcscpy(strManagedType.Ptr(), strErrorMsg);
                        }
                        else
                        {
                            sigFmt.AddType(th);
                            iManagedTypeLen = (UINT)strlen(sigFmt.GetCString()) + 1;
                            strManagedType.Alloc(iManagedTypeLen);
                            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sigFmt.GetCString(), -1, strManagedType.Ptr(), iManagedTypeLen);
                        }

                    GCPROTECT_END();

                END_ENSURE_COOPERATIVE_GC();
            }
        }

        // Collect information for marshal type on the native side.

        NStructFieldTypeToString(pFWalk, elemType, &strUnmanagedType);
        strMessage.Alloc(lengthof(strMessageFormat) + (UINT)strManagedType.Size() + (UINT)strUnmanagedType.Size() + strFullFieldName.Size());
        Wszwsprintf(strMessage.Ptr(), strMessageFormat, strManagedType.Ptr(), strUnmanagedType.Ptr(), strFullFieldName.Ptr());
        pCdh->LogInfo(strMessage.Ptr(), CustomerCheckedBuildProbe_Marshaling);
    }
}


VOID NStructFieldTypeToString(LayoutRawFieldInfo *const pFWalk, CorElementType elemType, CQuickArray<WCHAR> *pStrNStructFieldType)
{
    UINT8   nfType = pFWalk->m_nft;
    LPWSTR  strRetVal;

    // Some NStruct Field Types have extra information and require special handling.
    if (nfType == NFT_FIXEDCHARARRAYANSI)
    {
        UINT32          iSize       = ((FieldMarshaler_FixedCharArrayAnsi *)&(pFWalk->m_FieldMarshaler))->NativeSize();
        static WCHAR    strTemp[]   = {L"fixed array of ANSI char (size = %i bytes)"};

        pStrNStructFieldType->Alloc(lengthof(strTemp) + MAX_INT32_DECIMAL_CHAR_LEN);
        Wszwsprintf(pStrNStructFieldType->Ptr(), strTemp, iSize);
        return;
    }
    else if (nfType == NFT_FIXEDBOOLARRAY) 
    {
        UINT32          iSize       = ((FieldMarshaler_FixedBoolArray *)&(pFWalk->m_FieldMarshaler))->NativeSize();
        static WCHAR    strTemp[]   = {L"fixed array of Bool (size = %i bytes)"};

        pStrNStructFieldType->Alloc(lengthof(strTemp) + MAX_INT32_DECIMAL_CHAR_LEN);
        Wszwsprintf(pStrNStructFieldType->Ptr(), strTemp, iSize);
        return;
    }
    else if (nfType == NFT_FIXEDBSTRARRAY)
    {
        UINT32          iSize       = ((FieldMarshaler_FixedBSTRArray *)&(pFWalk->m_FieldMarshaler))->NativeSize();
        static WCHAR    strTemp[]   = {L"fixed array of BSTR (size = %i bytes)"};

        pStrNStructFieldType->Alloc(lengthof(strTemp) + MAX_INT32_DECIMAL_CHAR_LEN);
        Wszwsprintf(pStrNStructFieldType->Ptr(), strTemp, iSize);
        return;
    }
    else if (nfType == NFT_SAFEARRAY)
    {
        UINT32              iSize       = ((FieldMarshaler_SafeArray*)&(pFWalk->m_FieldMarshaler))->NativeSize();
        static WCHAR        strTemp[]   = {L"safearray of %s (header size = %i bytes)"};
        LPWSTR              strElemType;

        // The following CorElementTypes are the only ones handled with FieldMarshaler_SafeArray. 
        switch (((FieldMarshaler_SafeArray *)&(pFWalk->m_FieldMarshaler))->GetElementType())
        {
            case ELEMENT_TYPE_I1:
                strElemType = L"SByte";
                break;

            case ELEMENT_TYPE_U1:
                strElemType = L"Byte";
                break;

            case ELEMENT_TYPE_I2:
                strElemType = L"Int16";
                break;

            case ELEMENT_TYPE_U2:
                strElemType = L"UInt16";
                break;

            IN_WIN32(case ELEMENT_TYPE_I:)
            case ELEMENT_TYPE_I4:
                strElemType = L"Int32";
                break;

            IN_WIN32(case ELEMENT_TYPE_U:)
            case ELEMENT_TYPE_U4:
                strElemType = L"UInt32";
                break;

            IN_WIN64(case ELEMENT_TYPE_I:)
            case ELEMENT_TYPE_I8:
                strElemType = L"Int64";
                break;

            IN_WIN64(case ELEMENT_TYPE_U:)
            case ELEMENT_TYPE_U8:
                strElemType = L"UInt64";
                break;

            case ELEMENT_TYPE_R4:
                strElemType = L"Single";
                break;

            case ELEMENT_TYPE_R8:
                strElemType = L"Double";
                break;

            case ELEMENT_TYPE_CHAR:
                strElemType = L"Unicode char";
                break;

            default:
                strElemType = L"Unknown";
                break;
        }

        // lengthof(strTemp) includes a NULL character already, so we do not have to add 1 to wcslen(strElemType).
        pStrNStructFieldType->Alloc(lengthof(strTemp) + (UINT)wcslen(strElemType) + MAX_INT32_DECIMAL_CHAR_LEN);
        Wszwsprintf(pStrNStructFieldType->Ptr(), strTemp, strElemType, iSize);
        return;
    }
    
    else if (nfType == NFT_FIXEDSCALARARRAY)
    {
        UINT32              iSize       = ((FieldMarshaler_FixedScalarArray *)&(pFWalk->m_FieldMarshaler))->NativeSize();
        static WCHAR        strTemp[]   = {L"fixed array of %s (size = %i bytes)"};
        LPWSTR              strElemType;

        // The following CorElementTypes are the only ones handled with FieldMarshaler_FixedScalarArray. 
        switch (((FieldMarshaler_FixedScalarArray *)&(pFWalk->m_FieldMarshaler))->GetElementType())
        {
            case ELEMENT_TYPE_I1:
                strElemType = L"SByte";
                break;

            case ELEMENT_TYPE_U1:
                strElemType = L"Byte";
                break;

            case ELEMENT_TYPE_I2:
                strElemType = L"Int16";
                break;

            case ELEMENT_TYPE_U2:
                strElemType = L"UInt16";
                break;

            IN_WIN32(case ELEMENT_TYPE_I:)
            case ELEMENT_TYPE_I4:
                strElemType = L"Int32";
                break;

            IN_WIN32(case ELEMENT_TYPE_U:)
            case ELEMENT_TYPE_U4:
                strElemType = L"UInt32";
                break;

            IN_WIN64(case ELEMENT_TYPE_I:)
            case ELEMENT_TYPE_I8:
                strElemType = L"Int64";
                break;

            IN_WIN64(case ELEMENT_TYPE_U:)
            case ELEMENT_TYPE_U8:
                strElemType = L"UInt64";
                break;

            case ELEMENT_TYPE_R4:
                strElemType = L"Single";
                break;

            case ELEMENT_TYPE_R8:
                strElemType = L"Double";
                break;

            case ELEMENT_TYPE_CHAR:
                strElemType = L"Unicode char";
                break;

            default:
                strElemType = L"Unknown";
                break;
        }

        // lengthof(strTemp) includes a NULL character already, so we do not have to add 1 to wcslen(strElemType).
        pStrNStructFieldType->Alloc(lengthof(strTemp) + (UINT)wcslen(strElemType) + MAX_INT32_DECIMAL_CHAR_LEN);
        Wszwsprintf(pStrNStructFieldType->Ptr(), strTemp, strElemType, iSize);
        return;
    }
    else if (nfType == NFT_INTERFACE)
    {
        MethodTable *pItfMT     = NULL;
        BOOL         fDispItf   = FALSE;

        ((FieldMarshaler_Interface *)&(pFWalk->m_FieldMarshaler))->GetInterfaceInfo(&pItfMT, &fDispItf);

        if (pItfMT)
        {
            DefineFullyQualifiedNameForClassW();
            GetFullyQualifiedNameForClassW(pItfMT->GetClass());

            if (fDispItf)
            {
                static WCHAR strTemp[] = {L"IDispatch %s"};
                pStrNStructFieldType->Alloc(lengthof(strTemp) + wcslen(_wszclsname_));
                Wszwsprintf(pStrNStructFieldType->Ptr(), strTemp, _wszclsname_);
                return;
            }
            else
            {
                static WCHAR strTemp[] = {L"IUnknown %s"};
                pStrNStructFieldType->Alloc(lengthof(strTemp) + wcslen(_wszclsname_));
                Wszwsprintf(pStrNStructFieldType->Ptr(), strTemp, _wszclsname_);
                return;
            }
        }
        else
        {
            if (fDispItf)
                strRetVal = L"IDispatch";
            else
                strRetVal = L"IUnknown";
        }
    }
    else if (nfType == NFT_NESTEDLAYOUTCLASS)
    {
        MethodTable     *pMT                = ((FieldMarshaler_NestedLayoutClass *)&(pFWalk->m_FieldMarshaler))->GetMethodTable();
        static WCHAR     strNestedClass[]   = {L"nested layout class %s"};

        DefineFullyQualifiedNameForClassW();
        GetFullyQualifiedNameForClassW(pMT->GetClass());

        pStrNStructFieldType->Alloc(lengthof(strNestedClass) + (UINT)wcslen(_wszclsname_));
        Wszwsprintf(pStrNStructFieldType->Ptr(), strNestedClass, _wszclsname_);
        return;
    }
    else if (nfType == NFT_NESTEDVALUECLASS)
    {
        MethodTable     *pMT                = ((FieldMarshaler_NestedValueClass *)&(pFWalk->m_FieldMarshaler))->GetMethodTable();
        static WCHAR     strNestedClass[]   = {L"nested value class %s"};

        DefineFullyQualifiedNameForClassW();
        GetFullyQualifiedNameForClassW(pMT->GetClass());

        pStrNStructFieldType->Alloc(lengthof(strNestedClass) + (UINT)wcslen(_wszclsname_));
        Wszwsprintf(pStrNStructFieldType->Ptr(), strNestedClass, _wszclsname_);
        return;
    }
    else if (nfType == NFT_COPY1)
    {
        // The following CorElementTypes are the only ones handled with FieldMarshaler_Copy1. 
        switch (elemType)
        {
            case ELEMENT_TYPE_I1:
                strRetVal = L"SByte";
                break;

            case ELEMENT_TYPE_U1:
                strRetVal = L"Byte";
                break;

            default:
                strRetVal = L"Unknown";
                break;
        }
    }
    else if (nfType == NFT_COPY2)
    {
        // The following CorElementTypes are the only ones handled with FieldMarshaler_Copy2. 
        switch (elemType)
        {
            case ELEMENT_TYPE_CHAR:
                strRetVal = L"Unicode char";
                break;

            case ELEMENT_TYPE_I2:
                strRetVal = L"Int16";
                break;

            case ELEMENT_TYPE_U2:
                strRetVal = L"UInt16";
                break;

            default:
                strRetVal = L"Unknown";
                break;
        }
    }
    else if (nfType == NFT_COPY4)
    {
        // The following CorElementTypes are the only ones handled with FieldMarshaler_Copy4. 
        switch (elemType)
        {
            // At this point, ELEMENT_TYPE_I must be 4 bytes long.  Same for ELEMENT_TYPE_U.
            case ELEMENT_TYPE_I:
            case ELEMENT_TYPE_I4:
                strRetVal = L"Int32";
                break;

            case ELEMENT_TYPE_U:
            case ELEMENT_TYPE_U4:
                strRetVal = L"UInt32";
                break;

            case ELEMENT_TYPE_R4:
                strRetVal = L"Single";
                break;

            case ELEMENT_TYPE_PTR:
                strRetVal = L"4-byte pointer";
                break;

            default:
                strRetVal = L"Unknown";
                break;
        }
    }
    else if (nfType == NFT_COPY8)
    {
        // The following CorElementTypes are the only ones handled with FieldMarshaler_Copy8. 
        switch (elemType)
        {
            // At this point, ELEMENT_TYPE_I must be 8 bytes long.  Same for ELEMENT_TYPE_U and ELEMENT_TYPE_R.
            case ELEMENT_TYPE_I:
            case ELEMENT_TYPE_I8:
                strRetVal = L"Int64";
                break;

            case ELEMENT_TYPE_U:
            case ELEMENT_TYPE_U8:
                strRetVal = L"UInt64";
                break;

            case ELEMENT_TYPE_R:
            case ELEMENT_TYPE_R8:
                strRetVal = L"Double";
                break;

            case ELEMENT_TYPE_PTR:
                strRetVal = L"8-byte pointer";
                break;

            default:
                strRetVal = L"Unknown";
                break;
        }
    }
    else
    {
        // All other NStruct Field Types which do not require special handling.
        switch (nfType)
        {
            case NFT_NONE:
                strRetVal = L"illegal type";
                break;
            case NFT_BSTR:
                strRetVal = L"BSTR";
                break;
            case NFT_STRINGUNI:
                strRetVal = L"LPWSTR";
                break;
            case NFT_STRINGANSI:
                strRetVal = L"LPSTR";
                break;
            case NFT_FIXEDSTRINGUNI:
                strRetVal = L"embedded LPWSTR";
                break;
            case NFT_FIXEDSTRINGANSI:
                strRetVal = L"embedded LPSTR";
                break;
            case NFT_DELEGATE:
                strRetVal = L"Delegate";
                break;
            case NFT_VARIANT:
                strRetVal = L"VARIANT";
                break;
            case NFT_ANSICHAR:
                strRetVal = L"ANSI char";
                break;
            case NFT_WINBOOL:
                strRetVal = L"Windows Bool";
                break;
            case NFT_CBOOL:
                strRetVal = L"CBool";
                break;
            case NFT_DECIMAL:
                strRetVal = L"DECIMAL";
                break;
            case NFT_DATE:
                strRetVal = L"DATE";
                break;
            case NFT_VARIANTBOOL:
                strRetVal = L"VARIANT Bool";
                break;
            case NFT_CURRENCY:
                strRetVal = L"CURRENCY";
                break;
            case NFT_ILLEGAL:
                strRetVal = L"illegal type";
                break;
            default:
                strRetVal = L"<UNKNOWN>";
                break;
        }
    }

    pStrNStructFieldType->Alloc((UINT)wcslen(strRetVal) + 1);
    wcscpy(pStrNStructFieldType->Ptr(), strRetVal);
    return;
}


BOOL CheckForPrimitiveType(CorElementType elemType, CQuickArray<WCHAR> *pStrPrimitiveType)
{
    LPWSTR  strRetVal;

    switch (elemType)
    {
        case ELEMENT_TYPE_VOID:
            strRetVal = L"Void";
            break;
        case ELEMENT_TYPE_BOOLEAN:
            strRetVal = L"Boolean";
            break;
        case ELEMENT_TYPE_I1:
            strRetVal = L"SByte";
            break;
        case ELEMENT_TYPE_U1:
            strRetVal = L"Byte";
            break;
        case ELEMENT_TYPE_I2:
            strRetVal = L"Int16";
            break;
        case ELEMENT_TYPE_U2:
            strRetVal = L"UInt16";
            break;
        case ELEMENT_TYPE_CHAR:
            strRetVal = L"Char";
            break;
        case ELEMENT_TYPE_I:
            strRetVal = L"IntPtr";
            break;
        case ELEMENT_TYPE_U:
            strRetVal = L"UIntPtr";
            break;
        case ELEMENT_TYPE_I4:
            strRetVal = L"Int32"; 
            break;
        case ELEMENT_TYPE_U4:       
            strRetVal = L"UInt32"; 
            break;
        case ELEMENT_TYPE_I8:       
            strRetVal = L"Int64"; 
            break;
        case ELEMENT_TYPE_U8:       
            strRetVal = L"UInt64"; 
            break;
        case ELEMENT_TYPE_R4:       
            strRetVal = L"Single"; 
            break;
        case ELEMENT_TYPE_R8:       
            strRetVal = L"Double"; 
            break;
        default:
            return false;
    }

    pStrPrimitiveType->Alloc((UINT)wcslen(strRetVal) + 1);
    wcscpy(pStrPrimitiveType->Ptr(), strRetVal);
    return true;
}


#endif // CUSTOMER_CHECKED_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\object.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// OBJECT.CPP
//
// Definitions of a Com+ Object
//

#include "common.h"

#include "vars.hpp"
#include "class.h"
#include "object.h"
#include "threads.h"
#include "excep.h"
#include "EEConfig.h"
#include "gc.h"
#include "remoting.h"
#include "field.h"

#include "comclass.h"

BOOL CanBoxToObject(MethodTable *pMT) {
    if ((pMT->GetParentMethodTable() == g_pValueTypeClass) ||
        (pMT->GetParentMethodTable() == g_pEnumClass)) {
            return TRUE;
    }
    return FALSE;
}

MethodTable *Object::GetTrueMethodTable()
{
    return GetMethodTable()->AdjustForThunking(ObjectToOBJECTREF(this));
}

EEClass *Object::GetTrueClass()
{
    return GetClass()->AdjustForThunking(ObjectToOBJECTREF(this));
}

TypeHandle Object::GetTypeHandle()
{
    if (m_pMethTab->IsArray())
        return ((ArrayBase*) this)->GetTypeHandle();
    else 
        return TypeHandle(m_pMethTab);
}

TypeHandle ArrayBase::GetTypeHandle() const
{
    TypeHandle elemType = GetElementTypeHandle();
    CorElementType kind = GetMethodTable()->GetNormCorElementType();
    unsigned rank = GetArrayClass()->GetRank();
    TypeHandle arrayType = elemType.GetModule()->GetClassLoader()->FindArrayForElem(elemType, kind, rank);
    _ASSERTE(!arrayType.IsNull());
    return(arrayType);
}

BOOL ArrayBase::IsSZRefArray() const
{
    return(GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_SZARRAY && CorTypeInfo::IsObjRef(GetElementType()));
}

void Object::SetAppDomain(AppDomain *pDomain)
{
    _ASSERTE(pDomain != NULL);

#ifndef _DEBUG
    if (!GetMethodTable()->IsShared())
    {
        //
        // If we have a per-app-domain method table, we can 
        // infer the app domain from the method table, so 
        // there is no reason to mark the object.
        //
        // But we don't do this in a debug build, because
        // we want to be able to detect the case when the
        // domain was unloaded from underneath an object (and
        // the MethodTable will be toast in that case.)
        //

        _ASSERTE(pDomain == GetMethodTable()->GetDomain());
    }
    else
#endif
    {
        DWORD index = pDomain->GetIndex();
        GetHeader()->SetAppDomainIndex(index);
    }

    _ASSERTE(GetHeader()->GetAppDomainIndex() != 0);
}


AppDomain *Object::GetAppDomain()
{
#ifndef _DEBUG
    if (!GetMethodTable()->IsShared())
        return (AppDomain*) GetMethodTable()->GetModule()->GetDomain();
#endif

    DWORD index = GetHeader()->GetAppDomainIndex();

    if (index == 0)
        return NULL;

    AppDomain *pDomain = SystemDomain::TestGetAppDomainAtIndex(index);

#if CHECK_APP_DOMAIN_LEAKS
    if (! g_pConfig->AppDomainLeaks())
        return pDomain;

    if (IsAppDomainAgile())
        return NULL;

    //
    // If an object has an index of an unloaded domain (its ok to be of a 
    // domain where an unload is in progress through), go ahead
    // and make it agile. If this fails, we have an invalid reference
    // to an unloaded domain.  If it succeeds, the object is no longer
    // contained in that app domain so we can continue.
    //

    if (pDomain == NULL)
	{
		if (SystemDomain::IndexOfAppDomainBeingUnloaded() == index) {
			// if appdomain is unloading but still alive and is valid to have instances
			// in that domain, then use it.
			AppDomain *tmpDomain = SystemDomain::AppDomainBeingUnloaded();
			if (tmpDomain && tmpDomain->ShouldHaveInstances())
				pDomain = tmpDomain;
		}
		if (!pDomain && ! SetAppDomainAgile(FALSE))
			_ASSERTE(!"Attempt to reference an object belonging to an unloaded domain");
    }
#endif

    return pDomain;
}

#if CHECK_APP_DOMAIN_LEAKS

BOOL Object::IsAppDomainAgile()
{
    SyncBlock *psb = GetRawSyncBlock();

    if (psb)
    {
        if (psb->IsAppDomainAgile())
            return TRUE;
        if (psb->IsCheckedForAppDomainAgile())
            return FALSE;
    }
    return CheckAppDomain(NULL);
}

BOOL Object::SetAppDomainAgile(BOOL raiseAssert)
{
    if (!g_pConfig->AppDomainLeaks())
        return TRUE;

    if (this == NULL)
        return TRUE;

    if (IsAppDomainAgile())
        return TRUE;

    // if it's not agile and we've already checked it, just bail early
    if (IsCheckedForAppDomainAgile())
        return FALSE;

    if (IsTypeNeverAppDomainAgile())
    {
        if (raiseAssert)
            _ASSERTE(!"Attempt to reference a domain bound object from an agile location");
        return FALSE;
    }

    //
    // Do not allow any object to be set to be agile unless we 
    // are compiling field access checking into the class.  This
    // will help guard against unintentional "agile" propagation
    // as well.
    //

    if (!IsTypeAppDomainAgile() && !IsTypeCheckAppDomainAgile()) 
    {
        if (raiseAssert)
            _ASSERTE(!"Attempt to reference a domain bound object from an agile location");
        return FALSE;
    }

	ObjHeader* pOh = GetHeader();
	_ASSERTE(pOh);

	pOh->EnterSpinLock();
	
		if (pOh->GetBits() & BIT_SBLK_AGILE_IN_PROGRESS)
		{
			pOh->ReleaseSpinLock();
			return TRUE;
		}

		pOh->SetBit(BIT_SBLK_AGILE_IN_PROGRESS);

	pOh->ReleaseSpinLock();
	
    if (! IsTypeAppDomainAgile() && ! SetFieldsAgile(raiseAssert))
    {
        SetIsCheckedForAppDomainAgile();
        
        pOh->EnterSpinLock();
		pOh->ClrBit(BIT_SBLK_AGILE_IN_PROGRESS);
        pOh->ReleaseSpinLock();
        
        return FALSE;
    }

    pOh->EnterSpinLock();
	    pOh->ClrBit(BIT_SBLK_AGILE_IN_PROGRESS);
    pOh->ReleaseSpinLock();
    
    SetSyncBlockAppDomainAgile();
    return TRUE;
}

void Object::SetSyncBlockAppDomainAgile()
{
    SyncBlock *psb = GetRawSyncBlock();
    if (! psb)
    {
        // can't alloc memory if don't have a thread
        if (! GetThread())
            return;

        COMPLUS_TRY {
            psb = GetSyncBlock();
        } COMPLUS_CATCH {
            // eat any exceptions
        } COMPLUS_END_CATCH;
    }
    if (psb)
        psb->SetIsAppDomainAgile();
}

BOOL Object::CheckAppDomain(AppDomain *pAppDomain)
{
    if (!g_pConfig->AppDomainLeaks())
        return TRUE;

    if (this == NULL)
        return TRUE;

    if (IsAppDomainAgileRaw())
        return TRUE;

    MethodTable *pMT = GetGCSafeMethodTable();

#ifndef _DEBUG
    if (!pMT->IsShared())
        return pAppDomain == pMT->GetModule()->GetDomain();
#endif

    DWORD index = GetHeader()->GetAppDomainIndex();

    _ASSERTE(index);

    return (pAppDomain != NULL && index == pAppDomain->GetIndex());
}

BOOL Object::IsTypeAppDomainAgile()
{
    MethodTable *pMT = GetGCSafeMethodTable();

    if (pMT->IsArray())
    {
        TypeHandle th = ((ArrayClass*)(pMT->GetClass()))->GetElementTypeHandle();
        return th.IsArrayOfElementsAppDomainAgile();
    }
    else if (pMT->HasSharedMethodTable())
        return FALSE;
    else
        return pMT->GetClass()->IsAppDomainAgile();
}

BOOL Object::IsTypeCheckAppDomainAgile()
{
    MethodTable *pMT = GetGCSafeMethodTable();

    if (pMT->IsArray())
    {
        TypeHandle th = ((ArrayClass*)(pMT->GetClass()))->GetElementTypeHandle();
        return th.IsArrayOfElementsCheckAppDomainAgile();
    }
    else if (pMT->HasSharedMethodTable())
        return FALSE;
    else
        return pMT->GetClass()->IsCheckAppDomainAgile();
}

BOOL Object::IsTypeNeverAppDomainAgile()
{
    return !IsTypeAppDomainAgile() && !IsTypeCheckAppDomainAgile();
}

BOOL Object::IsTypeTypesafeAppDomainAgile()
{
    return IsTypeAppDomainAgile() && !IsTypeCheckAppDomainAgile();
}

BOOL Object::AssignAppDomain(AppDomain *pAppDomain, BOOL raiseAssert)
{
    if (!g_pConfig->AppDomainLeaks())
        return TRUE;

    if (CheckAppDomain(pAppDomain))
        return TRUE;

    //
    // App domain does not match; try to make this object agile
    //

    if (IsTypeNeverAppDomainAgile())
    {
        if (raiseAssert)
        {
            if (pAppDomain == NULL)
                _ASSERTE(!"Attempt to reference a domain bound object from an agile location");
            else
                _ASSERTE(!"Attempt to reference a domain bound object from a different domain");
        }
        return FALSE;
    }
    else
    {
        //
        // Make object agile
        //

        if (! IsTypeAppDomainAgile() && ! SetFieldsAgile(raiseAssert))
        {
            SetIsCheckedForAppDomainAgile();
			return FALSE;
        }

        SetSyncBlockAppDomainAgile();

		return TRUE;        
    }
}

BOOL Object::AssignValueTypeAppDomain(EEClass *pClass, void *base, AppDomain *pAppDomain, BOOL raiseAssert)
{
    if (!g_pConfig->AppDomainLeaks())
        return TRUE;

    if (pClass->IsAppDomainAgile())
        return TRUE;

    if (pAppDomain == NULL)
    {
        //
        // Do not allow any object to be set to be agile unless we 
        // are compiling field access checking into the class.  This
        // will help guard against unintentional "agile" propagation
        // as well.
        //

        if (pClass->IsNeverAppDomainAgile())
        {
            _ASSERTE(!"Attempt to reference a domain bound object from an agile location");
            return FALSE;
        }

        return SetClassFieldsAgile(pClass, base, TRUE/*=baseIsVT*/, raiseAssert);
    }
    else
    {
        return ValidateClassFields(pClass, base, TRUE/*=baseIsVT*/, pAppDomain, raiseAssert);
    }
}

BOOL Object::SetFieldsAgile(BOOL raiseAssert)
{
    BOOL result = TRUE;

    EEClass *pClass = GetGCSafeClass();

    if (pClass->IsArrayClass())
    {
        switch (((ArrayClass*)pClass)->GetElementType())
        {
        case ELEMENT_TYPE_CLASS:
            {
                PtrArray *pArray = (PtrArray *) this;

                DWORD n = pArray->GetNumComponents();
                OBJECTREF *p = (OBJECTREF *) 
                  (((BYTE*)pArray) + ArrayBase::GetDataPtrOffset(GetGCSafeMethodTable()));

                for (DWORD i=0; i<n; i++)
                    if (!p[i]->SetAppDomainAgile(raiseAssert))
                        result = FALSE;

                break;
            }
        case ELEMENT_TYPE_VALUETYPE:
            {
                ArrayClass *pArrayClass = (ArrayClass *)pClass;
                ArrayBase *pArray = (ArrayBase *) this;

                EEClass *pClass = pArrayClass->GetElementTypeHandle().AsClass();

                BYTE *p = ((BYTE*)pArray) + ArrayBase::GetDataPtrOffset(GetGCSafeMethodTable());
                unsigned size = pArray->GetComponentSize();
                DWORD n = pArray->GetNumComponents();

                for (DWORD i=0; i<n; i++)
                    if (!SetClassFieldsAgile(pClass, p + i*size, TRUE/*=baseIsVT*/, raiseAssert))
                        result = FALSE;

                break;
            }
            
        default:
            _ASSERTE(!"Unexpected array type");
        }
    }
    else
    {
        if (pClass->IsNeverAppDomainAgile())
        {
            _ASSERTE(!"Attempt to reference a domain bound object from an agile location");
            return FALSE;
        }

        while (pClass != NULL && !pClass->IsTypesafeAppDomainAgile())
        {
            if (!SetClassFieldsAgile(pClass, this, FALSE/*=baseIsVT*/, raiseAssert))
                result = FALSE;

            pClass = pClass->GetParentClass();

            if (pClass->IsNeverAppDomainAgile())
            {
                _ASSERTE(!"Attempt to reference a domain bound object from an agile location");
                return FALSE;
            }
        }
    }

    return result;
}

BOOL Object::SetClassFieldsAgile(EEClass *pClass, void *base, BOOL baseIsVT, BOOL raiseAssert)
{
    BOOL result = TRUE;

    if (pClass->IsNeverAppDomainAgile())
    {
        _ASSERTE(!"Attempt to reference a domain bound object from an agile location");
        return FALSE;
    }

    FieldDescIterator fdIterator(pClass, FieldDescIterator::INSTANCE_FIELDS);
    FieldDesc* pField;

    while ((pField = fdIterator.Next()) != NULL)
    {
        if (pField->IsDangerousAppDomainAgileField())
        {
            if (pField->GetFieldType() == ELEMENT_TYPE_CLASS)
            {
                OBJECTREF ref;

                if (baseIsVT)
                    ref = *(OBJECTREF*) pField->GetAddress(base);
                else
                    ref = *(OBJECTREF*) pField->GetAddressGuaranteedInHeap(base, FALSE);

                if (ref != 0 && !ref->IsAppDomainAgile())
                {
                    if (!ref->SetAppDomainAgile(raiseAssert))
                        result = FALSE;
                }
            }
            else if (pField->GetFieldType() == ELEMENT_TYPE_VALUETYPE)
            {
                // Be careful here - we may not have loaded a value
                // type field of a class under prejit, and we don't
                // want to trigger class loading here.

                TypeHandle th = pField->FindType();
                if (!th.IsNull())
                {
                    void *nestedBase;

                    if (baseIsVT)
                        nestedBase = pField->GetAddress(base);
                    else
                        nestedBase = pField->GetAddressGuaranteedInHeap(base, FALSE);

                    if (!SetClassFieldsAgile(th.AsClass(),
                                             nestedBase,
                                             TRUE/*=baseIsVT*/,
                                             raiseAssert))
                        result = FALSE;
                }
            }
            else
                _ASSERTE(!"Bad field type");
        }
    }

    return result;
}

BOOL Object::ValidateAppDomain(AppDomain *pAppDomain)
{
    if (!g_pConfig->AppDomainLeaks())
        return TRUE;

    if (this == NULL)
        return TRUE;

    if (CheckAppDomain())
        return ValidateAppDomainFields(pAppDomain);

    return AssignAppDomain(pAppDomain);
}

BOOL Object::ValidateAppDomainFields(AppDomain *pAppDomain)
{
    BOOL result = TRUE;

    EEClass *pClass = GetGCSafeClass();

    while (pClass != NULL && !pClass->IsTypesafeAppDomainAgile())
    {
        if (!ValidateClassFields(pClass, this, FALSE/*=baseIsVT*/, pAppDomain))
            result = FALSE;

        pClass = pClass->GetParentClass();
    }

    return result;
}

BOOL Object::ValidateValueTypeAppDomain(EEClass *pClass, void *base, AppDomain *pAppDomain, BOOL raiseAssert)
{
    if (!g_pConfig->AppDomainLeaks())
        return TRUE;

    if (pAppDomain == NULL)
    {
        if (pClass->IsTypesafeAppDomainAgile())
            return TRUE;
        else if (pClass->IsNeverAppDomainAgile())
        {
            if (raiseAssert)
                _ASSERTE(!"Value type cannot be app domain agile");
            return FALSE;
        }
    }

    return ValidateClassFields(pClass, base, TRUE/*=baseIsVT*/, pAppDomain, raiseAssert);
}

BOOL Object::ValidateClassFields(EEClass *pClass, void *base, BOOL baseIsVT, AppDomain *pAppDomain, BOOL raiseAssert)
{
    BOOL result = TRUE;
    FieldDescIterator fdIterator(pClass, FieldDescIterator::INSTANCE_FIELDS);
    FieldDesc* pField;

    while ((pField = fdIterator.Next()) != NULL)
    {
        if (!pClass->IsCheckAppDomainAgile() 
            || pField->IsDangerousAppDomainAgileField())
        {
            if (pField->GetFieldType() == ELEMENT_TYPE_CLASS)
            {
                OBJECTREF ref;

                if (baseIsVT)
                    ref = ObjectToOBJECTREF(*(Object**) pField->GetAddress(base));
                else
                    ref = ObjectToOBJECTREF(*(Object**) pField->GetAddressGuaranteedInHeap(base, FALSE));

                if (ref != 0 && !ref->AssignAppDomain(pAppDomain, raiseAssert))
                    result = FALSE;
            }
            else if (pField->GetFieldType() == ELEMENT_TYPE_VALUETYPE)
            {
                // Be careful here - we may not have loaded a value
                // type field of a class under prejit, and we don't
                // want to trigger class loading here.

                TypeHandle th = pField->FindType();
                if (!th.IsNull())
                {
                    void *nestedBase;

                    if (baseIsVT)
                        nestedBase = pField->GetAddress(base);
                    else
                        nestedBase = pField->GetAddressGuaranteedInHeap(base, FALSE);

                    if (!ValidateValueTypeAppDomain(th.AsClass(),
                                                    nestedBase,
                                                    pAppDomain,
                                                    raiseAssert
                                                    ))
                        result = FALSE;

                }
            }
        }
    }

    return result;
}

#endif

void Object::ValidatePromote(ScanContext *sc, DWORD flags)
{

#if defined (VERIFY_HEAP)
    Validate();
#endif

#if CHECK_APP_DOMAIN_LEAKS
    // Do app domain integrity checking here
    if (g_pConfig->AppDomainLeaks())
    {
        AppDomain *pDomain = GetAppDomain();

        //if (flags & GC_CALL_CHECK_APP_DOMAIN)
        //_ASSERTE(AssignAppDomain(sc->pCurrentDomain));

        if (pDomain != NULL 
            && !pDomain->ShouldHaveRoots() 
            && !SetAppDomainAgile(FALSE))    
		{
            _ASSERTE(!"Found GC object which should have been purged during app domain unload.");
		}
    }
#endif
}

void Object::ValidateHeap(Object *from)
{
#if defined (VERIFY_HEAP)
    Validate();
#endif

#if CHECK_APP_DOMAIN_LEAKS
    // Do app domain integrity checking here
    if (g_pConfig->AppDomainLeaks())
    {
        AppDomain *pDomain = from->GetAppDomain();

        // 
        // Don't perform check if we're checking for agility, and the containing type is not
        // marked checked agile - this will cover "proxy" type agility 
        // where cross references are allowed
        //

        if (pDomain != NULL || from->GetClass()->IsCheckAppDomainAgile())
            AssignAppDomain(pDomain);

        if (pDomain != NULL 
            && !pDomain->ShouldHaveInstances() 
            && !SetAppDomainAgile(FALSE))
            _ASSERTE(!"Found GC object which should have been purged during app domain unload.");
    }
#endif
}


//#ifndef GOLDEN

#if defined (VERIFY_HEAP)
//handle faults during concurrent gc.
int process_exception (EXCEPTION_POINTERS* ep){
    PEXCEPTION_RECORD er = ep->ExceptionRecord;
    if (   er->ExceptionCode == STATUS_BREAKPOINT
        || er->ExceptionCode == STATUS_SINGLE_STEP
        || er->ExceptionCode == STATUS_STACK_OVERFLOW)
        return EXCEPTION_CONTINUE_SEARCH;
    if ( er->ExceptionCode != STATUS_ACCESS_VIOLATION)
        return EXCEPTION_EXECUTE_HANDLER;
    void* f_address = (void*)er->ExceptionInformation [1];
    if (g_pGCHeap->HandlePageFault (f_address))
        return EXCEPTION_CONTINUE_EXECUTION;
    else if (COMPlusIsMonitorException(ep))
        return EXCEPTION_CONTINUE_EXECUTION;
    else
        return EXCEPTION_EXECUTE_HANDLER;
}
#endif //VERIFY_HEAP

void Object::SetOffsetObjectRef(DWORD dwOffset, size_t dwValue)
{ 
    OBJECTREF*  location;
    OBJECTREF   o;

    location = (OBJECTREF *) &GetData()[dwOffset];
    o        = ObjectToOBJECTREF(*(Object **)  &dwValue);

    SetObjectReference( location, o, GetAppDomain() );
}        
/******************************************************************/
/*
 * Write Barrier Helper
 *
 * Use this function to assign an object reference into
 * another object.
 *
 * It will set the appropriate GC Write Barrier data
 */

#if CHECK_APP_DOMAIN_LEAKS
void SetObjectReferenceChecked(OBJECTREF *dst,OBJECTREF ref,AppDomain *pAppDomain)
{
    ref->AssignAppDomain(pAppDomain);
    return SetObjectReferenceUnchecked(dst,ref);
}
#endif

void SetObjectReferenceUnchecked(OBJECTREF *dst,OBJECTREF ref)
{
    // Assign value. We use casting to avoid going thru the overloaded
    // OBJECTREF= operator which in this case would trigger a false
    // write-barrier violation assert.
    *(Object**)dst = OBJECTREFToObject(ref);
    ErectWriteBarrier(dst, ref);
}

#if CHECK_APP_DOMAIN_LEAKS
BOOL SetObjectReferenceSafeChecked(OBJECTREF *dst,OBJECTREF ref,AppDomain *pAppDomain)
{
    BOOL assigned = (NULL == FastInterlockCompareExchange((void **)dst, *(void **)&ref, NULL));
    if (assigned) {
        ref->AssignAppDomain(pAppDomain);
        ErectWriteBarrier(dst, ref);
    }
    return assigned;
}
#endif

BOOL SetObjectReferenceSafeUnchecked(OBJECTREF *dst,OBJECTREF ref)
{
    BOOL assigned = (NULL == FastInterlockCompareExchange((void **)dst, *(void **)&ref, NULL));
    if (assigned)
        ErectWriteBarrier(dst, ref);
    return assigned;
}

void ErectWriteBarrier(OBJECTREF *dst,OBJECTREF ref)
{

#ifdef _DEBUG
    Thread::ObjectRefAssign(dst);
#endif

        // if the dst is outside of the heap (unboxed value classes) then we
        //      simply exit
    if (((*(BYTE**)&dst) < g_lowest_address) || ((*(BYTE**)&dst) >= g_highest_address))
                return;
#ifdef _DEBUG
    updateGCShadow((Object**) dst, OBJECTREFToObject(ref));     // support debugging write barrier
#endif

    // Do the Write Barrier thing
    setCardTableEntryInterlocked(*(BYTE**)&dst, *(BYTE**)&ref);
}

/******************************************************************/
    // copies src to dest worrying about write barriers.  
    // Note that it can work on normal objects (but not arrays)
    // if dest, points just after the VTABLE.
#if CHECK_APP_DOMAIN_LEAKS
void CopyValueClassChecked(void* dest, void* src, MethodTable *pMT, AppDomain *pDomain)
{
    Object::AssignValueTypeAppDomain(pMT->GetClass(), src, pDomain);
    CopyValueClassUnchecked(dest,src,pMT);
}
#endif
    
void CopyValueClassUnchecked(void* dest, void* src, MethodTable *pMT) 
{
    _ASSERTE(!pMT->IsArray());  // bunch of assumptions about arrays wrong. 

        // Copy the bulk of the data, and any non-GC refs. 
    switch (pMT->GetClass()->GetNumInstanceFieldBytes())
    {
    case 1:
        *(UINT8*)dest = *(UINT8*)src;
        break;
    case 2:
        *(UINT16*)dest = *(UINT16*)src;
        break;
    case 4:
        *(UINT32*)dest = *(UINT32*)src;
        break;
    case 8:
        *(UINT64*)dest = *(UINT64*)src;
        break;
    default:
    
    memcpyNoGCRefs(dest, src, pMT->GetClass()->GetNumInstanceFieldBytes());
        break;
    }

        // Tell the GC about any copies.  
    if (pMT->ContainsPointers())
    {   
        CGCDesc* map = CGCDesc::GetCGCDescFromMT(pMT);
        CGCDescSeries* cur = map->GetHighestSeries();
        CGCDescSeries* last = map->GetLowestSeries();
        DWORD size = pMT->GetBaseSize();
        _ASSERTE(cur >= last);
        do                                                                  
        {   
            // offset to embedded references in this series must be
            // adjusted by the VTable pointer, when in the unboxed state.
            unsigned offset = cur->GetSeriesOffset() - sizeof(void*);
            OBJECTREF* srcPtr = (OBJECTREF*)(((BYTE*) src) + offset);
            OBJECTREF* destPtr = (OBJECTREF*)(((BYTE*) dest) + offset);
            OBJECTREF* srcPtrStop = (OBJECTREF*)((BYTE*) srcPtr + cur->GetSeriesSize() + size);         
            while (srcPtr < srcPtrStop)                                         
            {   
                SetObjectReferenceUnchecked(destPtr, ObjectToOBJECTREF(*(Object**)srcPtr));
                srcPtr++;
                destPtr++;
            }                                                               
            cur--;                                                              
        } while (cur >= last);                                              
    }
}

#if defined (VERIFY_HEAP)

#include "DbgInterface.h"

    // make the checking code goes as fast as possible!
#pragma optimize("tgy", on)

#ifndef _DEBUG
#ifdef _ASSERTE
#undef _ASSERTE
#endif
#define _ASSERTE(c) if (!(c)) DebugBreak()
#endif

VOID Object::Validate(BOOL bDeep)
{
    if (this == NULL)
    {
        return;     // NULL is ok
    }

    if (g_fEEShutDown & ShutDown_Phase2)
    {
        return; // During second phase of shutdown code below is not guaranteed to work.
    }

    Thread *pThread = GetThread();

#ifdef _DEBUG
    if (pThread != NULL && !(pThread->PreemptiveGCDisabled()))
    {
        // Debugger helper threads are special in that they take over for
        // what would normally be a nonEE thread (the RCThread).  If an
        // EE thread is doing RCThread duty, then it should be treated
        // as such.
        //
        // There are some GC threads in the same kind of category.  Note that
        // GetThread() sometimes returns them, if DLL_THREAD_ATTACH notifications
        // have run some managed code.
        if (!dbgOnly_IsSpecialEEThread())
            _ASSERTE(!"OBJECTREF being accessed while thread is in preemptive GC mode.");
    }
#endif

#ifndef _WIN64 // avoids error C2712: Cannot use __try in functions that require object unwinding
    __try
    {
#endif // !_win64

        MethodTable *pMT = GetGCSafeMethodTable();

        _ASSERTE(pMT->GetClass()->GetMethodTable() == pMT);

        _ASSERTE(g_pGCHeap->IsHeapPointer(this));

        if (bDeep && HasSyncBlockIndex()) {
            DWORD sbIndex = GetHeader()->GetHeaderSyncBlockIndex();
            _ASSERTE(SyncTableEntry::GetSyncTableEntry()[sbIndex].m_Object == this);
        }
        
        if (bDeep && g_pConfig->GetHeapVerifyLevel() == 1) {
            ValidateObjectMember(this);
        }

#ifdef _DEBUG        
        if (g_pGCHeap->IsHeapPointer(this, TRUE)) {
            _ASSERTE (!GCHeap::IsObjectInFixedHeap(this));
        }
#endif        

        if (pMT->IsArray())
        {
            if (pMT->GetClass()->IsArrayClass() == FALSE)
                _ASSERTE(!"Detected use of a corrupted OBJECTREF. Possible GC hole.");

            if (pMT != pMT->m_pEEClass->GetMethodTable())
                _ASSERTE(!"Detected use of a corrupted OBJECTREF. Possible GC hole.");
        }
        else if (pMT != pMT->m_pEEClass->GetMethodTable())
        {
            // The special case where this can happen is Context proxies, where we
            // build a small number of large VTables and share them.
            if (!pMT->IsThunking() ||
                !pMT->m_pEEClass->IsThunking())
            {
                _ASSERTE(!"Detected use of a corrupted OBJECTREF. Possible GC hole.");
            }
        }

#if CHECK_APP_DOMAIN_LEAKS
        if (g_pConfig->AppDomainLeaks())
        {
            //
            // Check to see that our domain is valid.  This will assert if it has been unloaded.
            //
            AppDomain *pDomain = GetAppDomain();
        }
#endif

#if 0
        if (CRemotingServices::IsInstanceOfContext(pMT->m_pEEClass))
        {
            Context *pContext = ((ContextBaseObject*)this)->GetInternalContext();
            if (pContext && !Context::ValidateContext(pContext))
                _ASSERTE(!"Detected use of a corrupted context object.");
        }
#endif

#ifndef _WIN64 // avoids error C2712: Cannot use __try in functions that require object unwinding
    }
    __except(process_exception( GetExceptionInformation()))
    {
        _ASSERTE(!"Detected use of a corrupted OBJECTREF. Possible GC hole.");
    }
#endif // !_WIN64

}

#ifndef _DEBUG
#undef _ASSERTE
#define _ASSERTE(expr) ((void)0)
#endif   // _DEBUG

#endif   // VERIFY_HEAP


#ifdef _DEBUG

//-------------------------------------------------------------
// Default constructor, for non-initializing declarations:
//
//      OBJECTREF or;
//-------------------------------------------------------------
OBJECTREF::OBJECTREF()
{
    m_asObj = (Object*)POISONC;
    Thread::ObjectRefNew(this);
}

//-------------------------------------------------------------
// Copy constructor, for passing OBJECTREF's as function arguments.
//-------------------------------------------------------------
OBJECTREF::OBJECTREF(const OBJECTREF & objref)
{
    VALIDATEOBJECTREF(objref.m_asObj);

    // !!! If this assert is fired, there are two possibilities:
    // !!! 1.  You are doing a type cast, e.g.  *(OBJECTREF*)pObj
    // !!!     Instead, you should use ObjectToOBJECTREF(*(Object**)pObj),
    // !!!                          or ObjectToSTRINGREF(*(StringObject**)pObj)
    // !!! 2.  There is a real GC hole here.
    // !!! Either way you need to fix the code.
    _ASSERTE(Thread::IsObjRefValid(&objref));
    if ((objref.m_asObj != 0) &&
        ((GCHeap*)g_pGCHeap)->IsHeapPointer( (BYTE*)this ))
    {
        _ASSERTE(!"Write Barrier violation. Must use SetObjectReference() to assign OBJECTREF's into the GC heap!");
    }
    m_asObj = objref.m_asObj;
    
    if (m_asObj != 0) {
        ENABLESTRESSHEAP();
    }

    Thread::ObjectRefNew(this);
}


//-------------------------------------------------------------
// To allow NULL to be used as an OBJECTREF.
//-------------------------------------------------------------
OBJECTREF::OBJECTREF(size_t nul)
{
    //_ASSERTE(nul == 0);
    m_asObj = (Object*)nul; // @TODO WIN64 - conversion from int to baseobj* of greater size
    if( m_asObj != NULL)
    {
        VALIDATEOBJECTREF(m_asObj);
        ENABLESTRESSHEAP();
    }
    Thread::ObjectRefNew(this);
}

//-------------------------------------------------------------
// This is for the GC's use only. Non-GC code should never
// use the "Object" class directly. The unused "int" argument
// prevents C++ from using this to implicitly convert Object*'s
// to OBJECTREF.
//-------------------------------------------------------------
OBJECTREF::OBJECTREF(Object *pObject)
{
    if ((pObject != 0) &&
        ((GCHeap*)g_pGCHeap)->IsHeapPointer( (BYTE*)this ))
    {
        _ASSERTE(!"Write Barrier violation. Must use SetObjectReference() to assign OBJECTREF's into the GC heap!");
    }
    m_asObj = pObject;
    VALIDATEOBJECTREF(m_asObj);
    if (m_asObj != 0) {
        ENABLESTRESSHEAP();
    }
    Thread::ObjectRefNew(this);
}

//-------------------------------------------------------------
// Test against NULL.
//-------------------------------------------------------------
int OBJECTREF::operator!() const
{
    VALIDATEOBJECTREF(m_asObj);
    // If this assert fires, you probably did not protect
    // your OBJECTREF and a GC might have occured.  To
    // where the possible GC was, set a breakpoint in Thread::TriggersGC - vancem
    _ASSERTE(Thread::IsObjRefValid(this));
    if (m_asObj != 0) {
        ENABLESTRESSHEAP();
    }
    return !m_asObj;
}

//-------------------------------------------------------------
// Compare two OBJECTREF's.
//-------------------------------------------------------------
int OBJECTREF::operator==(const OBJECTREF &objref) const
{
    VALIDATEOBJECTREF(objref.m_asObj);

    // !!! If this assert is fired, there are two possibilities:
    // !!! 1.  You are doing a type cast, e.g.  *(OBJECTREF*)pObj
    // !!!     Instead, you should use ObjectToOBJECTREF(*(Object**)pObj),
    // !!!                          or ObjectToSTRINGREF(*(StringObject**)pObj)
    // !!! 2.  There is a real GC hole here.
    // !!! Either way you need to fix the code.
    _ASSERTE(Thread::IsObjRefValid(&objref));
    VALIDATEOBJECTREF(m_asObj);
        // If this assert fires, you probably did not protect
        // your OBJECTREF and a GC might have occured.  To
        // where the possible GC was, set a breakpoint in Thread::TriggersGC - vancem
    _ASSERTE(Thread::IsObjRefValid(this));

    if (m_asObj != 0 || objref.m_asObj != 0) {
        ENABLESTRESSHEAP();
    }
    return m_asObj == objref.m_asObj;
}

//-------------------------------------------------------------
// Compare two OBJECTREF's.
//-------------------------------------------------------------
int OBJECTREF::operator!=(const OBJECTREF &objref) const
{
    VALIDATEOBJECTREF(objref.m_asObj);

    // !!! If this assert is fired, there are two possibilities:
    // !!! 1.  You are doing a type cast, e.g.  *(OBJECTREF*)pObj
    // !!!     Instead, you should use ObjectToOBJECTREF(*(Object**)pObj),
    // !!!                          or ObjectToSTRINGREF(*(StringObject**)pObj)
    // !!! 2.  There is a real GC hole here.
    // !!! Either way you need to fix the code.
    _ASSERTE(Thread::IsObjRefValid(&objref));
    VALIDATEOBJECTREF(m_asObj);
        // If this assert fires, you probably did not protect
        // your OBJECTREF and a GC might have occured.  To
        // where the possible GC was, set a breakpoint in Thread::TriggersGC - vancem
    _ASSERTE(Thread::IsObjRefValid(this));

    if (m_asObj != 0 || objref.m_asObj != 0) {
        ENABLESTRESSHEAP();
    }
    return m_asObj != objref.m_asObj;
}


//-------------------------------------------------------------
// Forward method calls.
//-------------------------------------------------------------
Object* OBJECTREF::operator->()
{
    VALIDATEOBJECTREF(m_asObj);
        // If this assert fires, you probably did not protect
        // your OBJECTREF and a GC might have occured.  To
        // where the possible GC was, set a breakpoint in Thread::TriggersGC - vancem
    _ASSERTE(Thread::IsObjRefValid(this));

    if (m_asObj != 0) {
        ENABLESTRESSHEAP();
    }

    // if you are using OBJECTREF directly,
    // you probably want an Object *
    return (Object *)m_asObj;
}


//-------------------------------------------------------------
// Forward method calls.
//-------------------------------------------------------------
const Object* OBJECTREF::operator->() const
{
    VALIDATEOBJECTREF(m_asObj);
        // If this assert fires, you probably did not protect
        // your OBJECTREF and a GC might have occured.  To
        // where the possible GC was, set a breakpoint in Thread::TriggersGC - vancem
    _ASSERTE(Thread::IsObjRefValid(this));

    if (m_asObj != 0) {
        ENABLESTRESSHEAP();
    }

    // if you are using OBJECTREF directly,
    // you probably want an Object *
    return (Object *)m_asObj;
}


//-------------------------------------------------------------
// Assignment. We don't validate the destination so as not
// to break the sequence:
//
//      OBJECTREF or;
//      or = ...;
//-------------------------------------------------------------
OBJECTREF& OBJECTREF::operator=(const OBJECTREF &objref)
{
    VALIDATEOBJECTREF(objref.m_asObj);

    // !!! If this assert is fired, there are two possibilities:
    // !!! 1.  You are doing a type cast, e.g.  *(OBJECTREF*)pObj
    // !!!     Instead, you should use ObjectToOBJECTREF(*(Object**)pObj),
    // !!!                          or ObjectToSTRINGREF(*(StringObject**)pObj)
    // !!! 2.  There is a real GC hole here.
    // !!! Either way you need to fix the code.
    _ASSERTE(Thread::IsObjRefValid(&objref));

    if ((objref.m_asObj != 0) &&
        ((GCHeap*)g_pGCHeap)->IsHeapPointer( (BYTE*)this ))
    {
        _ASSERTE(!"Write Barrier violation. Must use SetObjectReference() to assign OBJECTREF's into the GC heap!");
    }
    Thread::ObjectRefAssign(this);

    m_asObj = objref.m_asObj;
    if (m_asObj != 0) {
        ENABLESTRESSHEAP();
    }
    return *this;
}

//-------------------------------------------------------------
// Allows for the assignment of NULL to a OBJECTREF 
//-------------------------------------------------------------

OBJECTREF& OBJECTREF::operator=(int nul)
{
    _ASSERTE(nul == 0);
    Thread::ObjectRefAssign(this);
    m_asObj = (Object*)(size_t) nul; // @TODO WIN64 - conversion from int to baseobj* of greater size
    if (m_asObj != 0) {
        ENABLESTRESSHEAP();
    }
    return *this;
}


void* __cdecl GCSafeMemCpy(void * dest, const void * src, size_t len)
{

    if (!(((*(BYTE**)&dest) < g_lowest_address) || ((*(BYTE**)&dest) >= g_highest_address)))
    {
        // Note there is memcpyNoGCRefs which will allow you to do a memcpy into the GC
        // heap if you really know you don't need to call the write barrier

        _ASSERTE(!g_pGCHeap->IsHeapPointer((BYTE *) dest) ||
                 !"using memcpy to copy into the GC heap, use CopyValueClass");
    }
    return memcpyNoGCRefs(dest, src, len);
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\object.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// OBJECT.H
//
// Definitions of a Com+ Object
//

#ifndef _OBJECT_H_
#define _OBJECT_H_

#include "util.hpp"
#include "class.h"
#include "syncblk.h"
#include "oledb.h"
#include "gcdesc.h"
#include "specialstatics.h"
#include "gc.h"

// Copied from threads.h, since we can't include it here.
extern class AppDomain* (*GetAppDomain)();

BOOL CanBoxToObject(MethodTable *pMT);
TypeHandle ElementTypeToTypeHandle(const CorElementType type);
TypeHandle GetTypedByrefHandle();

// checks for both __ComObject and any COM Imported/extended class
BOOL CheckComWrapperClass(void* src);
// checks for the special class __ComObject
BOOL CheckComObjectClass(void* src);

/*
 * COM+ Internal Object Model
 *
 *
 * Object              - This is the common base part to all COM+ objects
 *  |                        it contains the MethodTable pointer and the
 *  |                        sync block index, which is at a negative offset
 *  |
 *  +-- StringObject       - String objects are specialized objects for string
 *  |                        storage/retrieval for higher performance
 *  |
 *  +-- StringBufferObject - StringBuffer instance layout.  
 *  |
 *  +-- BaseObjectWithCachedData - Object Plus one object field for caching.
 *  |       |
 *  |       +-- ReflectBaseObject  - This is the base object for reflection it represents
 *  |            |                FieldInfo, MethodInfo and ConstructorInfo
 *  |            |
 *  |            +-  ReflectClassBaseObject    - The base object for the class Class
 *  |            |
 *  |            +-  ReflectTokenBaseObject    - The base object for the class Event
 *  |
 *  +-- ArrayBase          - Base portion of all arrays
 *  |       |
 *  |       +-  I1Array    - Base type arrays
 *  |       |   I2Array
 *  |       |   ...
 *  |       |
 *  |       +-  PtrArray   - Array of OBJECTREFs, different than base arrays because of pObjectClass
 *  |              
 *  +-- AppDomainBaseObject - The base object for the class AppDomain
 *  |              
 *  +-- AssemblyBaseObject - The base object for the class Assembly
 *  |
 *  +-- ContextBaseObject   - base object for class Context
 *
 *
 * PLEASE NOTE THE FOLLOWING WHEN ADDING A NEW OBJECT TYPE:
 *
 *    The size of the object in the heap must be able to be computed
 *    very, very quickly for GC purposes.   Restrictions on the layout
 *    of the object guarantee this is possible.
 *
 *    Any object that inherits from Object must be able to
 *    compute its complete size by using the first 4 bytes of
 *    the object following the Object part and constants
 *    reachable from the MethodTable...
 *
 *    The formula used for this calculation is:
 *        MT->GetBaseSize() + ((OBJECTTYPEREF->GetSizeField() * MT->GetComponentSize())
 *
 *    So for Object, since this is of fixed size, the ComponentSize is 0, which makes the right side
 *    of the equation above equal to 0 no matter what the value of GetSizeField(), so the size is just the base size.
 *
 * NB: Arrays larger than 2G are not possible under this size computation system
 * @FUTURE: Revisit the 2G limit
 */


// @TODO:  #define COW         0x04     
// @TODO: MOO, MOO - no, not bovine, really Copy On Write bit for StringBuffer, requires 8 byte align MT
// @TODL: which we don't have yet

class MethodTable;
class Thread;
class LocalDataStore;
class BaseDomain;
class Assembly;
class Context;
class CtxStaticData;
class AssemblyNative;
class AssemblyName;
class WaitHandleNative;
//
// The generational GC requires that every object be at least 12 bytes
// in size.   
//@FUTURE: This costs for objects with no fields, investigate

#define MIN_OBJECT_SIZE     (2*sizeof(BYTE*) + sizeof(ObjHeader))

/*
 * Object
 *
 * This is the underlying base on which objects are built.   The MethodTable
 * pointer and the sync block index live here.  The sync block index is actually
 * at a negative offset to the instance.  See syncblk.h for details.
 *
 */
 
class Object
{
    friend BOOL InitJITHelpers1();

  protected:
    MethodTable    *m_pMethTab;

  protected:
    Object() { };
   ~Object() { };
   
  public:
    VOID SetMethodTable(MethodTable *pMT)               
    { 
        m_pMethTab = pMT; 
    }

    // An object might be a proxy of some sort, with a thunking VTable.  If so, we can
    // advance to the true method table or class.
    BOOL            IsThunking()                        
    { 
        return( GetMethodTable()->IsThunking() ); 
    }
    MethodTable    *GetMethodTable() const              
    { 
        return m_pMethTab ; 
    }
    MethodTable    *GetTrueMethodTable();
    EEClass        *GetClass()                          
    { 
        return( GetMethodTable()->GetClass() ); 
    }
    EEClass        *GetTrueClass();
    TypeHandle      GetTypeHandle();

    inline DWORD    GetNumComponents();
    inline DWORD    GetSize();

    CGCDesc*        GetSlotMap()                        
    { 
        return( CGCDesc::GetCGCDescFromMT(m_pMethTab)); 
    }

    // Sync Block & Synchronization services

    // Access the ObjHeader which is at a negative offset on the object (because of
    // cache lines)
    ObjHeader   *GetHeader()
    {
        return ((ObjHeader *) this) - 1;
    }

    // Get the current address of the object (works for debug refs, too.)
    BYTE        *GetAddress()
    {
        return (BYTE*) this;
    }

    // TRUE if the header has a real SyncBlockIndex (i.e. it has an entry in the
    // SyncTable, though it doesn't necessarily have an entry in the SyncBlockCache)
    BOOL HasSyncBlockIndex()
    {
        return GetHeader()->HasSyncBlockIndex();
    }

    // retrieve or allocate a sync block for this object
    SyncBlock *GetSyncBlock()
    {
        return GetHeader()->GetSyncBlock();
    }

    // retrieve a sync block for this object
    SyncBlock *GetRawSyncBlock()
    {
        return GetHeader()->GetRawSyncBlock();
    }

    DWORD GetSyncBlockIndex()
    {
        return GetHeader()->GetSyncBlockIndex();
    }

    DWORD GetAppDomainIndex();

    // Get app domain of object, or NULL if it is agile
    AppDomain *GetAppDomain();

    // Set app domain of object to current domain.
    void SetAppDomain() { SetAppDomain(::GetAppDomain()); }
    
    // Set app domain of object to given domain - it can only be set once
    void SetAppDomain(AppDomain *pDomain);

#if CHECK_APP_DOMAIN_LEAKS

    // Mark object as app domain agile
    BOOL SetAppDomainAgile(BOOL raiseAssert=TRUE);

    // Mark sync block as app domain agile
    void SetSyncBlockAppDomainAgile();

    // Check if object is app domain agile
    BOOL IsAppDomainAgile();

    // Check if object is app domain agile
    BOOL IsAppDomainAgileRaw()
    {
        SyncBlock *psb = GetRawSyncBlock();

        return (psb && psb->IsAppDomainAgile());
    }

    BOOL Object::IsCheckedForAppDomainAgile()
    {
        SyncBlock *psb = GetRawSyncBlock();
        return (psb && psb->IsCheckedForAppDomainAgile());
    }

    void Object::SetIsCheckedForAppDomainAgile()
    {
        SyncBlock *psb = GetRawSyncBlock();
        if (psb)
            psb->SetIsCheckedForAppDomainAgile();
    }

    // Check object to see if it is usable in the current domain 
    BOOL CheckAppDomain() { return CheckAppDomain(::GetAppDomain()); }

    //Check object to see if it is usable in the given domain 
    BOOL CheckAppDomain(AppDomain *pDomain);

    // Check if the object's type is app domain agile
    BOOL IsTypeAppDomainAgile();

    // Check if the object's type is conditionally app domain agile
    BOOL IsTypeCheckAppDomainAgile();

    // Check if the object's type is naturally app domain agile
    BOOL IsTypeTypesafeAppDomainAgile();

    // Check if the object's type is possibly app domain agile
    BOOL IsTypeNeverAppDomainAgile();

    // Validate object & fields to see that it's usable from the current app domain
    BOOL ValidateAppDomain() { return ValidateAppDomain(::GetAppDomain()); }

    // Validate object & fields to see that it's usable from any app domain
    BOOL ValidateAppDomainAgile() { return ValidateAppDomain(NULL); }

    // Validate object & fields to see that it's usable from the given app domain (or null for agile)
    BOOL ValidateAppDomain(AppDomain *pAppDomain);

    // Validate fields to see that they are usable from the object's app domain 
    // (or from any domain if the object is agile)
    BOOL ValidateAppDomainFields() { return ValidateAppDomainFields(GetAppDomain()); }

    // Validate fields to see that they are usable from the given app domain (or null for agile)
    BOOL ValidateAppDomainFields(AppDomain *pAppDomain);

    // Validate a value type's fields to see that it's usable from the current app domain
    static BOOL ValidateValueTypeAppDomain(EEClass *pClass, void *base, BOOL raiseAssert = TRUE) 
      { return ValidateValueTypeAppDomain(pClass, base, ::GetAppDomain(), raiseAssert); }

    // Validate a value type's fields to see that it's usable from any app domain
    static BOOL ValidateValueTypeAppDomainAgile(EEClass *pClass, void *base, BOOL raiseAssert = TRUE) 
      { return ValidateValueTypeAppDomain(pClass, base, NULL, raiseAssert); }

    // Validate a value type's fields to see that it's usable from the given app domain (or null for agile)
    static BOOL ValidateValueTypeAppDomain(EEClass *pClass, void *base, AppDomain *pAppDomain, BOOL raiseAssert = TRUE);

    // Call when we are assigning this object to a dangerous field 
    // in an object in a given app domain (or agile if null)
    BOOL AssignAppDomain(AppDomain *pAppDomain, BOOL raiseAssert = TRUE);

    // Call when we are assigning to a dangerous value type field 
    // in an object in a given app domain (or agile if null)
    static BOOL AssignValueTypeAppDomain(EEClass *pClass, void *base, AppDomain *pAppDomain, BOOL raiseAssert = TRUE);

#endif // CHECK_APP_DOMAIN_LEAKS

    // Validate an object ref out of the Promote routine in the GC
    void ValidatePromote(ScanContext *sc, DWORD flags);

    // Validate an object ref out of the VerifyHeap routine in the GC
    void ValidateHeap(Object *from);

    // should be called only from unwind code; used in the
    // case where EnterObjMonitor failed to allocate the
    // sync-object.
    void LeaveObjMonitorAtException()
    {
        GetHeader()->LeaveObjMonitorAtException();
    }

    SyncBlock *PassiveGetSyncBlock()
    {
        return GetHeader()->PassiveGetSyncBlock();
    }

        // COM Interop has special access to sync blocks
    // check .cpp file for more info
    SyncBlock* GetSyncBlockSpecial()
    {
        return GetHeader()->GetSyncBlockSpecial();
    }

    // Synchronization

    void EnterObjMonitor()
    {
        // There's no reason why you can't synchronize on a proxy.  But currently we
        // synchronize on the underlying server.  So don't relax this assertion until
        // we intentionally synchronize on proxies.
        _ASSERTE(!m_pMethTab->IsCtxProxyType());
        GetHeader()->EnterObjMonitor();
    }

    BOOL TryEnterObjMonitor(INT32 timeOut = 0)
    {
        _ASSERTE(!m_pMethTab->IsCtxProxyType());
        return GetHeader()->TryEnterObjMonitor(timeOut);
    }

    void LeaveObjMonitor()
    {
        GetHeader()->LeaveObjMonitor();
    }

    LONG LeaveObjMonitorCompletely()
    {
        return GetHeader()->LeaveObjMonitorCompletely();
    }

    BOOL DoesCurrentThreadOwnMonitor()
    {
        return GetHeader()->DoesCurrentThreadOwnMonitor();
    }

    BOOL Wait(INT32 timeOut, BOOL exitContext)
    {
        return GetHeader()->Wait(timeOut, exitContext);
    }

    void Pulse()
    {
        GetHeader()->Pulse();
    }

    void PulseAll()
    {
        GetHeader()->PulseAll();
    }

    void* UnBox()       // if it is a value class, get the pointer to the first field
    {
        _ASSERTE(GetClass()->IsValueClass());
        return(this + 1);
    }

    BYTE*   GetData(void)
    {
        return ((BYTE*) this) + sizeof(Object);
    }

    static UINT GetOffsetOfFirstField()
    {
        return sizeof(Object);
    }
    
    DWORD   GetOffset32(DWORD dwOffset)
    { 
        return *(DWORD *) &GetData()[dwOffset];
    }

    USHORT  GetOffset16(DWORD dwOffset)
    { 
        return *(USHORT *) &GetData()[dwOffset];
    }

    BYTE    GetOffset8(DWORD dwOffset)
    { 
        return *(BYTE *) &GetData()[dwOffset];
    }

    __int64 GetOffset64(DWORD dwOffset)
    { 
        return *(__int64 *) &GetData()[dwOffset];
    }

    void *GetPtrOffset(size_t pOffset)
    {
        return *(void**) &GetData()[pOffset];
    }

    void SetOffsetObjectRef(DWORD dwOffset, size_t dwValue);

    void SetOffsetPtr(DWORD dwOffset, LPVOID value)
    {
        *(LPVOID *) &GetData()[dwOffset] = value;
    }
        
    void SetOffset32(DWORD dwOffset, DWORD dwValue)
    { 
        *(DWORD *) &GetData()[dwOffset] = dwValue;
    }

    void SetOffset16(DWORD dwOffset, DWORD dwValue)
    { 
        *(USHORT *) &GetData()[dwOffset] = (USHORT) dwValue;
    }

    void SetOffset8(DWORD dwOffset, DWORD dwValue)
    { 
        *(BYTE *) &GetData()[dwOffset] = (BYTE) dwValue;
    }

    void SetOffset64(DWORD dwOffset, __int64 qwValue)
    { 
        *(__int64 *) &GetData()[dwOffset] = qwValue;
    }

    #ifndef GOLDEN
    VOID            Validate(BOOL bDeep=TRUE);
    #endif

 private:

    MethodTable *GetGCSafeMethodTable()
    {
        // lose GC marking bit
        return (MethodTable *) (((size_t) m_pMethTab) & ~3);
    }

    EEClass *GetGCSafeClass()
    {
        return GetGCSafeMethodTable()->GetClass();
    }

    BOOL SetFieldsAgile(BOOL raiseAssert = TRUE);
    static BOOL SetClassFieldsAgile(EEClass *pClass, void *base, BOOL baseIsVT, BOOL raiseAssert = TRUE); 
    static BOOL ValidateClassFields(EEClass *pClass, void *base, BOOL baseIsVT, AppDomain *pAppDomain, BOOL raiseAssert = TRUE);
};

/*
 * Object ref setting routines.  You must use these to do 
 * proper write barrier support, as well as app domain 
 * leak checking.
 *
 * Note that the AppDomain parameter is the app domain affinity
 * of the object containing the field or value class.  It should
 * be NULL if the containing object is app domain agile. Note that
 * you typically get this value by calling obj->GetAppDomain() on 
 * the containing object.
 */

// SetObjectReference sets an OBJECTREF field

void SetObjectReferenceUnchecked(OBJECTREF *dst,OBJECTREF ref);
BOOL SetObjectReferenceSafeUnchecked(OBJECTREF *dst,OBJECTREF ref);
void ErectWriteBarrier(OBJECTREF *dst,OBJECTREF ref);

#ifdef _DEBUG
void EnableStressHeapHelper();
#endif

//Used to clear the object reference
inline void ClearObjectReference(OBJECTREF* dst) 
{ 
    *(void**)(dst) = NULL; 
}

// CopyValueClass sets a value class field

void CopyValueClassUnchecked(void* dest, void* src, MethodTable *pMT);

inline void InitValueClass(void *dest, MethodTable *pMT)
{ 
    ZeroMemory(dest, pMT->GetClass()->GetNumInstanceFieldBytes()); 
}

#if CHECK_APP_DOMAIN_LEAKS

void SetObjectReferenceChecked(OBJECTREF *dst,OBJECTREF ref, AppDomain *pAppDomain);
BOOL SetObjectReferenceSafeChecked(OBJECTREF *dst,OBJECTREF ref, AppDomain *pAppDomain);
void CopyValueClassChecked(void* dest, void* src, MethodTable *pMT, AppDomain *pAppDomain);

#define SetObjectReference(_d,_r,_a)        SetObjectReferenceChecked(_d, _r, _a)
#define SetObjectReferenceSafe(_d,_r,_a)    SetObjectReferenceSafeChecked(_d, _r, _a)
#define CopyValueClass(_d,_s,_m,_a)         CopyValueClassChecked(_d,_s,_m,_a)      

#else

#define SetObjectReference(_d,_r,_a)        SetObjectReferenceUnchecked(_d, _r)
#define SetObjectReferenceSafe(_d,_r,_a)    SetObjectReferenceSafeUnchecked(_d, _r)
#define CopyValueClass(_d,_s,_m,_a)         CopyValueClassUnchecked(_d,_s,_m)       

#endif

#pragma pack(push,4)


// N/Direct marshaling will pin scalar arrays with more than this many
// components (limit is in terms of components rather than byte size to
// speed up the check.)
#define ARRAYPINLIMIT 10


// There are two basic kinds of array layouts in COM+
//      ELEMENT_TYPE_ARRAY  - a multidimensional array with lower bounds on the dims
//      ELMENNT_TYPE_SZARRAY - A zero based single dimensional array
//
// In addition the layout of an array in memory is also affected by
// whether the method table is shared (eg in the case of arrays of object refs)
// or not.  In the shared case, the array has to hold the type handle of
// the element type.  
//
// ArrayBase encapuslates all of these details.  In theory you should never
// have to peek inside this abstraction
//
class ArrayBase : public Object
{
    friend class GCHeap;
    friend class CObjectHeader;
    friend class Object;
    friend OBJECTREF AllocateArrayEx(TypeHandle arrayClass, DWORD *pArgs, DWORD dwNumArgs, BOOL bAllocateInLargeHeap); 
    friend OBJECTREF FastAllocatePrimitiveArray(MethodTable* arrayType, DWORD cElements, BOOL bAllocateInLargeHeap);
    friend class JIT_TrialAlloc;

private:
    // This MUST be the first field, so that it directly follows Object.  This is because
    // Object::GetSize() looks at m_NumComponents even though it may not be an array (the
    // values is shifted out if not an array, so it's ok). 
    DWORD       m_NumComponents;

        // What comes after this conceputally is 
    // TypeHandle elementType;      Only present if the method table is shared among many types (arrays of pointers)

            // The bounds are only present for Multidimensional arrays
    // DWORD bounds[rank];          
    // DWORD lowerBounds[rank]      valid indexes are lowerBounds[i] <= index[i] < lowerBounds[i] + bounds[i]

    void SetElementTypeHandle(TypeHandle value) {
        _ASSERTE(value.Verify());
        _ASSERTE(GetMethodTable()->HasSharedMethodTable());
        *((TypeHandle*) (this+1)) = value;
    }

public:
        // Gets the unique type handle for this array object.
    TypeHandle GetTypeHandle() const;

        // Get the element type for the array, this works whether the the element
        // type is stored in the array or not
    TypeHandle GetElementTypeHandle() const {
        if (GetMethodTable()->HasSharedMethodTable()) {
            TypeHandle ret = *((TypeHandle*) (this+1)); // Then it is in the array instance. 
            _ASSERTE(!ret.IsNull());
            _ASSERTE(ret.IsArray() || !ret.GetClass()->IsArrayClass());
            return ret;
        }
        else 
            return GetArrayClass()->GetElementTypeHandle(); 
    }

        // Get the CorElementType for the elements in the array.  Avoids creating a TypeHandle
    CorElementType GetElementType() const {
        return GetArrayClass()->GetElementType();
    }

    unsigned GetRank() const {
        return GetArrayClass()->GetRank();
    }

        // Total element count for the array
    unsigned GetNumComponents() const { 
        return m_NumComponents; 
    }

        // Get pointer to elements, handles any number of dimensions
    BYTE* GetDataPtr() const {
#ifdef _DEBUG
        EnableStressHeapHelper();
#endif
        return ((BYTE *) this) + GetDataPtrOffset(GetMethodTable());
    }

        // &Array[i]  == GetDataPtr() + GetComponentSize() * i
    unsigned GetComponentSize() const {
        return(GetMethodTable()->GetComponentSize());
    }

    // Can I cast this to a RefArray class given below?
    BOOL IsSZRefArray() const;

        // Note that this can be a multidimensional array of rank 1 
        // (for example if we had a 1-D array with lower bounds
    BOOL IsMultiDimArray() const {
        return(GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_ARRAY);
    }

        // Get pointer to the begining of the bounds (counts for each dim)
        // Works for any array type 
    const DWORD *GetBoundsPtr() const {
        if (IsMultiDimArray()) {
            const DWORD * ret = (const DWORD *) (this + 1);
            if (GetMethodTable()->HasSharedMethodTable())
                ret++;
            return(ret);
        }
        else
            return &m_NumComponents;
    }

        // Works for any array type 
    const DWORD *GetLowerBoundsPtr() const {
        static DWORD zero = 0;
        if (IsMultiDimArray())
            return GetBoundsPtr() + GetRank(); // Lower bounds info is after upper bounds info
        else
            return &zero;
    }

    ArrayClass *GetArrayClass() const {
        return  (ArrayClass *) m_pMethTab->GetClass();
    }

    static unsigned GetOffsetOfNumComponents() {
        return (UINT)offsetof(ArrayBase, m_NumComponents);
    }

    static unsigned GetDataPtrOffset(MethodTable* pMT) {
            // The -sizeof(ObjHeader) is because of the sync block, which is before "this"
        _ASSERTE(pMT->IsArray());
        return pMT->m_BaseSize - sizeof(ObjHeader);
    }

    static unsigned GetBoundsOffset(MethodTable* pMT) {
        if (pMT->GetNormCorElementType() == ELEMENT_TYPE_SZARRAY) 
            return(offsetof(ArrayBase, m_NumComponents));
        _ASSERTE(pMT->GetNormCorElementType() == ELEMENT_TYPE_ARRAY);
        return GetDataPtrOffset(pMT) - ((ArrayClass*) pMT->GetClass())->GetRank() * sizeof(DWORD) * 2;
    }

    static unsigned GetLowerBoundsOffset(MethodTable* pMT) {
        // There is no good offset for this for a SZARRAY.  
        _ASSERTE(pMT->GetNormCorElementType() == ELEMENT_TYPE_ARRAY);
        return GetDataPtrOffset(pMT) - ((ArrayClass*) pMT->GetClass())->GetRank() * sizeof(DWORD);
    }

};

//
// Template used to build all the non-object
// arrays of a single dimension
//

template < class KIND >
class Array : public ArrayBase
{
  public:
    KIND          m_Array[1];

    KIND *        GetDirectPointerToNonObjectElements() 
    { 
        // return m_Array; 
        return (KIND *) GetDataPtr(); // This also handles arrays of dim 1 with lower bounds present

    }

    const KIND *  GetDirectConstPointerToNonObjectElements() const
    { 
        // return m_Array; 
        return (const KIND *) GetDataPtr(); // This also handles arrays of dim 1 with lower bounds present
    }
};


// Warning: Use PtrArray only for single dimensional arrays, not multidim arrays.
class PtrArray : public ArrayBase
{
    friend class GCHeap;
    friend OBJECTREF AllocateArrayEx(TypeHandle arrayClass, DWORD *pArgs, DWORD dwNumArgs, BOOL bAllocateInLargeHeap); 
    friend class JIT_TrialAlloc;
public:

    TypeHandle GetElementTypeHandle()
    {
        return m_ElementType;
    }

    static unsigned GetDataOffset()
    {
        return offsetof(PtrArray, m_Array);
    }

    void SetAt(SIZE_T i, OBJECTREF ref)
    {
        SetObjectReference(m_Array + i, ref, GetAppDomain());
    }

    void ClearAt(DWORD i)
    {
        ClearObjectReference(m_Array + i);
    }

    OBJECTREF GetAt(DWORD i)
    {
        return m_Array[i];
    }

    friend class StubLinkerCPU;
private:
    TypeHandle  m_ElementType;
public:
    OBJECTREF    m_Array[1];
};

/* a TypedByRef is a structure that is used to implement VB's BYREF variants.  
   it is basically a tuple of an address of some data along with a EEClass
   that indicates the type of the address */
class TypedByRef 
{
public:

    void* data;
    TypeHandle type;  
};



typedef Array<I1>   I1Array;
typedef Array<I2>   I2Array;
typedef Array<I4>   I4Array;
typedef Array<I8>   I8Array;
typedef Array<R4>   R4Array;
typedef Array<R8>   R8Array;
typedef Array<U1>   U1Array;
typedef Array<U1>   BOOLArray;
typedef Array<U2>   U2Array;
typedef Array<U2>   CHARArray;
typedef Array<U4>   U4Array;
typedef Array<U8>   U8Array;
typedef PtrArray    PTRArray;  


#ifdef _DEBUG
typedef REF<ArrayBase>  BASEARRAYREF;
typedef REF<I1Array>    I1ARRAYREF;
typedef REF<I2Array>    I2ARRAYREF;
typedef REF<I4Array>    I4ARRAYREF;
typedef REF<I8Array>    I8ARRAYREF;
typedef REF<R4Array>    R4ARRAYREF;
typedef REF<R8Array>    R8ARRAYREF;
typedef REF<U1Array>    U1ARRAYREF;
typedef REF<BOOLArray>    BOOLARRAYREF;
typedef REF<U2Array>    U2ARRAYREF;
typedef REF<U4Array>    U4ARRAYREF;
typedef REF<U8Array>    U8ARRAYREF;
typedef REF<CHARArray>  CHARARRAYREF;
typedef REF<PTRArray>   PTRARRAYREF;  // Warning: Use PtrArray only for single dimensional arrays, not multidim arrays.

#else  _DEBUG

typedef ArrayBase*      BASEARRAYREF;
typedef I1Array*        I1ARRAYREF;
typedef I2Array*        I2ARRAYREF;
typedef I4Array*        I4ARRAYREF;
typedef I8Array*        I8ARRAYREF;
typedef R4Array*        R4ARRAYREF;
typedef R8Array*        R8ARRAYREF;
typedef U1Array*        U1ARRAYREF;
typedef BOOLArray*        BOOLARRAYREF;
typedef U2Array*        U2ARRAYREF;
typedef U4Array*        U4ARRAYREF;
typedef U8Array*        U8ARRAYREF;
typedef CHARArray*      CHARARRAYREF;
typedef PTRArray*       PTRARRAYREF;  // Warning: Use PtrArray only for single dimensional arrays, not multidim arrays.

#endif _DEBUG

inline DWORD Object::GetNumComponents()
{
    // Yes, we may not even be an array, which means we are reading some of the object's memory - however,
    // ComponentSize will multiply out this value.  Therefore, m_NumComponents must be the first field in
    // ArrayBase.
    return ((ArrayBase *) this)->m_NumComponents;
}

inline DWORD Object::GetSize()                          
{ 
    // mask the alignment bits because this methos is called during GC
    MethodTable* mT = (MethodTable*)((size_t)GetMethodTable()&~3);
    return mT->GetBaseSize() + (GetNumComponents() * mT->GetComponentSize());
}

#pragma pack(pop)


/*
 * StringObject
 *
 * Special String implementation for performance.   
 *
 *   m_ArrayLength  - Length of buffer (m_Characters) in number of WCHARs
 *   m_StringLength - Length of string in number of WCHARs, may be smaller
 *                    than the m_ArrayLength implying that there is extra
 *                    space at the end. The high two bits of this field are used
 *                    to indicate if the String has characters higher than 0x7F
 *   m_Characters   - The string buffer
 *
 */


/**
 *  The high bit state can be one of three value: 
 * STRING_STATE_HIGH_CHARS: We've examined the string and determined that it definitely has values greater than 0x80
 * STRING_STATE_FAST_OPS: We've examined the string and determined that it definitely has no chars greater than 0x80
 * STRING_STATE_UNDETERMINED: We've never examined this string.
 * We've also reserved another bit for future use.
 */

#define STRING_STATE_UNDETERMINED     0x00000000
#define STRING_STATE_HIGH_CHARS       0x40000000
#define STRING_STATE_FAST_OPS         0x80000000
#define STRING_STATE_SPECIAL_SORT     0xC0000000

#pragma warning(disable : 4200)     // disable zero-sized array warning
class StringObject : public Object
{
    friend class GCHeap;
    friend class JIT_TrialAlloc;

  private:
    DWORD   m_ArrayLength;
    DWORD   m_StringLength;
    WCHAR   m_Characters[0];

  public:
    //@TODO prevent access to this....
    VOID    SetArrayLength(DWORD len)                   { m_ArrayLength = len;     }

  protected:
    StringObject() {}
   ~StringObject() {}
   
  public:
    DWORD   GetArrayLength()                            { return( m_ArrayLength ); }
    DWORD   GetStringLength()                           { return( m_StringLength );}
    WCHAR*  GetBuffer()                                 { _ASSERTE(this); return( m_Characters );  }
    WCHAR*  GetBufferNullable()                         { return( (this == 0) ? 0 : m_Characters );  }

    VOID    SetStringLength(DWORD len) { 
                _ASSERTE( len <= m_ArrayLength );
                m_StringLength = len;
    }

    DWORD GetHighCharState() {
        DWORD ret = GetHeader()->GetBits() & (BIT_SBLK_STRING_HIGH_CHAR_MASK);
        return ret;
    }

    VOID ResetHighCharState() {
        if (GetHighCharState() != STRING_STATE_UNDETERMINED) {
            GetHeader()->ClrBit(BIT_SBLK_STRING_HIGH_CHAR_MASK);
        }
    }

    VOID SetHighCharState(DWORD value) {
        _ASSERTE(value==STRING_STATE_HIGH_CHARS || value==STRING_STATE_FAST_OPS 
                 || value==STRING_STATE_UNDETERMINED || value==STRING_STATE_SPECIAL_SORT);

        // you need to clear the present state before going to a new state, but we'll allow multiple threads to set it to the same thing.
        _ASSERTE((GetHighCharState() == STRING_STATE_UNDETERMINED) || (GetHighCharState()==value));    

        _ASSERTE(BIT_SBLK_STRING_HAS_NO_HIGH_CHARS == STRING_STATE_FAST_OPS && 
                 STRING_STATE_HIGH_CHARS == BIT_SBLK_STRING_HIGH_CHARS_KNOWN &&
                 STRING_STATE_SPECIAL_SORT == BIT_SBLK_STRING_HAS_SPECIAL_SORT);

        GetHeader()->SetBit(value);
    }

    static UINT GetBufferOffset()
    {
        return (UINT)(offsetof(StringObject, m_Characters));
    }

    static UINT GetStringLengthOffset_MaskOffHighBit()
    {
        return (UINT)(offsetof(StringObject, m_StringLength));
    }
    

};


// This is used to account for the CachedData member on
//   MemberInfo.
class BaseObjectWithCachedData : public Object
{
    protected:
        OBJECTREF  m_CachedData;   // cached data object (on MemberInfo in managed code, see MemberInfo.cool)
};

// ReflectBaseObject (FieldInfo, MethodInfo, ConstructorInfo, Parameter Module
// This class is the base class for all of the reflection method and field objects.
//  This class will connect the Object back to the underlying VM representation
//  m_vmReflectedClass -- This is the real Class that was used for reflection
//      This class was used to get at this object
//  m_pData -- this is a generic pointer which usually points either to a FieldDesc or a
//      MethodDesc
//  
class ReflectBaseObject : public BaseObjectWithCachedData
{
    friend class Binder;

  protected:
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class definition of this object.
    OBJECTREF          m_Param;         // The Param array....
    void*              m_ReflectClass;  // Pointer to the ReflectClass structure
    void*              m_pData;         // Pointer to the ReflectXXXX structure (method,Field, etc)

  protected:
    ReflectBaseObject() {}
   ~ReflectBaseObject() {}
   
  public:
    // check for classes that wrap Ole classes 

    void SetReflClass(void* classObj)  {
        m_ReflectClass = classObj;
    }
    void *GetReflClass() {
        return m_ReflectClass;
    }

    void SetData(void* p) {
        m_pData = p;
    }
    void* GetData() {
        return m_pData;
    }
};

// This is the Class version of the Reflection object.
//  A Class has adddition information.
//  For a ReflectClassBaseObject the m_pData is a pointer to a FieldDesc array that
//      contains all of the final static primitives if its defined.
//  m_cnt = the number of elements defined in the m_pData FieldDesc array.  -1 means
//      this hasn't yet been defined.
class ReflectClassBaseObject : public BaseObjectWithCachedData
{
    friend class Binder;

protected:
    void*              m_pData;         // Pointer to ReflectClass (See ReflectWrap.h)

public:
    void SetData(void* p) {
        m_pData = p;
    }
    void* GetData() {
        return m_pData;
    }

    // includes Types which hold a "ComObject" class
    // and types which are imported through typelib
    BOOL IsComWrapperClass() {
        return CheckComWrapperClass(m_pData);
    }

    // includes Type which hold a "__ComObject" class
    BOOL IsComObjectClass() {
        return CheckComObjectClass(m_pData);
    }
};

// This is the Token version of the Reflection object.
//  A Token has adddition information because the VM doesn't have an
//  object representing it.
//  m_token = The token of the event in the meta data.
class ReflectTokenBaseObject : public ReflectBaseObject
{
protected:
    mdToken     m_token;        // The event token

public:
    void inline SetToken(mdToken token) {
        m_token = token;
    }
    mdToken GetToken() {
        return m_token;
    }
};


// ReflectModuleBaseObject 
// This class is the base class for managed Module.
//  This class will connect the Object back to the underlying VM representation
//  m_ReflectClass -- This is the real Class that was used for reflection
//      This class was used to get at this object
//  m_pData -- this is a generic pointer which usually points CorModule
//  
class ReflectModuleBaseObject : public Object
{
    friend class Binder;

  protected:
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class definition of this object.
    OBJECTREF          m_TypeBuilderList;
    OBJECTREF          m_ISymWriter;
    OBJECTREF          m_moduleData;    // dynamic module data
    void*              m_ReflectClass;  // Pointer to the ReflectClass structure
    void*              m_pData;         // Pointer to the ReflectXXXX structure (method,Field, etc)
    void*              m_pInternalSymWriter; // Pointer to the ISymUnmanagedWriter.
    void*              m_pGlobals;      // Global values....
    void*              m_pGlobalsFlds;  // Global Fields....
    mdToken            m_EntryPoint;    // Value type MethodToken is embedded. It only contains one integer field.

  protected:
    ReflectModuleBaseObject() {}
   ~ReflectModuleBaseObject() {}
   
  public:
    // check for classes that wrap Ole classes 

    void SetReflClass(void* classObj)  {
        m_ReflectClass = classObj;
    }
    void *GetReflClass() {
        return m_ReflectClass;
    }

    void SetData(void* p) {
        m_pData = p;
    }
    void* GetData() {
        return m_pData;
    }

    void SetInternalSymWriter(void* p) {
        m_pInternalSymWriter = p;
    }
    void* GetInternalSymWriter() {
        return m_pInternalSymWriter;
    }

    void* GetGlobals() {
        return m_pGlobals;
    }
    void SetGlobals(void* p) {
        m_pGlobals = p;
    }
    void* GetGlobalFields() {
        return m_pGlobalsFlds;
    }
    void SetGlobalFields(void* p) {
        m_pGlobalsFlds = p;
    }
};

// CustomAttributeClass 
// This class is the mirror of System.Reflection.CustomAttribute
//  
class CustomAttributeClass : public Object
{
    friend class Binder;

private:
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    // classlib class definition of this object.
    OBJECTREF   m_next;
    OBJECTREF   m_caType;
    INT32       m_ctorToken;
    const void  *m_blob;
    ULONG       m_blobCount;
    ULONG       m_currPos;
    void*       m_module;
    INT32       m_inheritLevel;

protected:
    // the ctor and dtor can do no useful work.
    CustomAttributeClass() { }
   ~CustomAttributeClass() { }

public:
    void SetData(OBJECTREF next,
                 OBJECTREF caType,
                 INT32 ctorToken,
                 const void  *blob,
                 ULONG blobCount,
                 void* module,
                 INT32 inheritLevel)
    {
        AppDomain *pDomain = GetAppDomain();
        SetObjectReference((OBJECTREF*) &m_next, next, pDomain);
        SetObjectReference((OBJECTREF*) &m_caType, caType, pDomain);
        m_ctorToken = ctorToken;
        m_blob = blob;
        m_blobCount = blobCount;
        m_currPos = 0;
        m_module = module;
        m_inheritLevel = inheritLevel;
    }

    INT32 GetToken() {
        return m_ctorToken;
    }

    const void* GetBlob() {
        return m_blob;
    }
    
    ULONG GetBlobCount() {
        return m_blobCount;
    }

    Module* GetModule() {
        return (Module*)m_module;
    }

    OBJECTREF GetType() {
        return (OBJECTREF)m_caType;
    }

    void SetCurrPos(UINT32 currPos) {
        m_currPos = currPos;
    }

    UINT32 GetCurrPos() {
        return m_currPos;
    }

    INT32 GetInheritedLevel() {
        return m_inheritLevel;
    }

};



class ThreadBaseObject : public Object
{
    friend class ThreadNative;
    friend class Binder;

private:

    // These field are also defined in the managed representation.  If you
    // add or change these field you must also change the managed code so that
    // it matches these.  This is necessary so that the object is the proper
    // size. 
    
    OBJECTREF     m_ExposedContext;
    OBJECTREF     m_LogicalCallContext;
    OBJECTREF     m_IllogicalCallContext;
    OBJECTREF     m_Name;
    OBJECTREF     m_ExceptionStateInfo;
    OBJECTREF     m_Delegate;
    OBJECTREF     m_PrincipalSlot;
    PTRARRAYREF   m_ThreadStatics;
    I4ARRAYREF    m_ThreadStaticsBits;
    OBJECTREF     m_CurrentUserCulture;
    OBJECTREF     m_CurrentUICulture;
    INT32         m_Priority;

    // m_InternalThread is always valid -- unless the thread has finalized and been
    // resurrected.
    Thread       *m_InternalThread;

protected:
    // the ctor and dtor can do no useful work.
    ThreadBaseObject() { };
   ~ThreadBaseObject() { };

public:
    Thread   *GetInternal()
    {
        return m_InternalThread;
    }

    void      SetInternal(Thread *it)
    {
        // either you are transitioning from NULL to non-NULL or vice versa.  But
        // you aren't setting NULL to NULL or non-NULL to non-NULL.
        _ASSERTE((m_InternalThread == NULL) != (it == NULL));
        m_InternalThread = it;
    }

    HANDLE    GetHandle();
    OBJECTREF GetDelegate()                   { return m_Delegate; }
    void      SetDelegate(OBJECTREF delegate);

    // These expose the remoting context (System\Remoting\Context)
    OBJECTREF GetExposedContext() { return m_ExposedContext; }
    OBJECTREF SetExposedContext(OBJECTREF newContext) 
    {
        OBJECTREF oldContext = m_ExposedContext;

        // Note: this is a very dangerous unchecked assignment.  We are taking
        // responsibilty here for cleaning out the ExposedContext field when 
        // an app domain is unloaded.
        SetObjectReferenceUnchecked( (OBJECTREF *)&m_ExposedContext, newContext );

        return oldContext;
    }

    OBJECTREF GetCurrentUserCulture() { return m_CurrentUserCulture; }
    OBJECTREF GetCurrentUICulture() { return m_CurrentUICulture; }

    OBJECTREF GetLogicalCallContext() { return m_LogicalCallContext; }
    OBJECTREF GetIllogicalCallContext() { return m_IllogicalCallContext; }

    void SetLogicalCallContext(OBJECTREF ref) 
      { SetObjectReferenceUnchecked((OBJECTREF*)&m_LogicalCallContext, ref); }
    void SetIllogicalCallContext(OBJECTREF ref)
      { SetObjectReferenceUnchecked((OBJECTREF*)&m_IllogicalCallContext, ref); }
            
    // SetDelegate is our "constructor" for the pathway where the exposed object is
    // created first.  InitExisting is our "constructor" for the pathway where an
    // existing physical thread is later exposed.
    void      InitExisting();
    PTRARRAYREF GetThreadStaticsHolder() 
    { 
        // The code that needs this should have faulted it in by now!
        _ASSERTE(m_ThreadStatics != NULL); 

        return m_ThreadStatics; 
    }
    I4ARRAYREF GetThreadStaticsBits() 
    { 
        // The code that needs this should have faulted it in by now!
        _ASSERTE(m_ThreadStaticsBits != NULL); 

        return m_ThreadStaticsBits; 
    }
};


// ContextBaseObject 
// This class is the base class for Contexts
//  
class ContextBaseObject : public Object
{
    friend class Context;
    friend class Binder;

  private:
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class definition of this object.

    OBJECTREF m_ctxProps;   // array of name-value pairs of properties
    OBJECTREF m_dphCtx;     // dynamic property holder
    OBJECTREF m_localDataStore; // context local store
    OBJECTREF m_serverContextChain; // server context sink chain
    OBJECTREF m_clientContextChain; // client context sink chain
    OBJECTREF m_exposedAppDomain;       //appDomain ??
    PTRARRAYREF m_ctxStatics; // holder for context relative statics
    
    Context*  m_internalContext;            // Pointer to the VM context

  protected:
    ContextBaseObject() {}
   ~ContextBaseObject() {}
   
  public:

    void SetInternalContext(Context* pCtx) 
    {
        // either transitioning from NULL to non-NULL or vice versa.  
        // But not setting NULL to NULL or non-NULL to non-NULL.
        _ASSERTE((m_internalContext == NULL) != (pCtx == NULL));
        m_internalContext = pCtx;
    }
    
    Context* GetInternalContext() 
    {
        return m_internalContext;
    }

    OBJECTREF GetExposedDomain() { return m_exposedAppDomain; }
    OBJECTREF SetExposedDomain(OBJECTREF newDomain) 
    {
        OBJECTREF oldDomain = m_exposedAppDomain;
        SetObjectReference( (OBJECTREF *)&m_exposedAppDomain, newDomain, GetAppDomain() );
        return oldDomain;
    }

    PTRARRAYREF GetContextStaticsHolder() 
    { 
        // The code that needs this should have faulted it in by now!
        _ASSERTE(m_ctxStatics != NULL); 

        return m_ctxStatics; 
    }
};

// LocalDataStoreBaseObject 
// This class is the base class for local data stores
//  
class LocalDataStoreBaseObject : public Object
{
    friend class LocalDataStore;
    friend class Binder;
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class definition of this object.
  protected:
    OBJECTREF m_DataTable;
    OBJECTREF m_Manager;
    LocalDataStore* m_pLDS;  // Pointer to the LocalDataStore Structure    

    LocalDataStoreBaseObject() {}
   ~LocalDataStoreBaseObject() {}

  public:

    void SetLocalDataStore(LocalDataStore* p) 
    {
        m_pLDS = p;
    }

    LocalDataStore* GetLocalDataStore() 
    {
        return m_pLDS;
    }
};


// AppDomainBaseObject 
// This class is the base class for application domains
//  
class AppDomainBaseObject : public Object
{
    friend AppDomain;
    friend class Binder;

  protected:
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class definition of this object.
    OBJECTREF    m___Identity;         // Identity object contributed by the MarshalByRef base class
    OBJECTREF    m_LocalStore;
    OBJECTREF    m_FusionTable;
    OBJECTREF    m_pSecurityIdentity;  // Evidence associated with this domain
    OBJECTREF    m_pPolicies;          // Array of context policies associated with this domain
    OBJECTREF    m_pDomainUnloadEventHandler; // Delegate for 'about to unload domain' event
    OBJECTREF    m_pAssemblyEventHandler; // Delegate for 'loading assembly' event
    OBJECTREF    m_pProcessExitEventHandler; // Delegate for 'process exit' event.  Only used in Default appdomain.
    OBJECTREF    m_pTypeEventHandler;     // Delegate for 'resolve type' event
    OBJECTREF    m_pResourceEventHandler; // Delegate for 'resolve resource' event
    OBJECTREF    m_pAsmResolveEventHandler; // Delegate for 'resolve assembly' event
    OBJECTREF    m_pDefaultContext;     // Default managed context for this AD.
    OBJECTREF    m_pUnhandledExceptionEventHandler; // Delegate for 'unhandled exception' event
    OBJECTREF    m_pDefaultPrincipal;  // Lazily computed default principle object used by threads
    OBJECTREF    m_pURITable;          // Identity table for remoting
    INT32        m_iPrincipalPolicy;   // Type of principal to create by default
    AppDomain*   m_pDomain;            // Pointer to the BaseDomain Structure
    BOOL         m_bHasSetPolicy;      // SetDomainPolicy has been called for this domain

  protected:
    AppDomainBaseObject() {}
   ~AppDomainBaseObject() {}
   
  public:

    void SetDomain(AppDomain* p) 
    {
        m_pDomain = p;
    }
    AppDomain* GetDomain() 
    {
        return m_pDomain;
    }

    OBJECTREF GetSecurityIdentity()
    {
        return m_pSecurityIdentity;
    }

    // Ref needs to be a PTRARRAYREF
    void SetPolicies(OBJECTREF ref)
    {
        SetObjectReference(&m_pPolicies, ref, m_pDomain );
    }

    BOOL HasSetPolicy()
    {
        return m_bHasSetPolicy;
    }
};

// AssemblyBaseObject 
// This class is the base class for assemblies
//  
class AssemblyBaseObject : public Object
{
    friend Assembly;
    friend class Binder;

  protected:
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class definition of this object.
    OBJECTREF     m_pAssemblyBuilderData;
    OBJECTREF     m_pModuleEventHandler;   // Delegate for 'resolve module' event
    OBJECTREF     m_cache;                 // Slot for storing managed cached data.
    Assembly*     m_pAssembly;             // Pointer to the Assembly Structure

  protected:
    AssemblyBaseObject() {}
   ~AssemblyBaseObject() {}
   
  public:

    void SetAssembly(Assembly* p) 
    {
        m_pAssembly = p;
    }

    Assembly* GetAssembly() 
    {
        return m_pAssembly;
    }
};

class AssemblyHash
{
    DWORD   m_algorithm;
    LPCUTF8 m_szValue;
};
 

// AssemblyNameBaseObject 
// This class is the base class for assembly names
//  
class AssemblyNameBaseObject : public Object
{
    friend class AssemblyNative;
    friend class AppDomainNative;
    friend class Binder;

  protected:
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class definition of this object.

    OBJECTREF     m_pSimpleName; 
    U1ARRAYREF    m_pPublicKey;
    U1ARRAYREF    m_pPublicKeyToken;
    OBJECTREF     m_pCultureInfo;
    OBJECTREF     m_pCodeBase;
    OBJECTREF     m_pVersion;
    OBJECTREF     m_StrongNameKeyPair;
    OBJECTREF     m_Assembly;
    OBJECTREF     m_siInfo;
    U1ARRAYREF    m_HashForControl;
    DWORD         m_HashAlgorithm;
    DWORD         m_HashAlgorithmForControl;
    DWORD         m_VersionCompatibility;
    DWORD         m_Flags;


  protected:
    AssemblyNameBaseObject() {}
   ~AssemblyNameBaseObject() {}
   
  public:
    OBJECTREF GetSimpleName() { return m_pSimpleName; }
    U1ARRAYREF GetPublicKey() { return m_pPublicKey; }
    U1ARRAYREF GetPublicKeyToken() { return m_pPublicKeyToken; }
    OBJECTREF GetStrongNameKeyPair() { return m_StrongNameKeyPair; }
    OBJECTREF GetCultureInfo() { return m_pCultureInfo; }
    OBJECTREF GetAssemblyCodeBase() { return m_pCodeBase; }
    OBJECTREF GetVersion() { return m_pVersion; }
    DWORD GetAssemblyHashAlgorithm() { return m_HashAlgorithm; }
    DWORD GetFlags() { return m_Flags; }
    void UnsetAssembly() { m_Assembly = NULL; }
    U1ARRAYREF GetHashForControl() {return m_HashForControl;}
    DWORD GetHashAlgorithmForControl() { return m_HashAlgorithmForControl; }
};

// VersionBaseObject
// This class is the base class for versions
//
class VersionBaseObject : public Object
{
    friend AssemblyName;
    friend class Binder;

  protected:
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class definition of this object.

    int m_Major;
    int m_Minor;
    int m_Build;
    int m_Revision;
 
  protected:
    VersionBaseObject() {}
   ~VersionBaseObject() {}

  public:
    int GetMajor() { return m_Major; }
    int GetMinor() { return m_Minor; }
    int GetBuild() { return m_Build; }
    int GetRevision() { return m_Revision; }
};

// FrameSecurityDescriptorBaseObject 
// This class is the base class for the frame security descriptor
//  
class FrameSecurityDescriptorBaseObject : public Object
{
  protected:
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class definition of this object.

    OBJECTREF       m_assertions;
    OBJECTREF       m_denials;
    OBJECTREF       m_restriction;
    BOOL            m_assertAllPossible;

  protected:
    FrameSecurityDescriptorBaseObject() {}
   ~FrameSecurityDescriptorBaseObject() {}
   
  public:
    BOOL HasAssertions()
    {
        return m_assertions != NULL;
    }

    BOOL HasDenials()
    {
        return m_denials != NULL;
    }

    BOOL HasPermitOnly()
    {
        return m_restriction != NULL;
    }

    BOOL HasAssertAllPossible()
    {
        return m_assertAllPossible;
    }

};

#ifdef _DEBUG

typedef REF<StringObject> STRINGREF;

typedef REF<ReflectBaseObject> REFLECTBASEREF;

typedef REF<ReflectModuleBaseObject> REFLECTMODULEBASEREF;

typedef REF<ReflectClassBaseObject> REFLECTCLASSBASEREF;

typedef REF<ReflectTokenBaseObject> REFLECTTOKENBASEREF;

typedef REF<CustomAttributeClass> CUSTOMATTRIBUTEREF;

typedef REF<ThreadBaseObject> THREADBASEREF;

typedef REF<LocalDataStoreBaseObject> LOCALDATASTOREREF;

typedef REF<AppDomainBaseObject> APPDOMAINREF;

typedef REF<ContextBaseObject> CONTEXTBASEREF;

typedef REF<AssemblyBaseObject> ASSEMBLYREF;

typedef REF<AssemblyNameBaseObject> ASSEMBLYNAMEREF;

typedef REF<VersionBaseObject> VERSIONREF;

typedef REF<FrameSecurityDescriptorBaseObject> FRAMESECDESCREF;


inline __int64 ObjToInt64(OBJECTREF or)
{
    LPVOID v;
    *((OBJECTREF*)&v) = or;
    return (__int64)v;
}

inline OBJECTREF Int64ToObj(__int64 i64)
{
    LPVOID v;
    v = (LPVOID)i64;
    return ObjectToOBJECTREF ((Object*)v);
}


inline __int64 StringToInt64(STRINGREF or)
{
    LPVOID v;
    *((STRINGREF*)&v) = or;
    return (__int64)v;
}

inline STRINGREF Int64ToString(__int64 i64)
{
    LPVOID v;
    v = (LPVOID)i64;
    return ObjectToSTRINGREF ((StringObject*)v);
}


#else

typedef StringObject* STRINGREF;
typedef ReflectBaseObject* REFLECTBASEREF;
typedef ReflectModuleBaseObject* REFLECTMODULEBASEREF;
typedef ReflectClassBaseObject* REFLECTCLASSBASEREF;
typedef ReflectTokenBaseObject* REFLECTTOKENBASEREF;
typedef CustomAttributeClass* CUSTOMATTRIBUTEREF;
typedef ThreadBaseObject* THREADBASEREF;
typedef LocalDataStoreBaseObject* LOCALDATASTOREREF;
typedef AppDomainBaseObject* APPDOMAINREF;
typedef ContextBaseObject* CONTEXTBASEREF;
typedef AssemblyBaseObject* ASSEMBLYREF;
typedef AssemblyNameBaseObject* ASSEMBLYNAMEREF;
typedef VersionBaseObject* VERSIONREF;
typedef FrameSecurityDescriptorBaseObject* FRAMESECDESCREF;

#define ObjToInt64(objref) ((__int64)(objref))
#define Int64ToObj(i64)    ((OBJECTREF)(i64))

#define StringToInt64(objref) ((__int64)(objref))
#define Int64ToString(i64)    ((STRINGREF)(i64))

#endif //_DEBUG


// MarshalByRefObjectBaseObject 
// This class is the base class for MarshalByRefObject
//  
class MarshalByRefObjectBaseObject : public Object
{
    friend class Binder;

  protected:
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    //  classlib class definition of this object.
    OBJECTREF     m_ServerIdentity;

  protected:
    MarshalByRefObjectBaseObject() {}
   ~MarshalByRefObjectBaseObject() {}   
};

// WaitHandleBase
// Base class for WaitHandle 
class WaitHandleBase :public MarshalByRefObjectBaseObject //Object
{
    friend class WaitHandleNative;
    friend class Binder;

public:
    __inline LPVOID GetWaitHandle() {return m_handle;}

private:
    OBJECTREF m_handleProtector;
    LPVOID m_handle;
};

typedef WaitHandleBase* WAITHANDLEREF;

class ComponentServices;

/*************************
// DON'T CHANGE THE LAYOUT OF THE FOLLOWING CLASSES
// WITHOUT UPDATING THE MANAGED CLASSES IN BCL ALSO
**************************/

class RealProxyObject : public Object
{
    friend class Binder;

protected:
    RealProxyObject()
    {}; // don't instantiate this class directly
    ~RealProxyObject(){};

private:
    OBJECTREF       _tp;
    OBJECTREF       _identity;
    OBJECTREF       _serverObject;
};


struct ComPlusWrapper;
//-------------------------------------------------------------
// class ComObject, Exposed class __ComObject
// 
// 
//-------------------------------------------------------------
class ComObject : public MarshalByRefObjectBaseObject
{
    friend class Binder;

protected:

    ComObject()
    {}; // don't instantiate this class directly
    ~ComObject(){};

    static TypeHandle m_IEnumerableType;

public:
    OBJECTREF           m_ObjectToDataMap;
    ComPlusWrapper*     m_pWrap;

    //-------------------------------------------------------------
    // Get the wrapper that this object wraps 
    ComPlusWrapper* GetWrapper()
    {
        return m_pWrap;
    }

    //---------------------------------------------------------------
    // Init method
    void Init(ComPlusWrapper *pWrap)
    {
        _ASSERTE((pWrap != NULL) || (m_pWrap != NULL));
        m_pWrap = pWrap;
    }

    //--------------------------------------------------------------------
    // SupportsInterface
    static  BOOL SupportsInterface(OBJECTREF oref, 
                                            MethodTable* pIntfTable);

    //-----------------------------------------------------------------
    // GetComIPFromWrapper
    static inline IUnknown* GetComIPFromWrapper(OBJECTREF oref, 
                                                MethodTable* pIntfTable);

    //-----------------------------------------------------------
    // create an empty ComObjectRef
    static OBJECTREF ComObject::CreateComObjectRef(MethodTable* pMT);

    //-----------------------------------------------------------
    // Release all the data associated with the __ComObject.
    static void ReleaseAllData(OBJECTREF oref);

    //-----------------------------------------------------------
    // ISerializable methods
    typedef struct 
    {
        DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF, context );
    } _GetObjectDataArgs;

    typedef struct 
    {
        DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF, context );
        DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF, info );
    } _SetObjectDataArgs;

    static OBJECTREF GetObjectData(_GetObjectDataArgs* pArgs);
    static VOID     SetObjectData(_SetObjectDataArgs* pArgs);
};

#ifdef _DEBUG
typedef REF<ComObject> COMOBJECTREF;
#else
typedef ComObject*     COMOBJECTREF;
#endif


//-------------------------------------------------------------
// class UnknownWrapper, Exposed class UnknownWrapper
// 
// 
//-------------------------------------------------------------
class UnknownWrapper : public Object
{
protected:

    UnknownWrapper() {}; // don't instantiate this class directly
    ~UnknownWrapper() {};

    OBJECTREF m_WrappedObject;

public:
    OBJECTREF GetWrappedObject()
    {
        return m_WrappedObject;
    }

    void SetWrappedObject(OBJECTREF pWrappedObject)
    {
        m_WrappedObject = pWrappedObject;
    }
};

#ifdef _DEBUG
typedef REF<UnknownWrapper> UNKNOWNWRAPPEROBJECTREF;
#else
typedef UnknownWrapper*     UNKNOWNWRAPPEROBJECTREF;
#endif


//-------------------------------------------------------------
// class DispatchWrapper, Exposed class DispatchWrapper
// 
// 
//-------------------------------------------------------------
class DispatchWrapper : public Object
{
protected:

    DispatchWrapper() {}; // don't instantiate this class directly
    ~DispatchWrapper() {};

    OBJECTREF m_WrappedObject;

public:
    OBJECTREF GetWrappedObject()
    {
        return m_WrappedObject;
    }

    void SetWrappedObject(OBJECTREF pWrappedObject)
    {
        m_WrappedObject = pWrappedObject;
    }
};

#ifdef _DEBUG
typedef REF<DispatchWrapper> DISPATCHWRAPPEROBJECTREF;
#else
typedef DispatchWrapper*     DISPATCHWRAPPEROBJECTREF;
#endif


//-------------------------------------------------------------
// class RecordWrapper, Exposed class RecordWrapper
// 
// 
//-------------------------------------------------------------
class RecordWrapper : public Object
{
protected:

    RecordWrapper() {}; // don't instantiate this class directly
    ~RecordWrapper() {};

    OBJECTREF m_WrappedObject;

public:
    OBJECTREF GetWrappedObject()
    {
        return m_WrappedObject;
    }

    void SetWrappedObject(OBJECTREF pWrappedObject)
    {
        m_WrappedObject = pWrappedObject;
    }
};

#ifdef _DEBUG
typedef REF<RecordWrapper> RECORDWRAPPEROBJECTREF;
#else
typedef RecordWrapper*     RECORDWRAPPEROBJECTREF;
#endif


//-------------------------------------------------------------
// class ErrorWrapper, Exposed class ErrorWrapper
// 
// 
//-------------------------------------------------------------
class ErrorWrapper : public Object
{
protected:

    ErrorWrapper() {}; // don't instantiate this class directly
    ~ErrorWrapper() {};

    INT32 m_ErrorCode;

public:
    INT32 GetErrorCode()
    {
        return m_ErrorCode;
    }

    void SetErrorCode(int ErrorCode)
    {
        m_ErrorCode = ErrorCode;
    }
};

#ifdef _DEBUG
typedef REF<ErrorWrapper> ERRORWRAPPEROBJECTREF;
#else
typedef ErrorWrapper*     ERRORWRAPPEROBJECTREF;
#endif


//-------------------------------------------------------------
// class CurrencyWrapper, Exposed class CurrencyWrapper
// 
// 
//-------------------------------------------------------------

#pragma pack(push,4)

class CurrencyWrapper : public Object
{
protected:

    CurrencyWrapper() {}; // don't instantiate this class directly
    ~CurrencyWrapper() {};

    DECIMAL m_WrappedObject;

public:
    DECIMAL GetWrappedObject()
    {
        return m_WrappedObject;
    }

    void SetWrappedObject(DECIMAL WrappedObj)
    {
        m_WrappedObject = WrappedObj;
    }
};

#ifdef _DEBUG
typedef REF<CurrencyWrapper> CURRENCYWRAPPEROBJECTREF;
#else
typedef CurrencyWrapper*     CURRENCYWRAPPEROBJECTREF;
#endif

#pragma pack(pop)


//
// StringBufferObject
//
// Note that the "copy on write" bit is buried within the implementation
// of the object in order to make the implementation smaller.
//


class StringBufferObject : public Object
{
    friend class Binder;

  private:
    // READ ME:
    //   Modifying the order or fields of this object may require
    //   other changes to the classlib class definition of this
    //   object or special handling when loading this system class.
    //   The GCDesc stuff must be built correctly to promote the m_orString
    //   reference during garbage collection.   See jeffwe for details.
    STRINGREF   m_orString;
    void*       m_currentThread; 
    INT32       m_MaxCapacity;

  protected:
    StringBufferObject() { };
   ~StringBufferObject() { };

  public:
    STRINGREF   GetStringRef()                          { return( m_orString ); };
    VOID        SetStringRef(STRINGREF orString)        { SetObjectReference( (OBJECTREF*) &m_orString, ObjectToOBJECTREF(*(Object**) &orString), GetAppDomain()); };

  void* GetCurrentThread()
  {
     return m_currentThread;
  }

  VOID SetCurrentThread(void* value)
  {
     m_currentThread = value;
  }

  //An efficency hack to save us from calling GetStringRef().
  DWORD GetArrayLength() 
  {
      return m_orString->GetArrayLength();
  };
  INT32 GetMaxCapacity() 
  {
      return m_MaxCapacity;
  }
  VOID SetMaxCapacity(INT32 max) 
  {
      m_MaxCapacity=max;
  }
};

#ifdef _DEBUG
typedef REF<StringBufferObject> STRINGBUFFERREF;
#else _DEBUG
typedef StringBufferObject * STRINGBUFFERREF;
#endif _DEBUG

// These two prototypes should really be in util.hpp.
// But we have a very bad cyclic includes.
// Out of 157 .cpp files under VM, 155 includes common.h.
// Why do we have 24 .h/.hpp files including util.hpp?
HANDLE VMWszCreateFile(
    LPCWSTR pwszFileName,   // pointer to name of the file 
    DWORD dwDesiredAccess,  // access (read-write) mode 
    DWORD dwShareMode,  // share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // pointer to security descriptor 
    DWORD dwCreationDistribution,   // how to create 
    DWORD dwFlagsAndAttributes, // file attributes 
    HANDLE hTemplateFile )  // handle to file with attributes to copy  
    ;

HANDLE VMWszCreateFile(
    STRINGREF sFileName,   // pointer to STRINGREF containing file name
    DWORD dwDesiredAccess,  // access (read-write) mode 
    DWORD dwShareMode,  // share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // pointer to security descriptor 
    DWORD dwCreationDistribution,   // how to create 
    DWORD dwFlagsAndAttributes, // file attributes 
    HANDLE hTemplateFile )  // handle to file with attributes to copy  
    ;


#endif _OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\nstruct.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// NSTRUCT.H -
//
// NStruct's are used to allow COM+ programs to allocate and access
// native structures for interop purposes. NStructs are actually normal GC
// objects with a class, but instead of keeping fields in the GC object,
// it keeps a hidden pointer to a fixed memory block (which may have been
// allocated by a third party.) Field accesses to NStructs are redirected
// to this fixed block.
//



#ifndef __nstruct_h__
#define __nstruct_h__


#include "util.hpp"
#include "compile.h"
#include "mlinfo.h"
#include "comoavariant.h"
#include "comvariant.h"

// Forward refernces
class EEClass;
class EEClassLayoutInfo;
class FieldDesc;
class MethodTable;


//=======================================================================
// Magic number for default struct packing size.
//=======================================================================
#define DEFAULT_PACKING_SIZE 8


//=======================================================================
// IMPORTANT: This value is used to figure out how much to allocate
// for a fixed array of FieldMarshaler's. That means it must be at least
// as large as the largest FieldMarshaler subclass. This requirement
// is guarded by an assert.
//=======================================================================
#define MAXFIELDMARSHALERSIZE 36



//=======================================================================
// This is invoked from the class loader while building a EEClass.
// This function should check if explicit layout metadata exists.
//
// Returns:
//  S_OK    - yes, there's layout metadata
//  S_FALSE - no, there's no layout.
//  fail    - couldn't tell because of metadata error
//
// If S_OK,
//   *pNLType            gets set to nltAnsi or nltUnicode
//   *pPackingSize       declared packing size
//   *pfExplicitoffsets  offsets explicit in metadata or computed?
//=======================================================================
HRESULT HasLayoutMetadata(IMDInternalImport *pInternalImport, mdTypeDef cl, EEClass *pParentClass, BYTE *pPackingSize, BYTE *pNLTType, BOOL *pfExplicitOffsets, BOOL *pfIsBlob);








//=======================================================================
// Each possible COM+/Native pairing of data type has a
// NLF_* id. This is used to select the marshaling code.
//=======================================================================
#undef DEFINE_NFT
#define DEFINE_NFT(name, nativesize) name,
enum NStructFieldType {

#include "nsenums.h"

    NFT_COUNT

};






MethodTable* ArraySubTypeLoadWorker(NativeTypeParamInfo ParamInfo, Assembly* pAssembly);
VARTYPE ArrayVarTypeFromTypeHandleWorker(TypeHandle th);


//=======================================================================
// The classloader stores an intermediate representation of the layout
// metadata in an array of these structures. The dual-pass nature
// is a bit extra overhead but building this structure requiring loading
// other classes (for nested structures) and I'd rather keep this
// next to the other places where we load other classes (e.g. the superclass
// and implemented interfaces.)
//
// Each redirected field gets one entry in LayoutRawFieldInfo.
// The array is terminated by one dummy record whose m_MD == mdMemberDefNil.
//=======================================================================
struct LayoutRawFieldInfo
{
    mdFieldDef  m_MD;             // mdMemberDefNil for end of array
    UINT8       m_nft;            // NFT_* value
    UINT32      m_offset;         // native offset of field
    UINT32      m_cbNativeSize;   // native size of field in bytes
    ULONG       m_sequence;       // sequence # from metadata

    struct {
        private:
            char m_space[MAXFIELDMARSHALERSIZE];
    } m_FieldMarshaler;
    BOOL        m_fIsOverlapped;      

};


//=======================================================================
// Called from the clsloader to load up and summarize the field metadata
// for layout classes.
// WARNING: This function can load other classes (for resolving nested
// structures.) 
//=======================================================================
HRESULT CollectLayoutFieldMetadata(
   mdTypeDef cl,                // cl of the NStruct being loaded
   BYTE packingSize,            // packing size (from @dll.struct)
   BYTE nlType,                 // nltype (from @dll.struct)
   BOOL fExplicitOffsets,       // explicit offsets?
   EEClass *pParentClass,       // the loaded superclass
   ULONG cMembers,              // total number of members (methods + fields)
   HENUMInternal *phEnumField,  // enumerator for field
   Module* pModule,             // Module that defines the scope, loader and heap (for allocate FieldMarshalers)
   EEClassLayoutInfo *pEEClassLayoutInfoOut,  // caller-allocated structure to fill in.
   LayoutRawFieldInfo *pInfoArrayOut, // caller-allocated array to fill in.  Needs room for cMember+1 elements
   OBJECTREF *pThrowable
);








VOID LayoutUpdateNative(LPVOID *ppProtectedManagedData, UINT offsetbias, EEClass *pcls, BYTE* pNativeData, CleanupWorkList *pOptionalCleanupWorkList);
VOID LayoutUpdateComPlus(LPVOID *ppProtectedManagedData, UINT offsetbias, EEClass *pcls, BYTE *pNativeData, BOOL fDeleteNativeCopies);
VOID LayoutDestroyNative(LPVOID pNative, EEClass *pcls);



VOID FmtClassUpdateNative(OBJECTREF *ppProtectedManagedData, BYTE *pNativeData);
VOID FmtClassUpdateNative(OBJECTREF pObj, BYTE *pNativeData);
VOID FmtClassUpdateComPlus(OBJECTREF *ppProtectedManagedData, BYTE *pNativeData, BOOL fDeleteOld);
VOID FmtClassUpdateComPlus(OBJECTREF pObj, BYTE *pNativeData, BOOL fDeleteOld);
VOID FmtClassDestroyNative(LPVOID pNative, EEClass *pcls);

VOID FmtValueTypeUpdateNative(LPVOID pProtectedManagedData, MethodTable *pMT, BYTE *pNativeData);
VOID FmtValueTypeUpdateComPlus(LPVOID pProtectedManagedData, MethodTable *pMT, BYTE *pNativeData, BOOL fDeleteOld);




//=======================================================================
// Abstract base class. Each type of NStruct reference field extends
// this class and implements the necessary methods.
//
//   UpdateNative
//       - this method receives a COM+ field value and a pointer to
//         native field inside the fixed portion. it should marshal
//         the COM+ value to a new native instance and store it
//         inside *pNativeValue. Do not destroy the value you overwrite
//         in *pNativeValue.
//
//         may throw COM+ exceptions
//
//   UpdateComPlus
//       - this method receives a read-only pointer to the native field inside
//         the fixed portion. it should marshal the native value to
//         a new COM+ instance and store it in *ppComPlusValue.
//         (the caller keeps *ppComPlusValue gc-protected.)
//
//         may throw COM+ exceptions
//
//   DestroyNative
//       - should do the type-specific deallocation of a native instance.
//         if the type has a "NULL" value, this method should
//         overwrite the field with this "NULL" value (whether or not
//         it does, however, it's considered a bug to depend on the
//         value left over after a DestroyNative.)
//
//         must NOT throw a COM+ exception
//
//   NativeSize
//       - returns the size, in bytes, of the native version of the field.
//
//   AlignmentRequirement
//       - returns one of 1,2,4 or 8; indicating the "natural" alignment
//         of the native field. In general,
//
//            for scalars, the AR is equal to the size
//            for arrays,  the AR is that of a single element
//            for structs, the AR is that of the member with the largest AR
//
//
//=======================================================================

class FieldMarshaler_BSTR;
class FieldMarshaler_NestedLayoutClass;
class FieldMarshaler_NestedValueClass;
class FieldMarshaler_StringUni;
class FieldMarshaler_StringAnsi;
class FieldMarshaler_FixedStringUni;
class FieldMarshaler_FixedStringAnsi;
class FieldMarshaler_FixedCharArrayAnsi;
class FieldMarshaler_FixedBoolArray;
class FieldMarshaler_FixedBSTRArray;
class FieldMarshaler_FixedScalarArray;
class FieldMarshaler_SafeArray;
class FieldMarshaler_Delegate;
class FieldMarshaler_Interface;
class FieldMarshaler_Illegal;
class FieldMarshaler_Copy1;
class FieldMarshaler_Copy2;
class FieldMarshaler_Copy4;
class FieldMarshaler_Copy8;
class FieldMarshaler_Ansi;
class FieldMarshaler_WinBool;
class FieldMarshaler_CBool;
class FieldMarshaler_Decimal;
class FieldMarshaler_Date;
class FieldMarshaler_VariantBool;


//=======================================================================
//
// FieldMarshaler's are constructed in place and replicated via bit-wise
// copy, so you can't have a destructor. Make sure you don't define a 
// destructor in derived classes!!
// We used to enforce this by defining a private destructor, by the C++
// compiler doesn't allow that anymore.
//
//=======================================================================

class FieldMarshaler
{
    public:
        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const = 0;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const = 0;
        virtual VOID DestroyNative(LPVOID pNativeValue) const 
        {
        }
        virtual UINT32 NativeSize() = 0;
        virtual UINT32 AlignmentRequirement() = 0;

        virtual BOOL IsScalarMarshaler() const
        {
            return FALSE;
        }

        virtual BOOL IsNestedValueClassMarshaler() const
        {
            return FALSE;
        }

        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }
        
        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID NestedValueClassUpdateNative(const VOID **ppProtectedComPlus, UINT startoffset, LPVOID pNative) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }
        
        virtual VOID NestedValueClassUpdateComPlus(const VOID *pNative, LPVOID *ppProtectedComPlus, UINT startoffset) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }


        FieldDesc       *m_pFD;                // FieldDesc
        UINT32           m_dwExternalOffset;   // offset of field in the fixed portion

        void * operator new (size_t sz, void *pv)
        {
            return pv;
        }

        // 
        // Methods for saving & restoring in prejitted images:
        //

        enum Class
        {
            CLASS_BSTR,
            CLASS_NESTED_LAYOUT_CLASS,
            CLASS_NESTED_VALUE_CLASS,
            CLASS_STRING_UNI,
            CLASS_STRING_ANSI,
            CLASS_FIXED_STRING_UNI,
            CLASS_FIXED_STRING_ANSI,
            CLASS_FIXED_CHAR_ARRAY_ANSI,
            CLASS_FIXED_BOOL_ARRAY,
            CLASS_FIXED_BSTR_ARRAY,
            CLASS_FIXED_SCALAR_ARRAY,
            CLASS_SAFEARRAY,
            CLASS_DELEGATE,
            CLASS_INTERFACE,
            CLASS_VARIANT,
            CLASS_ILLEGAL,
            CLASS_COPY1,
            CLASS_COPY2,
            CLASS_COPY4,
            CLASS_COPY8,
            CLASS_ANSI,
            CLASS_WINBOOL,
            CLASS_CBOOL,
            CLASS_DECIMAL,
            CLASS_DATE,
            CLASS_VARIANTBOOL,
            CLASS_CURRENCY,
        };

        enum Dummy
        {
        };

        virtual Class GetClass() const = 0;
        FieldMarshaler(Module *pModule) {}

        virtual HRESULT Fixup(DataImage *image)
        {
            HRESULT hr;

            IfFailRet(image->FixupPointerField(&m_pFD));

            Class *dest = (Class *) image->GetImagePointer(this);
            if (dest == NULL)
                return E_POINTER;
            *dest = GetClass();

            return S_OK;
        }

        static FieldMarshaler *RestoreConstruct(MethodTable* pMT, void *space, Module *pModule);

    protected:
        FieldMarshaler()
        {
#ifdef _DEBUG
            m_pFD = (FieldDesc*)(size_t)0xcccccccc;
            m_dwExternalOffset = 0xcccccccc;
#endif
        }
};




//=======================================================================
// BSTR <--> System.String
//=======================================================================
class FieldMarshaler_BSTR : public FieldMarshaler
{
    public:
        FieldMarshaler_BSTR() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;
        virtual VOID DestroyNative(LPVOID pNativeValue) const;

        virtual UINT32 NativeSize()
        {
            return sizeof(BSTR);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(BSTR);
        }

        Class GetClass() const { return CLASS_BSTR; }
        FieldMarshaler_BSTR(Module *pModule) : FieldMarshaler(pModule) {}
};





//=======================================================================
// Embedded struct <--> LayoutClass
//=======================================================================
class FieldMarshaler_NestedLayoutClass : public FieldMarshaler
{
    public:
        //FieldMarshaler_NestedLayoutClass() {}

        FieldMarshaler_NestedLayoutClass(MethodTable *pMT)
        {
            m_pNestedMethodTable = pMT;
        }

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;
        virtual VOID DestroyNative(LPVOID pNativeValue) const;

        virtual UINT32 NativeSize();
        virtual UINT32 AlignmentRequirement();

        Class GetClass() const { return CLASS_NESTED_LAYOUT_CLASS; }

        FieldMarshaler_NestedLayoutClass(Module *pModule) : FieldMarshaler(pModule)
        {
            THROWSCOMPLUSEXCEPTION();

            DWORD rva = (DWORD)(size_t)m_pNestedMethodTable; // @todo WIN64 - Pointer truncation
            Module *pContainingModule = pModule->GetBlobModule(rva);
            TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                          pModule->GetZapBase() + rva);
            m_pNestedMethodTable = type.GetMethodTable();
        }

        virtual HRESULT Fixup(DataImage *image)
        {
            HRESULT hr;

            IfFailRet(image->FixupPointerFieldToToken(&m_pNestedMethodTable, 
                                                      NULL, m_pNestedMethodTable->GetModule(),
                                                      mdtTypeDef));

            
            return FieldMarshaler::Fixup(image);
        }
        
#ifdef CUSTOMER_CHECKED_BUILD
        MethodTable *GetMethodTable() { return m_pNestedMethodTable; }
#endif // CUSTOMER_CHECKED_BUILD

    private:
        // MethodTable of nested NStruct.
        MethodTable     *m_pNestedMethodTable;
};

//=======================================================================
// Embedded struct <--> ValueClass
//=======================================================================
class FieldMarshaler_NestedValueClass : public FieldMarshaler
{
    public:

//        FieldMarshaler_NestedValueClass() {}

        FieldMarshaler_NestedValueClass(MethodTable *pMT)
        {
            m_pNestedMethodTable = pMT;
        }

        virtual BOOL IsNestedValueClassMarshaler() const
        {
            return TRUE;
        }


        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID DestroyNative(LPVOID pNativeValue) const;

        virtual UINT32 NativeSize();
        virtual UINT32 AlignmentRequirement();
        virtual VOID NestedValueClassUpdateNative(const VOID **ppProtectedComPlus, UINT startoffset, LPVOID pNative) const;
        virtual VOID NestedValueClassUpdateComPlus(const VOID *pNative, LPVOID *ppProtectedComPlus, UINT startoffset) const;

        Class GetClass() const { return CLASS_NESTED_VALUE_CLASS; }
        FieldMarshaler_NestedValueClass(Module *pModule) : FieldMarshaler(pModule)
        {
            THROWSCOMPLUSEXCEPTION();
            DWORD rva = (DWORD)(size_t)m_pNestedMethodTable; // @todo WIN64 - Pointer truncation
            Module *pContainingModule = pModule->GetBlobModule(rva);
            TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                          pModule->GetZapBase() + rva);
            m_pNestedMethodTable = type.GetMethodTable();
        }

        BOOL IsBlittable()
        {
            return m_pNestedMethodTable->GetClass()->IsBlittable();
        }

        virtual HRESULT Fixup(DataImage *image)
        { 
            HRESULT hr;

            IfFailRet(image->FixupPointerFieldToToken(&m_pNestedMethodTable, 
                                                      NULL, m_pNestedMethodTable->GetModule(),
                                                      mdtTypeDef));

            return FieldMarshaler::Fixup(image);
        }

#ifdef CUSTOMER_CHECKED_BUILD
        MethodTable *GetMethodTable() { return m_pNestedMethodTable; }
#endif // CUSTOMER_CHECKED_BUILD

    private:
        // MethodTable of nested NStruct.
        MethodTable     *m_pNestedMethodTable;
};



//=======================================================================
// LPWSTR <--> System.String
//=======================================================================
class FieldMarshaler_StringUni : public FieldMarshaler
{
    public:
        FieldMarshaler_StringUni() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;
        virtual VOID DestroyNative(LPVOID pNativeValue) const;

        virtual UINT32 NativeSize()
        {
            return sizeof(LPWSTR);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(LPWSTR);
        }

        Class GetClass() const { return CLASS_STRING_UNI; }
        FieldMarshaler_StringUni(Module *pModule) : FieldMarshaler(pModule) {}
};


//=======================================================================
// LPSTR <--> System.String
//=======================================================================
class FieldMarshaler_StringAnsi : public FieldMarshaler
{
    public:
        FieldMarshaler_StringAnsi(BOOL BestFit, BOOL ThrowOnUnmappableChar) : 
            m_BestFitMap(BestFit), m_ThrowOnUnmappableChar(ThrowOnUnmappableChar) {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;
        virtual VOID DestroyNative(LPVOID pNativeValue) const;

        virtual UINT32 NativeSize()
        {
            return sizeof(LPSTR);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(LPSTR);
        }
    
        Class GetClass() const { return CLASS_STRING_ANSI; }
        FieldMarshaler_StringAnsi(Module *pModule, BOOL BestFit, BOOL ThrowOnUnmappableChar) :
            FieldMarshaler(pModule), m_BestFitMap(BestFit),
            m_ThrowOnUnmappableChar(ThrowOnUnmappableChar) {}

        BOOL m_BestFitMap;
        BOOL m_ThrowOnUnmappableChar;

        void SetBestFit(BOOL BestFit) { m_BestFitMap = BestFit; }
        void SetThrowOnUnmappableChar(BOOL ThrowOnUnmappableChar) { m_ThrowOnUnmappableChar = ThrowOnUnmappableChar; }        
};


//=======================================================================
// Embedded LPWSTR <--> System.String
//=======================================================================
class FieldMarshaler_FixedStringUni : public FieldMarshaler
{
    public:
        FieldMarshaler_FixedStringUni() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;

        virtual UINT32 NativeSize()
        {
            return m_numchar * sizeof(WCHAR);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(WCHAR);
        }

        FieldMarshaler_FixedStringUni(UINT32 numChar)
        {
            m_numchar = numChar;
        }

        Class GetClass() const { return CLASS_FIXED_STRING_UNI; }
        FieldMarshaler_FixedStringUni(Module *pModule) : FieldMarshaler(pModule) {}

    private:
        // # of characters for fixed strings
        UINT32           m_numchar;
    

};


//=======================================================================
// Embedded LPSTR <--> System.String
//=======================================================================
class FieldMarshaler_FixedStringAnsi : public FieldMarshaler
{
    public:
        FieldMarshaler_FixedStringAnsi(BOOL BestFitMap, BOOL ThrowOnUnmappableChar) :
            m_BestFitMap(BestFitMap), m_ThrowOnUnmappableChar(ThrowOnUnmappableChar) {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;

        virtual UINT32 NativeSize()
        {
            return m_numchar * sizeof(CHAR);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(CHAR);
        }

        FieldMarshaler_FixedStringAnsi(UINT32 numChar, BOOL BestFitMap, BOOL ThrowOnUnmappableChar) :
            m_BestFitMap(BestFitMap), m_ThrowOnUnmappableChar(ThrowOnUnmappableChar)
        {
            m_numchar = numChar;
        }

        Class GetClass() const { return CLASS_FIXED_STRING_ANSI; }
        FieldMarshaler_FixedStringAnsi(Module *pModule, BOOL BestFitMap, BOOL ThrowOnUnmappableChar) :
            FieldMarshaler(pModule), m_BestFitMap(BestFitMap), m_ThrowOnUnmappableChar(ThrowOnUnmappableChar) {}

        void SetBestFit(BOOL BestFit) { m_BestFitMap = BestFit; }
        void SetThrowOnUnmappableChar(BOOL ThrowOnUnmappableChar) { m_ThrowOnUnmappableChar = ThrowOnUnmappableChar; }        

    private:
        // # of characters for fixed strings
        UINT32           m_numchar;
        BOOL             m_BestFitMap;
        BOOL             m_ThrowOnUnmappableChar;
};


//=======================================================================
// Embedded AnsiChar array <--> char[]
//=======================================================================
class FieldMarshaler_FixedCharArrayAnsi : public FieldMarshaler
{
    public:
        FieldMarshaler_FixedCharArrayAnsi(BOOL BestFit, BOOL ThrowOnUnmappableChar) :
            m_BestFitMap(BestFit), m_ThrowOnUnmappableChar(ThrowOnUnmappableChar) {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;

        virtual UINT32 NativeSize()
        {
            return m_numElems * sizeof(CHAR);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(CHAR);
        }


        FieldMarshaler_FixedCharArrayAnsi(UINT32 numElems, BOOL BestFit, BOOL ThrowOnUnmappableChar) :
            m_BestFitMap(BestFit), m_ThrowOnUnmappableChar(ThrowOnUnmappableChar)
        {
            m_numElems = numElems;
        }

        Class GetClass() const { return CLASS_FIXED_CHAR_ARRAY_ANSI; }
        FieldMarshaler_FixedCharArrayAnsi(Module *pModule, BOOL BestFit, BOOL ThrowOnUnmappableChar) :
            FieldMarshaler(pModule), m_BestFitMap(BestFit), m_ThrowOnUnmappableChar(ThrowOnUnmappableChar) {}

        void SetBestFit(BOOL BestFit) { m_BestFitMap = BestFit; }
        void SetThrowOnUnmappableChar(BOOL ThrowOnUnmappableChar) { m_ThrowOnUnmappableChar = ThrowOnUnmappableChar; }        

    private:
        // # of elements for fixedchararray
        UINT32           m_numElems;
        BOOL             m_BestFitMap;
        BOOL             m_ThrowOnUnmappableChar;
};

//=======================================================================
// Embedded BOOL array <--> boolean[]
//=======================================================================
class FieldMarshaler_FixedBoolArray : public FieldMarshaler
{
    public:
        FieldMarshaler_FixedBoolArray() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;

        virtual UINT32 NativeSize()
        {
            return m_numElems * sizeof(BOOL);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(BOOL);
        }


        FieldMarshaler_FixedBoolArray(UINT32 numElems)
        {
            m_numElems = numElems;
        }

        Class GetClass() const { return CLASS_FIXED_BOOL_ARRAY; }
        FieldMarshaler_FixedBoolArray(Module *pModule) : FieldMarshaler(pModule) {}

    private:
        // # of elements for fixedchararray
        UINT32           m_numElems;

};

//=======================================================================
// Embedded BSTR array <--> string[]
//=======================================================================
class FieldMarshaler_FixedBSTRArray : public FieldMarshaler
{
    public:
        FieldMarshaler_FixedBSTRArray() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;
        virtual VOID DestroyNative(LPVOID pNativeValue) const;

        virtual UINT32 NativeSize()
        {
            return m_numElems * sizeof(BSTR);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(BSTR);
        }


        FieldMarshaler_FixedBSTRArray(UINT32 numElems)
        {
            m_numElems = numElems;
        }

        Class GetClass() const { return CLASS_FIXED_BSTR_ARRAY; }
        FieldMarshaler_FixedBSTRArray(Module *pModule) : FieldMarshaler(pModule) {}

    private:
        // # of elements for FixedBSTRArray
        UINT32           m_numElems;

};


//=======================================================================
// Scalar arrays
//=======================================================================
class FieldMarshaler_FixedScalarArray : public FieldMarshaler
{
    public:
        FieldMarshaler_FixedScalarArray() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;

        virtual UINT32 NativeSize()
        {
            return m_numElems << m_componentShift;
        }

        virtual UINT32 AlignmentRequirement()
        {
            return 1 << m_componentShift;
        }


        FieldMarshaler_FixedScalarArray(CorElementType arrayType, UINT32 numElems, UINT32 componentShift)
        {
            m_arrayType      = arrayType;
            m_numElems       = numElems;
            m_componentShift = componentShift;
        }

        Class GetClass() const { return CLASS_FIXED_SCALAR_ARRAY; }
        FieldMarshaler_FixedScalarArray(Module *pModule) : FieldMarshaler(pModule) {}

#ifdef CUSTOMER_CHECKED_BUILD
        CorElementType GetElementType() { return m_arrayType; }
#endif // CUSTOMER_CHECKED_BUILD

    private:
        // # of elements for fixedarray
        CorElementType   m_arrayType;
        UINT32           m_numElems;
        UINT32           m_componentShift;

};



//=======================================================================
// SafeArrays
//=======================================================================
class FieldMarshaler_SafeArray : public FieldMarshaler
{
    public:
        FieldMarshaler_SafeArray() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;
        virtual VOID DestroyNative(LPVOID pNativeValue) const;

        virtual UINT32 NativeSize()
        {
            return sizeof(LPSAFEARRAY);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(LPSAFEARRAY);
        }

        FieldMarshaler_SafeArray(CorElementType arrayType, VARTYPE vt, MethodTable* pMT)
        {
            m_arrayType             = arrayType;
            m_vt                    = vt;
            m_pMT                   = pMT;
        }

        Class GetClass() const { return CLASS_SAFEARRAY; }
        FieldMarshaler_SafeArray(Module *pModule) : FieldMarshaler(pModule) {}

#ifdef CUSTOMER_CHECKED_BUILD
        CorElementType GetElementType() { return m_arrayType; }
#endif // CUSTOMER_CHECKED_BUILD

    private:
        MethodTable*     m_pMT;
        CorElementType   m_arrayType;
        VARTYPE          m_vt;
};



//=======================================================================
// Embedded function ptr <--> Delegate (note: function ptr must have
// come from delegate!!!)
//=======================================================================
class FieldMarshaler_Delegate : public FieldMarshaler
{
    public:
        FieldMarshaler_Delegate() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;

        virtual UINT32 NativeSize()
        {
            return sizeof(LPVOID);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(LPVOID);
        }


        Class GetClass() const { return CLASS_DELEGATE; }
        FieldMarshaler_Delegate(Module *pModule) : FieldMarshaler(pModule) {}

    private:

};





//=======================================================================
// COM IP <--> Interface
//=======================================================================
class FieldMarshaler_Interface : public FieldMarshaler
{
    public:
        FieldMarshaler_Interface() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;
        virtual VOID DestroyNative(LPVOID pNativeValue) const;

        virtual UINT32 NativeSize()
        {
            return sizeof(IUnknown*);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(IUnknown*);
        }


        FieldMarshaler_Interface(MethodTable *pClassMT, MethodTable *pItfMT, BOOL fDispItf, BOOL fClassIsHint)
        {
            m_pClassMT = pClassMT;
            m_pItfMT = pItfMT;
            m_fDispItf = fDispItf;
            m_fClassIsHint = fClassIsHint;
        }

        Class GetClass() const { return CLASS_INTERFACE; }
        FieldMarshaler_Interface(Module *pModule) : FieldMarshaler(pModule)
        {
            THROWSCOMPLUSEXCEPTION();

            if (m_pClassMT != NULL)
            {
                DWORD rva = (DWORD)(size_t)m_pClassMT; // @todo WIN64 - Pointer truncation
                Module *pContainingModule = pModule->GetBlobModule(rva);
                TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                              pModule->GetZapBase() + rva);
                m_pClassMT = type.GetMethodTable();
            }

            if (m_pItfMT != NULL)
            {
                DWORD rva = (DWORD)(size_t)m_pItfMT; // @todo WIN64 - Pointer truncation
                Module *pContainingModule = pModule->GetBlobModule(rva);
                TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                              pModule->GetZapBase() + rva);
                m_pItfMT = type.GetMethodTable();
            }
        }

        virtual HRESULT Fixup(DataImage *image)
        {
            HRESULT hr;

            if (m_pClassMT != NULL)
                IfFailRet(image->FixupPointerFieldToToken(&m_pClassMT, 
                                                          NULL, m_pClassMT->GetModule(), mdtTypeDef));

            if (m_pItfMT != NULL)
                IfFailRet(image->FixupPointerFieldToToken(&m_pItfMT, 
                                                          NULL, m_pItfMT->GetModule(), mdtTypeDef));

            return FieldMarshaler::Fixup(image);
        }

#ifdef CUSTOMER_CHECKED_BUILD
        void GetInterfaceInfo(MethodTable **ppItfMT, BOOL *pfDispItf)
        {
            *ppItfMT    = m_pItfMT;
            *pfDispItf  = m_fDispItf;
        }
#endif // CUSTOMER_CHECKED_BUILD

    private:
        MethodTable *m_pClassMT;
        MethodTable *m_pItfMT;
        BOOL m_fDispItf;
        BOOL m_fClassIsHint;
};




//=======================================================================
// VARIANT <--> Object
//=======================================================================
class FieldMarshaler_Variant : public FieldMarshaler
{
    public:
        FieldMarshaler_Variant() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;
        virtual VOID DestroyNative(LPVOID pNativeValue) const;

        virtual UINT32 NativeSize()
        {
            return sizeof(VARIANT);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return 8;
        }


        Class GetClass() const { return CLASS_VARIANT; }
        FieldMarshaler_Variant(Module *pModule) : FieldMarshaler(pModule) {}



};





//=======================================================================
// Dummy marshaler
//=======================================================================
class FieldMarshaler_Illegal : public FieldMarshaler
{
    public:
//        FieldMarshaler_Illegal() {}
        FieldMarshaler_Illegal(UINT resIDWhy)
        {
            m_resIDWhy = resIDWhy;
        }

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const ;
        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const ;
        virtual VOID DestroyNative(LPVOID pNativeValue) const;

        virtual UINT32 NativeSize()
        {
            return 1;
        }

        virtual UINT32 AlignmentRequirement()
        {
            return 1;
        }

        Class GetClass() const { return CLASS_ILLEGAL; }
        FieldMarshaler_Illegal(Module *pModule) : FieldMarshaler(pModule) {}

    private:
        UINT m_resIDWhy;

};




class FieldMarshaler_Copy1 : public FieldMarshaler
{
    public:
        FieldMarshaler_Copy1() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return 1;
        }

        virtual UINT32 AlignmentRequirement()
        {
            return 1;
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
        {
            *((U1*)pNative) = *((U1*)pComPlus);
        }


        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
        {
            *((U1*)pComPlus) = *((U1*)pNative);
        }

        Class GetClass() const { return CLASS_COPY1; }
        FieldMarshaler_Copy1(Module *pModule) : FieldMarshaler(pModule) {}

};



class FieldMarshaler_Copy2 : public FieldMarshaler
{
    public:
        FieldMarshaler_Copy2() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return 2;
        }

        virtual UINT32 AlignmentRequirement()
        {
            return 2;
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
        {
            *((U2*)pNative) = *((U2*)pComPlus);
        }


        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
        {
            *((U2*)pComPlus) = *((U2*)pNative);
        }

        Class GetClass() const { return CLASS_COPY2; }
        FieldMarshaler_Copy2(Module *pModule) : FieldMarshaler(pModule) {}

};


class FieldMarshaler_Copy4 : public FieldMarshaler
{
    public:
        FieldMarshaler_Copy4() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return 4;
        }

        virtual UINT32 AlignmentRequirement()
        {
            return 4;
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
        {
            *((U4*)pNative) = *((U4*)pComPlus);
        }


        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
        {
            *((U4*)pComPlus) = *((U4*)pNative);
        }

        Class GetClass() const { return CLASS_COPY4; }
        FieldMarshaler_Copy4(Module *pModule) : FieldMarshaler(pModule) {}

};


class FieldMarshaler_Copy8 : public FieldMarshaler
{
    public:
        FieldMarshaler_Copy8() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return 8;
        }

        virtual UINT32 AlignmentRequirement()
        {
            return 8;
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
        {
            *((U8*)pNative) = *((U8*)pComPlus);
        }


        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
        {
            *((U8*)pComPlus) = *((U8*)pNative);
        }

        Class GetClass() const { return CLASS_COPY8; }
        FieldMarshaler_Copy8(Module *pModule) : FieldMarshaler(pModule) {}

};



class FieldMarshaler_Ansi : public FieldMarshaler
{
    public:
        FieldMarshaler_Ansi(BOOL BestFitMap, BOOL ThrowOnUnmappableChar) :
            m_BestFitMap(BestFitMap), m_ThrowOnUnmappableChar(ThrowOnUnmappableChar) {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return sizeof(CHAR);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(CHAR);
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
        {
            THROWSCOMPLUSEXCEPTION();
            
            char c;

            DWORD flags = 0;
            BOOL DefaultCharUsed = FALSE;
        
            if (m_BestFitMap == FALSE)
                flags = WC_NO_BEST_FIT_CHARS;

            if (!(WszWideCharToMultiByte(CP_ACP,
                                flags,
                                (LPCWSTR)pComPlus,
                                1,
                                &c,
                                1,
                                NULL,
                                &DefaultCharUsed)))
            {
                COMPlusThrowWin32();
            }

            if ( DefaultCharUsed && m_ThrowOnUnmappableChar ) {
                COMPlusThrow(kArgumentException, IDS_EE_MARSHAL_UNMAPPABLE_CHAR);
            }

            *((char*)pNative) = c;
        }


        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
        {
            MultiByteToWideChar(CP_ACP, 0, (char*)pNative, 1, (LPWSTR)pComPlus, 1);
        }

        Class GetClass() const { return CLASS_ANSI; }
        FieldMarshaler_Ansi(Module *pModule, BOOL BestFitMap, BOOL ThrowOnUnmappableChar) :
            FieldMarshaler(pModule), m_BestFitMap(BestFitMap), m_ThrowOnUnmappableChar(ThrowOnUnmappableChar) {}

        void SetBestFit(BOOL BestFit) { m_BestFitMap = BestFit; }
        void SetThrowOnUnmappableChar(BOOL ThrowOnUnmappableChar) { m_ThrowOnUnmappableChar = ThrowOnUnmappableChar; }        

        BOOL             m_BestFitMap;
        BOOL             m_ThrowOnUnmappableChar;
};



class FieldMarshaler_WinBool : public FieldMarshaler
{
    public:
        FieldMarshaler_WinBool() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return sizeof(BOOL);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(BOOL);
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
        {
            *((BOOL*)pNative) = (*((U1*)pComPlus)) ? 1 : 0;
        }


        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
        {
            *((U1*)pComPlus) = (*((BOOL*)pNative)) ? 1 : 0;
        }

        Class GetClass() const { return CLASS_WINBOOL; }
        FieldMarshaler_WinBool(Module *pModule) : FieldMarshaler(pModule) {}

};



class FieldMarshaler_VariantBool : public FieldMarshaler
{
    public:
        FieldMarshaler_VariantBool() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return sizeof(VARIANT_BOOL);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(VARIANT_BOOL);
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
        {
            *((VARIANT_BOOL*)pNative) = (*((U1*)pComPlus)) ? VARIANT_TRUE : VARIANT_FALSE;
        }


        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
        {
            *((U1*)pComPlus) = (*((VARIANT_BOOL*)pNative)) ? 1 : 0;
        }

        Class GetClass() const { return CLASS_VARIANTBOOL; }
        FieldMarshaler_VariantBool(Module *pModule) : FieldMarshaler(pModule) {}

};


class FieldMarshaler_CBool : public FieldMarshaler
{
    public:
        FieldMarshaler_CBool() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return 1;
        }

        virtual UINT32 AlignmentRequirement()
        {
            return 1;
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
        {
            *((U1*)pNative) = (*((U1*)pComPlus)) ? 1 : 0;
        }


        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
        {
            *((U1*)pComPlus) = (*((U1*)pNative)) ? 1 : 0;
        }

        Class GetClass() const { return CLASS_CBOOL; }
        FieldMarshaler_CBool(Module *pModule) : FieldMarshaler(pModule) {}

};


class FieldMarshaler_Decimal : public FieldMarshaler
{
    public:
        FieldMarshaler_Decimal() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return sizeof(DECIMAL);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return 8;
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const
        {
            *((DECIMAL*)pNative) = *((DECIMAL*)pComPlus);
        }


        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const
        {
            *((DECIMAL*)pComPlus) = *((DECIMAL*)pNative);
        }

        Class GetClass() const { return CLASS_DECIMAL; }
        FieldMarshaler_Decimal(Module *pModule) : FieldMarshaler(pModule) {}

};





class FieldMarshaler_Date : public FieldMarshaler
{
    public:
        FieldMarshaler_Date() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return sizeof(DATE);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(DATE);
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const;
        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const;

        Class GetClass() const { return CLASS_DATE; }
        FieldMarshaler_Date(Module *pModule) : FieldMarshaler(pModule) {}

};




class FieldMarshaler_Currency : public FieldMarshaler
{
    public:
        FieldMarshaler_Currency() {}

        virtual VOID UpdateNative(OBJECTREF pComPlusValue, LPVOID pNativeValue) const
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual VOID UpdateComPlus(const VOID *pNativeValue, OBJECTREF *ppProtectedComPlusValue) const 
        {
            _ASSERTE(!"Not supposed to get here.");
        }

        virtual BOOL IsScalarMarshaler() const
        {
            return TRUE;
        }

        virtual UINT32 NativeSize()
        {
            return sizeof(CURRENCY);
        }

        virtual UINT32 AlignmentRequirement()
        {
            return sizeof(CURRENCY);
        }


        virtual VOID ScalarUpdateNative(const VOID *pComPlus, LPVOID pNative) const;
        virtual VOID ScalarUpdateComPlus(const VOID *pNative, LPVOID pComPlus) const;

        Class GetClass() const { return CLASS_CURRENCY; }
        FieldMarshaler_Currency(Module *pModule) : FieldMarshaler(pModule) {}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\objecthandle.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Wraps handle table to implement various handle types (Strong, Weak, etc.)
 *
 * francish
 */

#ifndef _OBJECTHANDLE_H
#define _OBJECTHANDLE_H


/*
 * include handle manager declarations
 */
#include "HandleTable.h"


/*
 * Convenience macros for accessing handles.  StoreFirstObjectInHandle is like
 * StoreObjectInHandle, except it only succeeds if transitioning from NULL to
 * non-NULL.  In other words, if this handle is being initialized for the first
 * time.
 */
#define ObjectFromHandle(handle)                   HndFetchHandle(handle)
#define StoreObjectInHandle(handle, object)        HndAssignHandle(handle, object)
#define InterlockedCompareExchangeObjectInHandle(handle, object, oldObj)        HndInterlockedCompareExchangeHandle(handle, object, oldObj)
#define StoreFirstObjectInHandle(handle, object)   HndFirstAssignHandle(handle, object)
#define ObjectHandleIsNull(handle)                 HndIsNull(handle)
#define IsHandleNullUnchecked(pHandle)             HndCheckForNullUnchecked(pHandle)


/*
 * HANDLES
 *
 * The default type of handle is a strong handle.
 *
 */
#define HNDTYPE_DEFAULT                         HNDTYPE_STRONG


/*
 * WEAK HANDLES
 *
 * Weak handles are handles that track an object as long as it is alive,
 * but do not keep the object alive if there are no strong references to it.
 *
 * The default type of weak handle is 'long-lived' weak handle.
 *
 */
#define HNDTYPE_WEAK_DEFAULT                    HNDTYPE_WEAK_LONG


/*
 * SHORT-LIVED WEAK HANDLES
 *
 * Short-lived weak handles are weak handles that track an object until the
 * first time it is detected to be unreachable.  At this point, the handle is
 * severed, even if the object will be visible from a pending finalization
 * graph.  This further implies that short weak handles do not track
 * across object resurrections.
 *
 */
#define HNDTYPE_WEAK_SHORT                      (0)


/*
 * LONG-LIVED WEAK HANDLES
 *
 * Long-lived weak handles are weak handles that track an object until the
 * object is actually reclaimed.  Unlike short weak handles, long weak handles
 * continue to track their referents through finalization and across any
 * resurrections that may occur.
 *
 */
#define HNDTYPE_WEAK_LONG                       (1)


/*
 * STRONG HANDLES
 *
 * Strong handles are handles which function like a normal object reference.
 * The existence of a strong handle for an object will cause the object to
 * be promoted (remain alive) through a garbage collection cycle.
 *
 */
#define HNDTYPE_STRONG                          (2)


/*
 * PINNED HANDLES
 *
 * Pinned handles are strong handles which have the added property that they
 * prevent an object from moving during a garbage collection cycle.  This is
 * useful when passing a pointer to object innards out of the runtime while GC
 * may be enabled.
 *
 * NOTE:  PINNING AN OBJECT IS EXPENSIVE AS IT PREVENTS THE GC FROM ACHIEVING
 *        OPTIMAL PACKING OF OBJECTS DURING EPHEMERAL COLLECTIONS.  THIS TYPE
 *        OF HANDLE SHOULD BE USED SPARINGLY!
 */
#define HNDTYPE_PINNED                          (3)


/*
 * VARIABLE HANDLES
 *
 * Variable handles are handles whose type can be changed dynamically.  They
 * are larger than other types of handles, and are scanned a little more often,
 * but are useful when the handle owner needs an efficient way to change the
 * strength of a handle on the fly.
 * 
 */
#define HNDTYPE_VARIABLE                        (4)


/*
 * REFCOUNTED HANDLES
 *
 * Refcounted handles are handles that behave as strong handles while the
 * refcount on them is greater than 0 and behave as weak handles otherwise.
 *
 * N.B. These are currently NOT general purpose.
 *      The implementation is tied to COM Interop.
 *
 */
#define HNDTYPE_REFCOUNTED                      (5)


/*
 * Global Handle Table - these handles may only reference domain agile objects
 */
extern HHANDLETABLE g_hGlobalHandleTable;


/*
 * Type mask definitions for HNDTYPE_VARIABLE handles.
 */
#define VHT_WEAK_SHORT              (0x00000100)  // avoid using low byte so we don't overlap normal types
#define VHT_WEAK_LONG               (0x00000200)  // avoid using low byte so we don't overlap normal types
#define VHT_STRONG                  (0x00000400)  // avoid using low byte so we don't overlap normal types
#define VHT_PINNED                  (0x00000800)  // avoid using low byte so we don't overlap normal types

#define IS_VALID_VHT_VALUE(flag)   ((flag == VHT_WEAK_SHORT) || \
                                    (flag == VHT_WEAK_LONG)  || \
                                    (flag == VHT_STRONG)     || \
                                    (flag == VHT_PINNED))


/*
 * Convenience macros and prototypes for the various handle types we define
 */

inline OBJECTHANDLE CreateTypedHandle(HHANDLETABLE table, OBJECTREF object, int type)
{ 
    return HndCreateHandle(table, type, object); 
}

inline void DestroyTypedHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandleOfUnknownType(HndGetHandleTable(handle), handle);
}

inline OBJECTHANDLE CreateHandle(HHANDLETABLE table, OBJECTREF object)
{ 
    return HndCreateHandle(table, HNDTYPE_DEFAULT, object); 
}

inline void DestroyHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(HndGetHandleTable(handle), HNDTYPE_DEFAULT, handle);
}

inline OBJECTHANDLE CreateDuplicateHandle(OBJECTHANDLE handle) {
    // Create a new STRONG handle in the same table as an existing handle.  
    return HndCreateHandle(HndGetHandleTable(handle), HNDTYPE_DEFAULT, ObjectFromHandle(handle));
}


inline OBJECTHANDLE CreateWeakHandle(HHANDLETABLE table, OBJECTREF object)
{ 
    return HndCreateHandle(table, HNDTYPE_WEAK_DEFAULT, object); 
}

inline void DestroyWeakHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(HndGetHandleTable(handle), HNDTYPE_WEAK_DEFAULT, handle);
}

inline OBJECTHANDLE CreateShortWeakHandle(HHANDLETABLE table, OBJECTREF object)
{ 
    return HndCreateHandle(table, HNDTYPE_WEAK_SHORT, object); 
}

inline void DestroyShortWeakHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(HndGetHandleTable(handle), HNDTYPE_WEAK_SHORT, handle);
}


inline OBJECTHANDLE CreateLongWeakHandle(HHANDLETABLE table, OBJECTREF object)
{ 
    return HndCreateHandle(table, HNDTYPE_WEAK_LONG, object); 
}

inline void DestroyLongWeakHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(HndGetHandleTable(handle), HNDTYPE_WEAK_LONG, handle);
}

inline OBJECTHANDLE CreateStrongHandle(HHANDLETABLE table, OBJECTREF object)
{ 
    return HndCreateHandle(table, HNDTYPE_STRONG, object); 
}

inline void DestroyStrongHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(HndGetHandleTable(handle), HNDTYPE_STRONG, handle);
}

inline OBJECTHANDLE CreatePinningHandle(HHANDLETABLE table, OBJECTREF object)
{ 
    return HndCreateHandle(table, HNDTYPE_PINNED, object); 
}

inline void DestroyPinningHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(HndGetHandleTable(handle), HNDTYPE_PINNED, handle);
}

inline OBJECTHANDLE CreateRefcountedHandle(HHANDLETABLE table, OBJECTREF object)
{ 
    return HndCreateHandle(table, HNDTYPE_REFCOUNTED, object); 
}

inline void DestroyRefcountedHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(HndGetHandleTable(handle), HNDTYPE_REFCOUNTED, handle);
}

OBJECTHANDLE CreateVariableHandle(HHANDLETABLE hTable, OBJECTREF object, UINT type);
void         UpdateVariableHandleType(OBJECTHANDLE handle, UINT type);

inline void  DestroyVariableHandle(OBJECTHANDLE handle)
{
    HndDestroyHandle(HndGetHandleTable(handle), HNDTYPE_VARIABLE, handle);
}


/*
 * Convenience prototypes for using the global handles
 */

inline OBJECTHANDLE CreateGlobalTypedHandle(OBJECTREF object, int type)
{ 
    return HndCreateHandle(g_hGlobalHandleTable, type, object); 
}

inline void DestroyGlobalTypedHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandleOfUnknownType(g_hGlobalHandleTable, handle);
}

inline OBJECTHANDLE CreateGlobalHandle(OBJECTREF object)
{ 
    return HndCreateHandle(g_hGlobalHandleTable, HNDTYPE_DEFAULT, object); 
}

inline void DestroyGlobalHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(g_hGlobalHandleTable, HNDTYPE_DEFAULT, handle);
}

inline OBJECTHANDLE CreateGlobalWeakHandle(OBJECTREF object)
{ 
    return HndCreateHandle(g_hGlobalHandleTable, HNDTYPE_WEAK_DEFAULT, object); 
}

inline void DestroyGlobalWeakHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(g_hGlobalHandleTable, HNDTYPE_WEAK_DEFAULT, handle);
}

inline OBJECTHANDLE CreateGlobalShortWeakHandle(OBJECTREF object)
{ 
    return HndCreateHandle(g_hGlobalHandleTable, HNDTYPE_WEAK_SHORT, object); 
}

inline void DestroyGlobalShortWeakHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(g_hGlobalHandleTable, HNDTYPE_WEAK_SHORT, handle);
}

inline OBJECTHANDLE CreateGlobalLongWeakHandle(OBJECTREF object)
{ 
    return HndCreateHandle(g_hGlobalHandleTable, HNDTYPE_WEAK_LONG, object); 
}

inline void DestroyGlobalLongWeakHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(g_hGlobalHandleTable, HNDTYPE_WEAK_LONG, handle);
}

inline OBJECTHANDLE CreateGlobalStrongHandle(OBJECTREF object)
{ 
    return HndCreateHandle(g_hGlobalHandleTable, HNDTYPE_STRONG, object); 
}

inline void DestroyGlobalStrongHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(g_hGlobalHandleTable, HNDTYPE_STRONG, handle);
}

inline OBJECTHANDLE CreateGlobalPinningHandle(OBJECTREF object)
{ 
    return HndCreateHandle(g_hGlobalHandleTable, HNDTYPE_PINNED, object); 
}

inline void DestroyGlobalPinningHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(g_hGlobalHandleTable, HNDTYPE_PINNED, handle);
}

inline OBJECTHANDLE CreateGlobalRefcountedHandle(OBJECTREF object)
{ 
    return HndCreateHandle(g_hGlobalHandleTable, HNDTYPE_REFCOUNTED, object); 
}

inline void DestroyGlobalRefcountedHandle(OBJECTHANDLE handle)
{ 
    HndDestroyHandle(g_hGlobalHandleTable, HNDTYPE_REFCOUNTED, handle);
}


/*
 * Table maintenance routines
 */
BOOL Ref_Initialize();
void Ref_Shutdown();
HHANDLETABLE Ref_CreateHandleTable(UINT uADIndex);
void Ref_RemoveHandleTable(HHANDLETABLE hTable);
void Ref_DestroyHandleTable(HHANDLETABLE table);

/*
 * GC-time scanning entrypoints
 */
void Ref_BeginSynchronousGC   (UINT uCondemnedGeneration, UINT uMaxGeneration);
void Ref_EndSynchronousGC     (UINT uCondemnedGeneration, UINT uMaxGeneration);

void Ref_TracePinningRoots    (UINT uCondemnedGeneration, UINT uMaxGeneration, LPARAM lp1);
void Ref_TraceNormalRoots     (UINT uCondemnedGeneration, UINT uMaxGeneration, LPARAM lp1);
void Ref_CheckReachable       (UINT uCondemnedGeneration, UINT uMaxGeneration, LPARAM lp1);
void Ref_CheckAlive           (UINT uCondemnedGeneration, UINT uMaxGeneration, LPARAM lp1);
void Ref_UpdatePointers       (UINT uCondemnedGeneration, UINT uMaxGeneration, LPARAM lp1);
void Ref_ScanPointersForProfiler(UINT uMaxGeneration, LPARAM lp1);
void Ref_UpdatePinnedPointers (UINT uCondemnedGeneration, UINT uMaxGeneration, LPARAM lp1);
void Ref_AgeHandles           (UINT uCondemnedGeneration, UINT uMaxGeneration, LPARAM lp1);
void Ref_RejuvenateHandles();


#endif //_OBJECTHANDLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\objecthandle.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Wraps handle table to implement various handle types (Strong, Weak, etc.)
 *
 * francish
 */

#include "common.h"
#include "vars.hpp"
#include "object.h"
#include "log.h"
#include "eeconfig.h"
#include "gc.h"
#include "nstruct.h"

#include "comcallwrapper.h"

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))

#include "ObjectHandle.h"


//----------------------------------------------------------------------------

/*
 * struct VARSCANINFO
 *
 * used when tracing variable-strength handles.
 */
struct VARSCANINFO
{
    LPARAM         lEnableMask; // mask of types to trace
    HANDLESCANPROC pfnTrace;    // tracing function to use
};


//----------------------------------------------------------------------------

/*
 * Scan callback for tracing variable-strength handles.
 *
 * This callback is called to trace individual objects referred to by handles
 * in the variable-strength table.
 */
void CALLBACK VariableTraceDispatcher(_UNCHECKED_OBJECTREF *pObjRef, LPARAM *pExtraInfo, LPARAM lp1, LPARAM lp2)
{
    // lp2 is a pointer to our VARSCANINFO
    struct VARSCANINFO *pInfo = (struct VARSCANINFO *)lp2;

    // is the handle's dynamic type one we're currently scanning?
    if ((*pExtraInfo & pInfo->lEnableMask) != 0)
    {
        // yes - call the tracing function for this handle
        pInfo->pfnTrace(pObjRef, NULL, lp1, 0);
    }
}


/*
 * Scan callback for tracing ref-counted handles.
 *
 * This callback is called to trace individual objects referred to by handles
 * in the refcounted table.
 */
void CALLBACK PromoteRefCounted(_UNCHECKED_OBJECTREF *pObjRef, LPARAM *pExtraInfo, LPARAM lp1, LPARAM lp2)
{
    LOG((LF_GC, LL_INFO1000, "Handle %08X causes promotion of object %08x\n", pObjRef, *pObjRef));

    Object **pRef = (Object **)pObjRef;
    if (*pRef && !GCHeap::IsPromoted(*pRef, (ScanContext *)lp1))
    {
        //@todo optimize the access to the ref-count
        ComCallWrapper* pWrap = ComCallWrapper::GetWrapperForObject((OBJECTREF)*pRef);
        if (pWrap == NULL)
        {
            // There is a potential race with ReconnectWrapper() which NULLs out the CCW on an object
            // and transfers it to a new object. If we get dereference the handle to get the old
            // object, ReconnectWrapper can NULL out the CCW underneath us. So we have this check
            // for a NULL CCW.
            // This is only possible during the concurrent scan. Since we will do a non-concurrent
            // scan again when all threads are synchronized, its OK to not report *pRef
            _ASSERTE(((ScanContext*) lp1)->concurrent);
            return;
        }

        BOOL fIsActive = ComCallWrapper::IsWrapperActive(pWrap);
        if (fIsActive)
            GCHeap::Promote(*pRef, (ScanContext *)lp1);
    }
}


/*
 * Scan callback for pinning handles.
 *
 * This callback is called to pin individual objects referred to by handles in
 * the pinning table.
 */
void CALLBACK PinObject(_UNCHECKED_OBJECTREF *pObjRef, LPARAM *pExtraInfo, LPARAM lp1, LPARAM lp2)
{
    // PINNING IS EVIL - DON'T DO IT IF YOU CAN AVOID IT
    LOG((LF_ALL, LL_WARNING, "WARNING: Handle %08X causes pinning of object %08x\n", pObjRef, *pObjRef));

    Object **pRef = (Object **)pObjRef;
    GCHeap::Promote(*pRef, (ScanContext *)lp1, GC_CALL_PINNED);
}


/*
 * Scan callback for tracing strong handles.
 *
 * This callback is called to trace individual objects referred to by handles
 * in the strong table.
 */
void CALLBACK PromoteObject(_UNCHECKED_OBJECTREF *pObjRef, LPARAM *pExtraInfo, LPARAM lp1, LPARAM lp2)
{
    LOG((LF_GC, LL_INFO1000, "Handle %08X causes promotion of object %08x\n", pObjRef, *pObjRef));

    Object **pRef = (Object **)pObjRef;
    GCHeap::Promote(*pRef, (ScanContext *)lp1);
}


/*
 * Scan callback for disconnecting dead handles.
 *
 * This callback is called to check promotion of individual objects referred to by
 * handles in the weak tables.
 */
void CALLBACK CheckPromoted(_UNCHECKED_OBJECTREF *pObjRef, LPARAM *pExtraInfo, LPARAM lp1, LPARAM lp2)
{
    LOG((LF_GC, LL_INFO100000, "Checking referent of weak handle %08X (%08x) for reachability\n", pObjRef, *pObjRef));

    Object **pRef = (Object **)pObjRef;
    if (!GCHeap::IsPromoted(*pRef, (ScanContext *)lp1))
    {
        LOG((LF_GC, LL_INFO100, "Severing weak handle %08X as object %08x has become unreachable\n", pObjRef, *pObjRef));

        *pRef = NULL;
    }
    else
    {
        LOG((LF_GC, LL_INFO100, "object %08x reachable\n", *pObjRef));
    }
}


/*
 * Scan callback for updating pointers.
 *
 * This callback is called to update pointers for individual objects referred to by
 * handles in the weak and strong tables.
 */
void CALLBACK UpdatePointer(_UNCHECKED_OBJECTREF *pObjRef, LPARAM *pExtraInfo, LPARAM lp1, LPARAM lp2)
{
    LOG((LF_GC, LL_INFO100000, "Querying for new location of object %08x (hnd=%08X)\n", *pObjRef, pObjRef));

    Object **pRef = (Object **)pObjRef;

#ifdef _DEBUG
    Object *pOldLocation = *pRef;
#endif

    GCHeap::Relocate(*pRef, (ScanContext *)lp1);

#ifdef _DEBUG
    if (pOldLocation != *pObjRef)
        LOG((LF_GC, LL_INFO10000, "Updating handle %08X object pointer from %08x to %08x\n", pObjRef, *pOldLocation, *pObjRef));
    else
        LOG((LF_GC, LL_INFO100000, "Updating handle %08X - object %08x did not move\n", pObjRef, *pObjRef));
#endif
}


#ifdef GC_PROFILING
/*
 * Scan callback for updating pointers.
 *
 * This callback is called to update pointers for individual objects referred to by
 * handles in the weak and strong tables.
 */
void CALLBACK ScanPointerForProfiler(_UNCHECKED_OBJECTREF *pObjRef, LPARAM *pExtraInfo, LPARAM lp1, LPARAM lp2)
{
    LOG((LF_GC | LF_CORPROF, LL_INFO100000, "Notifying profiler of object %08x (hnd=%08X)\n", *pObjRef, pObjRef));

    // Get the baseobject (which can subsequently be cast into an OBJECTREF == ObjectID
    Object **pRef = (Object **)pObjRef;

    // Get a hold of the heap ID that's tacked onto the end of the scancontext struct.
    ProfilingScanContext *pSC = (ProfilingScanContext *)lp1;

    // Give the profiler the objectref.
    g_profControlBlock.pProfInterface->RootReference((ObjectID)*pRef, &pSC->pHeapId);
}
#endif // GC_PROFILING


/*
 * Scan callback for updating pointers.
 *
 * This callback is called to update pointers for individual objects referred to by
 * handles in the pinned table.
 */
void CALLBACK UpdatePointerPinned(_UNCHECKED_OBJECTREF *pObjRef, LPARAM *pExtraInfo, LPARAM lp1, LPARAM lp2)
{
    Object **pRef = (Object **)pObjRef;

    GCHeap::Relocate(*pRef, (ScanContext *)lp1, GC_CALL_PINNED);

    LOG((LF_GC, LL_INFO100000, "Updating handle %08X - object %08x did not move\n", pObjRef, *pObjRef));
}


//----------------------------------------------------------------------------

HHANDLETABLE    g_hGlobalHandleTable = NULL;

/* 
 * The definition of this structure *must* be kept up to date with the
 * definition in dump-tables.cpp.
 */
struct HandleTableMap
{
    HHANDLETABLE            *pTable;
    struct HandleTableMap   *pNext;
    DWORD                    dwMaxIndex;
};

HandleTableMap g_HandleTableMap = {NULL,0,0};

#define INITIAL_HANDLE_TABLE_ARRAY_SIZE 10

// flags describing the handle types
static UINT s_rgTypeFlags[] =
{
    HNDF_NORMAL,    // HNDTYPE_WEAK_SHORT
    HNDF_NORMAL,    // HNDTYPE_WEAK_LONG
    HNDF_NORMAL,    // HNDTYPE_STRONG
    HNDF_NORMAL,    // HNDTYPE_PINNED
    HNDF_EXTRAINFO, // HNDTYPE_VARIABLE
    HNDF_NORMAL,    // HNDTYPE_REFCOUNTED
};

BOOL Ref_Initialize()
{
    // sanity
    _ASSERTE(g_hGlobalHandleTable == NULL);

    // Create an array to hold the handle tables
    HHANDLETABLE *pTable = new HHANDLETABLE [ INITIAL_HANDLE_TABLE_ARRAY_SIZE ];
    if (pTable == NULL) {
        return FALSE;
    }
    ZeroMemory(pTable,
               INITIAL_HANDLE_TABLE_ARRAY_SIZE * sizeof (HHANDLETABLE));
    g_HandleTableMap.pTable = pTable;
    g_HandleTableMap.dwMaxIndex = INITIAL_HANDLE_TABLE_ARRAY_SIZE;
    g_HandleTableMap.pNext = NULL;

    // create the handle table
    g_hGlobalHandleTable = HndCreateHandleTable(s_rgTypeFlags, ARRAYSIZE(s_rgTypeFlags), 0);
    if (!g_hGlobalHandleTable) 
        FailFast(GetThread(), FatalOutOfMemory);
    HndSetHandleTableIndex(g_hGlobalHandleTable, 0);
    g_HandleTableMap.pTable[0] = g_hGlobalHandleTable;
      
    // return true if we successfully created a table
    return (g_hGlobalHandleTable != NULL);
}

void Ref_Shutdown()
{
    // are there any handle tables?
    if (g_hGlobalHandleTable)
    {
        // don't destroy any of the indexed handle tables; they should
        // be destroyed externally.

        // destroy the global handle table 
        HndDestroyHandleTable(g_hGlobalHandleTable);

        // destroy the handle table array
        HandleTableMap *walk = &g_HandleTableMap;
        while (walk) {
            delete [] walk->pTable;
            walk = walk->pNext;
        }

        // null out the handle table array
        g_HandleTableMap.pNext = NULL;
        g_HandleTableMap.dwMaxIndex = 0;

        // null out the global table handle
        g_hGlobalHandleTable = NULL;
    }
}

HHANDLETABLE Ref_CreateHandleTable(UINT uADIndex)
{
    HHANDLETABLE result = NULL;
    HandleTableMap *walk;
    
    walk = &g_HandleTableMap;
    HandleTableMap *last = NULL;
    UINT offset = 0;
    
    result = HndCreateHandleTable(s_rgTypeFlags, ARRAYSIZE(s_rgTypeFlags), uADIndex);
    if (!result) 
      FailFast(GetThread(), FatalOutOfMemory);

retry:
    // Do we have free slot
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            if (walk->pTable[i] == 0) {
                HndSetHandleTableIndex(result, i+offset);
                if (FastInterlockCompareExchange((void**)&walk->pTable[i], (void*)result, 0) == 0) {
                    // Get a free slot.
                    return result;
                }
            }
        }
        last = walk;
        offset = walk->dwMaxIndex;
        walk = walk->pNext;
    }

    // No free slot.
    // Let's create a new node
    HandleTableMap *newMap = new (nothrow) HandleTableMap;
    if (newMap == NULL) {
        return NULL;
    }
    newMap->pTable = new (nothrow) HHANDLETABLE [INITIAL_HANDLE_TABLE_ARRAY_SIZE];
    if (newMap->pTable == NULL) {
        delete newMap;
        return NULL;
    }
    newMap->dwMaxIndex = last->dwMaxIndex + INITIAL_HANDLE_TABLE_ARRAY_SIZE;
    newMap->pNext = NULL;
    ZeroMemory (newMap->pTable,INITIAL_HANDLE_TABLE_ARRAY_SIZE*sizeof(HHANDLETABLE));

    if (FastInterlockCompareExchange((void**)&last->pNext,newMap,NULL) == NULL) {
    }
    else
    {
        // This thread loses.
        delete [] newMap->pTable;
        delete newMap;
    }
    walk = last->pNext;
    offset = last->dwMaxIndex;
    goto retry;
}

void Ref_RemoveHandleTable(HHANDLETABLE hTable)
{
    UINT index = HndGetHandleTableIndex(hTable);

    if (index == -1)
        return;

    HndSetHandleTableIndex(hTable, -1);

    HandleTableMap *walk = &g_HandleTableMap;
    UINT offset = 0;

    while (walk) {
        if (index < walk->dwMaxIndex) {
            // During AppDomain unloading, we first remove a handle table and then destroy
            // the table.  As soon as the table is removed, the slot can be reused.
            if (walk->pTable[index-offset] == hTable)
                walk->pTable[index-offset] = NULL;
            return;
        }
        offset = walk->dwMaxIndex;
        walk = walk->pNext;
    }

    _ASSERTE (!"Should not reach here");
}


void Ref_DestroyHandleTable(HHANDLETABLE table)
{
    HndDestroyHandleTable(table);
}

// BUGBUG - reexpress as complete only like hndtable does now!!! -fmh
void Ref_EndSynchronousGC(UINT condemned, UINT maxgen)
{
    // tell the table we finished a GC
    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndNotifyGcCycleComplete(hTable, condemned, maxgen);
        }
        walk = walk->pNext;
    }
}


//----------------------------------------------------------------------------

/*
 * CreateVariableHandle.
 *
 * Creates a variable-strength handle.
 *
 * N.B. This routine is not a macro since we do validation in RETAIL.
 * We always validate the type here because it can come from external callers.
 */
OBJECTHANDLE CreateVariableHandle(HHANDLETABLE hTable, OBJECTREF object, UINT type)
{
    // verify that we are being asked to create a valid type
    if (!IS_VALID_VHT_VALUE(type))
    {
        // bogus value passed in
        _ASSERTE(FALSE);
        return NULL;
    }

    // create the handle
    return HndCreateHandle(hTable, HNDTYPE_VARIABLE, object, (LPARAM)type);
}


/*
 * UpdateVariableHandleType.
 *
 * Changes the dynamic type of a variable-strength handle.
 *
 * N.B. This routine is not a macro since we do validation in RETAIL.
 * We always validate the type here because it can come from external callers.
 */
void UpdateVariableHandleType(OBJECTHANDLE handle, UINT type)
{
    // verify that we are being asked to set a valid type
    if (!IS_VALID_VHT_VALUE(type))
    {
        // bogus value passed in
        _ASSERTE(FALSE);
        return;
    }

    // BUGBUG (francish)  CONCURRENT GC NOTE
    //
    // If/when concurrent GC is implemented, we need to make sure variable handles
    // DON'T change type during an asynchronous scan, OR that we properly recover
    // from the change.  Some changes are benign, but for example changing to or
    // from a pinning handle in the middle of a scan would not be fun.
    //

    // store the type in the handle's extra info
    HndSetHandleExtraInfo(handle, HNDTYPE_VARIABLE, (LPARAM)type);
}


/*
 * TraceVariableHandles.
 *
 * Convenience function for tracing variable-strength handles.
 * Wraps HndScanHandlesForGC.
 */
void TraceVariableHandles(HANDLESCANPROC pfnTrace, LPARAM lp1, UINT uEnableMask, UINT condemned, UINT maxgen, UINT flags)
{
    // set up to scan variable handles with the specified mask and trace function
    UINT               type = HNDTYPE_VARIABLE;
    struct VARSCANINFO info = { (LPARAM)uEnableMask, pfnTrace };

    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndScanHandlesForGC(hTable, VariableTraceDispatcher,
                                    lp1, (LPARAM)&info, &type, 1, condemned, maxgen, HNDGCF_EXTRAINFO | flags);
        }
        walk = walk->pNext;
    }
}


//----------------------------------------------------------------------------

void Ref_TracePinningRoots(UINT condemned, UINT maxgen, LPARAM lp1)
{
    LOG((LF_GC, LL_INFO10000, "Pinning referents of pinned handles in generation %u\n", condemned));

    // pin objects pointed to by pinning handles
    UINT type = HNDTYPE_PINNED;
    UINT flags = (((ScanContext*) lp1)->concurrent) ? HNDGCF_ASYNC : HNDGCF_NORMAL;

    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndScanHandlesForGC(hTable, PinObject, lp1, 0, &type, 1, condemned, maxgen, flags);
        }
        walk = walk->pNext;
    }

    // pin objects pointed to by variable handles whose dynamic type is VHT_PINNED
    TraceVariableHandles(PinObject, lp1, VHT_PINNED, condemned, maxgen, flags);
}


void Ref_TraceNormalRoots(UINT condemned, UINT maxgen, LPARAM lp1)
{
    LOG((LF_GC, LL_INFO10000, "Promoting referents of strong handles in generation %u\n", condemned));

    // promote objects pointed to by strong handles
    UINT type = HNDTYPE_STRONG;
    UINT flags = (((ScanContext*) lp1)->concurrent) ? HNDGCF_ASYNC : HNDGCF_NORMAL;

    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndScanHandlesForGC(hTable, PromoteObject, lp1, 0, &type, 1, condemned, maxgen, flags);
        }
        walk = walk->pNext;
    }

    // promote objects pointed to by variable handles whose dynamic type is VHT_STRONG
    TraceVariableHandles(PromoteObject, lp1, VHT_STRONG, condemned, maxgen, flags);
    
    // promote ref-counted handles
    type = HNDTYPE_REFCOUNTED;

    walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndScanHandlesForGC(hTable, PromoteRefCounted, lp1, 0, &type, 1, condemned, maxgen, flags );
        }
        walk = walk->pNext;
    }
}


void Ref_CheckReachable(UINT condemned, UINT maxgen, LPARAM lp1)
{
    LOG((LF_GC, LL_INFO10000, "Checking reachability of referents of long-weak handles in generation %u\n", condemned));

    // these are the handle types that need to be checked
    UINT types[] =
    {
        HNDTYPE_WEAK_LONG,
        HNDTYPE_REFCOUNTED
    };

    // check objects pointed to by short weak handles
    UINT flags = (((ScanContext*) lp1)->concurrent) ? HNDGCF_ASYNC : HNDGCF_NORMAL;

    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndScanHandlesForGC(hTable, CheckPromoted, lp1, 0, types, ARRAYSIZE(types), condemned, maxgen, flags);
        }
        walk = walk->pNext;
    }

    // check objects pointed to by variable handles whose dynamic type is VHT_WEAK_LONG
    TraceVariableHandles(CheckPromoted, lp1, VHT_WEAK_LONG, condemned, maxgen, flags);

    // For now, treat the syncblock as if it were short weak handles.  Later, get
    // the benefits of fast allocation / free & generational awareness by supporting
    // the SyncTable as a new block type.
    // @TODO cwb: wait for compelling performance measurements.
    SyncBlockCache::GetSyncBlockCache()->GCWeakPtrScan(&CheckPromoted, lp1, 0);
}


void Ref_CheckAlive(UINT condemned, UINT maxgen, LPARAM lp1)
{
    LOG((LF_GC, LL_INFO10000, "Checking liveness of referents of short-weak handles in generation %u\n", condemned));

    // perform a multi-type scan that checks for unreachable objects
    UINT type = HNDTYPE_WEAK_SHORT;
    UINT flags = (((ScanContext*) lp1)->concurrent) ? HNDGCF_ASYNC : HNDGCF_NORMAL;

    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndScanHandlesForGC(hTable, CheckPromoted, lp1, 0, &type, 1, condemned, maxgen, flags);
        }
        walk = walk->pNext;
    }

    // check objects pointed to by variable handles whose dynamic type is VHT_WEAK_SHORT
    TraceVariableHandles(CheckPromoted, lp1, VHT_WEAK_SHORT, condemned, maxgen, flags);
}


// NTOE: Please: if you update this function, update the very similar profiling function immediately below!!!
void Ref_UpdatePointers(UINT condemned, UINT maxgen, LPARAM lp1)
{
    // For now, treat the syncblock as if it were short weak handles.  Later, get
    // the benefits of fast allocation / free & generational awareness by supporting
    // the SyncTable as a new block type.
    // @TODO cwb: wait for compelling performance measurements.
    SyncBlockCache::GetSyncBlockCache()->GCWeakPtrScan(&UpdatePointer, lp1, 0);

    LOG((LF_GC, LL_INFO10000, "Updating pointers to referents of non-pinning handles in generation %u\n", condemned));

    // these are the handle types that need their pointers updated
    UINT types[] =
    {
        HNDTYPE_WEAK_SHORT,
        HNDTYPE_WEAK_LONG,
        HNDTYPE_STRONG,
        HNDTYPE_REFCOUNTED
    };

    // perform a multi-type scan that updates pointers
    UINT flags = (((ScanContext*) lp1)->concurrent) ? HNDGCF_ASYNC : HNDGCF_NORMAL;

    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndScanHandlesForGC(hTable, UpdatePointer, lp1, 0, types, ARRAYSIZE(types), condemned, maxgen, flags);
        }
        walk = walk->pNext;
    }

    // update pointers in variable handles whose dynamic type is VHT_WEAK_SHORT, VHT_WEAK_LONG or VHT_STRONG
    TraceVariableHandles(UpdatePointer, lp1, VHT_WEAK_SHORT | VHT_WEAK_LONG | VHT_STRONG, condemned, maxgen, flags);
}

#ifdef PROFILING_SUPPORTED
// Please update this if you change the Ref_UpdatePointers function above.
void Ref_ScanPointersForProfiler(UINT maxgen, LPARAM lp1)
{
    LOG((LF_GC | LF_CORPROF, LL_INFO10000, "Scanning all roots for profiler.\n"));

    // Don't scan the sync block because they should not be reported. They are weak handles only

    // @todo jenh: we should change the following to not report weak either
    // these are the handle types that need their pointers updated
    UINT types[] =
    {
        HNDTYPE_WEAK_SHORT,
        HNDTYPE_WEAK_LONG,
        HNDTYPE_STRONG,
        HNDTYPE_REFCOUNTED,
        HNDTYPE_PINNED//,
//        HNDTYPE_VARIABLE
    };

    UINT flags = HNDGCF_NORMAL;

    // perform a multi-type scan that updates pointers
    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndScanHandlesForGC(hTable, &ScanPointerForProfiler, lp1, 0, types, ARRAYSIZE(types), maxgen, maxgen, flags);
        }
        walk = walk->pNext;
    }

    // update pointers in variable handles whose dynamic type is VHT_WEAK_SHORT, VHT_WEAK_LONG or VHT_STRONG
    TraceVariableHandles(&ScanPointerForProfiler, lp1, VHT_WEAK_SHORT | VHT_WEAK_LONG | VHT_STRONG, maxgen, maxgen, flags);
}
#endif // PROFILING_SUPPORTED

void Ref_UpdatePinnedPointers(UINT condemned, UINT maxgen, LPARAM lp1)
{
    LOG((LF_GC, LL_INFO10000, "Updating pointers to referents of pinning handles in generation %u\n", condemned));

    // these are the handle types that need their pointers updated
    UINT type = HNDTYPE_PINNED;
    UINT flags = (((ScanContext*) lp1)->concurrent) ? HNDGCF_ASYNC : HNDGCF_NORMAL;

    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndScanHandlesForGC(hTable, UpdatePointerPinned, lp1, 0, &type, 1, condemned, maxgen, flags); 
        }
        walk = walk->pNext;
    }

    // update pointers in variable handles whose dynamic type is VHT_PINNED
    TraceVariableHandles(UpdatePointerPinned, lp1, VHT_PINNED, condemned, maxgen, flags);
}


void Ref_AgeHandles(UINT condemned, UINT maxgen, LPARAM lp1)
{
    LOG((LF_GC, LL_INFO10000, "Aging handles in generation %u\n", condemned));

    // these are the handle types that need their ages updated
    UINT types[] =
    {
        HNDTYPE_WEAK_SHORT,
        HNDTYPE_WEAK_LONG,

        HNDTYPE_STRONG,

        HNDTYPE_PINNED,
        HNDTYPE_VARIABLE,
        HNDTYPE_REFCOUNTED
    };

    // perform a multi-type scan that ages the handles
    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndScanHandlesForGC(hTable, NULL, 0, 0, types, ARRAYSIZE(types), condemned, maxgen, HNDGCF_AGE);
        }
        walk = walk->pNext;
    }
}


void Ref_RejuvenateHandles()
{
    LOG((LF_GC, LL_INFO10000, "Rejuvenating handles.\n"));

    // these are the handle types that need their ages updated
    UINT types[] =
    {
        HNDTYPE_WEAK_SHORT,
        HNDTYPE_WEAK_LONG,


        HNDTYPE_STRONG,

        HNDTYPE_PINNED,
        HNDTYPE_VARIABLE,
        HNDTYPE_REFCOUNTED
    };

    // reset the ages of these handles
    HandleTableMap *walk = &g_HandleTableMap;
    while (walk) {
        for (UINT i = 0; i < INITIAL_HANDLE_TABLE_ARRAY_SIZE; i ++) {
            HHANDLETABLE hTable = walk->pTable[i];
            if (hTable)
                HndResetAgeMap(hTable, types, ARRAYSIZE(types), HNDGCF_NORMAL);
        }
        walk = walk->pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\objecthandlenative.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  ObjectHandle.cpp
**
** Purpose: Implements ObjectHandle (loader domain) architecture
**
** Date:  January 31, 2000
**
===========================================================*/

#include "common.h"

#include <stdlib.h>

#include "ObjectHandleNative.hpp"
#include "excep.h"

void __stdcall ObjectHandleNative::SetDomainOnObject(SetDomainOnObjectArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if(args->obj == NULL) {
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");
    }

    Thread* pThread = GetThread();
    AppDomain* pDomain = pThread->GetDomain();
    args->obj->SetAppDomain(pDomain);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\orefcache.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------------
// ObjectRefCache
//
// Implementation of handle table for write-once object references
//
//%%Created by: rajak
//---------------------------------------------------------------------------------

#include "common.h"
#include "object.h"
#include "cachelinealloc.h"
#include "orefcache.h"

ObjectRefCache* ObjectRefCache::s_pRefCache = NULL;

BOOL ObjectRefCache::Init()
{
    s_pRefCache = new ObjectRefCache();
    return s_pRefCache != NULL;
}

#ifdef SHOULD_WE_CLEANUP
void ObjectRefCache::Terminate()
{
 //@todo
    if (s_pRefCache != NULL)
    {
        delete s_pRefCache;
        s_pRefCache = NULL;
    }
}
#endif /* SHOULD_WE_CLEANUP */

ObjectRefCache::~ObjectRefCache()
{
    RefBlock* pBlock = NULL;
    while((pBlock = s_pRefCache->m_refBlockList.RemoveHead()) != NULL)
    {
        delete pBlock;
    }
}
// inline call
OBJECTREF* ObjectRefCache::GetObjectRefPtr(OBJECTREF objref)
{
    OBJECTREF* pRef = NULL;
    int slot = 0;
    int i;
    //@todo lock
    RefBlock* pBlock = m_refBlockList.GetHead();
    // if the head is not null 
    if (!pBlock)
    {
        goto LNew;
    }
    for(i =0; i < RefBlock::numRefs; i++)
    {
        if(pBlock->m_rgRefs[i] == NULL)
        {
            slot = i;
            goto LSet;
        }
    } 

LNew: // create a new block and add it to the list
    pBlock = new RefBlock();
    if (pBlock != NULL)
    {
        m_refBlockList.InsertHead(pBlock);

LSet: // found a valid slot in pBlock

        pRef = &pBlock->m_rgRefs[slot];
        pBlock->m_rgRefs[slot] = objref;
    }

    return pRef;
}

void ObjectRefCache::ReleaseObjectRef(OBJECTREF* pobjref)
{
    //@todo lock
    _ASSERTE(pobjref != NULL);
    *pobjref = NULL;
    // @todo mask to get the block and increment the free count
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\objecthandlenative.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  ObjectHandle.hpp
**
** Purpose: Implements ObjectHandle (loader domain) architecture
**
** Date:  August 10, 1999
**
===========================================================*/
#ifndef _ObjectHandle_H
#define _ObjectHandle_H

class ObjectHandleNative
{
    struct SetDomainOnObjectArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj);
    };

public:
    static void __stdcall SetDomainOnObject(SetDomainOnObjectArgs* args);

};

#endif // _ObjectHandle_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\oletls.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  File:       tls.hxx
//
//  Purpose:    manage thread local storage for OLE
//
//  Notes:      The gTlsIndex is initialized at process attach time.
//              The per-thread data is allocated in CoInitialize in
//              single-threaded apartments or on first use in
//              multi-threaded apartments.
//
//----------------------------------------------------------------------------
#ifndef _TLS_HXX_
#define _TLS_HXX_

#ifdef _IA64_
//#include <ntia64.h> // @TODO: Inclusion of this header causes redef's
#define GDT_ENTRIES 24
#endif

//+---------------------------------------------------------------------------
//
// forward declarations (in order to avoid type casting when accessing
// data members of the SOleTlsData structure).
//
//+---------------------------------------------------------------------------

class  CAptCallCtrl;                        // see callctrl.hxx
class  CSrvCallState;                       // see callctrl.hxx
class  CObjServer;                          // see sobjact.hxx
class  CSmAllocator;                        // see stg\h\smalloc.hxx
class  CMessageCall;                        // see call.hxx
class  CClientCall;                         // see call.hxx
class  CAsyncCall;                          // see call.hxx
class  CClipDataObject;                     // see ole232\clipbrd\clipdata.h
class  CSurrogatedObjectList;               // see com\inc\comsrgt.hxx
class  CCtxCall;                            // see PSTable.hxx
class  CPolicySet;                          // see PSTable.hxx
class  CObjectContext;                      // see context.hxx
class  CComApartment;                       // see aprtmnt.hxx

//+-------------------------------------------------------------------
//
//  Struct:     CallEntry
//
//  Synopsis:   Call Table Entry.
//
//+-------------------------------------------------------------------
typedef struct tagCallEntry
{
    void  *pNext;        // ptr to next entry
    void  *pvObject;     // Entry object
} CallEntry;



//+---------------------------------------------------------------------------
//
//  Enum:       OLETLSFLAGS
//
//  Synopsys:   bit values for dwFlags field of SOleTlsData. If you just want
//              to store a BOOL in TLS, use this enum and the dwFlag field.
//
//+---------------------------------------------------------------------------
typedef enum tagOLETLSFLAGS
{
    OLETLS_LOCALTID             = 0x01,   // This TID is in the current process.
    OLETLS_UUIDINITIALIZED      = 0x02,   // This Logical thread is init'd.
    OLETLS_INTHREADDETACH       = 0x04,   // This is in thread detach. Needed
                                          // due to NT's special thread detach
                                          // rules.
    OLETLS_CHANNELTHREADINITIALZED = 0x08,// This channel has been init'd
    OLETLS_WOWTHREAD            = 0x10,   // This thread is a 16-bit WOW thread.
    OLETLS_THREADUNINITIALIZING = 0x20,   // This thread is in CoUninitialize.
    OLETLS_DISABLE_OLE1DDE      = 0x40,   // This thread can't use a DDE window.
    OLETLS_APARTMENTTHREADED    = 0x80,   // This is an STA apartment thread
    OLETLS_MULTITHREADED        = 0x100,  // This is an MTA apartment thread
    OLETLS_IMPERSONATING        = 0x200,  // This thread is impersonating
    OLETLS_DISABLE_EVENTLOGGER  = 0x400,  // Prevent recursion in event logger
    OLETLS_INNEUTRALAPT         = 0x800,  // This thread is in the NTA
    OLETLS_DISPATCHTHREAD       = 0x1000, // This is a dispatch thread
    OLETLS_HOSTTHREAD           = 0x2000, // This is a host thread
    OLETLS_ALLOWCOINIT          = 0x4000, // This thread allows inits
    OLETLS_PENDINGUNINIT        = 0x8000, // This thread has pending uninit
    OLETLS_FIRSTMTAINIT         = 0x10000,// First thread to attempt an MTA init
    OLETLS_FIRSTNTAINIT         = 0x20000,// First thread to attempt an NTA init
    OLETLS_APTINITIALIZING      = 0x40000 // Apartment Object is initializing
}  OLETLSFLAGS;


//+---------------------------------------------------------------------------
//
//  Structure:  SOleTlsData
//
//  Synopsis:   structure holding per thread state needed by OLE32
//
//+---------------------------------------------------------------------------
typedef struct tagSOleTlsData
{
#if !defined(_CHICAGO_)
    // Docfile multiple allocator support
    void               *pvThreadBase;       // per thread base pointer
    CSmAllocator       *pSmAllocator;       // per thread docfile allocator
#endif
    DWORD               dwApartmentID;      // Per thread "process ID"
    DWORD               dwFlags;            // see OLETLSFLAGS above

    LONG                TlsMapIndex;        // index in the global TLSMap
    void              **ppTlsSlot;          // Back pointer to the thread tls slot
    DWORD               cComInits;          // number of per-thread inits
    DWORD               cOleInits;          // number of per-thread OLE inits

    DWORD               cCalls;             // number of outstanding calls
    CMessageCall       *pCallInfo;          // channel call info
    CAsyncCall         *pFreeAsyncCall;     // ptr to available call object for this thread.
    CClientCall        *pFreeClientCall;    // ptr to available call object for this thread.

    CObjServer         *pObjServer;         // Activation Server Object for this apartment.
    DWORD               dwTIDCaller;        // TID of current calling app
    CObjectContext     *pCurrentCtx;        // Current context
    CObjectContext     *pEmptyCtx;          // Empty context

    CObjectContext     *pNativeCtx;         // Native context
    CComApartment      *pNativeApt;         // Native apartment for the thread.
    IUnknown           *pCallContext;       // call context object
    CCtxCall           *pCtxCall;           // Context call object

    CPolicySet         *pPS;                // Policy set
    PVOID               pvPendingCallsFront;// Per Apt pending async calls
    PVOID               pvPendingCallsBack;
    CAptCallCtrl       *pCallCtrl;          // call control for RPC for this apartment

    CSrvCallState      *pTopSCS;            // top server-side callctrl state
    IMessageFilter     *pMsgFilter;         // temp storage for App MsgFilter
    HWND                hwndSTA;            // STA server window same as poxid->hServerSTA
                                            // ...needed on Win95 before oxid registration
    LONG                cORPCNestingLevel;  // call nesting level (DBG only)

    DWORD               cDebugData;         // count of bytes of debug data in call
    ULONG               cPreRegOidsAvail;   // count of server-side OIDs avail
    unsigned hyper     *pPreRegOids;        // ptr to array of pre-reg OIDs

    UUID                LogicalThreadId;    // current logical thread id

    HANDLE              hThread;            // Thread handle used for cancel
    HANDLE              hRevert;            // Token before first impersonate.
    IUnknown           *pAsyncRelease;      // Controlling unknown for async release
    // DDE data
    HWND                hwndDdeServer;      // Per thread Common DDE server

    HWND                hwndDdeClient;      // Per thread Common DDE client
    ULONG               cServeDdeObjects;   // non-zero if objects DDE should serve
    // ClassCache data
    LPVOID              pSTALSvrsFront;     // Chain of LServers registers in this thread if STA
    // upper layer data
    HWND                hwndClip;           // Clipboard window

    IDataObject         *pDataObjClip;      // Current Clipboard DataObject
    DWORD               dwClipSeqNum;       // Clipboard Sequence # for the above DataObject
    DWORD               fIsClipWrapper;     // Did we hand out the wrapper Clipboard DataObject?
    IUnknown            *punkState;         // Per thread "state" object
    // cancel data
    DWORD              cCallCancellation;   // count of CoEnableCallCancellation
    // async sends data
    DWORD              cAsyncSends;         // count of async sends outstanding

    CAsyncCall*           pAsyncCallList;   // async calls outstanding
    CSurrogatedObjectList *pSurrogateList;  // Objects in the surrogate

    LockEntry             lockEntry;        // Locks currently held by the thread
    CallEntry             CallEntry;        // client-side call chain for this thread

#ifdef WX86OLE
    IUnknown           *punkStateWx86;      // Per thread "state" object for Wx86
#endif
    void               *pDragCursors;       // Per thread drag cursor table.

#ifdef _CHICAGO_
    LPVOID              pWcstokContext;     // Scan context for wcstok
#endif

    IUnknown           *punkError;          // Per thread error object.
    ULONG               cbErrorData;        // Maximum size of error data.

#if(_WIN32_WINNT >= 0x0500)
    IUnknown           *punkActiveXSafetyProvider;
#endif //(_WIN32_WINNT >= 0x0500)

#if DBG==1
    LONG                cTraceNestingLevel; // call nesting level for OLETRACE
#endif

} SOleTlsData;



#ifndef _NTPSAPI_

#ifndef _NTDEF_
#include <subauth.h>
#endif

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;


//
// Gdi command batching
//

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
    ULONG Offset;
    ULONG HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH,*PGDI_TEB_BATCH;


//
// Wx86 thread state information
//

typedef struct _Wx86ThreadState {
    PULONG  CallBx86Eip;
    PVOID   DeallocationCpu;
    BOOLEAN UseKnownWx86Dll;
    char    OleStubInvoked;
} WX86THREAD, *PWX86THREAD;

//
//  TEB - The thread environment block
//

#define STATIC_UNICODE_BUFFER_LENGTH 261
#define WIN32_CLIENT_INFO_LENGTH 62
#define WIN32_CLIENT_INFO_SPIN_COUNT 1

typedef struct _TEB {
    NT_TIB NtTib;
    PVOID  EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    LPVOID ProcessEnvironmentBlock;
    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;          // PtiCurrent
    ULONG User32Reserved[26];       // user32.dll items
    ULONG UserReserved[5];          // Winsrv SwitchStack
    PVOID WOW32Reserved;            // used by WOW
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister; // offset known by outsiders!
#ifdef _IA64_
    ULONGLONG Gdt[GDT_ENTRIES];         // Provide Gdt table entries
    ULONGLONG GdtDescriptor;
    ULONGLONG LdtDescriptor;
    ULONGLONG FsDescriptor;
#else  // _IA64_
    PVOID SystemReserved1[54];      // Used by FP emulator
#endif // _IA64_
    NTSTATUS ExceptionCode;         // for RaiseUserException
    UCHAR SpareBytes1[44];
    GDI_TEB_BATCH GdiTebBatch;      // Gdi batching
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG Win32ClientInfo[WIN32_CLIENT_INFO_LENGTH];    // User32 Client Info
    PVOID glDispatchTable[233];     // OpenGL
    ULONG glReserved1[29];          // OpenGL
    PVOID glReserved2;              // OpenGL
    PVOID glSectionInfo;            // OpenGL
    PVOID glSection;                // OpenGL
    PVOID glTable;                  // OpenGL
    PVOID glCurrentRC;              // OpenGL
    PVOID glContext;                // OpenGL
    ULONG LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
#ifdef  _IA64_
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    PVOID DeallocationStack;
    PVOID TlsSlots[TLS_MINIMUM_AVAILABLE];
    LIST_ENTRY TlsLinks;
    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];
    ULONG HardErrorsAreDisabled;
    PVOID Instrumentation[16];
    PVOID WinSockData;              // WinSock
    ULONG GdiBatchCount;
    ULONG Spare2;
    ULONG Spare3;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    WX86THREAD Wx86Thread;
    PVOID *TlsExpansionSlots;
} TEB;
typedef TEB *PTEB;
#endif

#ifdef INITGUID
#include "initguid.h"
#endif

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_OLEGUID(IID_IStdIdentity,        0x0000001bL, 0, 0);
DEFINE_OLEGUID(IID_IStdWrapper,         0x000001caL, 0, 0);

#endif // _TLS_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\olevariant.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _H_OLEVARIANT_
#define _H_OLEVARIANT_

class COMVariant;
#include "COMVariant.h"

enum EnumWrapperTypes
{
    WrapperTypes_Dispatch,
    WrapperTypes_Unknown,
    WrapperTypes_Error,
    WrapperTypes_Currency,
    WrapperTypes_Last,
};

// The COM interop native array marshaler is built on top of VT_* types.
// The P/Invoke marshaler supports marshaling to WINBOOL's and ANSICHAR's.
// This is an annoying hack to shoehorn these non-OleAut types into
// the COM interop marshaler.
#define VTHACK_NONBLITTABLERECORD 251
#define VTHACK_BLITTABLERECORD 252
#define VTHACK_ANSICHAR        253
#define VTHACK_WINBOOL         254

class OleVariant
{
  public:

    // One-time init
    static BOOL Init();
    static VOID Terminate();

	// Variant conversion

	static void MarshalComVariantForOleVariant(VARIANT *pOle, VariantData *pCom);
	static void MarshalOleVariantForComVariant(VariantData *pCom, VARIANT *pOle);
	static void MarshalOleRefVariantForComVariant(VariantData *pCom, VARIANT *pOle);

    // New variant conversion

    static void MarshalOleVariantForObject(OBJECTREF *pObj, VARIANT *pOle);
    static void MarshalOleRefVariantForObject(OBJECTREF *pObj, VARIANT *pOle);
    static void MarshalObjectForOleVariant(const VARIANT *pOle, OBJECTREF *pObj);

    // an performance version to integate the translation and clear

    static Object* STDMETHODCALLTYPE MarshalObjectForOleVariantAndClear(VARIANT *pOle);


	// Safearray conversion

	static SAFEARRAY *
		 CreateSafeArrayDescriptorForArrayRef(BASEARRAYREF *pArrayRef, VARTYPE vt,
											  MethodTable *pInterfaceMT = NULL);
	static SAFEARRAY *CreateSafeArrayForArrayRef(BASEARRAYREF *pArrayRef, VARTYPE vt,
												 MethodTable *pInterfaceMT = NULL);

	static BASEARRAYREF CreateArrayRefForSafeArray(SAFEARRAY *pSafeArray, VARTYPE vt, 
												   MethodTable *pElementMT);

	static void MarshalSafeArrayForArrayRef(BASEARRAYREF *pArrayRef, 
											SAFEARRAY *pSafeArray,
                                            VARTYPE vt,
											MethodTable *pInterfaceMT);
	static void MarshalArrayRefForSafeArray(SAFEARRAY *pSafeArray, 
											BASEARRAYREF *pArrayRef,
                                            VARTYPE vt,
											MethodTable *pInterfaceMT);

	// Type conversion utilities
    static void ExtractContentsFromByrefVariant(VARIANT *pByrefVar, VARIANT *pDestVar);
    static void InsertContentsIntoByrefVariant(VARIANT *pSrcVar, VARIANT *pByrefVar);
    static void CreateByrefVariantForVariant(VARIANT *pSrcVar, VARIANT *pByrefVar);

	static VARTYPE GetVarTypeForComVariant(VariantData *pComVariant);
	static CVTypes GetCVTypeForVarType(VARTYPE vt);
	static VARTYPE GetVarTypeForCVType(CVTypes);
	static VARTYPE GetVarTypeForTypeHandle(TypeHandle typeHnd);

	static VARTYPE GetVarTypeForValueClassArrayName(LPCUTF8 pArrayClassName);
	static VARTYPE GetElementVarTypeForArrayRef(BASEARRAYREF pArrayRef);
    static BOOL IsValidArrayForSafeArrayElementType(BASEARRAYREF *pArrayRef, VARTYPE vtExpected);

	// Note that Rank == 0 means SZARRAY (that is rank 1, no lower bounds)
	static TypeHandle GetArrayForVarType(VARTYPE vt, TypeHandle elemType, unsigned rank=0, OBJECTREF* pThrowable=NULL);
	static UINT GetElementSizeForVarType(VARTYPE vt, MethodTable *pInterfaceMT);

    // Helper function to convert a boxed value class to an OLE variant.
    static void ConvertValueClassToVariant(OBJECTREF *pBoxedValueClass, VARIANT *pOleVariant);

    // Helper function to transpose the data in a multidimensionnal array.
    static void TransposeArrayData(BYTE *pDestData, BYTE *pSrcData, DWORD dwNumComponents, DWORD dwComponentSize, SAFEARRAY *pSafeArray, BOOL bSafeArrayToMngArray, BOOL bObjRefs);

    // Helper to retrieve the type handle for the wrapper types.
    static TypeHandle GetWrapperTypeHandle(EnumWrapperTypes WrapperType);

    // Helper to determine if an array is an array of wrappers.
    static BOOL IsArrayOfWrappers(BASEARRAYREF *pArray);

    // Helper to extract the wrapped objects from an array.
    static BASEARRAYREF ExtractWrappedObjectsFromArray(BASEARRAYREF *pArray);

    // Determine the element type of the objects being wrapped by an array of wrappers.
    static TypeHandle GetWrappedArrayElementType(BASEARRAYREF *pArray);

    // Determines the element type of an array taking wrappers into account. This means
    // that is an array of wrappers is passed in, the returned element type will be that
    // of the wrapped objects, not of the wrappers.
    static TypeHandle GetArrayElementTypeWrapperAware(BASEARRAYREF *pArray);

    // Determine the type of the elements for a safe array of records.
    static TypeHandle GetElementTypeForRecordSafeArray(SAFEARRAY* pSafeArray);

    // Helper called from MarshalIUnknownArrayComToOle and MarshalIDispatchArrayComToOle.
    static void MarshalInterfaceArrayComToOleHelper(BASEARRAYREF *pComArray, void *oleArray,
                                                    MethodTable *pElementMT, BOOL bDefaultIsDispatch);

    static void MarshalBSTRArrayComToOleWrapper(BASEARRAYREF *pComArray, void *oleArray);
    static void MarshalBSTRArrayOleToComWrapper(void *oleArray, BASEARRAYREF *pComArray);
    static void ClearBSTRArrayWrapper(void *oleArray, SIZE_T cElements);

    struct Marshaler
    {
        void (*OleToComVariant)(VARIANT *pOleVariant, VariantData *pComVariant);
        void (*ComToOleVariant)(VariantData *pComVariant, VARIANT *pOleVariant);
        void (*OleRefToComVariant)(VARIANT *pOleVariant, VariantData *pComVariant);
        void (*OleToComArray)(void *oleArray, BASEARRAYREF *pComArray, MethodTable *pInterfaceMT);
        void (*ComToOleArray)(BASEARRAYREF *pComArray, void *oleArray, MethodTable *pInterfaceMT);
        void (*ClearOleArray)(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT);
    };

    static Marshaler *GetMarshalerForVarType(VARTYPE vt);

#ifdef CUSTOMER_CHECKED_BUILD
    static BOOL CheckVariant(VARIANT *pOle);
#endif

private:

	// Specific marshaler functions

	static void MarshalBoolVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalBoolVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);
	static void MarshalBoolVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalBoolArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
										 MethodTable *pInterfaceMT);
	static void MarshalBoolArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
										 MethodTable *pInterfaceMT);

	static void MarshalWinBoolVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalWinBoolVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);
	static void MarshalWinBoolVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalWinBoolArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
										 MethodTable *pInterfaceMT);
	static void MarshalWinBoolArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
										 MethodTable *pInterfaceMT);

	static void MarshalAnsiCharVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalAnsiCharVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);
	static void MarshalAnsiCharVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalAnsiCharArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
										 MethodTable *pInterfaceMT);
	static void MarshalAnsiCharArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
										 MethodTable *pInterfaceMT);

	static void MarshalInterfaceVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalInterfaceVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);
	static void MarshalInterfaceVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalInterfaceArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
											  MethodTable *pInterfaceMT);
	static void MarshalIUnknownArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
											 MethodTable *pInterfaceMT);
	static void MarshalIDispatchArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
								 			  MethodTable *pInterfaceMT);
	static void ClearInterfaceArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT);

	static void MarshalBSTRVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalBSTRVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);
	static void MarshalBSTRVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalBSTRArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
										 MethodTable *pInterfaceMT);
	static void MarshalBSTRArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
										 MethodTable *pInterfaceMT);
	static void ClearBSTRArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT);

	static void MarshalNonBlittableRecordArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
										 MethodTable *pInterfaceMT);
	static void MarshalNonBlittableRecordArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
										 MethodTable *pInterfaceMT);
	static void ClearNonBlittableRecordArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT);

	static void MarshalLPWSTRArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
										 MethodTable *pInterfaceMT);
	static void MarshalLPWSTRRArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
										 MethodTable *pInterfaceMT);
	static void ClearLPWSTRArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT);

	static void MarshalLPSTRArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
										 MethodTable *pInterfaceMT);
	static void MarshalLPSTRRArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
										 MethodTable *pInterfaceMT);
	static void ClearLPSTRArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT);

	static void MarshalDateVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalDateVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);
	static void MarshalDateVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalDateArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
										  MethodTable *pInterfaceMT);
	static void MarshalDateArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
										  MethodTable *pInterfaceMT);

	static void MarshalDecimalVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalDecimalVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);
	static void MarshalDecimalVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);

	static void MarshalCurrencyVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalCurrencyVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);
	static void MarshalCurrencyVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalCurrencyArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
										     MethodTable *pInterfaceMT);
	static void MarshalCurrencyArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
										     MethodTable *pInterfaceMT);

	static void MarshalVariantArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
											MethodTable *pInterfaceMT);
	static void MarshalVariantArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
											MethodTable *pInterfaceMT);
	static void ClearVariantArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT);

	static void MarshalArrayVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalArrayVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);
	static void MarshalArrayVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);
	static void MarshalArrayArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
										  MethodTable *pInterfaceMT);
	static void MarshalArrayArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
										  MethodTable *pInterfaceMT);
	static void ClearArrayArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT);

    static void MarshalErrorVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
    static void MarshalErrorVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);
    static void MarshalErrorVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);

    static void MarshalRecordVariantOleToCom(VARIANT *pOleVariant, VariantData *pComVariant);
    static void MarshalRecordVariantComToOle(VariantData *pComVariant, VARIANT *pOleVariant);
    static void MarshalRecordVariantOleRefToCom(VARIANT *pOleVariant, VariantData *pComVariant);
    static void MarshalRecordArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray, MethodTable *pElementMT);
    static void MarshalRecordArrayComToOle(BASEARRAYREF *pComArray, void *oleArray, MethodTable *pElementMT);
    static void ClearRecordArray(void *oleArray, SIZE_T cElements, MethodTable *pElementMT);

    static BYTE m_aWrapperTypes[WrapperTypes_Last * sizeof(TypeHandle)];



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\olevariant.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "object.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "COMVariant.h"
#include "metasig.h"
#include "COMString.h"
#include "COMStringCommon.h"
#include "COMMember.h"
#include "OleVariant.h"
#include "COMDateTime.h"
#include "nstruct.h"

#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"
#endif

#define CLEAR_BYREF_VARIANT_CONTENTS

/* ------------------------------------------------------------------------- *
 * Local constants
 * ------------------------------------------------------------------------- */

#define NO_MAPPING (BYTE)-1
#define RUNTIMEPACKAGE "System."

static MethodTable *g_pDecimalMethodTable = NULL;

BYTE OleVariant::m_aWrapperTypes[WrapperTypes_Last * sizeof(TypeHandle)];


/* ------------------------------------------------------------------------- *
 * Boolean marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalBoolVariantOleToCom(VARIANT *pOleVariant, 
                                            VariantData *pComVariant)
{
    *(INT64*)pComVariant->GetData() = V_BOOL(pOleVariant) ? 1 : 0;
}

void OleVariant::MarshalBoolVariantComToOle(VariantData *pComVariant, 
                                            VARIANT *pOleVariant)
{
    V_BOOL(pOleVariant) = *(INT64*)pComVariant->GetData() ? VARIANT_TRUE : VARIANT_FALSE;
}

void OleVariant::MarshalBoolVariantOleRefToCom(VARIANT *pOleVariant, 
                                            VariantData *pComVariant)
{
    *(INT64*)pComVariant->GetData() = *V_BOOLREF(pOleVariant) ? 1 : 0;
}

void OleVariant::MarshalBoolArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                          MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    VARIANT_BOOL *pOle = (VARIANT_BOOL *) oleArray;
    VARIANT_BOOL *pOleEnd = pOle + elementCount;
    
    UCHAR *pCom = (UCHAR *) (*pComArray)->GetDataPtr();

    while (pOle < pOleEnd)
        *pCom++ = *pOle++ ? 1 : 0;
}

void OleVariant::MarshalBoolArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                          MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    VARIANT_BOOL *pOle = (VARIANT_BOOL *) oleArray;
    VARIANT_BOOL *pOleEnd = pOle + elementCount;
    
    UCHAR *pCom = (UCHAR *) (*pComArray)->GetDataPtr();

    while (pOle < pOleEnd)
        *pOle++ = *pCom++ ? VARIANT_TRUE : VARIANT_FALSE;
}




/* ------------------------------------------------------------------------- *
 * Boolean marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalWinBoolVariantOleToCom(VARIANT *pOleVariant, 
                                            VariantData *pComVariant)
{
    _ASSERTE(!"Not supposed to get here.");
}

void OleVariant::MarshalWinBoolVariantComToOle(VariantData *pComVariant, 
                                            VARIANT *pOleVariant)
{
    _ASSERTE(!"Not supposed to get here.");
}

void OleVariant::MarshalWinBoolVariantOleRefToCom(VARIANT *pOleVariant, 
                                            VariantData *pComVariant)
{
    _ASSERTE(!"Not supposed to get here.");
}

void OleVariant::MarshalWinBoolArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                          MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    BOOL *pOle = (BOOL *) oleArray;
    BOOL *pOleEnd = pOle + elementCount;
    
    UCHAR *pCom = (UCHAR *) (*pComArray)->GetDataPtr();

    while (pOle < pOleEnd)
        *pCom++ = *pOle++ ? 1 : 0;
}

void OleVariant::MarshalWinBoolArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                          MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    BOOL *pOle = (BOOL *) oleArray;
    BOOL *pOleEnd = pOle + elementCount;
    
    UCHAR *pCom = (UCHAR *) (*pComArray)->GetDataPtr();

    while (pOle < pOleEnd)
        *pOle++ = *pCom++ ? 1 : 0;
}


/* ------------------------------------------------------------------------- *
 * Ansi char marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalAnsiCharVariantOleToCom(VARIANT *pOleVariant, 
                                            VariantData *pComVariant)
{
    _ASSERTE(!"Not supposed to get here.");
}

void OleVariant::MarshalAnsiCharVariantComToOle(VariantData *pComVariant, 
                                            VARIANT *pOleVariant)
{
    _ASSERTE(!"Not supposed to get here.");
}

void OleVariant::MarshalAnsiCharVariantOleRefToCom(VARIANT *pOleVariant, 
                                            VariantData *pComVariant)
{
    _ASSERTE(!"Not supposed to get here.");
}

void OleVariant::MarshalAnsiCharArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                          MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    WCHAR *pCom = (WCHAR *) (*pComArray)->GetDataPtr();

    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        (const CHAR *)oleArray,
                        (int)elementCount,
                        pCom,
                        (int)elementCount);

}

void OleVariant::MarshalAnsiCharArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                          MethodTable *pInterfaceMT)
{
    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    const WCHAR *pCom = (const WCHAR *) (*pComArray)->GetDataPtr();

    WszWideCharToMultiByte(CP_ACP,
                         0,
                         (const WCHAR *)pCom,
                         (int)elementCount,
                         (CHAR *)oleArray,
                         (int)(elementCount << 1),
                         NULL,
                         NULL);
}



/* ------------------------------------------------------------------------- *
 * Interface marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalInterfaceVariantOleToCom(VARIANT *pOleVariant, 
                                                 VariantData *pComVariant)
{
    IUnknown *unk = V_UNKNOWN(pOleVariant);

    OBJECTREF obj;
    if (unk == NULL)
        obj = NULL;
    else
        obj = GetObjectRefFromComIP(V_UNKNOWN(pOleVariant));

    pComVariant->SetObjRef(obj);
}

void OleVariant::MarshalInterfaceVariantComToOle(VariantData *pComVariant, 
                                                 VARIANT *pOleVariant)

{
    OBJECTREF *obj = pComVariant->GetObjRefPtr();
    VARTYPE vt = pComVariant->GetVT();
    
    ASSERT_PROTECTED(obj);

    if (*obj == NULL)
    {
        // If there is no VT set in the managed variant, then default to VT_UNKNOWN.
        if (vt == VT_EMPTY)
            vt = VT_UNKNOWN;

        V_UNKNOWN(pOleVariant) = NULL;
        V_VT(pOleVariant) = vt;
    }
    else
    {
        ComIpType FetchedIpType = ComIpType_None;
        ComIpType ReqIpType;

        if (vt != VT_EMPTY)
        {
            // We are dealing with an UnknownWrapper or DispatchWrapper. 
            // In this case, we need to respect the VT.
            _ASSERTE(vt == VT_DISPATCH || vt == VT_UNKNOWN);
            ReqIpType = vt == VT_DISPATCH ? ComIpType_Dispatch : ComIpType_Unknown;
        }
        else
        {
            // We are dealing with a normal object so we can give either
            // IDispatch or IUnknown out depending on what it supports.
            ReqIpType = ComIpType_Both;
        }

        IUnknown *unk = GetComIPFromObjectRef(obj, ReqIpType, &FetchedIpType);
        BOOL ItfIsDispatch = FetchedIpType == ComIpType_Dispatch;

        V_UNKNOWN(pOleVariant) = unk;
        V_VT(pOleVariant) = ItfIsDispatch ? VT_DISPATCH : VT_UNKNOWN;
    }
}

void OleVariant::MarshalInterfaceVariantOleRefToCom(VARIANT *pOleVariant, 
                                                 VariantData *pComVariant)
{
    IUnknown *unk = V_UNKNOWN(pOleVariant);

    OBJECTREF obj;
    if (unk == NULL)
        obj = NULL;
    else
        obj = GetObjectRefFromComIP(*V_UNKNOWNREF(pOleVariant));

    pComVariant->SetObjRef(obj);
}

void OleVariant::MarshalInterfaceArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                               MethodTable *pElementMT)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();
    TypeHandle hndElementType = TypeHandle(pElementMT);

    IUnknown **pOle = (IUnknown **) oleArray;
    IUnknown **pOleEnd = pOle + elementCount;

    BASEARRAYREF unprotectedArray = *pComArray;
    OBJECTREF *pCom = (OBJECTREF *) unprotectedArray->GetDataPtr();

    AppDomain *pDomain = unprotectedArray->GetAppDomain();

    OBJECTREF obj = NULL; 
    GCPROTECT_BEGIN(obj)
    {
        while (pOle < pOleEnd)
        {
            IUnknown *unk = *pOle++;
        
            if (unk == NULL)
                obj = NULL;
            else 
                obj = GetObjectRefFromComIP(unk);

            //
            // Make sure the object can be cast to the destination type.
            //

            if (!hndElementType.IsNull() && !CanCastComObject(obj, hndElementType))
            {
                WCHAR wszObjClsName[MAX_CLASSNAME_LENGTH];
                WCHAR wszDestClsName[MAX_CLASSNAME_LENGTH];
                obj->GetClass()->_GetFullyQualifiedNameForClass(wszObjClsName, MAX_CLASSNAME_LENGTH);
                hndElementType.GetClass()->_GetFullyQualifiedNameForClass(wszDestClsName, MAX_CLASSNAME_LENGTH);
                COMPlusThrow(kInvalidCastException, IDS_EE_CANNOTCAST, wszObjClsName, wszDestClsName);
            }       

            //
            // Reset pCom pointer only if array object has moved, rather than
            // recomputing every time through the loop.  Beware implicit calls to
            // ValidateObject inside OBJECTREF methods.
            //

            if (*(void **)&unprotectedArray != *(void **)&*pComArray)
            {
                SIZE_T currentOffset = ((BYTE *)pCom) - (*(Object **) &unprotectedArray)->GetAddress();
                unprotectedArray = *pComArray;
                pCom = (OBJECTREF *) (unprotectedArray->GetAddress() + currentOffset);
            }

            SetObjectReference(pCom++, obj, pDomain);
        }
    }
    GCPROTECT_END();
}

void OleVariant::MarshalIUnknownArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                              MethodTable *pElementMT)
{
    MarshalInterfaceArrayComToOleHelper(pComArray, oleArray, pElementMT, FALSE);
}

void OleVariant::MarshalIDispatchArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                               MethodTable *pElementMT)
{
    MarshalInterfaceArrayComToOleHelper(pComArray, oleArray, pElementMT, TRUE);
}

void OleVariant::ClearInterfaceArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT)
{
    IUnknown **pOle = (IUnknown **) oleArray;
    IUnknown **pOleEnd = pOle + cElements;

    while (pOle < pOleEnd)
    {
        IUnknown *pUnk = *pOle++;
        
        if (pUnk != NULL)
        {
            ULONG cbRef = SafeRelease(pUnk);
            LogInteropRelease(pUnk, cbRef, "VariantClearInterfacArray");
        }
    }
}

/* ------------------------------------------------------------------------- *
 * BSTR marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalBSTRVariantOleToCom(VARIANT *pOleVariant, 
                                            VariantData *pComVariant)
{
    BSTR bstr = V_BSTR(pOleVariant);
    
    STRINGREF string;
    if (bstr == NULL)
        string = NULL;
    else
        string = COMString::NewString(bstr);

    pComVariant->SetObjRef((OBJECTREF) string);
}

void OleVariant::MarshalBSTRVariantComToOle(VariantData *pComVariant, 
                                            VARIANT *pOleVariant)
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF stringRef = (STRINGREF) pComVariant->GetObjRef();

    BSTR bstr;
    if (stringRef == NULL)
        bstr = NULL;
    else 
    {
        bstr = SysAllocStringLen(stringRef->GetBuffer(), stringRef->GetStringLength());
        if (bstr == NULL)
            COMPlusThrowOM();
    }

    V_BSTR(pOleVariant) = bstr;
}

void OleVariant::MarshalBSTRVariantOleRefToCom(VARIANT *pOleVariant, 
                                            VariantData *pComVariant)
{
    BSTR bstr = *V_BSTRREF(pOleVariant);
    
    STRINGREF string;
    if (bstr == NULL)
        string = NULL;
    else
        string = COMString::NewString(bstr);

    pComVariant->SetObjRef((OBJECTREF) string);
}

void OleVariant::MarshalBSTRArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                          MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    BSTR *pOle = (BSTR *) oleArray;
    BSTR *pOleEnd = pOle + elementCount;

    BASEARRAYREF unprotectedArray = *pComArray;
    STRINGREF *pCom = (STRINGREF *) unprotectedArray->GetDataPtr();
    
    AppDomain *pDomain = unprotectedArray->GetAppDomain();

    while (pOle < pOleEnd)
    {
        BSTR bstr = *pOle++;
    
        STRINGREF string;
        if (bstr == NULL)
            string = NULL;
        else
            string = COMString::NewString(bstr);

        //
        // Reset pCom pointer only if array object has moved, rather than
        // recomputing it every time through the loop.  Beware implicit calls to
        // ValidateObject inside OBJECTREF methods.
        //

        if (*(void **)&unprotectedArray != *(void **)&*pComArray)
        {
            SIZE_T currentOffset = ((BYTE *)pCom) - (*(Object **) &unprotectedArray)->GetAddress();
            unprotectedArray = *pComArray;
            pCom = (STRINGREF *) (unprotectedArray->GetAddress() + currentOffset);
        }

        SetObjectReference((OBJECTREF*) pCom++, (OBJECTREF) string, pDomain);
    }
}

void OleVariant::MarshalBSTRArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                          MethodTable *pInterfaceMT)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    BSTR *pOle = (BSTR *) oleArray;
    BSTR *pOleEnd = pOle + elementCount;

    STRINGREF *pCom = (STRINGREF *) (*pComArray)->GetDataPtr();

    while (pOle < pOleEnd)
    {
        //
        // We aren't calling anything which might cause a GC, so don't worry about
        // the array moving here.
        //

        STRINGREF stringRef = *pCom++;

        BSTR bstr;
        if (stringRef == NULL)
            bstr = NULL;
        else 
        {
            bstr = SysAllocStringLen(stringRef->GetBuffer(), stringRef->GetStringLength());
            if (bstr == NULL)
                COMPlusThrowOM();
        }

        *pOle++ = bstr;
    }
}

void OleVariant::ClearBSTRArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT)
{
    BSTR *pOle = (BSTR *) oleArray;
    BSTR *pOleEnd = pOle + cElements;

    while (pOle < pOleEnd)
    {
        BSTR bstr = *pOle++;
        
        if (bstr != NULL)
            SysFreeString(bstr);
    }
}



/* ------------------------------------------------------------------------- *
 * Structure marshaling routines
 * ------------------------------------------------------------------------- */
void OleVariant::MarshalNonBlittableRecordArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                                        MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();
    SIZE_T elemSize     = pInterfaceMT->GetNativeSize();

    BYTE *pOle = (BYTE *) oleArray;
    BYTE *pOleEnd = pOle + elemSize * elementCount;

    BASEARRAYREF unprotectedArray = *pComArray;
    
    UINT dstofs = ArrayBase::GetDataPtrOffset( (*pComArray)->GetMethodTable() );
    while (pOle < pOleEnd)
    {
        LayoutUpdateComPlus( (LPVOID*)pComArray, dstofs, pInterfaceMT->GetClass(), pOle, FALSE );
        dstofs += (*pComArray)->GetComponentSize();
        pOle += elemSize;
    }
}

void OleVariant::MarshalNonBlittableRecordArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                          MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();
    SIZE_T elemSize     = pInterfaceMT->GetNativeSize();

    BYTE *pOle = (BYTE *) oleArray;
    BYTE *pOleEnd = pOle + elemSize * elementCount;

    BASEARRAYREF unprotectedArray = *pComArray;
    STRINGREF *pCom = (STRINGREF *) unprotectedArray->GetDataPtr();
        
    UINT srcofs = ArrayBase::GetDataPtrOffset( (*pComArray)->GetMethodTable() );
    while (pOle < pOleEnd)
    {
        LayoutUpdateNative( (LPVOID*)pComArray, srcofs, pInterfaceMT->GetClass(), pOle, NULL );
        pOle += elemSize;
        srcofs += (*pComArray)->GetComponentSize();
    }
}

void OleVariant::ClearNonBlittableRecordArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT)
{
    SIZE_T elemSize     = pInterfaceMT->GetNativeSize();
    BYTE *pOle = (BYTE *) oleArray;
    BYTE *pOleEnd = pOle + elemSize * cElements;
    EEClass *pcls = pInterfaceMT->GetClass();
    while (pOle < pOleEnd)
    {
        LayoutDestroyNative(pOle, pcls);
        pOle += elemSize;
    }
}


/* ------------------------------------------------------------------------- *
 * LPWSTR marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalLPWSTRArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                            MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    LPWSTR *pOle = (LPWSTR *) oleArray;
    LPWSTR *pOleEnd = pOle + elementCount;

    BASEARRAYREF unprotectedArray = *pComArray;
    STRINGREF *pCom = (STRINGREF *) unprotectedArray->GetDataPtr();
    
    AppDomain *pDomain = unprotectedArray->GetAppDomain();

    while (pOle < pOleEnd)
    {
        LPWSTR lpwstr = *pOle++;
    
        STRINGREF string;
        if (lpwstr == NULL)
            string = NULL;
        else
            string = COMString::NewString(lpwstr);

        //
        // Reset pCom pointer only if array object has moved, rather than
        // recomputing it every time through the loop.  Beware implicit calls to
        // ValidateObject inside OBJECTREF methods.
        //

        if (*(void **)&unprotectedArray != *(void **)&*pComArray)
        {
            SIZE_T currentOffset = ((BYTE *)pCom) - (*(Object **) &unprotectedArray)->GetAddress();
            unprotectedArray = *pComArray;
            pCom = (STRINGREF *) (unprotectedArray->GetAddress() + currentOffset);
        }

        SetObjectReference((OBJECTREF*) pCom++, (OBJECTREF) string, pDomain);
    }
}

void OleVariant::MarshalLPWSTRRArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                             MethodTable *pInterfaceMT)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    LPWSTR *pOle = (LPWSTR *) oleArray;
    LPWSTR *pOleEnd = pOle + elementCount;

    STRINGREF *pCom = (STRINGREF *) (*pComArray)->GetDataPtr();

    while (pOle < pOleEnd)
    {
        //
        // We aren't calling anything which might cause a GC, so don't worry about
        // the array moving here.
        //

        STRINGREF stringRef = *pCom++;

        LPWSTR lpwstr;
        if (stringRef == NULL)
        {
            lpwstr = NULL;
        }
        else 
        {
            // Retrieve the length of the string.
            int Length = stringRef->GetStringLength();

            // Allocate the string using CoTaskMemAlloc.
            lpwstr = (LPWSTR)CoTaskMemAlloc((Length + 1) * sizeof(WCHAR));
            if (lpwstr == NULL)
                COMPlusThrowOM();

            // Copy the COM+ string into the newly allocated LPWSTR.
            memcpyNoGCRefs(lpwstr, stringRef->GetBuffer(), (Length + 1) * sizeof(WCHAR));
            lpwstr[Length] = 0;
        }

        *pOle++ = lpwstr;
    }
}

void OleVariant::ClearLPWSTRArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT)
{
    LPWSTR *pOle = (LPWSTR *) oleArray;
    LPWSTR *pOleEnd = pOle + cElements;

    while (pOle < pOleEnd)
    {
        LPWSTR lpwstr = *pOle++;
        
        if (lpwstr != NULL)
            CoTaskMemFree(lpwstr);
    }
}

/* ------------------------------------------------------------------------- *
 * LPWSTR marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalLPSTRArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                           MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    LPSTR *pOle = (LPSTR *) oleArray;
    LPSTR *pOleEnd = pOle + elementCount;

    BASEARRAYREF unprotectedArray = *pComArray;
    STRINGREF *pCom = (STRINGREF *) unprotectedArray->GetDataPtr();
    
    AppDomain *pDomain = unprotectedArray->GetAppDomain();

    while (pOle < pOleEnd)
    {
        LPSTR lpstr = *pOle++;
    
        STRINGREF string;
        if (lpstr == NULL)
            string = NULL;
        else
            string = COMString::NewString(lpstr);

        //
        // Reset pCom pointer only if array object has moved, rather than
        // recomputing it every time through the loop.  Beware implicit calls to
        // ValidateObject inside OBJECTREF methods.
        //

        if (*(void **)&unprotectedArray != *(void **)&*pComArray)
        {
            SIZE_T currentOffset = ((BYTE *)pCom) - (*(Object **) &unprotectedArray)->GetAddress();
            unprotectedArray = *pComArray;
            pCom = (STRINGREF *) (unprotectedArray->GetAddress() + currentOffset);
        }

        SetObjectReference((OBJECTREF*) pCom++, (OBJECTREF) string, pDomain);
    }
}

void OleVariant::MarshalLPSTRRArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                            MethodTable *pInterfaceMT)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    LPSTR *pOle = (LPSTR *) oleArray;
    LPSTR *pOleEnd = pOle + elementCount;

    STRINGREF *pCom = (STRINGREF *) (*pComArray)->GetDataPtr();

    while (pOle < pOleEnd)
    {
        //
        // We aren't calling anything which might cause a GC, so don't worry about
        // the array moving here.
        //

        STRINGREF stringRef = *pCom++;

        LPSTR lpstr;
        if (stringRef == NULL)
        {
            lpstr = NULL;
        }
        else 
        {
            // Retrieve the length of the string.
            int Length = stringRef->GetStringLength();

            // Allocate the string using CoTaskMemAlloc.
            lpstr = (LPSTR)CoTaskMemAlloc(Length + 1);
            if (lpstr == NULL)
                COMPlusThrowOM();

            // Convert the unicode string to an ansi string.
            if (WszWideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, stringRef->GetBuffer(), Length, lpstr, Length, NULL, NULL) == 0)
                COMPlusThrowWin32();
            lpstr[Length] = 0;
        }

        *pOle++ = lpstr;
    }
}

void OleVariant::ClearLPSTRArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT)
{
    LPSTR *pOle = (LPSTR *) oleArray;
    LPSTR *pOleEnd = pOle + cElements;

    while (pOle < pOleEnd)
    {
        LPSTR lpstr = *pOle++;
        
        if (lpstr != NULL)
            CoTaskMemFree(lpstr);
    }
}

/* ------------------------------------------------------------------------- *
 * Date marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalDateVariantOleToCom(VARIANT *pOleVariant, 
                                            VariantData *pComVariant)
{
    *(INT64*)pComVariant->GetData() = COMDateTime::DoubleDateToTicks(V_DATE(pOleVariant));
}

void OleVariant::MarshalDateVariantComToOle(VariantData *pComVariant, 
                                            VARIANT *pOleVariant)
                                            
{
    V_DATE(pOleVariant) = COMDateTime::TicksToDoubleDate(*(INT64*)pComVariant->GetData());
}

void OleVariant::MarshalDateVariantOleRefToCom(VARIANT *pOleVariant, 
                                               VariantData *pComVariant)
{
    *(INT64*)pComVariant->GetData() = COMDateTime::DoubleDateToTicks(*V_DATEREF(pOleVariant));
}

void OleVariant::MarshalDateArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                          MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    DATE *pOle = (DATE *) oleArray;
    DATE *pOleEnd = pOle + elementCount;
    
    INT64 *pCom = (INT64 *) (*pComArray)->GetDataPtr();

    //
    // We aren't calling anything which might cause a GC, so don't worry about
    // the array moving here.
    //

    while (pOle < pOleEnd)
        *pCom++ = COMDateTime::DoubleDateToTicks(*pOle++);
}

void OleVariant::MarshalDateArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                          MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    DATE *pOle = (DATE *) oleArray;
    DATE *pOleEnd = pOle + elementCount;
    
    INT64 *pCom = (INT64 *) (*pComArray)->GetDataPtr();

    //
    // We aren't calling anything which might cause a GC, so don't worry about
    // the array moving here.
    //

    while (pOle < pOleEnd)
        *pOle++ = COMDateTime::TicksToDoubleDate(*pCom++);
}

/* ------------------------------------------------------------------------- *
 * Decimal marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalDecimalVariantOleToCom(VARIANT *pOleVariant, 
                                               VariantData *pComVariant)
{
    THROWSCOMPLUSEXCEPTION();

    if (g_pDecimalMethodTable == NULL)
        g_pDecimalMethodTable = g_Mscorlib.GetClass(CLASS__DECIMAL);
            
    OBJECTREF pDecimalRef = AllocateObject(g_pDecimalMethodTable);

    *(DECIMAL *) pDecimalRef->UnBox() = V_DECIMAL(pOleVariant);
    
    pComVariant->SetObjRef(pDecimalRef);
}

void OleVariant::MarshalDecimalVariantComToOle(VariantData *pComVariant, 
                                               VARIANT *pOleVariant)
{
    VARTYPE vt = V_VT(pOleVariant);
    _ASSERTE(vt == VT_DECIMAL);
    V_DECIMAL(pOleVariant) = * (DECIMAL*) pComVariant->GetObjRef()->UnBox();
    V_VT(pOleVariant) = vt;
}

void OleVariant::MarshalDecimalVariantOleRefToCom(VARIANT *pOleVariant, 
                                                  VariantData *pComVariant )
{
    THROWSCOMPLUSEXCEPTION();

    if (g_pDecimalMethodTable == NULL)
        g_pDecimalMethodTable = g_Mscorlib.GetClass(CLASS__DECIMAL);
            
    OBJECTREF pDecimalRef = AllocateObject(g_pDecimalMethodTable);

    *(DECIMAL *) pDecimalRef->UnBox() = *V_DECIMALREF(pOleVariant);
    
    pComVariant->SetObjRef(pDecimalRef);
}

/* ------------------------------------------------------------------------- *
 * Currency marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalCurrencyVariantOleToCom(VARIANT *pOleVariant, 
                                                VariantData *pComVariant)
{
    THROWSCOMPLUSEXCEPTION();

    if (g_pDecimalMethodTable == NULL)
        g_pDecimalMethodTable = g_Mscorlib.GetClass(CLASS__DECIMAL);
            
    OBJECTREF pDecimalRef = AllocateObject(g_pDecimalMethodTable);
    DECIMAL DecVal;

    // Convert the currency to a decimal.
    HRESULT hr = VarDecFromCy(V_CY(pOleVariant), &DecVal);
    IfFailThrow(hr);

    DecimalCanonicalize(&DecVal);

    // Store the value into the unboxes decimal and store the decimal in the variant.
    *(DECIMAL *) pDecimalRef->UnBox() = DecVal;   
    pComVariant->SetObjRef(pDecimalRef);
}

void OleVariant::MarshalCurrencyVariantComToOle(VariantData *pComVariant, 
                                                VARIANT *pOleVariant)
{
    THROWSCOMPLUSEXCEPTION();

    CURRENCY CyVal;

    // Convert the decimal to a currency.
    HRESULT hr = VarCyFromDec((DECIMAL*)pComVariant->GetObjRef()->UnBox(), &CyVal);
    IfFailThrow(hr);

    // Store the currency in the VARIANT and set the VT.
    V_CY(pOleVariant) = CyVal;
}

void OleVariant::MarshalCurrencyVariantOleRefToCom(VARIANT *pOleVariant, 
                                                   VariantData *pComVariant)
{
    THROWSCOMPLUSEXCEPTION();

    if (g_pDecimalMethodTable == NULL)
        g_pDecimalMethodTable = g_Mscorlib.GetClass(CLASS__DECIMAL);
            
    OBJECTREF pDecimalRef = AllocateObject(g_pDecimalMethodTable);
    DECIMAL DecVal;

    // Convert the currency to a decimal.
    HRESULT hr = VarDecFromCy(*V_CYREF(pOleVariant), &DecVal);
    IfFailThrow(hr);

    DecimalCanonicalize(&DecVal);

    // Store the value into the unboxes decimal and store the decimal in the variant.
    *(DECIMAL *) pDecimalRef->UnBox() = DecVal;   
    pComVariant->SetObjRef(pDecimalRef);
}

void OleVariant::MarshalCurrencyArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                              MethodTable *pInterfaceMT)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();
    HRESULT hr;

    CURRENCY *pOle = (CURRENCY *) oleArray;
    CURRENCY *pOleEnd = pOle + elementCount;
    
    DECIMAL *pCom = (DECIMAL *) (*pComArray)->GetDataPtr();

    while (pOle < pOleEnd)
    {
        IfFailThrow(VarDecFromCy(*pOle++, pCom++));
        DecimalCanonicalize(pCom);
    }
}

void OleVariant::MarshalCurrencyArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                              MethodTable *pInterfaceMT)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();
    HRESULT hr;

    CURRENCY *pOle = (CURRENCY *) oleArray;
    CURRENCY *pOleEnd = pOle + elementCount;
    
    DECIMAL *pCom = (DECIMAL *) (*pComArray)->GetDataPtr();

    while (pOle < pOleEnd)
        IfFailThrow(VarCyFromDec(pCom++, pOle++));
}


/* ------------------------------------------------------------------------- *
 * Variant marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalVariantArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                             MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    VARIANT *pOle = (VARIANT *) oleArray;
    VARIANT *pOleEnd = pOle + elementCount;
    
    BASEARRAYREF unprotectedArray = *pComArray;
    OBJECTREF *pCom = (OBJECTREF *) unprotectedArray->GetDataPtr();

    AppDomain *pDomain = unprotectedArray->GetAppDomain();

    OBJECTREF TmpObj = NULL;
    GCPROTECT_BEGIN(TmpObj)
    {
        while (pOle < pOleEnd)
        {
            // Marshal the OLE variant into a temp managed variant.
            MarshalObjectForOleVariant(pOle++, &TmpObj);

            // Reset pCom pointer only if array object has moved, rather than
            // recomputing it every time through the loop.  Beware implicit calls to
            // ValidateObject inside OBJECTREF methods.
            if (*(void **)&unprotectedArray != *(void **)&*pComArray)
            {
                SIZE_T currentOffset = ((BYTE *)pCom) - (*(Object **) &unprotectedArray)->GetAddress();
                unprotectedArray = *pComArray;
                pCom = (OBJECTREF *) (unprotectedArray->GetAddress() + currentOffset);
            }
            SetObjectReference(pCom++, TmpObj, pDomain);
        }
    }
    GCPROTECT_END();
}

void OleVariant::MarshalVariantArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                             MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    VARIANT *pOle = (VARIANT *) oleArray;
    VARIANT *pOleEnd = pOle + elementCount;
    
    BASEARRAYREF unprotectedArray = *pComArray;
    OBJECTREF *pCom = (OBJECTREF *) unprotectedArray->GetDataPtr();

    OBJECTREF TmpObj = NULL;
    GCPROTECT_BEGIN(TmpObj)
    {
        while (pOle < pOleEnd)
        {
            // Reset pCom pointer only if array object has moved, rather than
            // recomputing it every time through the loop.  Beware implicit calls to
            // ValidateObject inside OBJECTREF methods.
            if (*(void **)&unprotectedArray != *(void **)&*pComArray)
            {
                SIZE_T currentOffset = ((BYTE *)pCom) - (*(Object **) &unprotectedArray)->GetAddress();
                unprotectedArray = *pComArray;
                pCom = (OBJECTREF *) (unprotectedArray->GetAddress() + currentOffset);
            }
            TmpObj = *pCom++;

            // Marshal the temp managed variant into the OLE variant.
            MarshalOleVariantForObject(&TmpObj, pOle++);
        }
    }
    GCPROTECT_END();
}

void OleVariant::ClearVariantArray(void *oleArray, SIZE_T cElements, MethodTable *pInterfaceMT)
{
    VARIANT *pOle = (VARIANT *) oleArray;
    VARIANT *pOleEnd = pOle + cElements;

    while (pOle < pOleEnd)
        VariantClear(pOle++);
}


/* ------------------------------------------------------------------------- *
 * Array marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalArrayVariantOleToCom(VARIANT *pOleVariant, 
                                             VariantData *pComVariant)
{
    SAFEARRAY *pSafeArray = V_ARRAY(pOleVariant);

    VARTYPE vt = V_VT(pOleVariant) & ~VT_ARRAY;

    if (pSafeArray)
    {
        MethodTable *pElemMT = NULL;
        if (vt == VT_RECORD)
            pElemMT = GetElementTypeForRecordSafeArray(pSafeArray).GetMethodTable();

        BASEARRAYREF pArrayRef = CreateArrayRefForSafeArray(pSafeArray, vt, pElemMT);
        pComVariant->SetObjRef((OBJECTREF) pArrayRef);
        MarshalArrayRefForSafeArray(pSafeArray, (BASEARRAYREF *) pComVariant->GetObjRefPtr(), vt, pElemMT);
    }
    else
    {
        pComVariant->SetObjRef(NULL);
    }
}

void OleVariant::MarshalArrayVariantComToOle(VariantData *pComVariant, 
                                             VARIANT *pOleVariant)                                          
{
    SAFEARRAY *pSafeArray = NULL;
    BASEARRAYREF *pArrayRef = (BASEARRAYREF *) pComVariant->GetObjRefPtr();
    BOOL bSucceeded = FALSE;
    MethodTable *pElemMT = NULL;
    _ASSERTE(pArrayRef);

    VARTYPE vt = GetElementVarTypeForArrayRef(*pArrayRef);
    if (vt == VT_ARRAY)
        vt = VT_VARIANT;

    pElemMT = GetArrayElementTypeWrapperAware(pArrayRef).GetMethodTable();

    EE_TRY_FOR_FINALLY
    {  
        if (*pArrayRef != NULL)
        {
            pSafeArray = CreateSafeArrayForArrayRef(pArrayRef, vt, pElemMT);
            MarshalSafeArrayForArrayRef(pArrayRef, pSafeArray, vt, pElemMT);
        }

        V_ARRAY(pOleVariant) = pSafeArray;
        bSucceeded = TRUE;
    }
    EE_FINALLY
    {
        if (!bSucceeded && pSafeArray)
            SafeArrayDestroy(pSafeArray);
    }
    EE_END_FINALLY; 
}

void OleVariant::MarshalArrayVariantOleRefToCom(VARIANT *pOleVariant, 
                                                VariantData *pComVariant)
{
    SAFEARRAY *pSafeArray = *V_ARRAYREF(pOleVariant);

    VARTYPE vt = V_VT(pOleVariant) & ~(VT_ARRAY|VT_BYREF);

    if (pSafeArray)
    {
        MethodTable *pElemMT = NULL;
        if (vt == VT_RECORD)
            pElemMT = GetElementTypeForRecordSafeArray(pSafeArray).GetMethodTable();

        BASEARRAYREF pArrayRef = CreateArrayRefForSafeArray(pSafeArray, vt, pElemMT);
        pComVariant->SetObjRef((OBJECTREF) pArrayRef);
        MarshalArrayRefForSafeArray(pSafeArray, (BASEARRAYREF *) pComVariant->GetObjRefPtr(), vt, pElemMT);
    }
    else
    {
        pComVariant->SetObjRef(NULL);
    }
}

void OleVariant::MarshalArrayArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                           MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);

    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    VARIANT *pOle = (VARIANT *) oleArray;
    VARIANT *pOleEnd = pOle + elementCount;
    
    BASEARRAYREF unprotectedArray = *pComArray;
    BASEARRAYREF *pCom = (BASEARRAYREF *) unprotectedArray->GetDataPtr();

    AppDomain *pDomain = unprotectedArray->GetAppDomain();

    OBJECTHANDLE arrayHandle = GetAppDomain()->CreateHandle(NULL);

    while (pOle < pOleEnd)
    {
        VARIANT *pOleVariant = pOle++;
        SAFEARRAY *pSafeArray = V_ARRAY(pOleVariant);
        VARTYPE vt = V_VT(pOleVariant) &~ VT_ARRAY;
        BASEARRAYREF arrayRef = NULL;
        MethodTable *pElemMT = NULL;

        if (pSafeArray)         
        {
            if (vt == VT_RECORD)
                pElemMT = GetElementTypeForRecordSafeArray(pSafeArray).GetMethodTable();

            arrayRef = CreateArrayRefForSafeArray(pSafeArray, vt, pElemMT);
        }

        //
        // Reset pCom pointer only if array object has moved, rather than
        // recomputing it every time through the loop.  Beware implicit calls to
        // ValidateObject inside OBJECTREF methods.
        //

        if (*(void **)&unprotectedArray != *(void **)&*pComArray)
        {
            SIZE_T currentOffset = ((BYTE *)pCom) - (*(Object **) &unprotectedArray)->GetAddress();
            unprotectedArray = *pComArray;
            pCom = (BASEARRAYREF *) (unprotectedArray->GetAddress() + currentOffset);
        }

        SetObjectReference((OBJECTREF*) pCom++, (OBJECTREF) arrayRef, pDomain);

        if (arrayRef != NULL)
        {
            //
            // Use a handle, as we cannot pass an internal array pointer here.
            //
            StoreObjectInHandle(arrayHandle, (OBJECTREF) arrayRef);
            MarshalArrayRefForSafeArray(pSafeArray, 
                                        (BASEARRAYREF *) arrayHandle,
                                        V_VT(pOle) & ~VT_ARRAY,
                                        pInterfaceMT);
        }
    }

    DestroyHandle(arrayHandle);
}

void OleVariant::MarshalArrayArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                           MethodTable *pInterfaceMT)
{
    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();

    //
    // We can't put safearrays directly into a safearray, so 
    // the arrays are placed into an intermediate variant.
    //

    VARIANT *pOle = (VARIANT *) oleArray;
    VARIANT *pOleEnd = pOle + elementCount;
    
    BASEARRAYREF unprotectedArray = *pComArray;
    BASEARRAYREF *pCom = (BASEARRAYREF *) unprotectedArray->GetDataPtr();

    BASEARRAYREF TmpArray = NULL;
    GCPROTECT_BEGIN(TmpArray)
    {
        while (pOle < pOleEnd)
        {
            SAFEARRAY *pSafeArray = NULL;

            VARIANT *pOleVariant = pOle++;
            TmpArray = *pCom++;
            VARTYPE elementType = VT_EMPTY;

            if (TmpArray != NULL)
            {
                elementType = GetElementVarTypeForArrayRef(TmpArray);
                if (elementType == VT_ARRAY)
                    elementType = VT_VARIANT;

                MethodTable *pElemMT = GetArrayElementTypeWrapperAware(&TmpArray).GetMethodTable();

                pSafeArray = CreateSafeArrayForArrayRef(&TmpArray, elementType, pElemMT);
                MarshalSafeArrayForArrayRef(&TmpArray, pSafeArray, elementType, pElemMT);
            }       

            SafeVariantClear(pOleVariant);

            if (pSafeArray != NULL)
            {
                V_VT(pOleVariant) = VT_ARRAY | elementType;
                V_ARRAY(pOleVariant) = pSafeArray;
            }
            else
                V_VT(pOleVariant) = VT_NULL;

            if (*(void **)&unprotectedArray != *(void **)&*pComArray)
            {
                SIZE_T currentOffset = ((BYTE *)pCom) - (*(Object **) &unprotectedArray)->GetAddress();
                unprotectedArray = *pComArray;
                pCom = (BASEARRAYREF *) (unprotectedArray->GetAddress() + currentOffset);
            }
        }
    }
    GCPROTECT_END();
}


/* ------------------------------------------------------------------------- *
 * Error marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalErrorVariantOleToCom(VARIANT *pOleVariant, 
                                             VariantData *pComVariant)
{
    // Check to see if the variant represents a missing argument.
    if (V_ERROR(pOleVariant) == DISP_E_PARAMNOTFOUND)
    {
        pComVariant->SetType(CV_MISSING);
    }
    else
    {
        pComVariant->SetDataAsInt32(V_ERROR(pOleVariant));
    }
}

void OleVariant::MarshalErrorVariantOleRefToCom(VARIANT *pOleVariant, 
                                                 VariantData *pComVariant)
{
    // Check to see if the variant represents a missing argument.
    if (*V_ERRORREF(pOleVariant) == DISP_E_PARAMNOTFOUND)
    {
        pComVariant->SetType(CV_MISSING);
    }
    else
    {
        pComVariant->SetDataAsInt32(*V_ERRORREF(pOleVariant));
    }
}

void OleVariant::MarshalErrorVariantComToOle(VariantData *pComVariant, 
                                             VARIANT *pOleVariant)
{
    if (pComVariant->GetType() == CV_MISSING)
    {
        V_ERROR(pOleVariant) = DISP_E_PARAMNOTFOUND;
    }
    else
    {
        V_ERROR(pOleVariant) = pComVariant->GetDataAsInt32();
    }
}


/* ------------------------------------------------------------------------- *
 * Record marshaling routines
 * ------------------------------------------------------------------------- */

void OleVariant::MarshalRecordVariantOleToCom(VARIANT *pOleVariant, 
                                              VariantData *pComVariant)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    IRecordInfo *pRecInfo = pOleVariant->pRecInfo;
    if (!pRecInfo)
        COMPlusThrow(kArgumentException, IDS_EE_INVALID_OLE_VARIANT);

    OBJECTREF BoxedValueClass = NULL;
    GCPROTECT_BEGIN(BoxedValueClass)
    {
        LPVOID pvRecord = pOleVariant->pvRecord;
        if (pvRecord)
        {
            // Go to the registry to find the value class associated
            // with the record's guid.
            GUID guid;
            IfFailThrow(pRecInfo->GetGuid(&guid));
            EEClass *pValueClass = GetEEValueClassForGUID(guid);
            if (!pValueClass)
                COMPlusThrow(kArgumentException, IDS_EE_CANNOT_MAP_TO_MANAGED_VC);

            // Now that we have the value class, allocate an instance of the 
            // boxed value class and copy the contents of the record into it.
            BoxedValueClass = FastAllocateObject(pValueClass->GetMethodTable());
            FmtClassUpdateComPlus(&BoxedValueClass, (BYTE*)pvRecord, FALSE);
        }

        pComVariant->SetObjRef(BoxedValueClass);
    }
    GCPROTECT_END();
}

void OleVariant::MarshalRecordVariantComToOle(VariantData *pComVariant, 
                                              VARIANT *pOleVariant)
{
    OBJECTREF BoxedValueClass = pComVariant->GetObjRef();
    GCPROTECT_BEGIN(BoxedValueClass)
    {
        ConvertValueClassToVariant(&BoxedValueClass, pOleVariant);
    }
    GCPROTECT_END();
}

void OleVariant::MarshalRecordVariantOleRefToCom(VARIANT *pOleVariant, 
                                                 VariantData *pComVariant)
{
    // The representation of a VT_RECORD and a VT_BYREF | VT_RECORD VARIANT are
    // the same so we can simply forward the call to the non byref API.
    MarshalRecordVariantOleToCom(pOleVariant, pComVariant);
}

void OleVariant::MarshalRecordArrayOleToCom(void *oleArray, BASEARRAYREF *pComArray,
                                            MethodTable *pElementMT)
{
    // The element method table must be specified.
    _ASSERTE(pElementMT);

    if (pElementMT->GetClass()->IsBlittable())
    {
        // The array is blittable so we can simply copy it.
        _ASSERTE(pComArray);
        SIZE_T elementCount = (*pComArray)->GetNumComponents();
        SIZE_T elemSize     = pElementMT->GetNativeSize();
        memcpyNoGCRefs((*pComArray)->GetDataPtr(), oleArray, elementCount * elemSize);
    }
    else
    {
        // The array is non blittable so we need to marshal the elements.
        _ASSERTE(pElementMT->GetClass()->HasLayout());
        MarshalNonBlittableRecordArrayOleToCom(oleArray, pComArray, pElementMT);
    }
}

void OleVariant::MarshalRecordArrayComToOle(BASEARRAYREF *pComArray, void *oleArray,
                                            MethodTable *pElementMT)
{
    // The element method table must be specified.
    _ASSERTE(pElementMT);

    if (pElementMT->GetClass()->IsBlittable())
    {
        // The array is blittable so we can simply copy it.
        _ASSERTE(pComArray);
        SIZE_T elementCount = (*pComArray)->GetNumComponents();
        SIZE_T elemSize     = pElementMT->GetNativeSize();
        memcpyNoGCRefs(oleArray, (*pComArray)->GetDataPtr(), elementCount * elemSize);
    }
    else
    {
        // The array is non blittable so we need to marshal the elements.
        _ASSERTE(pElementMT->GetClass()->HasLayout());
        MarshalNonBlittableRecordArrayComToOle(pComArray, oleArray, pElementMT);
    }
}


void OleVariant::ClearRecordArray(void *oleArray, SIZE_T cElements, MethodTable *pElementMT)
{
    _ASSERTE(pElementMT);

    if (!pElementMT->GetClass()->IsBlittable())
    {
        _ASSERTE(pElementMT->GetClass()->HasLayout());
        ClearNonBlittableRecordArray(oleArray, cElements, pElementMT);
    }
}


/* ------------------------------------------------------------------------- *
 * Mapping routines
 * ------------------------------------------------------------------------- */

VARTYPE OleVariant::GetVarTypeForCVType(CVTypes type) {

    THROWSCOMPLUSEXCEPTION();

    static BYTE map[] = 
    {
        VT_EMPTY,           // CV_EMPTY
        VT_VOID,            // CV_VOID
        VT_BOOL,            // CV_BOOLEAN
        VT_UI2,             // CV_CHAR
        VT_I1,              // CV_I1
        VT_UI1,             // CV_U1
        VT_I2,              // CV_I2
        VT_UI2,             // CV_U2
        VT_I4,              // CV_I4
        VT_UI4,             // CV_U4
        VT_I8,              // CV_I8
        VT_UI8,             // CV_U8
        VT_R4,              // CV_R4
        VT_R8,              // CV_R8
        VT_BSTR,            // CV_STRING
        NO_MAPPING,         // CV_PTR
        VT_DATE,            // CV_DATETIME
        NO_MAPPING,         // CV_TIMESPAN
        VT_DISPATCH,        // CV_OBJECT
        VT_DECIMAL,         // CV_DECIMAL
        VT_CY,              // CV_CURRENCY
        VT_I4,              // CV_ENUM
        VT_ERROR,           // CV_MISSING
        VT_NULL             // CV_NULL
    };

    _ASSERTE(type < sizeof(map) / sizeof(map[0]));

    VARTYPE vt = VARTYPE(map[type]);

    if (vt == NO_MAPPING)
        COMPlusThrow(kArgumentException, IDS_EE_COM_UNSUPPORTED_SIG);

    return vt;
}

//
// GetCVTypeForVarType returns the COM+ variant type for a given 
// VARTYPE.  This is called by the marshaller in the context of
// a function call.
//

CVTypes OleVariant::GetCVTypeForVarType(VARTYPE vt)
{
    THROWSCOMPLUSEXCEPTION();

    static BYTE map[] = 
    {
        CV_EMPTY,           // VT_EMPTY
        CV_NULL,            // VT_NULL
        CV_I2,              // VT_I2
        CV_I4,              // VT_I4
        CV_R4,              // VT_R4
        CV_R8,              // VT_R8
        CV_DECIMAL,         // VT_CY
        CV_DATETIME,        // VT_DATE
        CV_STRING,          // VT_BSTR
        CV_OBJECT,          // VT_DISPATCH
        CV_I4,              // VT_ERROR
        CV_BOOLEAN,         // VT_BOOL
        NO_MAPPING,         // VT_VARIANT
        CV_OBJECT,          // VT_UNKNOWN
        CV_DECIMAL,         // VT_DECIMAL
        NO_MAPPING,         // unused
        CV_I1,              // VT_I1
        CV_U1,              // VT_UI1
        CV_U2,              // VT_UI2
        CV_U4,              // VT_UI4
        CV_I8,              // VT_I8
        CV_U8,              // VT_UI8
        CV_I4,              // VT_INT
        CV_U4,              // VT_UINT
        CV_VOID,            // VT_VOID
        NO_MAPPING,         // VT_HRESULT
        NO_MAPPING,         // VT_PTR
        NO_MAPPING,         // VT_SAFEARRAY
        NO_MAPPING,         // VT_CARRAY
        NO_MAPPING,         // VT_USERDEFINED
        NO_MAPPING,         // VT_LPSTR
        NO_MAPPING,         // VT_LPWSTR
        NO_MAPPING,         // unused
        NO_MAPPING,         // unused
        NO_MAPPING,         // unused
        NO_MAPPING,         // unused
        CV_OBJECT,          // VT_RECORD
    };

    CVTypes type = CV_LAST;

    // Validate the arguments.
    _ASSERTE((vt & VT_BYREF) == 0);

    // Array's map to CV_OBJECT.
    if (vt & VT_ARRAY)
        return CV_OBJECT;

    // This is prety much a hack because you cannot cast a CorElementType into a CVTYPE
    if (vt > VT_RECORD || (BYTE)(type = (CVTypes) map[vt]) == NO_MAPPING)
        COMPlusThrow(kArgumentException, IDS_EE_COM_UNSUPPORTED_TYPE);

    return type;
} // CVTypes OleVariant::GetCVTypeForVarType()


// GetVarTypeForComVariant retusn the VARTYPE for the contents
// of a COM+ variant.
//

VARTYPE OleVariant::GetVarTypeForComVariant(VariantData *pComVariant)
{
    THROWSCOMPLUSEXCEPTION();

    CVTypes type = pComVariant->GetType();
    VARTYPE vt;

    vt = pComVariant->GetVT();
    if (vt != VT_EMPTY)
    {
        // This variant was originally unmarshaled from unmanaged, and had the original VT recorded in it.
        // We'll always use that over inference.
        return vt;
    }

    if (type == CV_OBJECT)
    {
        OBJECTREF obj = pComVariant->GetObjRef();

        // Null objects will be converted to VT_DISPATCH variants with a null
        // IDispatch pointer.
        if (obj == NULL)
            return VT_DISPATCH;

        // Retrieve the object's method table.
        MethodTable *pMT = obj->GetMethodTable();

        // Handle the value class case.
        if (pMT->IsValueClass())
            return VT_RECORD;

        // Handle the array case.
        if (pMT->IsArray())
        {
            vt = GetElementVarTypeForArrayRef((BASEARRAYREF)obj);
            if (vt == VT_ARRAY)
                vt = VT_VARIANT;

            return vt | VT_ARRAY;
        }

        // We are dealing with a normal object (not a wrapper) so we will
        // leave the VT as VT_DISPATCH for now and we will determine the actual
        // VT when we convert the object to a COM IP.
        return VT_DISPATCH;
    }

    return GetVarTypeForCVType(type);
}


VARTYPE OleVariant::GetVarTypeForTypeHandle(TypeHandle type)
{
    THROWSCOMPLUSEXCEPTION();

    // Handle primitive types.
    CorElementType elemType = type.GetSigCorElementType();
    if (elemType <= ELEMENT_TYPE_R8) 
        return GetVarTypeForCVType(COMVariant::CorElementTypeToCVTypes(elemType));

    // Handle objects.
    if (type.IsUnsharedMT()) 
    {
        // We need to make sure the CVClasses table is populated.
        if(GetTypeHandleForCVType(CV_DATETIME) == type)
            return VT_DATE;
        if(GetTypeHandleForCVType(CV_DECIMAL) == type)
            return VT_DECIMAL;
        if (type == TypeHandle(g_pStringClass))
            return VT_BSTR;
        if (type == TypeHandle(g_pObjectClass))
            return VT_VARIANT;
        if (type == GetWrapperTypeHandle(WrapperTypes_Dispatch))
            return VT_DISPATCH;
        if (type == GetWrapperTypeHandle(WrapperTypes_Unknown))
            return VT_UNKNOWN;
        if (type == GetWrapperTypeHandle(WrapperTypes_Error))
            return VT_ERROR;
        if (type == GetWrapperTypeHandle(WrapperTypes_Currency))
            return VT_CY;

        if (type.IsEnum())
            return GetVarTypeForCVType((CVTypes)type.GetNormCorElementType());
       
        if (type.GetMethodTable()->IsValueClass())
            return VT_RECORD;

        if (type.GetMethodTable()->IsInterface())
        {
            return type.GetMethodTable()->GetComInterfaceType() == ifVtable ? VT_UNKNOWN : VT_DISPATCH;
        }

        TypeHandle hndDefItfClass;
        DefaultInterfaceType DefItfType = GetDefaultInterfaceForClass(type, &hndDefItfClass);
        switch (DefItfType)
        {
            case DefaultInterfaceType_Explicit:
            {
                return hndDefItfClass.GetMethodTable()->GetComInterfaceType() == ifVtable ? VT_UNKNOWN : VT_DISPATCH;
            }

            case DefaultInterfaceType_AutoDual:
            {
                return VT_DISPATCH;
            }

            case DefaultInterfaceType_IUnknown:
            case DefaultInterfaceType_BaseComClass:
            {
                return VT_UNKNOWN;
            }

            case DefaultInterfaceType_AutoDispatch:
            {
                return VT_DISPATCH;
            }

            default:
            {
                _ASSERTE(!"Invalid default interface type!");
                return VT_UNKNOWN;
            }
        }
    }

    // Handle array's.
    if (CorTypeInfo::IsArray(elemType))
        return VT_ARRAY;
    
    // Non interop compatible type.
    COMPlusThrow(kArgumentException, IDS_EE_COM_UNSUPPORTED_SIG);
    return NO_MAPPING; // Keep the compiler happy.
}

//
// GetElementVarTypeForArrayRef returns the safearray variant type for the
// underlying elements in the array.  
//

VARTYPE OleVariant::GetElementVarTypeForArrayRef(BASEARRAYREF pArrayRef) 
{
    TypeHandle elemTypeHnd = pArrayRef->GetElementTypeHandle();
    return(GetVarTypeForTypeHandle(elemTypeHnd));
}

BOOL OleVariant::IsValidArrayForSafeArrayElementType(BASEARRAYREF *pArrayRef, VARTYPE vtExpected)
{
    // Retrieve the VARTYPE for the managed array.
    VARTYPE vtActual = GetElementVarTypeForArrayRef(*pArrayRef);

    // If the actual type is the same as the expected type, then the array is valid.
    if (vtActual == vtExpected)
        return TRUE;

    // Check for additional supported VARTYPES.
    switch (vtExpected)
    {
        case VT_I4:
            return vtActual == VT_INT;

        case VT_INT:
            return vtActual == VT_I4;

        case VT_UI4:
            return vtActual == VT_UINT;

        case VT_UINT:
            return vtActual == VT_UI4;

        case VT_UNKNOWN:
            return vtActual == VT_VARIANT || vtActual == VT_DISPATCH;

        case VT_DISPATCH:
            return vtActual == VT_VARIANT;

        case VT_CY:
            return vtActual == VT_DECIMAL;

        default:
            return FALSE;
    }
}


//
// GetArrayClassForVarType returns the element class name and underlying method table
// to use to represent an array with the given variant type.  
//

TypeHandle OleVariant::GetArrayForVarType(VARTYPE vt, TypeHandle elemType, unsigned rank, OBJECTREF* pThrowable) 
{
    THROWSCOMPLUSEXCEPTION();

    CorElementType baseElement = ELEMENT_TYPE_END;
    TypeHandle baseType;
    
    if (!elemType.IsNull() && elemType.IsEnum())
    {
        baseType = elemType;       
    }
    else
    {
        switch (vt)
        {
        case VT_BOOL:
        case VTHACK_WINBOOL:
            baseElement = ELEMENT_TYPE_BOOLEAN;
            break;

        case VTHACK_ANSICHAR:
            baseElement = ELEMENT_TYPE_CHAR;
            break;

        case VT_UI1:
            baseElement = ELEMENT_TYPE_U1;
            break;

        case VT_I1:
            baseElement = ELEMENT_TYPE_I1;
            break;

        case VT_UI2:
            baseElement = ELEMENT_TYPE_U2;
            break;

        case VT_I2:
            baseElement = ELEMENT_TYPE_I2;
            break;

        case VT_UI4:
        case VT_UINT:
        case VT_ERROR:
            if (vt == VT_UI4)
            {
                if (elemType.IsNull() || elemType == TypeHandle(g_pObjectClass))
                {
                baseElement = ELEMENT_TYPE_U4;
                }
                else
                {
                    switch (elemType.AsMethodTable()->GetNormCorElementType())
                    {
                        case ELEMENT_TYPE_U4:
                            baseElement = ELEMENT_TYPE_U4;
                            break;
                        case ELEMENT_TYPE_U:
                            baseElement = ELEMENT_TYPE_U;
                            break;
                        default:
                            _ASSERTE(0);
                    }
                }
            }
            else
            {
                baseElement = ELEMENT_TYPE_U4;
            }
            break;

        case VT_I4:
        case VT_INT:
            if (vt == VT_I4)
            {
                if (elemType.IsNull() || elemType == TypeHandle(g_pObjectClass))
                {
                    baseElement = ELEMENT_TYPE_I4;
                }
                else
                {
                    switch (elemType.AsMethodTable()->GetNormCorElementType())
                    {
                        case ELEMENT_TYPE_I4:
                            baseElement = ELEMENT_TYPE_I4;
                            break;
                        case ELEMENT_TYPE_I:
                            baseElement = ELEMENT_TYPE_I;
                            break;
                        default:
                            _ASSERTE(0);
                    }
                }
            }
            else
            {
                baseElement = ELEMENT_TYPE_I4;
            }
            break;

        case VT_I8:
            if (vt == VT_I8)
            {
                if (elemType.IsNull() || elemType == TypeHandle(g_pObjectClass))
                {
                    baseElement = ELEMENT_TYPE_I8;
                }
                else
                {
                    switch (elemType.AsMethodTable()->GetNormCorElementType())
                    {
                        case ELEMENT_TYPE_I8:
                            baseElement = ELEMENT_TYPE_I8;
                            break;
                        case ELEMENT_TYPE_I:
                            baseElement = ELEMENT_TYPE_I;
                            break;
                        default:
                            _ASSERTE(0);
                    }
                }
            }
            else
            {
                baseElement = ELEMENT_TYPE_I8;
            }
            break;

        case VT_UI8:
            if (vt == VT_UI8)
            {
                if (elemType.IsNull() || elemType == TypeHandle(g_pObjectClass))
                {
                    baseElement = ELEMENT_TYPE_U8;
                }
                else
                {
                    switch (elemType.AsMethodTable()->GetNormCorElementType())
                    {
                        case ELEMENT_TYPE_U8:
                            baseElement = ELEMENT_TYPE_U8;
                            break;
                        case ELEMENT_TYPE_U:
                            baseElement = ELEMENT_TYPE_U;
                            break;
                        default:
                            _ASSERTE(0);
                    }
                }
            }
            else
            {
                baseElement = ELEMENT_TYPE_U8;
            }
            break;

        case VT_R4:
            baseElement = ELEMENT_TYPE_R4;
            break;

        case VT_R8:
            baseElement = ELEMENT_TYPE_R8;
            break;

        case VT_CY:
            baseType = TypeHandle(g_Mscorlib.GetClass(CLASS__DECIMAL));
            break;

        case VT_DATE:
            baseType = TypeHandle(g_Mscorlib.GetClass(CLASS__DATE_TIME));
            break;

        case VT_DECIMAL:
            baseType = TypeHandle(g_Mscorlib.GetClass(CLASS__DECIMAL));
            break;

        case VT_VARIANT:

            //
            // It would be nice if our conversion between SAFEARRAY and
            // array ref were symmetric.  Right now it is not, because a
            // jagged array converted to a SAFEARRAY and back will come
            // back as an array of variants.
            //
            // We could try to detect the case where we can turn a
            // safearray of variants into a jagged array.  Basically we
            // needs to make sure that all of the variants in the array
            // have the same array type.  (And if that is array of
            // variant, we need to look recursively for another layer.)
            //
            // We also needs to check the dimensions of each array stored
            // in the variant to make sure they have the same rank, and
            // this rank is needed to build the correct array class name.
            // (Note that it will be impossible to tell the rank if all
            // elements in the array are NULL.)
            // 

            // @nice: implement this functionality if we decide it really makes sense
            // For now, just live with the asymmetry

            baseType = TypeHandle(g_Mscorlib.GetClass(CLASS__OBJECT));
            break;

        case VT_BSTR:
        case VT_LPWSTR:
        case VT_LPSTR:
            baseElement = ELEMENT_TYPE_STRING;
            break;

        case VT_DISPATCH:
        case VT_UNKNOWN:
            if (elemType.IsNull())
                baseType = TypeHandle(g_Mscorlib.GetClass(CLASS__OBJECT));
            else
                baseType = elemType;
            break;

        case VT_RECORD:
            _ASSERTE(!elemType.IsNull());   
            baseType = elemType;
            break;

        default:
            COMPlusThrow(kArgumentException, IDS_EE_COM_UNSUPPORTED_SIG);
        }
    }

    if (baseType.IsNull())
        baseType = TypeHandle(g_Mscorlib.GetElementType(baseElement));

    _ASSERTE(!baseType.IsNull());

    NameHandle typeName(rank == 0 ? ELEMENT_TYPE_SZARRAY : ELEMENT_TYPE_ARRAY,
                        baseType, rank == 0 ? 1 : rank);

    Assembly *pAssembly;
    if (elemType.IsNull())
        pAssembly = SystemDomain::SystemAssembly();
    else 
        pAssembly = elemType.GetAssembly();

    return pAssembly->LookupTypeHandle(&typeName, pThrowable);
}

//
// GetElementSizeForVarType returns the array element size for the given variant type.
//

UINT OleVariant::GetElementSizeForVarType(VARTYPE vt, MethodTable *pInterfaceMT)
{
    static BYTE map[] = 
    {
        0,                      // VT_EMPTY
        0,                      // VT_NULL
        2,                      // VT_I2
        4,                      // VT_I4
        4,                      // VT_R4
        8,                      // VT_R8
        sizeof(CURRENCY),       // VT_CY
        sizeof(DATE),           // VT_DATE
        sizeof(BSTR),           // VT_BSTR
        sizeof(IDispatch*),     // VT_DISPATCH
        sizeof(SCODE),          // VT_ERROR
        sizeof(VARIANT_BOOL),   // VT_BOOL
        sizeof(VARIANT),        // VT_VARIANT
        sizeof(IUnknown*),      // VT_UNKNOWN
        sizeof(DECIMAL),        // VT_DECIMAL
        0,                      // unused
        1,                      // VT_I1
        1,                      // VT_UI1
        2,                      // VT_UI2
        4,                      // VT_UI4
        8,                      // VT_I8
        8,                      // VT_UI8
        sizeof(void*),          // VT_INT 
        sizeof(void*),          // VT_UINT
        0,                      // VT_VOID
        sizeof(HRESULT),        // VT_HRESULT
        sizeof(void*),          // VT_PTR
        sizeof(SAFEARRAY*),     // VT_SAFEARRAY
        sizeof(void*),          // VT_CARRAY
        sizeof(void*),          // VT_USERDEFINED
        sizeof(LPSTR),          // VT_LPSTR
        sizeof(LPWSTR),         // VT_LPWSTR
    };

    // Special cases
    switch (vt)
    {
        case VTHACK_WINBOOL:
            return sizeof(BOOL);
            break;
        case VTHACK_ANSICHAR:
            return sizeof(CHAR)*2;  // *2 to leave room for MBCS.
            break;
        default:
            break;
    }

    // VT_ARRAY indicates a safe array which is always sizeof(SAFEARRAY *).
    if (vt & VT_ARRAY)
        return sizeof(SAFEARRAY*);

    if (vt == VTHACK_NONBLITTABLERECORD || vt == VTHACK_BLITTABLERECORD || vt == VT_RECORD)
        return pInterfaceMT->GetNativeSize();
    else if (vt > VT_LPWSTR)
        return 0;
    else
        return map[vt];
}

//
// GetMarshalerForVarType returns the marshaler for the
// given VARTYPE.
//

OleVariant::Marshaler *OleVariant::GetMarshalerForVarType(VARTYPE vt)
{
    THROWSCOMPLUSEXCEPTION();

    static Marshaler arrayMarshaler = 
    {
        MarshalArrayVariantOleToCom,
        MarshalArrayVariantComToOle,
        MarshalArrayVariantOleRefToCom,
        MarshalArrayArrayOleToCom,
        MarshalArrayArrayComToOle,
        ClearVariantArray
    };

    if (vt & VT_ARRAY)
        return &arrayMarshaler;

    switch (vt)
    {
    case VT_BOOL:
        {
            static Marshaler boolMarshaler = 
            {
                MarshalBoolVariantOleToCom,
                MarshalBoolVariantComToOle,
                MarshalBoolVariantOleRefToCom,
                MarshalBoolArrayOleToCom,
                MarshalBoolArrayComToOle,
                NULL
            };

            return &boolMarshaler;
        }

    case VT_DATE:
        {
            static Marshaler dateMarshaler = 
            {
                MarshalDateVariantOleToCom,
                MarshalDateVariantComToOle,
                MarshalDateVariantOleRefToCom,
                MarshalDateArrayOleToCom,
                MarshalDateArrayComToOle,
                NULL
            };

            return &dateMarshaler;
        }

    case VT_DECIMAL:
        {
            static Marshaler decimalMarshaler = 
            {
                MarshalDecimalVariantOleToCom,
                MarshalDecimalVariantComToOle,
                MarshalDecimalVariantOleRefToCom,
                NULL, NULL, NULL
            };

            return &decimalMarshaler;
        }

    case VT_CY:
        {
            static Marshaler currencyMarshaler = 
            {
                MarshalCurrencyVariantOleToCom,
                MarshalCurrencyVariantComToOle,
                MarshalCurrencyVariantOleRefToCom,
                MarshalCurrencyArrayOleToCom,
                MarshalCurrencyArrayComToOle,
                NULL
            };

            return &currencyMarshaler;
        }

    case VT_BSTR:
        {
            static Marshaler bstrMarshaler = 
            {
                MarshalBSTRVariantOleToCom,
                MarshalBSTRVariantComToOle,
                MarshalBSTRVariantOleRefToCom,
                MarshalBSTRArrayOleToCom,
                MarshalBSTRArrayComToOle,
                ClearBSTRArray,
            };

            return &bstrMarshaler;
        }

    case VTHACK_NONBLITTABLERECORD:
        {
            static Marshaler nonblittablerecordMarshaler = 
            {
                NULL,
                NULL,
                NULL,
                MarshalNonBlittableRecordArrayOleToCom,
                MarshalNonBlittableRecordArrayComToOle,
                ClearNonBlittableRecordArray,
            };

            return &nonblittablerecordMarshaler;
        }

    case VT_UNKNOWN:
        {
            static Marshaler unknownMarshaler = 
            {
                MarshalInterfaceVariantOleToCom,
                MarshalInterfaceVariantComToOle,
                MarshalInterfaceVariantOleRefToCom,
                MarshalInterfaceArrayOleToCom,
                MarshalIUnknownArrayComToOle,
                ClearInterfaceArray
            };

            return &unknownMarshaler;
        }

    case VT_DISPATCH:
        {
            static Marshaler dispatchMarshaler = 
            {
                MarshalInterfaceVariantOleToCom,
                MarshalInterfaceVariantComToOle,
                MarshalInterfaceVariantOleRefToCom,
                MarshalInterfaceArrayOleToCom,
                MarshalIDispatchArrayComToOle,
                ClearInterfaceArray
            };

            return &dispatchMarshaler;
        }

    case VT_VARIANT:
        {
            static Marshaler variantMarshaler = 
            {
                NULL, NULL, NULL, 
                MarshalVariantArrayOleToCom,
                MarshalVariantArrayComToOle,
                ClearVariantArray
            };

            return &variantMarshaler;
        }

    case VT_SAFEARRAY:
        return &arrayMarshaler;

    case VTHACK_WINBOOL:
        {
            static Marshaler winboolMarshaler = 
            {
                MarshalWinBoolVariantOleToCom,
                MarshalWinBoolVariantComToOle,
                MarshalWinBoolVariantOleRefToCom,
                MarshalWinBoolArrayOleToCom,
                MarshalWinBoolArrayComToOle,
                NULL
            };

            return &winboolMarshaler;
        }

    case VTHACK_ANSICHAR:
        {
            static Marshaler ansicharMarshaler = 
            {
                MarshalAnsiCharVariantOleToCom,
                MarshalAnsiCharVariantComToOle,
                MarshalAnsiCharVariantOleRefToCom,
                MarshalAnsiCharArrayOleToCom,
                MarshalAnsiCharArrayComToOle,
                NULL
            };
            return &ansicharMarshaler;
        }

    case VT_LPSTR:
        {
            static Marshaler lpstrMarshaler = 
            {
                NULL, NULL, NULL,
                MarshalLPSTRArrayOleToCom,
                MarshalLPSTRRArrayComToOle,
                ClearLPSTRArray
            };

            return &lpstrMarshaler;
        }

    case VT_LPWSTR:
        {
            static Marshaler lpwstrMarshaler = 
            {
                NULL, NULL, NULL,
                MarshalLPWSTRArrayOleToCom,
                MarshalLPWSTRRArrayComToOle,
                ClearLPWSTRArray
            };

            return &lpwstrMarshaler;
        }

    case VT_CARRAY:
    case VT_USERDEFINED:
        COMPlusThrow(kArgumentException, IDS_EE_COM_UNSUPPORTED_SIG);

    case VT_ERROR:
        {
            static Marshaler errorMarshaler = 
            {
                MarshalErrorVariantOleToCom, 
                MarshalErrorVariantComToOle,
                MarshalErrorVariantOleRefToCom, 
                NULL, NULL, NULL,
            };

            return &errorMarshaler;
        }

    case VT_RECORD:
        {
            static Marshaler recordMarshaler = 
            {
                MarshalRecordVariantOleToCom,
                MarshalRecordVariantComToOle,
                MarshalRecordVariantOleRefToCom,
                MarshalRecordArrayOleToCom,
                MarshalRecordArrayComToOle,
                ClearRecordArray
            };

            return &recordMarshaler;
        }

    case VTHACK_BLITTABLERECORD:
        return NULL; // Requires no marshaling

    default:
        return NULL;
    }
} // OleVariant::Marshaler *OleVariant::GetMarshalerForVarType()

/* ------------------------------------------------------------------------- *
 * New variant marshaling routines
 * ------------------------------------------------------------------------- */

static MethodDesc *pMD_MarshalHelperConvertObjectToVariant = NULL;
static DWORD    dwMDConvertObjectToVariantAttrs = 0;

static MethodDesc *pMD_MarshalHelperCastVariant = NULL;
static MethodDesc *pMD_MarshalHelperConvertVariantToObject = NULL;
static DWORD    dwMDConvertVariantToObjectAttrs = 0;

static MetaSig *pMetaSig_ConvertObjectToVariant = NULL;
static MetaSig *pMetaSig_CastVariant = NULL;
static MetaSig *pMetaSig_ConvertVariantToObject = NULL;
static char szMetaSig_ConvertObjectToVariant[sizeof(MetaSig)];
static char szMetaSig_CastVariant[sizeof(MetaSig)];
static char szMetaSig_ConvertVariantToObject[sizeof(MetaSig)];

// Warning! VariantClear's previous contents of pVarOut.
void OleVariant::MarshalOleVariantForObject(OBJECTREF *pObj, VARIANT *pOle)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pObj != NULL && pOle != NULL);

    SafeVariantClear(pOle);

#ifdef _DEBUG
    FillMemory(pOle, sizeof(VARIANT),0xdd);
    pOle->vt = VT_EMPTY;
#endif

    // For perf reasons, let's handle the more common and easy cases
    // without transitioning to managed code.

    if (*pObj == NULL)
    {
        // null maps to VT_EMPTY - nothing to do here.
    }
    else
    {
        MethodTable *pMT = (*pObj)->GetMethodTable();
        if (pMT == TheInt32Class())
        {
            pOle->vt = VT_I4;
            pOle->lVal = *(long*)( (*pObj)->GetData() );
        }
        else if (pMT == g_pStringClass)
        {
            pOle->vt = VT_BSTR;
            if (*(pObj) == NULL)
            {
                pOle->bstrVal = NULL;
            }
            else
            {
                STRINGREF stringRef = (STRINGREF)(*pObj);
                pOle->bstrVal = SysAllocStringLen(stringRef->GetBuffer(), stringRef->GetStringLength());
                if (pOle->bstrVal == NULL)
                {
                    COMPlusThrowOM();
                }
            }
        }
        else if (pMT == TheInt16Class())
        {
            pOle->vt = VT_I2;
            pOle->iVal = *(short*)( (*pObj)->GetData() );
        }
        else if (pMT == TheSByteClass())
        {
            pOle->vt = VT_I1;
            *(I1*)&(pOle->iVal) = *(I1*)( (*pObj)->GetData() );
        }
        else if (pMT == TheUInt32Class())
        {
            pOle->vt = VT_UI4;
            pOle->lVal = *(long*)( (*pObj)->GetData() );
        }
        else if (pMT == TheUInt16Class())
        {
            pOle->vt = VT_UI2;
            pOle->iVal = *(short*)( (*pObj)->GetData() );
        }
        else if (pMT == TheByteClass())
        {
            pOle->vt = VT_UI1;
            *(U1*)&(pOle->iVal) = *(U1*)( (*pObj)->GetData() );
        }
        else if (pMT == TheSingleClass())
        {
            pOle->vt = VT_R4;
            pOle->fltVal = *(float*)( (*pObj)->GetData() );
        }
        else if (pMT == TheDoubleClass())
        {
            pOle->vt = VT_R8;
            pOle->dblVal = *(double*)( (*pObj)->GetData() );
        }
        else if (pMT == TheBooleanClass())
        {
            pOle->vt = VT_BOOL;
            pOle->boolVal = *(U1*)( (*pObj)->GetData() ) ? VARIANT_TRUE : VARIANT_FALSE;
        }
        else if (pMT == TheIntPtrClass())
        {
            pOle->vt = VT_INT;
            *(LPVOID*)&(pOle->iVal) = *(LPVOID*)( (*pObj)->GetData() );
        }
        else if (pMT == TheUIntPtrClass())
        {
            pOle->vt = VT_UINT;
            *(LPVOID*)&(pOle->iVal) = *(LPVOID*)( (*pObj)->GetData() );
        }
        else
        {
            if (!pMD_MarshalHelperConvertObjectToVariant)
            {
                COMVariant::EnsureVariantInitialized();
                // Use a temporary here to make sure thread safe.
                MethodDesc *pMDTmp = g_Mscorlib.GetMethod(METHOD__VARIANT__CONVERT_OBJECT_TO_VARIANT);
                if (FastInterlockCompareExchange ((void**)&pMetaSig_ConvertObjectToVariant, (void*)1, (void*)0) == 0)
                {
                    // We are using a static buffer.  Make sure the following code
                    // only happens once.
                    pMetaSig_ConvertObjectToVariant =
                        new (szMetaSig_ConvertObjectToVariant) MetaSig (
                            g_Mscorlib.GetMethodBinarySig(METHOD__VARIANT__CONVERT_OBJECT_TO_VARIANT),
                            pMDTmp->GetModule());
                }
                else
                {
                    _ASSERTE (pMetaSig_ConvertObjectToVariant != 0);
                    // we loose.  Wait for initialization to be finished.
                    while ((void*)pMetaSig_ConvertObjectToVariant == (void*)1)
                        __SwitchToThread(0);
                }
                    
                dwMDConvertObjectToVariantAttrs = pMDTmp->GetAttrs();
                pMD_MarshalHelperConvertObjectToVariant = pMDTmp;
                _ASSERTE(pMD_MarshalHelperConvertObjectToVariant);
            }
        
            VariantData managedVariant;
            FillMemory(&managedVariant, sizeof(managedVariant), 0);
            GCPROTECT_BEGIN_VARIANTDATA(managedVariant)
            {
                INT64 args[] = { (INT64)&managedVariant, ObjToInt64(*pObj) };
                pMD_MarshalHelperConvertObjectToVariant->Call(args,
                      pMetaSig_ConvertObjectToVariant);
                OleVariant::MarshalOleVariantForComVariant(&managedVariant, pOle);
            }
            GCPROTECT_END_VARIANTDATA();
    
        }

    }


}

void OleVariant::MarshalOleRefVariantForObject(OBJECTREF *pObj, VARIANT *pOle)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pObj != NULL && pOle != NULL && pOle->vt & VT_BYREF);


    // Let's try to handle the common trivial cases quickly first before
    // running the generalized stuff.
    MethodTable *pMT = (*pObj) == NULL ? NULL : (*pObj)->GetMethodTable();
    if ( (pOle->vt == (VT_BYREF | VT_I4) || pOle->vt == (VT_BYREF | VT_UI4)) && (pMT == TheInt32Class() || pMT == TheUInt32Class()) )
    {
        // deallocation of old value optimized away since there's nothing to
        // deallocate for this vartype.

        *(pOle->plVal) = *(long*)( (*pObj)->GetData() );
    }
    else if ( (pOle->vt == (VT_BYREF | VT_I2) || pOle->vt == (VT_BYREF | VT_UI2)) && (pMT == TheInt16Class() || pMT == TheUInt16Class()) )
    {
        // deallocation of old value optimized away since there's nothing to
        // deallocate for this vartype.

        *(pOle->piVal) = *(short*)( (*pObj)->GetData() );
    }
    else if ( (pOle->vt == (VT_BYREF | VT_I1) || pOle->vt == (VT_BYREF | VT_UI1)) && (pMT == TheSByteClass() || pMT == TheByteClass()) )
    {
        // deallocation of old value optimized away since there's nothing to
        // deallocate for this vartype.

        *(I1*)(pOle->piVal) = *(I1*)( (*pObj)->GetData() );
    }
    else if ( pOle->vt == (VT_BYREF | VT_R4) && pMT == TheSingleClass() )
    {
        // deallocation of old value optimized away since there's nothing to
        // deallocate for this vartype.

        *(pOle->pfltVal) = *(float*)( (*pObj)->GetData() );
    }
    else if ( pOle->vt == (VT_BYREF | VT_R8) && pMT == TheDoubleClass() )
    {
        // deallocation of old value optimized away since there's nothing to
        // deallocate for this vartype.

        *(pOle->pdblVal) = *(double*)( (*pObj)->GetData() );
    }
    else if ( pOle->vt == (VT_BYREF | VT_BOOL) && pMT == TheBooleanClass() )
    {
        // deallocation of old value optimized away since there's nothing to
        // deallocate for this vartype.

        *(pOle->pboolVal) =  ( *(U1*)( (*pObj)->GetData() ) ) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else if ( (pOle->vt == (VT_BYREF | VT_INT) || pOle->vt == (VT_BYREF | VT_UINT)) && (pMT == TheIntPtrClass() || pMT == TheUIntPtrClass()) )
    {
        // deallocation of old value optimized away since there's nothing to
        // deallocate for this vartype.

        *(LPVOID*)(pOle->piVal) = *(LPVOID*)( (*pObj)->GetData() );
    }
    else if ( pOle->vt == (VT_BYREF | VT_BSTR) && pMT == g_pStringClass )
    {
        if (*(pOle->pbstrVal))
        {
            SysFreeString(*(pOle->pbstrVal));
            *(pOle->pbstrVal) = NULL;
        }
        STRINGREF stringRef = (STRINGREF)(*pObj);

        if (stringRef == NULL)
        {
            *(pOle->pbstrVal) = NULL;
        }
        else
        {
            *(pOle->pbstrVal) = SysAllocStringLen(stringRef->GetBuffer(), stringRef->GetStringLength());
            if (*(pOle->pbstrVal) == NULL)
            {
                COMPlusThrowOM();
            }
        }
    }
    else
    {

        if (!pMD_MarshalHelperCastVariant)
        {
            COMVariant::EnsureVariantInitialized();
            // Use a temporary here to make sure thread safe.
            MethodDesc *pMDTmp = g_Mscorlib.GetMethod(METHOD__VARIANT__CAST_VARIANT);
            if (FastInterlockCompareExchange ((void**)&pMetaSig_CastVariant, (void*)1, (void*)0) == 0)
            {
                // We are using a static buffer.  Make sure the following code
                // only happens once.
                pMetaSig_CastVariant =
                    new (szMetaSig_CastVariant) MetaSig (
                        g_Mscorlib.GetMethodBinarySig(METHOD__VARIANT__CAST_VARIANT), pMDTmp->GetModule());
            }
            else
            {
                _ASSERTE (pMetaSig_CastVariant != 0);
                // we loose.  Wait for initialization to be finished.
                while ((void*)pMetaSig_CastVariant == (void*)1)
                    __SwitchToThread(0);
            }
            
            pMD_MarshalHelperCastVariant = pMDTmp;
            _ASSERTE(pMD_MarshalHelperCastVariant);
        }
    
        VARIANT vtmp;
        VARTYPE vt = pOle->vt & ~VT_BYREF;
    
        // Release the data pointed to by the byref variant.
        ExtractContentsFromByrefVariant(pOle, &vtmp);
        SafeVariantClear(&vtmp);
    
        if (vt == VT_VARIANT)
        {
            // Since variants can contain any VARTYPE we simply convert the object to 
            // a variant and stuff it back into the byref variant.
            MarshalOleVariantForObject(pObj, &vtmp);
            InsertContentsIntoByrefVariant(&vtmp, pOle);
        }
        else if (vt & VT_ARRAY)
        {
            // Since the marshal cast helper does not support array's the best we can do
            // is marshal the object back to a variant and hope it is of the right type.
            // If it is not then we must throw an exception.
            MarshalOleVariantForObject(pObj, &vtmp);
            if (vtmp.vt != vt)
                COMPlusThrow(kInvalidCastException, IDS_EE_CANNOT_COERCE_BYREF_VARIANT);
            InsertContentsIntoByrefVariant(&vtmp, pOle);
        }
        else
        {
            // The variant is not an array so we can use the marshal cast helper
            // to coerce the object to the proper type.
            VariantData vd;
            FillMemory(&vd, sizeof(vd), 0);
            GCPROTECT_BEGIN_VARIANTDATA(vd);
            {
                if ( (*pObj) == NULL &&
                     (vt == VT_BSTR ||
                      vt == VT_DISPATCH ||
                      vt == VT_UNKNOWN ||
                      vt == VT_PTR ||
                      vt == VT_CARRAY ||
                      vt == VT_SAFEARRAY ||
                      vt == VT_LPSTR ||
                      vt == VT_LPWSTR) )
                {
                    // Have to handle this specially since the managed variant
                    // conversion will return a VT_EMPTY which isn't what we want.
                    vtmp.vt = vt;
                    vtmp.punkVal = NULL;
                }
                else
                {
                    INT64 args[3];
                    args[2] = ObjToInt64(*pObj);
                    args[1] = (INT64)vt;
                    args[0] = (INT64)&vd;
                    pMD_MarshalHelperCastVariant->Call(args,
                          pMetaSig_CastVariant);
                    OleVariant::MarshalOleVariantForComVariant(&vd, &vtmp);
                }
                // If the variant types are still not the same then call VariantChangeType to
                // try and coerse them.
                if (vtmp.vt != vt)
                {
                    VARIANT vtmp2;
                    memset(&vtmp2, 0, sizeof(VARIANT));
    
                    // The type of the variant has changed so attempt to change
                    // the type back.
                    HRESULT hr = SafeVariantChangeType(&vtmp2, &vtmp, 0, vt);
                    if (FAILED(hr))
                    {
                        if (hr == DISP_E_TYPEMISMATCH)
                            COMPlusThrow(kInvalidCastException, IDS_EE_CANNOT_COERCE_BYREF_VARIANT);
                        else
                            COMPlusThrowHR(hr);
                    }
    
                    // Copy the converted variant back into the original variant and clear the temp.
                    InsertContentsIntoByrefVariant(&vtmp2, pOle);
                    SafeVariantClear(&vtmp);
                }
                else
                {
                    InsertContentsIntoByrefVariant(&vtmp, pOle);
                }
            }
            GCPROTECT_END_VARIANTDATA();
        }
    }
}

void OleVariant::MarshalObjectForOleVariant(const VARIANT *pOle, OBJECTREF *pObj)
{

#ifdef CUSTOMER_CHECKED_BUILD

    CustomerDebugHelper* pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_InvalidVariant))
    {
        if (!CheckVariant((VARIANT*)pOle))
            pCdh->ReportError(L"Invalid VARIANT detected.", CustomerCheckedBuildProbe_InvalidVariant);
    }

#endif

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pOle != NULL && pObj != NULL);

    if (V_ISBYREF(pOle) && !pOle->byref)
        COMPlusThrow(kArgumentException, IDS_EE_INVALID_OLE_VARIANT);

    switch (pOle->vt)
    {
        case VT_EMPTY:
            *pObj = NULL;
            break;

        case VT_I4:
            *pObj = FastAllocateObject(TheInt32Class());
            *(long*)((*pObj)->GetData()) = pOle->lVal;
            break;

        case VT_BYREF|VT_I4:
            *pObj = FastAllocateObject(TheInt32Class());
            *(long*)((*pObj)->GetData()) = *(pOle->plVal);
            break;

        case VT_UI4:
            *pObj = FastAllocateObject(TheUInt32Class());
            *(long*)((*pObj)->GetData()) = pOle->lVal;
            break;

        case VT_BYREF|VT_UI4:
            *pObj = FastAllocateObject(TheUInt32Class());
            *(long*)((*pObj)->GetData()) = *(pOle->plVal);
            break;

        case VT_I2:
            *pObj = FastAllocateObject(TheInt16Class());
            *(short*)((*pObj)->GetData()) = pOle->iVal;
            break;

        case VT_BYREF|VT_I2:
            *pObj = FastAllocateObject(TheInt16Class());
            *(short*)((*pObj)->GetData()) = *(pOle->piVal);
            break;

        case VT_UI2:
            *pObj = FastAllocateObject(TheUInt16Class());
            *(short*)((*pObj)->GetData()) = pOle->iVal;
            break;

        case VT_BYREF|VT_UI2:
            *pObj = FastAllocateObject(TheUInt16Class());
            *(short*)((*pObj)->GetData()) = *(pOle->piVal);
            break;

        case VT_I1:
            *pObj = FastAllocateObject(TheSByteClass());
            *(I1*)((*pObj)->GetData()) = *(I1*)&(pOle->iVal);
            break;

        case VT_BYREF|VT_I1:
            *pObj = FastAllocateObject(TheSByteClass());
            *(I1*)((*pObj)->GetData()) = *(I1*)(pOle->piVal);
            break;

        case VT_UI1:
            *pObj = FastAllocateObject(TheByteClass());
            *(I1*)((*pObj)->GetData()) = *(I1*)&(pOle->iVal);
            break;

        case VT_BYREF|VT_UI1:
            *pObj = FastAllocateObject(TheByteClass());
            *(I1*)((*pObj)->GetData()) = *(I1*)(pOle->piVal);
            break;

        case VT_INT:
            *pObj = FastAllocateObject(TheIntPtrClass());
            *(LPVOID*)((*pObj)->GetData()) = *(LPVOID*)&(pOle->iVal);
            break;

        case VT_BYREF|VT_INT:
            *pObj = FastAllocateObject(TheIntPtrClass());
            *(LPVOID*)((*pObj)->GetData()) = *(LPVOID*)(pOle->piVal);
            break;

        case VT_UINT:
            *pObj = FastAllocateObject(TheUIntPtrClass());
            *(LPVOID*)((*pObj)->GetData()) = *(LPVOID*)&(pOle->iVal);
            break;

        case VT_BYREF|VT_UINT:
            *pObj = FastAllocateObject(TheUIntPtrClass());
            *(LPVOID*)((*pObj)->GetData()) = *(LPVOID*)(pOle->piVal);
            break;

        case VT_R4:
            *pObj = FastAllocateObject(TheSingleClass());
            *(float*)((*pObj)->GetData()) = pOle->fltVal;
            break;

        case VT_BYREF|VT_R4:
            *pObj = FastAllocateObject(TheSingleClass());
            *(float*)((*pObj)->GetData()) = *(pOle->pfltVal);
            break;

        case VT_R8:
            *pObj = FastAllocateObject(TheDoubleClass());
            *(double*)((*pObj)->GetData()) = pOle->dblVal;
            break;

        case VT_BYREF|VT_R8:
            *pObj = FastAllocateObject(TheDoubleClass());
            *(double*)((*pObj)->GetData()) = *(pOle->pdblVal);
            break;

        case VT_BOOL:
            *pObj = FastAllocateObject(TheBooleanClass());
            *(U1*)((*pObj)->GetData()) = pOle->boolVal ? 1 : 0;
            break;

        case VT_BYREF|VT_BOOL:
            *pObj = FastAllocateObject(TheBooleanClass());
            *(U1*)((*pObj)->GetData()) = *(pOle->pboolVal) ? 1 : 0;
            break;

        case VT_BSTR:
            *pObj = pOle->bstrVal ? COMString::NewString(pOle->bstrVal, SysStringLen(pOle->bstrVal)) : NULL;
            break;

        case VT_BYREF|VT_BSTR:
            *pObj = *(pOle->pbstrVal) ? COMString::NewString(*(pOle->pbstrVal), SysStringLen(*(pOle->pbstrVal))) : NULL;
            break;

        default:
            {
                if (!pMD_MarshalHelperConvertVariantToObject)
                {
                    COMVariant::EnsureVariantInitialized();
                    // Use a temporary here to make sure thread safe.
                    MethodDesc *pMDTmp = g_Mscorlib.GetMethod(METHOD__VARIANT__CONVERT_VARIANT_TO_OBJECT);
                    if (FastInterlockCompareExchange ((void**)&pMetaSig_ConvertVariantToObject, (void*)1, (void*)0) == 0)
                    {
                        // We are using a static buffer.  Make sure the following code
                        // only happens once.
                        pMetaSig_ConvertVariantToObject =
                            new (szMetaSig_ConvertVariantToObject) MetaSig (
                                 g_Mscorlib.GetMethodBinarySig(METHOD__VARIANT__CONVERT_VARIANT_TO_OBJECT),
                                 SystemDomain::SystemModule());
                    }
                    else
                    {
                        _ASSERTE (pMetaSig_ConvertVariantToObject != 0);
                        // we loose.  Wait for initialization to be finished.
                        while ((void*)pMetaSig_ConvertVariantToObject == (void*)1)
                            __SwitchToThread(0);
                    }
                    
                    dwMDConvertVariantToObjectAttrs = pMDTmp->GetAttrs();
                    pMD_MarshalHelperConvertVariantToObject = pMDTmp;
                    _ASSERTE(pMD_MarshalHelperConvertVariantToObject);
                }
            
                VariantData managedVariant;
                FillMemory(&managedVariant, sizeof(managedVariant), 0);
                GCPROTECT_BEGIN_VARIANTDATA(managedVariant)
                {
                    OleVariant::MarshalComVariantForOleVariant((VARIANT*)pOle, &managedVariant);    
                    INT64 args[] = { (INT64)&managedVariant };
                    *pObj = Int64ToObj(pMD_MarshalHelperConvertVariantToObject->Call(args,
                                       pMetaSig_ConvertVariantToObject));
                }
                GCPROTECT_END_VARIANTDATA();
            }

    }

}


// This function has to return Object* rather than OBJREF because this fcn
// is called from x86-generated code and we don't want the special checked
// definition of OBJECTREF changing this fcn's calling convention.
Object* STDMETHODCALLTYPE OleVariant::MarshalObjectForOleVariantAndClear(VARIANT *pOle)
{

#ifdef CUSTOMER_CHECKED_BUILD

    CustomerDebugHelper* pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_InvalidVariant))
    {
        if (!CheckVariant(pOle))
            pCdh->ReportError(L"Invalid VARIANT detected.", CustomerCheckedBuildProbe_InvalidVariant);
    }

#endif

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pOle != NULL);

    OBJECTREF unprotectedobj;

    switch (pOle->vt)
    {
        case VT_EMPTY:
            unprotectedobj = NULL;
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_I4:
            unprotectedobj = FastAllocateObject(TheInt32Class());
            *(long*)(unprotectedobj->GetData()) = pOle->lVal;
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_UI4:
            unprotectedobj = FastAllocateObject(TheUInt32Class());
            *(long*)((unprotectedobj)->GetData()) = pOle->lVal;
            // optimized away VariantClear() since it's a nop for this VT
            break;


        case VT_I2:
            unprotectedobj = FastAllocateObject(TheInt16Class());
            *(short*)((unprotectedobj)->GetData()) = pOle->iVal;
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_UI2:
            unprotectedobj = FastAllocateObject(TheUInt16Class());
            *(short*)((unprotectedobj)->GetData()) = pOle->iVal;
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_I1:
            unprotectedobj = FastAllocateObject(TheSByteClass());
            *(I1*)((unprotectedobj)->GetData()) = *(I1*)&(pOle->iVal);
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_UI1:
            unprotectedobj = FastAllocateObject(TheByteClass());
            *(I1*)((unprotectedobj)->GetData()) = *(I1*)&(pOle->iVal);
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_INT:
            unprotectedobj = FastAllocateObject(TheIntPtrClass());
            *(LPVOID*)((unprotectedobj)->GetData()) = *(LPVOID*)&(pOle->iVal);
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_UINT:
            unprotectedobj = FastAllocateObject(TheUIntPtrClass());
            *(LPVOID*)((unprotectedobj)->GetData()) = *(LPVOID*)&(pOle->iVal);
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_R4:
            unprotectedobj = FastAllocateObject(TheSingleClass());
            *(float*)((unprotectedobj)->GetData()) = pOle->fltVal;
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_R8:
            unprotectedobj = FastAllocateObject(TheDoubleClass());
            *(double*)((unprotectedobj)->GetData()) = pOle->dblVal;
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_BOOL:
            unprotectedobj = FastAllocateObject(TheBooleanClass());
            *(U1*)((unprotectedobj)->GetData()) = pOle->boolVal ? 1 : 0;
            // optimized away VariantClear() since it's a nop for this VT
            break;

        case VT_BSTR:
            unprotectedobj = pOle->bstrVal ? COMString::NewString(pOle->bstrVal, SysStringLen(pOle->bstrVal)) : NULL;
            if (pOle->bstrVal)
            {
                SysFreeString(pOle->bstrVal);
            }
            break;

        default:
        {
            OBJECTREF obj = NULL;
        
            GCPROTECT_BEGIN(obj)
            {
                OleVariant::MarshalObjectForOleVariant(pOle, &obj);
                SafeVariantClear(pOle);
        
        
                unprotectedobj = obj;
            }
            GCPROTECT_END();
        }
    }


    return OBJECTREFToObject(unprotectedobj);
}


/* ------------------------------------------------------------------------- *
 * Byref variant manipulation helpers.
 * ------------------------------------------------------------------------- */

void OleVariant::ExtractContentsFromByrefVariant(VARIANT *pByrefVar, VARIANT *pDestVar)
{
    THROWSCOMPLUSEXCEPTION();

    VARTYPE vt = pByrefVar->vt & ~VT_BYREF;

    // VT_BYREF | VT_EMPTY is not a valid combination.
    if (vt == 0 || vt == VT_EMPTY)
        COMPlusThrow(kInvalidOleVariantTypeException, IDS_EE_INVALID_OLE_VARIANT);

    switch (vt)
    {
        case VT_RECORD:
        {
            // VT_RECORD's are weird in that regardless of is the VT_BYREF flag is set or not
            // they have the same internal representation.
            pDestVar->pvRecord = pByrefVar->pvRecord;
            pDestVar->pRecInfo = pByrefVar->pRecInfo;
            break;
        }

        case VT_VARIANT:
        {
            // A byref variant is not allowed to contain a byref variant.
            if (pByrefVar->pvarVal->vt & VT_BYREF)
                COMPlusThrow(kInvalidOleVariantTypeException, IDS_EE_INVALID_OLE_VARIANT);

            // Copy the variant that the byref variant points to into the destination variant.
            memcpyNoGCRefs(pDestVar, pByrefVar->pvarVal, sizeof(VARIANT));
            break;
        }

        case VT_DECIMAL:
        {
            // Copy the value that the byref variant points to into the destination variant.
            // Decimal's are special in that they occupy the 16 bits of padding between the 
            // VARTYPE and the intVal field.
            memcpyNoGCRefs(&(pDestVar->decVal), pByrefVar->pdecVal, sizeof(DECIMAL));
            break;
        }

        default:
        {
            // Copy the value that the byref variant points to into the destination variant.
            SIZE_T sz = OleVariant::GetElementSizeForVarType(vt, NULL);
            memcpyNoGCRefs(&(pDestVar->intVal), pByrefVar->pintVal, sz);
            break;
        }
    }

    // Set the variant type of the destination variant.
    pDestVar->vt = vt;
}

void OleVariant::InsertContentsIntoByrefVariant(VARIANT *pSrcVar, VARIANT *pByrefVar)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pSrcVar->vt == (pByrefVar->vt & ~VT_BYREF) || pByrefVar->vt == (VT_BYREF | VT_VARIANT));

    VARTYPE vt = pByrefVar->vt & ~VT_BYREF;

    // VT_BYREF | VT_EMPTY is not a valid combination.
    if (vt == 0 || vt == VT_EMPTY)
        COMPlusThrow(kInvalidOleVariantTypeException, IDS_EE_INVALID_OLE_VARIANT);

    switch (vt)
    {
        case VT_RECORD:
        {
            // VT_RECORD's are weird in that regardless of is the VT_BYREF flag is set or not
            // they have the same internal representation.
            pByrefVar->pvRecord = pSrcVar->pvRecord;
            pByrefVar->pRecInfo = pSrcVar->pRecInfo;
            break;
        }

        case VT_VARIANT:
        {
            // Copy the variant that the byref variant points to into the destination variant.
            memcpyNoGCRefs(pByrefVar->pvarVal, pSrcVar, sizeof(VARIANT));
            break;
        }

        case VT_DECIMAL:
        {
            // Copy the value inside the source variant into the location pointed to by the byref variant.
            memcpyNoGCRefs(pByrefVar->pdecVal, &(pSrcVar->decVal), sizeof(DECIMAL));
            break;
        }

        default:
        {
            // Copy the value inside the source variant into the location pointed to by the byref variant.
            SIZE_T sz = OleVariant::GetElementSizeForVarType(vt, NULL);
            memcpyNoGCRefs(pByrefVar->pintVal, &(pSrcVar->intVal), sz);
            break;
        }
    }
}

void OleVariant::CreateByrefVariantForVariant(VARIANT *pSrcVar, VARIANT *pByrefVar)
{
    THROWSCOMPLUSEXCEPTION();

    // Set the type of the byref variant based on the type of the source variant.
    VARTYPE vt = pSrcVar->vt;
    pByrefVar->vt = vt | VT_BYREF;

    // VT_BYREF | VT_EMPTY is not a valid combination.
    if (vt == 0 || vt == VT_EMPTY)
        COMPlusThrow(kInvalidOleVariantTypeException, IDS_EE_INVALID_OLE_VARIANT);

    switch (vt)
    {
        case VT_RECORD:
        {
            // VT_RECORD's are weird in that regardless of is the VT_BYREF flag is set or not
            // they have the same internal representation.
            pByrefVar->pvRecord = pSrcVar->pvRecord;
            pByrefVar->pRecInfo = pSrcVar->pRecInfo;
            break;
        }

        case VT_VARIANT:
        {
            pByrefVar->pvarVal = pSrcVar;
            break;
        }

        case VT_DECIMAL:
        {
            pByrefVar->pdecVal = &(pSrcVar->decVal);
            break;
        }

        default:
        {
            pByrefVar->pintVal = &(pSrcVar->intVal);
            break;
        }
    }
}

/* ------------------------------------------------------------------------- *
 * Variant marshaling
 * ------------------------------------------------------------------------- */

//
// MarshalComVariantForOleVariant copies the contents of the OLE variant from 
// the COM variant.
//

void OleVariant::MarshalComVariantForOleVariant(VARIANT *pOle, VariantData *pCom)
{
    THROWSCOMPLUSEXCEPTION();

    BOOL byref = V_ISBYREF(pOle);
    VARTYPE vt = V_VT(pOle) & ~VT_BYREF;

    if ((vt & ~VT_ARRAY) >= 128 )
        COMPlusThrow(kInvalidOleVariantTypeException, IDS_EE_INVALID_OLE_VARIANT);

    if (byref && !pOle->byref)
        COMPlusThrow(kArgumentException, IDS_EE_INVALID_OLE_VARIANT);

    if (byref && vt == VT_VARIANT)
    {
        pOle = V_VARIANTREF(pOle);
        byref = V_ISBYREF(pOle);
        vt = V_VT(pOle) & ~VT_BYREF;

        // Byref VARIANTS are not allowed to be nested.
        if (byref)
            COMPlusThrow(kInvalidOleVariantTypeException, IDS_EE_INVALID_OLE_VARIANT);
    }
    
    CVTypes cvt = GetCVTypeForVarType(vt);
    Marshaler *marshal = GetMarshalerForVarType(vt);

    pCom->SetType(cvt);
    pCom->SetVT(vt); // store away VT for return trip. 
    if (marshal == NULL || (byref 
                            ? marshal->OleRefToComVariant == NULL 
                            : marshal->OleToComVariant == NULL))
    {
        if (cvt==CV_EMPTY || cvt==CV_NULL) 
        {
            if (V_ISBYREF(pOle))
            {
                // Must set ObjectRef field of Variant to a specific instance.
                COMVariant::NewVariant(pCom, (INT64)pOle->byref, CV_U4); // @TODO: Make this CV_U.
            }
            else
            {
                // Must set ObjectRef field of Variant to a specific instance.
                COMVariant::NewVariant(pCom, cvt);
            }
        }
        else {
            pCom->SetObjRef(NULL);
            if (byref)
            {
                INT64 data = 0;
                CopyMemory(&data, V_R8REF(pOle), GetElementSizeForVarType(vt, NULL));
                pCom->SetData(&data);
            }
            else
                pCom->SetData(&V_R8(pOle));
        }
    }
    else
    {
        if (byref)
            marshal->OleRefToComVariant(pOle, pCom);
        else
            marshal->OleToComVariant(pOle, pCom);
    }
}

//
// MarshalOleVariantForComVariant copies the contents of the OLE variant from 
// the COM variant.
//

void OleVariant::MarshalOleVariantForComVariant(VariantData *pCom, VARIANT *pOle)
{
    THROWSCOMPLUSEXCEPTION();

    SafeVariantClear(pOle);

    VARTYPE vt = GetVarTypeForComVariant(pCom);
    V_VT(pOle) = vt;

    Marshaler *marshal = GetMarshalerForVarType(vt);

    if (marshal == NULL || marshal->ComToOleVariant == NULL)
    {
        *(INT64*)&V_R8(pOle) = *(INT64*)pCom->GetData();
    }
    else
    {
        BOOL bSucceeded = FALSE;

        EE_TRY_FOR_FINALLY
        {
            marshal->ComToOleVariant(pCom, pOle);
            bSucceeded = TRUE;
        }
        EE_FINALLY
        {
            if (!bSucceeded)
                V_VT(pOle) = VT_EMPTY;
        }
        EE_END_FINALLY; 
    }
}

//
// MarshalOleRefVariantForComVariant copies the contents of the OLE variant from 
// the COM variant.
//

void OleVariant::MarshalOleRefVariantForComVariant(VariantData *pCom, VARIANT *pOle)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pCom && pOle && (pOle->vt & VT_BYREF));

    VARIANT vtmp;
    VARTYPE InitVarType = pOle->vt & ~VT_BYREF;
    SIZE_T sz = GetElementSizeForVarType(InitVarType, NULL);

    // Clear the contents of the original variant.
    ExtractContentsFromByrefVariant(pOle, &vtmp);
    SafeVariantClear(&vtmp);

    // Convert the managed variant to an unmanaged variant.
    OleVariant::MarshalOleVariantForComVariant(pCom, &vtmp);

    // Copy the converted variant into the original variant.
    if (vtmp.vt != InitVarType)
    {
        if (InitVarType == VT_VARIANT)
        {
            // Since variants can contain any VARTYPE we simply convert the managed 
            // variant to an OLE variant and stuff it back into the byref variant.
            InsertContentsIntoByrefVariant(&vtmp, pOle);
        }
        else
        {
            VARIANT vtmp2;
            memset(&vtmp2, 0, sizeof(VARIANT));

            // The type of the variant has changed so attempt to change
            // the type back.
            HRESULT hr = SafeVariantChangeType(&vtmp2, &vtmp, 0, InitVarType);
            if (FAILED(hr))
                COMPlusThrowHR(hr);

            // Copy the converted variant back into the original variant and clear the temp.
            InsertContentsIntoByrefVariant(&vtmp2, pOle);
            SafeVariantClear(&vtmp);
        }
    }
    else
    {
        // The type is the same so we can simply copy the contents.
        InsertContentsIntoByrefVariant(&vtmp, pOle);
    }
}

/* ------------------------------------------------------------------------- *
 * Safearray allocation & conversion
 * ------------------------------------------------------------------------- */

//
// CreateSafeArrayDescriptorForArrayRef creates a SAFEARRAY descriptor with the
// appropriate type & dimensions for the given array ref.  No memory is 
// allocated.
//
// This function is useful when you want to allocate the data specially using
// a fixed buffer or pinning.
//

SAFEARRAY *OleVariant::CreateSafeArrayDescriptorForArrayRef(BASEARRAYREF *pArrayRef, VARTYPE vt,
                                                            MethodTable *pInterfaceMT)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArrayRef && *pArrayRef != NULL);
    ASSERT_PROTECTED(pArrayRef);

    _ASSERTE(!(vt & VT_ARRAY));

    ULONG nElem = (*pArrayRef)->GetNumComponents();
    ULONG nRank = (*pArrayRef)->GetRank();

    SAFEARRAY *pSafeArray = NULL;
    ITypeInfo *pITI = NULL;
    IRecordInfo *pRecInfo = NULL;
    HRESULT hr;
    BOOL bSucceeded = FALSE;

    EE_TRY_FOR_FINALLY
    {  
        IfFailThrow(SafeArrayAllocDescriptorEx(vt, nRank, &pSafeArray));

        switch (vt)
        {
            case VT_VARIANT:
            {
                // OleAut32.dll only sets FADF_HASVARTYPE, but VB says we also need to set
                // the FADF_VARIANT bit for this safearray to destruct properly.  OleAut32
                // doesn't want to change their code unless there's a strong reason, since
                // it's all "black magic" anyway.
                pSafeArray->fFeatures |= FADF_VARIANT;
                break;
            }

            case VT_BSTR:
            {
                pSafeArray->fFeatures |= FADF_BSTR;
                break;
            }

            case VT_UNKNOWN:
            {
                pSafeArray->fFeatures |= FADF_UNKNOWN;
                break;
            }

            case VT_DISPATCH:
            {
                pSafeArray->fFeatures |= FADF_DISPATCH;
                break;
            }

            case VT_RECORD:
            {           
                pSafeArray->fFeatures |= FADF_RECORD;
                break;
            }
        }

        //
        // Fill in bounds
        //

        SAFEARRAYBOUND *bounds = pSafeArray->rgsabound;
        SAFEARRAYBOUND *boundsEnd = bounds + nRank;
        SIZE_T cElements;

        if (!(*pArrayRef)->IsMultiDimArray()) 
        {
            bounds[0].cElements = nElem;
            bounds[0].lLbound = 0;
            cElements = nElem;
        } 
        else 
        {
            const DWORD *upper = (*pArrayRef)->GetBoundsPtr() + nRank - 1;
            const DWORD *lower = (*pArrayRef)->GetLowerBoundsPtr() + nRank - 1;

            cElements = 1;
            while (bounds < boundsEnd)
            {
                bounds->lLbound = *lower--;
                bounds->cElements = *upper--;
                cElements *= bounds->cElements;
                bounds++;
            }
        }

        pSafeArray->cbElements = (unsigned)GetElementSizeForVarType(vt, pInterfaceMT);

        // If the SAFEARRAY contains VT_RECORD's, then we need to set the 
        // IRecordInfo.
        if (vt == VT_RECORD)
        {
            IfFailThrow(GetITypeInfoForEEClass(pInterfaceMT->GetClass(), &pITI));
            IfFailThrow(GetRecordInfoFromTypeInfo(pITI, &pRecInfo));
            IfFailThrow(SafeArraySetRecordInfo(pSafeArray, pRecInfo));
        }

        // We succeeded in setting up the SAFEARRAY descriptor.
        bSucceeded = TRUE;
    }
    EE_FINALLY
    {
        if (pITI)
            pITI->Release();
        if (pRecInfo)
            pRecInfo->Release();
        if (!bSucceeded && pSafeArray)
            SafeArrayDestroy(pSafeArray);
    }
    EE_END_FINALLY; 

    return pSafeArray;
}

//
// CreateSafeArrayDescriptorForArrayRef creates a SAFEARRAY with the appropriate
// type & dimensions & data for the given array ref.  The data is initialized to
// zero if necessary for safe destruction.
//

SAFEARRAY *OleVariant::CreateSafeArrayForArrayRef(BASEARRAYREF *pArrayRef, VARTYPE vt,
                                                  MethodTable *pInterfaceMT)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT_PROTECTED(pArrayRef);
    _ASSERTE(pArrayRef && *pArrayRef != NULL);
    _ASSERTE(vt != VT_EMPTY);

    // Validate that the type of the managed array is the expected type.
    if (!IsValidArrayForSafeArrayElementType(pArrayRef, vt))
    {
        COMPlusThrow(kSafeArrayTypeMismatchException);
    }

    // For structs and interfaces, verify that the array is of the valid type.
    if (vt == VT_RECORD || vt == VT_UNKNOWN || vt == VT_DISPATCH)
    {
        if (pInterfaceMT && !GetArrayElementTypeWrapperAware(pArrayRef).CanCastTo(TypeHandle(pInterfaceMT)))
            COMPlusThrow(kSafeArrayTypeMismatchException);
    }

    SAFEARRAY *pSafeArray = CreateSafeArrayDescriptorForArrayRef(pArrayRef, vt, pInterfaceMT);
    
    HRESULT hr = SafeArrayAllocData(pSafeArray);
    if (FAILED(hr))
    {
        SafeArrayDestroy(pSafeArray);
        COMPlusThrowHR(hr);
    }

    return pSafeArray;
}

//
// CreateArrayRefForSafeArray creates an array object with the same layout and type
// as the given safearray.  The variant type of the safearray must be passed in.  
// The underlying element method table may also be specified (or NULL may be passed in 
// to use the base class method table for the VARTYPE.
//

BASEARRAYREF OleVariant::CreateArrayRefForSafeArray(SAFEARRAY *pSafeArray, VARTYPE vt, 
                                                    MethodTable *pElementMT)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle arrayType;
    DWORD *pAllocateArrayArgs;
    int cAllocateArrayArgs;
    int Rank;
    VARTYPE SafeArrayVT;
    
    _ASSERTE(pSafeArray);
    _ASSERTE(vt != VT_EMPTY);
    
    // Validate that the type of the SAFEARRAY is the expected type.
    if (SUCCEEDED(ClrSafeArrayGetVartype(pSafeArray, &SafeArrayVT)) && (SafeArrayVT != VT_EMPTY))
    {
        if ((SafeArrayVT != vt) &&
            !(vt == VT_INT && SafeArrayVT == VT_I4) &&
            !(vt == VT_UINT && SafeArrayVT == VT_UI4) &&
            !(vt == VT_I4 && SafeArrayVT == VT_INT) &&
            !(vt == VT_UI4 && SafeArrayVT == VT_UINT) &&
            !(vt == VT_UNKNOWN && SafeArrayVT == VT_DISPATCH))
        {
            COMPlusThrow(kSafeArrayTypeMismatchException);
        }
    }
    else
    {
        UINT ArrayElemSize = SafeArrayGetElemsize(pSafeArray);
        if (ArrayElemSize != GetElementSizeForVarType(vt, NULL))
        {
            COMPlusThrow(kSafeArrayTypeMismatchException, IDS_EE_SAFEARRAYTYPEMISMATCH);
        }
    }

    // Determine if the input SAFEARRAY can be converted to an SZARRAY.
    if ((pSafeArray->cDims == 1) && (pSafeArray->rgsabound->lLbound == 0))
    {
        // The SAFEARRAY maps to an SZARRAY. For SZARRAY's AllocateArrayEx() 
        // expects the arguments to be a pointer to the cound of elements in the array
        // and the size of the args must be set to 1.
        Rank = 1;
        cAllocateArrayArgs = 1;
        pAllocateArrayArgs = &pSafeArray->rgsabound[0].cElements;
    }
    else
    {
        // The SAFEARRAY maps to an general array. For general arrays AllocateArrayEx() 
        // expects the arguments to be composed of the lower bounds / element count pairs
        // for each of the dimensions. We need to reverse the order that the lower bounds 
        // and element pairs are presented before we call AllocateArrayEx().
        Rank = pSafeArray->cDims;
        cAllocateArrayArgs = Rank * 2;
        pAllocateArrayArgs = (DWORD*)_alloca(sizeof(DWORD) * Rank * 2);
        DWORD *pBoundsPtr = pAllocateArrayArgs;

        // Copy the lower bounds and count of elements for the dimensions. These
        // need to copied in reverse order.
        for (int i = Rank - 1; i >= 0; i--)
        {
            *pBoundsPtr++ = pSafeArray->rgsabound[i].lLbound;
            *pBoundsPtr++ = pSafeArray->rgsabound[i].cElements;
        }
    }

    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);

    // Retrieve the type of the array.
    arrayType = GetArrayForVarType(vt, pElementMT, Rank, &Throwable);
    if (arrayType.IsNull())
        COMPlusThrow(Throwable);

    GCPROTECT_END();

    // Allocate the array. 
    return (BASEARRAYREF) AllocateArrayEx(arrayType, pAllocateArrayArgs, cAllocateArrayArgs);
}

/* ------------------------------------------------------------------------- *
 * Safearray marshaling
 * ------------------------------------------------------------------------- */

//
// MarshalSafeArrayForArrayRef marshals the contents of the array ref into the given
// safe array. It is assumed that the type & dimensions of the arrays are compatible.
//
void OleVariant::MarshalSafeArrayForArrayRef(BASEARRAYREF *pArrayRef, 
                                             SAFEARRAY *pSafeArray,
                                             VARTYPE vt,
                                             MethodTable *pInterfaceMT)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT_PROTECTED(pArrayRef);

    _ASSERTE(pSafeArray != NULL);
    _ASSERTE(pArrayRef != NULL && *pArrayRef != NULL);
    _ASSERTE(vt != VT_EMPTY);

    // Retrieve the size and number of components.
    int dwComponentSize = GetElementSizeForVarType(vt, pInterfaceMT);
    int dwNumComponents = (*pArrayRef)->GetNumComponents();
    BASEARRAYREF Array = NULL;

    GCPROTECT_BEGIN(Array)
    {
        // Retrieve the marshaler to use to convert the contents.
        Marshaler *marshal = GetMarshalerForVarType(vt);

        // If the array is an array of wrappers, then we need to extract the objects
        // being wrapped and create an array of those.
        if (IsArrayOfWrappers(pArrayRef))
            Array = ExtractWrappedObjectsFromArray(pArrayRef);
        else 
            Array = *pArrayRef;

        if (marshal == NULL || marshal->ComToOleArray == NULL)
        {
            if (pSafeArray->cDims == 1)
            {
                // If the array is single dimensionnal then we can simply copy it over.
                memcpyNoGCRefs(pSafeArray->pvData, Array->GetDataPtr(), dwNumComponents * dwComponentSize);
            }
            else
            {
                // Copy and transpose the data.
                TransposeArrayData((BYTE*)pSafeArray->pvData, Array->GetDataPtr(), dwNumComponents, dwComponentSize, pSafeArray, FALSE, FALSE);
            }
        }
        else
        {
            OBJECTHANDLE handle = GetAppDomain()->CreatePinningHandle((OBJECTREF)Array);

            marshal->ComToOleArray(&Array, pSafeArray->pvData, pInterfaceMT);

            DestroyPinningHandle(handle);

            if (pSafeArray->cDims != 1)
            {
                // The array is multidimensionnal we need to transpose it.
                TransposeArrayData((BYTE*)pSafeArray->pvData, (BYTE*)pSafeArray->pvData, dwNumComponents, dwComponentSize, pSafeArray, FALSE, FALSE);
            }
        }
    }
    GCPROTECT_END();
}

//
// MarshalArrayRefForSafeArray marshals the contents of the safe array into the given
// array ref. It is assumed that the type & dimensions of the arrays are compatible.
//

void OleVariant::MarshalArrayRefForSafeArray(SAFEARRAY *pSafeArray, 
                                             BASEARRAYREF *pArrayRef,
                                             VARTYPE vt,
                                             MethodTable *pInterfaceMT)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT_PROTECTED(pArrayRef);

    _ASSERTE(pSafeArray != NULL);
    _ASSERTE(pArrayRef != NULL && *pArrayRef != NULL);
    _ASSERTE(vt != VT_EMPTY);

    // Retrieve the size and number of components.
    int dwComponentSize = (*pArrayRef)->GetComponentSize();
    int dwNumComponents = (*pArrayRef)->GetNumComponents();

    // Retrieve the marshaler to use to convert the contents.
    Marshaler *marshal = GetMarshalerForVarType(vt);

    if (marshal == NULL || marshal->OleToComArray == NULL)
    {
#ifdef _DEBUG
        {
            // If we're blasting bits, this better be a primitive type.  Currency is
            // an I8 on managed & unmanaged, so it's good enough.
            TypeHandle  th = (*pArrayRef)->GetElementTypeHandle();

            if (!CorTypeInfo::IsPrimitiveType(th.GetNormCorElementType()))
            {
                _ASSERTE(!strcmp(th.AsMethodTable()->GetClass()->m_szDebugClassName,
                                 "System.Currency"));
            }
        }
#endif
        if (pSafeArray->cDims == 1)
        {
            // If the array is single dimensionnal then we can simply copy it over.
            memcpyNoGCRefs((*pArrayRef)->GetDataPtr(), pSafeArray->pvData, dwNumComponents * dwComponentSize);
        }
        else
        {
            // Copy and transpose the data.
            TransposeArrayData((*pArrayRef)->GetDataPtr(), (BYTE*)pSafeArray->pvData, dwNumComponents, dwComponentSize, pSafeArray, TRUE, FALSE);
        }
    }
    else
    {
        OBJECTHANDLE handle = GetAppDomain()->CreatePinningHandle((OBJECTREF)*pArrayRef);

        marshal->OleToComArray(pSafeArray->pvData, pArrayRef,
                               pInterfaceMT);

        if (pSafeArray->cDims != 1)
        {
            // The array is multidimensionnal we need to transpose it.
            BOOL bIsObjRef = (TYPE_GC_REF == CorTypeInfo::GetGCType((*pArrayRef)->GetElementTypeHandle().GetNormCorElementType()));

            //BOOL bIsObjRef = !CorTypeInfo::IsPrimitiveType((*pArrayRef)->GetElementTypeHandle().GetNormCorElementType());
            TransposeArrayData((*pArrayRef)->GetDataPtr(), (*pArrayRef)->GetDataPtr(), dwNumComponents, dwComponentSize, pSafeArray, TRUE, bIsObjRef);
        }

        DestroyPinningHandle(handle);
    }
}

void OleVariant::ConvertValueClassToVariant(OBJECTREF *pBoxedValueClass, VARIANT *pOleVariant)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    ITypeInfo *pTypeInfo = NULL;
    BOOL bSuccess = FALSE;

    // Initialize the OLE variant's VT_RECORD fields to NULL.
    pOleVariant->pRecInfo = NULL;
    pOleVariant->pvRecord = NULL;

    EE_TRY_FOR_FINALLY
    {
        // Retrieve the ITypeInfo for the value class.
        EEClass *pValueClass = (*pBoxedValueClass)->GetClass();   
        IfFailThrow(GetITypeInfoForEEClass(pValueClass, &pTypeInfo, TRUE, TRUE, 0));

        // Convert the ITypeInfo to an IRecordInfo.
        IfFailThrow(GetRecordInfoFromTypeInfo(pTypeInfo, &pOleVariant->pRecInfo));

        // Allocate an instance of the record.
        pOleVariant->pvRecord = pOleVariant->pRecInfo->RecordCreate();
        IfNullThrow(pOleVariant->pvRecord);

        // Marshal the contents of the value class into the record.
        FmtClassUpdateNative(pBoxedValueClass, (BYTE*)pOleVariant->pvRecord);

        // Set the bSuccess flag to indicate we successfully set up
        // the OLE variant.
        bSuccess = TRUE;
    }
    EE_FINALLY
    {
        // Release the ITypeInfo regardless of the success of the operation.
        if (pTypeInfo)
            pTypeInfo->Release();

        // If we failed to set up the OLE variant, then release all the 
        // fields we might have set in the variant.
        if (!bSuccess)
        {
            if (pOleVariant->pvRecord)
                pOleVariant->pRecInfo->RecordDestroy(pOleVariant->pvRecord);
            if (pOleVariant->pRecInfo)
                pOleVariant->pRecInfo->Release();
        }
    }
    EE_END_FINALLY; 
}

void OleVariant::TransposeArrayData(BYTE *pDestData, BYTE *pSrcData, DWORD dwNumComponents, DWORD dwComponentSize, SAFEARRAY *pSafeArray, BOOL bSafeArrayToMngArray, BOOL bObjRefs)
{
    int iDims;
    DWORD *aDestElemCount = (DWORD*)_alloca(pSafeArray->cDims * sizeof(DWORD));
    DWORD *aDestIndex = (DWORD*)_alloca(pSafeArray->cDims * sizeof(DWORD));
    BYTE **aDestDataPos = (BYTE **)_alloca(pSafeArray->cDims * sizeof(BYTE *));
    DWORD *aDestDelta = (DWORD*)_alloca(pSafeArray->cDims * sizeof(DWORD));
    CQuickArray<BYTE> TmpArray;

    // If there are no components, then there we are done.
    if (dwNumComponents == 0)
        return;

    // Check to see if we are transposing in place or copying and transposing.
    if (pSrcData == pDestData)
    {
        // @perf(DM): Find a way to avoid the extra copy.
        TmpArray.ReSize(dwNumComponents * dwComponentSize);
        memcpyNoGCRefs(TmpArray.Ptr(), pSrcData, dwNumComponents * dwComponentSize);
        pSrcData = TmpArray.Ptr();
    }

    // Copy the element count in reverse order if we are copying from a safe array to
    // a managed array and in direct order otherwise.
    if (bSafeArrayToMngArray)
    {
        for (iDims = 0; iDims < pSafeArray->cDims; iDims++)
            aDestElemCount[iDims] = pSafeArray->rgsabound[pSafeArray->cDims - iDims - 1].cElements;
    }
    else
    {
        for (iDims = 0; iDims < pSafeArray->cDims; iDims++)
            aDestElemCount[iDims] = pSafeArray->rgsabound[iDims].cElements;
    }

    // Initalize the indexes for each dimension to 0.
    memset(aDestIndex, 0, pSafeArray->cDims * sizeof(int));

    // Set all the destination data positions to the start of the array.
    for (iDims = 0; iDims < pSafeArray->cDims; iDims++)
        aDestDataPos[iDims] = (BYTE*)pDestData;

    // Calculate the destination delta for each of the dimensions.
    aDestDelta[pSafeArray->cDims - 1] = dwComponentSize;
    for (iDims = pSafeArray->cDims - 2; iDims >= 0; iDims--)
        aDestDelta[iDims] = aDestDelta[iDims + 1] * aDestElemCount[iDims + 1];

    // Calculate the source data end pointer.
    BYTE *pSrcDataEnd = pSrcData + dwNumComponents * dwComponentSize;
    _ASSERTE(pDestData < pSrcData || pDestData >= pSrcDataEnd);

    // Copy and transpose the data.
    while (TRUE)
    {
        // Copy one component.
        if (bObjRefs)
        {
            _ASSERTE(sizeof(OBJECTREF*) == dwComponentSize);
            SetObjectReferenceUnchecked((OBJECTREF*)aDestDataPos[0], ObjectToOBJECTREF(*(Object**)pSrcData));  
        }
        else
        {
            memcpyNoGCRefs(aDestDataPos[0], pSrcData, dwComponentSize);
        }

        // Update the source position.
        pSrcData += dwComponentSize;

        // Check to see if we have reached the end of the array.
        if (pSrcData >= pSrcDataEnd)
            break;

        // Update the destination position.
        for (iDims = 0; aDestIndex[iDims] >= aDestElemCount[iDims] - 1; iDims++);

        _ASSERTE(iDims < pSafeArray->cDims); 

        aDestIndex[iDims]++;
        aDestDataPos[iDims] += aDestDelta[iDims];
        for (--iDims; iDims >= 0; iDims--)
        {
            aDestIndex[iDims] = 0;
            aDestDataPos[iDims] = aDestDataPos[iDims + 1];
        }
    }
}

BOOL OleVariant::Init()
{
    TypeHandle *pth = (TypeHandle*)m_aWrapperTypes;
    for (int i = 0; i < WrapperTypes_Last; i++)
    {
        pth[i] = TypeHandle();
    }
    return TRUE;
}

VOID OleVariant::Terminate()
{
}


TypeHandle OleVariant::GetWrapperTypeHandle(EnumWrapperTypes WrapperType)
{
    THROWSCOMPLUSEXCEPTION();

    // The names of the wrappers.
    static BinderClassID aWrapperIDs[] = 
    {
        CLASS__DISPATCH_WRAPPER,
        CLASS__UNKNOWN_WRAPPER,
        CLASS__ERROR_WRAPPER,
        CLASS__CURRENCY_WRAPPER,
    };

    TypeHandle *pWrapperTypes = (TypeHandle*)m_aWrapperTypes;

    // Load the wrapper type if it hasn't already been loaded.
    if (pWrapperTypes[WrapperType].IsNull())
        pWrapperTypes[WrapperType] = g_Mscorlib.GetClass(aWrapperIDs[WrapperType]);

    // Return the wrapper type.
    return pWrapperTypes[WrapperType];
}

BOOL OleVariant::IsArrayOfWrappers(BASEARRAYREF *pArray)
{
    TypeHandle hndElemType = (*pArray)->GetElementTypeHandle();

    if (hndElemType.IsUnsharedMT()) 
    {
        if (hndElemType == GetWrapperTypeHandle(WrapperTypes_Dispatch) ||
            hndElemType == GetWrapperTypeHandle(WrapperTypes_Unknown) ||
            hndElemType == GetWrapperTypeHandle(WrapperTypes_Error) ||
            hndElemType == GetWrapperTypeHandle(WrapperTypes_Currency))
        {
            return TRUE;      
        }
    }

    return FALSE;
}

BASEARRAYREF OleVariant::ExtractWrappedObjectsFromArray(BASEARRAYREF *pArray)
{
    TypeHandle hndWrapperType = (*pArray)->GetElementTypeHandle();
    TypeHandle hndElemType;
    TypeHandle hndArrayType;
    BOOL bIsMDArray = (*pArray)->IsMultiDimArray();
    unsigned rank = (*pArray)->GetRank();
    BASEARRAYREF RetArray = NULL;
   
    // Retrieve the element type handle for the array to create.
    if (hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Dispatch))
        hndElemType = TypeHandle(g_Mscorlib.GetClass(CLASS__OBJECT));
    else if (hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Unknown))
        hndElemType = TypeHandle(g_Mscorlib.GetClass(CLASS__OBJECT));
    else if (hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Error))
        hndElemType = TypeHandle(g_Mscorlib.GetClass(CLASS__INT32));
    else if (hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Currency))
        hndElemType = TypeHandle(g_Mscorlib.GetClass(CLASS__DECIMAL));
    else
        _ASSERTE(!"Invalid wrapper type");

    // Retrieve the type handle that represents the array.
    if (bIsMDArray)
    {
        hndArrayType = SystemDomain::Loader()->FindArrayForElem(hndElemType, ELEMENT_TYPE_ARRAY, rank);
    }
    else
    {
        hndArrayType = SystemDomain::Loader()->FindArrayForElem(hndElemType, ELEMENT_TYPE_SZARRAY);
    }
    _ASSERTE(!hndArrayType.IsNull());


    // Set up the bounds arguments.
    DWORD numArgs =  rank*2;
    DWORD* args = (DWORD*) _alloca(sizeof(DWORD)*numArgs);
    if (bIsMDArray)
    {
        const DWORD* bounds = (*pArray)->GetBoundsPtr();
        const DWORD* lowerBounds = (*pArray)->GetLowerBoundsPtr();
        for(unsigned int i=0; i < rank; i++) 
        {
            args[2*i]   = lowerBounds[i];
            args[2*i+1] = bounds[i];
        }
    }
    else
    {
        numArgs = 1;
        args[0] = (*pArray)->GetNumComponents();
    }

    // Extract the valus from the source array and copy them into the destination array.
    BASEARRAYREF DestArray = (BASEARRAYREF)AllocateArrayEx(hndArrayType, args, numArgs, FALSE);
    GCPROTECT_BEGIN(DestArray)
    {
        int NumComponents = (*pArray)->GetNumComponents();
        AppDomain *pDomain = DestArray->GetAppDomain();

        if (hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Dispatch))
        {
            DISPATCHWRAPPEROBJECTREF *pSrc = (DISPATCHWRAPPEROBJECTREF *)(*pArray)->GetDataPtr();
            DISPATCHWRAPPEROBJECTREF *pSrcEnd = pSrc + NumComponents;
            OBJECTREF *pDest = (OBJECTREF *)DestArray->GetDataPtr();
            for (; pSrc < pSrcEnd; pSrc++, pDest++)
                SetObjectReference(pDest, (*pSrc)->GetWrappedObject(), pDomain);
        }
        else if (hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Unknown))
        {
            UNKNOWNWRAPPEROBJECTREF *pSrc = (UNKNOWNWRAPPEROBJECTREF *)(*pArray)->GetDataPtr();
            UNKNOWNWRAPPEROBJECTREF *pSrcEnd = pSrc + NumComponents;
            OBJECTREF *pDest = (OBJECTREF *)DestArray->GetDataPtr();
            for (; pSrc < pSrcEnd; pSrc++, pDest++)
                SetObjectReference(pDest, (*pSrc)->GetWrappedObject(), pDomain);
        }
        else if (hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Error))
        {
            ERRORWRAPPEROBJECTREF *pSrc = (ERRORWRAPPEROBJECTREF *)(*pArray)->GetDataPtr();
            ERRORWRAPPEROBJECTREF *pSrcEnd = pSrc + NumComponents;
            INT32 *pDest = (INT32 *)DestArray->GetDataPtr();
            for (; pSrc < pSrcEnd; pSrc++, pDest++)
                *pDest = (*pSrc)->GetErrorCode();
        }
        else if (hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Currency))
        {
            CURRENCYWRAPPEROBJECTREF *pSrc = (CURRENCYWRAPPEROBJECTREF *)(*pArray)->GetDataPtr();
            CURRENCYWRAPPEROBJECTREF *pSrcEnd = pSrc + NumComponents;
            DECIMAL *pDest = (DECIMAL *)DestArray->GetDataPtr();
            for (; pSrc < pSrcEnd; pSrc++, pDest++)
                memcpyNoGCRefs(pDest, &(*pSrc)->GetWrappedObject(), sizeof(DECIMAL));
        }
        else
        {
            _ASSERTE(!"Invalid wrapper type");
        }

        // GCPROTECT_END() will wack NewArray so we need to copy the OBJECTREF into
        // a temp to be able to return it.
        RetArray = DestArray;
    }
    GCPROTECT_END();

    return RetArray;
}

TypeHandle OleVariant::GetWrappedArrayElementType(BASEARRAYREF *pArray)
{
    TypeHandle hndWrapperType = (*pArray)->GetElementTypeHandle();
    TypeHandle pWrappedObjType;
   
    int NumComponents = (*pArray)->GetNumComponents();

    if ((hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Dispatch)))
    {
        DISPATCHWRAPPEROBJECTREF *pSrc = (DISPATCHWRAPPEROBJECTREF *)(*pArray)->GetDataPtr();
        DISPATCHWRAPPEROBJECTREF *pSrcEnd = pSrc + NumComponents;
        for (; pSrc < pSrcEnd; pSrc++)
        {
            OBJECTREF WrappedObj = (*pSrc)->GetWrappedObject();
            if (WrappedObj != NULL)
            {
                pWrappedObjType = WrappedObj->GetTypeHandle();
                break;
            }
        }
    }
    else if ((hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Unknown)))
    {
        UNKNOWNWRAPPEROBJECTREF *pSrc = (UNKNOWNWRAPPEROBJECTREF *)(*pArray)->GetDataPtr();
        UNKNOWNWRAPPEROBJECTREF *pSrcEnd = pSrc + NumComponents;
        for (; pSrc < pSrcEnd; pSrc++)
        {
            OBJECTREF WrappedObj = (*pSrc)->GetWrappedObject();
            if (WrappedObj != NULL)
            {
                pWrappedObjType = WrappedObj->GetTypeHandle();
                break;
            }
        }
    }
    else if (hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Error))
    {
        pWrappedObjType = TypeHandle(g_Mscorlib.GetClass(CLASS__INT32));
    }
    else if (hndWrapperType == GetWrapperTypeHandle(WrapperTypes_Currency))
    {
        pWrappedObjType = TypeHandle(g_Mscorlib.GetClass(CLASS__DECIMAL));
    }
    else
    {
        _ASSERTE(!"Invalid wrapper type");
    }

    return pWrappedObjType;
}

TypeHandle OleVariant::GetArrayElementTypeWrapperAware(BASEARRAYREF *pArray)
{
    TypeHandle elemType;
    if (IsArrayOfWrappers(pArray))
        elemType = GetWrappedArrayElementType(pArray).GetMethodTable();
    else
        elemType = (*pArray)->GetElementTypeHandle().GetMethodTable();
    return elemType;
}

TypeHandle OleVariant::GetElementTypeForRecordSafeArray(SAFEARRAY* pSafeArray)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    IRecordInfo *pRecInfo = NULL;
    TypeHandle ElemType;

    EE_TRY_FOR_FINALLY
    {  
        GUID guid;
        IfFailThrow(SafeArrayGetRecordInfo(pSafeArray, &pRecInfo));
        IfFailThrow(pRecInfo->GetGuid(&guid));
        EEClass *pValueClass = GetEEValueClassForGUID(guid);
        if (!pValueClass)
            COMPlusThrow(kArgumentException, IDS_EE_CANNOT_MAP_TO_MANAGED_VC);
        ElemType = TypeHandle(pValueClass);
    }
    EE_FINALLY
    {
        if (pRecInfo)
            pRecInfo->Release();
    }
    EE_END_FINALLY; 

    return ElemType;
}

void OleVariant::MarshalInterfaceArrayComToOleHelper(BASEARRAYREF *pComArray, void *oleArray,
                                                     MethodTable *pElementMT, BOOL bDefaultIsDispatch)
{
    ASSERT_PROTECTED(pComArray);
    SIZE_T elementCount = (*pComArray)->GetNumComponents();
    BOOL bDispatch = bDefaultIsDispatch;

    // If the method table is for Object then don't consider it.
    if (pElementMT == g_pObjectClass)
        pElementMT = NULL;

    // If the element MT represents a class, then we need to determine the default
    // interface to use to expose the object out to COM.
    if (pElementMT && !pElementMT->IsInterface())
    {
        TypeHandle hndDefItfClass;
        DefaultInterfaceType DefItfType = GetDefaultInterfaceForClass(TypeHandle(pElementMT), &hndDefItfClass);
        switch (DefItfType)
        {
            case DefaultInterfaceType_Explicit:
            case DefaultInterfaceType_AutoDual:
            {
                pElementMT = hndDefItfClass.GetMethodTable();
                break;
            }

            case DefaultInterfaceType_IUnknown:
            case DefaultInterfaceType_BaseComClass:
            {
                bDispatch = FALSE;
                pElementMT = NULL;
                break;
            }

            case DefaultInterfaceType_AutoDispatch:
            {
                bDispatch = TRUE;
                pElementMT = NULL;
                break;
            }

            default:
            {
                _ASSERTE(!"Invalid default interface type!");
                break;
            }
        }
    }

    // Determine the start and the end of the data in the OLE array.
    IUnknown **pOle = (IUnknown **) oleArray;
    IUnknown **pOleEnd = pOle + elementCount;

    // Retrieve the start of the data in the managed array.
    BASEARRAYREF unprotectedArray = *pComArray;
    OBJECTREF *pCom = (OBJECTREF *) unprotectedArray->GetDataPtr();

    OBJECTREF TmpObj = NULL;
    GCPROTECT_BEGIN(TmpObj)
    {
        if (pElementMT)
        {
            while (pOle < pOleEnd)
            {
                TmpObj = *pCom++;

                IUnknown *unk;
                if (TmpObj == NULL)
                    unk = NULL;
                else
                    unk = GetComIPFromObjectRef(&TmpObj, pElementMT);

                *pOle++ = unk;

                if (*(void **)&unprotectedArray != *(void **)&*pComArray)
                {
                    SIZE_T currentOffset = ((BYTE *)pCom) - (*(Object **) &unprotectedArray)->GetAddress();
                    unprotectedArray = *pComArray;
                    pCom = (OBJECTREF *) (unprotectedArray->GetAddress() + currentOffset);
                }
            }
        }
        else
        {
            ComIpType ReqIpType = bDispatch ? ComIpType_Dispatch : ComIpType_Unknown;

            while (pOle < pOleEnd)
            {
                TmpObj = *pCom++;

                IUnknown *unk;
                if (TmpObj == NULL)
                    unk = NULL;
                else
                    unk = GetComIPFromObjectRef(&TmpObj, ReqIpType, NULL);

                *pOle++ = unk;

                if (*(void **)&unprotectedArray != *(void **)&*pComArray)
                {
                    SIZE_T currentOffset = ((BYTE *)pCom) - (*(Object **) &unprotectedArray)->GetAddress();
                    unprotectedArray = *pComArray;
                    pCom = (OBJECTREF *) (unprotectedArray->GetAddress() + currentOffset);
                }
            }
        }
    }
    GCPROTECT_END();
}

void OleVariant::MarshalBSTRArrayComToOleWrapper(BASEARRAYREF *pComArray, void *oleArray)
{
    MarshalBSTRArrayComToOle(pComArray, oleArray, NULL);
}

void OleVariant::MarshalBSTRArrayOleToComWrapper(void *oleArray, BASEARRAYREF *pComArray)
{
    MarshalBSTRArrayOleToCom(oleArray, pComArray, NULL);
}

void OleVariant::ClearBSTRArrayWrapper(void *oleArray, SIZE_T cElements)
{
    ClearBSTRArray(oleArray, cElements, NULL);
}

#ifdef CUSTOMER_CHECKED_BUILD

// Used by customer checked build to test validity of VARIANT

BOOL OleVariant::CheckVariant(VARIANT* pOle)
{
    BOOL bValidVariant = TRUE;

    if (!pOle)
        bValidVariant = FALSE;
    else
    {
        try
        {
            VARIANT pOleCopy;
            VariantInit(&pOleCopy);

            BEGIN_ENSURE_PREEMPTIVE_GC();
            if (VariantCopy(&pOleCopy, pOle) != S_OK)
                bValidVariant = FALSE;
            else
                VariantClear(&pOleCopy);
            END_ENSURE_PREEMPTIVE_GC();
        }
        catch (...)
        {
            bValidVariant = FALSE;
        }
    }

    return bValidVariant;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\orefcache.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------------
// ObjectRefCache
//
// Implementation of handle table for write-once object references
//
//%%Created by: rajak
//---------------------------------------------------------------------------------
#ifndef _H_OREFCACHE_
#define _H_OREFCACHE_

#include "common.h"
#include "object.h"


//---------------------------------------------------------------------------------
// class ObjectRefCache
// 

#pragma pack(push)
#pragma pack(1)

//Ref Block
class RefBlock
{
public:
    enum
    {
        numRefs = 12
    };

    RefBlock()
    {
        // no virtual functions
        memset(this, 0, sizeof(RefBlock));
    }

    DLink       m_link;         // link to the next block
    DWORD       m_generation;   // generation for this block
    union
    {
        DWORD       m_reserved;     // reserved
        struct
        {
            USHORT  m_cbLast; // last unused slot
            USHORT  m_cbFree; // count of slots freed
        };
    };

    OBJECTREF m_rgRefs[numRefs];     // reference cache
};

#pragma pack(pop)


//Ref cache
class ObjectRefCache
{
public:
    typedef DList<RefBlock, offsetof(RefBlock,m_link)> REFBLOCKLIST;
    //@todo add gc support
    // refblock list
    REFBLOCKLIST    m_refBlockList;
    
    //@Methods
    OBJECTREF* GetObjectRefPtr(OBJECTREF objref);
    // statics
    static void ReleaseObjectRef(OBJECTREF* pobjref);
    
    static ObjectRefCache*  s_pRefCache;

    ObjectRefCache()
    {
        m_refBlockList.Init();
    }
    ~ObjectRefCache();

    // one time init
    static BOOL Init();
    // one time cleamup
#ifdef SHOULD_WE_CLEANUP
    static void Terminate();
#endif /* SHOULD_WE_CLEANUP */
    // accessor to ObjectRefCache
    static ObjectRefCache* GetObjectRefCache()
    {
        _ASSERTE(s_pRefCache != NULL);
        return s_pRefCache;
    }
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\permset.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Used for loading permissions into the runtime
//*****************************************************************************

#ifndef _PERMSET_H
#define _PERMSET_H

#include "vars.hpp"
#include "CorPermP.h"
#include "eehash.h"

enum SpecialPermissionSetFlag
{
    // These also appear in clr/src/bcl/system/security/util/config.cs
    Regular = 0,
    NoSet = 1,
    EmptySet = 2,
    SkipVerification = 3
};

struct PermissionRequestSpecialFlags
{
    PermissionRequestSpecialFlags()
        : required( NoSet ),
          optional( NoSet ),
          refused( NoSet )
    {
    }

    SpecialPermissionSetFlag required;
    SpecialPermissionSetFlag optional;
    SpecialPermissionSetFlag refused;
};


// All out parameters use MallocM/FreeM macros defined in the CorPermE.h. 
// There are no serparately allocated internal pointers. All memory is 
// released with outter most pointer is freed.

// Records a serialized permission set we've seen and decoded. This entry
// exists both in a global dynamic array (which gives it an index used to
// identify the pset across appdomains) and chained into a hash (which
// allows us look for existing entries quickly when decoding new psets).
struct PsetCacheEntry
{
    EEHashEntry m_sHashEntry;
    PBYTE       m_pbPset;
    DWORD       m_cbPset;
    DWORD       m_dwIndex;
    SpecialPermissionSetFlag m_SpecialFlags;

    PsetCacheEntry(PBYTE pbPset, DWORD cbPset) :
        m_pbPset(pbPset),
        m_cbPset(cbPset)
    {}

    BOOL IsEquiv(PsetCacheEntry *pOther)
    {
        if (m_cbPset != pOther->m_cbPset)
            return FALSE;
        return memcmp(m_pbPset, pOther->m_pbPset, m_cbPset) == 0;
    }

    DWORD Hash()
    {
        DWORD dwHash = 0;
        for (DWORD i = 0; i < (m_cbPset / sizeof(DWORD)); i++)
            dwHash ^= ((DWORD*)m_pbPset)[i];
        return dwHash;
    }
};

class SecurityHelper {
public:

    static VOID Init();
    static VOID Shutdown();

    static HRESULT MapToHR(OBJECTREF ref);

    // Loads up the permission, will throw COMPLUS exceptions
    static void LoadPermissionSet(IN PBYTE              pbRawPermissions,
                                  IN DWORD              cbRawPermissions,
                                  OUT OBJECTREF        *pRef,
                                  OUT BOOL             *pFullyTrusted,
                                  OUT DWORD            *pdwSetIndex = NULL,
                                  IN BOOL               fNoCache = FALSE,
                                  OUT SpecialPermissionSetFlag *pSpecialFlags = NULL,
                                  IN BOOL               fCreate = TRUE);

    // Retrieves a previously loaded permission set by index (this will work
    // even if the permission set was loaded in a different appdomain).
    static OBJECTREF GetPermissionSet(DWORD dwIndex, SpecialPermissionSetFlag *specialFlags = NULL);

    // Locate the index of a permission set in the cache (returns false if the
    // permission set has not yet been seen and decoded).
    static BOOL LookupPermissionSet(IN PBYTE       pbPset,
                                    IN DWORD       cbPset,
                                    OUT DWORD     *pdwSetIndex);

    // Creates a new permission vector.
    static OBJECTREF CreatePermissionSet(BOOL fTrusted);

    // Uses MallocM to create the byte array that is returned.
    static void CopyByteArrayToEncoding(IN U1ARRAYREF* pArray,
                                        OUT PBYTE* pbData,
                                        OUT DWORD* cbData);

    static void CopyStringToWCHAR(IN STRINGREF* pString,
                                  OUT WCHAR** ppwString,
                                  OUT DWORD*  pdwString);
    
    static void EncodePermissionSet(IN OBJECTREF* pRef,
                                    OUT PBYTE* ppbData,
                                    OUT DWORD* pcbData);
    
    // Generic routine, use with encoding calls that 
    // use the EncodePermission client data
    // Uses MallocM to create the byte array that is returned.
    static void CopyEncodingToByteArray(IN PBYTE   pbData,
                                        IN DWORD   cbData,
                                        IN OBJECTREF* pArray);

    static void LoadPermissionRequestsFromAssembly(IN Assembly*     pAssembly,
                                                   OUT OBJECTREF*   pReqdPermissions,
                                                   OUT OBJECTREF*   pOptPermissions,
                                                   OUT OBJECTREF*   pDenyPermissions,
                                                   OUT PermissionRequestSpecialFlags* pSpecialFlags = NULL,
                                                   BOOL             fCreate = TRUE);

    static BOOL PermissionsRequestedInAssembly(IN  Assembly* pAssembly);

    // Returns the declared permissions for the specified action type.
    static HRESULT GetDeclaredPermissions(IN IMDInternalImport *pInternalImport,
                                          IN mdToken classToken,
                                          IN CorDeclSecurity action,
                                          OUT OBJECTREF *pDeclaredPermissions,
                                          OUT SpecialPermissionSetFlag* pSpecialFlags = NULL,
                                          BOOL fCreate = TRUE);


private:
    // Insert a decoded permission set into the cache. Duplicates are discarded.
    static BOOL InsertPermissionSet(IN PBYTE       pbPset,
                                    IN DWORD       cbPset,
                                    IN OBJECTREF   orPset,
                                    OUT SpecialPermissionSetFlag *pdwSpecialFlags,
                                    OUT DWORD     *pdwSetIndex);

    static BOOL TrustMeIAmSafe(void *pLock) {
        return TRUE;
    }

    // Managed helpers.
    static MethodDesc *s_pMarshalObjectMD;
    static MethodDesc *s_pMarshalObjectsMD;
    static MethodDesc *s_pUnmarshalObjectMD;
    static MethodDesc *s_pUnmarshalObjectsMD;

    static MethodDesc *FindAppDomainMethod(LPUTF8 szName, LPHARDCODEDMETASIG pSig, MethodDesc **ppMD);

    friend EEPsetHashTableHelper;
    static CQuickArray<PsetCacheEntry> s_rCachedPsets;
    static EEPsetHashTable s_sCachedPsetsHash;
    static SimpleRWLock * s_prCachedPsetsLock;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\pefile.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: PEFILE.H
// 

// PEFILE.H defines the class use to represent the PE file
// ===========================================================================
#ifndef PEFILE_H_
#define PEFILE_H_

#include <windows.h>
#include <wtypes.h> // for HFILE, HANDLE, HMODULE
#include <fusion.h>
#include <fusionpriv.h>
#include "vars.hpp" // for LPCUTF8
#include "hash.h"
#include "cormap.hpp"
#ifdef METADATATRACKER_ENABLED
#include "metadatatracker.h"
#endif // METADATATRACKER_ENABLED
#include <member-offset-info.h>

//
// A PEFile is the runtime's abstraction of an executable image.
// It may or may not have an actual file associated with it.  PEFiles
// exist mostly to be turned into Modules later.
//

enum PEFileFlags {
    PEFILE_SYSTEM = 0x1,
    PEFILE_DISPLAY = 0x2,
    PEFILE_WEBPERM = 0x4
};

class PEFile
{
    friend HRESULT InitializeMiniDumpBlock();
    friend struct MEMBER_OFFSET_INFO(PEFile);
  private:

    WCHAR               m_wszSourceFile[MAX_PATH];

    HMODULE             m_hModule;
    HCORMODULE          m_hCorModule;
    BYTE                *m_base;
    IMAGE_NT_HEADERS    *m_pNT;
    IMAGE_COR20_HEADER  *m_pCOR;
    IMDInternalImport   *m_pMDInternalImport;
    LPCWSTR             m_pLoadersFileName;
    DWORD               m_flags;
    DWORD               m_dwUnmappedFileLen; //for resource files, Win9X, and byte[] files
    BOOL                m_fShouldFreeModule;
    BOOL                m_fHashesVerified; // For manifest files, have internal modules been verified by fusion
#ifdef METADATATRACKER_ENABLED
    MetaDataTracker    *m_pMDTracker;
#endif // METADATATRACKER_ENABLED

    PEFile();
    PEFile(PEFile *pFile);

    HRESULT GetFileNameFromImage();

    struct CEStuff
    {
        HMODULE hMod;
        LPVOID  pBase;
        DWORD   dwRva14;
        CEStuff *pNext;
    };

    static CEStuff *m_pCEStuff;

  public:

    ~PEFile();

    static HRESULT RegisterBaseAndRVA14(HMODULE hMod, LPVOID pBase, DWORD dwRva14);

    static HRESULT Create(HMODULE hMod, PEFile **ppFile, BOOL fShouldFree);
    static HRESULT Create(HCORMODULE hMod, PEFile **ppFile, BOOL fResource=FALSE);
    static HRESULT Create(LPCWSTR moduleNameIn,         // Name of the PE image
                          Assembly* pParent,            // If file is a module you need to pass in the Assembly
                          mdFile kFile,                 // File token in the parent assembly associated with the file
                          BOOL fIgnoreVerification,     // Do not check entry points before loading
                          IAssembly* pFusionAssembly,   // Fusion object associated with module
                          LPCWSTR pCodeBase,            // Location where image originated (if different from name)
                          OBJECTREF* pExtraEvidence,    // Evidence that relates to the image (eg. zone, URL)
                          PEFile **ppFile);             // Returns a PEFile
    static HRESULT Create(PBYTE pUnmappedPE, DWORD dwUnmappedPE, 
                          LPCWSTR imageNameIn,
                          LPCWSTR pLoadersFileName, 
                          OBJECTREF* pExtraEvidence,    // Evidence that relates to the image (eg. zone, URL)
                          PEFile **ppFile,              // Returns a PEFile
                          BOOL fResource);
    static HRESULT CreateResource(LPCWSTR moduleNameIn,         // Name of the PE image
                                  PEFile **ppFile);             // Returns a PEFile

    static HRESULT VerifyModule(HCORMODULE hModule,
                                Assembly* pParent,
                                IAssembly* pFusionAssembly, 
                                LPCWSTR pCodeBase,
                                OBJECTREF* pExtraEvidence,
                                LPCWSTR pName,
                                HCORMODULE *phModule,
                                PEFile** ppFile,
                                BOOL* pfPreBindAllowed);

    static HRESULT CreateImageFile(HCORMODULE hModule, 
                                   IAssembly* pFusionAssembly, 
                                   PEFile **ppFile);

    static HRESULT Clone(PEFile *pFile, PEFile **ppFile);

    BYTE *GetBase()
    { 
        return m_base; 
    }
    IMAGE_NT_HEADERS *GetNTHeader()
    { 
        return m_pNT; 
    }
    IMAGE_COR20_HEADER *GetCORHeader() 
    { 
        return m_pCOR; 
    }
    BYTE *RVAToPointer(DWORD rva);

    HCORMODULE GetCORModule()
    {
        return m_hCorModule;
    }
    HRESULT ReadHeaders();
    
    void ShouldDelete()
    {
        m_fShouldFreeModule = TRUE;
    }

    BOOL IsSystem() { return (m_flags & PEFILE_SYSTEM) != 0; }
    BOOL IsDisplayAsm() { return (m_flags & PEFILE_DISPLAY) != 0; }
    void SetDisplayAsm() { m_flags |= PEFILE_DISPLAY; }
    BOOL IsWebPermAsm() { return (m_flags & PEFILE_WEBPERM) != 0; }
    void SetWebPermAsm() { m_flags |= PEFILE_WEBPERM; }

    IMAGE_DATA_DIRECTORY *GetSecurityHeader();

    IMDInternalImport *GetMDImport(HRESULT *hr = NULL);
    IMDInternalImport *GetZapMDImport(HRESULT *hr = NULL);

    HRESULT GetMetadataPtr(LPVOID *ppMetadata);

    HRESULT VerifyFlags(DWORD flag, BOOL fZap);

    BOOL IsTLSAddress(void* address);
    IMAGE_TLS_DIRECTORY* GetTLSDirectory();

    HRESULT SetFileName(LPCWSTR codeBase);
    LPCWSTR GetFileName();
    LPCWSTR GetLeafFileName();

    LPCWSTR GetLoadersFileName();

    //for resource files, Win9X, and byte[] files
    DWORD GetUnmappedFileLength()
    {
        return m_dwUnmappedFileLen;
    }

    HRESULT FindCodeBase(WCHAR* pCodeBase, 
                         DWORD* pdwCodeBase);

    static HRESULT FindCodeBase(LPCWSTR pFileName, 
                                WCHAR* pCodeBase, 
                                DWORD* pdwCodeBase);

    

    HRESULT GetFileName(LPSTR name, DWORD max, DWORD *count);

    HRESULT VerifyDirectory(IMAGE_DATA_DIRECTORY *dir, DWORD dwForbiddenCharacteristics)
    {
        return CorMap::VerifyDirectory(m_pNT, dir, dwForbiddenCharacteristics);
    }

    void SetHashesVerified()
    {
        m_fHashesVerified = TRUE;
    }

    BOOL HashesVerified()
    {
        return m_fHashesVerified;
    }

    static HRESULT ReleaseFusionMetadataImport(IAssembly* pAsm);

    // These methods help with prejit binding
    HRESULT GetStrongNameSignature(BYTE **ppbSNSig, DWORD *pcbSNSig);
    HRESULT GetStrongNameSignature(BYTE *pbSNSig, DWORD *pcbSNSig);
    static HRESULT GetStrongNameHash(LPWSTR szwFile, BYTE *pbHash, DWORD *pcbHash);
    HRESULT GetStrongNameHash(BYTE *pbHash, DWORD *pcbHash);
    HRESULT GetSNSigOrHash(BYTE *pbHash, DWORD *pcbHash);

private:
    static HRESULT Setup(PEFile* pFile,
                         HCORMODULE hMod,
                         BOOL fResource);

// This is hard coded right now for perf - basically this needs to change to adapt
// to the possiblity that a hash can change in size
#define PEFILE_SNHASH_BUF_SIZE 20
    BYTE m_rgbSNHash[PEFILE_SNHASH_BUF_SIZE];
    DWORD m_cbSNHash;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\peverifier.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *
 * Header:  PEVerifier.cpp
 *
 * Author:  Shajan Dasan
 *
 * Purpose: Verify PE images before loading. This is to prevent
 *          Native code (other than Mscoree.DllMain() ) to execute.
 *
 * The entry point should be the following instruction.
 *
 * [_X86_]
 * jmp dword ptr ds:[XXXX]
 *
 * XXXX should be the RVA of the first entry in the IAT.
 * The IAT should have only one entry, that should be MSCoree.dll:_CorMain
 *
 * Date created : 1 July 1999 
 * 
 */

#ifdef _PEVERIFIER_EXE_
#include <windows.h>
#include <crtdbg.h>
#endif
#include "Common.h"
#include "PeVerifier.h"

// See if the bitmap's i'th bit 0 ==> 1st bit, 1 ==> 2nd bit...
#define IS_SET_DWBITMAP(bitmap, i) ( ((i) > 31) ? 0 : ((bitmap) & (1 << (i))) )

#ifdef _X86_
// jmp dword ptr ds:[XXXX]
#define JMP_DWORD_PTR_DS_OPCODE { 0xFF, 0x25 }   
#define JMP_DWORD_PTR_DS_OPCODE_SIZE   2        // Size of opcode
#define JMP_SIZE   6                            // Size of opcode + operand
#endif

#define CLR_MAX_RVA 0x80000000L

#ifdef _MODULE_VERIFY_LOG 
void PEVerifier::LogError(PCHAR szField, DWORD dwActual, DWORD *pdwExpected, int n)
{
    Log(szField); Log(" = "); Log(dwActual);

    Log(" [ Expected "); 

    for (int i=0; i<n; ++i)
    {
        if (i == 0)
            Log("-> ");
        else if (i == n - 1)
            Log(" or ");
        else
            Log(", ");
        Log(pdwExpected[i]);
    }

    Log(" ]");
    Log("\n");
}

void PEVerifier::LogError(PCHAR szField, DWORD dwActual, DWORD dwExpected)
{
    Log(szField); Log(" = "); Log(dwActual);
    Log(" [ Expected "); Log(dwExpected); Log(" ]");
    Log("\n");
}
#else
#define Log(a) 
#define LogError(a, b, c) 
#endif

// Check that the given header lives within the extents of the file
// The headers cannot live in sections ie. their RVA is the same
// as the file position.

#define CHECK_INTERVAL(p, L, name)  {                               \
    if (p == NULL)                                                  \
    {                                                               \
        Log(name); Log(" is NULL\n");                               \
        return FALSE;                                               \
    }                                                               \
                                                                    \
    if (((PBYTE)p < m_pBase) ||                                     \
        ((PBYTE)p > (m_pBase + m_dwLength - L)))                    \
    {                                                               \
        Log(name); Log(" incomplete\n");                            \
        return FALSE;                                               \
    }                                                               \
}

#define CHECK_HEADER(p, Struct, name)   CHECK_INTERVAL(p, sizeof(Struct), name)

#define ALIGN(v, a) (((v)+(a)-1)&~((a)-1))

#define CHECK_ALIGNMENT_VALIDITY(a, name)                           \
    if ((a==0)||(((a)&((a)-1)) != 0))                               \
    {                                                               \
        Log("Bad alignment value ");                                \
        Log(name);                                                  \
        return FALSE;                                               \
    }

#define CHECK_ALIGNMENT(v, a, name)                                 \
    if (((v)&((a)-1)) != 0)                                         \
    {                                                               \
        Log("Improperly aligned value ");                           \
        Log(name);                                                  \
        return FALSE;                                               \
    }

BOOL PEVerifier::Check()
{
#define CHECK(x) if ((ret = Check##x()) == FALSE) goto Exit;

#define CHECK_OVERFLOW(offs) {                                      \
    if (offs & CLR_MAX_RVA)                                         \
    {                                                               \
        Log("overflow\n");                                          \
        ret = FALSE;                                                \
        goto Exit;                                                  \
    }                                                               \
    }


    BOOL ret = TRUE;
    m_pDOSh = (PIMAGE_DOS_HEADER)m_pBase;
    CHECK(DosHeader);

    CHECK_OVERFLOW(m_pDOSh->e_lfanew);
    m_pNTh = (PIMAGE_NT_HEADERS) (m_pBase + m_pDOSh->e_lfanew);
    CHECK(NTHeader);

    m_pFh = (PIMAGE_FILE_HEADER) &(m_pNTh->FileHeader);
    CHECK(FileHeader);

    m_nSections = m_pFh->NumberOfSections;

    m_pOPTh = (PIMAGE_OPTIONAL_HEADER) &(m_pNTh->OptionalHeader);
    CHECK(OptionalHeader);

    m_dwPrefferedBase = m_pOPTh->ImageBase;

    CHECK_OVERFLOW(m_pFh->SizeOfOptionalHeader);
    m_pSh = (PIMAGE_SECTION_HEADER) ( (PBYTE)m_pOPTh + 
            m_pFh->SizeOfOptionalHeader);

    CHECK(SectionHeader);
    
    CHECK(Directories);

    CHECK(ImportDlls);
    _ASSERTE(m_dwIATRVA);

    CHECK(Relocations);
    _ASSERTE(m_dwRelocRVA);

    CHECK(COMHeader);

    CHECK(EntryPoint);

Exit:
    return ret;

#undef CHECK
#undef CHECK_OVERFLOW
}


// Checks that a guard page will be created given the parameters for stack creation
// located in the PE file
BOOL PEVerifier::CheckPEManagedStack(IMAGE_NT_HEADERS*   pNT)
{
    // Make sure that there will be a guard page. We only need to do this for .exes
    // This is based in what NT does to determine if it will setup a guard page or not.
    if ( (pNT->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0 )
    {        
        DWORD dwReservedStack = pNT->OptionalHeader.SizeOfStackReserve;
        DWORD dwCommitedStack = pNT->OptionalHeader.SizeOfStackCommit;

        // Get System information. 
        SYSTEM_INFO SystemInfo;
        GetSystemInfo(&SystemInfo);    

        // OS rounds up sizes the following way to decide if it marks a guard page
        dwReservedStack = ALIGN(dwReservedStack, SystemInfo.dwAllocationGranularity); // Allocation granularity
        dwCommitedStack = ALIGN(dwCommitedStack, SystemInfo.dwPageSize);              // Page Size
        
        if (dwReservedStack <= dwCommitedStack)
        {
            // OS wont create guard page, we can't execute managed code safely.
            return FALSE;
        }
    }

    return TRUE;
}

BOOL PEVerifier::CheckDosHeader()
{
    CHECK_HEADER(m_pDOSh, IMAGE_DOS_HEADER, "Dos Header");

    if (m_pDOSh->e_magic != IMAGE_DOS_SIGNATURE)
    {
        LogError("IMAGE_DOS_HEADER.e_magic", m_pDOSh->e_magic, 
            IMAGE_DOS_SIGNATURE);
        return FALSE;
    }

    if(m_pDOSh->e_lfanew < offsetof(IMAGE_DOS_HEADER,e_lfanew)+sizeof(m_pDOSh->e_lfanew))
    {
        Log("IMAGE_DOS_HEADER.e_lfanew too small\n");
        return FALSE;
    }

    if((m_pDOSh->e_lfanew + sizeof(IMAGE_FILE_HEADER)+sizeof(DWORD)) >= m_dwLength)
    {
        Log("IMAGE_DOS_HEADER.e_lfanew too large\n");
        return FALSE;
    }

    if (m_pDOSh->e_lfanew & 7) 
    {
        Log("NT header not 8-byte aligned\n");
        return FALSE;
    }

    return TRUE;
}

BOOL PEVerifier::CheckNTHeader()
{
    CHECK_HEADER(m_pNTh, PIMAGE_NT_HEADERS, "NT Header");

    if (m_pNTh->Signature != IMAGE_NT_SIGNATURE)
    {
        LogError("IMAGE_NT_HEADER.Signature", m_pNTh->Signature, 
            IMAGE_NT_SIGNATURE);
        return FALSE;
    }

    return TRUE;
}

BOOL PEVerifier::CheckFileHeader()
{
    CHECK_HEADER(m_pFh, IMAGE_FILE_HEADER, "File Header");

    // We do expect exactly one reloc (for m_dwRelocRVA). So IMAGE_FILE_RELOCS_STRIPPED 
    // should not be set.
    //
    // Also, the Windows loader ignores this bit if the module gets rebased, if it
    // also has relocs in the reloc section. So this check by itself would not be enough
    // unless we also checked that the reloc section was empty.
    //
    // It should not be set even for EXEs (which usually don't get rebased) as
    // it is possible for the URT to load exes at a non-preferred base address.
    // Hence m_dwRelocRVA is necessary.
    //
    
    if ((m_pFh->Characteristics & IMAGE_FILE_RELOCS_STRIPPED) != 0)
    {
        LogError("IMAGE_FILE_HEADER.Characteristics", m_pFh->Characteristics, 
            (m_pFh->Characteristics & ~IMAGE_FILE_RELOCS_STRIPPED));
        return FALSE;
    }

    if ((m_pFh->Characteristics & IMAGE_FILE_SYSTEM) != 0)
    {
        LogError("IMAGE_FILE_HEADER.Characteristics", m_pFh->Characteristics, 
            (m_pFh->Characteristics & ~IMAGE_FILE_SYSTEM));
        return FALSE;
    }

    if (m_pFh->SizeOfOptionalHeader < (offsetof(IMAGE_OPTIONAL_HEADER32, NumberOfRvaAndSizes)
                        + sizeof(m_pOPTh->NumberOfRvaAndSizes)))
    {
        Log("Optional header too small to contain the NumberOfRvaAndSizes field\n");
        return FALSE;
    }

    // The rest of the check of SizeOfOptionalHeader removed, because it's checked correctly
    // in CheckOptionalHeader()

    if (m_pFh->NumberOfSections > ((4096 / sizeof(IMAGE_SECTION_HEADER)) + 1))
    {
        Log("This image has greater than the max number allowed for an x86 image\n");
        // This check also prevents 32 bit overflow on the next check

        return FALSE;
    }


    return TRUE;
}

BOOL PEVerifier::CheckOptionalHeader()
{
    _ASSERTE(m_pFh != NULL);

    
    // This check assumes that only PE (not PE+) format is verifiable
    CHECK_HEADER(m_pOPTh, IMAGE_OPTIONAL_HEADER32, "Optional Header");

    if (m_pOPTh->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
    {
        LogError("IMAGE_OPTIONAL_HEADER.Magic", m_pOPTh->Magic,IMAGE_NT_OPTIONAL_HDR32_MAGIC);
        return FALSE;
    }

    // Number of data directories is not guaranteed to be 16
    // ...but first, protection against possible overflow:
    if(m_pOPTh->NumberOfRvaAndSizes >= CLR_MAX_RVA/sizeof(IMAGE_DATA_DIRECTORY))
    {
        Log("Bogus IMAGE_FILE_HEADER.NumberOfRvaAndSizes (");
        Log(m_pOPTh->NumberOfRvaAndSizes);
        Log(")\n");
        return FALSE;
    }

    DWORD dwTrueOptHeaderSize = offsetof(IMAGE_OPTIONAL_HEADER32,DataDirectory)
        + m_pOPTh->NumberOfRvaAndSizes*sizeof(IMAGE_DATA_DIRECTORY);
    
    if (m_pFh->SizeOfOptionalHeader < dwTrueOptHeaderSize)
    {
        Log("Bogus IMAGE_FILE_HEADER.SizeOfOptionalHeader (");
        Log(m_pFh->SizeOfOptionalHeader);
        Log(")\n");
        return FALSE;
    }

    // Check if SizeOfHeaders is large enough to hold all headers incl. section headers
    if((m_pDOSh->e_lfanew + sizeof(IMAGE_FILE_HEADER) + dwTrueOptHeaderSize + sizeof(DWORD)
        + m_pFh->NumberOfSections*sizeof(IMAGE_SECTION_HEADER)) > m_pOPTh->SizeOfHeaders)
    {
        Log("IMAGE_OPTIONAL_HEADER.SizeOfHeaders too small\n");
        return FALSE;
    }

    CHECK_INTERVAL(m_pBase,m_pOPTh->SizeOfHeaders,"AllHeaders");
    
    if(m_pOPTh->SizeOfCode == 0)
    {
        Log("IMAGE_OPTIONAL_HEADER.SizeOfCode = 0\n");
        return FALSE;
    }

    // Check alignments for validity
    CHECK_ALIGNMENT_VALIDITY(m_pOPTh->FileAlignment, "FileAlignment");
    CHECK_ALIGNMENT_VALIDITY(m_pOPTh->SectionAlignment, "SectionAlignment");

    // Check alignment values
    CHECK_ALIGNMENT(m_pOPTh->FileAlignment, 512, "FileAlignment");
    // NOTE: Our spec requires that managed images have 8K section alignment.  We're not
    // going to enforce this right now since it's not a security issue. (OS_PAGE_SIZE is
    // required for security so proper section protection can be applied.)
    CHECK_ALIGNMENT(m_pOPTh->SectionAlignment, OS_PAGE_SIZE, "SectionAlignment");
    if(m_pOPTh->SectionAlignment < m_pOPTh->FileAlignment)
    {
        Log("IMAGE_OPTIONAL_HEADER.FileAlignment exceeds IMAGE_OPTIONAL_HEADER.SectionAlignment\n");
        return FALSE;
    }
    CHECK_ALIGNMENT(m_pOPTh->SectionAlignment, m_pOPTh->FileAlignment, "SectionAlignment");

    // Check that virtual bounds are aligned

    CHECK_ALIGNMENT(m_pOPTh->ImageBase, 0x10000 /* 64K */, "ImageBase");
    CHECK_ALIGNMENT(m_pOPTh->SizeOfImage, m_pOPTh->SectionAlignment, "SizeOfImage");
    CHECK_ALIGNMENT(m_pOPTh->SizeOfHeaders, m_pOPTh->FileAlignment, "SizeOfHeaders");


    // Check that we have a valid stack
    if (!CheckPEManagedStack(m_pNTh))
    {
        return FALSE;
    }

    return TRUE;
}

//
// Check that a section is well formed, and update file postion cursor and RVA cursor.
// It can also be used for any generic structure that needs to be walked past in the image.
//

BOOL PEVerifier::CheckSection(
    DWORD *pOffsetCounter,      // [IN,OUT] Updates the file position cursor past the section, accounting for file alignment etc
    DWORD dataOffset,           // File position of the section. 0 for headers check
    DWORD dataSize,             // Size on disk of the section
    DWORD *pAddressCounter,     // [IN,OUT] Updates the RVA cursor past the section
    DWORD virtualAddress,       // RVA of the section. 0 if this is not a real section
    DWORD unalignedVirtualSize, // Declared size (after load) of the section. Some types of sections have a different (smaller) size on disk
    int sectionIndex)           // Index in the section directory. -1 if this is not a real section
{
    // Assert that only one bit is set in this const.
    _ASSERTE( ((CLR_MAX_RVA - 1) & (CLR_MAX_RVA)) == 0);

    DWORD virtualSize = ALIGN(unalignedVirtualSize, m_pOPTh->SectionAlignment);
    DWORD alignedFileSize = ALIGN(m_dwLength,m_pOPTh->FileAlignment);

    // Note that since we are checking for the high bit in all of these values, there can be 
    // no overflow when adding any 2 of them.

    if ((dataOffset & CLR_MAX_RVA) ||
        (dataSize & CLR_MAX_RVA) ||
        ((dataOffset + dataSize) & CLR_MAX_RVA) ||
        (virtualAddress & CLR_MAX_RVA) ||
        (virtualSize & CLR_MAX_RVA) ||
        ((virtualAddress + virtualSize) & CLR_MAX_RVA))
    {
        Log("RVA too large for section ");
        Log(sectionIndex);
        Log("\n");
        return FALSE;
    }

    CHECK_ALIGNMENT(dataOffset, m_pOPTh->FileAlignment, "PointerToRawData");
    CHECK_ALIGNMENT(dataSize, m_pOPTh->FileAlignment, "SizeOfRawData");
    CHECK_ALIGNMENT(virtualAddress, m_pOPTh->SectionAlignment, "VirtualAddress");

    // Is the cursor at the right file postion?
    // Does the section fit in the file size?
    
    if ((dataOffset < *pOffsetCounter)
        || ((dataOffset + dataSize) > alignedFileSize))
    {
        Log("Bad Section ");
        Log(sectionIndex);
        Log("\n");
        return FALSE;
    }

    // Is the cursor at the right RVA postion?
    // Does the section fit in the file address space?
    
    if ((virtualAddress < *pAddressCounter)
        || ((virtualAddress + virtualSize) > m_pOPTh->SizeOfImage)
        || (dataSize > virtualSize))
    {
        Log("Bad section virtual address in Section ");
        Log(sectionIndex);
        Log("\n");
        return FALSE;
    }

    // Update the file postion cursor, and the RVA cursor
    *pOffsetCounter = dataOffset + dataSize;
    *pAddressCounter = virtualAddress + virtualSize;

    return TRUE;
}


BOOL PEVerifier::CheckSectionHeader()
{
    _ASSERTE(m_pSh != NULL);

    DWORD lastDataOffset = 0;
    DWORD lastVirtualAddress = 0;

    // All the headers should be read-only and mutually exlusive with everything else
    if (FAILED(m_ranges.AddNode(new (nothrow) RangeTree::Node(0, m_pOPTh->SizeOfHeaders))))
        return FALSE;
    
    // Check header data as if it were a section
    if (!CheckSection(&lastDataOffset, 0, m_pOPTh->SizeOfHeaders, 
                      &lastVirtualAddress, 0, m_pOPTh->SizeOfHeaders, 
                      -1))
        return FALSE;

    // No need to check if the section headers fit into IMAGE_OPTIONAL_HEADER.SizeOfHeaders -- 
    // it was done in CheckOptionalHeader()
    for (DWORD dw = 0; dw < m_nSections; ++dw)
    {

        if (m_pSh[dw].Characteristics & 
            (IMAGE_SCN_MEM_SHARED|IMAGE_SCN_LNK_NRELOC_OVFL))
        {
            Log("Section Characteristics (IMAGE_SCN_MEM_SHARED|IMAGE_SCN_LNK_NRELOC_OVFL) is set\n");
            return FALSE;
        }

        if ((m_pSh[dw].PointerToRelocations != 0) ||
            (m_pSh[dw].NumberOfRelocations  != 0))
        {
            Log("m_pSh[dw].PointerToRelocations or m_pSh[dw].NumberOfRelocations not 0\n");
            return FALSE;
        }

        if((m_pSh[dw].VirtualAddress < m_pOPTh->SizeOfHeaders) ||
           (m_pSh[dw].PointerToRawData < m_pOPTh->SizeOfHeaders))
        {
            Log("Section[");
            Log(dw);
            Log("] overlaps the headers\n");
            return FALSE;
        }

        if (!CheckSection(&lastDataOffset, m_pSh[dw].PointerToRawData, m_pSh[dw].SizeOfRawData, 
                          &lastVirtualAddress, m_pSh[dw].VirtualAddress, m_pSh[dw].Misc.VirtualSize,
                          dw))
            return FALSE;
    }

    return TRUE;
}

BOOL PEVerifier::CheckDirectories()
{
    _ASSERTE(m_pOPTh != NULL);

    DWORD nEntries = m_pOPTh->NumberOfRvaAndSizes;

#ifndef IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14
#endif

    // Allow only verifiable directories.
    //
    // IMAGE_DIRECTORY_ENTRY_IMPORT     1   Import Directory
    // IMAGE_DIRECTORY_ENTRY_RESOURCE   2   Resource Directory
    // IMAGE_DIRECTORY_ENTRY_SECURITY   4   Security Directory
    // IMAGE_DIRECTORY_ENTRY_BASERELOC  5   Base Relocation Table
    // IMAGE_DIRECTORY_ENTRY_DEBUG      6   Debug Directory
    // IMAGE_DIRECTORY_ENTRY_IAT        12  Import Address Table
    //
    // IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR  14  COM+ Data
    //
    // Construct a 0 based bitmap with these bits.


    static DWORD s_dwAllowedBitmap = 
        ((1 << (IMAGE_DIRECTORY_ENTRY_IMPORT   )) |
         (1 << (IMAGE_DIRECTORY_ENTRY_RESOURCE )) |
         (1 << (IMAGE_DIRECTORY_ENTRY_SECURITY )) |
         (1 << (IMAGE_DIRECTORY_ENTRY_BASERELOC)) |
         (1 << (IMAGE_DIRECTORY_ENTRY_DEBUG    )) |
         (1 << (IMAGE_DIRECTORY_ENTRY_IAT      )) |
         (1 << (IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR)));

    if(nEntries <= IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR)
    {
        Log("Missing IMAGE_OPTIONAL_HEADER.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR]\n");
        return FALSE;
    }

    for (DWORD dw=0; dw<nEntries; ++dw)
    {
        DWORD rva = m_pOPTh->DataDirectory[dw].VirtualAddress;
        DWORD size = m_pOPTh->DataDirectory[dw].Size;

        if ((rva != 0) || (size != 0))
        {
            if (!IS_SET_DWBITMAP(s_dwAllowedBitmap, dw))
            {
                Log("IMAGE_OPTIONAL_HEADER.DataDirectory[");
                Log(dw);
                Log("]");
                Log(" Cannot verify this DataDirectory\n");
                return FALSE;
            }
        }
    }
        
    return TRUE;
}

// This function has a side effect of setting m_dwIATRVA

BOOL PEVerifier::CheckImportDlls()
{
    // The only allowed DLL Imports are MscorEE.dll:_CorExeMain,_CorDllMain

    DWORD dwSectionSize;
    DWORD dwSectionOffset;
    DWORD dwImportSize;
    DWORD dwImportOffset;

    dwImportOffset = DirectoryToOffset(IMAGE_DIRECTORY_ENTRY_IMPORT, 
                            &dwImportSize, &dwSectionOffset, &dwSectionSize);

    // A valid COM+ image should have MscorEE imported.
    if (dwImportOffset == 0)
    {
        Log("IMAGE_DIRECTORY_IMPORT not found.");
        return FALSE;
    }

    // Check if import records will fit into the section that contains it.
    if ((dwImportOffset < dwSectionOffset) ||
        (dwImportOffset > (dwSectionOffset + dwSectionSize)) ||
        (dwImportSize > (dwSectionOffset + dwSectionSize - dwImportOffset)))
    {
ImportSizeError:

        Log("IMAGE_IMPORT_DESCRIPTOR does not fit in its section\n");
        return FALSE;
    }

    // There should be space for at least 2 entries. One corresponding to mscoree.dll
    // and the second one being the null terminator entry.
    if (dwImportSize < 2*sizeof(IMAGE_IMPORT_DESCRIPTOR))
        goto ImportSizeError;

    // The 2 entries should be read-only and mutually exlusive with everything else.
    DWORD importDescrsRVA = m_pOPTh->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    if (FAILED(m_ranges.AddNode(new (nothrow) RangeTree::Node(importDescrsRVA,
                            importDescrsRVA + 2*sizeof(IMAGE_IMPORT_DESCRIPTOR)))))
    {
        return FALSE;
    }
    
    PIMAGE_IMPORT_DESCRIPTOR pID = (PIMAGE_IMPORT_DESCRIPTOR)
        ((PBYTE)m_pBase + dwImportOffset);

    // Entry 1 must be all nulls.
    if ((pID[1].OriginalFirstThunk != 0)
        || (pID[1].TimeDateStamp != 0)
        || (pID[1].ForwarderChain != 0)
        || (pID[1].Name != 0)
        || (pID[1].FirstThunk != 0))
    {
        Log("IMAGE_IMPORT_DESCRIPTOR[1] should be NULL\n");
        return FALSE;
    }

    // In entry zero, ILT, Name, IAT must be be non-null.  Forwarder, DateTime should be NULL.
    if (   (pID[0].OriginalFirstThunk == 0)
        || (pID[0].TimeDateStamp != 0)
        || ((pID[0].ForwarderChain != 0) && (pID[0].ForwarderChain != -1))
        || (pID[0].Name == 0)
        || (pID[0].FirstThunk == 0))
    {
        Log("Invalid IMAGE_IMPORT_DESCRIPTOR[0] for MscorEE.dll\n");
        return FALSE;
    }
    
    // Check if mscoree.dll is the import dll name.
    static CHAR *s_pDllName = "mscoree.dll";
#define LENGTH_OF_DLL_NAME 11

#ifdef _DEBUG
    _ASSERTE(strlen(s_pDllName) == LENGTH_OF_DLL_NAME);
#endif

    // Include the NULL char in the comparison
    if (CompareStringAtRVA(pID[0].Name, s_pDllName, LENGTH_OF_DLL_NAME) == FALSE)
    {
#ifdef _MODULE_VERIFY_LOG 
        DWORD dwNameOffset = RVAToOffset(pID[0].Name, NULL, NULL);
        Log("IMAGE_IMPORT_DESCRIPTOR[0], cannot import library\n");
#endif
        return FALSE;
    }

    // Check the Hint/Name table and Import Address table.
    // They could be the same.

    if (CheckImportByNameTable(pID[0].OriginalFirstThunk, FALSE) == FALSE)
    {
        Log("IMAGE_IMPORT_DESCRIPTOR[0].OriginalFirstThunk bad.\n");
        return FALSE;
    }

    // IAT need to be checked only for size.
    if ((pID[0].OriginalFirstThunk != pID[0].FirstThunk) &&
        (CheckImportByNameTable(pID[0].FirstThunk, TRUE) == FALSE))
    {
        Log("IMAGE_IMPORT_DESCRIPTOR[0].FirstThunk bad.\n");
        return FALSE;
    }

    // Cache the RVA of the Import Address Table.
    // For Performance reasons, no seperate function to do this.
    m_dwIATRVA = pID[0].FirstThunk;

    if((m_dwIATRVA != m_pOPTh->DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress)
      || (m_pOPTh->DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size != 8))
    {
        Log("Invalid IAT\n");
        return FALSE;
    }

    return TRUE;
}

// This function has a side effect of setting m_dwRelocRVA (the RVA where a 
// reloc will be applied.)

BOOL PEVerifier::CheckRelocations()
{
    DWORD dwSectionSize;
    DWORD dwSectionOffset;
    DWORD dwRelocSize;
    DWORD dwRelocOffset;

    dwRelocOffset = DirectoryToOffset(IMAGE_DIRECTORY_ENTRY_BASERELOC, 
                        &dwRelocSize, &dwSectionOffset, &dwSectionSize);

    // Verifiable files have to have one reloc (for m_dwRelocRVA)
    if (dwRelocOffset == 0)
        return FALSE;

    // There should be exactly two entries.
    if (dwRelocSize != sizeof(IMAGE_BASE_RELOCATION) + 2*sizeof(WORD))
    {
        LogError("IMAGE_DIRECTORY_ENTRY_IMPORT.Size",dwRelocSize,sizeof(IMAGE_BASE_RELOCATION) + 2*sizeof(WORD));
        return FALSE;
    }

    IMAGE_BASE_RELOCATION *pReloc = (IMAGE_BASE_RELOCATION *)
        ((PBYTE)m_pBase + dwRelocOffset);

    // Only one Reloc record is expected
    if (pReloc->SizeOfBlock != dwRelocSize)
    {
        LogError("IMAGE_BASE_RELOCATION.SizeOfBlock",pReloc->SizeOfBlock,dwRelocSize);
        return FALSE;
    }

    CHECK_ALIGNMENT(pReloc->VirtualAddress, 4096, "IMAGE_BASE_RELOCATION.VirtualAddress");

    WORD *pwReloc = (WORD *)
        ((PBYTE)m_pBase + dwRelocOffset + sizeof(IMAGE_BASE_RELOCATION));

    // First fixup must be HIGHLOW @ EntryPoint + JMP_DWORD_PTR_DS_OPCODE_SIZE.  
    // Second fixup must be of type IMAGE_REL_BASED_ABSOLUTE (skipped).
    m_dwRelocRVA = pReloc->VirtualAddress + (pwReloc[0] & 0xfff);
    if (   ((pwReloc[0] >> 12) != IMAGE_REL_BASED_HIGHLOW)
        || (m_dwRelocRVA != (m_pOPTh->AddressOfEntryPoint + JMP_DWORD_PTR_DS_OPCODE_SIZE))
        || ((pwReloc[1] >> 12) != IMAGE_REL_BASED_ABSOLUTE))
    {
        Log("Invalid base relocation fixups\n");
        return FALSE;
    }

    // The reloced data should be mutually exlusive with everything else,
    // as LoadLibrary() will write to it
    if (FAILED(m_ranges.AddNode(new (nothrow) RangeTree::Node(m_dwRelocRVA, 
        m_dwRelocRVA + dwRelocSize))))
        return FALSE;
    
    return TRUE;
}

BOOL PEVerifier::CheckEntryPoint()
{
    _ASSERTE(m_pOPTh != NULL);

    DWORD dwSectionOffset;
    DWORD dwSectionSize;
    DWORD dwOffset;

    if (m_pOPTh->AddressOfEntryPoint == 0)
    {
        Log("PIMAGE_OPTIONAL_HEADER.AddressOfEntryPoint Missing Entry point\n");
        return FALSE;
    }

    dwOffset = RVAToOffset(m_pOPTh->AddressOfEntryPoint, 
                           &dwSectionOffset, &dwSectionSize);

    if (dwOffset == 0)
    {
        Log("Bad Entry point\n");
        return FALSE;
    }

    // EntryPoint should be a jmp dword ptr ds:[XXXX] instruction.
    // XXXX should be RVA of the first and only entry in the IAT.

#ifdef _X86_
    static BYTE s_DllOrExeMain[] = JMP_DWORD_PTR_DS_OPCODE;

    // First check if we have enough space to hold 2 DWORDS
    if ((dwOffset < dwSectionOffset) ||
        (dwOffset > (dwSectionOffset + dwSectionSize - JMP_SIZE)))
    {
        Log("Entry Function incomplete\n");
        return FALSE;
    }

    if (memcmp(m_pBase + dwOffset, s_DllOrExeMain, 
        JMP_DWORD_PTR_DS_OPCODE_SIZE)  != 0)
    {
        Log("Non Verifiable native code in entry stub. Expect ");
        Log(*(WORD*)(s_DllOrExeMain));
        Log(" Found ");
        Log(*(WORD*)((PBYTE)m_pBase+dwOffset));
        Log("\n");
        return FALSE;
    }

    // The operand for the jmp instruction is the RVA of IAT
    // (since we verified that there is one and only one entry in the IAT).
    DWORD dwJmpOperand = m_dwIATRVA + m_dwPrefferedBase;

    if (memcmp(m_pBase + dwOffset + JMP_DWORD_PTR_DS_OPCODE_SIZE,
        (PBYTE)&dwJmpOperand, JMP_SIZE - JMP_DWORD_PTR_DS_OPCODE_SIZE) != 0)
    {
        Log("Non Verifiable native code in entry stub. Expect ");
        Log(dwJmpOperand);
        Log(" Found ");
        Log(*(DWORD*)((PBYTE)m_pBase+dwOffset+JMP_DWORD_PTR_DS_OPCODE_SIZE));
        Log("\n");
        return FALSE;
    }

    // Condition (m_dwRelocRVA==m_pOPTh->AddressOfEntryPoint + JMP_DWORD_PTR_DS_OPCODE_SIZE)  
    // was checked in CheckRelocations() 
        
    // The reloced data should be mutually exlusive with everything else,
    // as LoadLibrary() will write to it.
    // Note that CheckRelocation() would already have added a Node for the jump operand (at m_dwRelocRVA)
    if (FAILED(m_ranges.AddNode(new (nothrow) RangeTree::Node(m_pOPTh->AddressOfEntryPoint,
                        m_pOPTh->AddressOfEntryPoint + JMP_DWORD_PTR_DS_OPCODE_SIZE))))
    {
        return FALSE;
    }
#endif // _X86_

    return TRUE;
}

BOOL PEVerifier::CheckImportByNameTable(DWORD dwRVA, BOOL fIAT)
{
    if (dwRVA == 0)
        return FALSE;

    DWORD dwSectionOffset;
    DWORD dwSectionSize;
    DWORD dwOffset;
    
    dwOffset = RVAToOffset(dwRVA, &dwSectionOffset, &dwSectionSize);

    if (dwOffset == 0)
        return FALSE;

    // First check if we have enough space to hold 2 DWORDS
    if ((dwOffset < dwSectionOffset) ||
        (dwOffset > (dwSectionOffset + dwSectionSize - (2 * sizeof(DWORD)))))
        return FALSE;

    // The import entry should be mutually exlusive with everything else
    // as LoadLibrary() will write to it
    if (FAILED(m_ranges.AddNode(new (nothrow) RangeTree::Node(dwRVA,
                                                              dwRVA + 2*sizeof(DWORD)))))
    {
        return FALSE;
    }
    
    // IAT need not be verified. It will be over written by the loader.
    if (fIAT)
        return TRUE;

    DWORD *pImportArray = (DWORD*) ((PBYTE)m_pBase + dwOffset); 

    if (pImportArray[0] == 0)
    {
ErrorImport:

        Log("_CorExeMain OR _CorDllMain should be the one and only import\n");
        return FALSE;
    }

    if (pImportArray[1] != 0)
        goto ErrorImport;

    // First bit Set implies Ordinal lookup
    if (pImportArray[0] & 0x80000000)
    {
        Log("Mscoree.dll:_CorExeMain/_CorDllMain ordinal lookup not allowed\n");
        return FALSE;
    }

    dwOffset = RVAToOffset(pImportArray[0], &dwSectionOffset, &dwSectionSize);

    if (dwOffset == 0)
        return FALSE;

    static CHAR *s_pEntry1 = "_CorDllMain";
    static CHAR *s_pEntry2 = "_CorExeMain";
#define LENGTH_OF_ENTRY_NAME 11

#ifdef _DEBUG
    _ASSERTE(strlen(s_pEntry1) == LENGTH_OF_ENTRY_NAME);
    _ASSERTE(strlen(s_pEntry2) == LENGTH_OF_ENTRY_NAME);
#endif

    // First check if we have enough space to hold 4 bytes + 
    // _CorExeMain or _CorDllMain and a NULL char

    if ((dwOffset < dwSectionOffset) ||
        (dwOffset >
         (dwSectionOffset + dwSectionSize - 4 - LENGTH_OF_ENTRY_NAME - 1)))
        return FALSE;

    PIMAGE_IMPORT_BY_NAME pImport = (PIMAGE_IMPORT_BY_NAME) 
        ((PBYTE)m_pBase + dwOffset); 

    // Include the null char when comparing.
    if ((_strnicmp(s_pEntry1, (CHAR*)pImport->Name, LENGTH_OF_ENTRY_NAME+1)!=0)&&
        (_strnicmp(s_pEntry2, (CHAR*)pImport->Name, LENGTH_OF_ENTRY_NAME+1)!=0))
    {
        Log("Attempt to import invalid name\n");
        goto ErrorImport;
    }

    // The import name should be read-only and mutually exlusive with everything else
    if (FAILED(m_ranges.AddNode(new (nothrow) RangeTree::Node(pImportArray[0],
                                    pImportArray[0] + LENGTH_OF_ENTRY_NAME+1))))
    {
        return FALSE;
    }
    
    return TRUE;
}

BOOL PEVerifier::CompareStringAtRVA(DWORD dwRVA, CHAR *pStr, DWORD dwSize)
{
    DWORD dwSectionOffset = 0;
    DWORD dwSectionSize   = 0;
    DWORD dwStringOffset  = RVAToOffset(dwRVA,&dwSectionOffset,&dwSectionSize);

    // First check if we have enough space to hold the string
    if ((dwStringOffset < dwSectionOffset) ||
        (dwStringOffset > (dwSectionOffset + dwSectionSize - dwSize)))
        return FALSE;

    // Compare should include the NULL char
    if (_strnicmp(pStr, (CHAR*)(m_pBase + dwStringOffset), dwSize + 1) != 0)
        return FALSE;

    // The string name should be read-only and mutually exlusive with everything else
    if (FAILED(m_ranges.AddNode(new (nothrow) RangeTree::Node(dwRVA,
                                                              dwRVA + dwSize))))
    {
        return FALSE;
    }
    
    return TRUE;
}

DWORD PEVerifier::RVAToOffset(DWORD dwRVA,
                              DWORD *pdwSectionOffset,
                              DWORD *pdwSectionSize) const
{
    _ASSERTE(m_pSh != NULL);

    // Find the section that contains the RVA
    for (DWORD dw=0; dw<m_nSections; ++dw)
    {
        if ((m_pSh[dw].VirtualAddress <= dwRVA) &&
            (m_pSh[dw].VirtualAddress + m_pSh[dw].SizeOfRawData > dwRVA))
        {
            if (pdwSectionOffset != NULL)
                *pdwSectionOffset = m_pSh[dw].PointerToRawData;

            if (pdwSectionSize != NULL)
                *pdwSectionSize = m_pSh[dw].SizeOfRawData;

            return (m_pSh[dw].PointerToRawData +
                    (dwRVA - m_pSh[dw].VirtualAddress));
        }
    }

#ifdef _DEBUG
    if (pdwSectionOffset != NULL)
        *pdwSectionOffset = 0xFFFFFFFF;

    if (pdwSectionSize != NULL)
        *pdwSectionSize = 0xFFFFFFFF;
#endif

    return 0;
}

DWORD PEVerifier::DirectoryToOffset(DWORD dwDirectory,
                                    DWORD *pdwDirectorySize,
                                    DWORD *pdwSectionOffset,
                                    DWORD *pdwSectionSize) const
{
    _ASSERTE(m_pOPTh != NULL);

    // Get the Directory RVA from the Optional Header
    if ((dwDirectory >= m_pOPTh->NumberOfRvaAndSizes) || 
        (m_pOPTh->DataDirectory[dwDirectory].VirtualAddress == 0))
    {
#ifdef _DEBUG
        if (pdwDirectorySize != NULL)
            *pdwDirectorySize = 0xFFFFFFFF;

        if (pdwSectionOffset != NULL)
            *pdwSectionOffset = 0xFFFFFFFF;

        if (pdwSectionSize != NULL)
            *pdwSectionSize = 0xFFFFFFFF;
#endif

        return 0;
    }

    if (pdwDirectorySize != NULL)
        *pdwDirectorySize = m_pOPTh->DataDirectory[dwDirectory].Size;

    // Return the file offset, using the directory RVA
    return RVAToOffset(m_pOPTh->DataDirectory[dwDirectory].VirtualAddress, 
        pdwSectionOffset, pdwSectionSize);
}

BOOL PEVerifier::CheckCOMHeader()
{
    DWORD dwSectionOffset, dwSectionSize, dwDirectorySize;
    DWORD dwCOR2Hdr = DirectoryToOffset(IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                            &dwDirectorySize, &dwSectionOffset, &dwSectionSize);
    if(dwCOR2Hdr==0)
        return FALSE;
    if (sizeof(IMAGE_COR20_HEADER) > dwDirectorySize)
            return FALSE;

    if ((dwCOR2Hdr + sizeof(IMAGE_COR20_HEADER)) > (dwSectionOffset + dwSectionSize))
            return FALSE;

    IMAGE_COR20_HEADER* pHeader=(IMAGE_COR20_HEADER*)(m_pBase+dwCOR2Hdr);
    if (!(pHeader->VTableFixups.VirtualAddress == 0 && pHeader->VTableFixups.Size == 0))
        return FALSE;
    if(!(pHeader->ExportAddressTableJumps.VirtualAddress == 0 && pHeader->ExportAddressTableJumps.Size == 0))
        return FALSE;

    IMAGE_DATA_DIRECTORY *pDD = &(pHeader->CodeManagerTable);
    if((pDD->VirtualAddress != 0)||(pDD->Size != 0))
        return FALSE;

    pDD = &(pHeader->ManagedNativeHeader);
    if((pDD->VirtualAddress != 0)||(pDD->Size != 0))
        return FALSE;

    if((pHeader->Flags & COMIMAGE_FLAGS_ILONLY)==0)
        return FALSE;

    if((pHeader->EntryPointToken != 0)&&((m_pFh->Characteristics & IMAGE_FILE_DLL)!=0))
    {
        Log("Entry point in a DLL\n");
        return FALSE;
    }

    if(pHeader->cb < offsetof(IMAGE_COR20_HEADER, ManagedNativeHeader) + sizeof(IMAGE_DATA_DIRECTORY))
    {
        LogError("IMAGE_COR20_HEADER.cb",pHeader->cb,
            offsetof(IMAGE_COR20_HEADER, ManagedNativeHeader) + sizeof(IMAGE_DATA_DIRECTORY));
        return FALSE;
    }
    // The COMHeader should be read-only and mutually exlusive with everything else
    DWORD comHeaderRVA = m_pOPTh->DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress;
    if (FAILED(m_ranges.AddNode(new (nothrow) RangeTree::Node(comHeaderRVA,
                                         comHeaderRVA + pHeader->cb))))
    {
        return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\pefile.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File.CPP
// 

// PEFILE reads in the PE file format using LoadLibrary
// ===========================================================================

#include "common.h"
#include "TimeLine.h"
#include "eeconfig.h"
#include "pefile.h"
#include "zapmonitor.h"
#include "peverifier.h"
#include "security.h"
#include "strongname.h"
#include "sha.h"

// ===========================================================================
// PEFile
// ===========================================================================

PEFile::PEFile()
{
    m_wszSourceFile[0] = 0;
    m_hModule = NULL;
    m_hCorModule = NULL;
    m_base = NULL;
    m_pNT = NULL;
    m_pCOR = NULL;
    m_pMDInternalImport = NULL;
    m_pLoadersFileName = NULL;
    m_flags = 0;
    m_dwUnmappedFileLen = -1;
    m_fShouldFreeModule = FALSE;
    m_fHashesVerified = FALSE;
    m_cbSNHash = 0;
#ifdef METADATATRACKER_ENABLED
    m_pMDTracker = NULL;
#endif // METADATATRACKER_ENABLED
}

PEFile::PEFile(PEFile *pFile)
{
    wcscpy(m_wszSourceFile, pFile->m_wszSourceFile);
    m_hModule = pFile->m_hModule;
    m_hCorModule = pFile->m_hCorModule;
    m_base = pFile->m_base;
    m_pNT = pFile->m_pNT;
    m_pCOR = pFile->m_pCOR;

    m_pMDInternalImport = NULL;
    m_pLoadersFileName = NULL;
    m_flags = pFile->m_flags;

    m_dwUnmappedFileLen = pFile->m_dwUnmappedFileLen;
    m_fShouldFreeModule = FALSE;
    m_cbSNHash = 0;
#ifdef METADATATRACKER_ENABLED
    m_pMDTracker = NULL;
#endif // METADATATRACKER_ENABLED
}

PEFile::~PEFile()
{
    if (m_pMDInternalImport != NULL)
    {
        m_pMDInternalImport->Release();
    }

#ifdef METADATATRACKER_ENABLED
    if (m_pMDTracker != NULL)
        m_pMDTracker->Deactivate();
#endif // METADATATRACKER_ENABLED

    if (m_hCorModule)
        CorMap::ReleaseHandle(m_hCorModule);
    else if(m_fShouldFreeModule)
    {
        _ASSERTE(m_hModule);
        // Unload the dll so that refcounting of EE will be done correctly
        // But, don't do this during process detach (this can be indirectly
        // called during process detach, potentially causing an AV).
        if (!g_fProcessDetach)
            FreeLibrary(m_hModule);
    }

}

HRESULT PEFile::ReadHeaders()
{
    IMAGE_DOS_HEADER* pDos;
    BOOL fData = FALSE;
    if(m_hCorModule) {
        DWORD types = CorMap::ImageType(m_hCorModule);
        if(types == CorLoadOSMap || types == CorLoadDataMap) 
            fData = TRUE;
    }

    return CorMap::ReadHeaders(m_base, &pDos, &m_pNT, &m_pCOR, fData, m_dwUnmappedFileLen);
}

BYTE *PEFile::RVAToPointer(DWORD rva)
{
    BOOL fData = FALSE;

    if(m_hCorModule) {
        DWORD types = CorMap::ImageType(m_hCorModule);
        if(types == CorLoadOSMap || types == CorLoadDataMap) 
            fData = TRUE;
    }

    if (rva == 0)
        return NULL;

    if (fData)
        rva = Cor_RtlImageRvaToOffset(m_pNT, rva, GetUnmappedFileLength());

    return m_base + rva;
}

PEFile::CEStuff *PEFile::m_pCEStuff = NULL;

HRESULT PEFile::RegisterBaseAndRVA14(HMODULE hMod, LPVOID pBase, DWORD dwRva14)
{
    // @todo: these are currently leaked.
    
    CEStuff *pStuff = new CEStuff;
    if (pStuff == NULL)
        return E_OUTOFMEMORY;

    pStuff->hMod = hMod;
    pStuff->pBase = pBase;
    pStuff->dwRva14 = dwRva14;

    pStuff->pNext = m_pCEStuff;
    m_pCEStuff = pStuff;

    return S_OK;
}

HRESULT PEFile::Create(HMODULE hMod, PEFile **ppFile, BOOL fShouldFree)
{
    HRESULT hr;

    PEFile *pFile = new PEFile();
    if (pFile == NULL)
        return E_OUTOFMEMORY;

    pFile->m_hModule = hMod;
    pFile->m_fShouldFreeModule = fShouldFree;

    CEStuff *pStuff = m_pCEStuff;
    while (pStuff != NULL)
    {
        if (pStuff->hMod == hMod)
            break;
        pStuff = pStuff->pNext;
    }

    if (pStuff == NULL)
    {
        pFile->m_base = (BYTE*) hMod;
    
        hr = pFile->ReadHeaders();
        if (FAILED(hr))
        {
            delete pFile;
            return hr;
        }
    }
    else
    {
       pFile->m_base = (BYTE*) pStuff->pBase;
       pFile->m_pNT = NULL;
       pFile->m_pCOR = (IMAGE_COR20_HEADER *) (pFile->m_base + pStuff->dwRva14);
    }

    *ppFile = pFile;
    return pFile->GetFileNameFromImage();
}

HRESULT PEFile::Create(HCORMODULE hMod, PEFile **ppFile, BOOL fResource/*=FALSE*/)
{
    HRESULT hr;

    PEFile *pFile = new PEFile();
    if (pFile == NULL)
        return E_OUTOFMEMORY;
    hr = Setup(pFile, hMod, fResource);
    if (FAILED(hr))
        delete pFile;
    else
        *ppFile = pFile;
    return hr;
}

HRESULT PEFile::Setup(PEFile* pFile, HCORMODULE hMod, BOOL fResource)
{
    HRESULT hr;

    // Release any pointers to the map data and the reload as a proper image
    if (pFile->m_pMDInternalImport != NULL) {
        pFile->m_pMDInternalImport->Release();
        pFile->m_pMDInternalImport = NULL;
    }

#ifdef METADATATRACKER_ENABLED
    if (pFile->m_pMDTracker != NULL)
        pFile->m_pMDTracker->Deactivate();
#endif // METADATATRACKER_ENABLED
    
    pFile->m_hCorModule = hMod;
    IfFailRet(CorMap::BaseAddress(hMod, (HMODULE*) &(pFile->m_base)));
    if(pFile->m_base)
    {
        pFile->m_dwUnmappedFileLen = (DWORD)CorMap::GetRawLength(hMod);
        if (!fResource)
            IfFailRet(hr = pFile->ReadHeaders());

        return pFile->GetFileNameFromImage();
    }
    else return E_FAIL;
}

HRESULT PEFile::Create(PBYTE pUnmappedPE, DWORD dwUnmappedPE, LPCWSTR imageNameIn,
                       LPCWSTR pLoadersFileName, 
                       OBJECTREF* pExtraEvidence,
                       PEFile **ppFile, 
                       BOOL fResource)
{
    HCORMODULE hMod = NULL;

    HRESULT hr = CorMap::OpenRawImage(pUnmappedPE, dwUnmappedPE, imageNameIn, &hMod, fResource);
    if (SUCCEEDED(hr) && hMod == NULL)
        hr = E_FAIL;

    if (SUCCEEDED(hr))
    {
        if (fResource)
            hr = Create(hMod, ppFile, fResource);
        else
            hr = VerifyModule(hMod, 
                              NULL, 
                              NULL, 
                              NULL,  // Code base
                              pExtraEvidence, 
                              imageNameIn, NULL, ppFile, NULL);
    }

    if (SUCCEEDED(hr)) {
        (*ppFile)->m_pLoadersFileName = pLoadersFileName;
        (*ppFile)->m_dwUnmappedFileLen = dwUnmappedPE;
    }

    return hr;
}


HRESULT PEFile::Create(LPCWSTR moduleName, 
                       Assembly* pParent,
                       mdFile kFile,                 // File token in the parent assembly associated with the file
                       BOOL fIgnoreVerification, 
                       IAssembly* pFusionAssembly,
                       LPCWSTR pCodeBase,
                       OBJECTREF* pExtraEvidence,
                       PEFile **ppFile)
{    
    HRESULT hr;
    _ASSERTE(moduleName);
    LOG((LF_CLASSLOADER, LL_INFO10, "PEFile::Create: Load module: \"%ws\" Ignore Verification = %d.\n", moduleName, fIgnoreVerification));
    
    TIMELINE_START(LOADER, ("PEFile::Create %S", moduleName));

    if((fIgnoreVerification == FALSE) || pParent) {
        // ----------------------------------------
        // Verify the module to see if we are allowed to load it. If it has no
        // unexplainable reloc's then it is veriable. If it is a simple 
        // image then we have already loaded it so just return that one.
        // If it is a complex one and security says we can load it then
        // we must release the original interface to it and then reload it.
        // VerifyModule will return S_OK if we do not need to reload it.
        Thread* pThread = GetThread();
        
        IAssembly* pOldFusionAssembly = pThread->GetFusionAssembly();
        Assembly* pAssembly = pThread->GetAssembly();
        mdFile kOldFile = pThread->GetAssemblyModule();

        pThread->SetFusionAssembly(pFusionAssembly);
        pThread->SetAssembly(pParent);
        pThread->SetAssemblyModule(kFile);

        HCORMODULE hModule;
        hr = CorMap::OpenFile(moduleName, CorLoadOSMap, &hModule);

        if (SUCCEEDED(hr)) {
            if(hr == S_FALSE) {
                PEFile *pFile;
                hr = Create(hModule, &pFile);
                if (SUCCEEDED(hr) && pFusionAssembly)
                    hr = ReleaseFusionMetadataImport(pFusionAssembly);
                if (SUCCEEDED(hr))
                    *ppFile = pFile;
            }
            else
                hr = VerifyModule(hModule, 
                                  pParent, 
                                  pFusionAssembly, 
                                  pCodeBase,
                                  pExtraEvidence, 
                                  moduleName,  
                                  NULL, ppFile, NULL);
        }

        pThread->SetFusionAssembly(pOldFusionAssembly);
        pThread->SetAssembly(pAssembly);
        pThread->SetAssemblyModule(kOldFile);

        if(pOldFusionAssembly)
            pOldFusionAssembly->Release();

    }
    else {
        
        HCORMODULE hModule;
        hr = CorMap::OpenFile(moduleName, CorLoadOSImage, &hModule);
        if(hr == S_FALSE) // if S_FALSE then we have already loaded it correctly
            hr = Create(hModule, ppFile, FALSE);
        else if(hr == S_OK) // Convert to an image
            hr = CreateImageFile(hModule, pFusionAssembly, ppFile);
        // return an error
        
    }
    TIMELINE_END(LOADER, ("PEFile::Create %S", moduleName));
    return hr;
}

HRESULT PEFile::CreateResource(LPCWSTR moduleName,
                               PEFile **pFile)
{
    HRESULT hr = S_OK;
    HCORMODULE hModule;
    IfFailRet(CorMap::OpenFile(moduleName, CorLoadOSMap,  &hModule));
    return Create(hModule, pFile, TRUE);
}


HRESULT PEFile::Clone(PEFile *pFile, PEFile **ppFile)
{
    PEFile *result;
    HRESULT hr = S_OK;
    result = new PEFile(pFile);
    if (result == NULL)
        return E_OUTOFMEMORY;

    //
    // Add a reference to the file
    //

    if (result->m_hModule != NULL)
    {
            // The flags being passed to LoadLibrary are a safety net.  If the
            // code is correct, and we are simply bumping a reference count on the
            // library, they do nothing.   If however we screwed up, they avoid
            // running the DllMain of a potentially malicious DLL, which blocks
            // many attacks.
        if(result->m_wszSourceFile &&  CorMap::ValidDllPath(result->m_wszSourceFile)) {
            DWORD loadLibraryFlags = LOAD_WITH_ALTERED_SEARCH_PATH;
            if (RunningOnWinNT())
                loadLibraryFlags |= DONT_RESOLVE_DLL_REFERENCES;
            HMODULE hMod = WszLoadLibraryEx(result->m_wszSourceFile, NULL, loadLibraryFlags);
            
            // Note that this assert may fail on win 9x for .exes.  This is a 
            // design problem which is being corrected - soon we will not allow
            // binding to .exes
            _ASSERTE(hMod == result->m_hModule);
            result->m_fShouldFreeModule = TRUE;
        }
        else {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        }
    }
    else if (result->m_hCorModule != NULL)
    {
        hr = CorMap::AddRefHandle(result->m_hCorModule);
        _ASSERTE(hr == S_OK);
    }

    *ppFile = result;
    return hr;
}

IMDInternalImport *PEFile::GetMDImport(HRESULT *phr)
{
    HRESULT hr = S_OK;

    if (m_pMDInternalImport == NULL)
    {
        LPVOID pMetaData = NULL;
        _ASSERTE(m_pCOR);

        hr = GetMetadataPtr(&pMetaData);
        if (SUCCEEDED(hr))
        {
            IMAGE_DATA_DIRECTORY *pMeta = &m_pCOR->MetaData;
#if METADATATRACKER_ENABLED
            m_pMDTracker = MetaDataTracker::GetOrCreateMetaDataTracker ((BYTE*)pMetaData, pMeta->Size, (LPWSTR)GetFileName());
#endif // METADATATRACKER_ENABLED

            hr = GetMetaDataInternalInterface(pMetaData,
                                              pMeta->Size,
                                              ofRead, 
                                              IID_IMDInternalImport,
                                              (void **) &m_pMDInternalImport);
#ifdef METADATATRACKER_ENABLED
            if (! SUCCEEDED(hr))
            {
                delete m_pMDTracker;
                m_pMDTracker = NULL;
            }
            else
            {
                if (REGUTIL::GetConfigDWORD (L"ShowMetaDataAccess", 0) > 0)
                {
                    _ASSERTE (m_pMDTracker);
                    LPCSTR pThrowAway;
                    GUID mvid;
                    if (m_pMDInternalImport->IsValidToken(m_pMDInternalImport->GetModuleFromScope())) {
                        m_pMDInternalImport->GetScopeProps (&pThrowAway, &mvid);
                        m_pMDTracker->NoteMVID (&mvid);
                    }
                    else
                        hr = COR_E_BADIMAGEFORMAT;
                }
            }
#endif // METADATATRACKER_ENABLED
        }
    }

    if (phr)
        *phr = hr;

    return m_pMDInternalImport;
}

HRESULT PEFile::GetMetadataPtr(LPVOID *ppMetadata)
{
    _ASSERTE(m_pCOR);

    if (!ppMetadata)
        return E_INVALIDARG;

    IMAGE_DATA_DIRECTORY *pMeta = &m_pCOR->MetaData;

    // Range check the metadata blob
    if (!Cor_RtlImageRvaRangeToSection(m_pNT, pMeta->VirtualAddress, pMeta->Size, GetUnmappedFileLength()))
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

    // Find the meta-data. If it is a non-mapped image then use the base offset
    // instead of the virtual address
    DWORD offset;
    if(m_hCorModule) {
        DWORD flags = CorMap::ImageType(m_hCorModule);
        if(flags == CorLoadOSImage || flags == CorLoadImageMap || flags == CorReLoadOSMap) 
            offset = pMeta->VirtualAddress;
        else
            offset = Cor_RtlImageRvaToOffset(m_pNT, pMeta->VirtualAddress, GetUnmappedFileLength());
    }
    else 
        offset = pMeta->VirtualAddress;

    // Set the out pointer to the start of the metadata.
    *ppMetadata = m_base + offset;
    return S_OK;
}

HRESULT PEFile::VerifyFlags(DWORD flags, BOOL fZap)
{

    DWORD validBits = COMIMAGE_FLAGS_ILONLY | COMIMAGE_FLAGS_32BITREQUIRED | COMIMAGE_FLAGS_TRACKDEBUGDATA | COMIMAGE_FLAGS_STRONGNAMESIGNED;
    if (fZap)
        validBits |= COMIMAGE_FLAGS_IL_LIBRARY;

    DWO