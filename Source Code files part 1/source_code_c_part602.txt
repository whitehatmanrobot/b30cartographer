CoTaskMemAlloc(sizeof(**InterfaceList) + sizeof(*Interface)));
    if (!*InterfaceList) {
        return E_OUTOFMEMORY;
    }
    (*InterfaceList)->Count = 1;
    (*InterfaceList)->Size = sizeof(**InterfaceList) + sizeof(*Interface);
    Interface = reinterpret_cast<PKSPIN_INTERFACE>(*InterfaceList + 1);
    Interface->Set = KSINTERFACESETID_Standard;
    Interface->Id = KSINTERFACE_STANDARD_STREAMING;
    Interface->Flags = 0;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\amkspin.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// amkspin.h  
//

STDMETHODIMP
AMKsQueryMediums(
    PKSMULTIPLE_ITEM* MediumList,
    KSPIN_MEDIUM * MediumSet
    );

STDMETHODIMP
AMKsQueryInterfaces(
    PKSMULTIPLE_ITEM* InterfaceList
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\wdmcapgf\ccapobj.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    CCapObj.cpp

Abstract:

    A class for a capture device object

Author:
    
    Yee J. Wu    24-April-97

Environment:

    User mode only

Revision History:

--*/

#include "pch.h"         // mainly stream.h

#include "CCapObj.h"


CObjCapture::CObjCapture(
    TCHAR * pstrDevicePath,        
    TCHAR * pstrFriendlyName,
    TCHAR * pstrExtensionDLL 
    )    
    :
    CBaseObject(NAME("A Capture Device"))
/*++

Routine Description:

    The constructor 

Arguments:

 

Return Value:

    Nothing.

--*/
{
 
    CopyMemory(m_strDevicePath,   pstrDevicePath,   _MAX_PATH);
    CopyMemory(m_strFriendlyName, pstrFriendlyName, _MAX_PATH);
    CopyMemory(m_strExtensionDLL, pstrExtensionDLL, _MAX_PATH);

}

CObjCapture::~CObjCapture()
/*++

Routine Description:

    The constructor 

Arguments:

 

Return Value:

    Nothing.

--*/
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\kssupp.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __KSSUPPORT__
#define __KSSUPPORT__

class CKsSupport : 
	  public IKsPin
    , public IKsPropertySet
    , public CUnknown
{
protected:
	KSPIN_MEDIUM        m_Medium;
    GUID                m_CategoryGUID;
    KSPIN_COMMUNICATION m_Communication;

public:

    // Constructor and destructor
    CKsSupport(KSPIN_COMMUNICATION Communication, LPUNKNOWN pUnk) :
          m_Communication (Communication)
        , m_CategoryGUID (GUID_NULL)
        , CUnknown (TEXT ("CKsSupport"), pUnk)
        {
            m_Medium.Set = GUID_NULL;
            m_Medium.Id = 0;
            m_Medium.Flags = 0;   
        };

    ~CKsSupport()
        {};

    void SetKsMedium   (const KSPIN_MEDIUM *Medium)    {m_Medium = *Medium;};
    void SetKsCategory (const GUID *Category)  {m_CategoryGUID = *Category;};

    DECLARE_IUNKNOWN;

    // IKsPropertySet implementation

    STDMETHODIMP 
    Set (
        REFGUID guidPropSet, 
        DWORD dwPropID, 
        LPVOID pInstanceData, 
        DWORD cbInstanceData, 
        LPVOID pPropData, 
        DWORD cbPropData
        )
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP 
    Get (
        REFGUID guidPropSet, 
        DWORD dwPropID, 
        LPVOID pInstanceData, 
        DWORD cbInstanceData, 
        LPVOID pPropData, 
        DWORD cbPropData, 
        DWORD *pcbReturned
        )
    {
        if (guidPropSet != AMPROPSETID_Pin)
	        return E_PROP_SET_UNSUPPORTED;

        if (dwPropID != AMPROPERTY_PIN_CATEGORY && dwPropID != AMPROPERTY_PIN_MEDIUM)
	        return E_PROP_ID_UNSUPPORTED;

        if (pPropData == NULL && pcbReturned == NULL)
	        return E_POINTER;

        if (pcbReturned)
            *pcbReturned = ((dwPropID == AMPROPERTY_PIN_CATEGORY) ? 
                sizeof(GUID) : sizeof (KSPIN_MEDIUM));

        if (pPropData == NULL)
	        return S_OK;

        if (cbPropData < sizeof(GUID))
	        return E_UNEXPECTED;

        if (dwPropID == AMPROPERTY_PIN_CATEGORY) {
            *(GUID *)pPropData = m_CategoryGUID;
        }
        else if (dwPropID == AMPROPERTY_PIN_MEDIUM) {
            *(KSPIN_MEDIUM *)pPropData = m_Medium;
        }


        return S_OK;
    }

    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
    {
        if (guidPropSet != AMPROPSETID_Pin)
	        return E_PROP_SET_UNSUPPORTED;

        if (dwPropID != AMPROPERTY_PIN_CATEGORY && dwPropID != AMPROPERTY_PIN_MEDIUM)
	        return E_PROP_ID_UNSUPPORTED;

        if (pTypeSupport)
	        *pTypeSupport = KSPROPERTY_SUPPORT_GET;

        return S_OK;
    }


    // IKsPin implementation

    virtual STDMETHODIMP 
    KsQueryMediums(
        PKSMULTIPLE_ITEM* MediumList
        )
        { return ::AMKsQueryMediums (MediumList, &m_Medium); }; 

    virtual STDMETHODIMP
    KsQueryInterfaces(
        PKSMULTIPLE_ITEM* InterfaceList
        ) 
        { return ::AMKsQueryInterfaces (InterfaceList); };

    STDMETHODIMP
    KsCreateSinkPinHandle(
        KSPIN_INTERFACE& Interface,
        KSPIN_MEDIUM& Medium
        ) { return E_UNEXPECTED; };


    STDMETHODIMP
    KsGetCurrentCommunication(
        KSPIN_COMMUNICATION *Communication,
        KSPIN_INTERFACE *Interface,
        KSPIN_MEDIUM *Medium
        )
        {
            if (Communication != NULL) {
                *Communication = m_Communication; 
            }
            if (Interface != NULL) {
                Interface->Set = KSINTERFACESETID_Standard;
                Interface->Id = KSINTERFACE_STANDARD_STREAMING;
                Interface->Flags = 0;
            }
            if (Medium != NULL) {
                *Medium = m_Medium;
            }
            // Special return code that indicates 
            // Kernel transport is  not possible

            return S_FALSE;     
        };
    
    STDMETHODIMP 
    KsPropagateAcquire() 
        { return NOERROR; };


    STDMETHODIMP
    KsDeliver(IMediaSample* Sample, ULONG Flags) 
        { return E_UNEXPECTED; };

    STDMETHODIMP
    KsMediaSamplesCompleted ( PKSSTREAM_SEGMENT StreamSegment )
        { return E_UNEXPECTED; };

    STDMETHODIMP_(IMemAllocator*)
    KsPeekAllocator(KSPEEKOPERATION Operation) 
        { return NULL; };

    STDMETHODIMP
    KsReceiveAllocator( IMemAllocator* MemAllocator) 
        { return E_UNEXPECTED; };

    STDMETHODIMP
    KsRenegotiateAllocator() 
        { return E_UNEXPECTED; };

    STDMETHODIMP_(LONG)
    KsIncrementPendingIoCount() 
        { return E_UNEXPECTED; };

    STDMETHODIMP_(LONG)
    KsDecrementPendingIoCount() 
        { return E_UNEXPECTED; };

    STDMETHODIMP
    KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta) 
        { return E_UNEXPECTED; };
    
    STDMETHODIMP_(REFERENCE_TIME) 
    KsGetStartTime() 
        { return E_UNEXPECTED; };
};

#endif // __KSSUPPORT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\wdmcapgf\ccapobj.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    CCapObj.h

Abstract:

    Header file for CCapObj.cpp

Author:
    
    Yee J. Wu  24-April-97

Environment:

    User mode only

Revision History:

--*/

#ifndef CCAPOBJ_H
#define CCAPOBJ_H

class CBaseObject;


class CObjCapture : public CBaseObject
{
private:

    TCHAR m_strDevicePath[_MAX_PATH];    // The unique device path
    TCHAR m_strFriendlyName[_MAX_PATH];
    TCHAR m_strExtensionDLL[_MAX_PATH]; 

public:

    CObjCapture(
        TCHAR * pstrDevicePath, 
        TCHAR * pstrFriendlyName,
        TCHAR * pstrExtensionDLL);  
    ~CObjCapture(); 

    TCHAR * GetDevicePath()   { return m_strDevicePath;}
    TCHAR * GetFriendlyName() { return m_strFriendlyName;}
    TCHAR * GetExtensionDLL() { return m_strExtensionDLL;}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\wdmcapgf\pch.h ===
#if 0   // DBG
#ifndef _DEBUG
#define _DEBUG
#endif
#ifndef DEBUG
#define DEBUG
#endif
#endif
//
// use Non MFC based generic template list classes
//
#include <streams.h>   // This include just about enerything !!
#include <vfw.h>       // DVM_ERR_*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\wdmcapgf\bldcapgf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    BldCapGf.h

Abstract:

    Header file for BldCapGf.cpp

Author:
    
    Yee J. Wu   24-April-97

Environment:

    User mode only

Revision History:

--*/


#include "CCapObj.h"


#ifndef BLDCAPGF_H
#define BLDCAPGF_H

typedef enum {
   BGf_DEVICE_VIDEO,
   BGf_DEVICE_AUDIO
} BGf_DEVICE_TYPE, *PBGf_DEVICE_TYPE;

//
// Customize for differnt clients
//
typedef enum {
    BGf_PURPOSE_VFWWDM,
    BGf_PURPOSE_STILL,
    BGf_PURPOSE_ATLCONTROL,
    BGf_PURPOSE_OTHER
} BGf_PURPOSE, *PBGf_PURPOSE;


typedef enum {
    BGf_PREVIEW_OVERLAPPED,
    BGf_PREVIEW_CHILD,
    BGf_PREVIEW_WINDOWLESS,
    BGf_PREVIEW_DONTCARE
} BGf_PREVIEW, *PBGf_PREVIEW;

//
// Device Info Link List struct
//
typedef struct _EnumDeviceInfo {
    DWORD dwSize;
    TCHAR strFriendlyName[_MAX_PATH];
    TCHAR strDevicePath[_MAX_PATH];         
    TCHAR strExtensionDLL[_MAX_PATH];    
    DWORD dwFlags;
} EnumDeviceInfo;


//
// This capture graph class contain many filters to build a complete graph.
// It has one base filter/device, like BT8T829 or BT848, from which  
// an upstream or/and down stream graph is built.
//
// Its base filter contain input and output pin(s).
//

class CCaptureGraph
{
private:

    HINSTANCE m_hInstance;

    // **********************
    // Enumeration parameters
    // **********************

    BGf_PURPOSE m_PurposeFlags;
    BGf_PREVIEW m_PreviewFlags;
    REFCLSID m_clsidVideoDeviceClass;
    DWORD    m_dwVideoEnumFlags;    
    REFCLSID m_clsidAudioDeviceClass;
    DWORD    m_dwAudioEnumFlags;  


    // *************
    // Graph builder
    // *************
    ICaptureGraphBuilder *m_pBuilder;
    IGraphBuilder *m_pFg;

    //
    // Event 
    //
    IMediaEventEx *m_pMEEx;


    // Current state
    BOOL m_fPreviewGraphBuilt;
    BOOL m_fPreviewing;



    typedef CGenericList <CObjCapture> CObjDeviceList;

    // **********
    // V I D E O:
    // **********

    // Cache this since it is used in many placed. It is reset when asked to re-enumerate the device list.    
    IEnumMoniker  *m_pVideoEnumMoniker;
    // A list of enumerated video capture devices.
    CObjDeviceList m_ObjListVCapture;  
    // Current video capture object.
    CObjCapture   *m_pObjVCaptureCurrent;
    // Extract key information from the current device object and cache here for easy access.    
    EnumDeviceInfo m_EnumVDeviceInfoCurrent;

    // Video filter
    IBaseFilter *m_pVCap;    

    // CrossBar filters
    IBaseFilter *m_pXBar1;    
    IBaseFilter *m_pXBar2;    

    LONG m_XBar1InPinCounts;
    LONG m_XBar1OutPinCounts;


    // IVideoWindow*
    // Client window to overly image to.    
    HWND m_hWndClient;
    IVideoWindow *m_pVW;
    LONG m_lWindowStyle;   // Original VideoRendererWindow style
    HWND m_hWndOwner;      // Original owner of the VRWindow
    BOOL m_bSetChild;

    // Set/GetWindowPosition
    LONG m_lLeft,
         m_lTop,
         m_lWidth,
         m_lHeight;


    // IAM*
    IAMVideoCompression *m_pIAMVC;
    IAMStreamConfig *m_pIAMVSC;      
    IAMDroppedFrames *m_pIAMDF;
    IAMVfwCaptureDialogs *m_pIAMDlg;
    IAMTVTuner *m_pIAMTV;
    IAMCrossbar *m_pIAMXBar1;  
    IAMCrossbar *m_pIAMXBar2; 


    // **********
    // A U D I O:
    // **********

    IEnumMoniker  *m_pAudioEnumMoniker;
    CObjDeviceList m_ObjListACapture;  
    CObjCapture   *m_pObjACaptureCurrent;
    EnumDeviceInfo m_EnumADeviceInfoCurrent;    
    IBaseFilter *m_pACap;
    IAMStreamConfig *m_pIAMASC;     
    BOOL m_fCapAudio;


    //
    // Object related private functions
    //
    HRESULT SetObjCapture(BGf_DEVICE_TYPE DeviceType, CObjCapture * pObjCaptureNew);  
    void DuplicateObjContent(EnumDeviceInfo * pDstEnumDeviceInfo, CObjCapture * pSrcObjCapture);


    // Pin route and connection methods
    HRESULT RouteInToOutPins(IAMCrossbar * pIAMXBar, LONG idxInPin);
    HRESULT RouteRelatedPins(IAMCrossbar * pIAMXBar, LONG idxInPin);
    HRESULT FindIPinFromIndex(IBaseFilter * pFilter, LONG idxInPin, IPin ** ppPin);
    HRESULT FindIndexFromIPin(IBaseFilter * pFilter, IAMCrossbar * pIAMXBar, IPin * pPin, LONG *pidxInPin);

    // Local method to enumerate devices        
    LONG EnumerateCaptureDevices(
        BGf_DEVICE_TYPE DeviceType,
        REFCLSID clsidDeviceClass,
        DWORD dwEnumFlags);

    // Destroy graph helper
    void DestroyObjList(BGf_DEVICE_TYPE DeviceType);
    void NukeDownstream(IBaseFilter *pf);
    void FreeCapFilters();

public:

    CCaptureGraph(  
        BGf_PURPOSE PurposeFlags,
        BGf_PREVIEW PreviewFlags,   
        REFCLSID clsidVideoDeviceClass,  // such as CLSID_VideoinputDeviceCategory,
        DWORD    dwVideoEnumFlags,       // such as CDEF_BYPASS_CLASS_MANAGER
        REFCLSID clsidAudioDeviceClass,
        DWORD    dwAudioEnumFlags,
        HINSTANCE hInstance
        );             
    ~CCaptureGraph();


    //
    // Allocate an array of EnumDeviceInfo, one for each enumerated device.
    // Client must call DestroyCaptureDevicesList to free this array.
    //                                               
    LONG BGf_CreateCaptureDevicesList(      BGf_DEVICE_TYPE DeviceType, EnumDeviceInfo ** ppEnumDevicesList);  // return number of devices
    LONG BGf_CreateCaptureDevicesListUpdate(BGf_DEVICE_TYPE DeviceType, EnumDeviceInfo ** ppEnumDevicesList);  // return number of devices      
    void BGf_DestroyCaptureDevicesList(      EnumDeviceInfo  *  pEnumDevicesList);
    LONG BGf_GetDevicesCount(BGf_DEVICE_TYPE DeviceType); // return number of devices in the device list.



    //
    // Set/Get target capture device
    //
    HRESULT BGf_SetObjCapture(BGf_DEVICE_TYPE DeviceType, TCHAR * pstrDevicePath);
    HRESULT BGf_SetObjCapture(BGf_DEVICE_TYPE DeviceType, EnumDeviceInfo * pEnumDeviceInfo, DWORD dwEnumDeviceInfoSize);

    HRESULT BGf_GetObjCapture(BGf_DEVICE_TYPE DeviceType, EnumDeviceInfo * pEnumDeviceInfo, DWORD dwEnumDeviceInfoSize);
    TCHAR * BGf_GetObjCaptureDevicePath(BGf_DEVICE_TYPE DeviceType);
    TCHAR * BGf_GetObjCaptureFriendlyName(BGf_DEVICE_TYPE DeviceType);
    TCHAR * BGf_GetObjCaptureExtensionDLL(BGf_DEVICE_TYPE DeviceType);






    //
    // Build an upstream graph using the selected capture device.
    // Can query its input and output pins.
    //
    HRESULT BGf_BuildGraphUpStream(BOOL bAddAudioFilter, BOOL * pbUseOVMixer);
    virtual HRESULT BGf_BuildGraphDownStream(TCHAR * pstrCapFilename);          // Customize for STILL, VFWWDM,..others.
    virtual HRESULT BGf_BuildPreviewGraph(TCHAR * pstrVideoDevicePath, TCHAR * pstrAudioDevicePath, TCHAR * pstrCapFilename);  // Preview, Capture(need filename??)
    BOOL BGf_PreviewGraphBuilt() { return m_fPreviewGraphBuilt; }
    HANDLE BGf_GetDeviceHandle(BGf_DEVICE_TYPE DeviceType);  // return device handle of the capture filter.
    HRESULT BGf_GetCapturePinID(DWORD *pdwID);  // Get the PinID of the CAPTURE pin

    //
    // Register a notification 
    //
    IMediaEventEx * BGf_RegisterMediaEventEx(HWND hWndNotify, long lMsg, long lInstanceData);

    //
    // Teardown graph and free resources
    //
    void BGf_DestroyGraph();



    //
    // Based on an analog input(Tuner, Composit or SVideo), program the cross switches.
    //
    LONG BGf_CreateInputChannelsList(PTCHAR ** ppaPinNames);  // return number of pins   
    void BGf_DestroyInputChannelsList(PTCHAR *   paPinNames);     
    HRESULT BGf_RouteInputChannel(LONG idxInPin);
    LONG BGf_GetIsRoutedTo();
    LONG BGf_GetInputChannelsCount();



    //
    // Overlay Mixer
    //

    BOOL BGf_OverlayMixerSupported();  

    DWORD BGf_UpdateWindow(HWND hWndApp, HDC hDC);  // Main overlay function
    HRESULT BGf_OwnPreviewWindow(HWND hWndClient, LONG lWidth, LONG lHeight);  // Make the OM window a child of the client. 
    HRESULT BGf_UnOwnPreviewWindow(BOOL bVisible);
    DWORD BGf_SetVisible(BOOL bStart);                 // Turn on or off OM window (Visible/insivible)
    DWORD BGf_GetVisible(BOOL *pVisible); // Query the VISIBLE state of IVideoWindow



    //
    // Set/get streaming Property
    //
    BOOL BGf_StartPreview(BOOL bVisible);
    BOOL BGf_PausePreview(BOOL bVisible);
    BOOL BGf_StopPreview(BOOL bVisible);

    BOOL BGf_PreviewStarted() { return m_fPreviewing;}


    //
    // For current DS vfwwdm use only; may not needed them in the future.
    //
    BOOL BGf_SupportTVTunerInterface();
    BOOL BGf_SupportXBarInterface()    { return m_pIAMXBar1 != NULL;}
    void ShowTvTunerPage(HWND hWnd);
    void ShowCrossBarPage(HWND hWnd);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\ptvaudio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  ptvaudio.h  XBar property page

#ifndef _INC_PTVAUDIO_H
#define _INC_PTVAUDIO_H

// -------------------------------------------------------------------------
// CTVAudioProperties class
// -------------------------------------------------------------------------

class CTVAudioProperties : public CBasePropertyPage {

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

private:

    CTVAudioProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CTVAudioProperties();

    void    InitPropertiesDialog(HWND hwndParent);
    void    UpdateOutputView();
    void    UpdateInputView(BOOL fShowSelectedInput);
    void    SetDirty();

    // Keep the original settings on entry
    
    IAMTVAudio       *m_pTVAudio;

};

#endif  // _INC_PTVAUDIO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\pxbar.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  pxbar.h  XBar property page

#ifndef _INC_PXBAR_H
#define _INC_PXBAR_H

// -------------------------------------------------------------------------
// CXBarProperties class
// -------------------------------------------------------------------------

class CXBarProperties : public CBasePropertyPage {

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

private:

    CXBarProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CXBarProperties();

    void    InitPropertiesDialog(HWND hwndParent);
    void    UpdateOutputView();
    void    UpdateInputView(BOOL fShowSelectedInput);
    void    SetDirty();

    // Keep the original settings on entry
    
    IAMCrossbar         *m_pXBar;
    HWND                m_hLBOut;
    HWND                m_hLBIn;
    long                m_InputPinCount;
    long                m_OutputPinCount;
    BOOL                *m_pCanRoute;
    long                *m_pRelatedInput;
    long                *m_pRelatedOutput;
    long                *m_pPhysicalTypeInput;
    long                *m_pPhysicalTypeOutput;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\tvaudio.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <tchar.h>
#include <stdio.h>
#include <olectl.h>
#include <amtvuids.h>     // GUIDs  
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>

#include "amkspin.h"
#include "kssupp.h"
#include "tvaudio.h"
#include "xbar.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

// Setup data


//
// CreateInstance
//
// Creator function for the class ID
//

CUnknown * WINAPI TVAudio::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new TVAudio(NAME("TVAudio Filter"), pUnk, phr);
}


//
// Constructor
//
TVAudio::TVAudio(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) 
    : m_pTVAudioInputPin (NULL)
    , m_pTVAudioOutputPin (NULL)
    , m_pPersistStreamDevice(NULL)
    , m_hDevice(NULL)
    , m_pDeviceName(NULL)
    , CPersistStream(pUnk, phr)
    , CBaseFilter(NAME("TVAudio filter"), pUnk, this, CLSID_TVAudioFilter)
{
    ASSERT(phr);
}


//
// Destructor
//
TVAudio::~TVAudio()
{
    delete m_pTVAudioInputPin;
    delete m_pTVAudioOutputPin;

    // close the device
    if(m_hDevice) {
    	CloseHandle(m_hDevice);
    }

    if (m_pDeviceName) {
        delete [] m_pDeviceName;
    }

    if (m_pPersistStreamDevice) {
       m_pPersistStreamDevice->Release();
    }
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP TVAudio::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof(IAMTVAudio)) {
        return GetInterface((IAMTVAudio *) this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    }
    else if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag *) this, ppv);
    }
    else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    }
    else {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


// -------------------------------------------------------------------------
// ISpecifyPropertyPages
// -------------------------------------------------------------------------

//
// GetPages
//
// Returns the clsid's of the property pages we support
STDMETHODIMP TVAudio::GetPages(CAUUID *pPages) {

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_TVAudioFilterPropertyPage;

    return NOERROR;
}


// -------------------------------------------------------------------------
// IAMTVAudio 
// -------------------------------------------------------------------------

STDMETHODIMP
TVAudio::GetHardwareSupportedTVAudioModes( 
            /* [out] */ long __RPC_FAR *plModes)
{
    MyValidateWritePtr (plModes, sizeof(long), E_POINTER);
    
    if (!m_hDevice)
        return E_INVALIDARG;

    *plModes = m_Caps.Capabilities;

    return NOERROR;
}

STDMETHODIMP
TVAudio::GetAvailableTVAudioModes( 
            /* [out] */ long __RPC_FAR *plModes)
{
    KSPROPERTY_TVAUDIO_S Mode;
    BOOL        fOK;
    ULONG       cbReturned;
    
    MyValidateWritePtr (plModes, sizeof(long), E_POINTER);
    
    if (!m_hDevice)
        return E_INVALIDARG;

    Mode.Property.Set   = PROPSETID_VIDCAP_TVAUDIO;
    Mode.Property.Id    = KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES;
    Mode.Property.Flags = KSPROPERTY_TYPE_GET;

    fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &Mode,
	            sizeof(Mode),
	            &Mode,
	            sizeof(Mode),
	            &cbReturned,
	            TRUE);

    if (fOK) {
        *plModes = Mode.Mode;
        return NOERROR;
    }
    else {
        return E_INVALIDARG;
    }
}
        
STDMETHODIMP
TVAudio::get_TVAudioMode( 
            /* [out] */ long __RPC_FAR *plMode)
{
    ULONG       cbReturned;
    BOOL        fOK;
    KSPROPERTY_TVAUDIO_S Mode;

    MyValidateWritePtr (plMode, sizeof(long), E_POINTER);

    if (!m_hDevice)
        return E_INVALIDARG;

    Mode.Property.Set   = PROPSETID_VIDCAP_TVAUDIO;
    Mode.Property.Id    = KSPROPERTY_TVAUDIO_MODE;
    Mode.Property.Flags = KSPROPERTY_TYPE_GET;

    fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &Mode,
	            sizeof(Mode),
	            &Mode,
	            sizeof(Mode),
	            &cbReturned,
	            TRUE);

    if (fOK) {
        *plMode = Mode.Mode;
        return NOERROR;
    }
    else {
        return E_INVALIDARG;
    }
}
        
STDMETHODIMP
TVAudio::put_TVAudioMode( 
            /* [in] */ long lMode)
{
    ULONG       cbReturned;
    BOOL        fOK;
    KSPROPERTY_TVAUDIO_S Mode;

    if (!m_hDevice)
        return E_INVALIDARG;

    Mode.Property.Set   = PROPSETID_VIDCAP_TVAUDIO;
    Mode.Property.Id    = KSPROPERTY_TVAUDIO_MODE;
    Mode.Property.Flags = KSPROPERTY_TYPE_SET;
    Mode.Mode           = lMode;

    fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &Mode,
	            sizeof(Mode),
	            &Mode,
	            sizeof(Mode),
	            &cbReturned,
	            TRUE);

    if (fOK) {
        SetDirty(TRUE);
        return NOERROR;
    }
    else {
        return E_INVALIDARG;
    }
}
        
STDMETHODIMP
TVAudio::RegisterNotificationCallBack( 
            /* [in] */ IAMTunerNotification __RPC_FAR *pNotify,
            /* [in] */ long lEvents)
{
    return E_NOTIMPL;
}
        
STDMETHODIMP
TVAudio::UnRegisterNotificationCallBack( 
            IAMTunerNotification __RPC_FAR *pNotify)
{
    return E_NOTIMPL;
}


int TVAudio::CreateDevice()
{
    HANDLE hDevice ;

    hDevice = CreateFile( m_pDeviceName,
		     GENERIC_READ | GENERIC_WRITE,
		     0,
		     NULL,
		     OPEN_EXISTING,
		     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		     NULL ) ;

    if (hDevice == (HANDLE) -1) {
        DbgLog((LOG_TRACE, 0, TEXT("TVAUDIO::CreateDevice ERROR, unable to create device")));
	    return 0 ;
    } else {
	    m_hDevice = hDevice;
	    return 1;
    }
}

//
// GetPin
//
CBasePin *TVAudio::GetPin(int n) 
{
    if (n == 0) return m_pTVAudioInputPin;
    else return m_pTVAudioOutputPin;
}

//
// GetPinCount
//
int TVAudio::GetPinCount(void)
{
    return (m_hDevice ? 2 : 0);
}



//
// CreateInputPins
//
BOOL TVAudio::CreatePins()
{
    HRESULT hr = S_OK;

    m_pTVAudioInputPin = new TVAudioInputPin(NAME("TVAudio Input"), this,
					    &hr, L"TVAudio In");

    if (FAILED(hr) || m_pTVAudioInputPin == NULL) {
        return FALSE;
    }

    m_pTVAudioOutputPin = new TVAudioOutputPin(NAME("TVAudio Output"), this,
					    &hr, L"TVAudio Out");

    if (FAILED(hr) || m_pTVAudioOutputPin == NULL) {
        return FALSE;
    }

    ULONG       cbReturned;
    BOOL        fOK;

    m_Caps.Property.Set   = PROPSETID_VIDCAP_TVAUDIO;
    m_Caps.Property.Id    = KSPROPERTY_TVAUDIO_CAPS;
    m_Caps.Property.Flags = KSPROPERTY_TYPE_GET;

    fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &m_Caps,
	            sizeof(m_Caps),
	            &m_Caps,
	            sizeof(m_Caps),
	            &cbReturned,
	            TRUE);

    if (fOK) {
        m_pTVAudioInputPin->SetPinMedium (&m_Caps.InputMedium);
        m_pTVAudioOutputPin->SetPinMedium (&m_Caps.OutputMedium);
    }
    
    return TRUE;

} // CreatePins



//
// IPersistPropertyBag interface implementation for AMPnP support
//
STDMETHODIMP TVAudio::InitNew(void)
{
    return S_OK ;
}

STDMETHODIMP TVAudio::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock Lock(m_pLock) ;

    VARIANT var;
    VariantInit(&var);
    V_VT(&var) = VT_BSTR;

    // ::Load can succeed only once
    ASSERT(m_pPersistStreamDevice == 0); 

    HRESULT hr = pPropBag->Read(L"DevicePath", &var,0);
    if(SUCCEEDED(hr))
    {
        ULONG DeviceNameSize;

        if (m_pDeviceName) delete [] m_pDeviceName;	
        m_pDeviceName = new TCHAR [DeviceNameSize = (wcslen (V_BSTR(&var)) + 1)];
        if (!m_pDeviceName)
            return E_OUTOFMEMORY;

#ifndef _UNICODE
        WideCharToMultiByte(CP_ACP, 0, V_BSTR(&var), -1,
                            m_pDeviceName, DeviceNameSize, 0, 0);
#else
        lstrcpy(m_pDeviceName, V_BSTR(&var));
#endif
        VariantClear(&var);
        DbgLog((LOG_TRACE,2,TEXT("TVAudio::Load: use %s"), m_pDeviceName));

        if (CreateDevice() &&  CreatePins()) {
            hr = S_OK;
        }
        else {
            hr = E_FAIL ;
        }

        // save moniker with addref. ignore error if qi fails
        pPropBag->QueryInterface(IID_IPersistStream, (void **)&m_pPersistStreamDevice);

    }
    return hr;
}

STDMETHODIMP TVAudio::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, 
                            BOOL fSaveAllProperties)
{
    return E_NOTIMPL ;
}

STDMETHODIMP TVAudio::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);
}

// -------------------------------------------------------------------------
// IPersistStream interface implementation for saving to a graph file
// -------------------------------------------------------------------------

#define CURRENT_PERSIST_VERSION 1

DWORD
TVAudio::GetSoftwareVersion(
    void
    )
/*++

Routine Description:

    Implement the CPersistStream::GetSoftwareVersion method. Returns
    the new version number rather than the default of zero.

Arguments:

    None.

Return Value:

    Return CURRENT_PERSIST_VERSION.

--*/
{
    return CURRENT_PERSIST_VERSION;
}

HRESULT TVAudio::WriteToStream(IStream *pStream)
{

    HRESULT hr = E_FAIL;

    if (m_pPersistStreamDevice) {

        hr = m_pPersistStreamDevice->Save(pStream, TRUE);
        if(SUCCEEDED(hr)) {
            long lMode;

            hr = get_TVAudioMode(&lMode);
            if (SUCCEEDED(hr)) {
                // Save the filter state
                hr =  pStream->Write(&lMode, sizeof(lMode), 0);
            }
        }
    }
    else {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT TVAudio::ReadFromStream(IStream *pStream)
{
    DWORD dwJunk;
    HRESULT hr = S_OK;

    //
    // If there is a stream pointer, then IPersistPropertyBag::Load has already
    // been called, and therefore this instance already has been initialized
    // with some particular state.
    //
    if (m_pPersistStreamDevice)
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);

    // The first element in the serialized data is the version stamp.
    // This was read by CPersistStream and put into mPS_dwFileVersion.
    // The rest of the data is the tuner state stream followed by the
    // property bag stream.
    if (mPS_dwFileVersion > GetSoftwareVersion())
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    if (0 == mPS_dwFileVersion) {
        // Before any kind of useful persistence was implemented,
        // another version ID was stored in the stream. This reads
        // that value (and basically ignores it).
        hr = pStream->Read(&dwJunk, sizeof(dwJunk), 0);
        if (SUCCEEDED(hr))
            SetDirty(TRUE); // force an update to the persistent stream
    }

    // If all went well, then access the property bag to load and initialize the device
    if(SUCCEEDED(hr))
    {
        IPersistStream *pMonPersistStream;
        hr = CoCreateInstance(CLSID_CDeviceMoniker, NULL, CLSCTX_INPROC_SERVER,
                              IID_IPersistStream, (void **)&pMonPersistStream);
        if(SUCCEEDED(hr)) {
            hr = pMonPersistStream->Load(pStream);
            if(SUCCEEDED(hr)) {
                IPropertyBag *pPropBag;
                hr = pMonPersistStream->QueryInterface(IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr)) {
                    hr = Load(pPropBag, 0);
                    if (SUCCEEDED(hr)) {
                        // Check if we have access to saved state
                        if (CURRENT_PERSIST_VERSION == mPS_dwFileVersion) {
                            long lMode;

                            // Get the filter state
                            hr = pStream->Read(&lMode, sizeof(lMode), 0);
                            if (SUCCEEDED(hr)) {
                                long lOrigMode;

                                // Compare it with the current hardware state and update if different
                                hr = get_TVAudioMode(&lOrigMode);
                                if (SUCCEEDED(hr) && lMode != lOrigMode)
                                    hr = put_TVAudioMode(lMode);
                            }
                        }
                    }
                    pPropBag->Release();
                }
            }

            pMonPersistStream->Release();
        }
    }

    return hr;
}

int TVAudio::SizeMax()
{

    ULARGE_INTEGER ulicb;
    HRESULT hr = E_FAIL;;

    if (m_pPersistStreamDevice) {
        hr = m_pPersistStreamDevice->GetSizeMax(&ulicb);
        if(hr == S_OK) {
            // space for the filter state
            ulicb.QuadPart += sizeof(long);
        }
    }

    return hr == S_OK ? (int)ulicb.QuadPart : 0;
}



//--------------------------------------------------------------------------;
// Input Pin
//--------------------------------------------------------------------------;

//
// TVAudioInputPin constructor
//
TVAudioInputPin::TVAudioInputPin(TCHAR *pName,
                           TVAudio *pTVAudio,
                           HRESULT *phr,
                           LPCWSTR pPinName) 
	: CBaseInputPin(pName, pTVAudio, pTVAudio, phr, pPinName)
    , CKsSupport (KSPIN_COMMUNICATION_SINK, reinterpret_cast<LPUNKNOWN>(pTVAudio))
	, m_pTVAudio(pTVAudio)
{
    ASSERT(pTVAudio);

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;
}


//
// TVAudioInputPin destructor
//

TVAudioInputPin::~TVAudioInputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("TVAudioInputPin destructor")));
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP TVAudioInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof (IKsPin)) {
        return GetInterface((IKsPin *) this, ppv);
    }
    else if (riid == __uuidof (IKsPropertySet)) {
        return GetInterface((IKsPropertySet *) this, ppv);
    }
    else {
        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


//
// CheckConnect
//
HRESULT TVAudioInputPin::CheckConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    IKsPin *KsPin;
    BOOL fOK = FALSE;

    hr = CBaseInputPin::CheckConnect(pReceivePin);
    if (FAILED(hr)) 
        return hr;

    // If the receiving pin supports IKsPin, then check for a match on the
    // Medium GUID, or check for a wildcard.
	if (SUCCEEDED (hr = pReceivePin->QueryInterface (
            __uuidof (IKsPin), (void **) &KsPin))) {

        PKSMULTIPLE_ITEM MediumList = NULL;
        PKSPIN_MEDIUM Medium;

        if (SUCCEEDED (hr = KsPin->KsQueryMediums(&MediumList))) {
            if ((MediumList->Count == 1) && 
                (MediumList->Size == (sizeof(KSMULTIPLE_ITEM) + sizeof(KSPIN_MEDIUM)))) {

				Medium = reinterpret_cast<PKSPIN_MEDIUM>(MediumList + 1);
                if (IsEqualGUID (Medium->Set, m_Medium.Set) && 
                        Medium->Id == m_Medium.Id &&
                        Medium->Flags == m_Medium.Flags) {
					fOK = TRUE;
				}
			}

            CoTaskMemFree(MediumList);
        }
        
        KsPin->Release();
    }
    else {
        if (IsEqualGUID (GUID_NULL, m_Medium.Set)) { 
            fOK = TRUE;
        }
    }
    
    return fOK ? NOERROR : E_INVALIDARG;

} // CheckConnect




//
// CheckMediaType
//
HRESULT TVAudioInputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    if (*(pmt->Type()) != MEDIATYPE_AnalogAudio ) {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    return NOERROR;

} // CheckMediaType


//
// SetMediaType
//
HRESULT TVAudioInputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the base class likes it
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    ASSERT(m_Connected != NULL);
    return NOERROR;

} // SetMediaType


//
// BreakConnect
//
HRESULT TVAudioInputPin::BreakConnect()
{
    return NOERROR;
} // BreakConnect


//
// Receive
//
HRESULT TVAudioInputPin::Receive(IMediaSample *pSample)
{
    CAutoLock lock_it(m_pLock);

    // Check that all is well with the base class
    HRESULT hr = NOERROR;
    hr = CBaseInputPin::Receive(pSample);
    if (hr != NOERROR)
        return hr;

    return NOERROR;

} // Receive


//
// Completed a connection to a pin
//
HRESULT TVAudioInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
        return hr;
    }

    return S_OK;
}

//--------------------------------------------------------------------------;
// Output Pin
//--------------------------------------------------------------------------;

//
// TVAudioOutputPin constructor
//
TVAudioOutputPin::TVAudioOutputPin(TCHAR *pName,
                             TVAudio *pTVAudio,
                             HRESULT *phr,
                             LPCWSTR pPinName) 
	: CBaseOutputPin(pName, pTVAudio, pTVAudio, phr, pPinName) 
    , CKsSupport (KSPIN_COMMUNICATION_SINK, reinterpret_cast<LPUNKNOWN>(pTVAudio))
	, m_pTVAudio(pTVAudio)
{
    ASSERT(pTVAudio);

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;
}


//
// TVAudioOutputPin destructor
//
TVAudioOutputPin::~TVAudioOutputPin()
{
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP TVAudioOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof (IKsPin)) {
        return GetInterface((IKsPin *) this, ppv);
    }
    else if (riid == __uuidof (IKsPropertySet)) {
        return GetInterface((IKsPropertySet *) this, ppv);
    }
    else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface

//
// CheckConnect
//
HRESULT TVAudioOutputPin::CheckConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    IKsPin *KsPin;
    BOOL fOK = FALSE;

    hr = CBaseOutputPin::CheckConnect(pReceivePin);
    if (FAILED(hr)) 
        return hr;

    // If the receiving pin supports IKsPin, then check for a match on the
    // Medium GUID, or check for a wildcard.
	if (SUCCEEDED (hr = pReceivePin->QueryInterface (
            __uuidof (IKsPin), (void **) &KsPin))) {

        PKSMULTIPLE_ITEM MediumList = NULL;
        PKSPIN_MEDIUM Medium;

        if (SUCCEEDED (hr = KsPin->KsQueryMediums(&MediumList))) {
            if ((MediumList->Count == 1) && 
                (MediumList->Size == (sizeof(KSMULTIPLE_ITEM) + sizeof(KSPIN_MEDIUM)))) {

				Medium = reinterpret_cast<PKSPIN_MEDIUM>(MediumList + 1);
                if (IsEqualGUID (Medium->Set, m_Medium.Set) && 
                        Medium->Id == m_Medium.Id &&
                        Medium->Flags == m_Medium.Flags) {
					fOK = TRUE;
				}
			}

            CoTaskMemFree(MediumList);
        }
        
        KsPin->Release();
    }
    else {
        if (IsEqualGUID (GUID_NULL, m_Medium.Set)) { 
            fOK = TRUE;
        }
    }
    
    return fOK ? NOERROR : E_INVALIDARG;

} // CheckConnect

//
// CheckMediaType
//
HRESULT TVAudioOutputPin::CheckMediaType(const CMediaType *pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_AnalogAudio)	{
        return E_INVALIDARG;
	}

    return S_OK;  // This format is acceptable.

} // CheckMediaType


//
// EnumMediaTypes
//
STDMETHODIMP TVAudioOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(ppEnum);

    return CBaseOutputPin::EnumMediaTypes (ppEnum);

} // EnumMediaTypes


#if 1
//
// EnumMediaTypes
//
HRESULT TVAudioOutputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    CAutoLock lock_it(m_pLock);

    if (iPosition < 0) 
        return E_INVALIDARG;
    if (iPosition >= 1)
	    return VFW_S_NO_MORE_ITEMS;

    pMediaType->SetFormatType(&GUID_NULL);
    pMediaType->SetType(&MEDIATYPE_AnalogAudio);
    pMediaType->SetTemporalCompression(FALSE);
    pMediaType->SetSubtype(&GUID_NULL);

    return NOERROR;
} // EnumMediaTypes

#endif


//
// SetMediaType
//
HRESULT TVAudioOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    // Make sure that the base class likes it
    HRESULT hr;

    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    return NOERROR;

} // SetMediaType


//
// CompleteConnect
//
HRESULT TVAudioOutputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = NOERROR;

    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
        return hr;

    // If the type is not the same as that stored for the input
    // pin then force the input pins peer to be reconnected

    return NOERROR;

} // CompleteConnect


HRESULT TVAudioOutputPin::DecideBufferSize(IMemAllocator *pAlloc,
                                       ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    // Just one buffer of 1 byte in length
    // "Buffers" are used for format change notification only,
    // that is, if a tuner can produce both NTSC and PAL, a
    // buffer will only be sent to notify the receiving pin
    // of the format change

    pProperties->cbBuffer = 1;
    pProperties->cBuffers = 1;

    // Ask the allocator to reserve us the memory

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\tvaudio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1997  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __TVAUDIO__
#define __TVAUDIO__

#define MODE_MONO_STEREO_MASK (KS_TVAUDIO_MODE_MONO | KS_TVAUDIO_MODE_STEREO)
#define MODE_LANGUAGE_MASK (KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_LANG_B | KS_TVAUDIO_MODE_LANG_C )

class TVAudio;
class TVAudioOutputPin;
class TVAudioInputPin;

// class for the TVAudio filter's Input pin

class TVAudioInputPin 
	: public CBaseInputPin
	, public CKsSupport
{
protected:
    TVAudio     *m_pTVAudio;                  // Main filter object
	KSPIN_MEDIUM m_Medium;

public:

    // Constructor and destructor
    TVAudioInputPin(TCHAR *pObjName,
                 TVAudio *pTVAudio,
                 HRESULT *phr,
                 LPCWSTR pPinName);

    ~TVAudioInputPin();

	STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);


    // Used to check the input pin connection
    HRESULT CheckConnect (IPin *pReceivePin);
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();

    // Reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    void SetPinMedium (const KSPIN_MEDIUM *Medium)    
            {
                if (Medium == NULL) {
                    m_Medium.Set = GUID_NULL;
                    m_Medium.Id = 0;
                    m_Medium.Flags = 0;
                }
                else {
                    m_Medium = *Medium;
                }
                SetKsMedium (&m_Medium);
            };
};


// Class for the TVAudio filter's Output pins.

class TVAudioOutputPin 
	: public CBaseOutputPin
	, public CKsSupport
{
    friend class TVAudioInputPin;
    friend class TVAudio;

protected:
    TVAudio     *m_pTVAudio;                          // Main filter object pointer
	KSPIN_MEDIUM m_Medium;

public:

    // Constructor and destructor

    TVAudioOutputPin(TCHAR *pObjName,
                   TVAudio *pTVAudio,
                   HRESULT *phr,
                   LPCWSTR pPinName);

    ~TVAudioOutputPin();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);


    HRESULT DecideBufferSize(IMemAllocator * pAlloc,ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Override to enumerate media types
    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);

    // Overriden to create and destroy output pins
    HRESULT CheckConnect (IPin *pReceivePin);
    HRESULT CompleteConnect(IPin *pReceivePin);

    void SetPinMedium (const KSPIN_MEDIUM *Medium)    
            {
                if (Medium == NULL) {
                    m_Medium.Set = GUID_NULL;
                    m_Medium.Id = 0;
                    m_Medium.Flags = 0;
                }
                else {
                    m_Medium = *Medium;
                }
                SetKsMedium (&m_Medium);
            };

};


// Class for the TVAudio filter

class TVAudio: 
    public CCritSec, 
    public IAMTVAudio,
    public CBaseFilter,
    public CPersistStream,
    public IPersistPropertyBag,
    public ISpecifyPropertyPages
{

public:

    DECLARE_IUNKNOWN;

    // Basic COM - used here to reveal our property interface.
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    //
    // --- IAMTVAudio ---
    //
    STDMETHODIMP GetHardwareSupportedTVAudioModes( 
            /* [out] */ long __RPC_FAR *plModes);

    STDMETHODIMP GetAvailableTVAudioModes( 
            /* [out] */ long __RPC_FAR *plModes);
        
    STDMETHODIMP  get_TVAudioMode( 
            /* [out] */ long __RPC_FAR *plMode);
        
    STDMETHODIMP  put_TVAudioMode( 
            /* [in] */ long lMode);
        
    STDMETHODIMP  RegisterNotificationCallBack( 
            /* [in] */ IAMTunerNotification __RPC_FAR *pNotify,
            /* [in] */ long lEvents);
        
    STDMETHODIMP  UnRegisterNotificationCallBack( 
            IAMTunerNotification __RPC_FAR *pNotify);


    // --- IPersistPropertyBag ---
    STDMETHODIMP InitNew(void) ;
    STDMETHODIMP Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog) ;
    STDMETHODIMP Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties) ;
    STDMETHODIMP GetClassID(CLSID *pClsId) ;

    //
    // --- CPersistStream ---
    //

    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    DWORD GetSoftwareVersion(void);
    int SizeMax();

    //
    // --- ISpecifyPropertyPages ---
    //

    STDMETHODIMP GetPages(CAUUID *pPages);



private:

    // Let the pins access our internal state
    friend class TVAudioInputPin;
    friend class TVAudioOutputPin;

    TVAudioInputPin            *m_pTVAudioInputPin;
    TVAudioOutputPin           *m_pTVAudioOutputPin;
    KSPROPERTY_TVAUDIO_CAPS_S   m_Caps;
    KSPROPERTY_TVAUDIO_S        m_Mode;

    // KS Stuff.
    HANDLE m_hDevice;              
    TCHAR *m_pDeviceName;
    int CreateDevice(void);
    BOOL CreatePins ();

    TVAudio(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~TVAudio();

    CBasePin *GetPin(int n);

    int GetPinCount(void);

    int GetDevicePinCount(void);

    // persist stream saved from  IPersistPropertyBag::Load
    IPersistStream *m_pPersistStreamDevice;

};

#endif // __TVAUDIO__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\ptvaudio.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// ptvaudio.cpp  Property page for TVAudio
//

#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <commctrl.h>
#include <memory.h>
#include <olectl.h>

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"

#include "kssupp.h"
#include "xbar.h"
#include "ptvaudio.h"
#include "tvaudio.h"
#include "resource.h"


// -------------------------------------------------------------------------
// CTVAudioProperties
// -------------------------------------------------------------------------

CUnknown *CTVAudioProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) 
{
    CUnknown *punk = new CTVAudioProperties(lpunk, phr);

    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Create a Property page object 

CTVAudioProperties::CTVAudioProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("TVAudio Property Page"), lpunk, 
        IDD_TVAudioProperties, IDS_TVAUDIOPROPNAME)
    , m_pTVAudio(NULL) 
{

}

// destructor
CTVAudioProperties::~CTVAudioProperties()
{
}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT CTVAudioProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pTVAudio == NULL);

    // Ask the filter for it's control interface
    HRESULT hr = pUnknown->QueryInterface(__uuidof(IAMTVAudio),(void **)&m_pTVAudio);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pTVAudio);

    // Get current filter state

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CTVAudioProperties::OnDisconnect()
{
    // Release the interface

    if (m_pTVAudio == NULL) {
        return E_UNEXPECTED;
    }

    m_pTVAudio->Release();
    m_pTVAudio = NULL;

    return NOERROR;
}


//
// OnActivate
//
// Called on dialog creation

HRESULT CTVAudioProperties::OnActivate(void)
{
    InitPropertiesDialog(m_hwnd);

    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CTVAudioProperties::OnDeactivate(void)
{
    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT CTVAudioProperties::OnApplyChanges(void)
{

    return NOERROR;
}

//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR CTVAudioProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
    int iNotify = HIWORD (wParam);
    long Mode;

    switch (uMsg) {

    case WM_INITDIALOG:
        m_hwnd = hwnd;
        return (INT_PTR)FALSE;    // I don't call setfocus...

    case WM_COMMAND:
        
        switch (LOWORD(wParam)) {

        case IDC_LANG_A:
            if (iNotify == BN_CLICKED) {
                m_pTVAudio->get_TVAudioMode (&Mode);
                Mode &= MODE_MONO_STEREO_MASK;
                m_pTVAudio->put_TVAudioMode (KS_TVAUDIO_MODE_LANG_A | Mode);
            }
            break;
        case IDC_LANG_B:
            if (iNotify == BN_CLICKED) {
                m_pTVAudio->get_TVAudioMode (&Mode);
                Mode &= MODE_MONO_STEREO_MASK;
                m_pTVAudio->put_TVAudioMode (KS_TVAUDIO_MODE_LANG_B | Mode);
            }
            break;
        case IDC_LANG_C:
            if (iNotify == BN_CLICKED) {
                m_pTVAudio->get_TVAudioMode (&Mode);
                Mode &= MODE_MONO_STEREO_MASK;
                m_pTVAudio->put_TVAudioMode (KS_TVAUDIO_MODE_LANG_C | Mode);
            }
            break;
        case IDC_MONO:
            if (iNotify == BN_CLICKED) {
                m_pTVAudio->get_TVAudioMode (&Mode);
                Mode &= MODE_LANGUAGE_MASK;
                m_pTVAudio->put_TVAudioMode (KS_TVAUDIO_MODE_MONO | Mode);
            }
            break;
        case IDC_STEREO:
            if (iNotify == BN_CLICKED) {
                m_pTVAudio->get_TVAudioMode (&Mode);
                Mode &= MODE_LANGUAGE_MASK;
                m_pTVAudio->put_TVAudioMode (KS_TVAUDIO_MODE_STEREO | Mode);
            }
            break;

      default:
            break;

        }

        break;


    default:
        return (INT_PTR)FALSE;

    }
    return (INT_PTR)TRUE;
}


//
// InitPropertiesDialog
//
//
void CTVAudioProperties::InitPropertiesDialog(HWND hwndParent) 
{
    long AvailableModes, CurrentMode;
    HRESULT hr;

    if (m_pTVAudio == NULL)
        return;
    
    hr = m_pTVAudio->GetHardwareSupportedTVAudioModes (&AvailableModes);
    if (SUCCEEDED (hr)) {
        EnableWindow (GetDlgItem (m_hwnd, IDC_LANG_A), AvailableModes & KS_TVAUDIO_MODE_LANG_A);
        EnableWindow (GetDlgItem (m_hwnd, IDC_LANG_B), AvailableModes & KS_TVAUDIO_MODE_LANG_B);
        EnableWindow (GetDlgItem (m_hwnd, IDC_LANG_C), AvailableModes & KS_TVAUDIO_MODE_LANG_C);
        EnableWindow (GetDlgItem (m_hwnd, IDC_MONO),   AvailableModes & KS_TVAUDIO_MODE_MONO);
        EnableWindow (GetDlgItem (m_hwnd, IDC_STEREO), AvailableModes & KS_TVAUDIO_MODE_STEREO);
    }

    hr = m_pTVAudio->get_TVAudioMode (&CurrentMode);
    if (SUCCEEDED (hr)) {
        long ID = -1;

        if (CurrentMode & KS_TVAUDIO_MODE_LANG_A)
            ID = IDC_LANG_A;
        else if (CurrentMode & KS_TVAUDIO_MODE_LANG_B)
            ID = IDC_LANG_B;
        else if (CurrentMode & KS_TVAUDIO_MODE_LANG_C)
            ID = IDC_LANG_C;
            
        if (ID != -1) {
            CheckRadioButton(
                m_hwnd,
                IDC_LANG_A,
                IDC_LANG_C,
                ID);
        }

        ID = -1;

        if (CurrentMode & KS_TVAUDIO_MODE_MONO)
            ID = IDC_MONO;
        else if (CurrentMode & KS_TVAUDIO_MODE_STEREO)
            ID = IDC_STEREO;
            
        if (ID != -1) {
            CheckRadioButton(
                m_hwnd,
                IDC_MONO,
                IDC_STEREO,
                ID);
        }
    }

}


//
// SetDirty
//
// notifies the property page site of changes

void 
CTVAudioProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbar.rc
//
#define IDS_CROSSBARPROPNAME            1
#define IDS_TVAUDIOPROPNAME             2
#define IDD_XBARProperties              103
#define IDD_TVAudioProperties           104
#define IDC_RADIO1                      1000
#define IDC_INPIN                       1002
#define IDC_LinkRelated                 1003
#define IDC_RELATEDPIN                  1004
#define IDC_RELATEDINPUTPIN             1004
#define IDC_CURRENT_INPUT               1005
#define IDC_RELATEDOUTPUTPIN            1006
#define IDC_OUTPIN                      1015
#define IDC_LANG_A                      2000
#define IDC_LANG_B                      2001
#define IDC_LANG_C                      2002
#define IDC_MONO                        2010
#define IDC_STEREO                      2011
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\pxbar.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// pxbar.cpp  Property page for Xbar
//

#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <commctrl.h>
#include <memory.h>
#include <olectl.h>

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"

#include "kssupp.h"
#include "xbar.h"
#include "pxbar.h"
#include "resource.h"


// -------------------------------------------------------------------------
// CXBarProperties
// -------------------------------------------------------------------------

CUnknown *CXBarProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) 
{
    CUnknown *punk = new CXBarProperties(lpunk, phr);

    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Create a Property page object 

CXBarProperties::CXBarProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("Crossbar Property Page"), lpunk, 
        IDD_XBARProperties, IDS_CROSSBARPROPNAME)
    , m_pXBar(NULL) 
{

}

// destructor
CXBarProperties::~CXBarProperties()
{
}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT CXBarProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pXBar == NULL);

    // Ask the filter for it's control interface

    HRESULT hr = pUnknown->QueryInterface(IID_IAMCrossbar,(void **)&m_pXBar);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pXBar);

    // Get current filter state

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CXBarProperties::OnDisconnect()
{
    // Release the interface

    if (m_pXBar == NULL) {
        return E_UNEXPECTED;
    }

    m_pXBar->Release();
    m_pXBar = NULL;

    if (m_pCanRoute) delete [] m_pCanRoute, m_pCanRoute = NULL;
    if (m_pRelatedInput) delete [] m_pRelatedInput, m_pRelatedInput = NULL;
    if (m_pRelatedOutput) delete [] m_pRelatedOutput, m_pRelatedOutput = NULL;
    if (m_pPhysicalTypeInput) delete [] m_pPhysicalTypeInput, m_pPhysicalTypeInput = NULL;
    if (m_pPhysicalTypeOutput) delete [] m_pPhysicalTypeOutput, m_pPhysicalTypeOutput = NULL;

    return NOERROR;
}


//
// OnActivate
//
// Called on dialog creation

HRESULT CXBarProperties::OnActivate(void)
{
    InitPropertiesDialog(m_hwnd);

    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CXBarProperties::OnDeactivate(void)
{
    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT CXBarProperties::OnApplyChanges(void)
{
    long lIn, lOut, lActive, lIndexRelatedOut, lIndexRelatedIn, PhysicalType;
    HRESULT hr;

    lOut = ComboBox_GetCurSel (m_hLBOut);
    lActive = ComboBox_GetCurSel (m_hLBIn);  // This is the CB index
    lIn = (LONG)ComboBox_GetItemData (m_hLBIn, lActive);

    hr = m_pXBar->Route (lOut, lIn); 

    // Try to link related input and output pins if the 
    // control is checked

    if (Button_GetCheck (GetDlgItem (m_hwnd, IDC_LinkRelated))) {
        // Related output pin
        hr = m_pXBar->get_CrossbarPinInfo( 
                        FALSE,       // IsInputPin,
                        lOut,        // PinIndex,
                        &lIndexRelatedOut,
                        &PhysicalType);

        // Related input pin
        hr = m_pXBar->get_CrossbarPinInfo( 
                        TRUE,        // IsInputPin,
                        lIn,         // PinIndex,
                        &lIndexRelatedIn,
                        &PhysicalType);

        hr = m_pXBar->Route (lIndexRelatedOut, lIndexRelatedIn);         
    }

    UpdateInputView(TRUE /*fShowSelectedInput*/);

    return NOERROR;
}


//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR CXBarProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
    int iNotify = HIWORD (wParam);

    switch (uMsg) {

    case WM_INITDIALOG:
        m_hwnd = hwnd;
        return (INT_PTR)TRUE;    // I don't call setfocus...

    case WM_COMMAND:
        
        switch (LOWORD(wParam)) {

        case IDC_OUTPIN:
            if (iNotify == CBN_SELCHANGE) {
                SetDirty();
                UpdateOutputView();
                UpdateInputView(TRUE/*fShowSelectedInput*/);
            }
            break;

        case IDC_INPIN:
            if (iNotify == CBN_SELCHANGE) {
                SetDirty();
                UpdateInputView(FALSE /*fShowSelectedInput*/);
            }
            break;

        default:
            break;

        }

        break;


    default:
        return (INT_PTR)FALSE;

    }
    return (INT_PTR)TRUE;
}


//
// InitPropertiesDialog
//
//
void CXBarProperties::InitPropertiesDialog(HWND hwndParent) 
{
    HRESULT hr;

    if (m_pXBar == NULL)
        return;

    m_hLBOut = GetDlgItem (hwndParent, IDC_OUTPIN);
    m_hLBIn  = GetDlgItem (hwndParent, IDC_INPIN);

    TCHAR szName[MAX_PATH];
    long i, o;

    hr = m_pXBar->get_PinCounts (&m_OutputPinCount, &m_InputPinCount);

    // Sanity check
    ASSERT (m_OutputPinCount * m_InputPinCount < 256 * 256);

    m_pCanRoute = new BOOL [m_OutputPinCount * m_InputPinCount];
    m_pRelatedInput = new long [m_InputPinCount];
    m_pRelatedOutput = new long [m_OutputPinCount];
    m_pPhysicalTypeInput = new long [m_InputPinCount];
    m_pPhysicalTypeOutput = new long [m_OutputPinCount];

    if (!m_pCanRoute ||
        !m_pRelatedInput ||
        !m_pRelatedOutput ||
        !m_pPhysicalTypeInput ||
        !m_pPhysicalTypeOutput) {
        return;
    }
    
    //
    // Get all of the related pin info, and physical pin types
    //

    // Add all of the output pins to the output pin list box

    for (o = 0; o < m_OutputPinCount; o++) {
        if (SUCCEEDED (hr = m_pXBar->get_CrossbarPinInfo( 
                            FALSE,  // IsInputPin,
                            o,      // PinIndex,
                            &m_pRelatedOutput[o],
                            &m_pPhysicalTypeOutput[o]))) {
            StringFromPinType (szName, sizeof(szName)/sizeof(TCHAR), m_pPhysicalTypeOutput[o], FALSE, o);
            ComboBox_InsertString (m_hLBOut, o, szName);
        }
    }
     
    // Check all input pins
    // This probably should be dynamic, but it's useful for debugging
    // drivers to do all possiblities up front.

    for (i = 0; i < m_InputPinCount; i++) {
        if (SUCCEEDED (hr = m_pXBar->get_CrossbarPinInfo( 
                            TRUE,  // IsInputPin,
                            i,      // PinIndex,
                            &m_pRelatedInput[i],
                            &m_pPhysicalTypeInput[i]))) {
        }
    }

    // Check all possible routings
    // This probably should be dynamic, but it's useful for debugging
    // drivers to do all possiblities up front.

    for (o = 0; o < m_OutputPinCount; o++) {
        for (i = 0; i < m_InputPinCount; i++) {
            // The following returns either S_OK, or S_FALSE
            hr = m_pXBar->CanRoute (o, i);
            m_pCanRoute[o * m_InputPinCount + i] = (hr == S_OK);
        }
    }

    ComboBox_SetCurSel (m_hLBOut, 0);

    UpdateOutputView();
    UpdateInputView(TRUE /*fShowSelectedInput*/);
}

void CXBarProperties::UpdateOutputView() 
{
    HRESULT hr;
    long lOut, lIn, IndexRelated1, IndexRelated2, PhysicalType;
    TCHAR szName[MAX_PATH];

    lOut = ComboBox_GetCurSel (m_hLBOut);

    hr = m_pXBar->get_IsRoutedTo ( 
                    lOut,       // OutputPinIndex,
                    &lIn);      // *InputPinIndex

    // Show pin related to output pin
    hr = m_pXBar->get_CrossbarPinInfo( 
                    FALSE,               // IsInputPin,
                    lOut,                // PinIndex,
                    &IndexRelated1,
                    &PhysicalType);

    hr = m_pXBar->get_CrossbarPinInfo( 
                    FALSE,               // IsInputPin,
                    IndexRelated1,       // PinIndex,
                    &IndexRelated2,
                    &PhysicalType);

    StringFromPinType (szName, sizeof(szName)/sizeof(TCHAR), PhysicalType, FALSE, IndexRelated1);
    SetDlgItemText (m_hwnd, IDC_RELATEDOUTPUTPIN, szName);


    // Reset the contents of the input list box
    // and refill it with all of the legal routings
    ComboBox_ResetContent (m_hLBIn);

    long Active = 0;
    for (lIn = 0; lIn < m_InputPinCount; lIn++) {
        if (!m_pCanRoute [lOut * m_InputPinCount + lIn])
            continue;
        
        StringFromPinType (szName, sizeof(szName)/sizeof(TCHAR), m_pPhysicalTypeInput[lIn], TRUE, lIn);
        ComboBox_InsertString (m_hLBIn, Active, szName);
        // Save the actual pin index as private data in the listbox
        ComboBox_SetItemData (m_hLBIn, Active, lIn);
        Active++;
    }

}

void CXBarProperties::UpdateInputView(BOOL fShowSelectedInput) 
{
    HRESULT hr;
    long j, k, lOut, lIn, IndexRelated1, IndexRelated2, PhysicalType;
    TCHAR szName[MAX_PATH];

    lOut = ComboBox_GetCurSel (m_hLBOut);

    hr = m_pXBar->get_IsRoutedTo ( 
                    lOut,       // OutputPinIndex,
                    &lIn);      // *InputPinIndex

    hr = m_pXBar->get_CrossbarPinInfo( 
                    TRUE,       // IsInputPin,
                    lIn,        // PinIndex,
                    &IndexRelated1,
                    &PhysicalType);

    StringFromPinType (szName, sizeof(szName)/sizeof(TCHAR), PhysicalType, TRUE, lIn);
    SetDlgItemText (m_hwnd, IDC_CURRENT_INPUT, szName);

    // Show pin related to input pin
    hr = m_pXBar->get_CrossbarPinInfo( 
                    TRUE,               // IsInputPin,
                    IndexRelated1,       // PinIndex,
                    &IndexRelated2,
                    &PhysicalType);

    StringFromPinType (szName, sizeof(szName)/sizeof(TCHAR), PhysicalType, TRUE, IndexRelated1);
    SetDlgItemText (m_hwnd, IDC_RELATEDINPUTPIN, szName);

    if (fShowSelectedInput) {
        // Show the active input for the selected output pin
        for (j = 0; j < ComboBox_GetCount (m_hLBIn); j++) {
            k = (LONG)ComboBox_GetItemData (m_hLBIn, j);
            if (k == lIn) {
                ComboBox_SetCurSel (m_hLBIn, j);
                break;
            }
        }
    }
}



//
// SetDirty
//
// notifies the property page site of changes

void 
CXBarProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\xbar.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __XBAR__
#define __XBAR__

#define MyValidateWritePtr(p,cb, ret) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            return ret;}

#define IsAudioPin(Pin) (Pin->GetXBarPinType() >= PhysConn_Audio_Tuner)
#define IsVideoPin(Pin) (Pin->GetXBarPinType() <  PhysConn_Audio_Tuner)

class XBar;
class XBarOutputPin;
class XBarInputPin;

// Global functions

long WideStringFromPinType (WCHAR *pc, int nSize, long lType, BOOL fInput);
long StringFromPinType (TCHAR *pc, int nSize, long lType, BOOL fInput, int i);
BOOL KsControl(
           HANDLE hDevice,
           DWORD dwIoControl,
           PVOID pvIn,
           ULONG cbIn,
           PVOID pvOut,
           ULONG cbOut,
           PULONG pcbReturned,
           BOOL fSilent);

// class for the XBar filter's Input pin

class XBarInputPin 
	: public CBaseInputPin
	, public CKsSupport
{
    class CChangeInfo
    {
    public:
        CChangeInfo() {
            m_ChangeInfo.dwFlags = 0;
            m_ChangeInfo.dwCountryCode = static_cast<DWORD>(-1);
            m_ChangeInfo.dwAnalogVideoStandard = static_cast<DWORD>(-1);
            m_ChangeInfo.dwChannel = static_cast<DWORD>(-1);
        }

        void GetChangeInfo(KS_TVTUNER_CHANGE_INFO *ChangeInfo) {
            memcpy(ChangeInfo, &m_ChangeInfo, sizeof(KS_TVTUNER_CHANGE_INFO));
        }
        void SetChangeInfo(KS_TVTUNER_CHANGE_INFO *ChangeInfo) {
            memcpy(&m_ChangeInfo, ChangeInfo, sizeof(KS_TVTUNER_CHANGE_INFO));
        }

    private:
        KS_TVTUNER_CHANGE_INFO m_ChangeInfo;
    } m_ChangeInfo;

protected:
    long            m_Index;            // Index of pin
    XBar           *m_pXBar;            // Main filter object
    int             m_IndexRelatedPin;  // Audio goes with video
    long            m_lType;            // PhysConn_
	KSPIN_MEDIUM	m_Medium;           // Describes physical connection

public:

    // Constructor and destructor
    XBarInputPin(TCHAR *pObjName,
                 XBar *pXBar,
                 HRESULT *phr,
                 LPCWSTR pPinName,
                 long Index);

    ~XBarInputPin();

	STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    void GetChangeInfo(KS_TVTUNER_CHANGE_INFO *ChangeInfo) { m_ChangeInfo.GetChangeInfo(ChangeInfo); }
    void SetIndexRelatedPin (int i)     {m_IndexRelatedPin = i;};
    int  GetIndexRelatedPin ()          {return m_IndexRelatedPin;};
    void SetXBarPinType (long lType)    {m_lType = lType;};
    long GetXBarPinType ()              {return m_lType;};
    void SetXBarPinMedium (const KSPIN_MEDIUM *Medium)    
            {
                if (Medium == NULL) {
                    m_Medium.Set = GUID_NULL;
                    m_Medium.Id = 0;
                    m_Medium.Flags = 0;
                }
                else {
                    m_Medium = *Medium;
                }
                SetKsMedium (&m_Medium);
            };

    // Used to check the input pin connection
    HRESULT CheckConnect (IPin *pReceivePin);
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();

    // Reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    STDMETHODIMP QueryInternalConnections(
        IPin* *apPin,     // array of IPin*
        ULONG *nPin);     // on input, the number of slots
                          // on output  the number of pins
    
};


// Class for the XBar filter's Output pins.

class XBarOutputPin 
	: public CBaseOutputPin
	, public CKsSupport
{
    friend class XBarInputPin;
    friend class XBar;

protected:
    long            m_Index;                // Index of this pin
    XBar           *m_pXBar;                // Main filter object pointer
    XBarInputPin   *m_pConnectedInputPin;
    int             m_IndexRelatedPin;
    long            m_lType;                // PhysConn_
	KSPIN_MEDIUM	m_Medium;               // Describes physical connection
    BOOL            m_Muted;                // True if muted due to tuning change
    long            m_PreMuteRouteIndex;    // connection before mute

public:

    // Constructor and destructor

    XBarOutputPin(TCHAR *pObjName,
                   XBar *pXBar,
                   HRESULT *phr,
                   LPCWSTR pPinName,
                   long Index);

    ~XBarOutputPin();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    void SetIndexRelatedPin (int i)     {m_IndexRelatedPin = i;};
    int  GetIndexRelatedPin ()          {return m_IndexRelatedPin;};
    void SetXBarPinType (long lType)    {m_lType = lType;};
    long GetXBarPinType ()              {return m_lType;};
    void SetXBarPinMedium (const KSPIN_MEDIUM *Medium)    
            {
                if (Medium == NULL) {
                    m_Medium.Set = GUID_NULL;
                    m_Medium.Id = 0;
                    m_Medium.Flags = 0;
                }
                else {
                    m_Medium = *Medium;
                }
                SetKsMedium (&m_Medium);
            };

    STDMETHODIMP Mute (BOOL Mute);
    
    HRESULT DecideBufferSize(IMemAllocator * pAlloc,ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Override to enumerate media types
    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);

    // Overriden to create and destroy output pins
    HRESULT CheckConnect (IPin *pReceivePin);
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();

    STDMETHODIMP QueryInternalConnections(
        IPin* *apPin,     // array of IPin*
        ULONG *nPin);     // on input, the number of slots
                          // on output  the number of pins

};


// Class for the XBar filter

class XBar: 
    public CCritSec, 
    public IAMCrossbar,
    public CBaseFilter,
    public CPersistStream,
    public IPersistPropertyBag,
    public ISpecifyPropertyPages
{

public:

    DECLARE_IUNKNOWN;

    // Basic COM - used here to reveal our property interface.
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    STDMETHODIMP RouteInternal( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex,
            /* [in] */ BOOL fOverridePreMuteRouting);

    HRESULT DeliverChangeInfo(DWORD dwFlags, XBarInputPin *pInPin, XBarOutputPin *OutPin);

    // IAMCrossbar methods
    
    STDMETHODIMP get_PinCounts( 
            /* [out] */ long *OutputPinCount,
            /* [out] */ long *InputPinCount);
        
    STDMETHODIMP CanRoute( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex);
        
    STDMETHODIMP Route( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex);
        
    STDMETHODIMP get_IsRoutedTo( 
            /* [in] */ long OutputPinIndex,
            /* [out] */ long *InputPinIndex);
        
    STDMETHODIMP get_CrossbarPinInfo( 
            /* [in] */ BOOL IsInputPin,
            /* [in] */ long PinIndex,
            /* [out] */ long *PinIndexRelated,
            /* [out] */ long *PhysicalType);


    // --- IPersistPropertyBag ---
    STDMETHODIMP InitNew(void) ;
    STDMETHODIMP Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog) ;
    STDMETHODIMP Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties) ;
    STDMETHODIMP GetClassID(CLSID *pClsId) ;

    //
    // --- CPersistStream ---
    //

    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    DWORD GetSoftwareVersion(void);
    int SizeMax();

    //
    // --- ISpecifyPropertyPages ---
    //

    STDMETHODIMP GetPages(CAUUID *pPages);



private:

    // Let the pins access our internal state
    friend class XBarInputPin;
    friend class XBarOutputPin;
    typedef CGenericList <XBarOutputPin> COutputList;
    typedef CGenericList <XBarInputPin> CInputList;

    INT m_NumInputPins;             // Input pin count
    CInputList m_InputPinsList;     // List of the input pins

    INT m_NumOutputPins;            // Output pin count
    COutputList m_OutputPinsList;   // List of the output pins

    // KS Stuff.
    HANDLE m_hDevice;              
    TCHAR *m_pDeviceName;
    int CreateDevice(void);


    XBar(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~XBar();

    CBasePin *GetPin(int n);

    int GetPinCount(void);

    int GetDevicePinCount(void);

    // The following manage the lists of input and output pins

    HRESULT CreateInputPins();
    void DeleteInputPins();
    XBarInputPin *GetInputPinNFromList(int n);
    int FindIndexOfInputPin (IPin *pPin);

    HRESULT CreateOutputPins();
    void DeleteOutputPins();
    XBarOutputPin *GetOutputPinNFromList(int n);
    int FindIndexOfOutputPin (IPin *pPin);

    BOOL IsRouted (IPin * pOutputPin, IPin *pInputPin);

    // persist stream saved from  IPersistPropertyBag::Load
    IPersistStream *m_pPersistStreamDevice;
};

#endif // __XBAR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\xbar\xbar.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <initguid.h>
#include <tchar.h>
#include <stdio.h>

#include <initguid.h>
#include <olectl.h>

#include <amtvuids.h>     // GUIDs  

#include <devioctl.h>

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "amkspin.h"

#include "kssupp.h"
#include "xbar.h"
#include "pxbar.h"
#include "tvaudio.h"
#include "ptvaudio.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

CFactoryTemplate g_Templates [] = {
    { L"WDM Analog Crossbar"
    , &CLSID_CrossbarFilter
    , XBar::CreateInstance
    , NULL
    , NULL },

    { L"WDM Analog Crossbar Property Page"
    , &CLSID_CrossbarFilterPropertyPage
    , CXBarProperties::CreateInstance
    , NULL
    , NULL } ,

    { L"WDM TVAudio"
    , &CLSID_TVAudioFilter
    , TVAudio::CreateInstance
    , NULL
    , NULL },

    { L"WDM TVAudio Property Page"
    , &CLSID_TVAudioFilterPropertyPage
    , CTVAudioProperties::CreateInstance
    , NULL
    , NULL } ,

};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
// WideStringFromPinType
//

long WideStringFromPinType (WCHAR *pc, int nSize, long lType, BOOL fInput, int index)
{
    WCHAR *pcT;


    if (index == -1) {
        pcT = L"Mute";
    }
    else {
        switch (lType) {
    
        case PhysConn_Video_Tuner:              pcT = L"Video Tuner";           break;
        case PhysConn_Video_Composite:          pcT = L"Video Composite";       break;
        case PhysConn_Video_SVideo:             pcT = L"Video SVideo";          break;
        case PhysConn_Video_RGB:                pcT = L"Video RGB";             break;
        case PhysConn_Video_YRYBY:              pcT = L"Video YRYBY";           break;
        case PhysConn_Video_SerialDigital:      pcT = L"Video SerialDigital";   break;
        case PhysConn_Video_ParallelDigital:    pcT = L"Video ParallelDigital"; break;
        case PhysConn_Video_SCSI:               pcT = L"Video SCSI";            break;
        case PhysConn_Video_AUX:                pcT = L"Video AUX";             break;
        case PhysConn_Video_1394:               pcT = L"Video 1394";            break;
        case PhysConn_Video_USB:                pcT = L"Video USB";             break;
        case PhysConn_Video_VideoDecoder:       pcT = L"Video Decoder";         break;
        case PhysConn_Video_VideoEncoder:       pcT = L"Video Encoder";         break;
    
        case PhysConn_Audio_Tuner:              pcT = L"Audio Tuner";           break;
        case PhysConn_Audio_Line:               pcT = L"Audio Line";            break;
        case PhysConn_Audio_Mic:                pcT = L"Audio Mic";             break;
        case PhysConn_Audio_AESDigital:         pcT = L"Audio AESDigital";      break;
        case PhysConn_Audio_SPDIFDigital:       pcT = L"Audio SPDIFDigital";    break;
        case PhysConn_Audio_SCSI:               pcT = L"Audio SCSI";            break;
        case PhysConn_Audio_AUX:                pcT = L"Audio AUX";             break;
        case PhysConn_Audio_1394:               pcT = L"Audio 1394";            break;
        case PhysConn_Audio_USB:                pcT = L"Audio USB";             break;
        case PhysConn_Audio_AudioDecoder:       pcT = L"Audio Decoder";         break;
    
        default:
            pcT = L"Unknown";
            break;
    
        }
    }
    return swprintf (pc, fInput ? L"%d: %s In" : L"%d: %s Out", index, pcT);
                  
};


//
// StringFromPinType
//

long StringFromPinType (TCHAR *pc, int nSize, long lType, BOOL fInput, int j)
{
    WCHAR wName[MAX_PATH];
    long l;

    l = WideStringFromPinType (wName, nSize, lType, fInput, j);

#ifdef _UNICODE
    lstrcpyn (pc, wName, nSize);
#else    
    l = wcstombs (pc, wName, nSize);
#endif                  
    return l;
};

//
// This should be in a library, or helper object
//

BOOL
KsControl
(
   HANDLE hDevice,
   DWORD dwIoControl,
   PVOID pvIn,
   ULONG cbIn,
   PVOID pvOut,
   ULONG cbOut,
   PULONG pcbReturned,
   BOOL fSilent
)
{
   BOOL fResult;
   OVERLAPPED ov;

   RtlZeroMemory( &ov, sizeof( OVERLAPPED ) ) ;
   if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL )))
        return FALSE ;

    fResult =
        DeviceIoControl( hDevice,
		       dwIoControl,
		       pvIn,
		       cbIn,
		       pvOut,
		       cbOut,
		       pcbReturned,
		       &ov ) ;


    if (!fResult) {
        if (ERROR_IO_PENDING == GetLastError()) {
	        WaitForSingleObject(ov.hEvent, INFINITE) ;
	        fResult = TRUE ;
        } 
        else {
	        fResult = FALSE ;
	        if(!fSilent)
	            MessageBox(NULL, TEXT("DeviceIoControl"), TEXT("Failed"), MB_OK);
        }
   }

   CloseHandle(ov.hEvent) ;

   return fResult ;
}

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI XBar::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new XBar(NAME("Analog Crossbar"), pUnk, phr);
}


//
// Constructor
//
XBar::XBar(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_InputPinsList(NAME("XBar Input Pins list")),
    m_NumInputPins(0),
    m_OutputPinsList(NAME("XBar Output Pins list")),
    m_NumOutputPins(0),
    m_pPersistStreamDevice(NULL),
    m_hDevice(NULL),
    m_pDeviceName(NULL),
    CBaseFilter(NAME("Crossbar filter"), pUnk, this, CLSID_CrossbarFilter),
    CPersistStream(pUnk, phr)
{
    ASSERT(phr);

}


//
// Destructor
//
XBar::~XBar()
{
    POSITION pos;
    XBarOutputPin *Pin;

    //
    // Mute all of the output pins on destruction
    //

    TRAVERSELIST(m_OutputPinsList, pos) {
        if (Pin = m_OutputPinsList.Get(pos)) {
            Pin->Mute (TRUE);
        }
    }

    DeleteInputPins();
    DeleteOutputPins();

    // close the device
    if(m_hDevice) {
	    CloseHandle(m_hDevice);
    }

    if(m_pDeviceName) {
        delete [] m_pDeviceName;
    }

    if (m_pPersistStreamDevice) {
       m_pPersistStreamDevice->Release();
    }
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP XBar::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == IID_IAMCrossbar) {
        return GetInterface((IAMCrossbar *) this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    }
    else if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag *) this, ppv);
    }
    else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    }
    else {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


// -------------------------------------------------------------------------
// ISpecifyPropertyPages
// -------------------------------------------------------------------------

//
// GetPages
//
// Returns the clsid's of the property pages we support
STDMETHODIMP XBar::GetPages(CAUUID *pPages) {

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_CrossbarFilterPropertyPage;

    return NOERROR;
}

// We can't Cue!

STDMETHODIMP XBar::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    HRESULT hr = CBaseFilter::GetState(dwMSecs, State);
    
    if (m_State == State_Paused) {
        hr = ((HRESULT)VFW_S_CANT_CUE); // VFW_S_CANT_CUE;
    }
    return hr;
};


// -------------------------------------------------------------------------
// IAMCrossbar 
// -------------------------------------------------------------------------
STDMETHODIMP 
XBar::get_PinCounts( 
            /* [out] */ long *OutputPinCount,
            /* [out] */ long *InputPinCount)
{
    MyValidateWritePtr (OutputPinCount, sizeof(long), E_POINTER);
    MyValidateWritePtr (InputPinCount, sizeof(long), E_POINTER);

    *OutputPinCount = m_NumOutputPins;
    *InputPinCount  = m_NumInputPins;

    return S_OK;
}


STDMETHODIMP 
XBar::CanRoute( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex)
{
    KSPROPERTY_CROSSBAR_ROUTE_S Route;
    BOOL fOK;
    ULONG cbReturned;

    // TODO:  Verify validity of indices

    Route.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
    Route.Property.Id    = KSPROPERTY_CROSSBAR_CAN_ROUTE;
    Route.Property.Flags = KSPROPERTY_TYPE_GET;

    Route.IndexInputPin  = InputPinIndex;
    Route.IndexOutputPin = OutputPinIndex;
    Route.CanRoute = FALSE;

    if (Route.IndexOutputPin == -1) {
        return S_FALSE;
    }

    fOK = KsControl(m_hDevice, 
            (DWORD) IOCTL_KS_PROPERTY,
	    &Route,
	    sizeof(Route),
	    &Route,
	    sizeof(Route),
	    &cbReturned,
	    TRUE);

    return Route.CanRoute ? S_OK : S_FALSE;
};


STDMETHODIMP 
XBar::Route ( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex)
{
    return RouteInternal ( 
                    OutputPinIndex,
                    InputPinIndex,
                    TRUE);
};

STDMETHODIMP 
XBar::RouteInternal ( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex,
            /* [in] */ BOOL fOverridePreMuteRouting)
{
    KSPROPERTY_CROSSBAR_ROUTE_S Route;
    BOOL fOK;
    HRESULT hr = S_OK;
    ULONG cbReturned;

    if (CanRoute (OutputPinIndex, InputPinIndex) == S_FALSE) {
        return S_FALSE;
    }

    // Only need OutPin to continue
    XBarOutputPin *OutPin = GetOutputPinNFromList(OutputPinIndex);
    if (OutPin)
    {
        XBarInputPin *InPin = GetInputPinNFromList(InputPinIndex);

        Route.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
        Route.Property.Id    = KSPROPERTY_CROSSBAR_ROUTE;
        Route.Property.Flags = KSPROPERTY_TYPE_SET;

        Route.IndexInputPin  = InputPinIndex;
        Route.IndexOutputPin = OutputPinIndex;

        if (IsVideoPin(OutPin))
        {
            DeliverChangeInfo(KS_TVTUNER_CHANGE_BEGIN_TUNE, InPin, OutPin);

            fOK = KsControl(m_hDevice, 
                    (DWORD) IOCTL_KS_PROPERTY,
	            &Route,
	            sizeof(Route),
	            &Route,
	            sizeof(Route),
	            &cbReturned,
	            TRUE);

            DeliverChangeInfo(KS_TVTUNER_CHANGE_END_TUNE, InPin, OutPin);
        }
        else
        {
            fOK = KsControl(m_hDevice, 
                    (DWORD) IOCTL_KS_PROPERTY,
	            &Route,
	            sizeof(Route),
	            &Route,
	            sizeof(Route),
	            &cbReturned,
	            TRUE);
        }

        if (fOK)
        {
            SetDirty(TRUE);

            OutPin->m_pConnectedInputPin = InPin;

            if (fOverridePreMuteRouting)
            {
                OutPin->m_PreMuteRouteIndex = InputPinIndex;
                OutPin->m_Muted = (InputPinIndex == -1) ? TRUE : FALSE;
            }
        }
        else
            hr = S_FALSE;
    }

    return hr;
};

HRESULT
XBar::DeliverChangeInfo(DWORD dwFlags, XBarInputPin *pInPin, XBarOutputPin *pOutPin)
{
    CAutoLock Lock(m_pLock);
    IMediaSample *pMediaSample = NULL;

    if (pOutPin == NULL || !pOutPin->IsConnected())
        return S_OK;

    HRESULT hr = pOutPin->GetDeliveryBuffer(&pMediaSample, NULL, NULL, 0);
    if (!FAILED(hr) && pMediaSample != NULL)
    {
        if (pMediaSample->GetSize() >= sizeof(KS_TVTUNER_CHANGE_INFO))
        {
            KS_TVTUNER_CHANGE_INFO *ChangeInfo;
    
            // Get the sample's buffer pointer
            hr = pMediaSample->GetPointer(reinterpret_cast<BYTE**>(&ChangeInfo));
            if (!FAILED(hr))
            {
                pMediaSample->SetActualDataLength(sizeof(KS_TVTUNER_CHANGE_INFO));

                // Check for an input pin to grab the ChangeInfo from
                if (!pInPin)
                {
                    ChangeInfo->dwCountryCode = static_cast<DWORD>(-1);
                    ChangeInfo->dwAnalogVideoStandard = static_cast<DWORD>(-1);
                    ChangeInfo->dwChannel = static_cast<DWORD>(-1);
                }
                else
                    pInPin->GetChangeInfo(ChangeInfo);

                ChangeInfo->dwFlags = dwFlags;

                DbgLog(( LOG_TRACE, 4, TEXT("Delivering change info on route change (channel = %d)"), ChangeInfo->dwChannel));

                hr = pOutPin->Deliver(pMediaSample);
            }
        }

        pMediaSample->Release();

        // Perform the mute operation on a related audio pin
        pOutPin->Mute(dwFlags & KS_TVTUNER_CHANGE_BEGIN_TUNE);
    }

    return hr;
}

STDMETHODIMP 
XBar::get_IsRoutedTo ( 
            /* [in] */  long OutputPinIndex,
            /* [out] */ long *InputPinIndex)
{
    KSPROPERTY_CROSSBAR_ROUTE_S Route;
    BOOL fOK;
    ULONG cbReturned;

    MyValidateWritePtr (InputPinIndex, sizeof(long), E_POINTER);

    Route.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
    Route.Property.Id    = KSPROPERTY_CROSSBAR_ROUTE;
    Route.Property.Flags = KSPROPERTY_TYPE_GET;

    Route.IndexOutputPin = OutputPinIndex;

    if (Route.IndexOutputPin == -1) {
        return S_FALSE;
    }

    fOK = KsControl(m_hDevice, 
            (DWORD) IOCTL_KS_PROPERTY,
	    &Route,
	    sizeof(Route),
	    &Route,
	    sizeof(Route),
	    &cbReturned,
	    TRUE);

    *InputPinIndex = Route.IndexInputPin;

    // TODO:  Verify validity of indices

    return fOK ? S_OK : S_FALSE;
};

STDMETHODIMP 
XBar::get_CrossbarPinInfo( 
            /* [in] */ BOOL IsInputPin,
            /* [in] */ long PinIndex,
            /* [out] */ long *PinIndexRelated,
            /* [out] */ long *PhysicalType)
{
    XBarOutputPin * pOutPin;
    XBarInputPin * pInPin;

    MyValidateWritePtr (PinIndexRelated, sizeof(long), E_POINTER);
    MyValidateWritePtr (PhysicalType, sizeof(long), E_POINTER);

    *PinIndexRelated = -1;
    *PhysicalType = 0;

    // TODO:  Verify validity of indices

    if (IsInputPin) {
        if (pInPin = GetInputPinNFromList (PinIndex)) {
            *PinIndexRelated = pInPin->GetIndexRelatedPin();
            *PhysicalType = pInPin->GetXBarPinType ();
        }
    } 
    else {
        if (pOutPin = GetOutputPinNFromList (PinIndex)) {
            *PinIndexRelated = pOutPin->GetIndexRelatedPin();
            *PhysicalType = pOutPin->GetXBarPinType ();
        }
    }

    return (*PhysicalType != 0) ? S_OK : S_FALSE;
};

int XBar::CreateDevice()
{
    HANDLE hDevice ;

    hDevice = CreateFile( m_pDeviceName,
		     GENERIC_READ | GENERIC_WRITE,
		     0,
		     NULL,
		     OPEN_EXISTING,
		     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		     NULL ) ;

    if (hDevice == (HANDLE) -1) {
	    MessageBox(NULL, m_pDeviceName, TEXT("Error: Can't CreateFile device"), MB_OK);
	    return 0 ;
    } else {
	    m_hDevice = hDevice;
	    return 1;
    }
}



//
// GetPin
//
CBasePin *XBar::GetPin(int n) 
{
    if (n < m_NumInputPins)
        return GetInputPinNFromList (n);
    else
        return GetOutputPinNFromList (n - m_NumInputPins);
}

//
// GetPinCount
//
int XBar::GetPinCount(void)
{
    return m_NumInputPins + m_NumOutputPins;
}


//
// GetPinCount
//
int XBar::GetDevicePinCount(void)
{
    KSPROPERTY_CROSSBAR_CAPS_S Caps;
    ULONG       cbReturned;
    BOOL        fOK;

    if(!m_hDevice)
	return 0;

    Caps.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
    Caps.Property.Id    = KSPROPERTY_CROSSBAR_CAPS;
    Caps.Property.Flags = KSPROPERTY_TYPE_GET;
    Caps.NumberOfInputs = Caps.NumberOfOutputs = 0;

    fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &Caps,
	            sizeof(Caps),
	            &Caps,
	            sizeof(Caps),
	            &cbReturned,
	            TRUE);

    m_NumInputPins = Caps.NumberOfInputs;
    m_NumOutputPins = Caps.NumberOfOutputs;

    return m_NumInputPins + m_NumOutputPins;
}

//
// CreateInputPins
//
HRESULT XBar::CreateInputPins()
{
    WCHAR szbuf[64];            // Temporary scratch buffer
    HRESULT hr = NOERROR;
    int i;
    KSPROPERTY_CROSSBAR_PININFO_S PinInfo;
    BOOL fOK;
    ULONG cbReturned;

    for (i = 0; SUCCEEDED(hr) && i < m_NumInputPins; i++)
    {
        ZeroMemory (&PinInfo, sizeof (PinInfo));

        PinInfo.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
        PinInfo.Property.Id    = KSPROPERTY_CROSSBAR_PININFO;
        PinInfo.Property.Flags = KSPROPERTY_TYPE_GET;
        PinInfo.Direction      = KSPIN_DATAFLOW_IN;

        PinInfo.Index = i;

        fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &PinInfo,
	            sizeof(PinInfo),
	            &PinInfo,
	            sizeof(PinInfo),
	            &cbReturned,
	            TRUE);
        if (fOK)
        {
            WideStringFromPinType(szbuf, sizeof(szbuf)/sizeof(WCHAR), PinInfo.PinType, TRUE /*fInput*/, i);

            XBarInputPin *pPin = new XBarInputPin(NAME("XBar Input"), this,
					            &hr, szbuf, i);
            if (pPin)
            {
                if (SUCCEEDED(hr))
                {
                    pPin->SetIndexRelatedPin (PinInfo.RelatedPinIndex);
                    pPin->SetXBarPinType (PinInfo.PinType);

                    pPin->SetXBarPinMedium (&PinInfo.Medium);

                    m_InputPinsList.AddTail (pPin);
                }
                else
                    delete pPin;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_FAIL;
    }

    return hr;
} // CreateInputPins

//
// CreateOutputPins
//
HRESULT XBar::CreateOutputPins()
{
    WCHAR szbuf[64];            // Temporary scratch buffer
    HRESULT hr = NOERROR;
    long i, k;
    KSPROPERTY_CROSSBAR_PININFO_S PinInfo;
    BOOL fOK;
    ULONG cbReturned;

    for (i = 0; SUCCEEDED(hr) && i < m_NumOutputPins; i++)
    {
        ZeroMemory (&PinInfo, sizeof (PinInfo));

        PinInfo.Property.Set   = PROPSETID_VIDCAP_CROSSBAR;
        PinInfo.Property.Id    = KSPROPERTY_CROSSBAR_PININFO;
        PinInfo.Property.Flags = KSPROPERTY_TYPE_GET;
        PinInfo.Direction      = KSPIN_DATAFLOW_OUT;

        PinInfo.Index = i;

        fOK = KsControl(m_hDevice, 
                (DWORD) IOCTL_KS_PROPERTY,
	            &PinInfo,
	            sizeof(PinInfo),
	            &PinInfo,
	            sizeof(PinInfo),
	            &cbReturned,
	            TRUE);
        if (fOK)
        {
            WideStringFromPinType(szbuf, sizeof(szbuf)/sizeof(WCHAR), PinInfo.PinType, FALSE /*fInput*/, i);

            XBarOutputPin *pPin = new XBarOutputPin(NAME("XBar Output"), this,
					            &hr, szbuf, i);
            if (pPin)
            {
                if (SUCCEEDED(hr))
                {
                    pPin->SetIndexRelatedPin (PinInfo.RelatedPinIndex);
                    pPin->SetXBarPinType (PinInfo.PinType);

                    pPin->SetXBarPinMedium (&PinInfo.Medium);


                    m_OutputPinsList.AddTail (pPin);
                }
                else
                    delete pPin;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr)) {
        //
        // Now establish the default connections,
        //   ie which input is connected to each
        //   output
        //
        for (i = 0; i < m_NumOutputPins; i++) {
            hr = get_IsRoutedTo (i, &k);
            if (S_OK == hr) {
                GetOutputPinNFromList(i)->m_pConnectedInputPin = 
                    GetInputPinNFromList(k);
            }
            else {
                GetOutputPinNFromList(i)->m_pConnectedInputPin =
                    NULL;
            }

        }
        hr = S_OK;  // hide any failures from this operation
    }

    return hr;
} // CreateOutputPins



//
// DeleteInputPins
//
void XBar::DeleteInputPins (void)
{
    XBarInputPin *pPin;

    while (pPin = m_InputPinsList.RemoveHead()) {
        delete pPin;
    }

} // DeleteInputPins


//
// DeleteOutputPins
//
void XBar::DeleteOutputPins (void)
{
    XBarOutputPin *pPin;


    while (pPin = m_OutputPinsList.RemoveHead()) {
        delete pPin;
    }

} // DeleteOutputPins



HRESULT XBar::Stop()
{
    return CBaseFilter::Stop();
}

HRESULT XBar::Pause()
{
    POSITION       pos;
    XBarOutputPin *Pin;

    //
    // Mute all of the output pins on Run to Pause
    //
    if (m_State == State_Running) {
        TRAVERSELIST(m_OutputPinsList, pos) {
            if (Pin = m_OutputPinsList.Get(pos)) {
                Pin->Mute (TRUE);
            }
        }
    }
    return CBaseFilter::Pause();
}

HRESULT XBar::Run(REFERENCE_TIME tStart)
{
    POSITION       pos;
    XBarOutputPin *Pin;

    //
    // UnMute all of the output pins
    //
    TRAVERSELIST(m_OutputPinsList, pos) {
        if (Pin = m_OutputPinsList.Get(pos)) {
            Pin->Mute (FALSE);
        }
    }

    return CBaseFilter::Run(tStart);
}




//
// GetInputPinNFromList
//
XBarInputPin *XBar::GetInputPinNFromList(int n)
{
    // Validate the position being asked for
    if ((n >= m_NumInputPins) || (n < 0))
        return NULL;

    // Get the head of the list
    POSITION pos = m_InputPinsList.GetHeadPosition();
    XBarInputPin *pInputPin = m_InputPinsList.GetHead();

    // GetNext really returns the current object, THEN updates pos to the next item
    while ( n >= 0 ) {
        pInputPin = m_InputPinsList.GetNext(pos);
        n--;
    }
    return pInputPin;

} // GetInputPinNFromList


//
// GetOutputPinNFromList
//
XBarOutputPin *XBar::GetOutputPinNFromList(int n)
{
    // Validate the position being asked for
    if ((n >= m_NumOutputPins) || (n < 0))
        return NULL;

    // Get the head of the list
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    XBarOutputPin *pOutputPin = m_OutputPinsList.GetHead();

    // GetNext really returns the current object, THEN updates pos to the next item
    while ( n >= 0 ) {
        pOutputPin = m_OutputPinsList.GetNext(pos);
        n--;
    }
    return pOutputPin;

} // GetOutputPinNFromList

// 
// Find the Index of the pin in the list, or -1 on failure
// 
int XBar::FindIndexOfInputPin (IPin * pPin)
{
    int j = 0;
    POSITION pos;
    int index = -1;

    TRAVERSELIST(m_InputPinsList, pos) {
        if ((IPin *) m_InputPinsList.Get(pos) == pPin) {
            index = j;
            break;
        }
        j++;
    }
 
    return index;
};

// 
// Find the Index of the pin in the list, or -1 on failure
// 
int XBar::FindIndexOfOutputPin (IPin * pPin)
{
    int j = 0;
    POSITION pos;
    int index = -1;

    TRAVERSELIST(m_OutputPinsList, pos) {
        if ((IPin *) m_OutputPinsList.Get(pos) == pPin) {
            index = j;
            break;
        }
        j++;
    }
 
    return index;
};

// 
// Check whether an output pin is connected to an input pin
// 
BOOL XBar::IsRouted (IPin * pOutputPin, IPin *pInputPin)
{
    long OutputIndex, InputIndex, InputTestIndex;
    HRESULT hr;

    InputIndex = FindIndexOfInputPin (pInputPin);
    OutputIndex = FindIndexOfOutputPin (pOutputPin);

    hr = get_IsRoutedTo ( 
                    OutputIndex,
                    &InputTestIndex);

    return (InputTestIndex == InputIndex);
};



//
// IPersistPropertyBag interface implementation for AMPnP support
//
STDMETHODIMP XBar::InitNew(void)
{
    return S_OK ;
}

STDMETHODIMP 
XBar::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock Lock(m_pLock) ;

    VARIANT var;
    VariantInit(&var);
    V_VT(&var) = VT_BSTR;

    // ::Load can succeed only once
    ASSERT(m_pPersistStreamDevice == 0); 
    
    HRESULT hr = pPropBag->Read(L"DevicePath", &var,0);
    if(SUCCEEDED(hr))
    {
        ULONG DeviceNameSize;

        if (m_pDeviceName) delete [] m_pDeviceName;	
        m_pDeviceName = new TCHAR [DeviceNameSize = (wcslen(V_BSTR(&var)) + 1)];
        if (!m_pDeviceName)
            return E_OUTOFMEMORY;

#ifndef _UNICODE
        WideCharToMultiByte(CP_ACP, 0, V_BSTR(&var), -1,
                            m_pDeviceName, DeviceNameSize, 0, 0);
#else
        lstrcpy(m_pDeviceName, V_BSTR(&var));
#endif
        VariantClear(&var);
        DbgLog((LOG_TRACE,2,TEXT("XBar::Load: use %s"), m_pDeviceName));

        if (CreateDevice()) {
            GetDevicePinCount();
            hr = CreateInputPins();
            if (FAILED(hr))
                return hr;
            hr = CreateOutputPins();
            if (FAILED(hr))
                return hr;
        }
        else {
            return E_FAIL ;
        }

        // save moniker with addref. ignore error if qi fails
        hr = pPropBag->QueryInterface(IID_IPersistStream, (void **)&m_pPersistStreamDevice);

        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP XBar::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, 
                            BOOL fSaveAllProperties)
{
    return E_NOTIMPL ;
}

STDMETHODIMP XBar::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);
}

// -------------------------------------------------------------------------
// IPersistStream interface implementation for saving to a graph file
// -------------------------------------------------------------------------

#define ORIGINAL_DEFAULT_PERSIST_VERSION    0

// Insert obsolete versions above with new names
// Keep the following name, and increment the value if changing the persist stream format

#define CURRENT_PERSIST_VERSION             1

DWORD
XBar::GetSoftwareVersion(
    void
    )
/*++

Routine Description:

    Implement the CPersistStream::GetSoftwareVersion method. Returns
    the new version number rather than the default of zero.

Arguments:

    None.

Return Value:

    Return CURRENT_PERSIST_VERSION.

--*/
{
    return CURRENT_PERSIST_VERSION;
}

HRESULT XBar::WriteToStream(IStream *pStream)
{

    HRESULT hr = E_FAIL;

    if (m_pPersistStreamDevice) {

        hr = m_pPersistStreamDevice->Save(pStream, TRUE);
        if(SUCCEEDED(hr)) {
            long temp = m_NumOutputPins;

            // Save the number of output pins (for sanity check when reading the stream later)
            hr = pStream->Write(&temp, sizeof(temp), 0);

            // Save state of each output pin
            for (long i = 0; SUCCEEDED(hr) && i < m_NumOutputPins; i++) {

                // Get a pointer to the pin object
                XBarOutputPin *OutPin = GetOutputPinNFromList(i);
                if (OutPin) {
                    long k = -1;

                    // Get the route index
                    get_IsRoutedTo(i, &k);

                    // Save the route index, the muted state, and the pre-mute route index
                    hr = pStream->Write(&k, sizeof(long), 0);
                    if (FAILED(hr))
                        break;

                    hr = pStream->Write(&OutPin->m_Muted, sizeof(BOOL), 0);
                    if (FAILED(hr))
                        break;

                    hr = pStream->Write(&OutPin->m_PreMuteRouteIndex, sizeof(long), 0);
                }
                else {
                    hr = E_UNEXPECTED;
                }
            } // for each output pin index
        }
    }
    else {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT XBar::ReadFromStream(IStream *pStream)
{
    DWORD dwJunk;
    HRESULT hr = S_OK;

    //
    // If there is a stream pointer, then IPersistPropertyBag::Load has already
    // been called, and therefore this instance already has been initialized
    // with some particular state.
    //
    if (m_pPersistStreamDevice)
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);

    // The first element in the serialized data is the version stamp.
    // This was read by CPersistStream and put into mPS_dwFileVersion.
    // The rest of the data is the tuner state stream followed by the
    // property bag stream.
    if (mPS_dwFileVersion > GetSoftwareVersion())
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    if (ORIGINAL_DEFAULT_PERSIST_VERSION == mPS_dwFileVersion)
    {
        // Before any kind of useful persistence was implemented,
        // another version ID was stored in the stream. This reads
        // that value (and basically ignores it).
        hr = pStream->Read(&dwJunk, sizeof(dwJunk), 0);
        if (SUCCEEDED(hr))
            SetDirty(TRUE); // force an update to the persistent stream
    }

    // If all went well, then access the property bag to load and initialize the device
    if(SUCCEEDED(hr))
    {
        IPersistStream *pMonPersistStream;
        hr = CoCreateInstance(CLSID_CDeviceMoniker, NULL, CLSCTX_INPROC_SERVER,
                              IID_IPersistStream, (void **)&pMonPersistStream);
        if(SUCCEEDED(hr)) {
            hr = pMonPersistStream->Load(pStream);
            if(SUCCEEDED(hr)) {
                IPropertyBag *pPropBag;
                hr = pMonPersistStream->QueryInterface(IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr)) {
                    hr = Load(pPropBag, 0);
                    if(SUCCEEDED(hr)) {

                        // Check if we have access to saved state
                        if (CURRENT_PERSIST_VERSION == mPS_dwFileVersion) {
                            long lNumOutputPins;

                            // Get the output pin count from the stream
                            hr = pStream->Read(&lNumOutputPins, sizeof(lNumOutputPins), 0);
                            if (SUCCEEDED(hr)) {

                                // Something's wrong if these don't match, but
                                // the following code will work regardless
                                ASSERT(m_NumOutputPins == lNumOutputPins);

                                // Read each output pin's connected state
                                for (long i = 0; i < lNumOutputPins; i++) {
                                    long RouteIndex, PreMuteRouteIndex;
                                    BOOL Muted;

                                    // Get the route index, the muted state, and the pre-mute route index
                                    hr = pStream->Read(&RouteIndex, sizeof(long), 0);
                                    if (FAILED(hr))
                                        break;

                                    hr = pStream->Read(&Muted, sizeof(BOOL), 0);
                                    if (FAILED(hr))
                                        break;

                                    hr = pStream->Read(&PreMuteRouteIndex, sizeof(long), 0);
                                    if (FAILED(hr))
                                        break;

                                    // Get a pointer to the pin
                                    XBarOutputPin *OutPin = GetOutputPinNFromList(i);
                                    if (OutPin) {
                                        long temp = -1;

                                        // Check to see if a route request is necessary
                                        get_IsRoutedTo(i, &temp);
                                        if (RouteIndex != temp) {
                                            RouteInternal(i, RouteIndex, FALSE);
                                        }

                                        OutPin->m_Muted = Muted;
                                        OutPin->m_PreMuteRouteIndex = PreMuteRouteIndex;
                                    }
                                } // for each output pin index
                            }
                        }
                    }
                    pPropBag->Release();
                }
            }

            pMonPersistStream->Release();
        }
    }

   return hr;
}

int XBar::SizeMax()
{

    ULARGE_INTEGER ulicb;
    HRESULT hr = E_FAIL;;

    if (m_pPersistStreamDevice) {
        hr = m_pPersistStreamDevice->GetSizeMax(&ulicb);
        if(hr == S_OK) {
            // space for the filter state (output pin count + state of output pins)
            ulicb.QuadPart +=
                sizeof(long) +
                (sizeof(long) + sizeof(BOOL) + sizeof(long)) * m_NumOutputPins
                ;
        }
    }

    return hr == S_OK ? (int)ulicb.QuadPart : 0;
}



//--------------------------------------------------------------------------;
// Input Pin
//--------------------------------------------------------------------------;

//
// XBarInputPin constructor
//
XBarInputPin::XBarInputPin(TCHAR *pName,
                           XBar *pXBar,
                           HRESULT *phr,
                           LPCWSTR pPinName,
                           LONG Index) 
	: CBaseInputPin(pName, pXBar, pXBar, phr, pPinName)
    , CKsSupport (KSPIN_COMMUNICATION_SINK, reinterpret_cast<LPUNKNOWN>(pXBar))
	, m_pXBar(pXBar)
    , m_Index(Index)
{
    ASSERT(pXBar);

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;
}


//
// XBarInputPin destructor
//

XBarInputPin::~XBarInputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("XBarInputPin destructor")));
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP XBarInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof (IKsPin)) {
        return GetInterface((IKsPin *) this, ppv);
    }
    else if (riid == __uuidof (IKsPropertySet)) {
        return GetInterface((IKsPropertySet *) this, ppv);
    }
    else {
        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


//
// CheckConnect
//
HRESULT XBarInputPin::CheckConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    IKsPin *KsPin;
    BOOL fOK = FALSE;
    PIN_INFO ConnectPinInfo;
    PIN_INFO ReceivePinInfo;

    hr = CBaseInputPin::CheckConnect(pReceivePin);
    if (FAILED(hr)) 
        return hr;

    // Ensure that these pins don't belong to the same filter
    if (SUCCEEDED(QueryPinInfo(&ConnectPinInfo))) {

        if (SUCCEEDED(pReceivePin->QueryPinInfo(&ReceivePinInfo))) {

            if (ConnectPinInfo.pFilter == ReceivePinInfo.pFilter) {
                hr = VFW_E_CIRCULAR_GRAPH;
            }
            QueryPinInfoReleaseFilter(ReceivePinInfo);
        }
        QueryPinInfoReleaseFilter(ConnectPinInfo);
    }
    if (FAILED(hr))
        return hr;

    // If the receiving pin supports IKsPin, then check for a match on the
    // Medium GUID

	if (SUCCEEDED (hr = pReceivePin->QueryInterface (
            __uuidof (IKsPin), (void **) &KsPin))) {

        PKSMULTIPLE_ITEM MediumList = NULL;
        PKSPIN_MEDIUM Medium;

        if (SUCCEEDED (hr = KsPin->KsQueryMediums(&MediumList))) {
            if ((MediumList->Count == 1) && 
                (MediumList->Size == (sizeof(KSMULTIPLE_ITEM) + sizeof(KSPIN_MEDIUM)))) {

				Medium = reinterpret_cast<PKSPIN_MEDIUM>(MediumList + 1);
                if (IsEqualGUID (Medium->Set, m_Medium.Set) && 
                        Medium->Id == m_Medium.Id &&
                        Medium->Flags == m_Medium.Flags) {
					fOK = TRUE;
				}
			}

            CoTaskMemFree(MediumList);
        }
        
        KsPin->Release();
    }
    else {
        if (IsEqualGUID (GUID_NULL, m_Medium.Set)) { 
            fOK = TRUE;
        }
    }
    
    return fOK ? NOERROR : E_INVALIDARG;

} // CheckConnect

//
// DisplayMediaType -- (DEBUG ONLY)
//
void DisplayMediaType(TCHAR *pDescription,const CMediaType *pmt)
{
#ifdef DEBUG

    // Dump the GUID types and a short description

    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("%s"),pDescription));
    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("Media Type Description")));
    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt->Type()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt->Subtype()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype description %s"),GetSubtypeName(pmt->Subtype())));
    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt->cbFormat));

    // Dump the generic media types */

    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt->IsFixedSize()));
    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt->IsTemporalCompressed()));
    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt->GetSampleSize()));

#endif

} // DisplayMediaType

#if 1
//
// GetMediaType
//
HRESULT XBarInputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    CAutoLock lock_it(m_pLock);

    if (iPosition < 0) 
        return E_INVALIDARG;
    if (iPosition >= 1)
	    return VFW_S_NO_MORE_ITEMS;

    if (m_lType >= KS_PhysConn_Audio_Tuner) {
        pMediaType->SetFormatType(&GUID_NULL);
        pMediaType->SetType(&MEDIATYPE_AnalogAudio);
        pMediaType->SetTemporalCompression(FALSE);
        pMediaType->SetSubtype(&GUID_NULL);
    }
    else {

        ANALOGVIDEOINFO avi;

        pMediaType->SetFormatType(&FORMAT_AnalogVideo);
        pMediaType->SetType(&MEDIATYPE_AnalogVideo);
        pMediaType->SetTemporalCompression(FALSE);
        pMediaType->SetSubtype(&KSDATAFORMAT_SUBTYPE_NONE);

        SetRect (&avi.rcSource, 0, 0, 
                720, 480);
        SetRect (&avi.rcTarget, 0, 0,
                720, 480);
        avi.dwActiveWidth  = 720;
        avi.dwActiveHeight =  480;
        avi.AvgTimePerFrame = 0;

        pMediaType->SetFormat ((BYTE *) &avi, sizeof (avi));
    }

    return NOERROR;


} // EnumMediaTypes

#endif

//
// CheckMediaType
//
HRESULT XBarInputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    // If we are already inside checkmedia type for this pin, return NOERROR
    // It is possble to hookup two of the XBar filters and some other filter
    // like the video effects sample to get into this situation. If we don't
    // detect this situation, we will carry on looping till we blow the stack

    HRESULT hr = NOERROR;

    // Display the type of the media for debugging perposes
    DisplayMediaType(TEXT("Input Pin Checking"), pmt);

    if ((*(pmt->Type()) != MEDIATYPE_AnalogAudio ) && 
        (*(pmt->Type()) != MEDIATYPE_AnalogVideo)) {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }


    // The media types that we can support are entirely dependent on the
    // downstream connections. If we have downstream connections, we should
    // check with them - walk through the list calling each output pin

    int n = m_pXBar->m_NumOutputPins;
    POSITION pos = m_pXBar->m_OutputPinsList.GetHeadPosition();

    while(n) {
        XBarOutputPin *pOutputPin = m_pXBar->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            if (m_pXBar->IsRouted (pOutputPin, this)) {      
                // The pin is connected, check its peer
                if (pOutputPin->IsConnected()) {
                    hr = pOutputPin->m_Connected->QueryAccept(pmt);
                
                    if (hr != NOERROR) {
                        return VFW_E_TYPE_NOT_ACCEPTED;
                    }
                }
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }

    return NOERROR;

} // CheckMediaType


//
// SetMediaType
//
HRESULT XBarInputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the base class likes it
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    ASSERT(m_Connected != NULL);
    return NOERROR;

} // SetMediaType


//
// BreakConnect
//
HRESULT XBarInputPin::BreakConnect()
{
    return CBaseInputPin::BreakConnect();
} // BreakConnect


//
// Receive
//
HRESULT XBarInputPin::Receive(IMediaSample *pSampleIn)
{
    CAutoLock lock_it(m_pLock);
    BYTE *pBufIn;

    // Check that all is well with the base class
    HRESULT hr = NOERROR;
    hr = CBaseInputPin::Receive(pSampleIn);
    if (hr != NOERROR)
        return hr;

    // Get the input sample's buffer pointer, and if not the expected size, just return success
    hr = pSampleIn->GetPointer(&pBufIn);
    if (hr != NOERROR || pSampleIn->GetActualDataLength() != sizeof(KS_TVTUNER_CHANGE_INFO))
        return hr;

    DbgLog(( LOG_TRACE, 4, TEXT("Caching change info (channel = %d)"), reinterpret_cast<KS_TVTUNER_CHANGE_INFO*>(pBufIn)->dwChannel));

    // Save the change info for use during route changes
    m_ChangeInfo.SetChangeInfo(reinterpret_cast<KS_TVTUNER_CHANGE_INFO*>(pBufIn));

    // Walk through the output pins list, 
    // delivering to each in turn if connected

    // JayBo made the following comment when writing this code:
    // "What about audio mute notifications?"
    // Don't know exactly what this means, but if it ever needs
    // to be addressed, this may be the place to do it.

    int n = m_pXBar->m_NumOutputPins;
    POSITION pos = m_pXBar->m_OutputPinsList.GetHeadPosition();

    while(n) {
        XBarOutputPin *pOutputPin = m_pXBar->m_OutputPinsList.GetNext(pos);
        
        if (pOutputPin != NULL) {
            if (m_pXBar->IsRouted(pOutputPin, this)) {
                IMediaSample *pSampleOut;

                // Allocate a new mediasample on the output pin and 
                // deliver it a copy of the change notification

                hr = pOutputPin->GetDeliveryBuffer(&pSampleOut, NULL, NULL, 0);
                
                if (!FAILED(hr)) {

                    BYTE *pBufOut;

                    // Get the output sample's buffer pointer
                    hr = pSampleOut->GetPointer(&pBufOut);
                    if (SUCCEEDED (hr)) {

                        hr = pSampleOut->SetActualDataLength(sizeof(KS_TVTUNER_CHANGE_INFO));
                        if (SUCCEEDED(hr)) {

                            DbgLog(( LOG_TRACE, 4, TEXT("Forwarding change info (channel = %d)"), reinterpret_cast<KS_TVTUNER_CHANGE_INFO*>(pBufIn)->dwChannel));

                            /* Copy the ChangeInfo structure into the media sample
                             */
                            memcpy(pBufOut, pBufIn, sizeof(KS_TVTUNER_CHANGE_INFO));
                            hr = pOutputPin->Deliver(pSampleOut);
                        }
                    }

                    pSampleOut->Release();

                    //
                    // Perform the mute operation on a related audio pin
                    //
                    pOutputPin->Mute (
                                ((PKS_TVTUNER_CHANGE_INFO) pBufIn)->dwFlags &
                                KS_TVTUNER_CHANGE_BEGIN_TUNE);
                }
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return NOERROR;

} // Receive


//
// Completed a connection to a pin
//
HRESULT XBarInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
        return hr;
    }

    // Force any output pins to use our type

    int n = m_pXBar->m_NumOutputPins;
    POSITION pos = m_pXBar->m_OutputPinsList.GetHeadPosition();

    while(n) {
        XBarOutputPin *pOutputPin = m_pXBar->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            // Check with downstream pin
            if (m_pXBar->IsRouted (pOutputPin, this)) {
                if (m_mt != pOutputPin->m_mt) {
                    hr = m_pXBar->m_pGraph->Reconnect(pOutputPin);
                    if (FAILED (hr)) {
                        DbgLog((LOG_TRACE,0,TEXT("XBar::CompleteConnect: hr= %ld"), hr));
                    }
                }
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return S_OK;
}

//
// Return a list of IPin * connected to a given pin
//

STDMETHODIMP XBarInputPin::QueryInternalConnections(
        IPin* *apPin,     // array of IPin*
        ULONG *nPin)      // on input, the number of slots
                          // on output  the number of pins
{
    HRESULT     hr;
    int         j, k; 
    ULONG       NumberConnected = 0;
    IPin       *pPin;

    // First count the number of connections

    for (j = 0; j < m_pXBar->m_NumOutputPins; j++) {
        if (m_pXBar->IsRouted (m_pXBar->GetOutputPinNFromList (j), (IPin *) this)) {
            NumberConnected++;
        }
    }

    //
    // if caller only want the count of the number of connected pins
    // the array pointer will be NULL
    //

    if (apPin == NULL) {
        hr = S_OK;
    }
    else if (*nPin >= NumberConnected) {
        for (j = k = 0; j < m_pXBar->m_NumOutputPins; j++) {
            if (m_pXBar->IsRouted (pPin = m_pXBar->GetOutputPinNFromList (j), (IPin *) this)) {
                pPin->AddRef();
                apPin[k] = pPin;
                k++;
            }
        }
        hr = S_OK;        
    }
    else {
        hr = S_FALSE;
    }

    *nPin = NumberConnected;

    return hr;
}

//--------------------------------------------------------------------------;
// Output Pin
//--------------------------------------------------------------------------;

//
// XBarOutputPin constructor
//
XBarOutputPin::XBarOutputPin(TCHAR *pName,
                             XBar *pXBar,
                             HRESULT *phr,
                             LPCWSTR pPinName,
                             long Index) 
	: CBaseOutputPin(pName, pXBar, pXBar, phr, pPinName) 
    , CKsSupport (KSPIN_COMMUNICATION_SOURCE, reinterpret_cast<LPUNKNOWN>(pXBar))
    , m_Index(Index)
	, m_pXBar(pXBar)
    , m_Muted (FALSE)
{
    ASSERT(pXBar);

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;
}


//
// XBarOutputPin destructor
//
XBarOutputPin::~XBarOutputPin()
{
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP XBarOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == __uuidof (IKsPin)) {
        return GetInterface((IKsPin *) this, ppv);
    }
    else if (riid == __uuidof (IKsPropertySet)) {
        return GetInterface((IKsPropertySet *) this, ppv);
    }
    else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface

//
// CheckConnect
//
HRESULT XBarOutputPin::CheckConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    IKsPin *KsPin;
    BOOL fOK = FALSE;
    PIN_INFO ConnectPinInfo;
    PIN_INFO ReceivePinInfo;

    hr = CBaseOutputPin::CheckConnect(pReceivePin);
    if (FAILED(hr)) 
        return hr;

    // Ensure that these pins don't belong to the same filter
    if (SUCCEEDED(QueryPinInfo(&ConnectPinInfo))) {

        if (SUCCEEDED(pReceivePin->QueryPinInfo(&ReceivePinInfo))) {

            if (ConnectPinInfo.pFilter == ReceivePinInfo.pFilter) {
                hr = VFW_E_CIRCULAR_GRAPH;
            }
            QueryPinInfoReleaseFilter(ReceivePinInfo);
        }
        QueryPinInfoReleaseFilter(ConnectPinInfo);
    }
    if (FAILED(hr))
        return hr;

    // If the receiving pin supports IKsPin, then check for a match on the
    // Medium GUID

	if (SUCCEEDED (hr = pReceivePin->QueryInterface (
            __uuidof (IKsPin), (void **) &KsPin))) {

        PKSMULTIPLE_ITEM MediumList = NULL;
        PKSPIN_MEDIUM Medium;

        if (SUCCEEDED (hr = KsPin->KsQueryMediums(&MediumList))) {
            if ((MediumList->Count == 1) && 
                (MediumList->Size == (sizeof(KSMULTIPLE_ITEM) + sizeof(KSPIN_MEDIUM)))) {

				Medium = reinterpret_cast<PKSPIN_MEDIUM>(MediumList + 1);
                if (IsEqualGUID (Medium->Set, m_Medium.Set) && 
                        Medium->Id == m_Medium.Id &&
                        Medium->Flags == m_Medium.Flags) {
					fOK = TRUE;
				}
			}

            CoTaskMemFree(MediumList);
        }
        
        KsPin->Release();
    }
    else {
        if (IsEqualGUID (GUID_NULL, m_Medium.Set)) { 
            fOK = TRUE;
        }
    }
    
    return fOK ? NOERROR : E_INVALIDARG;

} // CheckConnect

//
// CheckMediaType
//
HRESULT XBarOutputPin::CheckMediaType(const CMediaType *pmt)
{
    // Display the type of the media for debugging purposes
    DisplayMediaType(TEXT("Output Pin Checking"), pmt);

    if (m_lType >= KS_PhysConn_Audio_Tuner) {
        if (*(pmt->Type()) != MEDIATYPE_AnalogAudio)	{
        	return E_INVALIDARG;
		}
    }
    else {
        if (*(pmt->Type()) != MEDIATYPE_AnalogVideo) {
        	return E_INVALIDARG;
    	}
	}

    return S_OK;  // This format is acceptable.

#if 0

    // Make sure that our input pin peer is happy with this
    hr = m_pXBar->m_Input.m_Connected->QueryAccept(pmt);
    if (hr != NOERROR) {
        m_bInsideCheckMediaType = FALSE;
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    // Check the format with the other outpin pins

    int n = m_pXBar->m_NumOutputPins;
    POSITION pos = m_pXBar->m_OutputPinsList.GetHeadPosition();

    while(n) {
        XBarOutputPin *pOutputPin = m_pXBar->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL && pOutputPin != this) {
            if (pOutputPin->m_Connected != NULL) {
                // The pin is connected, check its peer
                hr = pOutputPin->m_Connected->QueryAccept(pmt);
                if (hr != NOERROR) {
                    m_bInsideCheckMediaType = FALSE;
                    return VFW_E_TYPE_NOT_ACCEPTED;
                }
            }
        }
        n--;
    }
    m_bInsideCheckMediaType = FALSE;

    return NOERROR;

#endif

} // CheckMediaType


//
// EnumMediaTypes
//
STDMETHODIMP XBarOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(ppEnum);

    return CBaseOutputPin::EnumMediaTypes (ppEnum);

} // EnumMediaTypes



//
// GetMediaType
//
HRESULT XBarOutputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    CAutoLock lock_it(m_pLock);

    if (iPosition < 0) 
        return E_INVALIDARG;
    if (iPosition >= 1)
	    return VFW_S_NO_MORE_ITEMS;

    if (m_lType >= KS_PhysConn_Audio_Tuner) {
        pMediaType->SetFormatType(&GUID_NULL);
        pMediaType->SetType(&MEDIATYPE_AnalogAudio);
        pMediaType->SetTemporalCompression(FALSE);
        pMediaType->SetSubtype(&GUID_NULL);
    }
    else {

        ANALOGVIDEOINFO avi;

        pMediaType->SetFormatType(&FORMAT_AnalogVideo);
        pMediaType->SetType(&MEDIATYPE_AnalogVideo);
        pMediaType->SetTemporalCompression(FALSE);
        pMediaType->SetSubtype(&KSDATAFORMAT_SUBTYPE_NONE);

        SetRect (&avi.rcSource, 0, 0, 
                720, 480);
        SetRect (&avi.rcTarget, 0, 0,
                720, 480);
        avi.dwActiveWidth  = 720;
        avi.dwActiveHeight =  480;
        avi.AvgTimePerFrame = 0;

        pMediaType->SetFormat ((BYTE *) &avi, sizeof (avi));
    }

    return NOERROR;


} // EnumMediaTypes


//
// SetMediaType
//
HRESULT XBarOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    // Display the format of the media for debugging purposes
    DisplayMediaType(TEXT("Output pin type agreed"), pmt);

    // Make sure that the base class likes it
    HRESULT hr = NOERROR;
    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    return NOERROR;

} // SetMediaType


//
// CompleteConnect
//
HRESULT XBarOutputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = NOERROR;

    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
        return hr;

    // If the type is not the same as that stored for the input
    // pin then force the input pins peer to be reconnected

    return NOERROR;

} // CompleteConnect


HRESULT XBarOutputPin::DecideBufferSize(IMemAllocator *pAlloc,
                                       ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;


    // "Buffers" are used for format change notification only,
    // that is, if a tuner can produce both NTSC and PAL, a
    // buffer will only be sent to notify the receiving pin
    // of the format change

    pProperties->cbBuffer = sizeof (KS_TVTUNER_CHANGE_INFO);
    pProperties->cBuffers = 1;

    // Ask the allocator to reserve us the memory

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }
    return NOERROR;
}

//
// Return a list of IPin * connected to a given pin
//

STDMETHODIMP XBarOutputPin::QueryInternalConnections(
        IPin* *apPin,     // array of IPin*
        ULONG *nPin)      // on input, the number of slots
                          // on output  the number of pins
{
    HRESULT     hr;
    int         j, k; 
    ULONG       NumberConnected = 0;
    IPin       *pPin;

    // First count the number of connections

    for (j = 0; j < m_pXBar->m_NumInputPins; j++) {
        if (m_pXBar->IsRouted (m_pXBar->GetInputPinNFromList (j), (IPin *) this)) {
            NumberConnected++;
        }
    }

    //
    // if caller only want the count of the number of connected pins
    // the array pointer will be NULL
    //

    if (apPin == NULL) {
        hr = S_OK;
    }
    else if (*nPin >= NumberConnected) {
        for (j = k = 0; j < m_pXBar->m_NumInputPins; j++) {
            if (m_pXBar->IsRouted (pPin = m_pXBar->GetInputPinNFromList (j), (IPin *) this)) {
                pPin->AddRef();
                apPin[k] = pPin;
                k++;
            }
        }
        hr = S_OK;        
    }
    else {
        hr = S_FALSE;
    }

    *nPin = NumberConnected;

    return hr;
}

//
// BreakConnect
//
HRESULT XBarOutputPin::BreakConnect()
{
    Mute (TRUE);

    return CBaseOutputPin::BreakConnect();
} // BreakConnect

//
// Given a pin, mute or unmute
//

STDMETHODIMP 
XBarOutputPin::Mute (
    BOOL Mute
)
{
    HRESULT hr = S_OK;

    // In case we get called twice (ie. during filter destruction)

    if (m_Muted == Mute) {
        return hr;
    }

    m_Muted = Mute;

    if (IsVideoPin (this)) {
        XBarOutputPin * RelatedPin = m_pXBar->GetOutputPinNFromList (m_IndexRelatedPin);

        if (RelatedPin) {
            if (IsAudioPin (RelatedPin)) {
                RelatedPin->Mute (Mute);
            }
        }
    }
    else if (IsAudioPin (this)) {
        if (Mute) {
            m_pXBar->get_IsRoutedTo (m_Index, &m_PreMuteRouteIndex);
            m_pXBar->RouteInternal (m_Index, -1, FALSE);
        }
        else {
            m_pXBar->RouteInternal (m_Index, m_PreMuteRouteIndex, FALSE);
        }
    }
    else {
        ASSERT (FALSE);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimsr\aviindex.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "aviindex.h"

static const ULONG F_PALETTE_CHANGE_INTERNAL = 0x40000000;
static const ULONG F_SIZE_MASK_INTERNAL =      0x3fffffff;

// constructor for the new format index (indx)
CImplStdAviIndex::CImplStdAviIndex(
  unsigned stream,
  AVIMETAINDEX *pIndx,
  AVISTREAMHEADER *pStrh,
  RIFFCHUNK *pStrf,
  IAsyncReader *pAsyncReader,
  HRESULT *phr)
{
  _CImplStdAviIndex();

  m_pAsyncReader = pAsyncReader;
  pAsyncReader->AddRef();
  
  if(!FAILED(*phr)) {
     *phr = Initialize(
       stream,
       pIndx,
       pStrh,
       pStrf);
  }
}

CImplStdAviIndex::CImplStdAviIndex()
{
  _CImplStdAviIndex();
}

void CImplStdAviIndex::_CImplStdAviIndex()
{
  m_pAsyncReader = 0;
  m_pStdIndex = 0;
  m_cbStdIndexAllocated = 0;
  m_fWaitForIndex = FALSE;
}

CImplStdAviIndex::~CImplStdAviIndex()
{
  if(m_cbStdIndexAllocated != 0)
    delete[] m_pStdIndex;

  if(m_pAsyncReader)
    m_pAsyncReader->Release();
}

HRESULT CImplStdAviIndex::Initialize(
  unsigned stream,
  AVIMETAINDEX *pIndx,
  AVISTREAMHEADER *pStrh,
  RIFFCHUNK *pStrf)
{
  m_stream = stream;
  m_bValid = FALSE;
  m_pStrh = pStrh;
  m_pStrf = pStrf;

  HRESULT hr = S_OK;

  // the following are guaranteed by ParseHeader in the pin
  ASSERT(m_pStrh->dwRate != 0);
  ASSERT(m_pStrh->fccType != streamtypeAUDIO ||
         ((WAVEFORMAT *)GetStrf())->nBlockAlign != 0);

  ASSERT(pIndx != 0);

  switch(pIndx->bIndexType)
  {
    case AVI_INDEX_OF_CHUNKS:
      m_pSuperIndex = 0;
      m_pStdIndex = (AVISTDINDEX *)pIndx;
      hr = ValidateStdIndex(m_pStdIndex);
      break;

    case AVI_INDEX_OF_INDEXES:
      m_pSuperIndex = (AVISUPERINDEX *)pIndx;
      hr = ValidateSuperIndex(m_pSuperIndex);
      if(FAILED(hr))
        break;

      hr = AllocateStdIndex();
      if(FAILED(hr))
        break;

      hr = S_OK;
      break;

    default:
      hr = VFW_E_INVALID_FILE_FORMAT;
  }

  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplStdAviIndex::Initialize: failed.")));
  }

  return hr;
}

// ------------------------------------------------------------------------
// IAviIndex

// SetPointer

HRESULT CImplStdAviIndex::SetPointer(LONGLONG llSrc)
{
  m_bValid = FALSE;

  if(m_pStrh->fccType == streamtypeVIDEO)
    llSrc += m_pStrh->dwInitialFrames;

  HRESULT hr;

  // dwStart not accounted for in index. so we have to subtract
  // dwStart from it
  DWORDLONG tick = llSrc;

  if(tick > m_pStrh->dwStart)
  {
      tick -= m_pStrh->dwStart;
  }
  else
  {
      tick = 0;
  }

  // what we use to track index position
  m_lliTick = tick;

  DbgLog((LOG_TRACE, 0x3f,
          TEXT("avi SetPointer: m_lliTick = %d, tick = %d"),
          (DWORD)m_lliTick, (DWORD)tick));


  // linear search through superindex to find subindex in range. !!!
  // we could start at the end if that's closer. or build an absolute
  // table and do a binary search. !!!
  if(m_pSuperIndex != 0)
  {
    for(DWORD dwi = 0;; dwi++)
    {
      if(dwi == m_pSuperIndex->nEntriesInUse)
      {
        DbgLog(( LOG_TRACE, 2,
                 TEXT("CImplStdAviIndex::SetPointer: past end.")));
        return AdvancePointerEnd();
      }

      if(m_pSuperIndex->aIndex[dwi].dwDuration > tick)
      {
          // tick contains the number of ticks in this entry we have
          // to skip. 
          
          break;
      }

      tick -= m_pSuperIndex->aIndex[dwi].dwDuration;
    }

    hr = LoadStdIndex(dwi, 0);
    if(FAILED(hr))
      return hr;

    ASSERT(m_iSuperIndex == dwi);
  }

  //
  // set the current std index entry
  //

  // since the number of ticks in an entry is unknown, must start from
  // beginning and count up. better to make an absolute index, do
  // binary search.

  // linear search through subindex chunk to find index entry
  // containing tick. !!! we could start searching at the end if
  // that's closer.
  for(m_iStdIndex = 0;; m_iStdIndex++)
  {
    ASSERT(m_iStdIndex <= m_pStdIndex->nEntriesInUse);
    if(m_iStdIndex == m_pStdIndex->nEntriesInUse)
    {
      if(m_pSuperIndex)
      {
        DbgLog(( LOG_ERROR, 2,
                 TEXT("SetPointer: std index differs from super.")));
        return VFW_E_INVALID_FILE_FORMAT;
      }
      else
      {
        DbgLog(( LOG_TRACE, 2, TEXT("SetPointer: off the end.")));
        return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
      }
    }

    ULONG cTicksInEntry = GetTicksInEntry(m_iStdIndex);

    // landed in the middle of an index entry
    if(cTicksInEntry > tick)
    {
      m_lliTick -= tick;

      DbgLog((LOG_TRACE, 0x3f,
              TEXT("avi index: found iStdIndex =  %d, tick = %d, m_lliTick = %d"),
              (DWORD)m_iStdIndex, (DWORD)tick, (DWORD)m_lliTick));
      break;
    }

    tick -= cTicksInEntry;
  }

  m_bValid = TRUE;

  DbgLog((LOG_TRACE, 5, TEXT("SetPointer: tick = %d, iIdx %d-%d"),
          (DWORD)m_lliTick, (DWORD)m_iSuperIndex, (DWORD)m_iStdIndex));

  
  return S_OK;
}

HRESULT CImplStdAviIndex::MapByteToSampleApprox(
  LONGLONG *piSample,
  const LONGLONG &fileOffset,
  const LONGLONG &fileLength)
{
  ULONG cTicks = 0;
  if(m_pSuperIndex)
  {
    ASSERT(m_pSuperIndex->nEntriesInUse > 0); // from Validate call
    for(ULONG iEntry = 0;;)
    {
      // byte offset of last thing indexed by this sub index. use the
      // file length if we're at the end
      LONGLONG byteOffsetEnd = fileLength;
      if(iEntry + 1 < m_pSuperIndex->nEntriesInUse)
      {
        byteOffsetEnd = m_pSuperIndex->aIndex[iEntry + 1].qwOffset;
      }
          
      if(byteOffsetEnd > fileOffset)
      {
        // cTicks points to the beginning of the sub index. do a
        // linear interpolation with the byte offset

        ULONG cbIndexed = (ULONG)(byteOffsetEnd -
                                  m_pSuperIndex->aIndex[iEntry].qwOffset);
        ULONG cbCovered = (ULONG)(fileOffset -
                                  m_pSuperIndex->aIndex[iEntry].qwOffset);

        ASSERT(cbIndexed >= cbCovered);

        if(cbIndexed != 0)
        {
          cTicks += (ULONG)((LONGLONG)m_pSuperIndex->aIndex[iEntry].dwDuration  *
                            cbCovered / cbIndexed);
        }

        break;
      }


      cTicks += m_pSuperIndex->aIndex[iEntry].dwDuration;
      iEntry++;
      
      if(iEntry >= m_pSuperIndex->nEntriesInUse)
        break;
    }
  }
  else
  {
    ASSERT(m_pStdIndex->nEntriesInUse > 0); // from Validate call
    LONGLONG fileOffsetAdjusted = fileOffset; // shadow const 
    fileOffsetAdjusted -= m_pStdIndex->qwBaseOffset;
    for(ULONG iEntry = 0; ; )
    {
      if(iEntry + 1 < m_pStdIndex->nEntriesInUse)
        if((LONGLONG)m_pStdIndex->aIndex[iEntry + 1].dwOffset > fileOffsetAdjusted)
          break;

      cTicks += GetTicksInEntry(iEntry);
      iEntry++;

      if(iEntry >= m_pStdIndex->nEntriesInUse)
        break;
    }
  }

  *piSample = cTicks;
  return S_OK;
}

HRESULT CImplStdAviIndex::Reset()
{
  if(m_fWaitForIndex)
  {
    DbgLog((LOG_TRACE, 5, TEXT("CImplStdAviIndex: index cancelled") ));
  }
  m_fWaitForIndex = FALSE;
  return S_OK;
}

HRESULT CImplStdAviIndex::AdvancePointerForward(IxReadReq *pIrr)
{
  if(!m_bValid)
  {
    ASSERT(!"index pointer not in valid state");
    return E_FAIL;
  }
  ASSERT(!m_fWaitForIndex);

  ASSERT(m_iStdIndex < m_pStdIndex->nEntriesInUse);
  ASSERT(m_pStdIndex->nEntriesInUse > 0);
  ASSERT(!m_pSuperIndex || m_pSuperIndex->nEntriesInUse > 0);

  m_lliTick += GetTicksInEntry(m_iStdIndex);
  if(++m_iStdIndex == m_pStdIndex->nEntriesInUse)
  {
    if(m_pSuperIndex == 0)
    {
      m_bValid = FALSE;
      DbgLog(( LOG_TRACE, 2,
               TEXT("CImplStdAviIndex::AdvancePointer: EOF")));
      return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
    }

    HRESULT hr = LoadStdIndex(m_iSuperIndex + 1, pIrr);
    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CImplStdAviIndex::AdvancePointer: LoadStdIndex")));
      return hr;
    }

    m_iStdIndex = 0;
  }
  if(m_fWaitForIndex)
  {
    ASSERT(!m_bValid);
    return S_FALSE;
  }
  else
  {
    m_bValid = TRUE;
    return S_OK;
  }
}

HRESULT CImplStdAviIndex::AdvancePointerBackward()
{
  if(!m_bValid)
  {
    ASSERT(!"index pointer not in valid state");
    return E_FAIL;
  }

  ASSERT(m_iStdIndex < m_pStdIndex->nEntriesInUse);
  ASSERT(m_pStdIndex->nEntriesInUse > 0);
  ASSERT(!m_pSuperIndex || m_pSuperIndex->nEntriesInUse > 0);

  if(m_iStdIndex-- == 0)
  {
    if(m_pSuperIndex == 0)
    {
      m_bValid = FALSE;
      return HRESULT_FROM_WIN32(ERROR_NEGATIVE_SEEK);
    }

    HRESULT hr = LoadStdIndex(m_iSuperIndex - 1, 0);
    if(FAILED(hr))
      return hr;

    m_iStdIndex = m_pStdIndex->nEntriesInUse - 1;
  }
  m_lliTick -= GetTicksInEntry(m_iStdIndex);
  m_bValid = TRUE;

  return S_OK;
}

HRESULT CImplStdAviIndex::AdvancePointerBackwardKeyFrame()
{
  if(!m_bValid)
  {
    ASSERT(!"index pointer not in valid state");
    return E_FAIL;
  }

  // otherwise look for a key frame. return an error if the first
  // thing isn't a key frame.
  while(!GetKey(m_pStdIndex->aIndex[m_iStdIndex]))
  {
    // drop frame at the beginning is ok
    if(m_lliTick == 0 && GetSize(m_pStdIndex->aIndex[m_iStdIndex]) == 0) {
      return S_OK;
    }
    
    HRESULT hr = AdvancePointerBackward();
    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 1, TEXT("avi: couldn't find a key frame")));
      return hr;
    }
  }

  return S_OK;
}

HRESULT CImplStdAviIndex::AdvancePointerEnd()
{
  if(m_pSuperIndex)
  {
    HRESULT hr = LoadStdIndex(m_pSuperIndex->nEntriesInUse - 1, 0);
    if(FAILED(hr))
      return hr;
  }
  m_iStdIndex = m_pStdIndex->nEntriesInUse - 1;
  m_lliTick = m_pStrh->dwLength - GetTicksInEntry(m_iStdIndex);
  m_bValid = TRUE;

  return S_OK;
}

HRESULT CImplStdAviIndex::AdvancePointerStart()
{
  if(m_pSuperIndex)
  {
    HRESULT hr = LoadStdIndex(0, 0);
    if(FAILED(hr))
      return hr;
  }
  m_iStdIndex = 0;
  m_lliTick = 0;
  m_bValid = TRUE;

  return S_OK;
}

HRESULT CImplStdAviIndex::AdvancePointerBackwardPaletteChange()
{
  return S_FALSE;
}

HRESULT CImplStdAviIndex::AdvancePointerForwardPaletteChange()
{
  return S_FALSE;
}

HRESULT CImplStdAviIndex::GetEntry(IndexEntry *pEntry)
{
  if(!m_bValid)
  {
    DbgBreak("index pointer not in valid state");
    
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplStdAviIndex::GetEntry: !m_bValid.")));
    return E_FAIL;
  }

  AVISTDINDEX_ENTRY &rEntry = m_pStdIndex->aIndex[m_iStdIndex];

#ifdef DEBUG
    if(m_pStrh->fccType == streamtypeAUDIO)
    {
        if(GetSize(rEntry) % ((WAVEFORMAT *)GetStrf())->nBlockAlign)
        {
            if(m_lliTick + GetTicksInEntry(m_iStdIndex) != m_pStrh->dwLength )
            {
                DbgBreak("invalid audio but not signaling an error.");
            }
        }
    }
#endif
  


  pEntry->qwPos = m_pStdIndex->qwBaseOffset + rEntry.dwOffset;
  pEntry->dwSize = GetSize(rEntry);
  pEntry->bKey = GetKey(rEntry);
  pEntry->bPalChange = GetPalChange(rEntry);
  pEntry->llStart = m_lliTick + m_pStrh->dwStart;
  if(m_pStrh->fccType == streamtypeVIDEO)
    pEntry->llStart -= m_pStrh->dwInitialFrames;
  
  pEntry->llEnd = pEntry->llStart + GetTicksInEntry(m_iStdIndex);

  DbgLog((LOG_TRACE, 0x40, TEXT("GetEntry: %d-%d, tick = %d, iIdx %d-%d"),
          (DWORD)pEntry->llStart, (DWORD)pEntry->llEnd,
          (DWORD)m_lliTick, (DWORD)m_iSuperIndex, (DWORD)m_iStdIndex));

  return S_OK;
}

HRESULT CImplStdAviIndex::GetInfo(StreamInfo *pStreamInfo)
{
  HRESULT hr;

  BOOL bTemporalCompression = FALSE;

  // media type entries (bTemporalCompression) for audio are ignored
  if(m_pStrh->fccType == streamtypeVIDEO)
  {
    // check first ten frames to see if one is not a key frame
    hr = AdvancePointerStart();
    if(FAILED(hr))
      return hr;

    IndexEntry ie;
    for(unsigned i = 0; i < 10; i++)
    {
      hr = GetEntry(&ie);
      if(FAILED(hr))
        return hr;

      if(!ie.bKey)
      {
        bTemporalCompression = TRUE;
        break;
      }

      hr = AdvancePointerForward(0);
      if(hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
      {
        break;
      }
      else if(FAILED(hr))
      {
        return hr;
      }
    }
  }

  pStreamInfo->bTemporalCompression = bTemporalCompression;
  pStreamInfo->dwStart = m_pStrh->dwStart;
  pStreamInfo->dwLength = m_pStrh->dwLength;
  return S_OK;
}

// return the largest index size, not the sample size
HRESULT CImplStdAviIndex::GetLargestSampleSize(ULONG *pcbSample)
{
  *pcbSample = 0;
  if(m_pSuperIndex == 0)
    return S_OK;
  
  ULONG cb = 0;
  for(ULONG i = 0; i < m_pSuperIndex->nEntriesInUse; i++)
    cb = max(cb, m_pSuperIndex->aIndex[i].dwSize);

  *pcbSample = cb;
  return S_OK;
}

HRESULT CImplStdAviIndex::IncomingIndex(BYTE *pb, ULONG cb)
{
  ASSERT(m_fWaitForIndex && !m_bValid);
  ASSERT(cb <= m_cbStdIndexAllocated);

  CopyMemory((BYTE *)m_pStdIndex, pb, cb);
  HRESULT hr = ValidateStdIndex(m_pStdIndex);
  if(hr != S_OK)
    return VFW_E_INVALID_FILE_FORMAT;

  m_bValid = TRUE;
  m_fWaitForIndex = FALSE;
  return S_OK;
}

// ------------------------------------------------------------------------
// catch things that would make us access memory out of bounds

HRESULT CImplStdAviIndex::ValidateStdIndex(AVISTDINDEX *pStdIndex)
{
  if(pStdIndex->wLongsPerEntry != sizeof(AVISTDINDEX_ENTRY) / sizeof(long))
    return VFW_E_INVALID_FILE_FORMAT;

  DWORD_PTR cb = ((BYTE *)(pStdIndex->aIndex + pStdIndex->nEntriesInUse) -
              (BYTE *)pStdIndex);
  cb -= sizeof(RIFFCHUNK);
  if(cb > pStdIndex->cb)
    return VFW_E_INVALID_FILE_FORMAT;

  if(pStdIndex->nEntriesInUse == 0)
    return VFW_E_INVALID_FILE_FORMAT;

  return S_OK;
}

HRESULT CImplStdAviIndex::ValidateSuperIndex(AVISUPERINDEX *pSuperIndex)
{
  if(pSuperIndex->wLongsPerEntry !=
     sizeof(AVISUPERINDEX::_avisuperindex_entry) / sizeof(long))
    return VFW_E_INVALID_FILE_FORMAT;

  DWORD_PTR cb = ((BYTE *)(pSuperIndex->aIndex + pSuperIndex->nEntriesInUse) -
              (BYTE *)pSuperIndex);
  cb -= sizeof(RIFFCHUNK);
  if(cb > pSuperIndex->cb)
    return VFW_E_INVALID_FILE_FORMAT;

  if(pSuperIndex->nEntriesInUse == 0)
    return VFW_E_INVALID_FILE_FORMAT;

  return S_OK;
}

// ------------------------------------------------------------------------
// AllocateStdIndex: find the largest subindex chunk size, and
// allocate that amount.

HRESULT CImplStdAviIndex::AllocateStdIndex()
{
  DWORD cbIndex = m_pSuperIndex->aIndex[0].dwSize;
  for(DWORD dwii = 0; dwii < m_pSuperIndex->nEntriesInUse; ++dwii)
    cbIndex = max(cbIndex, m_pSuperIndex->aIndex[dwii].dwSize);

  m_pStdIndex = (AVISTDINDEX*)new BYTE[cbIndex];
  if(m_pStdIndex == 0)
    return E_OUTOFMEMORY;
  m_cbStdIndexAllocated = cbIndex;

  return S_OK;
}

HRESULT CImplStdAviIndex::LoadStdIndex(DWORD iSuperIndex, IxReadReq *pIrr)
{
  if(m_pSuperIndex == 0)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplStdAviIndex::LoadStdIndex: no super index.")));
    return E_FAIL;
  }

  if(m_bValid && iSuperIndex == m_iSuperIndex)
    return S_OK;

  m_bValid = FALSE;

  if(iSuperIndex >= m_pSuperIndex->nEntriesInUse)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplStdAviIndex::LoadStdIndex: out of range.")));
    return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
  }

  AVISUPERINDEX::_avisuperindex_entry &rEntry =
    m_pSuperIndex->aIndex[iSuperIndex];
  ASSERT(rEntry.dwSize <= m_cbStdIndexAllocated);
  HRESULT hr;

  if(pIrr == 0)
  {
    hr = m_pAsyncReader->SyncRead(
      rEntry.qwOffset,
      rEntry.dwSize,
      (BYTE*)m_pStdIndex);
  

    if(SUCCEEDED(hr))
    {
      m_iSuperIndex = iSuperIndex;
      hr = ValidateStdIndex(m_pStdIndex);
    }
  }
  else
  {
    m_iSuperIndex = iSuperIndex;
    pIrr->fileOffset = rEntry.qwOffset;
    pIrr->cbData = rEntry.dwSize;
    m_fWaitForIndex = TRUE;
    hr = S_FALSE;
  }

  return hr;
}

// number of ticks in the current index entry
//
ULONG CImplStdAviIndex::GetTicksInEntry(ULONG iEntry)
{
  ULONG cTicks;
  
  if(m_pStrh->fccType == streamtypeAUDIO)
  {
    DWORD dwSize = GetSize(m_pStdIndex->aIndex[iEntry]);
    DWORD nBlockAlign = ((WAVEFORMAT *)GetStrf())->nBlockAlign;
    cTicks =  (dwSize + nBlockAlign - 1) / nBlockAlign;
  }
  else if(m_pStrh->fccType == streamtypeVIDEO)
  {
    cTicks = GetPalChange(m_pStdIndex->aIndex[iEntry]) ? 0 : 1;
  }
  else
  {
    cTicks = 1;
  }

  return cTicks;
}

inline
BOOL CImplStdAviIndex::GetKey(AVISTDINDEX_ENTRY &rEntry)
{
  return !(rEntry.dwSize & AVISTDINDEX_DELTAFRAME) &&
    !GetPalChange(rEntry);
}

inline
BOOL CImplStdAviIndex::GetPalChange(AVISTDINDEX_ENTRY &rEntry)
{
  return rEntry.dwSize & F_PALETTE_CHANGE_INTERNAL;
}

inline
DWORD CImplStdAviIndex::GetSize(AVISTDINDEX_ENTRY &rEntry)
{
  return rEntry.dwSize & F_SIZE_MASK_INTERNAL;
}

inline
BYTE * CImplStdAviIndex::GetStrf()
{
  ASSERT(sizeof(*m_pStrf) == sizeof(RIFFCHUNK));
  return (BYTE *)(m_pStrf + 1);
}

// BOOL CImplStdAviIndex::IsSampleEntry(
//   DWORD dwIdMask,
//   DWORD fccStream,
//   DWORD idxChunkId)
// {
//   if((idxChunkId & 0xffff) != dwIdMask)
//     return FALSE;

//   // accept only anything but pc (palette change) for video, "wb" for
//   // audio
//   WORD w2cc = WORD(idxChunkId >> 16);
//   if((fccStream == streamtypeAUDIO && w2cc == 'bw') ||
//      (fccStream == streamtypeVIDEO && w2cc != 'cp') ||
//      (fccStream == streamtypeTEXT))
//   {
//     return TRUE;
//   }
//   return FALSE;
// }

BOOL CImplStdAviIndex::IsPaletteChange(
  DWORD dwIdMask,
  DWORD idxChunkId)
{
  if((idxChunkId & 0xffff) != dwIdMask)
    return FALSE;

  WORD w2cc = WORD(idxChunkId >> 16);
  if(w2cc == 'cp')
    return TRUE;

  return FALSE;
}

inline BOOL CImplStdAviIndex::IsStreamEntry(
  DWORD dwIdMask,
  DWORD idxChunkId)
{
  ASSERT((idxChunkId & 0xffff) == ((WORD *)&idxChunkId)[0]);

  if(((WORD *)&idxChunkId)[0] != dwIdMask)
    return FALSE;

  // !!! what about the no time flag.

  return TRUE;
}

// constructor for the old format index (idx1). creates a new format
// index (indx) from the idx1 chunk. two passes per stream over the
// entire index: extremely inefficient
CImplOldAviIndex::CImplOldAviIndex(
  unsigned stream,
  AVIOLDINDEX *pIdx1,
  DWORDLONG moviOffset,
  AVISTREAMHEADER *pStrh,
  RIFFCHUNK *pStrf,
  HRESULT *phr) :
    CImplStdAviIndex()
{
  m_cbLargestSampleSizeComputed = 0;

  // uncompressed video?
  BOOL fUncompressedVideo = FALSE;
  if(pStrh->fccType == streamtypeVIDEO)
  {
    BITMAPINFOHEADER *pbmi = (BITMAPINFOHEADER *)(pStrf + 1);
    if(pbmi->biCompression == BI_RGB || pbmi->biCompression == BI_BITFIELDS)
    {
      DbgLog((LOG_TRACE, 2, TEXT("aviindex: uncompressed video fixups.")));
      fUncompressedVideo = TRUE;
    }
  }

  if(!FAILED(*phr)) {

     // create the stream id used in the index (eg 01db)
     BYTE b0, b1;
     b0 = stream & 0x0F;
     b0 += (b0 <= 9) ? '0' : 'A' - 10;
     b1 = (stream & 0xF0) >> 4;
     b1 += (b1 <= 9) ? '0' : 'A' - 10;

     // little endian encoding of the stream id in the avioldindex entry
     DWORD dwIdMask = b1 + (b0 << 8);

     // count entries for this stream
     ULONG iIdx1Entry;
     ULONG cEntriesThisStream = 0;
     ULONG cEntriesIdx1 = pIdx1->cb / sizeof(AVIOLDINDEX::_avioldindex_entry);
     for(iIdx1Entry = 0; iIdx1Entry < cEntriesIdx1; iIdx1Entry++)
     {
       if(IsStreamEntry(dwIdMask, pIdx1->aIndex[iIdx1Entry].dwChunkId))
       {
         cEntriesThisStream++;
         if(pIdx1->aIndex[iIdx1Entry].dwSize > F_SIZE_MASK_INTERNAL)
         {
           *phr = VFW_E_INVALID_FILE_FORMAT;
           return;
         }
       }
     }

     // allocate std index
     m_cbStdIndexAllocated = cEntriesThisStream * sizeof(AVISTDINDEX_ENTRY) +
       sizeof(AVIMETAINDEX);
     m_pStdIndex = (AVISTDINDEX *)new BYTE[m_cbStdIndexAllocated];
     if(m_pStdIndex == 0)
     {
       *phr = E_OUTOFMEMORY;
       m_cbStdIndexAllocated = 0;

     } else {

        // copy entries over
        ULONG iIndxEntry = 0;
        for(iIdx1Entry = 0; iIdx1Entry < cEntriesIdx1; iIdx1Entry++)
        {
          AVIOLDINDEX::_avioldindex_entry &rOldEntry = pIdx1->aIndex[iIdx1Entry];
          AVISTDINDEX_ENTRY &rNewEntry = m_pStdIndex->aIndex[iIndxEntry];

          if(IsStreamEntry(dwIdMask, rOldEntry.dwChunkId))
          {
            rNewEntry.dwOffset = rOldEntry.dwOffset + sizeof(RIFFCHUNK);
            rNewEntry.dwSize = rOldEntry.dwSize;

            if(pStrh->fccType == streamtypeVIDEO &&
               IsPaletteChange(dwIdMask, rOldEntry.dwChunkId))
            {
              rNewEntry.dwSize |= F_PALETTE_CHANGE_INTERNAL;
            }
            else if(!((rOldEntry.dwFlags & AVIIF_KEYFRAME) ||
                      (pStrh->fccType != streamtypeAUDIO  && iIndxEntry == 0) ||
                      fUncompressedVideo))
            {
              // mark the delta frames. fixups for audio and text:
              // every frame is a key frame. fixup for video: first
              // frame is assumed to be keyframe (see
              // \\pigeon\avi\small.avi). fixup for uncompressed
              // video: every frame is a key frame.
              rNewEntry.dwSize |= (AVISTDINDEX_DELTAFRAME);
            }
            else
            {
              ASSERT(!(rNewEntry.dwSize & AVISTDINDEX_DELTAFRAME));
            }
            
            iIndxEntry++;
          }
        }

        ASSERT(iIndxEntry == cEntriesThisStream);

        m_pStdIndex->fcc            = FCC('indx');
        m_pStdIndex->cb             = m_cbStdIndexAllocated - sizeof(RIFFCHUNK);
        m_pStdIndex->wLongsPerEntry = sizeof(AVISTDINDEX_ENTRY) / sizeof(LONG);
        m_pStdIndex->bIndexSubType  = 0;
        m_pStdIndex->bIndexType     = AVI_INDEX_OF_CHUNKS;
        m_pStdIndex->nEntriesInUse  = cEntriesThisStream;
        m_pStdIndex->dwChunkId      = pIdx1->aIndex[0].dwChunkId;
        m_pStdIndex->dwReserved_3   = 0;

        // absolute index entries
        if(moviOffset + sizeof(RIFFLIST) == pIdx1->aIndex[0].dwOffset)
          m_pStdIndex->qwBaseOffset = 0;
        else
          m_pStdIndex->qwBaseOffset   = moviOffset + sizeof(RIFFCHUNK);

        *phr = Initialize(
          stream,
          (AVIMETAINDEX *)m_pStdIndex,
          pStrh,
          pStrf);
     }
  }
}

// linear search through all the other index entries for the previous
// palette entry. really should build a separate table of palette
// changes. also should check whether there are any palette changes in
// the file and bail immediately

HRESULT CImplOldAviIndex::AdvancePointerBackwardPaletteChange()
{
  if(!m_bValid)
  {
    ASSERT(!"index pointer not in valid state");
    return E_FAIL;
  }

  while(!GetPalChange(m_pStdIndex->aIndex[m_iStdIndex]))
  {
    HRESULT hr = AdvancePointerBackward();
    if(FAILED(hr))
      return hr;
  }

  return S_OK;
}

HRESULT CImplOldAviIndex::AdvancePointerForwardPaletteChange()
{
  return E_NOTIMPL;
}


HRESULT CImplOldAviIndex::GetLargestSampleSize(ULONG *pcbSample)
{

  if(m_cbLargestSampleSizeComputed != 0)
  {
    *pcbSample = m_cbLargestSampleSizeComputed;
    return S_OK;
  }

  *pcbSample = 0;

  // this method is a bit of a hack; we only need it for compatibility
  // files which don't know dwSuggestedBufferSize. we can't work with
  // the new format index since m_rpImplBuffer is not necessarily
  // created and set when this is called. !!! we should remember this
  // value and not recompute it.
  if(m_pAsyncReader == 0 && m_pSuperIndex != 0)
    return E_UNEXPECTED;

  // loop over all entries, remember the largest
  HRESULT hr = AdvancePointerStart();
  if(FAILED(hr))
    return hr;

  DWORD cbSize;
  ULONG cbLargest = 0;

  for(int i=0; ;++i)
  {
    cbSize = GetEntrySize();

    if(cbSize > cbLargest)
      cbLargest = cbSize;

    // for very large files this could take a significant time...
    hr = AdvancePointerForward(0);
    if(hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
    {
      break;
    }
    if(FAILED(hr))
      return hr;
  }

  if(cbLargest)
  {
    *pcbSample = cbLargest;
    m_cbLargestSampleSizeComputed = cbLargest;
    return S_OK;
  }
  else
  {
    return VFW_E_INVALID_FILE_FORMAT;
  }
}

HRESULT CImplOldAviIndex::GetInfo(StreamInfo *pStreamInfo)
{
  HRESULT hr = CImplStdAviIndex::GetInfo(pStreamInfo);

  DWORD dwLength = 0;
  for(ULONG ie = 0; ie < m_pStdIndex->nEntriesInUse; ie++)
    dwLength += GetTicksInEntry(ie);

  if(m_pStrh->fccType == streamtypeVIDEO)
    dwLength -= m_pStrh->dwInitialFrames;

  pStreamInfo->dwLength = dwLength;

  if(dwLength != m_pStrh->dwLength)
    DbgLog((LOG_ERROR, 3,
            TEXT("CImplOldAviIndex:: length from header: %d from index: %d"),
            m_pStrh->dwLength, dwLength));
  return hr;
}

DWORD CImplOldAviIndex::GetEntrySize()
{
  AVISTDINDEX_ENTRY &rEntry = m_pStdIndex->aIndex[m_iStdIndex];
  return GetSize(rEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimsr\aviindex.h ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// aviindex.h. classes that provide an interface to accessing index
// entries for AVI files with std, old, or no index
//

#ifndef _AviIndex_H
#define _AviIndex_H

#include <aviriff.h>
#include "reader.h"

struct IndexEntry
{
  DWORD dwSize;
  DWORDLONG qwPos;
  BOOL bKey;
  BOOL bPalChange;
  LONGLONG llStart;
  LONGLONG llEnd;
};

struct StreamInfo
{
  BOOL bTemporalCompression;
  DWORD dwStart;
  DWORD dwLength;
};

// request async index reads with this
struct IxReadReq
{
  DWORDLONG fileOffset;
  ULONG cbData;
};

//
// interface for accessing the index
//
class IAviIndex
{
public:

  virtual ~IAviIndex() {}

  // set the current index entry. S_FALSE means it landed in a
  // discontinuity
  virtual HRESULT SetPointer(LONGLONG llSrc) = 0;

  //
  // methods to advance the current index entry
  //

  // use pIrr to use asynchronous reads. S_FALSE means it needs a read
  // queued
  virtual HRESULT AdvancePointerForward(IxReadReq *pIrr) = 0;
  virtual HRESULT AdvancePointerBackward() = 0;
  virtual HRESULT AdvancePointerBackwardKeyFrame() = 0;
  virtual HRESULT AdvancePointerEnd() = 0;
  virtual HRESULT AdvancePointerStart() = 0;
  virtual HRESULT AdvancePointerBackwardPaletteChange() = 0;
  virtual HRESULT AdvancePointerForwardPaletteChange() = 0;

  // return the current index entry
  virtual HRESULT GetEntry(IndexEntry *pEntry) = 0;

  // information gotten from the index
  virtual HRESULT GetInfo(StreamInfo *pStreamInfo) = 0;

  virtual HRESULT GetLargestSampleSize(ULONG *pcbSample) = 0;

  // notify read completed from IxReadReq above
  virtual HRESULT IncomingIndex(BYTE *pb, ULONG cb) = 0;

  // this is done here because we don't want to read the disk (we'll
  // just use super index for an approximation). otherwise the avimsr
  // pin could just instantiate another instance of the index and use
  // the existing methods to map a byte offset to a sample

  virtual HRESULT MapByteToSampleApprox(
    LONGLONG *piSample,
    const LONGLONG &fileOffset,
    const LONGLONG &fileLength) = 0;

  // restarting; cancel pending reads, etc.
  virtual HRESULT Reset() = 0;
};

//
// implementation of IAviIndex for files with the std format index
//

class CImplStdAviIndex : public IAviIndex
{
public:

  CImplStdAviIndex(
    unsigned stream,
    AVIMETAINDEX *pIndx,
    AVISTREAMHEADER *pStrh,     /* needed for stream length, rate */
    RIFFCHUNK *pStrf,           /* needed for audio streams */
    IAsyncReader *pAsyncReader,
    HRESULT *phr);

  // dummy constructor. _ cos vc gives it the wrong this pointer o/w.
  void _CImplStdAviIndex();
  CImplStdAviIndex();

  ~CImplStdAviIndex();


  HRESULT SetPointer(LONGLONG llSrc);

  HRESULT AdvancePointerForward(IxReadReq *pIrr);
  HRESULT AdvancePointerBackward();
  HRESULT AdvancePointerBackwardKeyFrame();
  HRESULT AdvancePointerEnd();
  HRESULT AdvancePointerStart();
  HRESULT AdvancePointerBackwardPaletteChange();
  HRESULT AdvancePointerForwardPaletteChange();
  HRESULT GetEntry(IndexEntry *pEntry);
  virtual HRESULT GetInfo(StreamInfo *pStreamInfo);
  HRESULT GetLargestSampleSize(ULONG *pcbSample);
  HRESULT IncomingIndex(BYTE *pb, ULONG cb);
  HRESULT MapByteToSampleApprox(
      LONGLONG *piSample,
      const LONGLONG &fileOffset,
      const LONGLONG &fileLength);
  HRESULT Reset();
  
protected:

  // called from all constructors
  HRESULT Initialize(
    unsigned stream,
    AVIMETAINDEX *pIndx,
    AVISTREAMHEADER *pStrh,     /* needed for stream length, rate */
    RIFFCHUNK *pStrf);          /* needed for audio streams */

  // BOOL IsSampleEntry(DWORD dwIdMask, DWORD fccStream, DWORD idxid);
  inline BOOL IsStreamEntry(DWORD dwIdMask, DWORD idxid);
  BOOL IsPaletteChange(DWORD dwIdMask, DWORD idxid);

  ULONG GetTicksInEntry(ULONG iEntry);

  BOOL m_bValid;                // index is in a valid state

  IAsyncReader *m_pAsyncReader;

  BOOL GetPalChange(AVISTDINDEX_ENTRY &rEntry);
  DWORD GetSize(AVISTDINDEX_ENTRY &rEntry);

  ULONG m_iStdIndex;            // current sub index entry
  AVISTDINDEX *m_pStdIndex;     // pointer to current std index
  ULONG m_cbStdIndexAllocated;  // how much allocated there

  AVISUPERINDEX *m_pSuperIndex;

  AVISTREAMHEADER *m_pStrh;

private:

  HRESULT ValidateStdIndex(AVISTDINDEX *pStdIndex);
  HRESULT ValidateSuperIndex(AVISUPERINDEX *pSuperIndex);

  HRESULT AllocateStdIndex();
  HRESULT LoadStdIndex(DWORD dwiSuperIndex, IxReadReq *pIrr);

  BOOL GetKey(AVISTDINDEX_ENTRY &rEntry);
  BYTE *GetStrf();

  unsigned m_stream;            // which stream this indexes

  RIFFCHUNK *m_pStrf;

  ULONG m_iSuperIndex;          // sub index that is loaded
  DWORDLONG m_lliTick;          // current `tick'

  BOOL m_fWaitForIndex;         // waiting for async index read
};

class CImplOldAviIndex : public CImplStdAviIndex
{
public:
  CImplOldAviIndex(
    unsigned stream,
    AVIOLDINDEX *pIdx1,
    DWORDLONG moviOffset,
    AVISTREAMHEADER *pStrh,     /* needed for stream length, rate */
    RIFFCHUNK *pStrf,           /* needed for audio streams */
    HRESULT *phr);

  HRESULT AdvancePointerBackwardPaletteChange();
  HRESULT AdvancePointerForwardPaletteChange();
  HRESULT GetLargestSampleSize(ULONG *pcbSample);

  // only for new format indexes
  HRESULT IncomingIndex(BYTE *pb, ULONG cb) { return E_UNEXPECTED; }

  // overriden because the dwLength field in old AVI files can't be
  // trusted
  HRESULT GetInfo(StreamInfo *pStreamInfo);

private:

  // return the size of a specific Index Entry
  DWORD GetEntrySize(void);

  ULONG m_cbLargestSampleSizeComputed;

};

#endif // _AviIndex_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimsr\avimsr.h ===
#pragma warning(disable: 4097 4511 4512 4514 4705)

// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef _avimsr_h
#define _avimsr_h

#include "basemsr.h"
#include <aviriff.h>
#include "aviindex.h"
#include "qnetwork.h"

extern const AMOVIESETUP_FILTER sudAvimsrDll;

class CAviMSRFilter :
    public CBaseMSRFilter,
    public IAMMediaContent,
    public IPersistMediaPropertyBag
{

  DECLARE_IUNKNOWN;

public:
  // create a new instance of this class
  static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

  // want to find pins named "Stream 00" as well as usual names
  STDMETHODIMP FindPin(
    LPCWSTR Id,
    IPin ** ppPin
    );

  // helpers, accessed by pins
  HRESULT GetIdx1(AVIOLDINDEX **ppIdx1);
  HRESULT GetMoviOffset(DWORDLONG *pqw);
  REFERENCE_TIME GetInitialFrames();

  HRESULT GetCacheParams(
    StreamBufParam *rgSbp,
    ULONG *pcbRead,
    ULONG *pcBuffers,
    int *piLeadingStream);

  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

  // IPersistMediaPropertyBag methods
  STDMETHODIMP InitNew();
  STDMETHODIMP Load(IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog);
  STDMETHODIMP Save(IMediaPropertyBag *pPropBag, BOOL fClearDirty,
                  BOOL fSaveAllProperties);
  STDMETHODIMP GetClassID(CLSID *pClsid);


private:

  friend class CAviMSROutPin;

  // constructors, etc.
  CAviMSRFilter(TCHAR *pszFilter, LPUNKNOWN pUnk, HRESULT *phr);
  ~CAviMSRFilter();

  ULONG CountConsecutiveVideoFrames();

  // pure CBaseMSRFilter overrides
  HRESULT CreateOutputPins();

  HRESULT NotifyInputDisconnected();

  // pure base override
  HRESULT CheckMediaType(const CMediaType* mtOut);

  // helpers, internal
  HRESULT Search(
    DWORDLONG *qwPosOut,
    FOURCC fccSearchKey,
    DWORDLONG qwPosStart,
    ULONG *cb);

  HRESULT CacheInfoChunk();
  HRESULT GetInfoString(DWORD dwFcc, BSTR *pbstr);

  inline bool IsTightInterleaved() { return m_fIsTightInterleaved; }

  HRESULT CreatePins();
  HRESULT ParseHeaderCreatePins();
  HRESULT LoadHeaderParseHeaderCreatePins();

  // IAMMediaContent

  STDMETHODIMP GetTypeInfoCount(THIS_ UINT FAR* pctinfo) { return E_NOTIMPL; }

  STDMETHODIMP GetTypeInfo(
    THIS_
    UINT itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo) { return E_NOTIMPL; }

  STDMETHODIMP GetIDsOfNames(
    THIS_
    REFIID riid,
    OLECHAR FAR* FAR* rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID FAR* rgdispid) { return E_NOTIMPL; }

  STDMETHODIMP Invoke(
    THIS_
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr) { return E_NOTIMPL; }

  STDMETHODIMP get_AuthorName(BSTR FAR* pbstrAuthorName);
  STDMETHODIMP get_Title(BSTR FAR* pbstrTitle);
  STDMETHODIMP get_Rating(BSTR FAR* pbstrRating) { return E_NOTIMPL; }
  STDMETHODIMP get_Description(BSTR FAR* pbstrDescription) { return E_NOTIMPL; }
  STDMETHODIMP get_Copyright(BSTR FAR* pbstrCopyright);
  STDMETHODIMP get_BaseURL(BSTR FAR* pbstrBaseURL) { return E_NOTIMPL; }
  STDMETHODIMP get_LogoURL(BSTR FAR* pbstrLogoURL) { return E_NOTIMPL; }
  STDMETHODIMP get_LogoIconURL(BSTR FAR* pbstrLogoIconURL) { return E_NOTIMPL; }
  STDMETHODIMP get_WatermarkURL(BSTR FAR* pbstrWatermarkURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoURL(BSTR FAR* pbstrMoreInfoURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoBannerURL(BSTR FAR* pbstrMoreInfoBannerURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoBannerImage(BSTR FAR* pbstrMoreInfoBannerImage) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoText(BSTR FAR* pbstrMoreInfoText) { return E_NOTIMPL; }

    

  // pointer to buffer containing all of AVI 'hdrl' chunk. (allocated)
  BYTE * m_pAviHeader;

  // size of avi header data (does not include size of riff header or
  // 'hdrl' bytes)
  UINT m_cbAviHeader;

  // pointer to main avi header within m_pAviHeader (not allocated)
  AVIMAINHEADER * m_pAviMainHeader;

  // pointer to odml list within m_pAviHeader or 0. (not allocated)
  RIFFLIST * m_pOdmlList;

  DWORDLONG m_cbMoviOffset;

  // allocated
  AVIOLDINDEX *m_pIdx1;

  bool m_fIsDV;
  bool m_fIsTightInterleaved;
  RIFFLIST *m_pInfoList;
  bool m_fNoInfoList;         // search failed; don't keep searching    
};

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

class CAviMSRWorker : public CBaseMSRWorker
{
public:
  // constructor
  CAviMSRWorker(
    UINT stream,
    IMultiStreamReader *pReader,
    IAviIndex *pImplIndex);

  // pure base overrides
  HRESULT PushLoopInit(LONGLONG *pllCurrentOut, ImsValues *pImsValues);

  HRESULT TryQueueSample(
    LONGLONG &rllCurrent,       // [in, out]
    BOOL &rfQueuedSample,       // [out]
    ImsValues *pImsValues
    );

  // build media type with palette change info
  HRESULT HandleData(IMediaSample *pSample, DWORD dwUser);

  // set new palette
  HRESULT AboutToDeliver(IMediaSample *pSample);

private:

  HRESULT QueueIndexRead(IxReadReq *pReq);
  IxReadReq m_Irr;
  enum IrrState { IRR_NONE, IRR_REQUESTED, IRR_QUEUED };
  IrrState m_IrrState;

  IAviIndex *m_pImplIndex;

  ULONG m_cbAudioChunkOffset;

  // new media type for next sample delivered
  bool m_fDeliverPaletteChange;
  bool m_fDeliverDiscontinuity; // !!! use dwflags for these flags

  // Fix MPEG audio timestamps
  bool m_fFixMPEGAudioTimeStamps;

  CMediaType m_mtNextSample;

  HRESULT HandlePaletteChange(BYTE *pb, ULONG cb);
  HRESULT HandleNewIndex(BYTE *pb, ULONG cb);

  // valid after PushLoopInit
  AVISTREAMHEADER *m_pStrh;
  WAVEFORMATEX m_wfx;

#ifdef PERF
  int m_perfidIndex;
#endif
};

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

class CAviMSROutPin :
    public CBaseMSROutPin,
    public IPropertyBag
{
public:
  CAviMSROutPin(    CBaseFilter *pOwningFilter,
                    CBaseMSRFilter *pFilter,
                    UINT iStream,
                    IMultiStreamReader *&rpImplBuffer,
                    HRESULT *phr,
                    LPCWSTR pName);

  ~CAviMSROutPin();

  DECLARE_IUNKNOWN;
  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

  // base class overrides
  ULONG GetMaxSampleSize();
  HRESULT OnActive();

  // internal helper, called from the filter
  BOOL ParseHeader (RIFFLIST * pRiffList, UINT id);
  BYTE *GetStrf();
  AVISTREAMHEADER *GetStrh();

  // base class wants these for IMediaSelection
  HRESULT IsFormatSupported(const GUID *const pFormat);
  HRESULT GetDuration(LONGLONG *pDuration);
  HRESULT GetAvailable(LONGLONG *pEarliest, LONGLONG *pLatest);

  HRESULT RecordStartAndStop(
    LONGLONG *pCurrent,
    LONGLONG *pStop,
    REFTIME *pTime,
    const GUID *const pGuidFormat
    );

  // helpers
  LONGLONG ConvertToTick(const LONGLONG ll, const TimeFormat Format);
  LONGLONG ConvertFromTick(const LONGLONG ll, const TimeFormat Format);
  LONGLONG ConvertToTick(const LONGLONG ll, const GUID *const pFormat);
  LONGLONG ConvertFromTick(const LONGLONG ll, const GUID *const pFormat);

  REFERENCE_TIME ConvertInternalToRT(const LONGLONG llVal);
  LONGLONG ConvertRTToInternal(const REFERENCE_TIME llVal);

  // IPropertyBag
  STDMETHODIMP Read( 
    /* [in] */ LPCOLESTR pszPropName,
    /* [out][in] */ VARIANT *pVar,
    /* [in] */ IErrorLog *pErrorLog);
        
  STDMETHODIMP Write( 
    /* [in] */ LPCOLESTR pszPropName,
    /* [in] */ VARIANT *pVar) { return E_FAIL; } 

private:

  // base class overrides
  HRESULT GetMediaType(int iPosition, CMediaType* pt);
  LONGLONG GetStreamStart();
  LONGLONG GetStreamLength();

  REFERENCE_TIME GetRefTime(ULONG tick);

  // internal helpers
  HRESULT InitializeIndex();
  IAviIndex *m_pImplIndex;
  HRESULT BuildMT();

  // pointers to data allocated elsewhere. set in ParseHeader
  AVISTREAMHEADER *m_pStrh;
  RIFFCHUNK *m_pStrf;
  char *m_pStrn;
  AVIMETAINDEX *m_pIndx;

  CMediaType m_mtFirstSample;

  friend class CAviMSRWorker;
  friend class CAviMSRFilter;

  // never deliver more than this many bytes of audio. computed when
  // the file is parsed from nAvgBytesPerSecond. unset for video
  ULONG m_cbMaxAudio;
};

class CMediaPropertyBag :
    public IMediaPropertyBag,
    public CUnknown

{
    DECLARE_IUNKNOWN;

public:

    CMediaPropertyBag(LPUNKNOWN pUnk);
    ~CMediaPropertyBag();

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);


    // IMediaPropertyBag

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP Read(
        LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);

    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);

    STDMETHODIMP EnumProperty(
        ULONG iProperty, VARIANT *pvarName,
        VARIANT *pVarVal);

    struct PropPair
    {
        WCHAR *wszProp;
        VARIANT var;
    };

private:

    // same as read, but returns the internal list pointer
    HRESULT Read(
        LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog, POSITION *pPos);

    CGenericList<PropPair> m_lstProp;
};

// functions shared between avi parser and wav parser
HRESULT SearchList(
    IAsyncReader *pAsyncReader,
    DWORDLONG *qwPosOut, FOURCC fccSearchKey,
    DWORDLONG qwPosStart, ULONG *cb);

HRESULT SaveInfoChunk(
    RIFFLIST UNALIGNED *pRiffInfo, IPropertyBag *pbag);

HRESULT GetInfoStringHelper(RIFFLIST *pInfoList, DWORD dwFcc, BSTR *pbstr);

#endif // _avimsr_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimux\alloc.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "alloc.h"

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
//
// Implements CSfxAllocator
//

CSfxAllocator::CSfxAllocator(
  TCHAR *pName,
  LPUNKNOWN pUnk,
  HRESULT *phr) :
    CMemAllocator(pName, pUnk, phr),
    m_cbSuffix(0)
{
}

HRESULT
CSfxAllocator::SetPropertiesAndSuffix(
  ALLOCATOR_PROPERTIES *pRequest,
  ULONG cbSuffixReq,
  ALLOCATOR_PROPERTIES *pActual)
{
  HRESULT hr = CMemAllocator::SetProperties(
    pRequest, pActual);
  if(FAILED(hr))
    return hr;

  m_cbSuffix = cbSuffixReq;
  return S_OK;
}

STDMETHODIMP
CSfxAllocator::SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pRequest, E_POINTER);
    ALLOCATOR_PROPERTIES apreq_copy = *pRequest;
    apreq_copy.cbAlign = max(apreq_copy.cbAlign, m_lAlignment);
    apreq_copy.cbPrefix = max(apreq_copy.cbPrefix, m_lPrefix);
    return CMemAllocator::SetProperties(&apreq_copy, pActual);
}



// ------------------------------------------------------------------------
// allocate the memory, this code copied from CMemAllocator and
// changed for the suffix

HRESULT
CSfxAllocator::Alloc(void)
{

  CAutoLock lck(this);

  /* Check he has called SetProperties */
  HRESULT hr = CBaseAllocator::Alloc();
  if (FAILED(hr)) {
    return hr;
  }

  /* If the requirements haven't changed then don't reallocate */
  if (hr == S_FALSE) {
    ASSERT(m_pBuffer);
    return NOERROR;
  }
  ASSERT(hr == S_OK); // we use this fact in the loop below

  /* Free the old resources */
  if (m_pBuffer) {
    ReallyFree();
  }

  // this allocator's responsibility to make sure the end of the
  // suffix is aligned.
  ULONG cbSuffixAdjust = 0;
  if(m_cbSuffix != 0)
  {
    cbSuffixAdjust += max((ULONG)m_lAlignment, m_cbSuffix);
  }

  // note we don't handle suffixes larger than alignment (except 1)
  ASSERT(cbSuffixAdjust >= m_cbSuffix);

  /* Create the contiguous memory block for the samples
     making sure it's properly aligned (64K should be enough!)
     */
  ASSERT(m_lAlignment != 0 &&
         (m_lSize + m_lPrefix) % m_lAlignment == 0);

  ASSERT((m_lSize + m_lPrefix + cbSuffixAdjust) % m_lAlignment == 0);

  m_pBuffer = (PBYTE)VirtualAlloc(
    NULL,
    m_lCount * (m_lSize + m_lPrefix + cbSuffixAdjust),
    MEM_COMMIT,
    PAGE_READWRITE);

  if (m_pBuffer == NULL) {
    return E_OUTOFMEMORY;
  }

  LPBYTE pNext = m_pBuffer;
  CMediaSample *pSample;

  ASSERT(m_lAllocated == 0);

  // Create the new samples - we have allocated m_lSize bytes for each sample
  // plus m_lPrefix bytes per sample as a prefix. We set the pointer to
  // the memory after the prefix - so that GetPointer() will return a pointer
  // to m_lSize bytes.
  for (; m_lAllocated < m_lCount;
       m_lAllocated++, pNext += (m_lSize + m_lPrefix + cbSuffixAdjust))
  {
    pSample = new CMediaSample(
      NAME("Default memory media sample"),
      this,
      &hr,
      pNext + m_lPrefix,      // GetPointer() value
      m_lSize + cbSuffixAdjust - m_cbSuffix); // size less prefix and suffix

    ASSERT(SUCCEEDED(hr));
    if (pSample == NULL) {
      return E_OUTOFMEMORY;
    }

    // This CANNOT fail
    m_lFree.Add(pSample);
  }

  m_bChanged = FALSE;
  return NOERROR;
}

//
// Destructor frees our memory resources

CSfxAllocator::~CSfxAllocator()
{
}

CSampSample::CSampSample(
  TCHAR *pName,
  CBaseAllocator *pAllocator,
  HRESULT *phr) :
    CMediaSample(pName, pAllocator, phr),
    m_pSample(0)
{
}

HRESULT CSampSample::SetSample(
  IMediaSample *pSample,
  BYTE *pb,
  ULONG cb)
{
  ASSERT(m_pSample == 0);

  m_pSample = pSample;
  pSample->AddRef();

  HRESULT hr = SetPointer(pb, cb);
  ASSERT(hr == S_OK);

  return S_OK;
}

STDMETHODIMP_(ULONG) CSampSample::Release()
{
  IMediaSample *pSample = m_pSample;
  ULONG c = CMediaSample::Release();
  if(c == 0 && pSample != 0)
  {
    pSample->Release();
    // cannot zero m_pSample because CMediaSample::NonDelegatingRelease
    // might have deleted this
  }

  return c;
}

CSampAllocator::CSampAllocator(
  TCHAR *pName,
  LPUNKNOWN pUnk,
  HRESULT *phr) :
    CBaseAllocator(pName, pUnk, phr)
{
}

CSampAllocator::~CSampAllocator()
{
  Decommit();
  ReallyFree();
}

HRESULT CSampAllocator::Alloc()
{
  HRESULT hr = S_OK;
  if(m_lCount <= 0)
    return VFW_E_SIZENOTSET;

  for(int i = 0; i < m_lCount; i++, m_lAllocated++)
  {
    CSampSample *pSample = new CSampSample(
      NAME("samp sample"),
      this,
      &hr);
    if(pSample == 0)
      return E_OUTOFMEMORY;
    if(hr != S_OK)
      return hr;
    m_lFree.Add(pSample);
  }

  return S_OK;
}

void CSampAllocator::ReallyFree()
{
  ASSERT(m_lAllocated == m_lFree.GetCount());
  CSampSample *pSample;
  for (;;) {
    pSample = (CSampSample *)(m_lFree.RemoveHead());
    if (pSample != NULL) {
      delete pSample;
    } else {
      break;
    }
  }
  m_lAllocated = 0;
}

void CSampAllocator::Free()
{

}

STDMETHODIMP
CSampAllocator::SetProperties(
  ALLOCATOR_PROPERTIES* pRequest,
  ALLOCATOR_PROPERTIES* pActual)
{
  ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

  /* Can't do this if already committed, there is an argument that says we
     should not reject the SetProperties call if there are buffers still
     active. However this is called by the source filter, which is the same
     person who is holding the samples. Therefore it is not unreasonable
     for them to free all their samples before changing the requirements */

  if (m_bCommitted) {
    return VFW_E_ALREADY_COMMITTED;
  }

  /* Must be no outstanding buffers */

  if (m_lAllocated != m_lFree.GetCount()) {
    return VFW_E_BUFFERS_OUTSTANDING;
  }

  /* There isn't any real need to check the parameters as they
     will just be rejected when the user finally calls Commit */

  pActual->cbBuffer = m_lSize = pRequest->cbBuffer;
  pActual->cBuffers = m_lCount = pRequest->cBuffers;
  pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
  pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

  m_bChanged = TRUE;
  return NOERROR;
}

STDMETHODIMP CSampAllocator::GetBuffer(
  CSampSample **ppBuffer,
  REFERENCE_TIME * pStartTime,
  REFERENCE_TIME * pEndTime,
  DWORD dwFlags)
{
  IMediaSample *pSample;
  HRESULT hr = CBaseAllocator::GetBuffer(&pSample, pStartTime, pEndTime, dwFlags);
  *ppBuffer = (CSampSample *)pSample;
  if(SUCCEEDED(hr))
  {
    (*ppBuffer)->m_pSample = 0;
  }
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimsr\avimsr.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

// AVI File parser built on CBaseMSRFilter. Plus a property bag
// implementation to read the copyright strings and such from the AVI
// file.
//
// The interesting things about it are
//
// 1. the index may be streamed in along with the data. The worker
// thread maintains this state and cannot queue new reads until the
// index is read off disk.
//
// 2. lots of customization to buffer things efficiently. tightly
// interleaved (1 to 1) files are handled differently.
//

#include <streams.h>
#include <mmreg.h>
#include "basemsr.h"
#include "avimsr.h"
#include <checkbmi.h>

// each stream works with 20 buffers if it's an interleaved file.
#define C_BUFFERS_INTERLEAVED 20

enum SampleDataType
{
  // zero means its a sample, so we can't use that value
  DATA_PALETTE = 1,
  DATA_INDEX = 2
};

// easier than computing structure sizes
static const UINT CB_STRH_SHORT = 0x24;
static const UINT CB_STRH_NORMAL = 0x30;
// and they can have 0x38 bytes if they have the rcFrame fields

// ------------------------------------------------------------------------
// setup data

const AMOVIESETUP_MEDIATYPE sudIpPinTypes =
{
  &MEDIATYPE_Stream,            // MajorType
  &MEDIASUBTYPE_Avi             // MintorType
};

const AMOVIESETUP_MEDIATYPE sudOpPinTypes =
{
  &MEDIATYPE_Video,             // MajorType
  &MEDIASUBTYPE_NULL            // MintorType
};

const AMOVIESETUP_PIN psudAvimsrPins[] =
{
  { L"Input",                     // strName
    FALSE,                        // bRendererd
    FALSE,                        // bOutput
    FALSE,                        // bZero
    FALSE,                        // bMany
    &CLSID_NULL,                  // connects to filter
    NULL,                         // connects to pin
    1,                            // nMediaTypes
    &sudIpPinTypes }              // lpMediaType
,
  { L"Output",                    // strName
    FALSE,                        // bRendererd
    TRUE,                         // bOutput
    FALSE,                        // bZero
    FALSE,                        // bMany
    &CLSID_NULL,                  // connects to filter
    NULL,                         // connects to pin
    1,                            // nMediaTypes
    &sudOpPinTypes }              // lpMediaType
};

const AMOVIESETUP_FILTER sudAvimsrDll =
{
  &CLSID_AviSplitter,           // clsID
  L"AVI Splitter",              // strName
  MERIT_NORMAL,                 // dwMerit
  2,                            // nPins
  psudAvimsrPins                // lpPin
};

// nothing to say about the output pin

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = {
  { L"AVI Splitter"
  , &CLSID_AviSplitter
  , CAviMSRFilter::CreateInstance
  , NULL
  , &sudAvimsrDll }
  ,
  { L"CMediaPropertyBag",
    &CLSID_MediaPropertyBag,
    CMediaPropertyBag::CreateInstance,
    0,
    0
  }
};
int g_cTemplates = NUMELMS(g_Templates);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif // FILTER_DLL


CUnknown * CAviMSRFilter::CreateInstance (
  LPUNKNOWN pUnk,
  HRESULT* phr)
{
  if(FAILED(*phr))
    return 0;

  return new CAviMSRFilter(NAME("AVI File Reader"), pUnk, phr);
}

CAviMSRFilter::CAviMSRFilter(
  TCHAR *pName,
  LPUNKNOWN pUnk,
  HRESULT *phr) :
        CBaseMSRFilter(pName, pUnk, CLSID_AviSplitter, phr),
        m_pInfoList(0),
        m_fNoInfoList(false)
{
  m_pAviHeader = 0;
  m_pIdx1 = 0;
  m_cbMoviOffset = 0;
  m_fIsDV = false;

  if(FAILED(*phr))
    return;

  // base ctor can't do this for us.
  *phr = CreateInputPin(&m_pInPin);
}


CAviMSRFilter::~CAviMSRFilter()
{
  delete[] m_pAviHeader;
  delete[] m_pIdx1;
  ASSERT(m_pInfoList == 0);
  ASSERT(!m_fNoInfoList);
}


// ------------------------------------------------------------------------
// implementation of a virtual method. we need to find pins persisted
// by the 1.0 runtime AVI parser. tries the base class implementation
// first.

STDMETHODIMP
CAviMSRFilter::FindPin(
  LPCWSTR Id,
  IPin ** ppPin
  )
{
  CheckPointer(ppPin,E_POINTER);
  ValidateReadWritePtr(ppPin,sizeof(IPin *));

  //  We're going to search the pin list so maintain integrity
  CAutoLock lck(m_pLock);
  HRESULT hr = CBaseFilter::FindPin(Id, ppPin);
  if(hr != VFW_E_NOT_FOUND)
    return hr;

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    WCHAR wszPinName[20];
    wsprintfW(wszPinName, L"Stream %02x", iStream);
    if(0 == lstrcmpW(wszPinName, Id))
    {
      //  Found one that matches
      //
      //  AddRef() and return it
      *ppPin = m_rgpOutPin[iStream];
      (*ppPin)->AddRef();
      return S_OK;
    }
  }

  *ppPin = NULL;
  return VFW_E_NOT_FOUND;
}

HRESULT CAviMSRFilter::CreateOutputPins()
{
  ASSERT(m_pAviHeader == 0);
  ASSERT(m_pIdx1 == 0);
  ASSERT(m_cbMoviOffset == 0);

  // set in constructor and breakconnect
  ASSERT(!m_fIsDV);

  HRESULT hr = LoadHeaderParseHeaderCreatePins();
  return hr;
}

HRESULT CAviMSRFilter::NotifyInputDisconnected()
{
  CAutoLock lck(m_pLock);

  delete[] m_pAviHeader;
  m_pAviHeader = 0;

  delete[] m_pIdx1;
  m_pIdx1 = 0;

  m_cbMoviOffset = 0;
  m_fIsDV = false;

  delete[] (BYTE *)m_pInfoList;
  m_pInfoList = 0;
  m_fNoInfoList = false;

  return CBaseMSRFilter::NotifyInputDisconnected();
}

//
// read the old format index chunk if unread, return it
//
HRESULT CAviMSRFilter::GetIdx1(AVIOLDINDEX **ppIdx1)
{
  if(!(m_pAviMainHeader->dwFlags & AVIF_HASINDEX))
  {
    return VFW_E_NOT_FOUND;
  }

  HRESULT hr;
  if(!m_pIdx1)
  {
    ULONG cbIdx1;
    DWORDLONG qw;
    hr = Search(&qw, FCC('idx1'), sizeof(RIFFLIST), &cbIdx1);
    if(SUCCEEDED(hr))
    {
      hr = AllocateAndRead((BYTE **)&m_pIdx1, cbIdx1, qw);
      if(FAILED(hr))
        return hr == E_OUTOFMEMORY ? E_OUTOFMEMORY : VFW_E_INVALID_FILE_FORMAT;
    }
    else
    {
      return VFW_E_INVALID_FILE_FORMAT;
    }
  }

  ASSERT(m_pIdx1);
  *ppIdx1 = m_pIdx1;
  return S_OK;
}

// return byte offset of movi chunk
HRESULT CAviMSRFilter::GetMoviOffset(DWORDLONG *pqw)
{
  ULONG cbMovi;
  HRESULT hr = S_OK;

  if(m_cbMoviOffset == 0)
  {
    hr = SearchList(
      m_pAsyncReader,
      &m_cbMoviOffset, FCC('movi'), sizeof(RIFFLIST), &cbMovi);
  }
  if(SUCCEEDED(hr))
    *pqw = m_cbMoviOffset;
  else
    *pqw = 0;

  return SUCCEEDED(hr) ? S_OK : VFW_E_INVALID_FILE_FORMAT;
}

REFERENCE_TIME CAviMSRFilter::GetInitialFrames()
{
  return m_pAviMainHeader->dwInitialFrames *
    m_pAviMainHeader->dwMicroSecPerFrame *
    (UNITS / (MILLISECONDS * 1000));
}

HRESULT CAviMSRFilter::GetCacheParams(
  StreamBufParam *rgSbp,
  ULONG *pcbRead,
  ULONG *pcBuffers,
  int *piLeadingStream)
{
  HRESULT hr = CBaseMSRFilter::GetCacheParams(
    rgSbp,
    pcbRead,
    pcBuffers,
    piLeadingStream);
  if(FAILED(hr))
    return hr;

  // for tightly interleaved files, we try to read one record at a
  // time for cheap hardware that locks the machine if we read large
  // blocks
  if(IsTightInterleaved())
  {
    DbgLog((LOG_TRACE, 15, TEXT("CAviMSRFilter:GetCacheParams: interleaved")));

    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      rgSbp[iStream].cSamplesMax = C_BUFFERS_INTERLEAVED;
    }

    // set leading stream to first audio stream. negative (from base
    // class) if we can't find one. indicates no leading stream.
    ASSERT(*piLeadingStream < 0);
    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      if(((CAviMSROutPin *)m_rgpOutPin[iStream])->GetStrh()->fccType ==
         streamtypeAUDIO)
      {
        *piLeadingStream = iStream;
        break;
      }
    }

    // one buffer per frame.
    ULONG cbRead = 0;
    for(iStream = 0; iStream < m_cStreams; iStream++)
      cbRead += m_rgpOutPin[iStream]->GetMaxSampleSize();
    *pcbRead = cbRead + 2048;   // 2k alignment in interleaved files
    if(m_pAviMainHeader->dwMicroSecPerFrame == 0)
    {
      // arbitrary number of buffers
      *pcBuffers = max(10, m_cStreams);
    }
    else
    {
      // buffers enough for .75 seconds
      *pcBuffers = max(
        ((LONG)UNITS / 10 * 3 / 4 / m_pAviMainHeader->dwMicroSecPerFrame),
        m_cStreams);
    }
  }
  else                          // not interleaved
  {
    DbgLog((LOG_TRACE, 15,
            TEXT("CAviMSRFilter:GetCacheParams: uninterleaved")));

    // no leading stream. base class sets this
    ASSERT(*piLeadingStream < 0);

    // target reading 64k at a time
    *pcbRead = 64 * 1024;

    // for files with audio after the video, we're trying to size each
    // buffer to contain one audio block and the corresponding
    // video. so for a file that looks like
    //
    // (15 v) a (15 v) a (15 v) a (15 v) a (15 v) a (15 v) a
    //
    // we need three buffers because the directsound renderer will
    // receive, copy, and release 2 buffers immediately (1 second of
    // buffering). and we need to keep from trying to read the 3rd
    // audio block into a reserve buffer.

    if(!m_fIsDV) {
        *pcBuffers = (m_cStreams > 1 ? 3 : 2);
    }
    else
    {
        // DV splitter needs to work with more than 2 buffers at once
        // and negotiating this is broken.
        *pcBuffers = 4;
    }


    // first need to find out what the largest sample in the file is.
    ULONG cbLargestSample = 0;
    ULONG cbSumOfLargestSamples = 0;
    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      if(m_rgpOutPin[iStream]->GetMaxSampleSize() == 0)
        return VFW_E_INVALID_FILE_FORMAT;

      // really should add in the alignment here
      cbSumOfLargestSamples += m_rgpOutPin[iStream]->GetMaxSampleSize();

      cbLargestSample = max(
        m_rgpOutPin[iStream]->GetMaxSampleSize(),
        cbLargestSample);
    }

    if(m_cStreams > 1)
    {

      ULONG cInterleave = CountConsecutiveVideoFrames();

      // this number should be the number of video frames between audio
      // chunks
      *pcbRead = max(cbSumOfLargestSamples * cInterleave, *pcbRead);
    }
    else
    {
      // there may be some garbage around each frame (RIFF header,
      // sector alignment, etc.) so add in an extra 2k around each
      // frame.
      *pcbRead = (cbSumOfLargestSamples + 2048) * 2;
    }
  }

  return S_OK;
}

STDMETHODIMP
CAviMSRFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if(riid == IID_IPersistMediaPropertyBag)
    {
        return GetInterface((IPersistMediaPropertyBag *)this, ppv);
    }
    else if(riid == IID_IAMMediaContent)
    {
        return GetInterface((IAMMediaContent *)this, ppv);
    }
    else
    {
        return CBaseMSRFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


// ------------------------------------------------------------------------
// IPropertyBag

// ------------------------------------------------------------------------
// IPersistMediaPropertyBag

STDMETHODIMP CAviMSRFilter::Load(IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog)
{
    CheckPointer(pPropBag, E_POINTER);

    // the avi parser is read-only!
    HRESULT hr = STG_E_ACCESSDENIED;
    return hr;
}

HRESULT CAviMSRFilter::CacheInfoChunk()
{
    ASSERT(CritCheckIn(m_pLock));

    if(m_pInfoList) {
        return S_OK;
    }
    if(m_fNoInfoList) {
        return VFW_E_NOT_FOUND;
    }

    // !!! don't block waiting for progressive download

    // search the first RIFF list for an INFO list
    DWORDLONG dwlInfoPos;
    ULONG cbInfoList;
    HRESULT hr = SearchList(
      m_pAsyncReader,
      &dwlInfoPos, FCC('INFO'), sizeof(RIFFLIST), &cbInfoList);
    if(SUCCEEDED(hr))
    {
        hr = AllocateAndRead((BYTE **)&m_pInfoList, cbInfoList, dwlInfoPos);
    }

    if(FAILED(hr)) {
        ASSERT(!m_fNoInfoList);
        m_fNoInfoList = true;
    }

    return hr;

}

HRESULT ReadInfoChunk(RIFFLIST UNALIGNED *pInfoList, UINT iEntry, RIFFCHUNK UNALIGNED **ppRiff)
{
    HRESULT hr = VFW_E_NOT_FOUND;

    // alignment not guaranteed.
    RIFFCHUNK UNALIGNED * pRiff = (RIFFCHUNK *)(pInfoList + 1);// first entry

    // safe to use this limit because we know we allocated pInfoList->cb bytes.
    RIFFCHUNK * pLimit = (RIFFCHUNK *)((BYTE *)pRiff + pInfoList->cb);

    // enumerate elements of the INFO list
    while(pRiff + 1 < pLimit)
    {
        if( ((BYTE*)pRiff + pRiff->cb + sizeof(RIFFCHUNK)) > (BYTE*)pLimit )
        {
            hr = VFW_E_INVALID_FILE_FORMAT;
            break;
        }

        if(iEntry == 0)
        {
            *ppRiff = pRiff;
            hr = S_OK;
            break;
        }

        if(RIFFNEXT(pRiff) > pLimit)
        {
            hr = VFW_E_NOT_FOUND;
            break;
        }

        iEntry--;
        pRiff = RIFFNEXT(pRiff);
    }

    return hr;
}

HRESULT CAviMSRFilter::GetInfoString(DWORD dwFcc, BSTR *pbstr)
{
    *pbstr = 0;
    CAutoLock l(m_pLock);

    HRESULT hr = CacheInfoChunk();
    if(SUCCEEDED(hr)) {
        hr = GetInfoStringHelper(m_pInfoList, dwFcc, pbstr);
    }
    return hr;
}

HRESULT SaveInfoChunk(
    RIFFLIST UNALIGNED *pRiffInfo,
    IPropertyBag *pPropBag)
{
    RIFFCHUNK UNALIGNED * pRiff;
    HRESULT hr = S_OK;
    for(UINT ichunk = 0; SUCCEEDED(hr); ichunk++)
    {
        // ignore error when there are no more items
        HRESULT hrTmp = ReadInfoChunk(pRiffInfo, ichunk, &pRiff);
        if(FAILED(hrTmp)) {
            break;
        }
        if(pRiff->cb == 0) {
            DbgLog((LOG_ERROR, 0, TEXT("0 byte INFO chunk (bad file.)")));
            continue;
        }

        DWORD szProp[2];        // string dereferences as DWORD
        szProp[0] = pRiff->fcc;
        szProp[1] = 0;          // null terminate
        WCHAR wszProp[20];
        wsprintfW(wszProp, L"INFO/%hs", szProp);

        VARIANT var;
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocStringLen(0, pRiff->cb);
        if(var.bstrVal)
        {
            char *sz = (char *)(pRiff + 1);
            sz[pRiff->cb - 1] = 0; // null terminate

            if(MultiByteToWideChar(
                CP_ACP, 0, sz, pRiff->cb, var.bstrVal, pRiff->cb))
            {
                hr = pPropBag->Write(wszProp, &var);
                DbgLog((LOG_TRACE, 10,
                        TEXT("CAviMSRFilter::Save: wrote %S to prop bag, hr = %08x"),
                        wszProp, hr));
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }
            SysFreeString(var.bstrVal);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    } // for loop


    return hr;
}

HRESULT GetInfoStringHelper(RIFFLIST *pInfoList, DWORD dwFcc, BSTR *pbstr)
{
    HRESULT hr = S_OK;

    for(UINT ichunk = 0; SUCCEEDED(hr); ichunk++)
    {
        RIFFCHUNK UNALIGNED *pRiff;
        hr = ReadInfoChunk(pInfoList, ichunk, &pRiff);
        if(SUCCEEDED(hr) && pRiff->fcc == dwFcc)
        {
            *pbstr = SysAllocStringLen(0, pRiff->cb);
            if(*pbstr)
            {
                char *sz = (char *)(pRiff + 1);
                sz[pRiff->cb - 1] = 0; // null terminate

                MultiByteToWideChar(
                    CP_ACP, 0, sz, pRiff->cb, *pbstr, pRiff->cb);

                break;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

// dump everything in the info and disp chunks into the caller's
// property bag. property names are "INFO/xxxx" and "DISP/nnnnnnnn"

STDMETHODIMP CAviMSRFilter::Save(
    IMediaPropertyBag *pPropBag,
    BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    CAutoLock lck(m_pLock);
    HRESULT hr = CacheInfoChunk();

    if(SUCCEEDED(hr))
    {
        hr = SaveInfoChunk(m_pInfoList, pPropBag);
    }


    hr = S_OK;                  // ignore errors

    // now the disp chunks
    ULONG cbDispChunk;
    DWORDLONG dwlStartPos = sizeof(RIFFLIST);
    DWORDLONG dwlDispPos;

    while(SUCCEEDED(hr) &&
          SUCCEEDED(Search(&dwlDispPos, FCC('DISP'), dwlStartPos, &cbDispChunk)))
    {
        RIFFCHUNK *pDispChunk;
        hr = AllocateAndRead((BYTE **)&pDispChunk, cbDispChunk, dwlDispPos);
        if(SUCCEEDED(hr))
        {

            // data in a disp chunk is a four byte identifier followed
            // by data
            if(pDispChunk->cb > sizeof(DWORD))
            {
                WCHAR wszProp[20];
                wsprintfW(wszProp, L"DISP/%010d", *(DWORD *)(pDispChunk + 1));


                unsigned int i;
                VARIANT var;
                SAFEARRAY * psa;
                SAFEARRAYBOUND rgsabound[1];
                rgsabound[0].lLbound = 0;
                rgsabound[0].cElements = pDispChunk->cb - sizeof(DWORD);

                psa = SafeArrayCreate(VT_UI1, 1, rgsabound);
                if(psa)
                {
                    BYTE *pbData;
                    EXECUTE_ASSERT(SafeArrayAccessData(psa, (void **)&pbData) == S_OK);
                    CopyMemory(pbData, (DWORD *)(pDispChunk + 1) + 1,
                               pDispChunk->cb - sizeof(DWORD));
                    EXECUTE_ASSERT(SafeArrayUnaccessData(psa) == S_OK);

                    VARIANT var;
                    var.vt = VT_UI1 | VT_ARRAY;
                    var.parray = psa;
                    hr = pPropBag->Write(wszProp, &var);

                    EXECUTE_ASSERT(SafeArrayDestroy(psa) == S_OK);

                    DbgLog((LOG_TRACE, 10,
                            TEXT("CAviMSRFilter::Save: wrote %S to prop bag, hr = %08x"),
                            wszProp, hr));
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            delete[] (BYTE *)pDispChunk;
        }

        dwlStartPos = dwlDispPos + cbDispChunk;
    }

    return hr;

}

STDMETHODIMP CAviMSRFilter::InitNew()
{
    return S_OK;
}

STDMETHODIMP CAviMSRFilter::GetClassID(CLSID *pClsID)
{
    return CBaseFilter::GetClassID(pClsID);
}




// ------------------------------------------------------------------------
// look for a block of video and count the consecutive video. doesn't
// work if there are two video streams.  easily fooled
ULONG CAviMSRFilter::CountConsecutiveVideoFrames()
{
  HRESULT hr;
  CAviMSROutPin *pPin;
  for(UINT i = 0; i < m_cStreams; i++)
  {
    pPin = (CAviMSROutPin *)m_rgpOutPin[i];
    if(pPin->m_pStrh->fccType == FCC('vids'))
      break;
  }
  if(i != m_cStreams)
  {

    IAviIndex *pIndx = pPin->m_pImplIndex;
    hr = pIndx->AdvancePointerStart();
    if(hr == S_OK)
    {

      DWORDLONG dwlLastOffset;

      IndexEntry ie;
      hr = pIndx->GetEntry(&ie);
      if(hr == S_OK)
      {

        // run of video frames
        ULONG cVideoRun = 1;

        for(UINT cTries = 0; cTries < 2; cTries++)
        {
          for(i = 1; i < 50; i++)
          {
            dwlLastOffset = ie.qwPos + ie.dwSize;

            hr = pIndx->AdvancePointerForward(0);
            if(hr != S_OK)
              goto Failed;

            hr = pIndx->GetEntry(&ie);
            if(hr != S_OK)
              goto Failed;

            if(ie.qwPos > dwlLastOffset + 2 * 1024)
            {
              cVideoRun = max(cVideoRun, i);
              break;
            }
          }
        } // cTries loop

        DbgLog((LOG_TRACE, 15, TEXT("avi: reporting interleaving at %d"),
                cVideoRun));

        return cVideoRun;
      }
    }
  }

Failed:

  DbgLog((LOG_ERROR, 3,
          TEXT("avi: couldn't CountConsecutiveVideoFrames. 4.")));
  return 4;
}

// parse the header (already in m_pAviHeader) and create streams
// based on the avi streams.
//
HRESULT CAviMSRFilter::ParseHeaderCreatePins()
{

  RIFFCHUNK * pRiff = (RIFFCHUNK *)m_pAviHeader;
  RIFFCHUNK * pLimit = (RIFFCHUNK *)(m_pAviHeader + m_cbAviHeader);
  m_pAviMainHeader = NULL;
  while (pRiff < pLimit)
  {
    // sanity check.  chunks should be smaller than the remaining list
    // or they are not valid.
    //
    if (pRiff + 1 > pLimit || RIFFNEXT(pRiff) > pLimit)
    {
      m_cStreams = 0;
      return VFW_E_INVALID_FILE_FORMAT;
    }

    // find the main AVI header and count the stream headers
    // also make a note of the location of the odml list if any.
    //
    switch (pRiff->fcc)
    {
      case FCC('avih'):
        m_pAviMainHeader = (AVIMAINHEADER *)(void *)pRiff;
      break;

      case FCC('LIST'):
      {
        RIFFLIST * pRiffList = (RIFFLIST *)pRiff;
        if (pRiffList->fccListType == FCC('strl'))
          ++m_cStreams;
        else if (pRiffList->fccListType == FCC('odml'))
          m_pOdmlList = pRiffList;
      }
      break;
    }

    pRiff = RIFFNEXT(pRiff);
  }

  // Exit if there's no avih chunk
  if (NULL == m_pAviMainHeader) {
      m_cStreams = 0;
      return VFW_E_INVALID_FILE_FORMAT;
  }

  // we try to use less memory and read smaller blocks for tightly
  // interleaved files.
  m_fIsTightInterleaved = m_cStreams == 2 &&
     m_pAviMainHeader->dwFlags & AVIF_ISINTERLEAVED;

  // now know m_cStreams; create pins
  HRESULT hr = CreatePins();
  if(FAILED(hr))
    return hr;

  // parse streams
  pRiff = (RIFFCHUNK *)m_pAviHeader;
  UINT ii = 0;
  while (pRiff < pLimit)
  {
    ASSERT(pRiff + 1 <= pLimit); // from first pass
    ASSERT(RIFFNEXT(pRiff) <= pLimit);

    // parse the stream lists and find the interesting chunks
    // in each list.
    //
    RIFFLIST * pRiffList = (RIFFLIST *)pRiff;
    if (pRiffList->fcc == FCC('LIST') &&
        pRiffList->fccListType == FCC('strl'))
    {
      ASSERT(ii < m_cStreams);

      if ( ! ((CAviMSROutPin *)m_rgpOutPin[ii])->ParseHeader(pRiffList, ii))
      {
        // bit of a hack. we want to remove this stream which we
        // couldn't parse and collapse the remaining pins one slot. we
        // do this by releasing the last output pin and reusing the
        // current pin. we look only at m_cStream pins, so no one will
        // touch the pin we just released.
        ASSERT(m_cStreams > 0);
        --m_cStreams;
        m_rgpOutPin[m_cStreams]->Release();
        m_rgpOutPin[m_cStreams] = 0;
      }
      else
      {
        ++ii;
      }

    }

    pRiff = RIFFNEXT(pRiff);
  }

  // we dont expect to have fewer initialized streams than
  // allocated streams, but since it could happen, we deal with
  // it by seting the number of streams to be the number of
  // initialized streams
  //
  ASSERT (ii == m_cStreams);
  m_cStreams = ii;

  // if there are no streams, then this is obviously a problem.
  //
  if (m_cStreams <= 0)
  {
    return VFW_E_INVALID_FILE_FORMAT;
  }

  return S_OK;
}
HRESULT CAviMSRFilter::Search (
  DWORDLONG *qwPosOut,
  FOURCC fccSearchKey,
  DWORDLONG qwPosStart,
  ULONG *cb)
{
  HRESULT hr = S_OK;
  RIFFCHUNK rc;
  BYTE *pb = 0;
  *qwPosOut = 0;

  if(m_pAsyncReader == 0)
    return E_FAIL;

  for(;;)
  {
    hr = m_pAsyncReader->SyncRead(qwPosStart, sizeof(rc), (BYTE*)&rc);
    if(hr != S_OK)
    {
      hr = VFW_E_INVALID_FILE_FORMAT;
      break;
    }

    if(rc.fcc == fccSearchKey)
    {
      *cb = rc.cb + sizeof(RIFFCHUNK);
      *qwPosOut = qwPosStart;
      return S_OK;
    }

    // handle running off the end of a preallocated file. the last
    // DWORD should be a zero.
    if(rc.fcc == 0)
    {
        hr = VFW_E_NOT_FOUND;
        break;
    }

    // AVI RIFF chunks need to be rounded up to word boundaries
    qwPosStart += sizeof(RIFFCHUNK) + ((rc.cb + 1) & 0xfffffffe);
  }

  return hr;
}

HRESULT SearchList(
  IAsyncReader *pAsyncReader,
  DWORDLONG *qwPosOut,
  FOURCC fccSearchKey,
  DWORDLONG qwPosStart,
  ULONG *cb)
{
  RIFFLIST rl;
  BYTE *pb = 0;
  HRESULT hr = S_OK;
  *qwPosOut = 0;

  if(pAsyncReader == 0)
    return E_FAIL;

  for(;;)
  {
    hr = pAsyncReader->SyncRead(qwPosStart, sizeof(rl), (BYTE*)&rl);
    if(hr != S_OK)
    {
      hr = VFW_E_INVALID_FILE_FORMAT;
      break;
    }

    if(rl.fcc == FCC('LIST') && rl.fccListType == fccSearchKey)
    {
      *cb = rl.cb + sizeof(RIFFCHUNK);
      *qwPosOut = qwPosStart;
      return S_OK;
    }

    // handle running off the end of a preallocated file. the last
    // DWORD should be a zero.
    if(rl.fcc == 0)
    {
        hr = VFW_E_NOT_FOUND;
        break;
    }

    qwPosStart += sizeof(RIFFCHUNK) + ((rl.cb + 1) & 0xfffffffe);
  }

  return hr;;
}

HRESULT CAviMSRFilter::LoadHeaderParseHeaderCreatePins()
{
  HRESULT hr;
  DbgLog((LOG_TRACE, 3, TEXT("CAviMSRFilter::LoadHeader()")));
  ASSERT(m_cStreams == 0);

  // read in the first 24 bytes of the file and check to see
  // if it is really an AVI file. if it is, determine the size
  // of the header
  //
  DWORD cbHeader = 0;

  {
    RIFFLIST * pRiffList;
    hr = AllocateAndRead((BYTE **)&pRiffList, sizeof(RIFFLIST)*2, 0);
    if(FAILED(hr))
      return hr == E_OUTOFMEMORY ? E_OUTOFMEMORY : VFW_E_INVALID_FILE_FORMAT;

    // read in the RIFF header for the avi file and for the 'hdrl' chunk.
    // by the way this code is written, we require that the 'hdrl' chunk be
    // first in the avi file, (which most readers require anyway)
    //
    if (pRiffList[0].fcc != FCC('RIFF') ||
        pRiffList[0].fccListType != FCC('AVI ') ||
        pRiffList[1].fcc != FCC('LIST') ||
        pRiffList[1].fccListType != FCC('hdrl') ||
        pRiffList[1].cb < 4)
    {
      delete[] ((LPBYTE)pRiffList);
      return VFW_E_INVALID_FILE_FORMAT;
    }

    // figure out the size of the aviheader rounded up to the next word boundary.
    // (it should really always be even, we are just being careful here)
    //
    cbHeader = pRiffList[1].cb + (pRiffList[1].cb&1) - 4;
    delete[] ((LPBYTE)pRiffList);
  }

  // now read in the entire header. if we fail to do that
  // give up and return failure.
  //
  m_cbAviHeader = cbHeader;
  ASSERT(m_pAviHeader == 0);
  hr = AllocateAndRead((BYTE **)&m_pAviHeader, cbHeader, sizeof(RIFFLIST) * 2);

  if(FAILED(hr))
    return hr == E_OUTOFMEMORY ? E_OUTOFMEMORY : VFW_E_INVALID_FILE_FORMAT;

  hr = ParseHeaderCreatePins();
  if(FAILED(hr))
  {
    delete[] m_pAviHeader;
    m_pAviHeader = 0;
  }

  return hr;
}

//
// allocate array of CAviStream

HRESULT CAviMSRFilter::CreatePins()
{
  UINT iStream;
  HRESULT hr = S_OK;

  ASSERT(m_cStreams);

  m_rgpOutPin = new CBaseMSROutPin*[m_cStreams];
  if(m_rgpOutPin == 0)
  {
    m_cStreams = 0;
    return E_OUTOFMEMORY;
  }

  for(iStream = 0; iStream < m_cStreams; iStream++)
    m_rgpOutPin[iStream] = 0;

  for(iStream = 0; iStream < m_cStreams; iStream++)
  {

    WCHAR wszPinName[20];
    wsprintfW(wszPinName, L"Stream %02x", iStream);

    m_rgpOutPin[iStream] = new CAviMSROutPin(
      this,
      this,
      iStream,
      m_pImplBuffer,
      &hr,
      wszPinName);

    if(m_rgpOutPin[iStream] == 0)
    {
      hr = E_OUTOFMEMORY;
      break;
    }

    if(FAILED(hr))
    {
      break;
    }
  }

  if(FAILED(hr))
  {
    if(m_rgpOutPin)
      for(iStream = 0; iStream < m_cStreams; iStream++)
        delete m_rgpOutPin[iStream];
    delete[] m_rgpOutPin;
    m_rgpOutPin =0;

    m_cStreams = 0;
    return hr;
  }

  for(iStream = 0; iStream < m_cStreams; iStream++)
    m_rgpOutPin[iStream]->AddRef();

  return hr;
}

HRESULT
CAviMSRFilter::CheckMediaType(const CMediaType* pmt)
{
  if(*(pmt->Type()) != MEDIATYPE_Stream)
    return E_INVALIDARG;

  if(*(pmt->Subtype()) != MEDIASUBTYPE_Avi)
    return E_INVALIDARG;

  return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
// determine the index type and load the correct handler

HRESULT CAviMSROutPin::InitializeIndex()
{
  HRESULT hr = S_OK;

  if(m_pIndx)
  {

    m_pImplIndex = new CImplStdAviIndex(
      m_id,
      m_pIndx,
      m_pStrh,
      m_pStrf,
      m_pFilter->m_pAsyncReader,
      &hr);
  }
  else
  {
    AVIOLDINDEX *pIdx1;
    hr = ((CAviMSRFilter *)m_pFilter)->GetIdx1(&pIdx1);
    if(FAILED(hr))
      return hr;

    DWORDLONG qwMoviOffset;
    hr = ((CAviMSRFilter *)m_pFilter)->GetMoviOffset(&qwMoviOffset);
    if(FAILED(hr))
      return hr;

    m_pImplIndex = new CImplOldAviIndex(
      m_id,
      pIdx1,
      qwMoviOffset,
      m_pStrh,
      m_pStrf,
      &hr);
  }

  if(m_pImplIndex == 0)
    hr = E_OUTOFMEMORY;

  if(FAILED(hr))
  {
    delete m_pImplIndex;
    m_pImplIndex = 0;
    return hr;
  }

  return S_OK;
}

// set subtype and format type and block. deal with
// WAVEFORMATEXTENSIBLE and WAVEFORMATEX.

HRESULT SetAudioSubtypeAndFormat(CMediaType *pmt, BYTE *pbwfx, ULONG cbwfx)
{
    HRESULT hr = S_OK;
    bool fCustomSubtype = false;

    if (cbwfx < sizeof(WAVEFORMATEX))
    {
        // if the stream format in the avi file is smaller than a
        // waveformatex we need to deal with this by copying the
        // waveformat into a temporary waveformatex structure, then
        // using that to fill in the mediatype format
        //
        WAVEFORMATEX wfx;
        ZeroMemory(&wfx, sizeof(wfx));
        CopyMemory(&wfx, pbwfx, cbwfx);
        if(!pmt->SetFormat ((BYTE *)&wfx, sizeof(wfx))) {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        WAVEFORMATEX *pwfx = (WAVEFORMATEX *)(pbwfx);

        if(pwfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
           cbwfx >= sizeof(WAVEFORMATEXTENSIBLE))
        {
            WAVEFORMATEXTENSIBLE *pwfxe = (WAVEFORMATEXTENSIBLE *)(pbwfx);

            // we've chosen not to support any mapping of an extensible
            // format back to the old format.

            if(pmt->SetFormat (pbwfx, cbwfx))
            {
                fCustomSubtype = true;
                pmt->SetSubtype(&pwfxe->SubFormat);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            // format in the avifile is >= waveformatex, so just
            // copy it into the mediaformat buffer
            //
            if(!pmt->SetFormat (pbwfx, cbwfx)) {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        // some things refuse PCM with non-zero cbSize. zero cbSize
        // for PCM until this components are changed.
        //
        WAVEFORMATEX *pwfxNew = (WAVEFORMATEX *)(pmt->pbFormat);
        if(pwfxNew->wFormatTag == WAVE_FORMAT_PCM)
        {
            if(pwfxNew->cbSize != 0) {
                DbgLog((LOG_ERROR, 0, TEXT(
                    "SetAudioSubtypeAndFormat: pcm w/ non-zero cbSize")));
            }
            pwfxNew->cbSize = 0;
        }

        pmt->formattype = FORMAT_WaveFormatEx;

        if(!fCustomSubtype) {

            pmt->SetSubtype(
                &FOURCCMap(((WAVEFORMATEX *)pmt->pbFormat)->wFormatTag));
        }
    }

    return hr;
}

HRESULT CAviMSROutPin::BuildMT()
{
  // ParseHeader guarantees these
  ASSERT(m_pStrh && m_pStrf);

  FOURCCMap fccMapSubtype = m_pStrh->fccHandler;
  FOURCCMap fccMapType = m_pStrh->fccType;
  if(m_pStrh->fccType != FCC('al21'))
  {
      m_mtFirstSample.SetType(&fccMapType);
      // subtype corrected below
      m_mtFirstSample.SetSubtype(&fccMapSubtype);
  }
  else
  {
      m_mtFirstSample.SetType(&MEDIATYPE_AUXLine21Data);
      m_mtFirstSample.SetSubtype(&MEDIASUBTYPE_Line21_BytePair);
  }

  StreamInfo si;
  HRESULT hr = m_pImplIndex->GetInfo(&si);
  if(FAILED(hr))
    return hr;

  if(si.dwLength != m_pStrh->dwLength)
    m_pStrh->dwLength = si.dwLength;

  m_mtFirstSample.bTemporalCompression = si.bTemporalCompression;

  if(m_pStrh->cb >= CB_STRH_NORMAL && m_pStrh->dwSampleSize)
  {
    m_mtFirstSample.SetSampleSize (m_pStrh->dwSampleSize);
  }
  else
  {
    m_mtFirstSample.SetVariableSize ();
  }

  if((m_pStrh->fccType == FCC('iavs')) ||
     (m_pStrh->fccType == FCC('vids') &&
      (m_pStrh->fccHandler == FCC('dvsd') ||
       m_pStrh->fccHandler == FCC('dvhd') ||
       m_pStrh->fccHandler == FCC('dvsl'))))
  {
    ((CAviMSRFilter *)m_pFilter)->m_fIsDV = true;
  }

  if((m_pStrh->fccType == FCC('iavs')) &&
     (m_pStrh->fccHandler == FCC('dvsd') ||
      m_pStrh->fccHandler == FCC('dvhd') ||
      m_pStrh->fccHandler == FCC('dvsl')))
  {
    m_mtFirstSample.SetFormat ((BYTE *)(m_pStrf+1), m_pStrf->cb);
    m_mtFirstSample.formattype = FORMAT_DvInfo;
  }
  else if (m_pStrh->fccType == streamtypeAUDIO)
  {
      HRESULT hrTmp = SetAudioSubtypeAndFormat(
          &m_mtFirstSample, (BYTE  *)(m_pStrf + 1), m_pStrf->cb);
      if(FAILED(hrTmp)) {
          return hrTmp;
      }
  }
  else if (m_pStrh->fccType == FCC('vids'))
  {
    // the format info in an AVI is a subset of the videoinfo stuff so
    // we need to build up a videoinfo from stream header & stream
    // format chunks.
    //
    if (!ValidateBitmapInfoHeader((const BITMAPINFOHEADER *)GetStrf(),
                                  m_pStrf->cb)) {
        return E_INVALIDARG;
    }
    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)new BYTE[SIZE_PREHEADER+ m_pStrf->cb];
    if(pvi == 0)
      return E_OUTOFMEMORY;
    VIDEOINFOHEADER &vi = *pvi;

    ZeroMemory(pvi, SIZE_PREHEADER);
    CopyMemory(&vi.bmiHeader, GetStrf(), m_pStrf->cb);

    // probably a badly authored file if this isn't true
    if(m_pStrf->cb >= sizeof(BITMAPINFOHEADER))
    {
      // fixup for avi files broken in this way (nike301.avi)
      if((m_pStrh->fccHandler == FCC('RLE ') || m_pStrh->fccHandler == FCC('MRLE')) &&
         vi.bmiHeader.biCompression == BI_RGB &&
         vi.bmiHeader.biBitCount == 8)
      {
        vi.bmiHeader.biCompression = BI_RLE8;
        // o/w leave it as is. do the same fix for rle4?
      }

      // sometimes the biSizeImage field is set incorrectly.
      // work out what it should be - only OK for uncompressed images

      if (vi.bmiHeader.biCompression == BI_RGB ||
          vi.bmiHeader.biCompression == BI_BITFIELDS)
      {
        // the image is not compressed
        DWORD dwImageSize = vi.bmiHeader.biHeight * DIBWIDTHBYTES(vi.bmiHeader);

        // assume that biSizeImage is correct, or if not that it
        // might be OK to get biSizeImage from dwSuggestedBufferSize
        // This acts as a check that we only alter values when
        // there is a real need to do so, and that the new value
        // we insert is reasonable.
        ASSERT((dwImageSize == vi.bmiHeader.biSizeImage)  || (dwImageSize == GetMaxSampleSize()));
        if (dwImageSize != vi.bmiHeader.biSizeImage) {
          DbgLog((LOG_TRACE, 1,
                  "Set biSizeImage... to %d (was %d)  Width %d  Height %d (%d)",
                  dwImageSize, vi.bmiHeader.biSizeImage,
                  vi.bmiHeader.biWidth, vi.bmiHeader.biHeight,
                  vi.bmiHeader.biWidth * vi.bmiHeader.biHeight));
          vi.bmiHeader.biSizeImage = dwImageSize;
        }
      } else {
        DbgLog((LOG_TRACE, 4, "We have a compressed image..."));
      }

      if(m_pStrh->fccHandler == FCC('dvsd') ||
         m_pStrh->fccHandler == FCC('dvhd') ||
         m_pStrh->fccHandler == FCC('dvsl'))
      {
          FOURCCMap fcc(m_pStrh->fccHandler);
          m_mtFirstSample.SetSubtype(&fcc);
      }
      else
      {
          GUID subtype = GetBitmapSubtype(&vi.bmiHeader);
          m_mtFirstSample.SetSubtype(&subtype);
      }
    }

    SetRect(&vi.rcSource, 0, 0, 0, 0);
    SetRectEmpty(&vi.rcTarget);

    vi.dwBitRate = 0;
    vi.dwBitErrorRate = 0;

    // convert scale/rate (sec/tick) to avg 100ns ticks per frame
    vi.AvgTimePerFrame = ((LONGLONG)m_pStrh->dwScale * UNITS) /
      m_pStrh->dwRate;

    // put the format into the mediatype
    //
    m_mtFirstSample.SetFormat((BYTE *)&vi, FIELD_OFFSET(VIDEOINFOHEADER,bmiHeader) +
                          m_pStrf->cb);
    m_mtFirstSample.formattype = FORMAT_VideoInfo;

    delete[] pvi;
  }
  else
  {
    if(m_pStrf->cb != 0)
    {
      m_mtFirstSample.SetFormat ((BYTE *)(m_pStrf+1), m_pStrf->cb);
      // format type same as media type
      m_mtFirstSample.formattype = FOURCCMap(m_pStrh->fccType);
    }
    else
    {
      // probably not neccessary
      m_mtFirstSample.ResetFormatBuffer();
    }
  }

  return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

CAviMSRWorker::CAviMSRWorker(
  UINT stream,
  IMultiStreamReader *pReader,
  IAviIndex *pImplIndex) :
    CBaseMSRWorker(stream, pReader),
    m_pImplIndex(pImplIndex),
    m_fFixMPEGAudioTimeStamps(false)
{
  m_cbAudioChunkOffset = 0xffffffff;

#ifdef PERF
  char foo[1024];

  lstrcpy(foo, "pin00 avimsr index");
  foo[4] += m_id % 10;
  foo[3] += m_id / 10;

  m_perfidIndex = MSR_REGISTER(foo);
#endif
}

HRESULT CAviMSRWorker::PushLoopInit(
  LONGLONG *pllCurrentOut,
  ImsValues *pImsValues)
{
  m_IrrState = IRR_NONE;

  HRESULT hr;

  hr = m_pImplIndex->Reset();
  if(FAILED(hr))
    return hr;

  m_pStrh = ((CAviMSROutPin *)m_pPin)->GetStrh();

  m_fDeliverPaletteChange = false;

  // first thing delivered when thread is restarted is a discontinuity.
  m_fDeliverDiscontinuity = true;

  m_fFixMPEGAudioTimeStamps = false;

  if(m_pStrh->fccType == streamtypeVIDEO)
  {
    hr = m_pImplIndex->SetPointer(pImsValues->llTickStart);
    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 5, TEXT("CAviMSRWorker::PLI: SetPointer %08x"), hr));
      return hr;
    }

    // locate right palette chunk
    if(m_pStrh->dwFlags & AVISF_VIDEO_PALCHANGES)
    {
      hr = m_pImplIndex->AdvancePointerBackwardPaletteChange();
      if(FAILED(hr))
      {
        // !!! IAviIndex should define proper errors
        if(hr != HRESULT_FROM_WIN32(ERROR_NEGATIVE_SEEK))
        {
          DbgLog((LOG_ERROR, 5, TEXT("CAviMSRWorker::APBPC: %08x"), hr));
          return hr;
        }


        m_fDeliverPaletteChange = true;
        hr = m_pPin->GetMediaType(0, &m_mtNextSample);
        ASSERT(SUCCEEDED(hr));

      }
      else
      {
        // need to read data for the palette. DoRunLoop insists on
        // starting with cPendingReads = 0, so use a synchronous read
        IndexEntry iePal;
        hr = m_pImplIndex->GetEntry(&iePal);
        ASSERT(SUCCEEDED(hr));
        ASSERT(iePal.bPalChange);

        if(iePal.dwSize < sizeof(LOGPALETTE))
        {
          DbgLog((LOG_ERROR, 1,
                  TEXT("CAviMSRWorker::PushLoopInit: bad pal change")));
          return VFW_E_INVALID_FILE_FORMAT;
        }

        // could do this in the memory we allocated in the media type
        // and transform in place.
        BYTE *pb = new BYTE[iePal.dwSize];
        if(pb == 0)
          return E_OUTOFMEMORY;
        hr = m_pReader->SynchronousRead(pb, iePal.qwPos, iePal.dwSize);
        if(FAILED(hr))
        {
          delete[] pb;
          return hr;
        }
        hr = HandlePaletteChange(pb, iePal.dwSize);
        delete[] pb;
        if(FAILED(hr))
          return hr;
      } // AdvancePointerBackwardPaletteChange succeeded
    } // palette changes in file?
  } // video?

  // set the index's notion of current time.
  hr = m_pImplIndex->SetPointer(pImsValues->llTickStart);
  if(FAILED(hr))
  {
    DbgLog((LOG_ERROR, 5, TEXT("CAviMSRWorker::PLI: SetPointer %08x"), hr));

    // obsoleted by code to not trust dwLength in header for old files
    // // supress this error for corrupt old format files. happens
    // // because the index has zero size index entries by mistake
    // if(m_pStrh->fccType == streamtypeAUDIO &&
    //    hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF) &&
    //    ((CAviMSROutPin *)m_pPin)->m_pIndx == 0)
    // {
    //   DbgLog((LOG_ERROR, 5, TEXT("CAviMSRWorker: supressing error")));
    //   return VFW_S_NO_MORE_ITEMS;
    // }

    return hr;
  }

  *pllCurrentOut = pImsValues->llTickStart; // updated for video

  if(m_pStrh->fccType == streamtypeAUDIO)
  {
    // handle seeking into the middle of an audio chunk by computing
    // byte offset of first block

    IndexEntry indexEntry;
    hr = m_pImplIndex->GetEntry(&indexEntry);
    ASSERT(SUCCEEDED(hr));
    DbgLog(( LOG_TRACE, 5,
             TEXT("PushLoopInit: current entry %d %d %d"),
             (ULONG)indexEntry.llStart,
             (ULONG)pImsValues->llTickStart,
             (ULONG)indexEntry.llEnd
             ));

    CopyMemory(&m_wfx, ((CAviMSROutPin *)m_pPin)->GetStrf(), sizeof(PCMWAVEFORMAT));
    m_wfx.cbSize = 0;
    ULONG nBlockAlign = m_wfx.nBlockAlign;

    ULONG cbSkip;
    if(pImsValues->llTickStart >= indexEntry.llStart)
      cbSkip = (ULONG)(pImsValues->llTickStart - indexEntry.llStart) * nBlockAlign;
    else
      cbSkip = 0;

    if (m_wfx.wFormatTag == WAVE_FORMAT_MPEG ||
        m_wfx.wFormatTag == WAVE_FORMAT_MPEGLAYER3) {
        m_fFixMPEGAudioTimeStamps = true;
    }

    DbgLog(( LOG_TRACE, 5,
             TEXT("PushLoopInit: audio skip %d bytes"),
             cbSkip));

    m_cbAudioChunkOffset = cbSkip;
    *pllCurrentOut = max(pImsValues->llTickStart, indexEntry.llStart);
  }
  else if(m_pStrh->fccType != streamtypeAUDIO)
  {
    // go back to a key frame
    hr = m_pImplIndex->AdvancePointerBackwardKeyFrame();
    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 5, TEXT("CAviMSRWorker::PLI: APBKF %08x"), hr));
      return VFW_E_INVALID_FILE_FORMAT;
    }

    IndexEntry indexEntry;

    hr = m_pImplIndex->GetEntry(&indexEntry);
    // cannot fail if the SetPointer or AdvancePointer succeeded
    ASSERT(SUCCEEDED(hr));

    // this is valid even if it's a palette change
    *pllCurrentOut = indexEntry.llStart;
  } // video ?

  return S_OK;
}

HRESULT CAviMSRWorker::TryQueueSample(
  LONGLONG &rllCurrent,         // current time updated
  BOOL &rfQueuedSample,         // [out] queued sample?
  ImsValues *pImsValues
  )
{
  HRESULT hr;
  rfQueuedSample = FALSE;
  CAviMSROutPin *pPin = (CAviMSROutPin *)m_pPin;

  if(m_IrrState == IRR_REQUESTED)
  {
    hr = QueueIndexRead(&m_Irr);
    if(hr == S_OK)
    {
      rfQueuedSample = TRUE;
      m_IrrState = IRR_QUEUED;
      return S_OK;
    }
    else
    {
      ASSERT(FAILED(hr) || hr == S_FALSE);
      return hr;
    }
  }
  else if(m_IrrState == IRR_QUEUED)
  {
    return S_FALSE;
  }

  BOOL fFinishedCurrentEntry = TRUE;

  // sample passed into QueueRead().
  CRecSample *pSampleOut = 0;

  IndexEntry currentEntry;
  hr = m_pImplIndex->GetEntry(&currentEntry);
  if(FAILED(hr)) {
    DbgBreak("avimsr: internal error with index.");
    return hr;
  }

  if(rllCurrent > pImsValues->llTickStop)
  {
    DbgLog((LOG_TRACE,5,TEXT("CAviMSRWorker::TryQSample: tCurrent > tStop")));
    return VFW_S_NO_MORE_ITEMS;
  }

// for video (and other non-audio) streams we may be able to deliver
// partial samples from the last frame, but for audio we can't handle
// partial samples. not special casing this means the code below will
// try to issue a zero byte read for audio.
//
//    else if (m_pStrh->fccType == streamtypeAUDIO &&
//             rllCurrent == pImsValues->llTickStop)
//    {
//      DbgLog((LOG_TRACE,5,TEXT("CAviMSRWorker::TryQSample: tCurrent == tStop, audio")));
//      return VFW_S_NO_MORE_ITEMS;
//    }

  // this number may be changed if we are not delivering an entire
  // audio chunk
  LONGLONG llEndDeliver = currentEntry.llEnd;

  DWORD dwSizeRead = 0;
  if(currentEntry.dwSize != 0)
  {
    // get an empty sample w/ no allocated space. ok if this blocks
    // because we configured it with more samples than there are
    // SampleReqs for this stream in the buffer. that means that if
    // it blocks it is because down stream filters have refcounts on
    // samples
    hr = m_pPin->GetDeliveryBufferInternal(&pSampleOut, 0, 0, 0);
    if(FAILED(hr))
    {
      DbgLog((LOG_TRACE, 5, TEXT("CAviMSRWorker::PushLoop: getbuffer failed")));
      return hr;
    }

    ASSERT(pSampleOut != 0);

    // set in our GetBuffer.
    ASSERT(pSampleOut->GetUser() == 0);

    DWORDLONG qwPosRead = currentEntry.qwPos;
    dwSizeRead = currentEntry.dwSize;

    if(m_pStrh->fccType == streamtypeVIDEO)
    {
      if(currentEntry.bPalChange)
      {
        DbgLog((LOG_TRACE, 5, TEXT("CAviMSRWorker::TryQueueSample: palette")));

        // reject palette changes that are too small to be valid
        if(dwSizeRead < sizeof(LOGPALETTE))
        {
          pSampleOut->Release();
          DbgLog((LOG_ERROR, 1,
                  TEXT("CAviMSRWorker::TryQueueSample: bad pal change")));
          return VFW_E_INVALID_FILE_FORMAT;
        }

        // many sample attributes unset. !!! if going backwards, want to
        // pick up the last palette change

        // indicate palette change.
        pSampleOut->SetUser(DATA_PALETTE);

        DbgLog((
          LOG_TRACE, 5,
          TEXT("CAviMSRWorker::TryQSample: queued pc: size=%5d, ms %08x"),
          dwSizeRead,
          (ULONG)qwPosRead ));

        // do not change rtCurrent

      } // palette change?
    } // video?
    else if(m_pStrh->fccType == streamtypeAUDIO)
    {
      // even though m_cbAudioChunkOffset may not be zero, the
      // rtCurrent time is right and is what we deliver.
      qwPosRead += m_cbAudioChunkOffset;
      dwSizeRead -= m_cbAudioChunkOffset;

      // may have to read a partial RIFF chunk if the end of the audio
      // selection is in the middle of the RIFF chunk.
      ASSERT(m_cbAudioChunkOffset % m_wfx.nBlockAlign == 0);
      if(llEndDeliver > pImsValues->llTickStop)
      {
          ULONG cTicksToTrim = (ULONG)(llEndDeliver - pImsValues->llTickStop);
          DbgLog((LOG_TRACE, 5, TEXT("avimsr: trimming audio: %d ticks"),
                  cTicksToTrim));
          dwSizeRead -= cTicksToTrim * m_wfx.nBlockAlign;

          // there are some cases where playing the audio sample where
          // the end time is on a riff chunk boundary or playing past
          // the end of the stream produces this assert
          if(dwSizeRead == 0) {
              DbgLog((LOG_ERROR, 0, TEXT("avi TryQueueSample: 0 byte read")));
          }
      }

      ULONG cbMaxAudio = pPin->m_cbMaxAudio;
      // oversized audio chunk?
      if(dwSizeRead > cbMaxAudio)
      {
        // adjust read
        ULONG nBlockAlign = m_wfx.nBlockAlign;
        dwSizeRead = cbMaxAudio;
        if(dwSizeRead % nBlockAlign != 0)
          dwSizeRead -= dwSizeRead % nBlockAlign;

        // adjust time stamps, end time
        llEndDeliver = rllCurrent + dwSizeRead / nBlockAlign;
        fFinishedCurrentEntry = FALSE;
      }
    } // audio?

    pSampleOut->SetPreroll(currentEntry.llEnd <= pImsValues->llTickStart);
    pSampleOut->SetSyncPoint(currentEntry.bKey);

    // first thing we send is discontinuous from the last thing they
    // receive.
    //
    // now we just look at the m_fDeliverDiscontinuity bit
    //
    ASSERT(rllCurrent != m_llPushFirst || m_fDeliverDiscontinuity);

    ASSERT(pSampleOut->IsDiscontinuity() != S_OK);
    if(m_fDeliverDiscontinuity) {
        pSampleOut->SetDiscontinuity(true);
    }

    hr = pSampleOut->SetActualDataLength(currentEntry.dwSize);
    ASSERT(SUCCEEDED(hr));      // !!!

    //
    // compute sample times and media times.
    //
    REFERENCE_TIME rtstStart, rtstEnd;

    // not using IMediaSelection or using samples or frames.
    if(m_Format != FORMAT_TIME)
    {
      LONGLONG llmtStart = rllCurrent, llmtEnd = llEndDeliver;

      // report media time as ticks
      llmtStart -= pImsValues->llTickStart;
      llmtEnd -= pImsValues->llTickStart;

      // report ref time as exact multiple of ticks
      rtstStart = m_pPin->ConvertInternalToRT(llmtStart);
      rtstEnd = m_pPin->ConvertInternalToRT(llmtEnd);
    }
    else
    {
      ASSERT(m_Format == FORMAT_TIME);

      rtstStart = m_pPin->ConvertInternalToRT(rllCurrent);
      rtstEnd = m_pPin->ConvertInternalToRT(llEndDeliver);

      // DbgLog((LOG_TRACE, 1, TEXT("unadjusted times: %d-%d"),
      //        (LONG)rtstStart, (LONG)rtstEnd));

      // use IMediaSelection value to handle playing less than one frame
      ASSERT(rtstStart <= pImsValues->llImsStop);
      rtstStart -= pImsValues->llImsStart;
      rtstEnd = min(rtstEnd, pImsValues->llImsStop) - pImsValues->llImsStart;
    }

    LONGLONG llmtStartAdjusted = rllCurrent;
    LONGLONG llmtEndAdjusted = llEndDeliver;
    pSampleOut->SetMediaTime(&llmtStartAdjusted, &llmtEndAdjusted);

    // adjust both times by Rate
    if(pImsValues->dRate != 0 && pImsValues->dRate != 1)
    {
      // scale up and divide?
      rtstStart = (REFERENCE_TIME)((double)rtstStart / pImsValues->dRate);
      rtstEnd = (REFERENCE_TIME)((double)rtstEnd / pImsValues->dRate);
    }

    pSampleOut->SetTime(&rtstStart, &rtstEnd);
    pSampleOut->SetMediaType(0);

    DbgLog((
      LOG_TRACE, 5,
      TEXT("CAviMSRWorker::queued cb=%5d, %07d-%07d%c ms %08x mt=%08d-%08d"),
      dwSizeRead,
      (ULONG)(rtstStart / (UNITS / MILLISECONDS)),
      (ULONG)(rtstEnd / (UNITS / MILLISECONDS)),
      currentEntry.llEnd <= pImsValues->llTickStart ? 'p' : ' ',
      (ULONG)qwPosRead,
      (ULONG) rllCurrent, (ULONG)llEndDeliver ));


    hr = m_pReader->QueueReadSample(
      qwPosRead,
      dwSizeRead,
      pSampleOut,
      m_id);

    pSampleOut->Release();
    pSampleOut = 0;

    if(hr == E_OUTOFMEMORY)
    {
      DbgLog((LOG_TRACE, 5,
              TEXT("CAviMSRWorker::TryQSample: q full (normal)") ));
      return S_FALSE;
    }

    if(FAILED(hr))
    {
      DbgLog((LOG_TRACE, 5, TEXT("CAviMSRWorker::TryQSample: QRS failed") ));

      if(hr == VFW_E_BUFFER_OVERFLOW)
        hr = VFW_E_INVALID_FILE_FORMAT;

      return hr;
    }

    ASSERT(SUCCEEDED(hr));
    rfQueuedSample = TRUE;
    m_fDeliverDiscontinuity = false; // reset after sample queued successfully

  } // zero byte?
  else
  {
    // zero byte sample (for dropped frame). do nothing.
    rfQueuedSample = FALSE;

    // hack: make dv splitter send discontinuity with dropped audio so
    // that the audio renderer plays silence
    if(m_pStrh->fccType == FCC('iavs')) {
        m_fDeliverDiscontinuity = true; // set discontinuity on next real sample
    }
  }

  rllCurrent = llEndDeliver;

  // reached the end?
  if(fFinishedCurrentEntry)
  {

    m_cbAudioChunkOffset = 0;
    hr = m_pImplIndex->AdvancePointerForward(&m_Irr);
    if(hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
    {
      if(rllCurrent < m_pStrh->dwLength + m_pStrh->dwStart)
      {
        DbgLog((LOG_ERROR, 1,
                TEXT("CAviMSRWorker::TryQSample: index end -- invalid file")));
        return VFW_E_INVALID_FILE_FORMAT;
      }
      else
      {
        return VFW_S_NO_MORE_ITEMS;
      }
    }
    else if(FAILED(hr))
    {
      DbgLog((LOG_ERROR,2,
              TEXT("CAviMSRWorker::TryQSample: index error %08x"), hr));
      return hr;
    }
    else if(hr == S_FALSE)
    {
      ASSERT(m_IrrState == IRR_NONE);
      m_IrrState = IRR_REQUESTED;
    }
  }
  else
  {
    ASSERT(m_pStrh->fccType == streamtypeAUDIO);
    ASSERT(dwSizeRead != 0);
    m_cbAudioChunkOffset += dwSizeRead;
  }

  return S_OK;
}

HRESULT CAviMSRWorker::QueueIndexRead(IxReadReq *pIrr)
{
  CRecSample *pIxSample;
  HRESULT hr = m_pPin->GetDeliveryBufferInternal(&pIxSample, 0, 0, 0);
  if(FAILED(hr))
    return hr;

  ASSERT(pIxSample != 0);
  ASSERT(pIxSample->GetUser() == 0); // set in our GetBuffer.
  pIxSample->SetUser(DATA_INDEX);
  hr = pIxSample->SetActualDataLength(pIrr->cbData);
  if(FAILED(hr))
    goto Bail;

  // leave other fields empty

  DbgLog((LOG_TRACE, 5, TEXT("CAviMSRWorker: queueing index read")));

  DbgLog((
      LOG_TRACE, 5,
      TEXT("CAviMSRWorker::queued index cb=%5d@%08x, pSample=%08x"),
      pIrr->cbData,
      (ULONG)pIrr->fileOffset,
      pIxSample));


  hr = m_pReader->QueueReadSample(
    pIrr->fileOffset,
    pIrr->cbData,
    pIxSample,
    m_id,
    true);                      // out of order

  if(SUCCEEDED(hr))
    hr = S_OK;
  else if(hr == E_OUTOFMEMORY)
    hr = S_FALSE;
  else if(hr == VFW_E_BUFFER_OVERFLOW)
    hr = VFW_E_INVALID_FILE_FORMAT;

  if(hr == S_OK)
      MSR_START(m_perfidIndex);
Bail:
  pIxSample->Release();
  return hr;
}

HRESULT CAviMSRWorker::HandleData(IMediaSample *pSample, DWORD dwUser)
{
  BYTE *pb;
  HRESULT hr = pSample->GetPointer(&pb);
  ASSERT(SUCCEEDED(hr));
  LONG cbLength = pSample->GetActualDataLength();

  if(dwUser == DATA_PALETTE)
    return HandlePaletteChange(pb, cbLength);
  else if(dwUser == DATA_INDEX)
    return HandleNewIndex(pb, cbLength);

  DbgBreak("blah");
  return E_UNEXPECTED;
}

// palette data came in; prepare a new media type
HRESULT CAviMSRWorker::HandlePaletteChange(BYTE *pbChunk, ULONG cbChunk)
{
  m_mtNextSample = m_pPin->CurrentMediaType();
  VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) m_mtNextSample.Format();

  // actual structure of palette
  struct AviPaletteInternal
  {
    BYTE bFirstEntry;           // first entry to change
    BYTE bNumEntries;           // # entries to change, 0 means 256
    WORD wFlags;                // mostly to preserve alignment
    PALETTEENTRY peNew[];       // new colors
  };
  AviPaletteInternal *pAp = (AviPaletteInternal *)pbChunk;

  if((pvi->bmiHeader.biClrUsed <= 0) || (pvi->bmiHeader.biBitCount != 8))
  {
    DbgLog(( LOG_ERROR, 1, TEXT("HandlePaletteChange: bad palette change")));
    return VFW_E_INVALID_FILE_FORMAT;
  }

  ULONG cPalEntries = pAp->bNumEntries == 0 ? 256 : pAp->bNumEntries;

  // make sure the palette chunk is not short
  if(cPalEntries * sizeof(PALETTEENTRY) > cbChunk - 2 * sizeof(WORD))
  {
    DbgLog((LOG_ERROR, 5, TEXT("bad palette")));
    return VFW_E_INVALID_FILE_FORMAT;
  }

  // make sure there's enough room in the palette. we seem to always
  // allocate 256, so this shouldn't be a problem.
  if(cPalEntries + pAp->bFirstEntry > pvi->bmiHeader.biClrUsed)
  {
    DbgBreak("avimsr: internal palette error? bailing.");
    DbgLog((LOG_ERROR, 5, TEXT("too many new colours")));
    return VFW_E_INVALID_FILE_FORMAT;
  }

  for (UINT i = 0; i < cPalEntries; i++)
  {
    RGBQUAD *pQuad = &(COLORS(pvi)[i + pAp->bFirstEntry]);
    pQuad->rgbRed   = pAp->peNew[i].peRed;
    pQuad->rgbGreen = pAp->peNew[i].peGreen;
    pQuad->rgbBlue  = pAp->peNew[i].peBlue;
    pQuad->rgbReserved = 0;
  }

  m_fDeliverPaletteChange = true;
  return S_OK;
}

// new index came in.
HRESULT CAviMSRWorker::HandleNewIndex(BYTE *pb, ULONG cb)
{
  DbgLog((LOG_TRACE, 10, TEXT("avimsr %d: new index came in."), m_id ));


  m_IrrState = IRR_NONE;
  MSR_STOP(m_perfidIndex);
  return m_pImplIndex->IncomingIndex(pb, cb);
}

HRESULT CAviMSRWorker::AboutToDeliver(IMediaSample *pSample)
{
  if(m_fDeliverPaletteChange)
  {
    m_fDeliverPaletteChange = false;
    HRESULT hr = pSample->SetMediaType(&m_mtNextSample);

    if (FAILED(hr))
        return hr;
  } else if (m_fFixMPEGAudioTimeStamps) {
    if (!FixMPEGAudioTimeStamps(pSample, m_cSamples == 0, &m_wfx)) {
        //  Don't use this one
        return S_FALSE;
    }
  }
  return CBaseMSRWorker::AboutToDeliver(pSample);
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------


CAviMSROutPin::CAviMSROutPin(
  CBaseFilter *pOwningFilter,
  CBaseMSRFilter *pFilter,
  UINT iStream,
  IMultiStreamReader *&rpImplBuffer,
  HRESULT *phr,
  LPCWSTR pName) :
    CBaseMSROutPin(
      pOwningFilter,
      pFilter,
      iStream,
      rpImplBuffer,
      phr,
      pName)
  ,m_pStrh (0)
  ,m_pStrf (0)
  ,m_pIndx (0)
  ,m_pImplIndex (0)
  ,m_cbMaxAudio (0)
  ,m_pStrn(0)
{
}

CAviMSROutPin::~CAviMSROutPin()
{
  delete m_pImplIndex;
}

STDMETHODIMP CAviMSROutPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
  if(riid == IID_IPropertyBag)
  {
    return GetInterface((IPropertyBag *)this, ppv);
  }
  return CBaseMSROutPin::NonDelegatingQueryInterface(riid, ppv);
}

REFERENCE_TIME CAviMSROutPin::GetRefTime(ULONG tick)
{
  ASSERT(m_pStrh->dwRate != 0);  // ParseHeader guarantees this
  LONGLONG rt = (LONGLONG)tick * m_pStrh->dwScale * UNITS / m_pStrh->dwRate;
  return rt;
}

ULONG CAviMSROutPin::GetMaxSampleSize()
{
  ULONG cb;

  // note could return the largest index size for new format index.
  HRESULT hr = m_pImplIndex->GetLargestSampleSize(&cb);
  if(FAILED(hr))
    return 0;

  // cannot trust dwSuggestedBufferSize in old format avi files. file
  // has new format index?
  if(m_pIndx != 0)
    return max(cb, m_pStrh->dwSuggestedBufferSize);

  if(m_pStrh->fccType == streamtypeAUDIO && cb > m_cbMaxAudio)
  {
    ASSERT(m_cbMaxAudio != 0);
    cb = m_cbMaxAudio;
  }

  return cb;
}

inline BYTE * CAviMSROutPin::GetStrf()
{
  ASSERT(sizeof(*m_pStrf) == sizeof(RIFFCHUNK));
  return (BYTE *)(m_pStrf + 1);
}

inline AVISTREAMHEADER *CAviMSROutPin::GetStrh()
{
  return m_pStrh;
}

// ------------------------------------------------------------------------

HRESULT CAviMSROutPin::GetDuration(LONGLONG *pllDur)
{
  *pllDur = ConvertFromTick(
    m_pStrh->dwLength + m_pStrh->dwStart,
    &m_guidFormat);

  return S_OK;
}

HRESULT CAviMSROutPin::GetAvailable(
  LONGLONG * pEarliest,
  LONGLONG * pLatest)
{
  HRESULT hr = S_OK;
  if(pEarliest)
    *pEarliest = 0;
  if(pLatest)
  {
    // ask the source file reader how much of the file is available
    LONGLONG llLength, llAvail;
    m_pFilter->m_pAsyncReader->Length(&llLength, &llAvail);

    // entries in index may not match length in header (or index), so
    // report the full length in this case
    if(llLength == llAvail)
    {
      *pLatest = GetStreamLength() + GetStreamStart();
    }
    else
    {
      hr = m_pImplIndex->MapByteToSampleApprox(pLatest, llAvail, llLength);

      // convert absolute sample number to tick
      if(m_pStrh->fccType == streamtypeVIDEO &&
         *pLatest >= m_pStrh->dwInitialFrames)
        *pLatest -= m_pStrh->dwInitialFrames;
    }


    // this has already been done for us in aviindex.cpp @ 614
    // *pLatest += GetStreamStart();

    if(m_guidFormat == TIME_FORMAT_MEDIA_TIME)
      *pLatest = ConvertInternalToRT(*pLatest);
  }
  return hr;
}

HRESULT CAviMSROutPin::RecordStartAndStop(
  LONGLONG *pCurrent, LONGLONG *pStop, REFTIME *pTime,
  const GUID *const pGuidFormat
  )
{
  if(pCurrent)
    m_llCvtImsStart = ConvertToTick(*pCurrent, pGuidFormat);

  if(pStop)
    m_llCvtImsStop = ConvertToTick(*pStop, pGuidFormat);

  if(pTime)
  {
    ASSERT(pCurrent);

    if(*pGuidFormat == TIME_FORMAT_MEDIA_TIME)
      *pTime = (double)*pCurrent / UNITS;
    else
      *pTime = ((double)ConvertFromTick(m_llCvtImsStart, &TIME_FORMAT_MEDIA_TIME)) / UNITS;
  }

  DbgLog((LOG_TRACE, 5, TEXT("CAviMSROutPin::RecordStartAndStop: %d-%d (%d ms)"),
          (long)m_llCvtImsStart,
          (long)m_llCvtImsStop,
          pTime ? (ULONG)(*pTime) : 0
          ));


  return S_OK;
}

HRESULT CAviMSROutPin::IsFormatSupported(const GUID *const pFormat)
{
  if(*pFormat == TIME_FORMAT_MEDIA_TIME)
  {
    return S_OK;
  }
  else if(*pFormat == TIME_FORMAT_SAMPLE && m_pStrh->fccType == streamtypeAUDIO &&
          ((WAVEFORMAT *)GetStrf())->wFormatTag == WAVE_FORMAT_PCM)
  {
    return S_OK;
  }
  else if(*pFormat == TIME_FORMAT_FRAME && m_pStrh->fccType != streamtypeAUDIO)
  {
    return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}


// The rounding characteristics of ConvertToTick and ConvertFromTick MUST be
// complimentary.  EITHER one rounds up (away from zero) and one rounds down
// (towards zero) OR they both "round" in the traditional sense (add a half
// then truncate).  If both round up or if both round down, then we are likely
// to experiece BAD round trip integrity problems.

LONGLONG
CAviMSROutPin::ConvertToTick(
  const LONGLONG ll,
  const TimeFormat Format)
{
  LONGLONG Result = ll;  // Default value: good for Frames & Samples

  if(Format == FORMAT_TIME)
  {
    // Always round DOWN!
    Result = llMulDiv( ll, m_pStrh->dwRate, m_pStrh->dwScale * UNITS, 0 );
    const LONGLONG Max = m_pStrh->dwLength + m_pStrh->dwStart;
    if (Result > Max) Result = Max;
    if (Result < 0 ) Result = 0;
  }
  else if(Format == FORMAT_FRAME)
  {
    ASSERT(m_pStrh->fccType != streamtypeAUDIO);
    // one tick per frame
  }
  else if(Format == FORMAT_SAMPLE)
  {
    ASSERT(m_pStrh->fccType == streamtypeAUDIO ||
           m_pStrh->fccType == streamtypeMIDI);
    // one tick per sample for uncompressed audio at least
  }
  else
  {
    DbgBreak("CAviMSROutPin::ConvertToTick");
    Result = -1;
  }
  return Result;
}

LONGLONG
CAviMSROutPin::ConvertFromTick(
  const LONGLONG ll,
  const TimeFormat Format)
{
  // ASSERT( ll >= 0 );  This will fire if you've just fast forwarded or rewound!!
  // This is because we seek back to the last key-frame and send that plus the
  // frames between the key frame and the 'current' frame so that the codec can
  // build the display properly.  The key frame will have a negative relative-reference
  // time.


  // this assertion is invalid because this can be called from
  // external components.
  //
  // ASSERT( ll <= m_pStrh->dwStart + m_pStrh->dwLength );

  LONGLONG Result = ll;  // Good default for Samples & Frames
  if(Format == FORMAT_TIME)
  {
    // Round UP (to the nearest 100ns unit!).  the likelyhood is that 100ns will be
    // the finest grained unit we encounter (but possibly not for long :-(.
    Result = llMulDiv( ll, m_pStrh->dwScale * UNITS, m_pStrh->dwRate, m_pStrh->dwRate - 1 );
  }
  else if(Format == FORMAT_FRAME)
  {
    ASSERT(m_pStrh->fccType != streamtypeAUDIO);
    // one tick per frame
  }
  else if(Format == FORMAT_SAMPLE)
  {
    ASSERT(m_pStrh->fccType == streamtypeAUDIO);
    // one tick per sample, for uncompressed audio at least
  }
  else
  {
    DbgBreak("CAviMSROutPin::ConvertToTick");
    Result = -1;
  }
  return Result;
}

LONGLONG CAviMSROutPin::ConvertToTick(
  const LONGLONG ll,
  const GUID *const pFormat)
{
  return ConvertToTick(ll, CBaseMSRFilter::MapGuidToFormat(pFormat));
}

LONGLONG CAviMSROutPin::ConvertFromTick(
  const LONGLONG ll,
  const GUID *const pFormat)
{
  return ConvertFromTick(ll, CBaseMSRFilter::MapGuidToFormat(pFormat));
}


inline REFERENCE_TIME
CAviMSROutPin::ConvertInternalToRT(
  const LONGLONG llVal)
{
  return ConvertFromTick(llVal, FORMAT_TIME);
}

inline LONGLONG
CAviMSROutPin::ConvertRTToInternal(const REFERENCE_TIME rtVal)
{
  return ConvertToTick(rtVal, FORMAT_TIME);
}


// ------------------------------------------------------------------------

inline LONGLONG CAviMSROutPin::GetStreamStart()
{
  return m_pStrh->dwStart;
}

inline LONGLONG CAviMSROutPin::GetStreamLength()
{
  return m_pStrh->dwLength;
}

HRESULT CAviMSROutPin::GetMediaType(
  int iPosition,
  CMediaType *pMediaType)
{
    BOOL fRgb32 = (m_mtFirstSample.subtype == MEDIASUBTYPE_RGB32);

    if (iPosition == 0 || iPosition == 1 && fRgb32)
    {
        (*pMediaType) = m_mtFirstSample;
        if(fRgb32 && iPosition == 0) { // offer ARGB32 first
            pMediaType->subtype = MEDIASUBTYPE_ARGB32;
        }

        return S_OK;
    }

    return VFW_S_NO_MORE_ITEMS;
}

// parse 'strl' rifflist and keep track of the chunks found in
// the provided AVISTREAM structure.
//
BOOL CAviMSROutPin::ParseHeader (
  RIFFLIST * pRiffList,
  UINT      id)
{
  CAviMSRFilter *pFilter = (CAviMSRFilter *)m_pFilter;
  DbgLog((LOG_TRACE, 5,
          TEXT("CAviMSROutPin::ParseHeader(%08X,%08x,%d)"),
          this, pRiffList, id));

  RIFFCHUNK * pRiff = (RIFFCHUNK *)(pRiffList+1);
  RIFFCHUNK * pLimit = RIFFNEXT(pRiffList);

  ASSERT(m_id == id);

  m_pStrh      = NULL;
  m_pStrf      = NULL;
  m_pIndx      = NULL;

  while (pRiff < pLimit)
  {
    // sanity check.  chunks should never be smaller than the total
    // size of the list chunk
    //
    if (RIFFNEXT(pRiff) > pLimit)
      return FALSE;

    switch (pRiff->fcc)
    {
      case FCC('strh'):
        m_pStrh = (AVISTREAMHEADER *)pRiff;
        break;

      case FCC('strf'):
        m_pStrf = pRiff;
        break;

      case FCC('indx'):
        m_pIndx = (AVIMETAINDEX *)pRiff;
        break;

      case FCC('strn'):
        if(pRiff->cb > 0)
        {
          m_pStrn = (char *)pRiff + sizeof(RIFFCHUNK);

          // truncate if not null terminated
          if(m_pStrn[pRiff->cb - 1] != 0)
            m_pStrn[pRiff->cb - 1] = 0;
        }

        break;
    }

    pRiff = RIFFNEXT(pRiff);
  }

  // if we didn't find a stream header & format.  return failure.
  // (note that the INDX chunk is not required...)
  //

  if (!(m_pStrh && m_pStrf))
  {
    DbgLog((LOG_ERROR, 1, TEXT("one of strf, strh missing")));
    return FALSE;
  }

  // misc requirements to avoid division by zero
  if(m_pStrh->dwRate == 0)
  {
    DbgLog((LOG_ERROR, 1, TEXT("dwRate = 0")));
    return FALSE;
  }

  if(m_pStrh->fccType == streamtypeAUDIO &&
     ((WAVEFORMAT *)GetStrf())->nBlockAlign == 0)
  {
    DbgLog((LOG_ERROR, 1, TEXT("nBlockAlign = 0")));
    return FALSE;
  }

  // the strh chunk may only have the entries up to dwLength and not
  // have dwSuggestedBufferSize, dwQuality, dwSampleSize, rcFrame
  if(m_pStrh->cb < CB_STRH_SHORT)
    return FALSE;

  HRESULT hr = InitializeIndex();
  if(FAILED(hr))
    return FALSE;

  // dwInitialFrames computation for audio
  ULONG cbIf = 0;
  if(m_pStrh->fccType == streamtypeAUDIO)
  {
    // for audio we want to tell people how many bytes will give us
    // enough audio buffering for dwInitialFrames. This is typically
    // 750 ms.

    // Convert dwInitialFrames to time using main frame rate then to
    // to bytes using avgBytesPerSecond.

    // avoid delivering too much audio at once
    WAVEFORMAT *pwfx = (WAVEFORMAT *)GetStrf();
    m_cbMaxAudio = max(pwfx->nAvgBytesPerSec, pwfx->nBlockAlign);
    if(m_cbMaxAudio == 0)
    {
      m_cbMaxAudio = 0x3000;
    }
    else
    {
      // avoid delivering much more than a second of audio
      m_cbMaxAudio = m_cbMaxAudio + 10;

    }

    REFERENCE_TIME rtIf = pFilter->GetInitialFrames();
    if(rtIf == 0)
    {
      // file isn't 1:1 interleaved; ask for 1 second buffering. !!!
      // this seems to do worse with b.avi and mekanome.avi
      cbIf = ((WAVEFORMAT *)GetStrf())->nAvgBytesPerSec;
    }
    else
    {
      // bytes of audio ahead of video
      cbIf = (ULONG)((rtIf * ((WAVEFORMAT *)GetStrf())->nAvgBytesPerSec) /
                     UNITS);
    }

    DbgLog(( LOG_TRACE, 5, TEXT("audio offset = %dms = %d bytes"),
             (ULONG)(rtIf / (UNITS / MILLISECONDS)),
             cbIf));

    if(cbIf < 4096)
    {
      // file is probably not 1:1 interleaved
      cbIf = 4096;
    }
  }

  ALLOCATOR_PROPERTIES Request,Actual;

  // plus one so that there are more samples than samplereqs;
  // GetBuffer blocks
  ZeroMemory(&Request, sizeof(Request));

  // let the downstream filter hold on to more than buffer (even
  // though GetProperties reports 1 in this case). The worker thread
  // blocks in GetBuffer unless there is more than one CRecSample for
  // the downstream filter to hold on to. so add a few more for the
  // downstream filter to hold on to
  if(((CAviMSRFilter *)m_pFilter)->IsTightInterleaved())
  {
    Request.cBuffers = C_BUFFERS_INTERLEAVED + 3;
  }
  else
  {
    Request.cBuffers = m_pFilter->C_MAX_REQS_PER_STREAM + 10;
  }

  ULONG ulMaxSampleSize = GetMaxSampleSize();
  if( 0 == ulMaxSampleSize ) {
    return FALSE;
  }

  Request.cbBuffer = ulMaxSampleSize;
  Request.cbAlign = (LONG) 1;
  Request.cbPrefix = (LONG) 0;

  // m_pAllocator is not set, so use m_pRecAllocator
  hr = m_pRecAllocator->SetPropertiesInternal(&Request,&Actual);
  ASSERT(SUCCEEDED(hr));        // !!! really?

  if(cbIf != 0)
  {
    ULONG cbufReported = cbIf / ulMaxSampleSize;

    // capture files typically have audio after the video, so we want
    // to report as little audio as possible so that the throttling
    // code doesn't shout and so that the audio renderer doesn't
    // buffer too much data (because we have to have enough memory for
    // all the data between the audio and the video). a better thing
    // to do is to check for audio preroll in the file. !!! (a hack)
    if(pFilter->m_pAviMainHeader->dwFlags & AVIF_WASCAPTUREFILE)
      cbufReported = 1;

    cbufReported = max(cbufReported, 1);

    DbgLog(( LOG_TRACE, 5, TEXT("Avi stream %d: reporting %d buffers"),
             m_id, cbufReported ));
    hr = m_pRecAllocator->SetCBuffersReported(cbufReported);
    ASSERT(SUCCEEDED(hr));
  }
  else
  {
    // not audio. report something small in case some configures their
    // allocator with our values
    hr = m_pRecAllocator->SetCBuffersReported(1);
    ASSERT(SUCCEEDED(hr));
  }

  // ignore errors building the media type -- just means the
  // downstream filter may not be able to connect.
  BuildMT();

  if(m_pStrn)
  {
    ASSERT(m_pName);            // from pin creation
    delete[] m_pName;
    ULONG cc = lstrlenA(m_pStrn);

    // add a unique prefix so we can be persisted through FindPin and
    // QueryId in the base class
    const unsigned ccPrefix = 4;
    m_pName = new WCHAR[cc + 1 + ccPrefix];
    MultiByteToWideChar(GetACP(), 0, m_pStrn, -1, m_pName + ccPrefix, cc + 1);

    WCHAR szTmp[10];
    wsprintfW(szTmp, L"%02x", m_id);
    m_pName[0] = szTmp[0];
    m_pName[1] = szTmp[1];
    m_pName[2] = L')';
    m_pName[3] = L' ';
  }
  else if(m_pStrh->fccType == FCC('al21'))
  {
      ASSERT(lstrlenW(m_pName) >= 5); // from pin creation
      lstrcpyW(m_pName, L"~l21");
  }


  return TRUE;
}

HRESULT CAviMSROutPin::OnActive()
{
  if(!m_pWorker && m_Connected)
  {
    m_pWorker = new CAviMSRWorker(m_id, m_rpImplBuffer, m_pImplIndex);
    if(m_pWorker == 0)
      return E_OUTOFMEMORY;
  }

  return S_OK;
}

HRESULT CAviMSROutPin::Read(    /* [in] */ LPCOLESTR pszPropName,
                                /* [out][in] */ VARIANT *pVar,
                                /* [in] */ IErrorLog *pErrorLog)
{
  CheckPointer(pVar, E_POINTER);
  CheckPointer(pszPropName, E_POINTER);

  if(pVar->vt != VT_BSTR && pVar->vt != VT_EMPTY) {
      return E_FAIL;
  }

  CAutoLock l(m_pFilter);

  if(m_pStrn == 0 || lstrcmpW(pszPropName, L"name") != 0) {
      return E_INVALIDARG;
  }

  WCHAR wsz[256];
  MultiByteToWideChar(CP_ACP, 0, m_pStrn, -1, wsz, NUMELMS(wsz));

  pVar->vt = VT_BSTR;
  pVar->bstrVal = SysAllocString(wsz);

  return pVar->bstrVal ? S_OK : E_OUTOFMEMORY;
}


// helper function to return a fourcc code that contains the stream id
// of this stream combined with the supplied TwoCC code
//
// FOURCC CBaseMSROutPin::TwoCC(WORD tcc)
// {
//   FOURCC fcc = ((DWORD)tcc & 0xFF00) << 8 | ((DWORD)tcc & 0x00FF) << 24;
//   UCHAR  ch;

//   ch = m_id & 0x0F;
//   ch += (ch > 9) ? '0' : 'A' - 10;
//   fcc |= (DWORD)ch;

//   ch = (m_id & 0xF0) >> 4;
//   ch += (ch > 9) ? '0' : 'A' - 10;
//   fcc |= (DWORD)ch << 8;

//   return fcc;
// }

#ifdef DEBUG
ULONG get_last_error() { return GetLastError(); }
#endif // DEBUG

CMediaPropertyBag::CMediaPropertyBag(LPUNKNOWN pUnk) :
        CUnknown(NAME("CMediaPropertyBag"), pUnk),
        m_lstProp(NAME("CMediaPropertyBag list"), 10)
{
}

void DelPropPair(CMediaPropertyBag::PropPair *ppp)
{
    ASSERT(ppp);
    delete[] ppp->wszProp;
    EXECUTE_ASSERT(VariantClear(&ppp->var) == S_OK);
    delete ppp;
}

CMediaPropertyBag::~CMediaPropertyBag()
{
    PropPair *ppp;
    while(ppp = m_lstProp.RemoveHead(),
          ppp)
    {
        DelPropPair(ppp);
    }
}

STDMETHODIMP CMediaPropertyBag::NonDelegatingQueryInterface(
    REFIID riid, void ** ppv)
{
    HRESULT hr;

    if(riid == IID_IMediaPropertyBag)
    {
        hr = GetInterface((IMediaPropertyBag *)this, ppv);
    }
    else
    {
        hr = CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }

    return hr;
}

STDMETHODIMP CMediaPropertyBag::EnumProperty(
    ULONG iProperty, VARIANT *pvarName,
    VARIANT *pvarVal)
{
    CheckPointer(pvarName, E_POINTER);
    CheckPointer(pvarVal, E_POINTER);

    if((pvarName->vt != VT_BSTR && pvarName->vt != VT_EMPTY) ||
       (pvarVal->vt != VT_BSTR && pvarVal->vt != VT_EMPTY && pvarVal->vt != (VT_UI1 | VT_ARRAY)))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    POSITION pos = m_lstProp.GetHeadPosition();

    while(pos)
    {
        if(iProperty == 0)
        {
            PropPair *ppp = m_lstProp.Get(pos);
            pvarName->bstrVal = SysAllocString(ppp->wszProp);
            pvarName->vt = VT_BSTR;

            if(pvarName->bstrVal)
            {
                hr = VariantCopy(pvarVal, &ppp->var);
                if(FAILED(hr))
                {
                    SysFreeString(pvarName->bstrVal);
                    pvarName->vt = VT_EMPTY;
                    pvarName->bstrVal = 0;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            break;
        }

        iProperty--;
        pos = m_lstProp.Next(pos);
    }

    if(pos == 0)
    {
        ASSERT(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    return hr;
}

HRESULT CMediaPropertyBag::Read(
    LPCOLESTR pszProp, LPVARIANT pvar,
    LPERRORLOG pErrorLog, POSITION *pPos
    )
{
    if(pvar && pvar->vt != VT_EMPTY && pvar->vt != VT_BSTR)
        return E_INVALIDARG;

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    for(POSITION pos = m_lstProp.GetHeadPosition();
        pos;
        pos = m_lstProp.Next(pos))
    {
        PropPair *ppp = m_lstProp.Get(pos);

        if(lstrcmpW(ppp->wszProp, pszProp) == 0)
        {
            hr = S_OK;
            if(pvar)
            {
                hr = VariantCopy(pvar, &ppp->var);
            }

            if(pPos)
            {
                *pPos = pos;
            }

            break;
        }
    }

    if(pos == 0)
    {
        ASSERT(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

    return hr;
}

STDMETHODIMP CMediaPropertyBag::Read(
    LPCOLESTR pszProp, LPVARIANT pvar,
    LPERRORLOG pErrorLog)
{
    CheckPointer(pszProp, E_POINTER);
    CheckPointer(pvar, E_POINTER);

    return Read(pszProp, pvar, pErrorLog, 0);
}

// write property to bag. remove property first if it exists. if
// bstrVal is null, don't write the new value in.

STDMETHODIMP CMediaPropertyBag::Write(
    LPCOLESTR pszProp, LPVARIANT pVar)
{
    CheckPointer(pszProp, E_POINTER);
    CheckPointer(pVar, E_POINTER);

    if(pVar->vt != VT_BSTR &&
       pVar->vt != (VT_UI1 | VT_ARRAY))
    {
        return E_INVALIDARG;
    }

    // remove existing entry in list with the same property name
    POSITION pos;
    HRESULT hr = S_OK;
    if(Read(pszProp, 0, 0, &pos) == S_OK)
    {
        PropPair *ppp = m_lstProp.Remove(pos);
        DelPropPair(ppp);
    }

    // non empty value to record?
    if((pVar->vt == VT_BSTR && pVar->bstrVal) ||
       (pVar->vt == (VT_UI1 | VT_ARRAY) && pVar->parray))
    {
        int cchProp = lstrlenW(pszProp) + 1;
        PropPair *ppp = new PropPair;
        WCHAR *wszProp = new OLECHAR[cchProp];
        VARIANT varVal;
        VariantInit(&varVal);

        if(ppp &&
           wszProp &&
           SUCCEEDED(VariantCopy(&varVal, pVar)) &&
           m_lstProp.AddTail(ppp))
        {
            ppp->wszProp = wszProp;
            lstrcpyW(ppp->wszProp, pszProp);
            ppp->var = varVal;

            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            delete[] wszProp;
            EXECUTE_ASSERT(VariantClear(&varVal) == S_OK);
            delete ppp;
        }
    }

    return hr;
}

CUnknown *CMediaPropertyBag::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CUnknown *pUnkRet = new CMediaPropertyBag(pUnk);
    return pUnkRet;
}

HRESULT CAviMSRFilter::get_Copyright(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('ICOP'), pbstrX);
}
HRESULT CAviMSRFilter::get_AuthorName(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('IART'), pbstrX);
}
HRESULT CAviMSRFilter::get_Title(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('INAM'), pbstrX);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimux\alloc.h ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)


#ifndef _allocator_h
#define _allocator_h

//
// The suffix allocator implementation. this one gives us a suffix and
// a prefix on each buffer for AVI Riff chunks and junk chunks. The
// suffix is not reported in GetSize() on the sample.
//
class CSfxAllocator :
  public CMemAllocator
{
public:

  CSfxAllocator(
    TCHAR *,
    LPUNKNOWN,
    HRESULT *
    );
  
  ~CSfxAllocator();

  // internal method for the avi mux to record some values. fails if
  // it can't give the requested suffix.
  STDMETHODIMP SetPropertiesAndSuffix(
    ALLOCATOR_PROPERTIES *pRequest,
    ULONG cbSuffixReq,
    ALLOCATOR_PROPERTIES *pActual
    );

  // overridden not to reset certain values (alignment, prefix)
  STDMETHODIMP SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual);
    

private:

  // overriden to allocate space for the suffix
  HRESULT Alloc(void);

  ULONG m_cbSuffix;
};

//
// another allocator implementaion which takes an IMediaSample and
// wraps it into a CSampSample. samples have their own sample times
// and media times.
//

class CSampSample : public CMediaSample
{
  friend class CSampAllocator;
  IMediaSample *m_pSample;

public:
  HRESULT SetSample(IMediaSample *pSample, BYTE *pb, ULONG cb);

  CSampSample(
    TCHAR *pName,
    CBaseAllocator *pAllocator,
    HRESULT *phr);

  STDMETHODIMP_(ULONG) Release();

};

class CSampAllocator : public CBaseAllocator
{
public:
  CSampAllocator(TCHAR *, LPUNKNOWN, HRESULT *);
  ~CSampAllocator();

  void Free(void);
  void ReallyFree(void);
  HRESULT Alloc(void);

  STDMETHODIMP SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual);

  STDMETHODIMP GetBuffer(
    CSampSample **ppBuffer,
    REFERENCE_TIME * pStartTime,
    REFERENCE_TIME * pEndTime,
    DWORD dwFlags);
};


#endif // _allocator_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimux\avidest.h ===
#pragma warning(disable: 4097 4511 4512 4514 4705)

//
// Avi dest (render filter)
//

#include "alloc.h"

#include <stdio.h>              // for FILENAME_MAX

extern const AMOVIESETUP_FILTER sudAviMux ;

const int C_MAX_INPUTS = 0x7f;

class CAviDest;

class CAviDestOutput :
  public CBaseOutputPin
{
  CAviDest *m_pFilter;
  CSampAllocator *m_pSampAllocator;
public:
  CAviDestOutput(
    TCHAR *pObjectName,         // Object description
    CAviDest *pFilter,          // Owning filter who knows about pins
    CCritSec *pLock,            // Object who implements the lock
    HRESULT *phr);              // General OLE return code
  ~CAviDestOutput();

  HRESULT CheckMediaType(const CMediaType *);
  STDMETHODIMP BeginFlush(void);
  STDMETHODIMP EndFlush(void);
  HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);
  HRESULT CompleteConnect(IPin *pReceivePin);
  HRESULT BreakConnect();
  HRESULT DecideBufferSize(
    IMemAllocator * pAlloc,
    ALLOCATOR_PROPERTIES * ppropInputRequest) {
    return E_NOTIMPL;
  }
  HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);
};

class CAviDest : public CBaseFilter,
                 public IConfigInterleaving,
                 public IConfigAviMux,
                 public ISpecifyPropertyPages,
                 public IPersistMediaPropertyBag,
                 public CPersistStream,                 
                 public IMediaSeeking
{
  class CAviInput;

public:

  //
  // COM stuff
  //
  DECLARE_IUNKNOWN;
  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
  
  //
  // filter creation
  //
  CAviDest(LPUNKNOWN pUnk, HRESULT *pHr);
  ~CAviDest();
  static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *pHr);

  //
  // CBaseFilter overrides
  //
  CBasePin* GetPin(int n);
  int GetPinCount();

  //
  // IMediaFilter overrides
  //
  STDMETHODIMP Stop();
  STDMETHODIMP Pause();
  STDMETHODIMP Run(REFERENCE_TIME tStart);

  // for IAMStreamControl
  STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
  STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

  HRESULT Receive(
      int pinNum,
      IMediaSample *pSample,
      const AM_SAMPLE2_PROPERTIES *pSampProp);

  // IConfigInterleaving
  STDMETHODIMP put_Mode(InterleavingMode mode);
  STDMETHODIMP get_Mode(InterleavingMode *pMode);
  STDMETHODIMP put_Interleaving(
      const REFERENCE_TIME *prtInterleave,
      const REFERENCE_TIME *prtPreroll);
    
  STDMETHODIMP get_Interleaving(
      REFERENCE_TIME *prtInterleave,
      REFERENCE_TIME *prtPreroll);
  
  // IConfigAviMux
  STDMETHODIMP SetMasterStream(LONG iStream);
  STDMETHODIMP GetMasterStream(LONG *pStream);
  STDMETHODIMP SetOutputCompatibilityIndex(BOOL fOldIndex);
  STDMETHODIMP GetOutputCompatibilityIndex(BOOL *pfOldIndex);

  // CPersistStream
  HRESULT WriteToStream(IStream *pStream);
  HRESULT ReadFromStream(IStream *pStream);
  int SizeMax();

  //
  // implements ISpecifyPropertyPages interface
  //
  STDMETHODIMP GetPages(CAUUID * pPages);

  ULONG GetCFramesDropped();

  // IMediaSeeking. currently used for a progress bar (how much have
  // we written?)
  STDMETHODIMP IsFormatSupported(const GUID * pFormat);
  STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
  STDMETHODIMP SetTimeFormat(const GUID * pFormat);
  STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
  STDMETHODIMP GetTimeFormat(GUID *pFormat);
  STDMETHODIMP GetDuration(LONGLONG *pDuration);
  STDMETHODIMP GetStopPosition(LONGLONG *pStop);
  STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
  STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
  STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );

  STDMETHODIMP ConvertTimeFormat(
    LONGLONG * pTarget, const GUID * pTargetFormat,
    LONGLONG    Source, const GUID * pSourceFormat );

  STDMETHODIMP SetPositions(
    LONGLONG * pCurrent,  DWORD CurrentFlags,
    LONGLONG * pStop,  DWORD StopFlags );

  STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
  STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
  STDMETHODIMP SetRate( double dRate);
  STDMETHODIMP GetRate( double * pdRate);
  STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

  // IPersistMediaPropertyBag methods    
  STDMETHODIMP InitNew();
  STDMETHODIMP Load( IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog);
  STDMETHODIMP Save( IMediaPropertyBag *pPropBag, BOOL fClearDirty,
                  BOOL fSaveAllProperties);
  STDMETHODIMP GetClassID(CLSID *pClsid);

private:

  // number of inputs filter has currently
  unsigned m_cInputs;           // count of pins
  unsigned m_cActivePins;       // pins that haven't seen EOS
  unsigned m_cConnections;      // connected pins
  HRESULT AddNextPin(unsigned callingPin);
  void CompleteConnect();
  void BreakConnect();

  HRESULT ReconnectAllInputs();

  friend class CAviInput;
  friend class CImplFileSinkFilter;
  friend class CAviDestOutput;

  // critical section protecting filter state.
  CCritSec m_csFilter;

  // interface to writing the Avi file
  class CAviWrite *m_pAviWrite;

  BOOL m_fErrorSignaled;
  BOOL m_fIsDV;
  ULONG GetStreamDuration(IPin *pInputPin, CMediaType *pmt);

  // memory requirements of all allocators on this filter (all pins,
  // etc.)
  ULONG m_AlignReq, m_cbPrefixReq, m_cbSuffixReq;


  CAviDestOutput m_outputPin;

  //
  // input pin implementation
  //
  class CAviInput : public CBaseInputPin, public CBaseStreamControl,
                    public IPropertyBag
  {
    friend class CAviDest;

  public:

    CAviInput(
      CAviDest *pAviDest,       // used to enumerate pins
      HRESULT *pHr,             // OLE failure return code
      LPCWSTR szName,           // pin identification
      int numPin);              // number of this pin


    ~CAviInput();

    DECLARE_IUNKNOWN

    // to expose IAMStreamControl
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // for IAMStreamControl
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();

    HRESULT CheckMediaType(const CMediaType *);
    STDMETHODIMP Receive(IMediaSample *pSample);

    // IMemInputPin
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProp);
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    HRESULT BreakConnect();
    HRESULT CompleteConnect(IPin *pReceivePin);
    STDMETHODIMP EndOfStream();

    HRESULT Active(void);
    HRESULT Inactive(void);

    HRESULT HandlePossibleDiscontinuity(IMediaSample* pSample);
    // check with CAviWrite class
    STDMETHODIMP QueryAccept(
        const AM_MEDIA_TYPE *pmt
    );
      

    BOOL WriteFromOurAllocator();

    // IPropertyBag
    STDMETHODIMP Read( 
      /* [in] */ LPCOLESTR pszPropName,
      /* [out][in] */ VARIANT *pVar,
      /* [in] */ IErrorLog *pErrorLog);
    
    STDMETHODIMP Write( 
      /* [in] */ LPCOLESTR pszPropName,
      /* [in] */ VARIANT *pVar);


  private:
    
    void Reset();

    // copy sample
    HRESULT Copy(IMediaSample *pDest, IMediaSample *pSource);

    CSfxAllocator *m_pOurAllocator;

    CAviDest *m_pFilter;        // filter that owns this pin
    BOOL m_bUsingOurAllocator;
    BOOL m_bCopyNecessary;      // allocator cannot meet requiments
    BOOL m_bConnected;          // CompleteConnect/BreakConnect pairs
    int m_numPin;               // pin number
    BOOL m_fLastSampleDiscarded;// for IAMStreamControl

    REFERENCE_TIME m_rtLastStop;
    REFERENCE_TIME m_rtSTime;   //Total time of silence inserted

    char *m_szStreamName;
  };

  // array of pointers to inputs
  CAviInput *m_rgpInput[C_MAX_INPUTS];

  enum TimeFormat
  {
    FORMAT_BYTES,
    FORMAT_TIME
  } m_TimeFormat;

 

  IMediaPropertyBag *m_pCopyrightProps;

  struct PersistVal
  {
    DWORD dwcb;
    InterleavingMode mode;
    REFERENCE_TIME rtInterleave;
    REFERENCE_TIME rtPreroll;
    LONG iMasterStream;
    BOOL fOldIndex;
  };
};

// ------------------------------------------------------------------------
// property page

class CAviMuxProp : public CBasePropertyPage
{
public:
  CAviMuxProp(LPUNKNOWN lpUnk, HRESULT *phr);
  static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

  HRESULT OnConnect(IUnknown *pUnknown);
  HRESULT OnDisconnect();

  HRESULT OnActivate(void);
  HRESULT OnDeactivate();
  
  HRESULT OnApplyChanges();
  
private:
  INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  void UpdatePropPage();
  void UpdateValues();
  
  void SetDirty();
  IConfigInterleaving *m_pIl;
  InterleavingMode m_mode;
  REFERENCE_TIME m_rtPreroll;
  REFERENCE_TIME m_rtInterleaving;
};

class CAviMuxProp1 : public CBasePropertyPage
{
public:
  CAviMuxProp1(LPUNKNOWN lpUnk, HRESULT *phr);
  static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

  HRESULT OnConnect(IUnknown *pUnknown);
  HRESULT OnDisconnect();

  HRESULT OnDeactivate();
  HRESULT OnActivate(void);
    
  HRESULT OnApplyChanges();
  
private:
  INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  void UpdatePropPage();
  void UpdateValues();
    
  void SetDirty();

  IConfigAviMux *m_pCfgAvi;
  LONG m_lMasterStream;
  BOOL m_fOldIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimux\avidest.cpp ===
#include <windows.h>
#include <streams.h>
#include <atlbase.h>

#include <olectl.h>
#include "resource.h"

#include <initguid.h>
#include "avidest.h"
#include "aviwrite.h"

static const C_WRITE_REQS = 32; // number duplicated in fio

#pragma warning(disable: 4097 4511 4512 4514 4705)

#define DbgFunc(a) DbgLog(( LOG_TRACE, 5, \
                            TEXT("CAviDest::%s"), TEXT(a) \
                            ));
#ifdef FILTER_DLL

CFactoryTemplate g_Templates[]= {
  {L"AVI mux", &CLSID_AviDest, CAviDest::CreateInstance, NULL, &sudAviMux},
  {L"AVI mux Property Page", &CLSID_AviMuxProptyPage, CAviMuxProp::CreateInstance, NULL, NULL},
  {L"AVI mux Property Page1", &CLSID_AviMuxProptyPage1, CAviMuxProp1::CreateInstance, NULL, NULL}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif // FILTER_DLL

AMOVIESETUP_MEDIATYPE sudAVIMuxPinTypes =   {
  &MEDIATYPE_Stream,            // clsMajorType
  &MEDIASUBTYPE_Avi };          // clsMinorType

AMOVIESETUP_PIN psudAVIMuxPins[] =
{
  { L"Output"                   // strName
    , FALSE                     // bRendered
    , FALSE                     // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , L""                       // strConnectsToPin
    , 1                         // nTypes
    , &sudAVIMuxPinTypes        // lpTypes
  }
};


const AMOVIESETUP_FILTER sudAviMux =
{
  &CLSID_AviDest                // clsID
  , L"AVI Mux"                  // strName
  , MERIT_DO_NOT_USE            // dwMerit
  , 1                           // nPins
  , psudAVIMuxPins              // lpPin
};


// ------------------------------------------------------------------------
// filter constructor

#pragma warning(disable:4355)
CAviDest::CAviDest(
  LPUNKNOWN pUnk,
  HRESULT *pHr) :
    CBaseFilter(NAME("Avi Dest"), pUnk, &m_csFilter, CLSID_AviDest),
    m_outputPin(NAME("demux out"), this, &m_csFilter, pHr),
    m_AlignReq(1),
    m_cInputs(0),
    m_cConnections(0),
    m_pAviWrite(0),
    m_cbPrefixReq(0),
    m_cbSuffixReq(0),
    m_pCopyrightProps(0),
    CPersistStream(pUnk, pHr),
    m_TimeFormat(FORMAT_TIME),
    m_fIsDV(FALSE)
{
  for(int i = 0; i < C_MAX_INPUTS; i++)
    m_rgpInput[i] = 0;

  if(FAILED(*pHr ))
    return ;

  *pHr = AddNextPin(0);
  if(FAILED(*pHr ))
    return ;


  DbgFunc("CAviDest: constructed");
}

// ------------------------------------------------------------------------
// destructor

CAviDest::~CAviDest()
{
  // free anything allocated

  for(unsigned i = 0; i < m_cInputs; i++)
    delete m_rgpInput[i];

  if(m_pCopyrightProps)
    m_pCopyrightProps->Release();



  DbgFunc("CAviDest: destructed");
}

//
// NonDelegatingQueryInterface
//
//
STDMETHODIMP
CAviDest::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
  if(riid == IID_ISpecifyPropertyPages)
  {
    return GetInterface((ISpecifyPropertyPages *)this, ppv);
  }
  else if(riid == IID_IConfigInterleaving)
  {
    return GetInterface((IConfigInterleaving *)this, ppv);
  }
  else if(riid == IID_IConfigAviMux)
  {
    return GetInterface((IConfigAviMux *)this, ppv);
  }
  else if(riid == IID_IMediaSeeking)
  {
    return GetInterface((IMediaSeeking *)this, ppv);
  }
  else if(riid == IID_IPersistMediaPropertyBag)
  {
    return GetInterface((IPersistMediaPropertyBag *)this, ppv);
  }
  else if(riid == IID_IPersistStream)
  {
    return GetInterface((IPersistStream *) this, ppv);
  }
  else
  {
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
  }
}

// // overridden because pin

// STDMETHODIMP_(ULONG)
// CBaseMSROutPin::NonDelegatingRelease()
// {
// }

CUnknown *
CAviDest::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
  return new CAviDest(pUnk, phr);
}

// ------------------------------------------------------------------------
// CBaseFilter methods

CBasePin* CAviDest::GetPin(int n)
{
  if(n == 0)
    return &m_outputPin;
  else if(n - 1 < (int)m_cInputs && n - 1 >= 0)
    return m_rgpInput[n - 1];
  else
    return 0;
}

int CAviDest::GetPinCount()
{
  return m_cInputs + 1;
}

// tell CBaseStreamControl what sink to use
//
STDMETHODIMP CAviDest::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if (hr == S_OK) {
        // tell our input pins' IAMStreamControl what sink to use
        for(unsigned i = 0; i < m_cInputs; i++) {
            m_rgpInput[i]->SetFilterGraph(m_pSink);
        }
    }
    return hr;
}

// ------------------------------------------------------------------------
// IMediaFilter


// tell CBaseStreamControl what clock to use
//
STDMETHODIMP CAviDest::SetSyncSource(IReferenceClock *pClock)
{
    // tell our input pins' IAMStreamControl what clock to use
    for(unsigned i = 0; i < m_cInputs; i++) {
        m_rgpInput[i]->SetSyncSource(pClock);
    }
    return CBaseFilter::SetSyncSource(pClock);
}

STDMETHODIMP CAviDest::Stop()
{
  CAutoLock lock(&m_csFilter);

  FILTER_STATE state = m_State;

  HRESULT hr = CBaseFilter::Stop();
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviDest::Stop: BaseMediaFilter::Stop failed.")));
    return hr;
  }


  if(state != State_Stopped &&
     m_pAviWrite != 0 &&
     m_outputPin.IsConnected())
  {
    hr = m_pAviWrite->Close();
  }

  // tell our input pins' IAMStreamControl what state we're in
  for(unsigned i = 0; i < m_cInputs; i++)
    {
      if(m_rgpInput[i]->IsConnected())
      {
        m_rgpInput[i]->NotifyFilterState(State_Stopped, 0);
      }
    }

  if(m_fErrorSignaled)
    return S_OK;



  return hr;
}

// STDMETHODIMP CAviDest::FindPin(LPCWSTR Id, IPin * *ppPin)
// {
//   ASSERT(!"!!! CAviDest::FindPin untested");

//   *ppPin = 0;
//   unsigned pin;

//   if(wcslen(Id) != 4)
//     return VFW_E_NOT_FOUND;

//   if(swscanf(Id + 2, L"%02x", &pin) != 1)
//     return VFW_E_NOT_FOUND;

//   if(pin >= C_MAX_INPUTS)
//     return VFW_E_NOT_FOUND;

//   if(m_rgpInput[pin] == 0)
//     return VFW_E_NOT_FOUND;

//   *ppPin = m_rgpInput[pin];
//   (*ppPin)->AddRef();
//   return NOERROR;
// }

// ------------------------------------------------------------------------
//

STDMETHODIMP CAviDest::Pause()
{
  CAutoLock lock(&m_csFilter);

  if(m_State == State_Stopped && m_outputPin.IsConnected())
  {
    m_fErrorSignaled = TRUE;

    if(m_pAviWrite == 0)
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviDest::Pause: AviWrite wasn't initialized.")));
      return E_FAIL;
    }

    AviWriteStreamConfig rgAwsc[C_MAX_INPUTS];
    unsigned cActivePins = 0;
    for(unsigned i = 0; i < m_cInputs; i++)
    {
      if(m_rgpInput[i]->IsConnected())
      {

        rgAwsc[i].pmt = &m_rgpInput[i]->m_mt;
        rgAwsc[i].fOurAllocator = m_rgpInput[i]->WriteFromOurAllocator();
        rgAwsc[i].cSamplesExpected = GetStreamDuration(
          m_rgpInput[i], rgAwsc[i].pmt);
        rgAwsc[i].szStreamName = m_rgpInput[i]->m_szStreamName;

        cActivePins++;
      }
      else
      {
        rgAwsc[i].pmt = 0;
        rgAwsc[i].fOurAllocator = FALSE;
        rgAwsc[i].cSamplesExpected = 0;
        rgAwsc[i].szStreamName = 0;
      }
    }

    if(cActivePins == 0)
    {
      m_outputPin.DeliverEndOfStream();
    }

    m_cActivePins = cActivePins;
    ASSERT(m_cActivePins == m_cConnections);

    DbgLog(( LOG_TRACE, 2,
             TEXT("CAviDest::Pause: %i active streams."), m_cActivePins));

    HRESULT hr = m_pAviWrite->Initialize(m_cInputs, rgAwsc, m_pCopyrightProps);

    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviDest::Pause: aviwrite Initialize failed.")));
      return hr;
    }

    m_fErrorSignaled = FALSE;
  }

  // tell our input pins' IAMStreamControl what state we're in
  for(unsigned i = 0; i < m_cInputs; i++)
    {
      if(m_rgpInput[i]->IsConnected())
      {
        m_rgpInput[i]->NotifyFilterState(State_Paused, 0);
      }
    }

  return CBaseFilter::Pause();
}






STDMETHODIMP CAviDest::Run(REFERENCE_TIME tStart)
{
  CAutoLock lock(&m_csFilter);

  // tell our input pins' IAMStreamControl what state we're in
  for(unsigned i = 0; i < m_cInputs; i++)
    {
      if(m_rgpInput[i]->IsConnected())
      {
        m_rgpInput[i]->NotifyFilterState(State_Running, tStart);
      }
    }

  return CBaseFilter::Run(tStart);
}

// use IMediaSeeking to report how many samples an upstream pin will
// send us. zero if anything goes wrong.
//
ULONG CAviDest::GetStreamDuration(
  IPin *pInputPin,
  CMediaType *pmt)
{
  ULONG cFrames = 0;

  IPin *pPin;
  if(pInputPin->ConnectedTo(&pPin) == S_OK)
  {
    IMediaSeeking *pIms;
    HRESULT hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
    if(SUCCEEDED(hr))
    {
      REFERENCE_TIME rtStart, rtStop;
      hr = pIms->GetPositions(&rtStart, &rtStop);
      if(SUCCEEDED(hr))
      {
        REFERENCE_TIME rtStartSample, rtStopSample;
        GUID guidTimeFormat;

        if(pmt->majortype == MEDIATYPE_Audio)
          guidTimeFormat = TIME_FORMAT_SAMPLE;
        else
          guidTimeFormat = TIME_FORMAT_FRAME;

        hr = pIms->ConvertTimeFormat(
          &rtStartSample, &guidTimeFormat,
          rtStart, 0);
        if(SUCCEEDED(hr))
        {
          hr = pIms->ConvertTimeFormat(
            &rtStopSample, &guidTimeFormat,
            rtStop, 0);
          if(SUCCEEDED(hr))
          {
            ASSERT(rtStopSample >= rtStartSample);
            cFrames = (ULONG)(rtStopSample - rtStartSample);
          }
        }
      }

      pIms->Release();
    }
    pPin->Release();
  }

  DbgLog((LOG_TRACE, 5, TEXT("Avimux: GetStreamDuration: %d"),
          cFrames));

  return cFrames;
}

// ------------------------------------------------------------------------
// filter Receive method. entered concurrently from pin->Receive()
//

HRESULT CAviDest::Receive(
    int pinNum,
    IMediaSample *pSample,
    const AM_SAMPLE2_PROPERTIES *pSampProp)
{
  if(m_State == State_Stopped)
  {
    DbgLog((LOG_ERROR,1, TEXT("avi mux: Receive when stopped!")));
    return VFW_E_NOT_RUNNING;
  }

  if(m_fErrorSignaled)
  {
    DbgLog((LOG_ERROR, 1,
            TEXT("avi mux: error signalled. S_FALSE to pin %d"), pinNum));
    return S_FALSE;
  }

  if(!m_outputPin.IsConnected())
  {
    DbgLog((LOG_ERROR, 1,
            TEXT("avi mux: no output pin. S_FALSE to pin %d"), pinNum));
    return S_FALSE;
  }

  // may block, so we can't lock the filter
  HRESULT hr = m_pAviWrite->Receive(pinNum, pSample, pSampProp);
  if(hr != S_OK)
  {
    DbgLog((LOG_ERROR, 1,
            TEXT("avimux: receive saw %08x on pin %d. refusing everything"),
            hr, pinNum));
    m_fErrorSignaled = TRUE;
    if(FAILED(hr))
    {
      NotifyEvent(EC_ERRORABORT, hr, 0);
      m_outputPin.DeliverEndOfStream();
    }
  }
  return hr;
}

// ------------------------------------------------------------------------
// IConfigAviMux methods

HRESULT CAviDest::put_Mode(InterleavingMode mode)
{
  CAutoLock lock(&m_csFilter);
  if(m_State != State_Stopped)
    return VFW_E_WRONG_STATE;

  HRESULT hr = m_pAviWrite->put_Mode(mode);
  if(SUCCEEDED(hr) && m_outputPin.IsConnected())
  {
    hr = m_pGraph->Reconnect(&m_outputPin);
    if(FAILED(hr))
      return hr;
  }
  return hr;
}

HRESULT CAviDest::get_Mode(InterleavingMode *pMode)
{
  CheckPointer(pMode, E_POINTER);

  return m_pAviWrite->get_Mode(pMode);
}

HRESULT CAviDest::put_Interleaving(
    const REFERENCE_TIME *prtInterleave,
    const REFERENCE_TIME * prtPreroll)
{
  CheckPointer(prtPreroll, E_POINTER);
  CheckPointer(prtInterleave, E_POINTER);

  CAutoLock lock(&m_csFilter);
  if(m_State != State_Stopped)
    return VFW_E_WRONG_STATE;

  return m_pAviWrite->put_Interleaving(prtInterleave, prtPreroll);
}

HRESULT CAviDest::get_Interleaving(
    REFERENCE_TIME *prtInterleave,
    REFERENCE_TIME *prtPreroll)
{
  CheckPointer(prtPreroll, E_POINTER);
  CheckPointer(prtInterleave, E_POINTER);

  return m_pAviWrite->get_Interleaving(prtInterleave, prtPreroll);
}

STDMETHODIMP CAviDest::GetPages(CAUUID * pPages)
{
  CAutoLock lock(&m_csFilter);
  pPages->cElems = 2;
  pPages->pElems =  (GUID *) CoTaskMemAlloc(sizeof(GUID) * 2);
  if (pPages->pElems == NULL)
    return E_OUTOFMEMORY;
  pPages->pElems[0] = CLSID_AviMuxProptyPage;
  pPages->pElems[1] = CLSID_AviMuxProptyPage1;

  return S_OK;
}

ULONG CAviDest::GetCFramesDropped()
{
  return m_pAviWrite ? m_pAviWrite->GetCFramesDropped() : 0;
}

// ------------------------------------------------------------------------
// IConfigureAviTemp

HRESULT CAviDest::SetMasterStream(LONG iStream)
{
  // postpone checking this until Pause because we may be called
  // before inputs are connected.
  if(iStream < -1)
  {
    DbgLog((LOG_ERROR, 1, TEXT("avimux: invalid master stream")));
    return E_INVALIDARG;
  }

  return m_pAviWrite->SetMasterStream(iStream);
}

HRESULT CAviDest::GetMasterStream(LONG *piStream)
{
  CheckPointer(piStream, E_POINTER);

  return m_pAviWrite->GetMasterStream(piStream);
}

HRESULT CAviDest::SetOutputCompatibilityIndex(BOOL fOldIndex)
{
  return m_pAviWrite->SetOutputCompatibilityIndex(fOldIndex);
}

HRESULT CAviDest::GetOutputCompatibilityIndex(BOOL *pfOldIndex)
{
  CheckPointer(pfOldIndex, E_POINTER);
  return m_pAviWrite->GetOutputCompatibilityIndex(pfOldIndex);
}

// IMediaSeeking

HRESULT CAviDest::IsFormatSupported(const GUID * pFormat)
{
  return *pFormat == TIME_FORMAT_MEDIA_TIME ||
    *pFormat == TIME_FORMAT_BYTE ? S_OK : S_FALSE;
}

HRESULT CAviDest::QueryPreferredFormat(GUID *pFormat)
{
  *pFormat = TIME_FORMAT_MEDIA_TIME;
  return S_OK;
}

HRESULT CAviDest::SetTimeFormat(const GUID * pFormat)
{
  HRESULT hr = S_OK;
  if(*pFormat == TIME_FORMAT_MEDIA_TIME)
    m_TimeFormat = FORMAT_TIME;
  else if(*pFormat == TIME_FORMAT_BYTE)
    m_TimeFormat = FORMAT_BYTES;
  else
    hr = E_INVALIDARG;

  return hr;
}

HRESULT CAviDest::IsUsingTimeFormat(const GUID * pFormat)
{
  HRESULT hr = S_OK;
  if (m_TimeFormat == FORMAT_TIME && *pFormat == TIME_FORMAT_MEDIA_TIME)
    ;
  else if (*pFormat == TIME_FORMAT_BYTE)
    ASSERT(m_TimeFormat == FORMAT_BYTES);
  else
    hr = S_FALSE;

  return hr;
}

HRESULT CAviDest::GetTimeFormat(GUID *pFormat)
{
  *pFormat = m_TimeFormat == FORMAT_TIME ?
    TIME_FORMAT_MEDIA_TIME : TIME_FORMAT_BYTE;

  return S_OK;
}

HRESULT CAviDest::GetDuration(LONGLONG *pDuration)
{
  HRESULT hr = S_OK;
  CAutoLock lock(&m_csFilter);

  if(m_TimeFormat == FORMAT_TIME)
  {
    *pDuration = 0;
    for(unsigned i = 0; i < m_cInputs; i++)
    {

      if(m_rgpInput[i]->IsConnected())
      {
        IPin *pPinUpstream;
        if(m_rgpInput[i]->ConnectedTo(&pPinUpstream) == S_OK)
        {
          IMediaSeeking *pIms;
          hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
          if(SUCCEEDED(hr))
          {
            LONGLONG dur = 0;
            hr = pIms->GetDuration(&dur);

            if(SUCCEEDED(hr))
              *pDuration = max(dur, *pDuration);

            pIms->Release();
          }

          pPinUpstream->Release();
        }
      }

      if(FAILED(hr))
        break;
    }
  }
  else
  {
    *pDuration = 0;
    return E_UNEXPECTED;
  }

  return hr;
}

HRESULT CAviDest::GetStopPosition(LONGLONG *pStop)
{
  return E_NOTIMPL;
}

HRESULT CAviDest::GetCurrentPosition(LONGLONG *pCurrent)
{
  CheckPointer(pCurrent, E_POINTER);

  if(m_TimeFormat == FORMAT_TIME)
  {
    m_pAviWrite->GetCurrentTimePos(pCurrent);
  }
  else
  {
    ASSERT(m_TimeFormat == FORMAT_BYTES);
    m_pAviWrite->GetCurrentBytePos(pCurrent);
  }

  return S_OK;
}

HRESULT CAviDest::GetCapabilities( DWORD * pCapabilities )
{
  CAutoLock lock(&m_csFilter);
  *pCapabilities = 0;

  // for the time format, we can get a duration by asking the upstream
  // filters
  if(m_TimeFormat == FORMAT_TIME)
  {
    *pCapabilities |= AM_SEEKING_CanGetDuration;
    for(unsigned i = 0; i < m_cInputs; i++)
    {
      if(m_rgpInput[i]->IsConnected())
      {
        IPin *pPinUpstream;
        if(m_rgpInput[i]->ConnectedTo(&pPinUpstream) == S_OK)
        {
          IMediaSeeking *pIms;
          HRESULT hr = pPinUpstream->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
          if(SUCCEEDED(hr))
          {
            hr = pIms->CheckCapabilities(pCapabilities);
            pIms->Release();
          }

          pPinUpstream->Release();
        }
      }
    }
  }

  // we always know the current position
  *pCapabilities |= AM_SEEKING_CanGetCurrentPos;

  return S_OK;
}

HRESULT CAviDest::CheckCapabilities( DWORD * pCapabilities )
{
  DWORD dwMask = 0;
  GetCapabilities(&dwMask);
  *pCapabilities &= dwMask;

  return S_OK;
}


HRESULT CAviDest::ConvertTimeFormat(
  LONGLONG * pTarget, const GUID * pTargetFormat,
  LONGLONG    Source, const GUID * pSourceFormat )
{
  return E_NOTIMPL;
}


HRESULT CAviDest::SetPositions(
  LONGLONG * pCurrent,  DWORD CurrentFlags,
  LONGLONG * pStop,  DWORD StopFlags )
{
  // not yet implemented. this might be how we append to a file. and
  // how we write less than an entire file.
  return E_NOTIMPL;
}


HRESULT CAviDest::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
  return E_NOTIMPL;
}

HRESULT CAviDest::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
  return E_NOTIMPL;
}

HRESULT CAviDest::SetRate( double dRate)
{
  return E_NOTIMPL;
}

HRESULT CAviDest::GetRate( double * pdRate)
{
  return E_NOTIMPL;
}

HRESULT CAviDest::GetPreroll(LONGLONG *pPreroll)
{
  return E_NOTIMPL;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// IPersistMediaPropertyBag

STDMETHODIMP CAviDest::Load(IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog)
{
    CheckPointer(pPropBag, E_POINTER);

    CAutoLock lock(&m_csFilter);
    if(m_State != State_Stopped)
        return VFW_E_WRONG_STATE;


    HRESULT hr = S_OK;

    if(m_pCopyrightProps)
        m_pCopyrightProps->Release();

    m_pCopyrightProps = pPropBag;
    pPropBag->AddRef();
    return hr;
}

STDMETHODIMP CAviDest::Save(
    IMediaPropertyBag *pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CAviDest::InitNew()
{
    if(m_pCopyrightProps)
    {
        m_pCopyrightProps->Release();
        m_pCopyrightProps = 0;
    }

    return S_OK;
}

STDMETHODIMP CAviDest::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);
}




// ------------------------------------------------------------------------
// private methods

HRESULT CAviDest::AddNextPin(unsigned callingPin)
{
  CAutoLock lock(&m_csFilter);
  HRESULT hr;

  if(m_cConnections + 1 < m_cInputs)
    return S_OK;

  if(m_cInputs >= C_MAX_INPUTS)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviDest::AddNextPin too many pins")));
    return E_FAIL;
  }

  WCHAR wsz[20];
  lstrcpyW(wsz, L"Input 00");
  wsz[6] = L'0' + (m_cInputs + 1) / 10;
  wsz[7] = L'0' + (m_cInputs + 1) % 10;

  hr = S_OK;
  m_rgpInput[m_cInputs] = new CAviInput(this, &hr, wsz, m_cInputs);
  if(m_rgpInput[m_cInputs] == 0)
    return  E_OUTOFMEMORY;

  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviDest::AddNextPin create pin failed")));
    m_rgpInput[m_cInputs] = 0;
  }
  else
  {
    DbgLog(( LOG_TRACE, 2,
             TEXT("CAviDest::added 1 pin")));
    // now bring this pin up to date with all the stuff its IAMStreamControl
    // needs to know
    // our state better be STOPPED!
    m_rgpInput[m_cInputs]->SetFilterGraph(m_pSink);
    m_rgpInput[m_cInputs]->SetSyncSource(m_pClock);
    m_cInputs++;
  }

  ASSERT(m_cConnections < m_cInputs);

  return hr;
}

void CAviDest::CompleteConnect()
{
  CAutoLock lock(&m_csFilter);

  m_cConnections++;
  DbgLog(( LOG_TRACE, 2,
           TEXT("CAviDest::CompleteConnect %i"), m_cConnections ));

  ASSERT(m_cConnections <= m_cInputs);
}

void CAviDest::BreakConnect()
{
  CAutoLock lock(&m_csFilter);

  ASSERT(m_cConnections > 0);
  m_cConnections--;

  DbgLog(( LOG_TRACE, 2,
           TEXT("CAviDest::BreakConnect %i"), m_cConnections ));

}

HRESULT CAviDest::ReconnectAllInputs()
{
  DbgLog((LOG_TRACE, 5, TEXT("CAviDest::ReconnectAllInputs")));
  HRESULT hr;
  for(UINT i = 0; i < m_cInputs; i++)
  {
    if(m_rgpInput[i]->IsConnected())
    {
      hr = m_pGraph->Reconnect(m_rgpInput[i]);
      if(FAILED(hr))
        return hr;
    }
  }
  return S_OK;
}






// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Input pin implementation

// ------------------------------------------------------------------------
// constructor

CAviDest::CAviInput::CAviInput(
  CAviDest *pAviDest,
  HRESULT *pHr,
  LPCWSTR szName,
  int numPin
  )
    : CBaseInputPin(NAME("AVI Dest Input"), pAviDest,
                    &pAviDest->m_csFilter, pHr, szName)
{
  DbgFunc("CAviInput::constructor");
  m_pOurAllocator = 0;
  m_pAllocator = 0;
  m_rtLastStop = 0;
  m_szStreamName = NULL;

  Reset();


  m_pFilter = pAviDest;
  m_numPin = numPin;
}

STDMETHODIMP CAviDest::CAviInput::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IAMStreamControl) {
        return GetInterface((IAMStreamControl *)this, ppv);
    } else if (riid == IID_IPropertyBag) {
        return GetInterface(static_cast<IPropertyBag *>(this), ppv);
    } else {
        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


// necessary to support IAMStreamControl
STDMETHODIMP CAviDest::CAviInput::BeginFlush()
{
    Flushing(TRUE);
    return CBaseInputPin::BeginFlush();
}

// necessary to support IAMStreamControl
STDMETHODIMP CAviDest::CAviInput::EndFlush()
{
    Flushing(FALSE);
    return CBaseInputPin::EndFlush();
}

void CAviDest::CAviInput::Reset()
{
  m_bUsingOurAllocator = FALSE;
  m_bCopyNecessary = FALSE;
  m_bConnected = FALSE;

  if(m_pOurAllocator != 0)
    m_pOurAllocator->Release();
  m_pOurAllocator = 0;
}

CAviDest::CAviInput::~CAviInput()
{
  DbgFunc("CAviInput::destructor");
  Reset();
  delete[] m_szStreamName;
}

STDMETHODIMP CAviDest::CAviInput::EndOfStream()
{
  HRESULT hr;
  {
    CAutoLock lock(&m_pFilter->m_csFilter);

    if(m_bFlushing)
      return S_OK;

    if(m_pFilter->m_State == State_Stopped)
      return S_FALSE;

    DbgLog(( LOG_TRACE, 2,
             TEXT("CAviDest::CAviInput::EndOfStream %i active now"),
             m_pFilter->m_cActivePins ));

    hr = m_pFilter->m_pAviWrite->EndOfStream(m_numPin);
  }

  ASSERT(m_pFilter->m_cActivePins > 0);
  if(--m_pFilter->m_cActivePins == 0)
    m_pFilter->m_outputPin.DeliverEndOfStream();

  return hr;
}

HRESULT CAviDest::CAviInput::BreakConnect()
{



  if ((m_mt.subtype== MEDIASUBTYPE_dvsd )||(m_mt.subtype== MEDIASUBTYPE_dvhd  )
      ||(m_mt.subtype== MEDIASUBTYPE_dvsl  ))
  {
      m_pFilter->m_fIsDV = FALSE;
      DbgLog((LOG_TRACE,3,TEXT("Dv Video Pin Disc onnected")));
  }
  if(m_bConnected)
  {
    m_pFilter->BreakConnect();
    ASSERT(m_pFilter->m_cConnections < m_pFilter->m_cInputs);
  }
  m_bConnected = FALSE;

  if(m_pOurAllocator)
  {
    m_pOurAllocator->Release();
    m_pOurAllocator = 0;
  }



  return CBaseInputPin::BreakConnect();
}

HRESULT CAviDest::CAviInput::CompleteConnect(IPin *pReceivePin)
{
  HRESULT hr;

  DbgLog(( LOG_TRACE, 2,
           TEXT("CAviDest::CAviInput::CompleteConnect") ));

  hr = CBaseInputPin::CompleteConnect(pReceivePin);
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviDest::CAviInput::CompleteConnect CompleteConnect")));
    return hr;
  }

  if(!m_bConnected)
  {
    hr = m_pFilter->AddNextPin(m_numPin);
    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviDest::CAviInput::CompleteConnect AddNextPin failed")));
      return hr;
    }
    m_pFilter->CompleteConnect();
  }
  if ((m_mt.subtype== MEDIASUBTYPE_dvsd )||(m_mt.subtype== MEDIASUBTYPE_dvhd  )
      ||(m_mt.subtype== MEDIASUBTYPE_dvsl  ))
  {
      m_pFilter->m_fIsDV = TRUE;
      DbgLog((LOG_TRACE,3,TEXT("Dv Video Pin Connected")));
  }
  m_bConnected = TRUE;

  return hr;
}

// STDMETHODIMP CAviDest::CAviInput::QueryId(LPWSTR *Id)
// {
//   *Id = (LPWSTR)QzTaskMemAlloc(10);
//   if (*Id==NULL)
//     return E_OUTOFMEMORY;

//   swprintf(*Id, L"In%02X", m_numPin); // 10 bytes including unicode double-null.
//   return NOERROR;
// }

// ------------------------------------------------------------------------
// CheckMediaType

HRESULT CAviDest::CAviInput::CheckMediaType(
  const CMediaType *pMediaType
  )
{
  DbgFunc("CAviInput::CheckMediaType");

  // accept anything whose mediatype is a fourcc whose format type is
  // null or video with VIDEOINFO and audio with WAVEFORMATEX.

  const GUID *pMajorType = pMediaType->Type();
  const GUID *pFormatType = pMediaType->FormatType();

  FOURCC fcc = pMajorType->Data1;
  if(FOURCCMap(fcc) != *pMajorType &&
     *pMajorType != MEDIATYPE_AUXLine21Data)
  {
    return VFW_E_TYPE_NOT_ACCEPTED;
  }

  if(*pMajorType == MEDIATYPE_Audio)
  {
    if(*pFormatType != FORMAT_WaveFormatEx)
      return VFW_E_TYPE_NOT_ACCEPTED;

    // code later on divides by nBlockAlign. check for 0.
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)pMediaType->Format();
    if(pwfx->nBlockAlign == 0)
      return VFW_E_TYPE_NOT_ACCEPTED;
  }
  else if(*pMajorType == MEDIATYPE_Video)
  {
    if(*pFormatType != FORMAT_VideoInfo) {
      if (*pFormatType != FORMAT_DvInfo) {
          return VFW_E_TYPE_NOT_ACCEPTED;
      }
    } else {
        //  Check for negative heights and non-zero stride or
        //  offset weirdnesses
        //  Use the rcTarget rectangle as that describes the portion of
        //  the bitmap we're supposed to use
        const VIDEOINFOHEADER * const pvih =
            (const VIDEOINFOHEADER *const)pMediaType->pbFormat;
        if (pvih->bmiHeader.biHeight < 0 ||
            pvih->rcTarget.left != 0 ||
            pvih->rcTarget.right != 0 &&
                pvih->rcTarget.right != pvih->bmiHeader.biWidth) {
            return VFW_E_TYPE_NOT_ACCEPTED;
        }
    }
  }
  else if(*pMajorType == MEDIATYPE_Interleaved)
  {
    if(*pFormatType != FORMAT_DvInfo)
      return VFW_E_TYPE_NOT_ACCEPTED;
  }
  else
  {
    if(*pFormatType != GUID_NULL &&
       *pFormatType != FOURCCMap(pFormatType->Data1) &&
       *pFormatType != FORMAT_None)
    {{
      return VFW_E_TYPE_NOT_ACCEPTED;
    }}
  }

  return S_OK;
}

// ansi-only version of NAME macro (so that we don't need two
// CSilenceSample ctors.)
#ifdef DEBUG
#define NAME_A(x) (x)
#else
#define NAME_A(_x_) ((char *) NULL)
#endif


class CSilenceSample : public CMediaSample
{
public:
    CSilenceSample(BYTE *pBuffer, ULONG cbPrefix, ULONG cbBuffer, ULONG cbActual, HRESULT *phr) :
            CMediaSample(
                NAME_A("CSilenceSample"),
                (CBaseAllocator *)1, // keep assert from firing
                phr,
                0,                  // pbBuffer
                0)
        {
            m_nPrefix = cbPrefix;
            m_pBuffer = pBuffer;
            m_cbBuffer = cbBuffer;
            m_lActual = cbActual;
        }
    
    ~CSilenceSample() {
        VirtualFree( m_pBuffer - m_nPrefix, 0, MEM_RELEASE );
    }

        

    // overriden to avoid calling allocator since no allocator is used
    STDMETHODIMP_(ULONG) Release()
        {
            /* Decrement our own private reference count */
            LONG lRef = InterlockedDecrement(&m_cRef);

            ASSERT(lRef >= 0);

            DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
                    this, m_cRef));

            /* Did we release our final reference count */
            if (lRef == 0) {
                delete this;
            }
            return (ULONG)lRef;
        }

    LONG m_nPrefix;
};

static inline DWORD AlignUp(DWORD dw, DWORD dwAlign) {
  // align up: round up to next boundary
  return (dw + (dwAlign -1)) & ~(dwAlign -1);
};


HRESULT CAviDest::CAviInput::HandlePossibleDiscontinuity(IMediaSample* pSample)
{
    HRESULT hr;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtStop;
    pSample->GetTime(&rtStart,&rtStop);


    REFERENCE_TIME rtLastStop = m_rtLastStop;


     //if this is the first packet then we should not treat it as a discontinuity
    if (!rtLastStop)
        return NOERROR;

    REFERENCE_TIME rtDropTime = rtStart-rtLastStop;

    DbgLog((LOG_TRACE, 2, TEXT("New Sample Starts at %I64d, Last Stop: %I64d"),rtStart,rtLastStop));
    DbgLog((LOG_TRACE, 2, TEXT("Dropped interval: %I64d * 100 Nanoseconds"), rtDropTime));


    //Obtain a pointer to the Stream MediaType
    AM_MEDIA_TYPE * pmt= NULL;
    m_pFilter->m_pAviWrite->GetStreamInfo(m_numPin,&pmt);
    if (!pmt)
        return NOERROR;


    WAVEFORMATEX * pwfx =(WAVEFORMATEX *) pmt->pbFormat;
    //Calculate bytes of silence = (time difference in 100 ns) * (avg. bytes/ 100 ns)


    LONG cbSilence;

    if (rtLastStop < rtStart)
        cbSilence = (LONG) ((rtDropTime) *
            (((double)pwfx->nAvgBytesPerSec)    /   UNITS));
    else return NOERROR;

    if (cbSilence % pwfx->nBlockAlign)
        cbSilence-=cbSilence %pwfx->nBlockAlign;

    DbgLog((LOG_TRACE ,2, TEXT("Insert Silence: Total Bytes: %d"),cbSilence));

    m_rtSTime += rtDropTime;

    // use buffer size so as not to exceed allocator agreed
    // size. unfortunately this could be unreasonably small
    const cbMaxToSend = pSample->GetActualDataLength();

    // allocator negotiation may require we leave space for suffix and
    // prefix.
    const cbOurBuffer = AlignUp(cbMaxToSend + m_pFilter->m_cbPrefixReq + m_pFilter->m_cbSuffixReq,
                                m_pFilter->m_AlignReq);
    while( cbSilence )
    {
        // size equals remaining silence bytes or size of buffer whichever is less
        //
        DWORD cbToSend = min( cbSilence, cbMaxToSend );

        //compute time stamps
        REFERENCE_TIME rtSilenceSampleStart = rtLastStop;
        REFERENCE_TIME rtSilenceSampleStop = rtSilenceSampleStart + 
            ((UNITS * cbToSend) / pwfx->nAvgBytesPerSec);

        DbgLog((LOG_TRACE, 2, TEXT("InsertSilence: Start: %I64d, Stop: %I64d, Bytes: %d"),
            rtSilenceSampleStart, rtSilenceSampleStop, cbToSend ));

        // allocate the memory
        //
        BYTE * pBuffer = (PBYTE) VirtualAlloc(
            NULL,
            cbOurBuffer,
            MEM_COMMIT,
            PAGE_READWRITE );
        if( !pBuffer )
        {
            return E_OUTOFMEMORY;
        }
        // VirtualAlloc zeroes the memory (silence) and gives us 64k aligned pointers
        // ASSERT((DWORD)pBuffer % 65536 == 0);

        hr = S_OK;
        CSilenceSample * pSilence = new CSilenceSample(
            pBuffer + m_pFilter->m_cbPrefixReq,
            m_pFilter->m_cbPrefixReq,
            cbOurBuffer,
            cbToSend,
            &hr);
        if( !pSilence )
        {
            VirtualFree( pBuffer, 0, MEM_RELEASE );
            return E_OUTOFMEMORY;
        }
        ASSERT(hr == S_OK);     // nothing to fail
        pSilence->AddRef( );

        pSilence->SetTime(&rtSilenceSampleStart, &rtSilenceSampleStop);

        hr = Receive( pSilence );

        pSilence->Release( );

        if( hr != S_OK )
            return hr;

        DbgLog( ( LOG_TRACE, 2, "Send %ld silence bytes", cbToSend ) );

        rtLastStop = rtSilenceSampleStop;
        cbSilence -= cbToSend;
    }

    return S_OK;
}




// ------------------------------------------------------------------------
// Receive. copies sample if necessary and passes it to filter

HRESULT CAviDest::CAviInput::Receive(
  IMediaSample *pSample
  )
{
  //Check for discontinutiy and if true, we send silence packets to fill up the gap.
  //We try to do this early before receive does any processing on the current sample
  //We do not check for success because if it returns failure.  Whatever caused that will
  // be handled in the code below and I do not want to fail the receive function because
  // of a failure in silence insertion

  if (m_pFilter->m_fIsDV &&(m_mt.formattype == FORMAT_WaveFormatEx)
      &&( pSample->IsDiscontinuity() == S_OK))
  {
      HRESULT hrTmp = HandlePossibleDiscontinuity(pSample);
      if(FAILED(hrTmp)) {
          m_pFilter->m_fErrorSignaled = TRUE;
          m_pFilter->NotifyEvent(EC_ERRORABORT, hrTmp, 0);
          m_pFilter->m_outputPin.DeliverEndOfStream();
      }
  }

  HRESULT hr = CBaseInputPin::Receive(pSample);
  if(FAILED(hr))
    return hr;

  // is this pin on or off?  IAMStreamControl tells us whether or not to
  // deliver it.  The first sample after being off for a while is a
  // discontinuity.. otherwise don't touch the discontinuity bit
  int iStreamState = CheckStreamState(pSample);
  if (iStreamState == STREAM_FLOWING) {
    //DbgLog((LOG_TRACE,4,TEXT("MUX FLOWING")));
    if (m_fLastSampleDiscarded)
      pSample->SetDiscontinuity(TRUE);
    m_fLastSampleDiscarded = FALSE;
  } else {
    //DbgLog((LOG_TRACE,4,TEXT("MUX DISCARDING")));
    m_fLastSampleDiscarded = TRUE;        // next one is discontinuity
  }

    // Remember ending time of last packet
  REFERENCE_TIME rtstart= 0;
  REFERENCE_TIME rtstop = 0;
  pSample->GetTime(&rtstart,&rtstop);
  if (rtstop > m_rtLastStop)
      m_rtLastStop = rtstop;

  if(m_bCopyNecessary && iStreamState == STREAM_FLOWING)
  {
    // copy sample to our properly configured buffer
    IMediaSample *pNewSample;
    hr = m_pOurAllocator->GetBuffer(&pNewSample, 0, 0, 0);
    if(FAILED(hr))              // fails if allocator was decommited
      return hr;
    hr = Copy(pNewSample, pSample);
    if(FAILED(hr))
    {
      pNewSample->Release();
      return hr;
    }

    hr = m_pFilter->Receive(m_numPin, pNewSample, SampleProps());
    // filter will addref it if it needs to keep it
    pNewSample->Release();
  }
  else if (iStreamState == STREAM_FLOWING)
  {
    hr = m_pFilter->Receive(m_numPin, pSample, SampleProps());
  }
  return hr;
}

// ------------------------------------------------------------------------
// NotifyAllocator

STDMETHODIMP CAviDest::CAviInput::NotifyAllocator(IMemAllocator * pAllocator,
                                                    BOOL bReadOnly)
{
  HRESULT hr;
  hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
  if (FAILED(hr))
  {
    return hr;
  }
  ASSERT(m_pAllocator != 0);

  m_bUsingOurAllocator = m_bCopyNecessary = FALSE;

  CAutoLock cObjectLock(m_pLock);

  // determine whether source filter passed in our allocator or its
  // own; set m_bUsingOurAllocator
  if(m_pOurAllocator == 0)
  {
    // source filter didn't call GetAllocator, so our allocator wasn't
    // created, and source must be using its own allocator
    m_bUsingOurAllocator = FALSE;
  }
  else
  {
    m_bUsingOurAllocator = IsEqualObject(m_pOurAllocator, pAllocator);
  }

  if(!m_bUsingOurAllocator)
  {
    // get alignment and offset to see if it meets our requirements;
    // set m_bCopyNecessary

    ALLOCATOR_PROPERTIES upstreamProp;
    HRESULT hr = pAllocator->GetProperties(&upstreamProp);
    if(FAILED(hr))
      return hr;

    InterleavingMode ilm;
    m_pFilter->m_pAviWrite->get_Mode(&ilm);

    // since we are a sink and we always request the prefix we know
    // it's ours to use. I suppose the upstream filter can give more
    // prefix than requested
    m_bCopyNecessary = (
      upstreamProp.cbAlign < (long)m_pFilter->m_AlignReq ||
      upstreamProp.cbPrefix != (long)m_pFilter->m_cbPrefixReq ||
      bReadOnly && ilm != INTERLEAVE_FULL);

    // we modify the data to add riff headers and junk chunks. should
    // fix this to refuse to connect to read only streams
    if(!m_bCopyNecessary)
      ASSERT(!bReadOnly || ilm == INTERLEAVE_FULL);
  }

  // if we are copying to our allocator, make sure we have created our
  // allocator (it's not created if source filter does not call
  // GetAllocator, so then this calls GetAllocator)
  if(m_bCopyNecessary && m_pOurAllocator == 0)
  {
    IMemAllocator *pAllocator;
    HRESULT hr = GetAllocator(&pAllocator);
    if(FAILED(hr))
      return hr;                // maybe we ran out of memory.
    pAllocator->Release();      // didn't actually want an allocator
    ASSERT(m_pOurAllocator != 0);
  }

  if(m_pOurAllocator)
  {
      // so now we are responsible for configuring the Allocator with
      // some minimum values in case upstream filter didn't listen to
      // GetAllocatorRequirements
      ALLOCATOR_PROPERTIES Request, Actual;
      hr = m_pAllocator->GetProperties(&Request);
      if(FAILED(hr))
          return hr;

      Request.cbPrefix = m_pFilter->m_cbPrefixReq;
      Request.cbAlign = max((LONG)m_pFilter->m_AlignReq, Request.cbAlign);

      hr = m_pOurAllocator->SetPropertiesAndSuffix(
          &Request, m_pFilter->m_cbSuffixReq, &Actual);

      ASSERT(SUCCEEDED(hr));

      if (FAILED(hr))
          return hr;

      if ((Request.cbBuffer > Actual.cbBuffer) ||
          (Request.cBuffers > Actual.cBuffers) ||
          (Request.cbAlign > Actual.cbAlign))
          return E_FAIL;
  }

  DbgLog(( LOG_TRACE, 2,  TEXT("CAviDest::NotifyAllocator: ours? %i copy? %i"),
           m_bUsingOurAllocator, m_bCopyNecessary));
  ASSERT(!(m_bUsingOurAllocator && m_bCopyNecessary));
  ASSERT(!(m_bCopyNecessary && m_pAllocator == m_pOurAllocator));

  return S_OK;
}

// ------------------------------------------------------------------------
// GetAllocatorRequirements. report that we want stuff aligned and
// room for a riff chunk up front.

STDMETHODIMP
CAviDest::CAviInput::GetAllocatorRequirements(
  ALLOCATOR_PROPERTIES *pProp)
{
  CheckPointer(pProp, E_POINTER);

  // NotifyAllocator relies on this being set
  pProp->cbPrefix = sizeof(RIFFCHUNK);
  if(m_pFilter->m_AlignReq == 0)
    DbgLog((LOG_TRACE, 10, TEXT("CAviMux: alignment unknown. reporting 0")));
  pProp->cbAlign = m_pFilter->m_AlignReq;
  return S_OK;
}

// ------------------------------------------------------------------------
// GetAllocator
//
// based on filter.cpp: CBaseInput. NotifyInterface relies on
// particular behavior. This is the thing that creates the allocator
//



STDMETHODIMP CAviDest::CAviInput::GetAllocator(IMemAllocator ** ppAllocator)
{
  CheckPointer(ppAllocator, E_POINTER);
  /*  Create our allocator */
  CAutoLock cObjectLock(m_pLock);
    if (m_pOurAllocator == NULL)
  {
    HRESULT hr = S_OK;

    /* Create the new allocator object */

    CSfxAllocator *pMemObject = new CSfxAllocator(
      NAME("AVI dest allocator created by input pin"),
      NULL,
      &hr);

    if (pMemObject == NULL)
    {
      return E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
      ASSERT(pMemObject);
      delete pMemObject;
      return hr;
    }

    m_pOurAllocator = pMemObject;
        /*  We AddRef() our own allocator */
    m_pOurAllocator->AddRef();
  }



  ASSERT(m_pOurAllocator != NULL);
  *ppAllocator = m_pOurAllocator;
  (*ppAllocator)->AddRef();
  return NOERROR;
}

HRESULT CreateAllocator (CSfxAllocator** ppSAlloc)
{

    HRESULT hr = S_OK;

    /* Create the new allocator object */

    CSfxAllocator *pMemObject = new CSfxAllocator(
      NAME("AVI dest allocator created by input pin"),
      NULL,
      &hr);

    if (pMemObject == NULL)
    {
      return E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
      ASSERT(pMemObject);
      delete pMemObject;
      return hr;
    }

    *ppSAlloc = pMemObject;

    /*  We AddRef() our own allocator */
    (*ppSAlloc)->AddRef();
    return S_OK;

}


HRESULT CAviDest::CAviInput::Active()
{
  ASSERT(IsConnected());        // base class

  if(m_pAllocator == 0)
    return E_FAIL;
  m_rtSTime = 0;
  m_rtLastStop = 0;
  m_fLastSampleDiscarded = FALSE;        // reset for IAMStreamControl

  // commit and prepare our allocator. Needs to be done if he is not
  // using our allocator and we need to use our allocator
  if(m_bCopyNecessary)
  {
    ASSERT(m_pOurAllocator != 0);
    return m_pOurAllocator->Commit();
  }


  // for silence insertion but not needed any more
  if (!m_bUsingOurAllocator && !m_bCopyNecessary)
  {

        HRESULT hr;
        if (!m_pOurAllocator)
        {
            hr =CreateAllocator(&m_pOurAllocator);
            if (FAILED (hr))
                return hr;
        }
      //Need to set properties and commit

        ALLOCATOR_PROPERTIES Actual, Request;
        Request.cBuffers = 4;
        Request.cbBuffer=32000;
        Request.cbAlign = m_pFilter->m_AlignReq;
        Request.cbPrefix=sizeof(RIFFCHUNK);

        hr = m_pOurAllocator->SetProperties(&Request,&Actual);
        if (FAILED (hr))
            return hr;
        hr = m_pOurAllocator->Commit();
        if (FAILED (hr))
            return hr;
  }

  return S_OK;
}


HRESULT CAviDest::CAviInput::Inactive()
{
  ASSERT(IsConnected());        // base class

  if(m_bCopyNecessary)
  {
    ASSERT(m_pOurAllocator != 0);
    return m_pOurAllocator->Decommit();
  }
  else if (!m_bUsingOurAllocator)
  {   HRESULT hr;
      hr = m_pOurAllocator->Decommit();
      if (FAILED (hr))
         return hr;
  }
  DbgLog((LOG_TRACE, 2, TEXT("Total Interval of Silence inserted = %I64d *100 NanoSeconds"),m_rtSTime));


  return S_OK;
}

HRESULT CAviDest::CAviInput::QueryAccept(
    const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = CBaseInputPin::QueryAccept(pmt);
    CAutoLock lock(&m_pFilter->m_csFilter);

    // if running, ask for on-the-fly format change
    if(hr == S_OK && m_pFilter->m_pAviWrite &&
       m_pFilter->m_State != State_Stopped)
    {
        hr = m_pFilter->m_pAviWrite->QueryAccept(m_numPin, pmt);
    }

    return hr;
}


BOOL CAviDest::CAviInput::WriteFromOurAllocator()
{
  return m_bUsingOurAllocator || m_bCopyNecessary;
}

// IPropertyBag
STDMETHODIMP CAviDest::CAviInput::Read( 
    /* [in] */ LPCOLESTR pszPropName,
    /* [out][in] */ VARIANT *pVar,
    /* [in] */ IErrorLog *pErrorLog)
{
    CheckPointer(pVar, E_POINTER);
    CheckPointer(pszPropName, E_POINTER);
    if(pVar->vt != VT_BSTR && pVar->vt != VT_EMPTY) {
        return E_FAIL;
    }

    // serialize with Write
    CAutoLock lock(&m_pFilter->m_csFilter);

    if(m_szStreamName == 0 || lstrcmpW(pszPropName, L"name") != 0) {
        return E_INVALIDARG;
    }
    
    WCHAR wsz[256];
    MultiByteToWideChar(CP_ACP, 0, m_szStreamName, -1, wsz, NUMELMS(wsz));
    pVar->vt = VT_BSTR;
    pVar->bstrVal = SysAllocString(wsz);

    return pVar->bstrVal ? S_OK : E_OUTOFMEMORY;
}
    
STDMETHODIMP CAviDest::CAviInput::Write( 
    /* [in] */ LPCOLESTR pszPropName,
    /* [in] */ VARIANT *pVar)
{
    CheckPointer(pVar, E_POINTER);
    CheckPointer(pszPropName, E_POINTER);

    if(lstrcmpW(pszPropName, L"name") != 0) {
        return E_INVALIDARG;
    }
    if(pVar->vt != VT_BSTR && pVar->vt != VT_EMPTY) {
        return E_INVALIDARG;
    }

    CAutoLock lock(&m_pFilter->m_csFilter);

    // refuse new name while running -- CAviWrite won't see new name
    if(m_pFilter->m_State != State_Stopped) {
        VFW_E_WRONG_STATE;
    }

    HRESULT hr = S_OK;

    if(pVar->vt == VT_BSTR && pVar->bstrVal && *pVar->bstrVal)
    {
        int cch = lstrlenW(pVar->bstrVal) + 1;
        char *szName = new char[cch];
        if(szName) {
            WideCharToMultiByte(CP_ACP, 0, pVar->bstrVal, -1, szName, cch, 0, 0);
            delete[] m_szStreamName;
            m_szStreamName = szName;
        } else {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        delete[] m_szStreamName;
        m_szStreamName = 0;
    }

    return hr;
}


HRESULT CAviDest::CAviInput::Copy(
  IMediaSample *pDest,
  IMediaSample *pSource)
{
    // Copy the sample data
    {
        BYTE *pSourceBuffer, *pDestBuffer;
        long lSourceSize = pSource->GetActualDataLength();
        long lDestSize        = pDest->GetSize();

        // bug to receive samples larger than what was agreed in allocator
        // negotiation
        ASSERT(lDestSize >= lSourceSize);

        // but we need to fail properly to keep from faulting on bad data
        if(lSourceSize > lDestSize)
        {
            DbgBreak("sample too large.");
            // !!! this won't signal an error to the graph
            return E_UNEXPECTED;
        }

        pSource->GetPointer(&pSourceBuffer);
        pDest->GetPointer(&pDestBuffer);

        CopyMemory( (PVOID) pDestBuffer, (PVOID) pSourceBuffer, lSourceSize );

        // Copy the actual data length
        pDest->SetActualDataLength(lSourceSize);
    }

  {
    // copy the sample time

    REFERENCE_TIME TimeStart, TimeEnd;

    if (NOERROR == pSource->GetTime(&TimeStart, &TimeEnd)) {
        pDest->SetTime(&TimeStart, &TimeEnd);
    }
  }
  {
    // copy the media time

    REFERENCE_TIME TimeStart, TimeEnd;

    if (NOERROR == pSource->GetMediaTime(&TimeStart, &TimeEnd)) {
        pDest->SetMediaTime(&TimeStart, &TimeEnd);
    }
  }
  {
    // Copy the Sync point property

    HRESULT hr = pSource->IsSyncPoint();
    if (hr == S_OK)
    {
      pDest->SetSyncPoint(TRUE);
    }
    else if (hr == S_FALSE)
    {
      pDest->SetSyncPoint(FALSE);
    }
    else {        // an unexpected error has occured...
      return E_UNEXPECTED;
    }
  }
  {
    // Copy the media type

    AM_MEDIA_TYPE *pMediaType;
    pSource->GetMediaType(&pMediaType);
    pDest->SetMediaType(pMediaType);
    DeleteMediaType( pMediaType );
  }
  {
    // Copy the preroll property

    HRESULT hr = pSource->IsPreroll();
    if (hr == S_OK)
    {
      pDest->SetPreroll(TRUE);
    }
    else if (hr == S_FALSE)
    {
      pDest->SetPreroll(FALSE);
    }
    else {        // an unexpected error has occured...
      return E_UNEXPECTED;
    }
  }
//   {
//     // Copy the Discontinuity property

//     HRESULT hr = pSource->IsDiscontinuity();
//     if (hr == S_OK) {
//       pDest->SetDiscontinuity(TRUE);
//     }
//     else if (hr == S_FALSE) {
//       pDest->SetDiscontinuity(FALSE);
//     }
//     else {        // an unexpected error has occured...
//       return E_UNEXPECTED;
//     }
//   }

  return NOERROR;
}

// ------------------------------------------------------------------------
// output pin

CAviDestOutput::CAviDestOutput(
  TCHAR *pObjectName,
  CAviDest *pFilter,
  CCritSec *pLock,
  HRESULT *phr) :
    CBaseOutputPin(pObjectName, pFilter, pLock, phr, L"AVI Out"),
    m_pFilter(pFilter),
    m_pSampAllocator(0)
{
  if(FAILED(*phr))
    return;

  // init allocator
  m_pSampAllocator = new CSampAllocator(NAME("samp alloc"), GetOwner(), phr);
  if(m_pSampAllocator == 0)
  {
    *phr =  E_OUTOFMEMORY;
    return;
  }
  // reset the allocator since we call GetProperties on it
  ALLOCATOR_PROPERTIES apReq, apActual;
  ZeroMemory(&apReq, sizeof(apReq));
  m_pSampAllocator->SetProperties(&apReq, &apActual);

  ASSERT(m_pFilter->m_pAviWrite == 0);
  m_pFilter->m_pAviWrite = new CAviWrite(phr);
  if(m_pFilter->m_pAviWrite == 0)
  {
    *phr = E_OUTOFMEMORY;
    return;
  }
  if(FAILED(*phr ))
    return ;

  DbgLog((LOG_TRACE, 10, TEXT("CAviDestOutput::CAviDestOutput")));
}

CAviDestOutput::~CAviDestOutput()
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviDestOutput::~CAviDestOutput")));
  delete m_pFilter->m_pAviWrite;
  delete m_pSampAllocator;
}

HRESULT CAviDestOutput::CheckMediaType(const CMediaType *pmt)
{
  if((MEDIATYPE_Stream == pmt->majortype ||
      pmt->majortype == GUID_NULL) &&
     (MEDIASUBTYPE_Avi == pmt->subtype ||
      pmt->subtype == GUID_NULL))
  {
    return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}

// every we time we connect, reconfigure our allocator to reflect our
// interleaving mode. we reconnect every time we change interleaving
// mode
HRESULT CAviDestOutput::DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc)
{
  ALLOCATOR_PROPERTIES apReq, apActual, apDownstream;
  m_pSampAllocator->GetProperties(&apReq);
  apReq.cBuffers = C_WRITE_REQS;

  HRESULT hr = pPin->GetAllocatorRequirements(&apDownstream);
  if(FAILED(hr))
    apDownstream.cbAlign = 1;

  InterleavingMode ilMode;
  hr = m_pFilter->get_Mode(&ilMode);
  if(FAILED(hr))
    return hr;

  if(ilMode == INTERLEAVE_FULL || ilMode == INTERLEAVE_NONE_BUFFERED)
    apReq.cbAlign = 1;
  else
    apReq.cbAlign = apDownstream.cbAlign;

  hr = m_pSampAllocator->SetProperties(&apReq, &apActual);
  ASSERT(hr == S_OK);
  if(apActual.cBuffers < C_WRITE_REQS)
  {
    DbgBreak("disobedient allocator");
    return E_UNEXPECTED;
  }

  hr = pPin->NotifyAllocator(m_pSampAllocator, TRUE);
  if(FAILED(hr))
  {
    DbgBreak("avidest: unexpected: allocator refused");
    return hr;
  }
  *pAlloc = m_pSampAllocator;
  m_pSampAllocator->AddRef();
  return S_OK;
}

HRESULT CAviDestOutput::CompleteConnect(IPin *pReceivePin)
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviDestOutput::CompleteConnect")));

  HRESULT hr = CBaseOutputPin::CompleteConnect(pReceivePin);
  if(FAILED(hr))
    return hr;

  hr = m_pFilter->m_pAviWrite->Connect(m_pSampAllocator, m_pInputPin);
  if(FAILED(hr))
    return hr;

  m_pFilter->m_pAviWrite->GetMemReq(
    &m_pFilter->m_AlignReq,
    &m_pFilter->m_cbPrefixReq,
    &m_pFilter->m_cbSuffixReq);

  // need to reconnect all input pins if alignment requirements
  // changed.

  return m_pFilter->ReconnectAllInputs();
}

HRESULT CAviDestOutput::BreakConnect()
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviDestOutput::BreakConnect")));

  HRESULT hr = m_pFilter->m_pAviWrite->Disconnect();

  return CBaseOutputPin::BreakConnect();
}

HRESULT CAviDestOutput::GetMediaType(
  int iPosition,
  CMediaType *pMediaType)
{
  if(iPosition == 0)
  {
    pMediaType->majortype = MEDIATYPE_Stream;
    pMediaType->subtype = MEDIASUBTYPE_Avi;
    return S_OK;
  }
  return S_FALSE;
}

STDMETHODIMP
CAviDestOutput::BeginFlush(void)
{
  DbgBreak("avi mux output flush");
  return E_UNEXPECTED;
}

STDMETHODIMP
CAviDestOutput::EndFlush(void)
{
  DbgBreak("avi mux output flush");
  return E_UNEXPECTED;
}



// ------------------------------------------------------------------------
// property page

CUnknown *WINAPI CAviMuxProp::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
  return new CAviMuxProp(lpunk, phr);
}

CAviMuxProp::CAviMuxProp(LPUNKNOWN lpunk, HRESULT *phr) :
    CBasePropertyPage(
      NAME("avi mux Property Page"),
      lpunk,
      IDD_DIALOG_AVIMUX, IDS_AVIMUXPROPNAME),
    m_pIl(0)
{
  // InitCommonControls();
}

HRESULT CAviMuxProp::OnConnect(IUnknown *pUnknown)
{
  ASSERT(m_pIl == NULL);

  // Ask the filter for it's control interface

  HRESULT hr = pUnknown->QueryInterface(IID_IConfigInterleaving,(void **)&m_pIl);
  if (FAILED(hr)) {
    DbgBreak("avidest: can't find IID_IConfigInterleaving");
    return E_NOINTERFACE;
  }
  ASSERT(m_pIl);

  UpdateValues();

  return NOERROR;
}

void CAviMuxProp::UpdatePropPage()
{
  HRESULT hr = m_pIl->get_Mode(&m_mode);
  ASSERT(hr == S_OK);
  hr = m_pIl->get_Interleaving(&m_rtInterleaving, &m_rtPreroll);
  ASSERT(hr == S_OK);

  int iRadioButton;
  if(m_mode == INTERLEAVE_NONE)
    iRadioButton = IDC_AVIMUX_RADIO_NONE;
  else if(m_mode == INTERLEAVE_CAPTURE)
    iRadioButton = IDC_AVIMUX_RADIO_CAPTURE;
  else if(m_mode == INTERLEAVE_NONE_BUFFERED)
    iRadioButton = IDC_AVIMUX_RADIO_NONE_BUFF;
  else
  {
    iRadioButton = IDC_AVIMUX_RADIO_FULL;
    ASSERT(m_mode == INTERLEAVE_FULL);
  }

  CheckRadioButton(m_hwnd, IDC_AVIMUX_RADIO_NONE, IDC_AVIMUX_RADIO_FULL, iRadioButton);
  SetDlgItemInt (
      m_hwnd, IDC_AVIMUX_EDIT_INTERLEAVING,
      (LONG)(m_rtInterleaving / (UNITS / MILLISECONDS)), TRUE);
  SetDlgItemInt (
    m_hwnd, IDC_AVIMUX_EDIT_PREROLL,
    (LONG)(m_rtPreroll / (UNITS / MILLISECONDS)), TRUE);

  // hack which relies on CAviDest being derived from
  // IConfigInterleaving
  CAviDest *pAviDest = (CAviDest *)m_pIl;
  SetDlgItemInt (m_hwnd, IDC_AVIMUX_FRAMES_DROPPED, pAviDest->GetCFramesDropped(), TRUE);

  {
    LONGLONG ibCurrent = 0;
    REFERENCE_TIME rtCurrent = 0;
    REFERENCE_TIME rtDur = 0;

    IMediaSeeking *pIms;
    hr = pAviDest->QueryInterface(IID_IMediaSeeking, (void **)&pIms);
    if(SUCCEEDED(hr))
    {
      hr = pIms->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);
      if(SUCCEEDED(hr))
      {
        pIms->GetDuration(&rtDur);
        pIms->GetCurrentPosition(&rtCurrent);
      }
      hr = pIms->SetTimeFormat(&TIME_FORMAT_BYTE);
      if(SUCCEEDED(hr))
      {
        pIms->GetCurrentPosition(&ibCurrent);
      }

      pIms->Release();
    }

    TCHAR szTempString[100];

    wsprintf(szTempString, TEXT("%02d:%02d:%02d"),
             (LONG)(rtDur / UNITS / 60 / 60),
             (LONG)(rtDur / UNITS / 60 % 60),
             (LONG)(rtDur / UNITS % 60));

    SetDlgItemText(m_hwnd, IDC_AVIMUX_DURATION, szTempString);

    wsprintf(szTempString, TEXT("%02d:%02d:%02d"),
             (LONG)(rtCurrent / UNITS / 60 / 60),
             (LONG)(rtCurrent / UNITS / 60 % 60),
             (LONG)(rtCurrent / UNITS % 60));

    SetDlgItemText(m_hwnd, IDC_AVIMUX_CURRENT_POS, szTempString);

    SetDlgItemInt(m_hwnd, IDC_AVIMUX_BYTES_WRITTEN, (LONG)(ibCurrent / 1024), FALSE);
  }
}

void CAviMuxProp::UpdateValues()
{
  m_pIl->get_Mode(&m_mode);
  m_pIl->get_Interleaving(&m_rtInterleaving, &m_rtPreroll);
}

HRESULT CAviMuxProp::OnActivate()
{
  UpdatePropPage();
  return S_OK;
}

HRESULT CAviMuxProp::OnDeactivate()
{
  UpdateValues();
  return S_OK;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CAviMuxProp::OnDisconnect()
{

  // Release the interface
  if (m_pIl == NULL)
    return E_UNEXPECTED;

  m_pIl->Release();
  m_pIl = NULL;

  return S_OK;
}

INT_PTR CAviMuxProp::OnReceiveMessage(
  HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  UNREFERENCED_PARAMETER(lParam);
  switch (uMsg) {

    case WM_INITDIALOG:
      break;

    case WM_COMMAND:
      switch (LOWORD(wParam)) {
        case IDC_AVIMUX_RADIO_NONE:
          m_pIl->put_Mode(INTERLEAVE_NONE);
          SetDirty();
          break;

        case IDC_AVIMUX_RADIO_CAPTURE:
          m_pIl->put_Mode(INTERLEAVE_CAPTURE);
          SetDirty();
          break;

        case IDC_AVIMUX_RADIO_NONE_BUFF:
          m_pIl->put_Mode(INTERLEAVE_NONE_BUFFERED);
          SetDirty();
          break;

        case IDC_AVIMUX_RADIO_FULL:
          m_pIl->put_Mode(INTERLEAVE_FULL);
          SetDirty();
          break;

        case IDC_AVIMUX_EDIT_INTERLEAVING:
        {
          int iNotify = HIWORD (wParam);
          if (iNotify == EN_KILLFOCUS)
          {
            BOOL fOK;
            REFERENCE_TIME rtIl = GetDlgItemInt (hwnd, IDC_AVIMUX_EDIT_INTERLEAVING, &fOK, FALSE);
            REFERENCE_TIME currentIl, currentPreroll;
            rtIl *= (UNITS / MILLISECONDS);
            m_pIl->get_Interleaving(&currentIl, &currentPreroll);
            m_pIl->put_Interleaving(&rtIl, &currentPreroll);
            SetDirty();
          }
          break;
        }

        case IDC_AVIMUX_EDIT_PREROLL:
        {
          int iNotify = HIWORD (wParam);
          if (iNotify == EN_KILLFOCUS)
          {
            BOOL fOK;
            REFERENCE_TIME iPreroll = GetDlgItemInt (hwnd, IDC_AVIMUX_EDIT_PREROLL, &fOK, FALSE);
            REFERENCE_TIME currentIl, currentPreroll;
            iPreroll *= (UNITS / MILLISECONDS);
            m_pIl->get_Interleaving(&currentIl, &currentPreroll);
            m_pIl->put_Interleaving(&currentIl, &iPreroll);
            SetDirty();
          }
          break;
        }

      }
      break;

    default:
      return FALSE;

  }
  return TRUE;
}

void
CAviMuxProp::SetDirty()
{
  m_bDirty = TRUE;
  if(m_pPageSite)
    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

HRESULT CAviMuxProp::OnApplyChanges()
{
  UpdateValues();
  return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// 2nd property page

CUnknown *WINAPI CAviMuxProp1::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
  return new CAviMuxProp1(lpunk, phr);
}

CAviMuxProp1::CAviMuxProp1(LPUNKNOWN lpunk, HRESULT *phr) :
    CBasePropertyPage(
      NAME("avi mux Property Page1"),
      lpunk,
      IDD_DIALOG_AVIMUX1, IDS_AVIMUXPROPNAME1),
    m_pCfgAvi(0)
{
  // InitCommonControls();
}

HRESULT CAviMuxProp1::OnConnect(IUnknown *pUnknown)
{
  ASSERT(m_pCfgAvi == 0);

  // Ask the filter for it's control interface

  HRESULT hr = pUnknown->QueryInterface(IID_IConfigAviMux, (void **)&m_pCfgAvi);
  if(FAILED(hr))
  {
    DbgBreak("avidest: can't find IID_IConfigAviMux");
    return E_NOINTERFACE;
  }
  ASSERT(m_pCfgAvi);

  UpdateValues();

  return NOERROR;
}

void CAviMuxProp1::UpdatePropPage()
{
  if(m_lMasterStream != -1)
  {
    SetDlgItemInt (m_hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM, m_lMasterStream, TRUE);
    CheckDlgButton (m_hwnd, IDC_AVIMUX_ENABLEFIXUPRATES, BST_CHECKED);
  }
  else
  {
    Edit_Enable(GetDlgItem(m_hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM), FALSE);
    CheckDlgButton (m_hwnd, IDC_AVIMUX_ENABLEFIXUPRATES, BST_UNCHECKED);
  }

  CheckDlgButton(
    m_hwnd, IDC_AVIMUX_CHECK_OLDINDEX,
    m_fOldIndex ? BST_CHECKED : BST_UNCHECKED);
}

void CAviMuxProp1::UpdateValues()
{
  HRESULT hr = m_pCfgAvi->GetMasterStream(&m_lMasterStream);
  ASSERT(hr == S_OK);

  hr = m_pCfgAvi->GetOutputCompatibilityIndex(&m_fOldIndex);
  ASSERT(hr == S_OK);
}

HRESULT CAviMuxProp1::OnActivate()
{
  UpdatePropPage();
  return S_OK;
}

HRESULT CAviMuxProp1::OnDeactivate()
{
    // Remember values for next Activate() call
    UpdateValues();
    return S_OK;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CAviMuxProp1::OnDisconnect()
{

  if(m_pCfgAvi == 0)
    return E_UNEXPECTED;

  m_pCfgAvi->Release();
  m_pCfgAvi = 0;

  return S_OK;
}

INT_PTR CAviMuxProp1::OnReceiveMessage(
  HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  UNREFERENCED_PARAMETER(lParam);
  switch (uMsg) {

    case WM_INITDIALOG:
      break;

    case WM_COMMAND:
      switch (LOWORD(wParam)) {
        case IDC_AVIMUX_EDIT_MASTER_STREAM:
        {
          int iNotify = HIWORD (wParam);
          if (iNotify == EN_KILLFOCUS)
          {
            HWND hButtonWnd = ::GetDlgItem(hwnd, IDC_AVIMUX_ENABLEFIXUPRATES);
            BOOL fMasterStream = ::SendMessage(hButtonWnd, BM_GETCHECK, 0, 0) == BST_CHECKED;
            Edit_Enable(GetDlgItem(hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM), fMasterStream);
            if(fMasterStream)
            {
              BOOL fOK;
              int iStream = GetDlgItemInt (hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM, &fOK, FALSE);
              m_pCfgAvi->SetMasterStream(iStream);
              SetDirty();
            }
          }
        };
        break;

        case IDC_AVIMUX_ENABLEFIXUPRATES:
        {
          HWND hButtonWnd = ::GetDlgItem(hwnd, IDC_AVIMUX_ENABLEFIXUPRATES);
          BOOL fMasterStream = ::SendMessage(hButtonWnd, BM_GETCHECK, 0, 0) == BST_CHECKED;
          Edit_Enable(GetDlgItem(hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM), fMasterStream);
          if(fMasterStream)
          {
            BOOL fOK;
            int iStream = GetDlgItemInt (hwnd, IDC_AVIMUX_EDIT_MASTER_STREAM, &fOK, FALSE);
            HRESULT hr = m_pCfgAvi->SetMasterStream(iStream);
            // !!! what to do on failure.
          }
          else
          {
            HRESULT hr = m_pCfgAvi->SetMasterStream(-1);
            ASSERT(hr == S_OK);
          }

          SetDirty();
        };
        break;

        case IDC_AVIMUX_CHECK_OLDINDEX:
        {
          HWND hButtonWnd = ::GetDlgItem(hwnd, IDC_AVIMUX_CHECK_OLDINDEX);
          BOOL fOldIndex = ::SendMessage(hButtonWnd, BM_GETCHECK, 0, 0) == BST_CHECKED;
          HRESULT hr = m_pCfgAvi->SetOutputCompatibilityIndex(fOldIndex);
          ASSERT(hr == S_OK);
          SetDirty();
        };
        break;
      }
      break;

    default:
      return FALSE;

  }
  return TRUE;
}

void
CAviMuxProp1::SetDirty()
{
  m_bDirty = TRUE;
  if(m_pPageSite)
    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

HRESULT CAviMuxProp1::OnApplyChanges()
{
  UpdateValues();
  return S_OK;
}

HRESULT CAviDest::WriteToStream(IStream *pStream)
{
    PersistVal pv;
    pv.dwcb = sizeof(pv);
    HRESULT hr = S_OK;
    if((hr = get_Mode(&pv.mode), SUCCEEDED(hr)) &&
       (hr = get_Interleaving(&pv.rtInterleave, &pv.rtPreroll), SUCCEEDED(hr)) &&
       (hr = GetMasterStream(&pv.iMasterStream), SUCCEEDED(hr)) &&
       (hr = GetOutputCompatibilityIndex(&pv.fOldIndex), SUCCEEDED(hr)))
    {
        hr = pStream->Write(&pv, sizeof(pv), 0);
    }

    return hr;
}

HRESULT CAviDest::ReadFromStream(IStream *pStream)
{
  PersistVal pv;
  HRESULT hr = S_OK;

  hr = pStream->Read(&pv, sizeof(pv), 0);
  if(FAILED(hr))
    return hr;

  if(pv.dwcb != sizeof(pv))
      return VFW_E_INVALID_FILE_VERSION;


  hr = put_Mode(pv.mode);
  if(SUCCEEDED(hr))
  {
    hr = put_Interleaving(&pv.rtInterleave, &pv.rtPreroll);
    if(SUCCEEDED(hr))
    {
      hr = SetMasterStream(pv.iMasterStream);

      if(SUCCEEDED(hr))
      {
        hr = SetOutputCompatibilityIndex(pv.fOldIndex);

      }
    }
  }

   return hr;
}

int CAviDest::SizeMax()
{
    return sizeof(PersistVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimux\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by avidest.rc

// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
#define IDS_AVIMUXPROPNAME              801
#define IDD_DIALOG_AVIMUX               802
#define IDS_AVIMUXPROPNAME1             802
#define IDC_AVIMUX_RADIO_NONE           803
#define IDD_DIALOG_AVIMUX1              803
#define IDC_AVIMUX_RADIO_CAPTURE        804
#define IDC_AVIMUX_RADIO_FULL           805
#define IDC_AVIMUX_LIST1                806
#define IDC_AVIMUX_RADIO_NONE_BUFF      806
#define IDC_AVIMUX_EDIT_INTERLEAVING    807
#define IDC_AVIMUX_EDIT_PREROLL         808
#define IDC_AVIMUX_FRAMES_DROPPED       811
#define IDC_AVIMUX_EDIT_FIXUPRATES      812
#define IDC_AVIMUX_ENABLEFIXUPRATES     813
#define IDC_AVIMUX_EDIT_MASTER_STREAM   814
#define IDC_AVIMUX_CHECK_OLDINDEX       815
#define IDC_AVIMUX_BYTES_WRITTEN        817
#define IDC_AVIMUX_CURRENT_POS          818
#define IDC_AVIMUX_DURATION             819

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        811
#define _APS_NEXT_COMMAND_VALUE         810
#define _APS_NEXT_CONTROL_VALUE         820
#define _APS_NEXT_SYMED_VALUE           812
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimux\aviwrite.cpp ===
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>

#include <limits.h>
#include "AviWrite.h"
#include "alloc.h"

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#ifdef DEBUG
#define DEBUG_EX(x) x
#else
#define DEBUG_EX(x)
#endif

// AVI prefix. each frame is preceded by a fourcc stream id and a
// DWORD size
static const unsigned CB_AVI_PREFIX = sizeof(RIFFCHUNK);

// the fourcc JUNK and the size (padding used to align the next chunk
// on a sector boundary).
static const unsigned CB_AVI_SUFFIX = 2 * sizeof(FOURCC);

// default size of super and sub indexes. sub index is rounded up to
// sector alignment for capture files. both are rounded down for
// interleaved files.
static const ULONG C_ENTRIES_SUPERINDEX = 2000;// 16 bytes each
static const ULONG C_ENTRIES_SUBINDEX = 4000; // 8 bytes each

// create a new RIFF chunk after this many bytes (+ a sample chunk and
// an index chunk). used if registry entry is not there.
static const ULONG CB_RIFF_MAX = 0x3fffffff;

// space to allow for sample chunk and index chunk above.
static const ULONG CB_NEW_RIFF_PADDING = 1024 * 1024 * 4;

static const ULONG CB_HEADER_JUNK = 0;

static const ULONG CB_BUFFER = 512 * 1024;
static const ULONG C_BUFFERS = 3;

static const BOOL g_B_OUTPUT_IDX1 = TRUE;
static const BOOL g_B_DROPPED_FRAMES = TRUE;

static const ULONG CB_SUBINDEX_OVERFLOW = MAXDWORD;

#define CB_ILEAVE_BUFFER (64 * 1024)

static inline unsigned int WFromHexrg2b(BYTE* rgb)
{
  unsigned high, low;

  low  = rgb[1] <= '9' && rgb[1] >= '0' ? rgb[1] - '0' : rgb[1] - 'A' + 0xa;
  high = rgb[0] <= '9' && rgb[0] >= '0' ? rgb[0] - '0' : rgb[0] - 'A' + 0xa;

  ASSERT((rgb[1] <= '9' && rgb[1] >= '0') || (rgb[1] <= 'F' && rgb[1] >= 'A'));
  ASSERT((rgb[0] <= '9' && rgb[0] >= '0') || (rgb[0] <= 'F' && rgb[0] >= 'A'));

  ASSERT(high <= 0xf && low <= 0xf);

  return low + 16 * high;
}

static inline void Hexrg2bFromW(BYTE *rgbDest_, unsigned int wSrc_)
{
  ASSERT(wSrc_ <= 255);
  unsigned high = wSrc_ / 16, low = wSrc_ % 16;
  ASSERT(high <= 0xf && low <= 0xf);

  rgbDest_[1] = (BYTE)(low  <= 9 ? low  + '0' : low - 0xa  + 'A');
  rgbDest_[0] = (BYTE)(high <= 9 ? high + '0' : high -0xa + 'A');

  ASSERT((rgbDest_[1] <= '9' && rgbDest_[1] >= '0') ||
         (rgbDest_[1] <= 'F' && rgbDest_[1] >= 'A'));
  ASSERT((rgbDest_[0] <= '9' && rgbDest_[0] >= '0') ||
         (rgbDest_[0] <= 'F' && rgbDest_[0] >= 'A'));
}

static inline DWORD AlignUp(DWORD dw, DWORD dwAlign) {
  // align up: round up to next boundary
  return (dw + (dwAlign -1)) & ~(dwAlign -1);
};

// return # bytes needed to hold a super index with cEntries entries
static inline const ULONG cbSuperIndex(ULONG cEntries)
{
  const cbIndex = FIELD_OFFSET(AVISUPERINDEX, aIndex);
  return cbIndex + sizeof(AVISUPERINDEX::_avisuperindex_entry) * cEntries;
}

// return # bytes needed to hold a sub-index with cEntries
// entries. caller may want to align up
static inline const ULONG cbSubIndex(ULONG cEntries)
{
  const cbIndex = FIELD_OFFSET(AVISTDINDEX, aIndex);
  return cbIndex + sizeof(_avistdindex_entry) * cEntries;
}

// return # of entries that can be put in sub index with size = cb
// bytes
static const ULONG cEntriesSubIndex(ULONG cb)
{
  const cbIndex = FIELD_OFFSET(AVISTDINDEX, aIndex);
  cb -= cbIndex;
  return cb / sizeof(_avistdindex_entry);
}

static const ULONG cEntriesSuperIndex(ULONG cb)
{
  const cbIndex = FIELD_OFFSET(AVISUPERINDEX, aIndex);
  cb -= cbIndex;
  return cb / sizeof(AVISUPERINDEX::_avisuperindex_entry);
}

// ------------------------------------------------------------------------
// constructor

CAviWrite::CAviWrite(HRESULT *phr) :
    m_lActiveStreams(NAME("aviwrite.cpp active stream list")),
    m_pIStream(0),
    m_IlMode(INTERLEAVE_NONE),
    m_rtAudioPreroll(0),
    m_rtInterleaving(UNITS),
    m_pIMemInputPin(0),
    m_pSampAlloc(0),
    m_cDroppedFrames(0),
    m_rgbIleave(0),
    m_lMasterStream(-1)
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviWrite::CAviWrite")));
  // these are saved across Initialize() Close() pairs
  m_cbAlign = 0;
  m_cbPrefix = m_cbSuffix = 0;

  // pointers to allocated memory
  m_pAllocator = 0;
  m_rgbHeader = 0;
  m_rgpStreamInfo = 0;
  m_rgbJunkSectors = 0;
  m_cStreams = 0;

#ifdef PERF
  m_idPerfDrop = Msr_Register("aviwrite drop frame written");
#endif // PERF

  // the rest
  Cleanup();

  if(FAILED(*phr))
    return;

  *phr = InitializeOptions();
  if(FAILED(*phr))
    return;

}

// ------------------------------------------------------------------------
// cleanup values that should not be saved across a stop -> pause/run
// -> stop transition.

void CAviWrite::Cleanup()
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviWrite::Cleanup")));
  m_dwlFilePos = 0;
  m_dwlCurrentRiffAvi_ = 0;
  m_cOutermostRiff = 0;
  m_cIdx1Entries = 0;
  ASSERT(m_lActiveStreams.GetCount() == 0);
  m_bInitialized = FALSE;

  m_pAvi_ = m_pHdrl = 0;
  m_pAvih = 0;
  m_pOdml = 0;
  m_pDmlh = 0;
  m_pMovi = 0;
  m_posIdx1 = 0;
  m_cbIdx1 = 0;
  m_posFirstIx = 0;
  m_bSawDeltaFrame = false;

  delete[] m_rgbJunkSectors;
  m_rgbJunkSectors = 0;

  delete[] m_rgbIleave;
  m_rgbIleave = 0;

  delete[] m_rgbHeader;
  m_rgbHeader = 0;
  for(UINT i = 0; i < m_cStreams; i++)
    delete m_rgpStreamInfo[i];
  m_cStreams = 0;
  delete[] m_rgpStreamInfo;
  m_rgpStreamInfo = 0;

  // this is the allocator for index chunks
  if(m_pAllocator != 0)
  {
    m_pAllocator->Decommit();
    m_pAllocator->Release();
    m_pAllocator = 0;
  }
}

CAviWrite::~CAviWrite()
{
  DbgLog((LOG_TRACE, 10, TEXT("CAviWrite::~CAviWrite")));
  Cleanup();

  ASSERT(m_pIStream == 0);
  ASSERT(m_pIMemInputPin == 0);
  if(m_pSampAlloc)
    m_pSampAlloc->Release();
}


// ------------------------------------------------------------------------
// initialize (on stop->pause transition). creates the file, writes
// out space for the AVI header, prepares to stream. SetFilename needs
// to have been called

HRESULT CAviWrite::Initialize(
  int cPins,
  AviWriteStreamConfig *rgAwsc,
  IMediaPropertyBag *pPropBag)
{
  HRESULT hr;

  Cleanup();

  DEBUG_EX(m_dwTimeInit = GetTickCount());
  ASSERT(m_cStreams == 0 &&
         m_rgpStreamInfo == 0 &&
         m_rgbHeader == 0 &&
         !m_bInitialized);

  if(cPins > C_MAX_STREAMS)
    return E_INVALIDARG;

  m_rgpStreamInfo = new StreamInfo*[cPins];
  if(m_rgpStreamInfo == 0)
    return E_OUTOFMEMORY;

  m_cDroppedFrames = 0;
  ASSERT(m_cStreams == 0);

  m_cEntriesMaxSuperIndex = cEntriesSuperIndex(
      AlignUp(cbSuperIndex(C_ENTRIES_SUPERINDEX), m_cbAlign));

  m_cEntriesMaxSubIndex = cEntriesSubIndex(
      AlignUp(cbSubIndex(C_ENTRIES_SUBINDEX), m_cbAlign));

  ASSERT(cbSubIndex(m_cEntriesMaxSubIndex) % m_cbAlign == 0);
  ASSERT(cbSuperIndex(m_cEntriesMaxSuperIndex) % m_cbAlign == 0);


  // create the pin -> stream mapping
  for(int i = 0; i < cPins; i++)
  {
    hr = S_OK;
    if(rgAwsc[i].pmt != 0)
    {
      m_mpPinStream[i] = m_cStreams;
      if(rgAwsc[i].pmt->majortype == MEDIATYPE_Audio &&
         m_IlMode != INTERLEAVE_FULL)
      {
        m_rgpStreamInfo[m_cStreams] =
          new CAudioStream(m_cStreams, i, &rgAwsc[i], this, &hr);
        // error checked below
      }
      else if(rgAwsc[i].pmt->majortype == MEDIATYPE_Audio &&
              m_IlMode == INTERLEAVE_FULL)
      {
        m_rgpStreamInfo[m_cStreams] =
          new CAudioStreamI(m_cStreams, i, &rgAwsc[i], this, &hr);
        // error checked below
      }
      else if(rgAwsc[i].pmt->majortype == MEDIATYPE_Video &&
              rgAwsc[i].pmt->formattype == FORMAT_VideoInfo)
      {
        m_rgpStreamInfo[m_cStreams] =
          new CVideoStream(m_cStreams, i, &rgAwsc[i], this, &hr);
        // error checked below
      }
      else
      {
        m_rgpStreamInfo[m_cStreams] =
          new CFrameBaseStream(m_cStreams, i, &rgAwsc[i], this, &hr);
        // error checked below
      }

      if(m_rgpStreamInfo[m_cStreams] == 0)
      {
        Cleanup();
        return E_OUTOFMEMORY;
      }
      if(FAILED(hr))
      {
        delete m_rgpStreamInfo[m_cStreams];
        m_rgpStreamInfo[m_cStreams] = 0;

        Cleanup();
        return hr;
      }

      m_cStreams++;
    }
  }

  // note that m_bInitialized is false if there are zero streams
  if(m_cStreams == 0)
    return S_OK;

  if((ULONG)m_lMasterStream >= m_cStreams && m_lMasterStream != -1)
  {
    DbgLog((LOG_ERROR, 1, TEXT("avimux: invalid master stream")));
    Cleanup();
    return E_INVALIDARG;
  }

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pSi = m_rgpStreamInfo[iStream];
    pSi->ComputeAndSetIndexSize();
  }


  if(hr = InitializeHeader(pPropBag), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::Initialize:: InitializeHeader failed.")));
    Cleanup();
    return hr;
  }

  if(hr = InitializeIndex(), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::Initialize:: InitializeIndex failed.")));
    Cleanup();
    return hr;
  }

  if(hr = InitializeInterleaving(), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::Initialize:: Interleaving failed.")));
    Cleanup();
    return hr;
  }

  //
  // setup junk chunks. if a sample delivered ends between 2 and 6
  // bytes before the end of the allocated buffer, we need to write
  // another sample with bits of the junk chunk.
  //
  if(m_cbAlign > 2)
  {
    // !!! don't allocator memory if all streams use our allocator
    delete[] m_rgbJunkSectors;
    m_rgbJunkSectors = new BYTE[m_cbAlign * 4];
    if(m_rgbJunkSectors == 0)
    {
      Cleanup();
      return E_OUTOFMEMORY;
    }
    ZeroMemory(m_rgbJunkSectors, m_cbAlign * 4);

    m_rgpbJunkSector[0] =
      (BYTE*)((DWORD_PTR) (m_rgbJunkSectors + m_cbAlign - 1) & ~((DWORD_PTR)m_cbAlign - 1));

    m_rgpbJunkSector[0][0] = 'N';
    m_rgpbJunkSector[0][1] = 'K';
    *(UNALIGNED DWORD *)&(m_rgpbJunkSector[0][2]) = m_cbAlign - 2 - sizeof(DWORD);

    m_rgpbJunkSector[1] = m_rgpbJunkSector[0] + m_cbAlign;
    *(DWORD *)m_rgpbJunkSector[1] = m_cbAlign - sizeof(DWORD);

    m_rgpbJunkSector[2] = m_rgpbJunkSector[1] + m_cbAlign;
    *(WORD *)m_rgpbJunkSector[2] = (WORD)(((m_cbAlign - 2) >> 16) & 0xffff);
  }

  if(m_IlMode == INTERLEAVE_FULL)
  {
      ASSERT(m_cbAlign == 1);

      m_rgbIleave = new BYTE[CB_ILEAVE_BUFFER];
      if(m_rgbIleave == 0)
      {
          Cleanup();
          return E_OUTOFMEMORY;
      }
      m_ibIleave = 0;
      m_dwlIleaveOffset = 0;

      ASSERT(m_pIStream == 0);

      hr = m_pIMemInputPin->QueryInterface(
          IID_IStream, (void **)&m_pIStream);
      if(FAILED(hr)) {
          Cleanup();
          return hr;
      }
  }

  DEBUG_EX(m_dwTimeInited = GetTickCount());

  m_bInitialized = TRUE;
  return S_OK;
}

HRESULT CAviWrite::Connect(CSampAllocator *pAlloc, IMemInputPin *pInPin)
{
  m_pSampAlloc = pAlloc;
  pAlloc->AddRef();

  m_pIMemInputPin = pInPin;
  m_pIMemInputPin->AddRef();

  ASSERT(m_pIStream == 0);

  return S_OK;
}

HRESULT CAviWrite::Disconnect()
{
  if(m_pIStream)
    m_pIStream->Release();
  m_pIStream = 0;
  if(m_pIMemInputPin)
    m_pIMemInputPin->Release();
  m_pIMemInputPin = 0;

  if(m_pSampAlloc)
    m_pSampAlloc->Release();
  m_pSampAlloc = 0;

  return S_OK;
}

// ------------------------------------------------------------------------
// finish writing the file, update the index, write the header, close
// the file and reset so that Initialize can be called again

HRESULT CAviWrite::Close()
{
  HRESULT hrIStream = S_OK;
  HRESULT hr = S_OK;
  if(m_pIStream == 0)
  {
    hrIStream = m_pIMemInputPin->QueryInterface(IID_IStream, (void **)&m_pIStream);
    if(FAILED(hrIStream))
    {
      DbgLog((LOG_ERROR, 1, ("aviwrite: couldn't get istream. !!! unhandled")));
      // do some small amount of clean up then return
    }
  }

  DEBUG_EX(m_dwTimeClose = GetTickCount());

  CAutoLock lock(&m_cs);

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pSi = m_rgpStreamInfo[iStream];
    pSi->EmptyQueue();

    if(!pSi->m_fEosSeen)
    {
       // will not block because we just emptied the queue
       hr = EndOfStream(pSi);
    }
  }

  if(FAILED(hrIStream))
    return hrIStream;
  if(FAILED(hr)) {
    return hr;
  }

  if(m_bInitialized)
  {
    DEBUG_EX(m_dwTimeStopStreaming = GetTickCount());

    hr = CloseHeader();
    if(FAILED(hr))
      DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Close: CloseHeader failed.")));

    HRESULT hrTmp = IStreamWrite(0, m_rgbHeader, m_posFirstIx);
    if(FAILED(hrTmp))
      DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Close: Write failed.")));

    hr = FAILED(hr) ? hr : hrTmp;

    // null terminate file if we didn't truncate the data
    RIFFCHUNK rc;
    if(SUCCEEDED(hr))
    {
      // test for someone elses data after our data
      hr = IStreamRead(m_dwlFilePos, (BYTE*) &rc, 1);
      if(SUCCEEDED(hr))
      {
        rc.fcc = 0;
        rc.cb = 0;
        hr = IStreamWrite(
          m_dwlFilePos,
          (BYTE*)&rc,
          sizeof(RIFFCHUNK));
      }
      else
      {
        hr = S_OK;
      }
    }
  }

  DEBUG_EX(m_dwTimeClosed = GetTickCount());

#ifdef DEBUG
  if(m_dwTimeStopStreaming != m_dwTimeFirstSample)
  {
    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeInit:          %9d"),
            m_dwTimeInit - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeInited:        %9d"),
            m_dwTimeInited - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeFirstSample:   %9d"),
            m_dwTimeFirstSample - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeClose:         %9d"),
            m_dwTimeClose - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeStopStreaming: %9d"),
            m_dwTimeStopStreaming - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("m_dwTimeClosed:        %9d"),
            m_dwTimeClosed - m_dwTimeInit));

    DbgLog((LOG_TRACE, 2, TEXT("mb streamed:           %9d"),
            (LONG)((m_dwlFilePos - m_posFirstIx) / (1024 * 1024) )));

    DbgLog((LOG_TRACE, 2, TEXT("~rate, k/s:            %9d"), (long)
            ((m_dwlFilePos - m_posFirstIx) /
             (m_dwTimeStopStreaming - m_dwTimeFirstSample))));
  }

#endif // DEBUG

  ULARGE_INTEGER uli;
  uli.QuadPart = 0;
  if(hr == HRESULT_FROM_WIN32(ERROR_EMPTY)) {
      m_pIStream->SetSize(uli);
      hr = S_OK;
  }

  // release so that the file can be closed.
  m_pIStream->Release();
  m_pIStream = 0;

  // hold on to IMemInputPin until the pin is disconnected
  ASSERT(m_pIMemInputPin);
  // !!! send EOS

  m_bInitialized = FALSE;
  return hr;
}

HRESULT CAviWrite::IStreamWrite(DWORDLONG dwlFilePos, BYTE *pb, ULONG cb)
{
  HRESULT hr = S_OK;

  if(m_IlMode == INTERLEAVE_FULL && m_ibIleave != 0) {
      hr = FlushILeaveWrite();
  }

  LARGE_INTEGER offset;
  offset.QuadPart = dwlFilePos;
  ASSERT(CritCheckIn(&m_cs));
  if(SUCCEEDED(hr)) {
      hr = m_pIStream->Seek(offset, STREAM_SEEK_SET, 0);
  }
  if(hr == S_OK) {
    hr = m_pIStream->Write(pb, cb, 0);
  }
  return hr;
}

HRESULT CAviWrite::IStreamRead(DWORDLONG dwlFilePos, BYTE *pb, ULONG cb)
{
    HRESULT hr = S_OK;
    if(m_IlMode == INTERLEAVE_FULL && m_ibIleave != 0) {
        hr = FlushILeaveWrite();
    }

    LARGE_INTEGER offset;
    offset.QuadPart = dwlFilePos;
    ASSERT(CritCheckIn(&m_cs));
    if(SUCCEEDED(hr )) {
        hr = m_pIStream->Seek(offset, STREAM_SEEK_SET, 0);
    }
    if(hr == S_OK) {
        hr = m_pIStream->Read(pb, cb, 0);
    }

    return hr;
}

HRESULT CAviWrite::HandleFormatChange(
  StreamInfo *pStreamInfo,
  const AM_MEDIA_TYPE *pmt)
{
  // CBaseInputPin::Receive only calls CheckMediaType, so it doesn't
  // check the additional constraints put on on-the-fly format changes
  // (handled through QueryAccept).
  HRESULT hr = QueryAccept(pStreamInfo->m_pin, pmt);

  // upstream filter should have checked
  ASSERT(hr == S_OK);

  if(hr == S_OK)
  {
    pStreamInfo->m_mt = *pmt;
    ASSERT(pmt->pbFormat);      // from QueryAccept;
    ASSERT(((RIFFCHUNK *)(m_rgbHeader + pStreamInfo->m_posStrf))->cb ==
           pmt->cbFormat);      // from QueryAccept;
    CopyMemory(
      m_rgbHeader + pStreamInfo->m_posStrf + sizeof(RIFFCHUNK),
      pmt->pbFormat,
      pmt->cbFormat);
  }

  return hr;
}


// ------------------------------------------------------------------------
// pass our memory requirements up to the caller

void CAviWrite::GetMemReq(ULONG *pAlignment, ULONG *pcbPrefix, ULONG *pcbSuffix)
{
  // get our minimum requirements from file object
  ALLOCATOR_PROPERTIES memReq;
  HRESULT hr = m_pSampAlloc->GetProperties(&memReq);
  ASSERT(hr == S_OK);
  *pAlignment = memReq.cbAlign;
  *pcbPrefix = 0;
  *pcbSuffix = 0;

  DbgLog((LOG_TRACE, 10,
          TEXT("CAviWrite::GetMemReq: got alignment of %d"), memReq.cbAlign));

  if(m_IlMode != INTERLEAVE_FULL)
  {
      // our requirements: add space for RIFF chunk header; Quartz
      // allocators support prefixes
      *pcbPrefix += CB_AVI_PREFIX;

      // this is the wrong place to do this
      //   // need things in multiples of two bytes (RIFF requirement)
      //   if(*pAlignment < sizeof(WORD))
      //     *pAlignment = sizeof(WORD);

      // if using our allocator, we can reserve a suffix for a JUNK chunk
      // needed when we add space to align writes
      *pcbSuffix = CB_AVI_SUFFIX;
  }
  else
  {
      ASSERT(memReq.cbAlign == 1);
  }

  // save our requirements
  m_cbAlign = *pAlignment;
  m_cbPrefix = *pcbPrefix;
  m_cbSuffix = *pcbSuffix;
}

inline void CAviWrite::DbgCheckFilePos()
{
#ifdef DEBUG
//   DWORDLONG ibFileActual;
//   HRESULT hr = (m_pFile->StreamingGetFilePointer(&ibFileActua
//   ASSERT(SUCCEEDED(hr));
//   ASSERT(ibFileActual == m_dwlFilePos);
#endif // DEBUG
}



// ------------------------------------------------------------------------
// process incoming samples.
//

HRESULT CAviWrite::Receive(
    int pinNum,
    IMediaSample *pSample,
    const AM_SAMPLE2_PROPERTIES *pSampProp)
{
  HRESULT hr;
  ASSERT(pinNum < C_MAX_STREAMS);
  ASSERT(m_cStreams != 0);
  ASSERT(m_lActiveStreams.GetCount() != 0);

  REFERENCE_TIME rtStart, rtEnd;
  hr = pSample->GetTime(&rtStart, &rtEnd);
  if(FAILED(hr))
  {
      // signal error if time stamps not set. ks devices unfortunately
      // send zero byte samples with no time stamps, so don't signal
      // errors for those.
      return pSampProp->lActual == 0 ? S_OK : hr;
  }

#if  defined(DEBUG) || defined(PERF)
  REFERENCE_TIME mtStart = 0, mtEnd = 0;
  pSample->GetMediaTime(&mtStart, &mtEnd);

  DbgLog((LOG_TIMING, 2, TEXT("avi mux: pin %d - time : %d-%d, mttime %d-%d"),
          pinNum,
          (long)(rtStart / (UNITS / MILLISECONDS)),
          (long)(rtEnd / (UNITS / MILLISECONDS)),
          (long)(mtStart),
          (long)(mtEnd),
          pinNum));

#endif

  // upstream filter will send us negative time stamps if it prerolls
  // more quickly than allowed
  if(rtEnd < 0)
    return S_OK;

  StreamInfo *pStreamInfo = m_rgpStreamInfo[m_mpPinStream[pinNum]];
  //MSR_START(pStreamInfo->m_idPerfReceive);
  MSR_INTEGER(pStreamInfo->m_idPerfReceive, (LONG)(rtStart / (UNITS / MILLISECONDS)));
  MSR_INTEGER(pStreamInfo->m_idPerfReceive, (LONG)(mtStart));

  if(pSampProp->dwSampleFlags & AM_SAMPLE_TYPECHANGED)
  {
      hr = HandleFormatChange(pStreamInfo, pSampProp->pMediaType);
      if(FAILED(hr)) {
          return hr;
      }
  }

  hr = pStreamInfo->AcceptRejectSample(pSample);
  if(hr == S_OK)
  {

      if(m_IlMode == INTERLEAVE_NONE || m_IlMode == INTERLEAVE_NONE_BUFFERED)
      {
          hr = pStreamInfo->WriteSample(pSample);
      }
      else
      {
          if(m_IlMode == INTERLEAVE_FULL) {
              hr = BlockReceive(pStreamInfo);
          }
          if(SUCCEEDED(hr))
          {
              DbgLog((LOG_TRACE, 15, TEXT("CAviWrite: stream %d. queueing sample %08x"),
                      m_mpPinStream[pinNum], pSample));

              CCopiedSample *pcs = 0;

              if(m_IlMode == INTERLEAVE_FULL)
              {
                  REFERENCE_TIME mts, mte;
                  HRESULT hrGetMt = pSample->GetMediaTime(&mts, &mte);
                  pcs = new CCopiedSample(
                      pSampProp,
                      SUCCEEDED(hrGetMt) ? &mts : 0,
                      SUCCEEDED(hrGetMt) ? &mte : 0,
                      &hr);
                  if(pcs) {
                      pcs->AddRef();
                  } else {
                      hr = E_OUTOFMEMORY;
                  }
              }
              if(SUCCEEDED(hr))
              {
                  CAutoLock lock(&m_cs);
                  if(!pStreamInfo->m_fEosSeen)
                  {
                      IMediaSample *pmsTmp = m_IlMode == INTERLEAVE_FULL ? pcs : pSample;
                      if(pStreamInfo->m_lIncoming.AddTail(pmsTmp))
                      {
                          pmsTmp->AddRef();
                          // this can block as it calls Receive() downstream
                          hr = ScheduleWrites();
                      }
                      else
                      {
                          hr = E_OUTOFMEMORY;
                      }
                  }
                  else          // EOS
                  {
                      hr = S_FALSE;
                  }
              }
              if(pcs) {
                  pcs->Release();
              }
          }
      }
  }
  else if(hr == S_FALSE)
  {
      hr = S_OK;
  }
  //MSR_STOP(pStreamInfo->m_idPerfReceive);
  return hr;
}

// accept only audio changes(it can happen in audio only or video-audio interleaved stream) that change the sampling rate for DV if
// no samples have been received. should be possible to accept any
// change that does not grow the format chunk.
HRESULT CAviWrite::QueryAccept(
    int pinNum,
    const AM_MEDIA_TYPE *pmt)
{
  CAutoLock lock(&m_cs);
  HRESULT hr = S_FALSE;
  StreamInfo *pStreamInfo = m_rgpStreamInfo[m_mpPinStream[pinNum]];
  if(pStreamInfo->m_cSamples == 0)
  {
    if(pStreamInfo->m_mt.majortype == MEDIATYPE_Audio &&
       pmt->majortype == MEDIATYPE_Audio &&
       pmt->formattype == FORMAT_WaveFormatEx &&
       pStreamInfo->m_mt.cbFormat == pmt->cbFormat)
    {
	hr = S_OK;
    }
    else if(pStreamInfo->m_mt.majortype == MEDIATYPE_Interleaved &&
       pmt->majortype == MEDIATYPE_Interleaved &&
       pmt->formattype == FORMAT_DvInfo &&
       pStreamInfo->m_mt.cbFormat == pmt->cbFormat &&
       pmt->pbFormat   != NULL)
    {
      hr = S_OK;
    }

  }

  return hr;
}


// ------------------------------------------------------------------------
// if interleaving, unblock another stream

HRESULT CAviWrite::EndOfStream(int pinNum)
{
  ASSERT(pinNum < C_MAX_STREAMS);
  ASSERT(m_cStreams != 0);
  ASSERT(m_lActiveStreams.GetCount() != 0);
  return EndOfStream(m_rgpStreamInfo[m_mpPinStream[pinNum]]);
}

// don't use nulls for EOS on list to avoid confusion with list apis
// returning null meaning empty list.
#define INCOMING_EOS_SAMPLE ((IMediaSample *)1)

HRESULT CAviWrite::EndOfStream(StreamInfo *pStreamInfo)
{
  CAutoLock lock(&m_cs);
  if(pStreamInfo->m_fEosSeen)
  {
    DbgBreak("CAviWrite::EndOfStream: EOS twice");
    return E_UNEXPECTED;
  }

  if(m_IlMode == INTERLEAVE_NONE)
  {
    m_lActiveStreams.Remove(pStreamInfo->m_posActiveStream);
    pStreamInfo->m_fEosSeen = TRUE;
    return S_OK;
  }
  else
  {
      if(pStreamInfo->m_lIncoming.AddTail(INCOMING_EOS_SAMPLE)) {
          return ScheduleWrites();
      } else {
          return E_OUTOFMEMORY;
      }
  }
}

HRESULT CAviWrite::put_Mode(InterleavingMode mode)
{
  InterleavingMode oldMode = m_IlMode;

  if(mode != INTERLEAVE_NONE &&
     mode != INTERLEAVE_CAPTURE &&
     mode != INTERLEAVE_FULL &&
     mode != INTERLEAVE_NONE_BUFFERED)
    return E_INVALIDARG;

  m_IlMode = mode;

  return S_OK;
}

HRESULT CAviWrite::get_Mode(InterleavingMode *pMode)
{
  *pMode = m_IlMode;
  return S_OK;
}

HRESULT CAviWrite::put_Interleaving(
    const REFERENCE_TIME *prtInterleave,
    const REFERENCE_TIME *prtAudioPreroll)
{
  if(*prtInterleave == 0)
    return E_INVALIDARG;

  m_rtInterleaving = *prtInterleave;
  m_rtAudioPreroll = *prtAudioPreroll;
  return S_OK;
}

HRESULT CAviWrite::get_Interleaving(
  REFERENCE_TIME *prtInterleave,
  REFERENCE_TIME *prtAudioPreroll)
{
  *prtInterleave = m_rtInterleaving;
  *prtAudioPreroll = m_rtAudioPreroll;
  return S_OK;
}

HRESULT CAviWrite::SetIgnoreRiff(BOOL fNoRiff)
{
  return E_NOTIMPL;
}

HRESULT CAviWrite::GetIgnoreRiff(BOOL *pfNoRiff)
{
  return E_NOTIMPL;
}

HRESULT CAviWrite::SetOutputCompatibilityIndex(BOOL fOldIndex)
{
  m_bOutputIdx1 = fOldIndex;
  return S_OK;
}

HRESULT CAviWrite::GetOutputCompatibilityIndex(BOOL *pfOldIndex)
{
  *pfOldIndex = m_bOutputIdx1;
  return S_OK;
}

HRESULT CAviWrite::SetMasterStream(LONG iStream)
{
  DbgLog((LOG_TRACE, 5, TEXT("CAviWrite::SetMasterStream: %i"), iStream));
  m_lMasterStream = iStream;
  return S_OK;
}

HRESULT CAviWrite::GetMasterStream(LONG *pStream)
{
  *pStream = m_lMasterStream;
  return S_OK;
}

// block Receive to keep m_lIncoming from growing indefinitely and
// using too much memory. This would happen if this stream is
// producing data at a slower rate than another.
//
HRESULT CAviWrite::BlockReceive(StreamInfo *pStreamInfo)
{
  HRESULT hr = S_OK;

  while(SUCCEEDED(hr))
  {
    bool fWait = false;
    {
      CAutoLock l(&m_cs);

      if(pStreamInfo->m_fEosSeen) {
          break;
      }

      ASSERT(m_lActiveStreams.GetCount());

      // don't block if we're the only stream or this stream only has a
      // few samples on it.
      if(m_lActiveStreams.GetCount() > 1 &&
         pStreamInfo->m_lIncoming.GetCount() > 10)
      {
        // make sure the time stamps span at least 3x the interleaving
        // amount. !!! not a good way to do this because logic can be
        // fooled by drop frames. We are trying to avoid allocating
        // lots of memory on the list, but if there's 3 seconds worth
        // of dropped frames on this list, this code will fire.

        IMediaSample *psStart = pStreamInfo->m_lIncoming.GetHead();
        IMediaSample *psEnd = pStreamInfo->m_lIncoming.Get(
            pStreamInfo->m_lIncoming.GetTailPosition());

        REFERENCE_TIME rtsFirst, rteLast, rtScratch;
        HRESULT hr = psStart->GetTime(&rtsFirst, &rtScratch);
        ASSERT(hr == S_OK);         // checked in receive
        hr = psEnd->GetTime(&rtScratch, &rteLast);
        ASSERT(hr == S_OK);         // checked in receive

        ASSERT(rtsFirst < rteLast);
        if(rteLast - rtsFirst > m_rtInterleaving * 3 &&
           rteLast - rtsFirst > UNITS)
        {
            DbgLog((LOG_TRACE, 15, TEXT("blocking %d, samples queued = %d, %dms"),
                    pStreamInfo->m_stream, pStreamInfo->m_lIncoming.GetCount(),
                    (LONG)((rteLast - rtsFirst) / (UNITS / MILLISECONDS))));
          fWait = true;
        }
      }
    } // critsec

    if(fWait)
    {
      EXECUTE_ASSERT(m_evBlockReceive.Wait());
    }
    else
    {
      break;
    }
  }

  return hr;
}

HRESULT CAviWrite::ScheduleWrites()
{
  ASSERT(m_IlMode != INTERLEAVE_NONE);
  ASSERT(CritCheckIn(&m_cs));

  // something's going to change - wake up threads in BlockReceive();
  m_evBlockReceive.Set();
  StreamInfo *pSi = m_lActiveStreams.Get(m_posCurrentStream);
  ASSERT(pSi->m_posActiveStream == m_posCurrentStream);

  DbgLog((LOG_TRACE, 15,
          TEXT("CAviWrite:ScheduleWrites: stream %i (%d ticks)"),
          pSi->m_stream, pSi->m_cTicksRemaining));

  // loop until the stream we want to write to needs more data
  for(;;)
  {
    if(pSi->m_fEosSeen)
    {
      DbgLog((LOG_TRACE, 15, TEXT("... removing stream %d"), pSi->m_stream));

      ASSERT(m_posCurrentStream == pSi->m_posActiveStream);
      m_posCurrentStream = GetNextActiveStream(m_posCurrentStream);
      ASSERT(m_posCurrentStream != 0);
      m_lActiveStreams.Remove(pSi->m_posActiveStream);
      if(pSi->m_posActiveStream == m_posCurrentStream)
      {
        ASSERT(m_lActiveStreams.GetCount() == 0);
        DbgLog((LOG_TRACE, 3,
                TEXT("CAviWrite::ScheduleWrites: no streams left")));
        return S_OK;
      }
      else
      {
        ASSERT(m_lActiveStreams.GetCount() != 0);
        pSi = m_lActiveStreams.Get(m_posCurrentStream);
      }
      DbgLog((LOG_TRACE, 15, TEXT("... switched to stream %d"),
              pSi->m_stream));
    }

    // this stream is done. get the next one
    while(pSi->m_cTicksRemaining <= 0)
    {
      m_posCurrentStream = GetNextActiveStream(m_posCurrentStream);
      ASSERT(m_posCurrentStream);

      pSi = m_lActiveStreams.Get(m_posCurrentStream);
      DbgLog((LOG_TRACE, 15,
              TEXT("... switched to stream %i (%d ticks left)"),
              pSi->m_stream, pSi->m_cTicksRemaining));
      ASSERT(!pSi->m_fEosSeen);

      // compute how many ticks this stream is allowed to write.
      if(pSi->m_cTicksRemaining <= 0)
      {
        if(m_posCurrentStream == m_lActiveStreams.GetHeadPosition())
        {
          ASSERT(pSi->m_cTicksPerChunk != 0);
          DbgLog((LOG_TRACE, 15,
                  TEXT("... adding %d ticks to leading stream %d"),
                  pSi->m_cTicksPerChunk, pSi->m_stream));
          pSi->m_cTicksRemaining += pSi->m_cTicksPerChunk;
        }
        else
        {
          StreamInfo *pSiHead = m_lActiveStreams.Get(
            m_lActiveStreams.GetHeadPosition());

          REFERENCE_TIME rtDiff;
          if(m_fInterleaveByTime)
          {
            rtDiff = pSiHead->m_refTimeEnd - pSiHead->m_rtPreroll -
              (pSi->m_refTimeEnd - pSi->m_rtPreroll);
          }
          else
          {
            rtDiff = pSiHead->ConvertTickToTime(pSiHead->m_iCurrentTick);
            rtDiff -= pSiHead->m_rtPreroll;
            rtDiff -= (pSi->ConvertTickToTime(pSi->m_iCurrentTick) -
                       pSi->m_rtPreroll);
          }

          DbgLog((LOG_TRACE, 15,
                  TEXT("... adding %d ticks to non-leading stream %d"),
                  pSi->ConvertTimeToTick(rtDiff), pSi->m_stream));
          pSi->m_cTicksRemaining += pSi->ConvertTimeToTick(rtDiff);
        }
      }
    }

    ASSERT(pSi->m_cTicksRemaining > 0);

    if(pSi->m_lIncoming.GetCount() == 0)
    {
      DbgLog((LOG_TRACE, 15,
              TEXT("CAviWrite:ScheduleWrites: stream %i empty"),
              pSi->m_stream));
      return S_OK;
    }

    HRESULT hr = pSi->WriteSample();

    if(hr != S_OK)
    {
      DbgLog((LOG_TRACE, 1, TEXT("... WriteSample returned %08x"), hr));
      return hr;
    }
  }
}

POSITION CAviWrite::GetNextActiveStream(POSITION pos)
{
  POSITION posNext = m_lActiveStreams.Next(pos);
  if(posNext == 0)
    posNext = m_lActiveStreams.GetHeadPosition();
  return posNext;
}

HRESULT CAviWrite::StreamInfo::NewSampleRecvd(
  IMediaSample *pSample)
{
  REFERENCE_TIME rtStart, rtStop;
  HRESULT hr = pSample->GetTime(&rtStart, &rtStop);
  if(FAILED(hr))
    return hr;

  DWORD lActualLen = pSample->GetActualDataLength();

  if(m_fEosSeen)
    return S_FALSE;

  if(m_cSamples == 0)
  {
    DEBUG_EX(m_pAviWrite->m_dwTimeFirstSample = GetTickCount());
    m_refTimeStart = rtStart;
  }
  else if(rtStop < m_refTimeEnd)
  {
    DbgBreak("StreamInfo::NewSampleRecvd: samples ends before previous one");
    return VFW_E_START_TIME_AFTER_END;
  }

  m_refTimeEnd = rtStop;

  REFERENCE_TIME mtStart, mtStop;
  hr = pSample->GetMediaTime(&mtStart, &mtStop);
  if(hr == S_OK)
  {
    if(mtStop > m_mtEnd)
    {
      m_mtEnd = mtStop;
    }
    else
    {
      DbgBreak("StreamInfo::NewSampleRecvd: media time went backwards");
      return VFW_E_START_TIME_AFTER_END;
    }
  }
  else
  {
    m_mtEnd = -1;
  }

  ASSERT(m_refTimeEnd >= m_refTimeStart);

  //
  // other stream statistics needed
  //
  m_cSamples++;

  // byte written for dwMaxBytesPerSecond. this is total/average. not
  // max !!!
  m_dwlcBytes += lActualLen;

  // for dwSuggestedBufferSize
  m_cbLargestChunk = max(lActualLen, m_cbLargestChunk);

  return S_OK;
}

HRESULT CAviWrite::CFrameBaseStream::NotifyNewSample(
  IMediaSample *pSample, ULONG *pcTicks)
{
  *pcTicks = 1;

  REFERENCE_TIME rtStartCurrent, rtEndCurrent;
  HRESULT hr = pSample->GetTime(&rtStartCurrent, &rtEndCurrent);
  if(FAILED(hr))
    return hr;

  REFERENCE_TIME mtStartCurrent, mtEndCurrent;
  hr = pSample->GetMediaTime(&mtStartCurrent, &mtEndCurrent);
  const BOOL fMtAvailable= (hr == S_OK);

  // fixups for streams that don't set AvgTimePerFrame. The
  // interleaving code uses this. Something proper will have to be
  // done for variable frame rate files.
  if(m_cSamples == 0)
  {
    m_rtDurationFirstFrame = rtEndCurrent - rtStartCurrent;
    if(m_rtDurationFirstFrame <= 0)
      m_rtDurationFirstFrame = UNITS / 30;

    REFERENCE_TIME mtStop;
    if(pSample->GetMediaTime((REFERENCE_TIME *)&m_mtStart, &mtStop) != S_OK)
    {
      m_mtStart = -1;
    }
  }
  else if(m_bDroppedFrames)
  {
    LONG cDropped;
    REFERENCE_TIME mtStart, mtStop;

    // VFW capture filter can't provide a clock and just calls GetTime
    // when it gets a sample. It does fix the media times it sends, so
    // we have to use media times if available.
    if(m_mtEnd != -1 &&
       pSample->GetMediaTime(&mtStart, &mtStop) == S_OK)
    {
      cDropped = (LONG)(mtStart - m_mtEnd);
    }
    else
    {
      //
      // insert null index entries for dropped frames. first frame
      // must not be a drop frame.
      //

      REFERENCE_TIME rtAvgTimePerFrame = ConvertTickToTime(1);
      cDropped = (LONG)(((rtStartCurrent - m_refTimeEnd) +
                         rtAvgTimePerFrame / 2) /
                        rtAvgTimePerFrame);
    }
    // bit of a hack: cDropped may be negative if the source filter
    // went backwards. we catch this properly later.
    for(LONG iDropped = 0; iDropped < cDropped; iDropped++)
    {

#ifdef PERF
//       return VFW_E_NO_SINK;
#endif

      DbgLog((LOG_TRACE, 1, TEXT("avimux: frame %d dropped"), m_cSamples));
      MSR_INTEGER(m_pAviWrite->m_idPerfDrop, m_cSamples);

      HRESULT hr = m_pAviWrite->IndexSample(m_stream, 0, 0, FALSE);
      if(hr != S_OK)
        return hr;

      m_cSamples++;
      m_pAviWrite->m_cDroppedFrames++;
      // we can handle drop frames without abandoning the
      // compatibility fixups
      // m_pAviWrite->m_bSawDeltaFrame = true;
      (*pcTicks)++;
    }
  }

  return S_OK;
}

HRESULT CAviWrite::CAudioStream::NotifyNewSample(
  IMediaSample *pSample, ULONG *pcTicks)
{
    ULONG cb = pSample->GetActualDataLength();
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();

    if(m_bAudioAlignmentError) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    if(cb % pwfx->nBlockAlign != 0) {
        m_bAudioAlignmentError = true;
    }

#ifdef DEBUG
    // complain about dropped audio
    //
    if(m_cSamples > 0)
    {
        REFERENCE_TIME rtStartCurrent, rtEndCurrent;
        HRESULT hr = pSample->GetTime(&rtStartCurrent, &rtEndCurrent);
        if(SUCCEEDED(hr)) {

            // 1ms threshold. The start time of this sample must be
            // near the end time of the previous sample
            if(rtStartCurrent > m_refTimeEnd + UNITS / (UNITS / MILLISECONDS)) {
              DbgLog((LOG_ERROR, 0, TEXT("avimux: audio dropped.")));
            }
        }
    }
#endif


    *pcTicks = GetTicksInSample(cb);
    return S_OK;
}


HRESULT CAviWrite::CAudioStreamI::WriteSample(IMediaSample *pSample)
{
  UNREFERENCED_PARAMETER(pSample);
  // CAudioStreamI can only work in interleaved mode. our WriteSample
  // method never calls this.
  DbgBreak("? interleaved audio confused");
  return E_NOTIMPL;
}

HRESULT CAviWrite::CAudioStreamI::WriteSample()
{
  CAutoLock lock(&m_pAviWrite->m_cs);
  DbgLog((LOG_TRACE, 15, TEXT("CAudioStreamI: ")));
  ASSERT(m_cTicksRemaining > 0);
  HRESULT hr;

  // current sample
  IMediaSample *pSample = m_lIncoming.GetHead();
  ASSERT(pSample);

  if(pSample == INCOMING_EOS_SAMPLE)
  {
    EXECUTE_ASSERT(m_lIncoming.RemoveHead() == INCOMING_EOS_SAMPLE);
    return this->EndOfStream();
  }

  // starting on a new upstream sample
  if(m_cbThisSample == 0)
  {
    hr = NewSampleRecvd(pSample);
    if(hr != S_OK)
      return hr;

    LONG cb = pSample->GetActualDataLength();
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();

    if(m_bAudioAlignmentError) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    if(cb % pwfx->nBlockAlign != 0) {
        m_bAudioAlignmentError = true;
    }
  }

  ASSERT(m_pAviWrite->m_cbAlign == 1);
  ASSERT(m_pAviWrite->m_IlMode == INTERLEAVE_FULL);

  LONG lActualLen = pSample->GetActualDataLength();
  LONG cTicks = GetTicksInSample(lActualLen);

  // adjust data pointer to include our header padding for the Riff
  // chunk header
  BYTE *pbData;
  pSample->GetPointer(&pbData );

  BOOL fFinishedSample = FALSE;

  long cbRemainingThisChunk = ConvertTickToBytes(m_cTicksRemaining);

  m_pAviWrite->DbgCheckFilePos();

  // starting a new riff chunk
  if(!m_fUnfinishedChunk)
  {
    DbgLog((LOG_TRACE, 15, TEXT("AudioStreamI: %d new chunk %d bytes"),
            m_stream, cbRemainingThisChunk));

    hr = m_pAviWrite->HandleSubindexOverflow(m_stream);
    if(FAILED(hr)) {
        return hr;
    }

    m_cbLargestChunk = max((ULONG)cbRemainingThisChunk, m_cbLargestChunk);

    m_dwlOffsetThisChunk = m_pAviWrite->m_dwlFilePos;
    m_cbInRiffChunk = cbRemainingThisChunk;
    RIFFCHUNK rc = { m_moviDataCkid, cbRemainingThisChunk };
    hr = m_pAviWrite->IleaveWrite(
      m_pAviWrite->m_dwlFilePos, (BYTE *)&rc, sizeof(RIFFCHUNK));
    if(hr != S_OK)
    {
      DbgLog(( LOG_ERROR, 2, TEXT("AudioStreamI: Write failed.")));
      return hr;
    }
    m_cbThisChunk = 0;
    m_pAviWrite->m_dwlFilePos += sizeof(RIFFCHUNK);
    m_pAviWrite->DbgCheckFilePos();
  }
  else
  {
    ASSERT(m_pAviWrite->m_dwlFilePos == m_dwlOffsetRecv);
    m_pAviWrite->DbgCheckFilePos();
  }
  m_fUnfinishedChunk = TRUE;

  ULONG cbWrite = min(cbRemainingThisChunk, lActualLen - m_cbThisSample);
  m_cbThisChunk += cbWrite;

  DbgLog((LOG_TRACE, 15, TEXT("AudioStreamI: %d wrote %d bytes"),
          m_stream, cbWrite));
  hr = m_pAviWrite->IleaveWrite(
    m_pAviWrite->m_dwlFilePos,
    pbData + m_cbThisSample, cbWrite);
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: Write failed.")));
    return hr;
  }

  ULONG ctWrite = ConvertBytesToTicks(cbWrite);
  hr = NotifyWrote(ctWrite);
  ASSERT(hr == S_OK);

  m_cbThisSample += cbWrite;
  cbRemainingThisChunk -= cbWrite;
  m_pAviWrite->m_dwlFilePos += cbWrite;
  m_pAviWrite->DbgCheckFilePos();
  DbgLog((LOG_TRACE, 15,
          TEXT("... m_cbThisSample = %d, lActualLen = %d, cbRemainingThisChunk = %d"),
          m_cbThisSample, lActualLen, cbRemainingThisChunk));

  if(cbRemainingThisChunk == 0)
  {
    m_fUnfinishedChunk = FALSE;
    hr = FlushChunk();
    if(hr != S_OK)
      return hr;
  }

  if(m_cbThisSample == lActualLen)
  {
    // take this sample off the queue
    DbgLog((LOG_TRACE, 15, TEXT("...audioI took %08x off the queue"),
            pSample));
    EXECUTE_ASSERT(pSample == m_lIncoming.RemoveHead());
    pSample->Release();
    m_cbThisSample = 0;
  }


#ifdef DEBUG
  if(m_fUnfinishedChunk)
    m_dwlOffsetRecv = m_pAviWrite->m_dwlFilePos;
#endif // DEBUG

  return S_OK;
}

HRESULT CAviWrite::CAudioStreamI::EndOfStream()
{
  DbgLog((LOG_TRACE, 5, TEXT("CAudioStreamI::EndOfStream")));
  ASSERT(m_pAviWrite->m_IlMode == INTERLEAVE_FULL);
  ASSERT(!m_fEosSeen);
  m_fEosSeen = TRUE;
  HRESULT hr;
  if(m_fUnfinishedChunk)
  {
    CAutoLock lock(&m_pAviWrite->m_cs);
    hr = FlushChunk();
    if(FAILED(hr))
      return hr;
    hr = NotifyWrote(m_cTicksRemaining);
  }
  return S_OK;
}

void
CAviWrite::CAudioStreamI::GetCbWritten(DWORDLONG *pdwlcb)
{
  *pdwlcb = m_dwlcbWritten;
}

HRESULT CAviWrite::CAudioStreamI::FlushChunk()
{
  HRESULT hr;
  ASSERT(CritCheckIn(&m_pAviWrite->m_cs));

  DbgLog((LOG_TRACE, 5, TEXT("CAudioStreamI:FlushChunk: stream %d"),
          m_stream));
  m_fUnfinishedChunk = FALSE;

  if(m_cbThisChunk != m_cbInRiffChunk)
  {
    DbgLog((LOG_TRACE, 5, TEXT("CAudioStreamI: need to fix up riff chunk.")));

    RIFFCHUNK rc = { m_moviDataCkid, m_cbThisChunk };
    hr = m_pAviWrite->IStreamWrite(
      m_dwlOffsetThisChunk, (BYTE *)&rc, sizeof(RIFFCHUNK));
    if(hr != S_OK)
    {
      DbgLog(( LOG_ERROR, 2, TEXT("AudioStreamI: Write failed.")));
      return hr;
    }
  }

  // round up to word boundary
  if(m_pAviWrite->m_dwlFilePos % 2)
  {
    m_pAviWrite->m_dwlFilePos++;
  }

  m_dwlcbWritten += m_cbThisChunk;


  hr = m_pAviWrite->IndexSample (
    m_stream,
    m_dwlOffsetThisChunk,
    m_cbThisChunk,
    TRUE);
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAudioStreamI:Flush: IndexSample failed.")));
    return hr;
  }

  hr = m_pAviWrite->NewRiffAvi_();
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAudioStreamI::Flush: NewRiffAvi_ failed.")));
    return hr;
  }

  return S_OK;
}

LONG CAviWrite::CAudioStream::GetTicksInSample(DWORDLONG lcb)
{
  WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();

  ASSERT(lcb / pwfx->nBlockAlign + 1 <= MAXDWORD);

  // we do need to count a partial tick
  LONG lTicks = (LONG)((lcb + pwfx->nBlockAlign - 1) / pwfx->nBlockAlign);

#ifdef DEBUG
  if(lcb % pwfx->nBlockAlign)
  {
      ASSERT(m_bAudioAlignmentError);
  }
#endif

  return lTicks;
}

HRESULT CAviWrite::StreamInfo::WriteSample()
{
  ASSERT(CritCheckIn(&m_pAviWrite->m_cs));
  IMediaSample *pSample = m_lIncoming.RemoveHead();
  ASSERT(pSample);
  if(pSample == INCOMING_EOS_SAMPLE)
  {
    ASSERT(m_fEosSeen == FALSE);
    m_fEosSeen = TRUE;
    return EndOfStream();
  }

  HRESULT hr = WriteSample(pSample);
  pSample->Release();
  return hr;
}

HRESULT CAviWrite::StreamInfo::WriteSample(IMediaSample *pSample)
{
  CAutoLock lock(&m_pAviWrite->m_cs);
  if(m_fEosSeen)
    return S_FALSE;

  bool fInterleaving = (m_pAviWrite->m_IlMode == INTERLEAVE_FULL);

  REFERENCE_TIME rtStartCurrent, rtEndCurrent;
  HRESULT hr = pSample->GetTime(&rtStartCurrent, &rtEndCurrent);
  if(FAILED(hr))
    return hr;

  hr = m_pAviWrite->HandleSubindexOverflow(m_stream);
  if(FAILED(hr)) {
      return hr;
  }

  ULONG cTicks;
  hr = NotifyNewSample(pSample, &cTicks);
  if(hr != S_OK)
    return hr;

  ULONG cbActualSampleCurrent = pSample->GetActualDataLength();

  // compute frame size of uncompressed frames and see if the sample
  // has the wrong size.
  //
  if(m_mt.formattype == FORMAT_VideoInfo)
  {
    VIDEOINFO *pvi = (VIDEOINFO *)m_mt.Format();

    if((pvi->bmiHeader.biCompression == BI_RGB ||
        pvi->bmiHeader.biCompression == BI_BITFIELDS) &&
       pvi->bmiHeader.biSizeImage < cbActualSampleCurrent)
    {
#ifdef DEBUG
      if(m_cSamples == 0) {
        DbgLog((
          LOG_ERROR, 0,
          TEXT("avi - frame size mismatch. h*w=%d, biSizeImage=%d, GetActualDataLength() = %d"),
          DIBSIZE(pvi->bmiHeader),
          pvi->bmiHeader.biSizeImage,
          cbActualSampleCurrent));

      }
#endif
      cbActualSampleCurrent = pvi->bmiHeader.biSizeImage;
      // !!! NewSampleRecvd sees the wrong buffer size too. should we
      // fix it?
    }
  }

  // adjust data pointer to include our header padding for the Riff
  // chunk header
  BYTE *pbData;
  pSample->GetPointer(&pbData );
  if(!fInterleaving) {
      pbData -= CB_AVI_PREFIX;
  }

  BOOL bSyncPoint = pSample->IsSyncPoint() == S_OK ||
      !m_mt.bTemporalCompression;

  if(!bSyncPoint) {
      m_pAviWrite->m_bSawDeltaFrame = true;
  }

  // set RIFF chunk header w/ sample size and stream id
  DWORD dwActualSize = cbActualSampleCurrent;
  DWORD dwSize = dwActualSize;

  RIFFCHUNK rc = {
      bSyncPoint ? m_moviDataCkid : m_moviDataCkidCompressed,
      dwSize
  };

  BYTE *pJunkSector = 0;
  CSampSample *pSSJunk = 0;

  DWORDLONG dwlOldFilePos = m_pAviWrite->m_dwlFilePos; // the old file offset

  if(!fInterleaving)
  {
      // adjust size for prefix we requested
      dwSize += CB_AVI_PREFIX;

      CopyMemory(pbData, &rc, sizeof(rc));

      if(m_fOurAllocator)
      {
          m_pAviWrite->AddJunk(dwSize, m_pAviWrite->m_cbAlign, pbData);
          // assert our new size fit in what's allocated
          ASSERT(dwSize <= pSample->GetSize() + m_pAviWrite->m_cbPrefix + m_pAviWrite->m_cbSuffix);
      }
      else
      {
          m_pAviWrite->AddJunkOtherAllocator(dwSize, m_pAviWrite->m_cbAlign, pbData, pSample, &pJunkSector);
      }

      CSampSample *pSS;
      hr = m_pAviWrite->m_pSampAlloc->GetBuffer(&pSS, 0, 0, 0);
      if(hr != S_OK)
          return S_FALSE;

      if(pJunkSector)
      {
          hr = m_pAviWrite->m_pSampAlloc->GetBuffer(&pSSJunk, 0, 0, 0);
          if(hr != S_OK)
          {
              pSS->Release();
              return S_FALSE;
          }
      }

      m_pAviWrite->DbgCheckFilePos();

      pSS->SetSample(pSample, pbData, cbActualSampleCurrent);
      REFERENCE_TIME rtStart = m_pAviWrite->m_dwlFilePos;
      REFERENCE_TIME rtStop = rtStart + dwSize;
      pSS->SetTime(&rtStart, &rtStop);

      hr = m_pAviWrite->m_pIMemInputPin->Receive(pSS);
      pSS->Release();
      if(hr != S_OK)
      {
          if(pSSJunk)
              pSSJunk->Release();
          DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: Write failed.")));

          // ask filter to stop accepting samples
          return S_FALSE;
      }
  }
  else
  {
      ASSERT(m_pAviWrite->m_dwlFilePos % 2 == 0);
      hr = m_pAviWrite->IleaveWrite(m_pAviWrite->m_dwlFilePos, (BYTE *)&rc, sizeof(rc));
      if(SUCCEEDED(hr))
      {
          m_pAviWrite->m_dwlFilePos += sizeof(rc);
          hr = m_pAviWrite->IleaveWrite(m_pAviWrite->m_dwlFilePos, pbData, dwSize);
          m_pAviWrite->m_dwlFilePos += dwSize;
          if(FAILED(hr)) {
              return hr;
          }
          // RIFF chunks need to be byte aligned.
          if(m_pAviWrite->m_dwlFilePos % 2)
          {
              BYTE b = 0;
              hr = m_pAviWrite->IleaveWrite(m_pAviWrite->m_dwlFilePos, &b, 1);
              m_pAviWrite->m_dwlFilePos ++;;
          }
      }
  }

  hr = NotifyWrote(cTicks);
  ASSERT(hr == S_OK);

  if(!fInterleaving)
  {
      m_pAviWrite->m_dwlFilePos += dwSize;

      m_pAviWrite->DbgCheckFilePos();

      // need to write out an additional junk sector
      if(pJunkSector)
      {
          ASSERT(m_pAviWrite->m_IlMode != INTERLEAVE_FULL);

          REFERENCE_TIME rtStart = m_pAviWrite->m_dwlFilePos;
          REFERENCE_TIME rtStop = rtStart + m_pAviWrite->m_cbAlign;
          pSSJunk->SetTime(&rtStart, &rtStop);
          pSSJunk->SetPointer(pJunkSector, (long)(rtStop - rtStart));
          hr = m_pAviWrite->m_pIMemInputPin->Receive(pSSJunk);
          pSSJunk->Release();
          if(hr != S_OK)
          {
              DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: write failed")));
              return S_FALSE;           // ask filter to stop accepting samples
          }
          m_pAviWrite->m_dwlFilePos += m_pAviWrite->m_cbAlign;
      }

      m_pAviWrite->DbgCheckFilePos();
  }

  hr = NewSampleRecvd(pSample);
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: NewSampleRecvd failed.")));
    return hr;
  }

  hr = m_pAviWrite->IndexSample (
    m_stream,
    dwlOldFilePos,
    dwActualSize,
    bSyncPoint);
  if(hr != S_OK)
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: IndexSample failed.")));
    return hr;
  }

  hr = m_pAviWrite->NewRiffAvi_();
  if(hr != S_OK)
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CAviWrite::Receive: NewRiffAvi_ failed.")));
    return hr;
  }

  return hr;
}


HRESULT CAviWrite::StreamInfo::NotifyWrote(long cTicks)
{
  ASSERT(CritCheckIn(&m_pAviWrite->m_cs));
  m_iCurrentTick += cTicks;
  m_cTicksRemaining -= cTicks;
  DbgLog((LOG_TRACE, 15,
          TEXT("CAviWrite::NotifyWrote: stream %d wrote %d ticks, %d left"),
          m_stream, cTicks, m_cTicksRemaining));
  return S_OK;
}

// try to pick a good size for the super index so we waste less space
// in the file.
void CAviWrite::StreamInfo::ComputeAndSetIndexSize()
{
    if(!PrecomputedIndexSizes())
    {
        m_cEntriesSuperIndex = m_pAviWrite->m_cEntriesMaxSuperIndex;
        m_cEntriesSubIndex = m_pAviWrite->m_cEntriesMaxSubIndex;
    }
    else
    {
        // we cannot predict exactly how much data will be pushed at
        // us and have to allocate space for the index in the file
        // before the data is pushed, we waste some space in the last
        // subindex. If the numbers are small, size the sub indexes so
        // that we waste less space.


        if(m_mt.majortype == MEDIATYPE_Audio)
        {
            const cTicksPerChunk = ConvertTimeToTick(m_pAviWrite->m_rtInterleaving);
            const ULONG cChunks = (m_cTicksExpected + cTicksPerChunk - 1) / cTicksPerChunk;

            m_cEntriesSubIndex = m_pAviWrite->m_cEntriesMaxSubIndex;
            if(cChunks < m_cEntriesSubIndex * 5)
                m_cEntriesSubIndex /= 20;

            m_cEntriesSuperIndex = cChunks / m_cEntriesSubIndex + 1;
        }
        else
        {
            m_cEntriesSubIndex = m_pAviWrite->m_cEntriesMaxSubIndex;
            if(m_cTicksExpected < m_cEntriesSubIndex * 5)
                m_cEntriesSubIndex /= 20;

            m_cEntriesSuperIndex = m_cTicksExpected / m_cEntriesSubIndex + 1;
        }

        // allocate 2x + 5 what we computed for various things that
        // can go wrong:
        //
        // 1. wrong number reported from upstream
        // 2. rounding in audio interleaving causes extra chunks
        // 3. subindex overflow
        //
        m_cEntriesSuperIndex *= 2;
        m_cEntriesSuperIndex += 5;
        m_cEntriesSuperIndex = min(m_cEntriesSuperIndex, m_pAviWrite->m_cEntriesMaxSuperIndex);
     }

    ASSERT(m_cEntriesSuperIndex != 0);

    DbgLog((LOG_TRACE, 3, TEXT("avimux: %i super index entries on stream %i"),
            m_cEntriesSuperIndex, m_stream));
}

BOOL CAviWrite::StreamInfo::PrecomputedIndexSizes()
{
  // these two conditions allow us to write smaller-sized index chunks
  // and waste less space.
  return m_cTicksExpected != 0 && m_pAviWrite->m_IlMode == INTERLEAVE_FULL;
}

// ------------------------------------------------------------------------
// static function. returns fourccs to stick in the AVI fcchandler
// field for all known quartz video subtypes.
//

FOURCC CAviWrite::MpVideoGuidSubtype_Fourcc(const GUID *pGuidSubtype)
{
  // which are in the fourcc guid space
  FOURCCMap *fccm = (FOURCCMap*)pGuidSubtype;
  if(fccm->Data2 == GUID_Data2 && // !!! is this in the registry somewhere
     fccm->Data3 == GUID_Data3 &&
     ((DWORD *)fccm->Data4)[0] == GUID_Data4_1 &&
     ((DWORD *)fccm->Data4)[1] == GUID_Data4_2)
    return  fccm->GetFOURCC();

  GUID guidSubType = *pGuidSubtype;
  if(// guidSubType == MEDIASUBTYPE_YVU9 ||
//      guidSubType == MEDIASUBTYPE_Y411 ||
//      guidSubType == MEDIASUBTYPE_Y41P ||
//      guidSubType == MEDIASUBTYPE_YUY2 ||
//      guidSubType == MEDIASUBTYPE_YVYU ||
     guidSubType == MEDIASUBTYPE_RGB1 ||
     guidSubType == MEDIASUBTYPE_RGB4 ||
     guidSubType == MEDIASUBTYPE_RGB8 ||
     guidSubType == MEDIASUBTYPE_RGB565 ||
     guidSubType == MEDIASUBTYPE_RGB555 ||
     guidSubType == MEDIASUBTYPE_RGB24 ||
     guidSubType == MEDIASUBTYPE_RGB32)
    return FCC('DIB ');

  return 0;
}

void CAviWrite::GetCurrentBytePos(LONGLONG *pllcbCurrent)
{
  *pllcbCurrent = m_dwlFilePos;
}




void CAviWrite::GetStreamInfo(int PinNum, AM_MEDIA_TYPE** ppmt)
{
    *ppmt = NULL;
    if (m_cStreams > 0)
    {
        StreamInfo *pStreamInfo = m_rgpStreamInfo[PinNum];
        *ppmt = & (pStreamInfo->m_mt);
    }

}



void CAviWrite::GetCurrentTimePos(REFERENCE_TIME *prtCurrent)
{
  *prtCurrent = 0;
  if(m_cStreams > 0)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[0];
    *prtCurrent = pStreamInfo->m_refTimeEnd;
  }
  for(UINT iStream = 1; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
    *prtCurrent = min(*prtCurrent, pStreamInfo->m_refTimeEnd);
  }
}

// ------------------------------------------------------------------------
// static method called when write is complete. releases sample

void CAviWrite::SampleCallback(void *pMisc)
{
  IMediaSample *pSample = (IMediaSample*)pMisc;
  pSample->Release();
}

// ------------------------------------------------------------------------
// initialize the internal representation of the avi AVIH structure in
// memory, allocate space for it on disk

HRESULT CAviWrite::InitializeHeader(IMediaPropertyBag *pProp)
{
  ULONG cbIndexChunks = 0;
  for(unsigned i = 0; i < m_cStreams; i++)
  {
    StreamInfo *pSi = m_rgpStreamInfo[i];
    cbIndexChunks += cbSuperIndex(C_ENTRIES_SUPERINDEX);
  }

  // allocate large amount of space; 8k for the header. an extra 1k
  // for each stream plus the indx chunk. 64k for properties
  const ULONG cbAlloc = 8192 +
    (cbIndexChunks + 1024) * m_cStreams +
    m_cbHeaderJunk + 65536;

  m_rgbHeader = new BYTE[cbAlloc];
  if(m_rgbHeader == 0)
    return E_OUTOFMEMORY;
  ZeroMemory(m_rgbHeader, cbAlloc);

  ULONG iPos = 0;               // current position

#define CheckOverflow(n) if(iPos + n >= cbAlloc) return VFW_E_BUFFER_OVERFLOW;

  m_pAvi_ = (RIFFLIST *)(m_rgbHeader + iPos);
  SetList(m_pAvi_, FCC('RIFF'), 0, FCC('AVI '));
  iPos += sizeof(RIFFLIST);

  m_pHdrl = (RIFFLIST *)(m_rgbHeader + iPos);
  SetList(m_pHdrl, FCC('LIST'), 0, FCC('hdrl'));
  iPos += sizeof(RIFFLIST);
  {
    m_pAvih = (AVIMAINHEADER *)(m_rgbHeader + iPos); // avih chunk
    SetChunk(m_pAvih, FCC('avih'), sizeof(AVIMAINHEADER) - sizeof(RIFFCHUNK));
    iPos += sizeof(AVIMAINHEADER);

    HRESULT hr = InitializeStrl(iPos);
    if(FAILED(hr))
      return hr;

    ASSERT(iPos <= cbAlloc);

    // do odml list
    m_pOdml = (RIFFLIST *)(m_rgbHeader + iPos);
    CheckOverflow(sizeof(RIFFLIST));
    SetList(m_pOdml, FCC('LIST'), 0, FCC('odml'));
    iPos += sizeof(RIFFLIST);
    {
      m_pDmlh = (AVIEXTHEADER *)(m_rgbHeader + iPos);
      CheckOverflow(sizeof(AVIEXTHEADER));
      SetChunk(m_pDmlh, FCC('dmlh'), sizeof(AVIEXTHEADER) - sizeof(RIFFCHUNK));
      iPos += sizeof(AVIEXTHEADER);

    } // odml list
    m_pOdml->cb = (DWORD)(m_rgbHeader + iPos - (BYTE *)m_pOdml - sizeof(RIFFCHUNK));

  } // hdrl list
  m_pHdrl->cb = (DWORD)(m_rgbHeader + iPos - (BYTE *)m_pHdrl - sizeof(RIFFCHUNK));

  // do INFO/DISP chunks
  if(pProp)
  {
      RIFFLIST *pInfoList = (RIFFLIST *)(m_rgbHeader + iPos);
      ULONG posInfoChunk = iPos;
      CheckOverflow(sizeof(RIFFLIST));
      iPos += sizeof(RIFFLIST);

      // look for INFO properties
      for(UINT i = 0; ; i++)
      {
          VARIANT varProp, varVal;
          varProp.bstrVal = 0;
          varProp.vt = VT_BSTR;
          varVal.vt = VT_EMPTY;
          HRESULT hr = pProp->EnumProperty(i, &varProp, &varVal);
          if(SUCCEEDED(hr))
          {
              // not really a valid assertion so we check for this too
              ASSERT(varProp.vt == VT_BSTR);

              if(varVal.vt == VT_BSTR && varProp.vt == VT_BSTR)
              {
                  DWORD szKey[20];        // string dereferenced as dword

                  int cch = WideCharToMultiByte(
                      CP_ACP, 0,
                      varProp.bstrVal, -1,
                      (char *)szKey, sizeof(szKey),
                      0, 0);
                  if(cch == sizeof("INFO/XXXX") &&
                     szKey[0] == FCC('INFO') &&
                     ((char *)szKey)[4] == '/')
                  {
                      DbgLog((LOG_TRACE, 5,
                              TEXT("avimux: writing copyright string %S = %S"),
                              varProp.bstrVal, varVal.bstrVal));

                      DWORD dwFcc = *(DWORD UNALIGNED *)(((BYTE *)szKey) + 5);
                      int cchVal = SysStringLen(varVal.bstrVal) + 1;
                      cchVal = AlignUp(cchVal, sizeof(DWORD)); // DWORD align RIFF chunks
                      UNALIGNED RIFFCHUNK *pRiffchunk = (RIFFCHUNK *)(m_rgbHeader + iPos);
                      CheckOverflow(sizeof(RIFFCHUNK)); // !!! memory leak
                      SetChunk(pRiffchunk, dwFcc, cchVal);
                      iPos += sizeof(RIFFCHUNK);

                      CheckOverflow(cchVal); // !!! memory leak
                      {
                          UINT cch = WideCharToMultiByte(
                              CP_ACP, 0,
                              varVal.bstrVal, -1,
                              (char *)m_rgbHeader + iPos, cbAlloc - iPos,
                              0, 0);
                          ASSERT(SysStringLen(varVal.bstrVal) + 1 == cch);
                      }
                      iPos += cchVal;
                  }

              }

              SysFreeString(varProp.bstrVal);
              VariantClear(&varVal);
          }
          else
          {
              hr = S_OK;
              break;
          }
      } // INFO

      SetList(
          pInfoList,
          FCC('LIST'),
          iPos - posInfoChunk - sizeof(RIFFCHUNK),
          FCC('INFO'));

      // DISP
      for(/* UINT */ i = 0; ; i++)
      {
          VARIANT varProp, varVal;
          varProp.bstrVal = 0;
          varProp.vt = VT_BSTR;
          varVal.vt = VT_EMPTY;
          HRESULT hr = pProp->EnumProperty(i, &varProp, &varVal);
          if(SUCCEEDED(hr) )
          {
              // not really a valid assertion, so we validate it anyway
              ASSERT(varProp.vt == VT_BSTR);

              // is this property an array of bytes?
              if(varProp.vt == VT_BSTR && varVal.vt == (VT_UI1 | VT_ARRAY))
              {
                  DWORD szKey[20];        // string dereferenced as dword

                  int cch = WideCharToMultiByte(
                      CP_ACP, 0,
                      varProp.bstrVal, -1,
                      (char *)szKey, sizeof(szKey),
                      0, 0);
                  if(cch == sizeof("DISP/XXXXXXXXXX") &&
                     szKey[0] == FCC('DISP') &&
                     ((char *)szKey)[4] == '/')
                  {
                      DbgLog((LOG_TRACE, 5,
                              TEXT("avimux: writing display string %S"),
                              varProp.bstrVal));

                      // read decimal value (no scanf w/o crt)
                      ULONG dispVal = 0, digit = 1;
                      for(int ichar = 9; ichar >= 0; ichar--)
                      {
                          dispVal += (((char *)szKey)[5 + ichar] - '0') * digit;
                          digit *= 10;
                      }

                      // bytes of data in the property
                      UINT cbDispData = varVal.parray->rgsabound[0].cElements;

                      // DWORD align RIFF chunks. +sizeof(DWORD) for
                      // the DISP chunk identifier at the beginning.
                      UINT cbDispChunk = AlignUp(cbDispData + sizeof(DWORD), sizeof(DWORD));

                      UNALIGNED RIFFCHUNK *pRiffchunk = (RIFFCHUNK *)(m_rgbHeader + iPos);

                      CheckOverflow(sizeof(RIFFCHUNK) + sizeof(DWORD)); // !!! memory leak
                      SetChunk(pRiffchunk, FCC('DISP'), cbDispChunk);
                      iPos += sizeof(RIFFCHUNK);
                      *(DWORD *)(m_rgbHeader + iPos) = dispVal;
                      iPos += sizeof(DWORD);

                      // copy the data from the property bag into the header
                      CheckOverflow(cbDispChunk - sizeof(DWORD)); // !!! memory leak
                      {
                          BYTE *pbData;
                          EXECUTE_ASSERT(SafeArrayAccessData(varVal.parray, (void **)&pbData) == S_OK);
                          CopyMemory(
                              m_rgbHeader + iPos,
                              pbData,
                              cbDispData);
                          EXECUTE_ASSERT(SafeArrayUnaccessData(varVal.parray) == S_OK);
                      }

                      // advance to the end. -sizeof(DWORD) because we
                      // already accounted for the DWORD earlier.
                      iPos += cbDispChunk - sizeof(DWORD);

                  } // DISP?
              } // array?

              SysFreeString(varProp.bstrVal);
              VariantClear(&varVal);
          } // ENUM
          else
          {
              hr = S_OK;
              break;
          }

      } // DISP chunk loop

  } // pProp

  // add requested empty space (for future edits) and make the data
  // part of the list-movi chunk start on a sector boundary
  if(m_cbAlign > 1 || m_cbHeaderJunk > 1)
  {
    RIFFCHUNK *pHeaderJunk = (RIFFCHUNK *)(m_rgbHeader + iPos);
    iPos += sizeof(RIFFCHUNK);
    ULONG cbJunk = m_cbHeaderJunk;
    unsigned remainder = (iPos + cbJunk + sizeof(RIFFLIST)) %  m_cbAlign;
    if(remainder != 0)
      cbJunk += m_cbAlign - remainder;
    CheckOverflow(cbJunk);
    SetChunk(pHeaderJunk, FCC('JUNK'), cbJunk);
    iPos += cbJunk;
  }

  ASSERT(iPos <= cbAlloc);

  m_pMovi = (RIFFLIST *)(m_rgbHeader + iPos); // movi List
  CheckOverflow(sizeof(RIFFLIST));
  SetList(m_pMovi, FCC('LIST'), 0, FCC('movi'));
  iPos += sizeof(RIFFLIST);

  ASSERT(m_cbAlign != 0);         // make sure GetMemReq was called
  ASSERT(iPos % sizeof(DWORD) == 0);

  AddJunk(iPos, m_cbAlign, m_rgbHeader);

  m_cbHeader = iPos;

  ASSERT(iPos <= cbAlloc);
  ASSERT(iPos % m_cbAlign == 0);

  m_posFirstIx = iPos;
  m_dwlCurrentRiffAvi_ = (BYTE*)m_pAvi_ - m_rgbHeader;

  m_dwlFilePos = m_posFirstIx;

  return S_OK;
}

// ------------------------------------------------------------------------
// a separate function that adds a "STRL" list for each stream

HRESULT CAviWrite::InitializeStrl(ULONG& iPos)
{
  // do the strl lists
  for(unsigned i = 0; i < m_cStreams; i++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[i];
    pStreamInfo->m_posStrl = iPos;
    SetList(m_rgbHeader + iPos, FCC('LIST'), 0, FCC('strl'));
    iPos += sizeof(RIFFLIST);   // strl
    {

      // strh
      RIFFCHUNK *pStrh = (RIFFCHUNK*)(m_rgbHeader + iPos);
      SetChunk(pStrh, FCC('strh'), sizeof(AVISTREAMHEADER) - sizeof(RIFFCHUNK));
      iPos += sizeof(AVISTREAMHEADER);
      // end strh

      // STRF chunk
      pStreamInfo->m_posStrf = iPos;
      ULONG cbStrf = pStreamInfo->m_mt.FormatLength();
      const GUID &majorType = pStreamInfo->m_mt.majortype;
      if(majorType == MEDIATYPE_Video)
      {
        // adjustment -- we save only the BITMAPINFOHEADER from the
        // VIDEOINFO
        if(pStreamInfo->m_mt.formattype == FORMAT_VideoInfo)
        {
          VIDEOINFO *pvi = (VIDEOINFO *)pStreamInfo->m_mt.Format();
          cbStrf = GetBitmapFormatSize(&pvi->bmiHeader) - SIZE_PREHEADER;
        }

        pStreamInfo->m_moviDataCkid = FCC('00db');
        Hexrg2bFromW((BYTE*)&pStreamInfo->m_moviDataCkid, i);
        pStreamInfo->m_moviDataCkidCompressed = FCC('00dc');
        Hexrg2bFromW((BYTE*)&pStreamInfo->m_moviDataCkidCompressed, i);
      }
      else if(majorType == MEDIATYPE_Audio)
      {
        pStreamInfo->m_moviDataCkid = FCC('00wb');
        Hexrg2bFromW((BYTE*)&pStreamInfo->m_moviDataCkid, i);
        pStreamInfo->m_moviDataCkidCompressed = pStreamInfo->m_moviDataCkid;
      }
      else if(majorType == MEDIATYPE_Text)
      {
        pStreamInfo->m_moviDataCkid = FCC('00tx');
        Hexrg2bFromW((BYTE*)&pStreamInfo->m_moviDataCkid, i);
        pStreamInfo->m_moviDataCkidCompressed = pStreamInfo->m_moviDataCkid;
      }
      else
      {
        pStreamInfo->m_moviDataCkid = FCC('00__');
        Hexrg2bFromW((BYTE*)&pStreamInfo->m_moviDataCkid, i);
        pStreamInfo->m_moviDataCkidCompressed = pStreamInfo->m_moviDataCkid;
      }

      pStreamInfo->m_cbStrf = cbStrf;
      SetChunk(m_rgbHeader + iPos, FCC('strf'), cbStrf);
      iPos += sizeof(RIFFCHUNK) + cbStrf;
      // end strf

      // strn
      if(pStreamInfo->m_szStrn)
      {
          // we need WORD alignment. But SetChunk appears to force
          // DWORD alignment for memory alignment issues rather than
          // file format issues.
          AddJunk(iPos, sizeof(DWORD), m_rgbHeader);
          ULONG cbSz = lstrlenA(pStreamInfo->m_szStrn) + 1;
          SetChunk(m_rgbHeader + iPos, FCC('strn'), cbSz);
          iPos += sizeof(RIFFCHUNK);
          pStreamInfo->m_posStrn = iPos;
          iPos += cbSz;
      }
      else
      {
          pStreamInfo->m_posStrn = 0;
      }
      

      // we need DWORD alignment
      AddJunk(iPos, sizeof(DWORD), m_rgbHeader);

      // indx chunk (including RIFFCHUNK header)
      pStreamInfo->m_posIndx = iPos;
      const ULONG cbIndx = cbSuperIndex(pStreamInfo->m_cEntriesSuperIndex);
      SetChunk(m_rgbHeader + iPos, FCC('indx'), cbIndx - sizeof(RIFFCHUNK));
      iPos += cbIndx;
      // end indx

    }
    // end strl
    ((RIFFLIST*)(m_rgbHeader + pStreamInfo->m_posStrl))->cb =
      iPos - pStreamInfo->m_posStrl - sizeof(RIFFCHUNK);
  } // for loop

  return S_OK;
}

// ------------------------------------------------------------------------
// get configuration from the registry. use constants otherwise.

HRESULT CAviWrite::InitializeOptions()
{
  m_cbRiffMax = CB_RIFF_MAX;
  m_cbBuffer = CB_BUFFER;
  m_cBuffers = C_BUFFERS;
  m_cbHeaderJunk = CB_HEADER_JUNK;
  m_bOutputIdx1 = g_B_OUTPUT_IDX1;

  HKEY hkOptions;
  LONG lResult = RegOpenKeyEx(
    HKEY_CURRENT_USER,
    TEXT("Software\\Microsoft\\Multimedia\\AviWriterFilter"),
    0,
    KEY_READ,
    &hkOptions);
  if(lResult != ERROR_SUCCESS)
    return S_OK;

//   RegGetDword(hkOptions, TEXT("cbSubIndex"), &m_cbIx);
//   RegGetDword(hkOptions, TEXT("cbSuperIndex"), &m_cbIndx);
  RegGetDword(hkOptions, TEXT("cbOuterRiff"), &m_cbRiffMax);
  RegGetDword(hkOptions, TEXT("cbHeaderJunk"), &m_cbHeaderJunk);
  RegGetDword(hkOptions, TEXT("cbBuffer"), &m_cbBuffer);
  RegGetDword(hkOptions, TEXT("cBuffers"), &m_cBuffers);

  // need to do the binary values specially
  DWORD dw_b;
  RegGetDword(hkOptions, TEXT("bOutputOldIndex"), &dw_b) &&
    (m_bOutputIdx1 = dw_b);

  lResult = RegCloseKey(hkOptions);
  ASSERT(lResult == ERROR_SUCCESS);

  return S_OK;
}

HRESULT CAviWrite::InitializeInterleaving()
{
  BOOL fFoundAudio = FALSE;
  REFERENCE_TIME rtLeadingStream = 0;
  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];

    if(iStream == 0)
    {
      pStreamInfo->m_cTicksPerChunk = pStreamInfo->ConvertTimeToTick(m_rtInterleaving);
      rtLeadingStream = m_rtInterleaving;
    }
    else
    {
      ASSERT(rtLeadingStream != 0);
      pStreamInfo->m_cTicksPerChunk =
        pStreamInfo->ConvertTimeToTick(rtLeadingStream);
    }
    if(pStreamInfo->m_cTicksPerChunk == 0)
    {
      pStreamInfo->m_cTicksPerChunk = 1;
    }

    if(*pStreamInfo->m_mt.Type() == MEDIATYPE_Audio &&
       m_rtAudioPreroll > 0)
    {
      fFoundAudio = TRUE;
      ASSERT(m_rgpStreamInfo[iStream]->m_cTicksRemaining == 0);
      REFERENCE_TIME rtPreroll = m_rtAudioPreroll;
      pStreamInfo->m_rtPreroll = rtPreroll;
      pStreamInfo->m_cTicksRemaining =
        pStreamInfo->ConvertTimeToTick(rtPreroll);

      // relative to other streams, this stream has completed 1 cycle
      // when it has written the preroll.
      pStreamInfo->m_iCurrentTick = pStreamInfo->m_cTicksPerChunk;

      // audio streams for audio preroll ares first on the list
      POSITION pos = m_lActiveStreams.AddHead(pStreamInfo);
      pStreamInfo->m_posActiveStream = pos;
    }
    else
    {
      pStreamInfo->m_rtPreroll = 0;
      pStreamInfo->m_cTicksRemaining = 0;

      // anything else goes at the end of the list
      POSITION pos = m_lActiveStreams.AddTail(pStreamInfo);
      pStreamInfo->m_posActiveStream = pos;
    }


  }
  m_posCurrentStream = m_lActiveStreams.GetHeadPosition();

  if(!fFoundAudio)
  {
    m_rgpStreamInfo[0]->m_cTicksRemaining =
      m_rgpStreamInfo[0]->m_cTicksPerChunk;
  }

  // account for drift if we are trying to interleave the captured output
  m_fInterleaveByTime = (m_IlMode == INTERLEAVE_CAPTURE);

  return S_OK;
}

BOOL CAviWrite::RegGetDword(HKEY hk, TCHAR *tsz, DWORD *dw)
{
  DWORD dwType, dwResult, cbRead;
  LONG lResult;

  lResult = RegQueryValueEx(
    hk,
    tsz,
    0,
    &dwType,
    (BYTE*)&dwResult,
    &cbRead);
  if(lResult == ERROR_SUCCESS && dwType == REG_DWORD && cbRead == sizeof(DWORD))
  {
    *dw = dwResult;
    return TRUE;
  }
  return FALSE;
}

// ------------------------------------------------------------------------
// initialize sub index structures on startup. leave space at the
// start of the file for one sub index per stream. initialize the
// super index structures

HRESULT CAviWrite::InitializeIndex()
{
  ASSERT(m_pAllocator == 0);
  ASSERT(m_cStreams != 0);

  HRESULT hr = CreateMemoryAllocator(&m_pAllocator);
  if(FAILED(hr))
  {
    return hr;
  }

  ALLOCATOR_PROPERTIES Request, Actual;

  Request.cBuffers = 2 * m_cStreams;
  Request.cbBuffer = AlignUp(cbSubIndex(m_cEntriesMaxSubIndex), m_cbAlign);
  Request.cbAlign = m_cbAlign;
  Request.cbPrefix = 0;

  hr = m_pAllocator->SetProperties(&Request, &Actual);

  if(FAILED(hr))
  {
    m_pAllocator->Release();
    m_pAllocator = 0;
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::InitializeIndex:: SetProperties failed.")));
    return hr;
  }

  if ((Request.cbBuffer > Actual.cbBuffer) ||
      (Request.cBuffers > Actual.cBuffers) ||
      (Request.cbAlign > Actual.cbAlign))
  {
    DbgBreak("our allocator refused our values");
    m_pAllocator->Release();
    m_pAllocator = 0;
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::InitializeIndex:: allocator refused values.")));
    return E_UNEXPECTED;
  }

  hr = m_pAllocator->Commit();
  if(FAILED(hr))
  {
    DbgBreak("our allocator won't commit");
    m_pAllocator->Release();
    m_pAllocator = 0;
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::InitializeIndex:: Commit failed.")));
    return hr;
  }

  unsigned i;
  // get memory from the the allocator for each stream
  for(i = 0; i < m_cStreams; i++)
  {
    if(hr = InitIx(i), FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::InitializeIndex:: InitIx failed.")));
      return hr;
    }
  }

  // advance the file pointer to leave space for the first sub-index
  // chunks
  ASSERT(m_dwlFilePos % m_cbAlign == 0);
  for(i = 0; i < m_cStreams; i++)
  {
    StreamInfo *pSi = m_rgpStreamInfo[i];

    // only need to do this if we really are writing out sub indexes.
    pSi->m_posFirstSubIndex = (ULONG)m_dwlFilePos;
    pSi->m_dwlOffsetCurrentSubIndex = m_dwlFilePos;
    m_dwlFilePos += cbSubIndex(pSi->m_cEntriesSubIndex);

    ASSERT(cbSubIndex(pSi->m_cEntriesSubIndex) % m_cbAlign == 0);
    ASSERT(m_dwlFilePos % m_cbAlign == 0);
  }

  //
  // build the super index
  //
  for(i = 0; i < m_cStreams; i++)
  {
    AVISUPERINDEX *pSuperIndx = (AVISUPERINDEX *)GetIndx(i);
    pSuperIndx->wLongsPerEntry = sizeof(AVISUPERINDEX::_avisuperindex_entry) /
      sizeof(DWORD);
    pSuperIndx->bIndexSubType = 0;
    pSuperIndx->bIndexType = AVI_INDEX_OF_INDEXES;
    pSuperIndx->nEntriesInUse = 0;
    pSuperIndx->dwChunkId = m_rgpStreamInfo[i]->m_moviDataCkid;
    pSuperIndx->dwReserved[0] = 0;
    pSuperIndx->dwReserved[1] = 0;
    pSuperIndx->dwReserved[2] = 0;

  }

  return S_OK;
}

// ------------------------------------------------------------------------
// fills out structures which weren't filled out on creation

HRESULT CAviWrite::CloseHeader()
{

  // go through all the steps even if a previous step failed and
  // record the first error
  HRESULT hr, hrTmp;

  if(hr = CloseStreamHeader(), FAILED(hr))
    DbgLog(( LOG_ERROR, 2,  TEXT("::CloseHeader: CloseStreamHeader failed.")));

  if(hrTmp = CloseIndex(), FAILED(hrTmp))
    DbgLog(( LOG_ERROR, 2,  TEXT("::CloseHeader: CloseIndex failed.")));

  hr = FAILED(hr) ? hr : hrTmp;

  if(hrTmp = CloseStreamFormat(), FAILED(hrTmp))
    DbgLog(( LOG_ERROR, 2,  TEXT("::CloseHeader: CloseStreamFormat failed.")));

  hr = FAILED(hr) ? hr : hrTmp;

  if(hrTmp = CloseStreamName(), FAILED(hrTmp))
    DbgLog(( LOG_ERROR, 0,  TEXT("::CloseHeader: CloseStreamName failed.")));

  hr = FAILED(hr) ? hr : hrTmp;

  if(hrTmp = CloseMainAviHeader(), FAILED(hrTmp))
    DbgLog(( LOG_ERROR, 2,  TEXT("::CloseHeader: CloseMainAviHeader failed.")));

  hr = FAILED(hr) ? hr : hrTmp;

  if(hrTmp = CloseOuterRiff(), FAILED(hrTmp))
    DbgLog(( LOG_ERROR, 2,  TEXT("::CloseHeader: CloseOuterRiff failed.")));

  hr = FAILED(hr) ? hr : hrTmp;

  DbgLog(( LOG_ERROR, 2,  TEXT("CAviWrite::CloseHeader: hr: %08x, %d"),
           hr, GetLastError()));

  return hr;
}

// ------------------------------------------------------------------------
// fills in the AVIH fields. needs to be called after the filter has
// run. note this requires that CloseStreamHeader has already been
// called to pick up updated values from that structure

HRESULT CAviWrite::CloseMainAviHeader()
{
  m_pAvih->dwStreams = m_cStreams;
  if(m_cStreams == 0)
    return S_OK;

  // locate the first video stream
  for(unsigned iVid = 0; iVid < m_cStreams; iVid++)
    if(m_rgpStreamInfo[iVid]->m_mt.majortype == MEDIATYPE_Video)
      break;

  if(iVid == m_cStreams)
  {
    // use values from the first stream
    iVid = 0;
  }

  StreamInfo &rSi = *(m_rgpStreamInfo[iVid]);
  CMediaType *pmt = &m_rgpStreamInfo[iVid]->m_mt;

  LONGLONG unitsElapsed = rSi.m_refTimeEnd.GetUnits() - rSi.m_refTimeStart.GetUnits();
  LONG secondsElapsed = (ULONG)(unitsElapsed / UNITS);

  BOOL bUseAvgTimerPerFrame = FALSE;
  VIDEOINFO *pvi;
  CRefTime rt;
  if(pmt->majortype == MEDIATYPE_Video &&
     pmt->formattype == FORMAT_VideoInfo)
  {
    pvi = (VIDEOINFO*)pmt->Format();
    rt = pvi->AvgTimePerFrame;
    bUseAvgTimerPerFrame = (rt.GetUnits() != 0);
  }
  if(bUseAvgTimerPerFrame)
  {
    m_pAvih->dwMicroSecPerFrame = (ULONG)(rt.GetUnits() / (UNITS / 1000000));
  }
  else
  {
    if(GetStrh(iVid)->dwRate != 0)
    {
      m_pAvih->dwMicroSecPerFrame =
        (DWORD)((double)(GetStrh(iVid)->dwScale) / GetStrh(iVid)->dwRate * 1000000);
    }
    else
    {
      m_pAvih->dwMicroSecPerFrame = 0;
    }
  }

  if(pmt->majortype == MEDIATYPE_Video &&
     pmt->formattype == FORMAT_VideoInfo)
  {
    VIDEOINFO *pvi;
    pvi = (VIDEOINFO*)pmt->Format();

    m_pAvih->dwHeight = pvi->bmiHeader.biHeight;
    m_pAvih->dwWidth = pvi->bmiHeader.biWidth;
  }
  else
  {
    m_pAvih->dwHeight = 0;
    m_pAvih->dwWidth = 0;
  }

  m_pAvih->dwSuggestedBufferSize = rSi.m_cbLargestChunk + sizeof(RIFFCHUNK);

  // really should check all streams for longest elapsed time
  // not maximum but average
  if(secondsElapsed != 0)
    m_pAvih->dwMaxBytesPerSec = (ULONG)(m_dwlFilePos / secondsElapsed);
  else
    m_pAvih->dwMaxBytesPerSec = 0;

  m_pAvih->dwPaddingGranularity = m_cbAlign;
  m_pAvih->dwFlags = AVIF_TRUSTCKTYPE;
  m_pAvih->dwFlags |= m_bOutputIdx1 ? AVIF_HASINDEX : 0;

  // VFW uses dwTotalFrames for the duration, so we have to find the
  // longest stream and convert it to the units we picked earlier.
  if(m_pAvih->dwMicroSecPerFrame != 0)
  {
    REFERENCE_TIME rtMaxDur = m_rgpStreamInfo[0]->m_refTimeEnd;
    for(UINT iStream = 1; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
      rtMaxDur = max(pStreamInfo->m_refTimeEnd, rtMaxDur);
    }
    // convert duration to microseconds and divide by duration of each frame
    m_pAvih->dwTotalFrames = (DWORD)
      (rtMaxDur / 10 / m_pAvih->dwMicroSecPerFrame);
  }
  else
  {
    m_pAvih->dwTotalFrames = 0;
  }

  m_pAvih->dwInitialFrames = 0;
  m_pAvih->dwReserved[0] = 0;
  m_pAvih->dwReserved[1] = 0;
  m_pAvih->dwReserved[2] = 0;
  m_pAvih->dwReserved[3] = 0;

  m_pDmlh->dwGrandFrames = GetStrh(iVid)->dwLength;

  return S_OK;
}

// #define MY_CDISP(x) ((lstrcpy((char *)_alloca(2000), CDisp(x))))

// ------------------------------------------------------------------------
// fill in strh values. needs to be called after running

HRESULT CAviWrite::CloseStreamHeader()
{
  DWORD cSamplesAll = 0;
      
  // determine skew on master stream
  double dScaleMasterStream = 1;
  if(m_lMasterStream != -1)
  {
    ASSERT((ULONG)m_lMasterStream < m_cStreams);

    StreamInfo *pStreamInfo = m_rgpStreamInfo[m_lMasterStream];
    CRefTime rtDuration = pStreamInfo->m_refTimeEnd - pStreamInfo->m_refTimeStart;
    ULONG cTicks = pStreamInfo->CountSamples();
    CRefTime rtDurComputed = pStreamInfo->ConvertTickToTime(cTicks);
    DbgLog((LOG_TRACE, 2, TEXT("avimux: rtDur: %d, ticks: %d, compDur: %d"),
            (long)(rtDuration.Millisecs()), cTicks,
            (long)(rtDurComputed.Millisecs())));

    if(rtDurComputed != 0)
      dScaleMasterStream = (double)(rtDuration) / (double)rtDurComputed;

    DbgLog((LOG_TRACE, 2, TEXT("skew on master stream = %s"),
            CDisp(dScaleMasterStream)));
  }

  // normalize earliest stream to time 0.
  REFERENCE_TIME rtMax = m_rgpStreamInfo[0]->m_refTimeStart;
  for(UINT iStream = 1; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
    if(pStreamInfo->m_refTimeStart < rtMax)
      rtMax = pStreamInfo->m_refTimeStart;
  }
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
    pStreamInfo->m_refTimeStart -= rtMax;
    pStreamInfo->m_refTimeEnd -= rtMax;
  }

  // adjust time stamps for skew
  if(dScaleMasterStream != 1 && dScaleMasterStream != 0)
  {
    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
      if((long)iStream != m_lMasterStream)
      {
        DbgLog((LOG_TRACE, 3,
                TEXT("avimux: adjusting for skew on %d. was %s - %s"),
                iStream, (LPCTSTR)CDisp(pStreamInfo->m_refTimeStart),
                (LPCTSTR)CDisp(pStreamInfo->m_refTimeEnd)));

        pStreamInfo->m_refTimeStart = (REFERENCE_TIME)(
          pStreamInfo->m_refTimeStart /dScaleMasterStream);
        pStreamInfo->m_refTimeEnd = (REFERENCE_TIME)(
          pStreamInfo->m_refTimeEnd / dScaleMasterStream);

        DbgLog((LOG_TRACE, 3,
                TEXT("avimux: adjusting for skew on %d. now %s - %s"),
                iStream, (LPCTSTR)CDisp(pStreamInfo->m_refTimeStart),
                (LPCTSTR)CDisp(pStreamInfo->m_refTimeEnd)));
      }
    }
  }

  if(!DoVfwDwStartHack())
  {
    // adjust start time for each stream so that frame-based streams
    // start on frame boundaries. shortcut: just do the first
    // frame-based one
    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
      if(pStreamInfo->m_mt.majortype != MEDIATYPE_Audio)
      {
        REFERENCE_TIME rtDuration = pStreamInfo->ConvertTickToTime(1);
        REFERENCE_TIME rtRemainder = pStreamInfo->m_refTimeStart % rtDuration;
        if(rtRemainder != 0)
        {
          for(UINT iStream = 0; iStream < m_cStreams; iStream++)
          {
            StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
            pStreamInfo->m_refTimeStart += (rtDuration - rtRemainder);
            pStreamInfo->m_refTimeEnd += (rtDuration - rtRemainder);
          }
        }

        break;
      }
    }
  }
  else
  {
    // Undo some of what we did above and make the earliest audio
    // stream start at zero and record any video frames we have to
    // delete.

    StreamInfo *pStreamInfoAudio = 0;

    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
      if(pStreamInfo->m_mt.majortype == MEDIATYPE_Audio) {
        if(pStreamInfoAudio != 0) {

          // no point fixing one audio stream if we can't fix them
          // all.
          pStreamInfoAudio = 0;
          break;
        }
        else
        {
          pStreamInfoAudio = pStreamInfo;
        }
      }
    }
    if(pStreamInfoAudio)   // found exactly one audio stream
    {
      REFERENCE_TIME llAudioOffset = pStreamInfoAudio->m_refTimeStart;
      if(llAudioOffset != 0)
      {
        for(iStream = 0; iStream < m_cStreams; iStream++)
        {
          ASSERT(pStreamInfoAudio->m_cInitialFramesToDelete == 0);
          StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
          if(pStreamInfo->m_refTimeStart >= llAudioOffset)
          {
            pStreamInfo->m_refTimeStart -= llAudioOffset;
            pStreamInfo->m_refTimeEnd -= llAudioOffset;
          }
          else
          {
            if(pStreamInfo->m_mt.majortype != MEDIATYPE_Audio) {
              pStreamInfo->m_refTimeStart -= llAudioOffset;
              pStreamInfo->m_refTimeEnd -= llAudioOffset;
              ASSERT(pStreamInfo->m_refTimeStart < 0);

              // !!! always rounding down
              pStreamInfo->m_cInitialFramesToDelete =
                pStreamInfo->ConvertTimeToTick(-pStreamInfo->m_refTimeStart.GetUnits());

              // deleting more frames than there are?
              pStreamInfo->m_cInitialFramesToDelete =
                min(pStreamInfo->m_cInitialFramesToDelete, pStreamInfo->m_cSamples);

              // this frame-based stream now starts at 0.
              pStreamInfo->m_refTimeStart = 0;

              pStreamInfo->m_mtStart += (LONGLONG)pStreamInfo->m_cInitialFramesToDelete;

            } // !audio
          } // stream starts before audio
        } // for
      } // audio starts after 0.
    } // found one audio stream
  }

  // fill in (strh) for each stream;
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
    ASSERT(iStream == pStreamInfo->m_stream);
    AVISTREAMHEADER *pStrh = GetStrh(iStream);
    cSamplesAll += pStreamInfo->m_cSamples;

    pStrh->dwFlags = 0;
    pStrh->wPriority = 0;
    pStrh->wLanguage = 0;
    pStrh->dwInitialFrames = 0;
    pStrh->dwSuggestedBufferSize = pStreamInfo->m_cbLargestChunk + sizeof(RIFFCHUNK);

    ASSERT(pStreamInfo->m_refTimeStart >= 0);

    if(pStreamInfo->m_mtStart != -1)
      ASSERT(pStreamInfo->m_mt.majortype != MEDIATYPE_Audio);

    pStrh->dwStart = (DWORD)(pStreamInfo->ConvertTimeToTick(
        pStreamInfo->m_refTimeStart.GetUnits()));

    if(pStreamInfo->m_mt.majortype == MEDIATYPE_Video &&
       pStreamInfo->m_mt.formattype == FORMAT_VideoInfo)
    {
      VIDEOINFO *pvi = (VIDEOINFO *)(pStreamInfo->m_mt.Format());
      pStrh->fccHandler = MpVideoGuidSubtype_Fourcc(pStreamInfo->m_mt.Subtype());
      pStrh->fccType = FCC('vids');

      pStrh->dwLength = pStreamInfo->m_cSamples - pStreamInfo->m_cInitialFramesToDelete;
      SetFrameRateAndScale(pStrh, pStreamInfo, dScaleMasterStream);
      pStrh->dwQuality = 0;
      pStrh->dwSampleSize = 0;
      pStrh->rcFrame.left = (short)pvi->rcSource.left;
      pStrh->rcFrame.top = (short)pvi->rcSource.top;
      pStrh->rcFrame.right = (short)pvi->rcSource.right;
      pStrh->rcFrame.bottom = (short)pvi->rcSource.bottom;
    }
    else if(pStreamInfo->m_mt.majortype == MEDIATYPE_Audio &&
            pStreamInfo->m_mt.formattype == FORMAT_WaveFormatEx)
    {
      pStrh->fccType = FCC('auds');
      pStrh->fccHandler = 0;
      WAVEFORMATEX *pwfe = (WAVEFORMATEX *)pStreamInfo->m_mt.Format();
      pStrh->dwScale = pwfe->nBlockAlign;

      if(m_lMasterStream != -1 && (long)iStream != m_lMasterStream)
      {
        const DWORD dwNewSps = (DWORD)(pwfe->nSamplesPerSec / dScaleMasterStream);
        DbgLog((LOG_TRACE, 2, TEXT("avimux: adjusting audio from %d to %d"),
                pwfe->nSamplesPerSec, dwNewSps));
        pwfe->nSamplesPerSec = dwNewSps;
        pwfe->nAvgBytesPerSec = (DWORD)(pwfe->nAvgBytesPerSec / dScaleMasterStream);
      }
      pStrh->dwRate = pwfe->nAvgBytesPerSec;

      DbgLog((LOG_TRACE, 5, TEXT("avimux: audio: dwScale %d, dwRate %d"),
              pStrh->dwScale, pStrh->dwRate));
      DbgLog((LOG_TRACE, 5, TEXT("nSamplesPerSec %d, nAvgBytesPerSec %d, nBlockAlign %d"),
              pwfe->nSamplesPerSec, pwfe->nAvgBytesPerSec, pwfe->nBlockAlign));


      pStrh->dwLength = ((CAudioStream *)(pStreamInfo))->
          GetTicksInSample(pStreamInfo->m_dwlcBytes);

      pStrh->dwQuality = 0;
      pStrh->dwSampleSize = pwfe->nBlockAlign;
      pStrh->rcFrame.left = 0;
      pStrh->rcFrame.top = 0;
      pStrh->rcFrame.right = 0;
      pStrh->rcFrame.bottom = 0;
    }
    else
    {
      // assume it's something frame based

      // we only connect with mediatypes made from fourccs
      ASSERT(FOURCCMap(pStreamInfo->m_mt.majortype.Data1) == pStreamInfo->m_mt.majortype ||
             pStreamInfo->m_mt.majortype == MEDIATYPE_AUXLine21Data);

      if(pStreamInfo->m_mt.majortype != MEDIATYPE_AUXLine21Data) {
          pStrh->fccType = pStreamInfo->m_mt.majortype.Data1;
      } else {
          pStrh->fccType = FCC('al21');
      }

      if(FOURCCMap(pStreamInfo->m_mt.subtype.Data1) ==
         pStreamInfo->m_mt.subtype)
      {
        pStrh->fccHandler = pStreamInfo->m_mt.subtype.Data1;
      }
      else
      {
        pStrh->fccHandler = 0;
      }

      pStrh->dwLength = pStreamInfo->m_cSamples -
        pStreamInfo->m_cInitialFramesToDelete;
      SetFrameRateAndScale(pStrh, pStreamInfo, dScaleMasterStream);
    }

    // we got more samples than we expected.
    if(pStrh->dwLength > pStreamInfo->m_cTicksExpected &&
       pStreamInfo->m_cTicksExpected != 0)
    {
      DbgLog((LOG_TRACE, 1, TEXT("upstream filter lied about duration")));
    }

#ifdef DEBUG
    if(pStreamInfo->m_refTimeEnd != pStreamInfo->m_refTimeStart )
    {
      // I see a divide by zero if I do this all at once
      LONGLONG llRate = pStrh->dwLength * UNITS;
      llRate /= (pStreamInfo->m_refTimeEnd - pStreamInfo->m_refTimeStart);
      llRate /= MILLISECONDS;
      DbgLog((LOG_TRACE, 2, TEXT("stream %d: actual rate = %d mHz"),
              iStream, (long)(llRate)));
    }
#endif

  } // for loop

  // used to erase files that can't be played back
  if(cSamplesAll == 0) {
      return HRESULT_FROM_WIN32(ERROR_EMPTY);
  }

  return S_OK;
}

HRESULT CAviWrite::CloseStreamName()
{
    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pStreamInfo = m_rgpStreamInfo[iStream];
      if(pStreamInfo->m_szStrn) {
          lstrcpyA((char *)(m_rgbHeader + pStreamInfo->m_posStrn),
                   pStreamInfo->m_szStrn);
      }
    }

    return S_OK;
}

void CAviWrite::SetFrameRateAndScale(
  AVISTREAMHEADER *pStrh,
  StreamInfo *pSi,
  double dScaleMasterStream)
{
  REFERENCE_TIME rtDuration = pSi->ConvertTickToTime(1);
  if(m_lMasterStream == -1 ||
     m_lMasterStream == (long)pSi->m_stream ||
     dScaleMasterStream == 1 ||
     pStrh->dwLength == 0       // check for divide by zero.
     )
  {

    // recognize standard rates and cook into known rationals. handle
    // the source rounding fractions up or down. Also handle the user
    // typing 29.97fps vs a source file which recorded 30000/1001 fps
    switch(rtDuration)
    {
      case 333666:
      case 333667:
        // 29.97fps (1e7 / (30000 / 1001) = 333666.666667 units, 1e7 / 29.97 = 333667.000334)
        pStrh->dwScale = 1001;
        pStrh->dwRate = 30000;
        DbgLog((LOG_TRACE, 3, TEXT("avimux: cooked rate 29.97")));
        break;

      case 416666:
      case 416667:
        // 24.00 (416666.666667)
        pStrh->dwScale = 1;
        pStrh->dwRate = 24;
        DbgLog((LOG_TRACE, 3, TEXT("avimux: cooked rate 24")));
        break;

      case 667333:
      case 667334:              // this number was wrong previously
        // 14.985 (667333.333334 or 667334.000667)
        pStrh->dwScale = 1001;
        pStrh->dwRate = 15000;
        DbgLog((LOG_TRACE, 3, TEXT("avimux: cooked rate 14.985")));
        break;

      case 666666:
      case 666667:
        // 15.000 (666666.666667)
        pStrh->dwScale = 1;
        pStrh->dwRate = 15;
        break;

      default:
        pStrh->dwScale = (DWORD)rtDuration;
        pStrh->dwRate = UNITS;
        DbgLog((LOG_TRACE, 3, TEXT("avimux: uncooked rate %d units"),
                (DWORD)(rtDuration)));
        break;
    }
  }
  else
  {
      // pStrh->dwLength checked for 0 above
      pStrh->dwScale = (DWORD)((pSi->m_refTimeEnd - pSi->m_refTimeStart) / pStrh->dwLength );
      DbgLog((LOG_TRACE, 2, TEXT("avimux: adjusted rate from %d to %d"),
              (DWORD)rtDuration, pStrh->dwScale));
      pStrh->dwRate = UNITS;
  }
}

// ------------------------------------------------------------------------
// fill in the strf values. can be called before or after running.

HRESULT CAviWrite::CloseStreamFormat()
{
  // fill in (strf) for each stream;
  for(unsigned i = 0; i < m_cStreams; i++)
  {
    StreamInfo *pStreamInfo = m_rgpStreamInfo[i];
    if(pStreamInfo->m_mt.majortype == MEDIATYPE_Video &&
       pStreamInfo->m_mt.formattype == FORMAT_VideoInfo)
    {
      VIDEOINFO *pvi = (VIDEOINFO *)(pStreamInfo->m_mt.Format());
      CopyMemory(GetStrf(i),
                 &pvi->bmiHeader,
                 pStreamInfo->m_cbStrf);
    }
    else
    {
      CopyMemory(
        GetStrf(i),
        pStreamInfo->m_mt.Format(),
        pStreamInfo->m_cbStrf);
    }
  }

  return S_OK;
}

// ------------------------------------------------------------------------
// CloseIndex. flushes sub indexes and propagates sub indexes up so
// they are before the data they index. also builds idx1 index.
//

HRESULT CAviWrite::CloseIndex()
{
  HRESULT hr;

  if(hr = m_pAllocator->Decommit(), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,  TEXT("CAviWrite::CloseIndex: decommit failed.")));
    return hr;
  }

  // this moves the index chunks and builds the old index
  if(hr = BuildIdx1(), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,  TEXT("CAviWrite::CloseIndex: BuildIdx1 failed.")));
    return hr;
  }

  return S_OK;
}

// ------------------------------------------------------------------------

HRESULT CAviWrite::CloseOuterRiff()
{
  HRESULT hr;

  ASSERT(m_cOutermostRiff < C_OUTERMOST_RIFF);

  //
  // fill in first RIFF-AVI_, LIST-movi pair
  //
  DWORD dwSize;
  if(m_cOutermostRiff == 0)
  {
    ASSERT(m_dwlFilePos <= MAXDWORD);
    dwSize = (DWORD)m_dwlFilePos;
  }
  else
  {
    dwSize = m_rgOutermostRiff[0].size;
  }

  ASSERT(m_bOutputIdx1 || m_cbIdx1 == 0);
  m_pAvi_->cb = dwSize - 0 - sizeof(RIFFCHUNK);
  m_pMovi->cb = (DWORD)(dwSize - ((BYTE *)m_pMovi - m_rgbHeader) - sizeof(RIFFCHUNK) - m_cbIdx1);

  ASSERT((sizeof(RIFFLIST) * 2 + sizeof(RIFFCHUNK)) % sizeof(DWORD) == 0);
  DWORD rgdw[(sizeof(RIFFLIST) * 2 + sizeof(RIFFCHUNK)) / sizeof(DWORD)];
  RIFFLIST *pRiffListRIFF = (RIFFLIST *)rgdw;
  RIFFLIST *pRiffListMOVI = pRiffListRIFF + 1;
  RIFFCHUNK *pRiffChunkJUNK = (RIFFCHUNK *)(pRiffListMOVI + 1);

  //
  // rest of the RIFF-AVI_ lists
  //
  for(unsigned i = 1; i <= m_cOutermostRiff; i++)
  {
    SizeAndPosition& rSap = m_rgOutermostRiff[i];
    pRiffListRIFF->fcc = FCC('RIFF');
    if(i == m_cOutermostRiff)
    {
      ASSERT(m_dwlFilePos - m_dwlCurrentRiffAvi_ <= MAXDWORD);
      pRiffListRIFF->cb = (DWORD)(m_dwlFilePos - m_dwlCurrentRiffAvi_) - sizeof(RIFFCHUNK);
    }
    else
    {
      ASSERT(rSap.pos % m_cbAlign == 0);
      pRiffListRIFF->cb = rSap.size - sizeof(RIFFCHUNK);
    }
    pRiffListRIFF->fccListType = FCC('AVIX');

    pRiffListMOVI->fcc = FCC('LIST');
    pRiffListMOVI->cb = pRiffListRIFF->cb - sizeof(FOURCC) - sizeof(RIFFCHUNK);
    pRiffListMOVI->fccListType = FCC('movi');

    ULONG cb = 2 * sizeof(RIFFLIST);
    AddJunk(cb, m_cbAlign, (BYTE *)rgdw);
    if(cb > sizeof(rgdw))
      cb = sizeof(rgdw);

    DWORDLONG dwlPos;
    if(i == m_cOutermostRiff)
      dwlPos = m_dwlCurrentRiffAvi_;
    else
      dwlPos = rSap.pos;

    hr = IStreamWrite(dwlPos, (BYTE*)rgdw, cb);
    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::CloseOuterRiff: SynchronousWrite failed.")));
      return hr;
    }
  }

  return S_OK;
}

// ------------------------------------------------------------------------
// BuildIdx1. creates the idx1 chunk in memory if necessary and
// propagates the sub index chunks

HRESULT CAviWrite::BuildIdx1()
{
  HRESULT hr;
  ULONG iIdx1 = 0;

  if(!m_bOutputIdx1)
  {
    ASSERT(!DoVfwDwStartHack());
    //
    // just propagate the sub index chunks
    //
    for(unsigned iStream = 0; iStream < m_cStreams; iStream++)
    {
      StreamInfo *pSi = m_rgpStreamInfo[iStream];
      CWalkIndex *pWalkIndex = new CWalkIndex(this, pSi);
      if(pWalkIndex == 0)
        return E_OUTOFMEMORY;

      if((hr = pWalkIndex->Init(), FAILED(hr)) ||
         (hr = pWalkIndex->Close(), FAILED(hr)))
      {
        DbgLog(( LOG_ERROR, 2,
                 TEXT("CAviWrite::BuildIdx1: CWalkIndex failed.")));
        delete pWalkIndex;
        return hr;
      }

      delete pWalkIndex;
    }
    return S_OK;
  } // !m_bOutputIdx1

  ASSERT(m_bOutputIdx1);

  hr = S_OK;

  if(m_cbIdx1 == 0)
    AllocateIdx1(FALSE);

  AVIOLDINDEX *pIdx1 = (AVIOLDINDEX *)new BYTE[m_cbIdx1];
  if (NULL == pIdx1) {
      return E_OUTOFMEMORY;
  }
  ZeroMemory(pIdx1, m_cbIdx1);
  CWalkIndex *rgpWalkIndex[C_MAX_STREAMS];
  unsigned iStream;
  ULONG iSample;

  for(iStream = 0; iStream < m_cStreams; iStream++)
    rgpWalkIndex[iStream] = 0;

  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    rgpWalkIndex[iStream] = new CWalkIndex(this, m_rgpStreamInfo[iStream]);
    if(rgpWalkIndex[iStream] == 0)
    {
      hr = E_OUTOFMEMORY;
      goto Done;
    }
    if(hr = rgpWalkIndex[iStream]->Init(), FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::BuildIdx1: CWalkIndex failed.")));
      goto Done;
    }
  }

  {
    ULONG cIdx1EntriesInitially = m_cIdx1Entries;
    if(DoVfwDwStartHack())
    {
      for(UINT iStream = 0; iStream < m_cStreams; iStream++)
      {
        StreamInfo *pSi = m_rgpStreamInfo[iStream];
        if(m_cIdx1Entries < pSi->m_cInitialFramesToDelete)
        {
          DbgBreak("internal error");
          return E_UNEXPECTED;
        }
        m_cIdx1Entries -= pSi->m_cInitialFramesToDelete;
      }
    }

    DbgLog((LOG_TRACE, 5,
            TEXT("avimux: BuildIdx1: %d idx1 entries (initially: %d)"),
            m_cIdx1Entries, cIdx1EntriesInitially));
  }

  for(iSample = 0; iSample < m_cIdx1Entries; iSample++)
  {
    // first entry is junk for compatibility with mciavi
    iIdx1 = iSample + 1;

    // bad way to check whether the index is full !!!
    if((BYTE*)&(pIdx1->aIndex[iIdx1 + 1]) > (BYTE*)pIdx1 + m_cbIdx1)
      break;

    unsigned nextStreamWithSample = C_MAX_STREAMS;
    DWORDLONG dwlNextSamplePos = 0;
    DWORD dwNextSampleSize = 0;
    BOOL bNextSampleIsSyncPoint = FALSE;

    // loop over streams to find next index entry (entry whose sample
    // is earliest in the file)
    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      DWORD dwSize;
      DWORDLONG dwlPos;
      BOOL bSyncPoint;

      HRESULT hr = rgpWalkIndex[iStream]->Peek(&dwlPos, &dwSize, &bSyncPoint);
      if(SUCCEEDED(hr) &&
         (nextStreamWithSample == C_MAX_STREAMS || dwlPos < dwlNextSamplePos))
      {
        nextStreamWithSample = iStream;
        dwlNextSamplePos = dwlPos;
        dwNextSampleSize = dwSize;
        bNextSampleIsSyncPoint = bSyncPoint;
      }
    }

    // didn't find an entry
    if(nextStreamWithSample == C_MAX_STREAMS)
    {
      DbgBreak("internal error");
      hr = E_UNEXPECTED;
      goto Done;
    }
    else
    {
      DbgLog((LOG_TRACE, 0x20,
              TEXT("avimux:BuildIdx1: idx1 entry: %d, stream: %d, pos: %08x"),
              iIdx1, nextStreamWithSample, (DWORD)dwlNextSamplePos));
    }

    rgpWalkIndex[nextStreamWithSample]->Advance();

    pIdx1->aIndex[iIdx1].dwChunkId = bNextSampleIsSyncPoint ?
      m_rgpStreamInfo[nextStreamWithSample]->m_moviDataCkid :
      m_rgpStreamInfo[nextStreamWithSample]->m_moviDataCkidCompressed;

    pIdx1->aIndex[iIdx1].dwFlags = bNextSampleIsSyncPoint ?
      AVIIF_KEYFRAME :
      0;

    if(dwlNextSamplePos >= m_cbRiffMax)
    {
      DbgBreak("avimux: unexpected error");
      hr = E_UNEXPECTED;
      goto Done;
    }

    pIdx1->aIndex[iIdx1].dwOffset = (DWORD)dwlNextSamplePos - sizeof(RIFFCHUNK);

    bool fDbgSawFirstNonDropFrame = false;

    // work around vfw hang by specifying non-zero offset for drop
    // frames. only drop frames have dwSize==0, and I make sure all
    // drop frames have non-zero byte offsets. note vfw actually puts
    // the drop frame in the movi chunk as well, but we don't
    if(dwNextSampleSize == 0 && iIdx1 > 1)
    {
        if(fDbgSawFirstNonDropFrame) {
            ASSERT(pIdx1->aIndex[iIdx1].dwOffset == 0);
            ASSERT(pIdx1->aIndex[iIdx1 - 1].dwOffset != 0);
        }

        pIdx1->aIndex[iIdx1].dwOffset = pIdx1->aIndex[iIdx1 - 1].dwOffset;
    }
    if(dwNextSampleSize != 0) {
        fDbgSawFirstNonDropFrame = true;
    }

    if(fDbgSawFirstNonDropFrame) {
        ASSERT(pIdx1->aIndex[iIdx1].dwOffset != 0);
    }

    pIdx1->aIndex[iIdx1].dwSize = dwNextSampleSize;

  }

  // mark the remaining index entries invalid.
  while((BYTE*)&(pIdx1->aIndex[++iIdx1 + 1]) <= (BYTE*)pIdx1 + m_cbIdx1)
    pIdx1->aIndex[iIdx1].dwChunkId = FCC('7Fxx');


  pIdx1->fcc = FCC('idx1');
  pIdx1->cb = m_cbIdx1 - sizeof(RIFFCHUNK);

  pIdx1->aIndex[0].dwChunkId = FCC('7Fxx');
  pIdx1->aIndex[0].dwFlags = 0;
  pIdx1->aIndex[0].dwOffset = (DWORD)((BYTE*)m_pMovi - m_rgbHeader + sizeof(RIFFLIST));
  pIdx1->aIndex[0].dwSize = 0;

  hr = IStreamWrite(m_posIdx1, (BYTE*)pIdx1, m_cbIdx1);
  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::BuildIdx1: SynchronousWrite failed.")));
    goto Done;
  }

Done:

  //
  // finish propagating the index / close them.
  //

  HRESULT hrClose = S_OK;
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    if(rgpWalkIndex[iStream])
    {
      if(hrClose = rgpWalkIndex[iStream]->Close(), FAILED(hrClose))
      {
        DbgLog(( LOG_ERROR, 2,
                 TEXT("CAviWrite::BuildIdx1: CWalkIndex close failed.")));
      }
      delete rgpWalkIndex[iStream];
    }
  }
  delete pIdx1;

  return FAILED(hr) ? hr : hrClose;
}

// ------------------------------------------------------------------------
// return pointers to stream header and format structures

AVISTREAMHEADER *CAviWrite::GetStrh(unsigned stream)
{
  ASSERT(stream < m_cStreams);
  return (AVISTREAMHEADER *)
    (m_rgbHeader + m_rgpStreamInfo[stream]->m_posStrl + sizeof(RIFFLIST));
}

BYTE *CAviWrite::GetStrf(unsigned stream)
{
    ASSERT(stream < m_cStreams);
    ASSERT(m_rgpStreamInfo[stream]->m_posStrl +
           sizeof(RIFFLIST) +          // strl
           sizeof(AVISTREAMHEADER)     // strh
           == m_rgpStreamInfo[stream]->m_posStrf);
  
    return m_rgbHeader +
        m_rgpStreamInfo[stream]->m_posStrl +
        sizeof(RIFFLIST) +          // strl
        sizeof(AVISTREAMHEADER) +   // strh
        sizeof(RIFFCHUNK);          // strf RIFFCHUNK
}

AVIMETAINDEX *CAviWrite::GetIndx(unsigned stream)
{
  ASSERT(stream < m_cStreams);
  return (AVIMETAINDEX *)(m_rgbHeader + m_rgpStreamInfo[stream]->m_posIndx);
}

// ------------------------------------------------------------------------
// load a new indx entry and set initial values

HRESULT CAviWrite::InitIx(unsigned stream)
{
  StreamInfo &rStreamInfo = *(m_rgpStreamInfo[stream]);
  // !!! the critsec is locked. not really a problem if getbuffer
  // blocks, but probably better if this is done outside
  HRESULT hr = m_pAllocator->GetBuffer(&rStreamInfo.m_pSampleStdIx, 0, 0, 0);
  if(FAILED(hr))
    return hr;
  ASSERT(rStreamInfo.m_pSampleStdIx != 0);

  if(m_IlMode == INTERLEAVE_FULL)
  {
    BYTE *pbIx;
    rStreamInfo.m_pSampleStdIx->GetPointer(&pbIx);
    ZeroMemory(pbIx, rStreamInfo.m_pSampleStdIx->GetSize());
  }

  AVISTDINDEX *pStdIndx = GetCurrentIx(stream);

  rStreamInfo.m_cIx++;

  pStdIndx->fcc = FCC('ix00');
  Hexrg2bFromW((BYTE*)&pStdIndx->fcc + 2, stream);

  pStdIndx->cb = cbSubIndex(rStreamInfo.m_cEntriesSubIndex) - sizeof(RIFFCHUNK);
  pStdIndx->wLongsPerEntry = sizeof(AVISTDINDEX_ENTRY) / sizeof(LONG);
  pStdIndx->bIndexSubType = 0;
  pStdIndx->bIndexType = AVI_INDEX_OF_CHUNKS;
  pStdIndx->nEntriesInUse = 0;
  pStdIndx->dwChunkId = rStreamInfo.m_moviDataCkid;
  pStdIndx->qwBaseOffset = 0;
  pStdIndx->dwReserved_3 = 0;

  return S_OK;
}

ULONG CAviWrite::GetIndexSize(AVIMETAINDEX *pIndex)
{
  ULONG cb = (ULONG)((BYTE *)pIndex->adwIndex - (BYTE *)pIndex);
  cb += pIndex->wLongsPerEntry * sizeof(DWORD) * pIndex->nEntriesInUse;
  return cb;
}

AVISTDINDEX *CAviWrite::GetCurrentIx(unsigned stream)
{
  AVISTDINDEX *pStdIndx;
  HRESULT hr = m_rgpStreamInfo[stream]->m_pSampleStdIx->GetPointer((BYTE**)&pStdIndx);
  ASSERT(SUCCEEDED(hr));
  return pStdIndx;
}

// ------------------------------------------------------------------------
// aligns the end of a chunk.

void CAviWrite::AddJunk(DWORD& rdwSize, DWORD dwAlign, BYTE *pb)
{
  // RIFF requires new chunks to start on WORD boundaries. implicitly
  // requiring an extra byte after the sample.
  if(rdwSize % sizeof(WORD) != 0)
    rdwSize ++;

  if(rdwSize % dwAlign != 0)
  {
    WORD *pw = (WORD *)(pb + rdwSize);

    rdwSize += sizeof(RIFFCHUNK);
    DWORD cb = 0;

    if(rdwSize % dwAlign != 0)
    {
      cb = dwAlign - rdwSize % dwAlign;
      rdwSize += cb;
    }

    const DWORD dwJunk = FCC('JUNK');

    *pw++ = ((WORD*)&dwJunk)[0];
    *pw++ = ((WORD*)&dwJunk)[1];
    *pw++ = ((WORD*)&cb)[0];
    *pw   = ((WORD*)&cb)[1];
  }

  ASSERT(rdwSize % dwAlign == 0);
}

// ------------------------------------------------------------------------
// used when there is not enough room for the junk chunk in this
// buffer

void CAviWrite::AddJunkOtherAllocator(
  DWORD& rdwSize,
  DWORD dwAlign,
  BYTE *pb,
  IMediaSample *pSample,
  BYTE **ppJunkSector)
{
  *ppJunkSector = 0;
  // RIFF requires new chunks to start on WORD boundaries
  if(rdwSize % sizeof(WORD) != 0)
    rdwSize ++;

  if(rdwSize % dwAlign != 0)
  {
    ASSERT(m_cbAlign != 1);
    WORD *pw = (WORD *)(pb + rdwSize);

    rdwSize += sizeof(RIFFCHUNK);
    DWORD dwOriginalSize = rdwSize;
    DWORD cb = 0;

    if(rdwSize % dwAlign != 0)
    {
      cb = dwAlign - rdwSize % dwAlign;
      rdwSize += cb;
    }

    const DWORD dwJunk = FCC('JUNK');
    ASSERT((pSample->GetSize() + m_cbPrefix) % m_cbAlign == 0);
    long cbDiff = pSample->GetSize() + m_cbPrefix - dwOriginalSize;
    if(cbDiff >= 0)
    {
      *pw++ = ((WORD*)&dwJunk)[0];
      *pw++ = ((WORD*)&dwJunk)[1];
      *pw++ = ((WORD*)&cb)[0];
      *pw   = ((WORD*)&cb)[1];
    }
    else
    {
      ASSERT(-cbDiff % 2 == 0);
      rdwSize = pSample->GetSize() + m_cbPrefix;
      switch(cbDiff)
      {
        case -6:
          *pw = ((WORD*)&dwJunk)[0];
          *ppJunkSector = m_rgpbJunkSector[0];
          break;

        case -4:
          *pw++ = ((WORD*)&dwJunk)[0];
          *pw   = ((WORD*)&dwJunk)[1];
          *ppJunkSector = m_rgpbJunkSector[1];
          break;

        case -2:
          *pw++ = ((WORD*)&dwJunk)[0];
          *pw++ = ((WORD*)&dwJunk)[1];
          *pw   = ((WORD*)&cb)[0];
          *ppJunkSector = m_rgpbJunkSector[2];
          break;

        default:
          DbgBreak("unexpected error w/ JUNK chunks.");
      }
    }
  }

  ASSERT(rdwSize % dwAlign == 0);
}

ULONG CAviWrite::GetCbJunk(DWORD dwSize, DWORD dwAlign)
{
  if(dwSize % dwAlign != 0)
  {
    dwSize += sizeof(RIFFCHUNK);
    if(dwSize % dwAlign != 0)
    {
      dwSize += dwAlign - dwSize % dwAlign;
    }
  }

  return dwSize;
}

void CAviWrite::SetList(void *pList, FOURCC ckid, DWORD dwSize, FOURCC listid)
{
  DbgAssertAligned( pList, sizeof(DWORD) );
  ((RIFFLIST *)pList)->fcc = ckid;
  ((RIFFLIST *)pList)->cb = dwSize;
  ((RIFFLIST *)pList)->fccListType = listid;

}

void CAviWrite::SetChunk(void *pChunk, FOURCC ckid, DWORD dwSize)
{
  DbgAssertAligned(pChunk, sizeof(DWORD) );
  ((RIFFCHUNK *)pChunk)->fcc = ckid;
  ((RIFFCHUNK *)pChunk)->cb = dwSize;
}

// ------------------------------------------------------------------------
// update index for new sample

HRESULT CAviWrite::IndexSample(
  unsigned stream,
  DWORDLONG dwlPos,
  ULONG ulSize,
  BOOL bSyncPoint)
{
  HRESULT hr = S_OK;

  ASSERT(stream < m_cStreams);
  StreamInfo &rStreamInfo = *(m_rgpStreamInfo[stream]);
  AVISTDINDEX *pStdIndx = GetCurrentIx(stream);

  // update subindex
  DbgLog((LOG_TRACE, 0x20,
          TEXT("avimux::IndexSample: stream %d: subindex offset %d"),
          rStreamInfo.m_stream, pStdIndx->nEntriesInUse));
  if(pStdIndx->nEntriesInUse >= rStreamInfo.m_cEntriesSubIndex)
  {
    DbgBreak("problem counting index entries");
    return E_UNEXPECTED;
  }

  if(pStdIndx->qwBaseOffset == 0) {
      pStdIndx->qwBaseOffset = dwlPos;
  }

  // dwlPos can be 0 for dropped frames and this underflows
  DWORDLONG dwlOffsetFromBase = (dwlPos - pStdIndx->qwBaseOffset + sizeof(RIFFCHUNK));
  if(dwlPos == 0)
  {
      dwlOffsetFromBase = 0;

      // should happen for dropped frames only
      ASSERT(ulSize == 0);
  }
  else if(dwlOffsetFromBase > CB_SUBINDEX_OVERFLOW)
  {
      DbgBreak("subindex overflow error");
  }

  AVISTDINDEX_ENTRY *aIndex = &pStdIndx->aIndex[pStdIndx->nEntriesInUse++];
  aIndex->dwOffset = (DWORD)(dwlOffsetFromBase);
  aIndex->dwSize = ulSize;

  if(!bSyncPoint)
    aIndex->dwSize |= AVISTDINDEX_DELTAFRAME;

  if(m_bOutputIdx1 && m_cOutermostRiff == 0)
  {
    ASSERT(m_dwlFilePos <= m_cbRiffMax);
    m_cIdx1Entries++;

    ASSERT(m_dwlFilePos % m_cbAlign == 0);
  }

  // if index entry is full, write it out and allocate a new one.
  if(pStdIndx->nEntriesInUse >= rStreamInfo.m_cEntriesSubIndex)
  {
    hr = DoFlushIndex(rStreamInfo);
  }

  return hr;
}

// a subindex can only index data that spans 4gb because it uses a 32
// bit integer. if we are about to exceed the 4gb limit, flush the
// subindex and start a new one.
//
HRESULT CAviWrite::HandleSubindexOverflow(
  unsigned stream)
{
    HRESULT hr = S_OK;
    ASSERT(stream < m_cStreams);
    StreamInfo &rStreamInfo = *(m_rgpStreamInfo[stream]);
    AVISTDINDEX *pStdIndx = GetCurrentIx(stream);

    // dwlPos cannot be 0 because we don't call this function for
    // dropped frames.
    ASSERT(m_dwlFilePos != 0);

    if(pStdIndx->qwBaseOffset != 0)
    {
        DWORDLONG dwlOffsetFromBase = (m_dwlFilePos - pStdIndx->qwBaseOffset +
                                       sizeof(RIFFCHUNK));

        if(dwlOffsetFromBase > CB_SUBINDEX_OVERFLOW)
        {
            DbgLog((LOG_TRACE, 1, TEXT("subindex overflow.")));
            hr = DoFlushIndex(rStreamInfo);
        }
    }

    return hr;
}

HRESULT CAviWrite::DoFlushIndex(StreamInfo &rStreamInfo)
{
    HRESULT hr = S_OK;


    // write out this one and create a new one.
    hr = FlushIx(rStreamInfo.m_stream);
    if(hr != S_OK)
        return hr;

    hr = InitIx(rStreamInfo.m_stream);
    if(FAILED(hr))
        return hr;


    return hr;
}

void CAviWrite::AllocateIdx1(BOOL bStreaming)
{
  DWORD dwIdx1Size = sizeof(AVIOLDINDEX);
  ASSERT(dwIdx1Size == 8);
  dwIdx1Size += m_cIdx1Entries * sizeof(AVIOLDINDEX::_avioldindex_entry);
  // first entry is used for relative index
  dwIdx1Size += sizeof(AVIOLDINDEX::_avioldindex_entry);
  dwIdx1Size = GetCbJunk(dwIdx1Size, m_cbAlign);

  ASSERT(m_dwlFilePos < MAXDWORD);
  ASSERT(m_dwlFilePos % sizeof(WORD) == 0);
  m_posIdx1 = (ULONG)(m_dwlFilePos);
  m_cbIdx1 = dwIdx1Size;

  m_dwlFilePos += dwIdx1Size;

  if(bStreaming)
  {
    DbgCheckFilePos();
  }
}


// ------------------------------------------------------------------------
// start a new RIFF chunk if necessary. Save size and position of the
// the previous one.

HRESULT CAviWrite::NewRiffAvi_()
{
  DWORDLONG cbRiff = m_dwlFilePos - m_dwlCurrentRiffAvi_ + CB_NEW_RIFF_PADDING;
  if(cbRiff >= m_cbRiffMax ||
     (m_cOutermostRiff == 0 &&
      m_bOutputIdx1 &&
      cbRiff + m_cIdx1Entries * sizeof(AVIOLDINDEX::_avioldindex_entry) >= m_cbRiffMax)
     )
  {
    if(m_bOutputIdx1 && m_cbIdx1 == 0)
      AllocateIdx1(TRUE);

    m_rgOutermostRiff[m_cOutermostRiff].pos = m_dwlCurrentRiffAvi_;
    m_rgOutermostRiff[m_cOutermostRiff].size =
      (DWORD)(m_dwlFilePos - m_dwlCurrentRiffAvi_);

    m_dwlCurrentRiffAvi_ = m_dwlFilePos;

    ULONG seek = 2 * sizeof(RIFFLIST);
    m_dwlFilePos += 2 * sizeof(RIFFLIST);
    if(m_dwlFilePos % m_cbAlign != 0)
    {
      if(m_cbAlign - m_dwlFilePos % m_cbAlign < sizeof(RIFFCHUNK))
      {
        // space for JUNK chunk
        m_dwlFilePos += sizeof(RIFFCHUNK);
        seek += sizeof(RIFFCHUNK);
      }

      if(m_dwlFilePos % m_cbAlign != 0)
      {
        // padding for alignment
        seek +=  (ULONG)(m_cbAlign - m_dwlFilePos % m_cbAlign);
        m_dwlFilePos += m_cbAlign - m_dwlFilePos % m_cbAlign;
      }
    }

    DbgCheckFilePos();

    if(++m_cOutermostRiff >= C_OUTERMOST_RIFF)
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::NewRiffAvi_: too many RIFF chunks.")));
      return VFW_E_BUFFER_OVERFLOW;
    }
  }

  return S_OK;
}

// update the super index to include the current index chunk at byte
// offset dwlPos.
//
HRESULT CAviWrite::UpdateSuperIndex(
  unsigned stream,
  DWORDLONG dwlPos)
{
  AVISUPERINDEX *pSuperIndx = (AVISUPERINDEX *)GetIndx(stream);
  DWORD &riEntry = pSuperIndx->nEntriesInUse;

  StreamInfo *pStreamInfo = m_rgpStreamInfo[stream];
  AVISTDINDEX *pStdIndx = GetCurrentIx(stream);

  ASSERT(riEntry < pStreamInfo->m_cEntriesSuperIndex);

  pSuperIndx->aIndex[riEntry].qwOffset = dwlPos;
  pSuperIndx->aIndex[riEntry].dwSize = pStdIndx->cb + sizeof(RIFFCHUNK);

  if(pStreamInfo->m_mt.majortype != MEDIATYPE_Audio)
  {
    pSuperIndx->aIndex[riEntry].dwDuration = GetCurrentIx(stream)->nEntriesInUse;
  }
  else
  {
    WAVEFORMATEX *pwfe = (WAVEFORMATEX *)pStreamInfo->m_mt.Format();

    ASSERT(pwfe->nBlockAlign != 0);
    ASSERT(pStreamInfo->m_dwlcBytes / pwfe->nBlockAlign <= MAXDWORD);

    DWORDLONG dwlcbWritten;
    pStreamInfo->GetCbWritten(&dwlcbWritten);

    pSuperIndx->aIndex[riEntry].dwDuration = ((CAudioStream *)pStreamInfo)->
        GetTicksInSample(dwlcbWritten - pStreamInfo->m_dwlcBytesLastSuperIndex);

    pStreamInfo->m_dwlcBytesLastSuperIndex = dwlcbWritten;
  }

  DbgLog((LOG_TRACE, 0x20,
          TEXT("avimux:UpdateSuperIndex: stream %d, entry %d, dwDuration %d"),
          pStreamInfo->m_stream, riEntry, pSuperIndx->aIndex[riEntry].dwDuration));

  // super index full?
  if(riEntry >= pStreamInfo->m_cEntriesSuperIndex)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::UpdateSuperIndex: superindex full.")));
    return VFW_E_BUFFER_OVERFLOW;
  }


  riEntry++;

  return S_OK;
}


// ------------------------------------------------------------------------
// output the indx chunk to disk and update the super index

HRESULT CAviWrite::FlushIx(unsigned stream)
{
  HRESULT hr;

  ASSERT(stream < m_cStreams);
  StreamInfo &rStreamInfo = *(m_rgpStreamInfo[stream]);

  AVISTDINDEX *pStdIndx = GetCurrentIx(stream);

  // no reason to output an empty one
  ASSERT(pStdIndx->nEntriesInUse != 0);

  const ULONG cbThisSubIndex = cbSubIndex(rStreamInfo.m_cEntriesSubIndex);
  ASSERT(cbThisSubIndex % m_cbAlign == 0);
  pStdIndx->cb = cbThisSubIndex - sizeof(RIFFCHUNK);

  // when writing interlaved files, we don't want to propagate index
  // chunks back one because we write them in the right place
  const DWORDLONG dwlFileOffsetOfSubIndex = rStreamInfo.PrecomputedIndexSizes() ?
    rStreamInfo.m_dwlOffsetCurrentSubIndex :
    m_dwlFilePos;

  // !!!! we call UpdateSuperIndex before successfully writing out the
  // subindex chunk.
  if(hr = UpdateSuperIndex(stream, dwlFileOffsetOfSubIndex), FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::FlushIx:: UpdateSuperIndex failed.")));
    return hr;
  }

  // !!!! blocks with CritSec locked. will unblock when a disk write
  // completes....
  CSampSample *pSS;
  hr = m_pSampAlloc->GetBuffer(&pSS, 0, 0, 0);
  if(hr != S_OK)
    return S_FALSE;

  REFERENCE_TIME rtStart = dwlFileOffsetOfSubIndex;
  REFERENCE_TIME rtStop = rtStart + cbThisSubIndex;
  pSS->SetTime(&rtStart, &rtStop);
  BYTE *pb;
  hr = rStreamInfo.m_pSampleStdIx->GetPointer(&pb);
  ASSERT(hr == S_OK);

  pSS->SetSample(rStreamInfo.m_pSampleStdIx, pb, cbThisSubIndex);
  hr = m_pIMemInputPin->Receive(pSS);

  pSS->Release();
  if(hr != S_OK)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CAviWrite::FlushIx: Write failed.")));
    return S_FALSE;
  }

  // delay releasing the sample to avoid crashes on failure. but there
  // are still other paths that can crash.
  rStreamInfo.m_pSampleStdIx->Release();
  rStreamInfo.m_pSampleStdIx = 0;

  rStreamInfo.m_dwlOffsetCurrentSubIndex = m_dwlFilePos;

  ULONG cbNextSubIndex = cbThisSubIndex;

  // leave space for the next index
  m_dwlFilePos += cbNextSubIndex;

  DbgCheckFilePos();

  return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// StreamInfo structure

CAviWrite::StreamInfo::StreamInfo(
  UINT iStream,
  UINT iPin,
  AviWriteStreamConfig *pAwsc,
  CAviWrite *pAviWrite,
  HRESULT *phr) :
    m_lIncoming(NAME("aviwrite - m_lIncoming"), 10)
{
  m_pin = C_MAX_STREAMS;
  m_posStrl = m_posIndx = m_cbStrf = m_cSamples = m_cIx = 0;
  m_dwlcBytes = 0;
  m_dwlcBytesLastSuperIndex = 0;
  m_cbLargestChunk = 0;
  m_pSampleStdIx = 0;
  m_cTicksPerChunk = 0;
  m_cTicksRemaining = 0;
  m_iCurrentTick = 0;
  m_posActiveStream = 0;
  m_cInitialFramesToDelete = 0;
  m_szStrn = 0;
  m_fEosSeen = FALSE;

  m_pin = iPin;
  m_mt = *pAwsc->pmt;
  m_fOurAllocator = pAwsc->fOurAllocator;
  m_cTicksExpected = pAwsc->cSamplesExpected;
  m_stream = iStream;
  m_pAviWrite = pAviWrite;

  m_mtEnd = -1;
  m_mtStart = -1;               // not necessary?

  if(pAwsc->szStreamName)
  {
      int cch = lstrlenA(pAwsc->szStreamName) + 1;
      m_szStrn = new char[cch];
      if(m_szStrn) {
          CopyMemory(m_szStrn, pAwsc->szStreamName, cch);
      } else {
          *phr = E_OUTOFMEMORY;
      }
  }


#ifdef PERF
  char buf[30];
  lstrcpy(buf, "avimux recv on pin 00");
  buf[19] = (char )m_pin / 10 + '0';
  buf[20] = (char)m_pin % 10 + '0';
  m_idPerfReceive = Msr_Register(buf);
#endif // PERF
}

CAviWrite::StreamInfo::~StreamInfo()
{
  if(m_pSampleStdIx != 0)
    m_pSampleStdIx->Release();

  delete[] m_szStrn;
}

void CAviWrite::StreamInfo::EmptyQueue()
{
  ASSERT(CritCheckIn(&m_pAviWrite->m_cs));

  while(m_lIncoming.GetCount() != 0)
  {
    IMediaSample *pSample;
    pSample = m_lIncoming.RemoveHead();
    if(pSample != INCOMING_EOS_SAMPLE)
      pSample->Release();
  }
}

CAviWrite::CFrameBaseStream::CFrameBaseStream(
  UINT iStream, UINT iPin, AviWriteStreamConfig *pAwsc, CAviWrite *pAviWrite,
  HRESULT *phr) :
    StreamInfo(iStream, iPin, pAwsc, pAviWrite, phr),
    m_rtDurationFirstFrame(0)
{
  m_bDroppedFrames = g_B_DROPPED_FRAMES;
}

CAviWrite::CVideoStream::CVideoStream(
  UINT iStream, UINT iPin, AviWriteStreamConfig *pAwsc, CAviWrite *pAviWrite,
  HRESULT *phr) :
    CFrameBaseStream(iStream, iPin, pAwsc, pAviWrite, phr)
{
  ASSERT(m_mt.formattype == FORMAT_VideoInfo);
}


CAviWrite::CAudioStream::CAudioStream(
  UINT iStream, UINT iPin, AviWriteStreamConfig *pAwsc, CAviWrite *pAviWrite,
  HRESULT *phr) :
    StreamInfo(iStream, iPin, pAwsc, pAviWrite, phr),
    m_bAudioAlignmentError(false)
{
}

CAviWrite::CAudioStreamI::CAudioStreamI(
  UINT iStream, UINT iPin, AviWriteStreamConfig *pAwsc, CAviWrite *pAviWrite,
  HRESULT *phr) :
    CAudioStream(iStream, iPin, pAwsc, pAviWrite, phr),
    m_fUnfinishedChunk(FALSE),
    m_cbThisSample(0),
    m_dwlcbWritten(0)
{
}

// for variable rate video, we assume 30fps or the duration of the
// first frame. this should be handled properly when variable frame
// rate AVI is supported.
REFERENCE_TIME CAviWrite::CFrameBaseStream::ConvertTickToTime(ULONG cTicks)
{
  if(m_rtDurationFirstFrame != 0)
    return cTicks * m_rtDurationFirstFrame;

  return cTicks * (UNITS / 30);
}

REFERENCE_TIME CAviWrite::CVideoStream::ConvertTickToTime(ULONG cTicks)
{
  VIDEOINFO *pvi = (VIDEOINFO *)m_mt.Format();
  if(pvi->AvgTimePerFrame != 0)
    return cTicks * pvi->AvgTimePerFrame;
  else
    return CFrameBaseStream::ConvertTickToTime(cTicks);
}

// for variable rate video, we assume 30fps or the duration of the
// first frame. this should be handled properly when variable frame
// rate AVI is supported.
ULONG CAviWrite::CFrameBaseStream::ConvertTimeToTick(REFERENCE_TIME rt)
{
  if(m_rtDurationFirstFrame != 0)
    return (ULONG)(rt / m_rtDurationFirstFrame);

  return (ULONG)(rt / (UNITS / 30));
}

HRESULT
CAviWrite::CVideoStream::AcceptRejectSample(IMediaSample *pSample)
{

    REFERENCE_TIME mtStart, mtStop;
    HRESULT hr = pSample->GetMediaTime(&mtStart, &mtStop);
    if(hr == S_OK)
    {
        // m_mtEnd is if -1 if the end time is not available. We want
        // to skip samples with identical media times. They are used
        // to identify extra frames when the source must send frames
        // at a higher rate than requested.
        if(mtStop == m_mtEnd)
        {
            return S_FALSE;
        }
    }


    return S_OK;

}

// for variable rate video, we assume 30fps or the duration of the
// first frame. this should be handled properly when variable frame
// rate AVI is supported.
ULONG CAviWrite::CVideoStream::ConvertTimeToTick(REFERENCE_TIME rt)
{
  VIDEOINFO *pvi = (VIDEOINFO *)m_mt.Format();
  if(pvi->AvgTimePerFrame != 0)
    return (ULONG)(rt / pvi->AvgTimePerFrame);
  else
    return CFrameBaseStream::ConvertTimeToTick(rt);
}

REFERENCE_TIME CAviWrite::CAudioStream::ConvertTickToTime(ULONG cTicks)
{
  WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();
  return cTicks * pwfx->nBlockAlign * UNITS / pwfx->nAvgBytesPerSec;
}

ULONG CAviWrite::CAudioStream::ConvertTimeToTick(REFERENCE_TIME rt)
{
   WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();
   return (ULONG)(rt *  pwfx->nAvgBytesPerSec / pwfx->nBlockAlign / UNITS);
}

ULONG CAviWrite::CAudioStream::CountSamples()
{
  ASSERT(*m_mt.Type() == MEDIATYPE_Audio);
  ASSERT(*m_mt.FormatType() == FORMAT_WaveFormatEx);

  WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();
  // connection refused if nBlockAlign is 0.
  ASSERT(m_dwlcBytes / pwfx->nBlockAlign <= MAXDWORD);
  ULONG cSamples= (ULONG)(m_dwlcBytes / pwfx->nBlockAlign);

  return cSamples;
}

ULONG CAviWrite::CAudioStream::ConvertTickToBytes(ULONG cTicks)
{
  ASSERT(*m_mt.Type() == MEDIATYPE_Audio);
  ASSERT(*m_mt.FormatType() == FORMAT_WaveFormatEx);

  WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();
  return cTicks * pwfx->nBlockAlign;
}

ULONG CAviWrite::CAudioStream::ConvertBytesToTicks(ULONG cBytes)
{
  ASSERT(*m_mt.Type() == MEDIATYPE_Audio);
  ASSERT(*m_mt.FormatType() == FORMAT_WaveFormatEx);

  WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_mt.Format();
  return cBytes / pwfx->nBlockAlign;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

CAviWrite::CWalkIndex::CWalkIndex(CAviWrite *pAviWrite, StreamInfo *pSi)
{
  m_pSi = pSi;

  m_pAviWrite = pAviWrite;
  m_offsetSuper = m_offsetStd = 0;

  m_dwlFilePosLastStd = pSi->m_posFirstSubIndex;

  m_pSuperIndex = 0;
  m_pStdIndex = 0;
}

HRESULT CAviWrite::CWalkIndex::Init()
{
  DbgLog((LOG_TRACE, 0x20, TEXT("CWalkIndex::Init: stream %d"),
          m_pSi->m_stream));

  HRESULT hr = S_OK;

  // nothing to do if this stream has no samples
  if(m_pSi->m_cSamples == 0)
  {
    ASSERT(m_pSuperIndex == 0);
    return S_OK;
  }


  ASSERT(m_pAviWrite->GetIndx(m_pSi->m_stream)->bIndexType == AVI_INDEX_OF_INDEXES);

  m_pSuperIndex = (AVISUPERINDEX *)m_pAviWrite->GetIndx(m_pSi->m_stream);

  m_pStdIndex = (AVISTDINDEX *)new BYTE[cbSubIndex(m_pSi->m_cEntriesSubIndex)];
  if(m_pStdIndex == 0)
    return E_OUTOFMEMORY;

  // we need to update the super index if the current sub index has
  // any chunks
  AVISTDINDEX *pStdIndx = m_pAviWrite->GetCurrentIx(m_pSi->m_stream);
  if(pStdIndx->nEntriesInUse != 0)
  {
    // the file offset will be updated later. we can't call FlushIx
    // because the graph may have stopped.
    if(hr = m_pAviWrite->UpdateSuperIndex(m_pSi->m_stream,
                                          m_pSi->m_dwlOffsetCurrentSubIndex),
       FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::CWalkIndex::Init: UpdateSuperIndex failed.")));
    }
  }
  if(SUCCEEDED(hr))
  {
    hr = ReadStdIndex();
    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 2,
               TEXT("CAviWrite::CWalkIndex::Init: ReadStdIndex failed.")));
    }
    else if(m_pSi->m_cInitialFramesToDelete > m_pSuperIndex->aIndex[0].dwDuration)
    {
      // !!! the amount of video we have to delete exceeds one sub
      // index. abort. If someone really needs to write out a file
      // with a long delay before the audio starts, they need to turn
      // off the compatibility index.

      DbgLog((LOG_ERROR, 0, TEXT("bug: cannot delete %d frames from stream %d"),
              m_pSi->m_cInitialFramesToDelete, m_pSi->m_stream));
      return E_UNEXPECTED;
    }
    else if(m_pSi->m_cInitialFramesToDelete > 0)
    {
      // update super index for frames we're deleting
      if(m_pSi->m_cInitialFramesToDelete < m_pSuperIndex->aIndex[0].dwDuration)
      {
        m_pSuperIndex->aIndex[0].dwDuration -= m_pSi->m_cInitialFramesToDelete;
      }
      else
      {
        m_pSuperIndex->aIndex[0].dwDuration = 0;
      }

      DbgLog((LOG_TRACE, 1, TEXT("m_cInitialFramesToDelete: 1, dwDuration: %d"),
              m_pSuperIndex->aIndex[0].dwDuration, m_pSi->m_cInitialFramesToDelete));

      // delete initial entries from subindex (DoVfwDwStartHack())
      ASSERT(m_pStdIndex->nEntriesInUse - m_pSi->m_cInitialFramesToDelete ==
             m_pSuperIndex->aIndex[0].dwDuration ||
             m_pSuperIndex->aIndex[0].dwDuration == 0);

      m_pStdIndex->nEntriesInUse = m_pSuperIndex->aIndex[0].dwDuration;
      ASSERT(m_pStdIndex->nEntriesInUse == m_pSuperIndex->aIndex[0].dwDuration);
      CopyMemory(
        m_pStdIndex->aIndex,
        &m_pStdIndex->aIndex[m_pSi->m_cInitialFramesToDelete],
        m_pStdIndex->nEntriesInUse * sizeof(m_pStdIndex->aIndex[0]));
      ZeroMemory(
        &m_pStdIndex->aIndex[m_pStdIndex->nEntriesInUse],
        m_pSi->m_cInitialFramesToDelete * sizeof(m_pStdIndex->aIndex[0]));

       hr = m_pAviWrite->IStreamWrite(
        m_pSuperIndex->aIndex[0].qwOffset,
        (BYTE*)m_pStdIndex,
        m_pStdIndex->cb + sizeof(RIFFCHUNK));

    }
  }



  return hr;
}

CAviWrite::CWalkIndex::~CWalkIndex()
{
  if(m_pStdIndex != 0)
    delete m_pStdIndex;
}

HRESULT CAviWrite::CWalkIndex::Peek(
  DWORDLONG *dwlPos,
  DWORD *dwSize,
  BOOL *pbSyncPoint)
{
  if(m_pSi->m_cSamples == 0) {
    ASSERT(m_pStdIndex == 0);
    return E_FAIL;
  }

  ASSERT(m_pStdIndex != 0);
  if(m_offsetStd >= m_pStdIndex->nEntriesInUse)
    return E_FAIL;

  if(m_pSuperIndex != 0 && m_offsetSuper >= m_pSuperIndex->nEntriesInUse)
    return E_FAIL;

  *dwlPos = m_pStdIndex->aIndex[m_offsetStd].dwOffset +
    m_pStdIndex->qwBaseOffset;

  *dwSize = m_pStdIndex->aIndex[m_offsetStd].dwSize & AVISTDINDEX_SIZEMASK;

  *pbSyncPoint = !(m_pStdIndex->aIndex[m_offsetStd].dwSize & AVISTDINDEX_DELTAFRAME);

  return S_OK;
}

// ------------------------------------------------------------------------
// set the pointer to the next sub index entry

HRESULT CAviWrite::CWalkIndex::Advance()
{
  HRESULT hr;

  if(++m_offsetStd >= m_pStdIndex->nEntriesInUse)
  {
    if(m_pSuperIndex == 0)
      return E_FAIL;

    if(++m_offsetSuper >= m_pSuperIndex->nEntriesInUse)
      return E_FAIL;

    if(hr = ReadStdIndex(), FAILED(hr))
      return E_FAIL;

    m_offsetStd = 0;
    if(m_offsetStd >= m_pStdIndex->nEntriesInUse)
      return E_FAIL;

  }
  return S_OK;
}

// ------------------------------------------------------------------------
// finish propagating the subindex chunks back

HRESULT CAviWrite::CWalkIndex::Close()
{
  HRESULT hr;
  if(m_pSuperIndex != 0)
    while(++m_offsetSuper < m_pSuperIndex->nEntriesInUse)
      if(hr = ReadStdIndex(), FAILED(hr))
        return hr;

  return S_OK;
}

// ------------------------------------------------------------------------
// ReadStdIndex. read the next standard index off disk to m_pStdIndex
// (the last standard index is in memory). Write it back to the
// location of the previous index entry.


HRESULT CAviWrite::CWalkIndex::ReadStdIndex()
{
  ASSERT(m_pSuperIndex != 0);
  ASSERT(m_offsetSuper < m_pSuperIndex->nEntriesInUse);

  DbgLog((LOG_TRACE, 0x20,
          TEXT("CWalkIndex::ReadStdIndex: stream %d, m_offsetSuper: %d"),
          m_pSi->m_stream, m_offsetSuper));

  // don't need to propagate index chunks for Interleaved files
  // because the indexes are in the right place already.
  BOOL fNeedToWriteOutSubIndexChunk = TRUE;

  BOOL fSubIndexInMem = FALSE;
  if(m_offsetSuper == m_pSuperIndex->nEntriesInUse - 1)
  {
    // get the last sub index. it may be on disk or in memory. It's in
    // memory if we haven't called FlushIx,InitIx(). we are able to
    // guarantee that the last video won't be written out, but can't
    // say anything about the audio.

    AVISTDINDEX *pStdIndx;
    IMediaSample *pSampleStdIx = m_pSi->m_pSampleStdIx;
    ASSERT(pSampleStdIx);
    HRESULT hr = pSampleStdIx->GetPointer((BYTE**)&pStdIndx);
    ASSERT(SUCCEEDED(hr));

    // if we didn't get a chance to write anything in this index, then
    // the last index is on disk.
    if(pStdIndx->nEntriesInUse != 0)
    {
      fSubIndexInMem = TRUE;
    }
  }

  if(!fSubIndexInMem)
  {

    HRESULT hr = m_pAviWrite->IStreamRead(
      m_pSuperIndex->aIndex[m_offsetSuper].qwOffset,
      (BYTE*)m_pStdIndex,
      m_pSuperIndex->aIndex[m_offsetSuper].dwSize);

    if(FAILED(hr))
      return hr;

    // if PrecomputedIndexSizes() then the indexes are already in the
    // right place
    fNeedToWriteOutSubIndexChunk = !m_pSi->PrecomputedIndexSizes();
  }
  else
  {
    DbgLog((LOG_TRACE, 0x20, TEXT("CWalkIndex::ReadStdIndex: copying")));
    AVISTDINDEX *pStdIndx;
    IMediaSample *&rpSampleStdIx = m_pSi->m_pSampleStdIx;
    ASSERT(rpSampleStdIx);
    HRESULT hr = rpSampleStdIx->GetPointer((BYTE**)&pStdIndx);
    ASSERT(SUCCEEDED(hr));
    CopyMemory(m_pStdIndex, pStdIndx, pStdIndx->cb + sizeof(RIFFCHUNK));
    rpSampleStdIx->Release();
    rpSampleStdIx = 0;

    // Always need to write out the last sub index chunk
    fNeedToWriteOutSubIndexChunk = TRUE;
  }

  ASSERT(m_pStdIndex->bIndexType == AVI_INDEX_OF_CHUNKS);

  if(m_pStdIndex->nEntriesInUse > 0 && fNeedToWriteOutSubIndexChunk)
  {
    // when writing interleaved files, we don't want to propagate
    // index chunks back one because we write them in the right place
    const DWORDLONG dwlByteOffsetThisSubIndex = m_pSi->PrecomputedIndexSizes() ?
      m_pSuperIndex->aIndex[m_offsetSuper].qwOffset :
      m_dwlFilePosLastStd;

    DbgLog((LOG_TRACE, 0x20,
            TEXT("CWalkIndex::ReadStdIndex: writing %d bytes to %08x"),
            m_pStdIndex->cb + sizeof(RIFFCHUNK),
            (DWORD)dwlByteOffsetThisSubIndex));

    HRESULT hr = m_pAviWrite->IStreamWrite(
      dwlByteOffsetThisSubIndex,
      (BYTE*)m_pStdIndex,
      m_pStdIndex->cb + sizeof(RIFFCHUNK));

    if(FAILED(hr))
      return hr;

    m_dwlFilePosLastStd = m_pSuperIndex->aIndex[m_offsetSuper].qwOffset;
    m_pSuperIndex->aIndex[m_offsetSuper].qwOffset = dwlByteOffsetThisSubIndex;
  }

  return S_OK;
}

HRESULT CAviWrite::FlushILeaveWrite()
{
    HRESULT hr = S_OK;

    ASSERT(m_IlMode == INTERLEAVE_FULL);

    ASSERT(CritCheckIn(&m_cs));
    ASSERT(m_ibIleave <= CB_ILEAVE_BUFFER);

    LARGE_INTEGER offset;
    offset.QuadPart = m_dwlIleaveOffset;
    hr = m_pIStream->Seek(offset, STREAM_SEEK_SET, 0);
    if(SUCCEEDED(hr)) {
        hr = m_pIStream->Write(m_rgbIleave, m_ibIleave, 0);
    }

    m_dwlIleaveOffset += m_ibIleave;
    m_ibIleave = 0;

    return hr;
}

HRESULT CAviWrite::IleaveWrite(
    const DWORDLONG &dwlOffset,
    BYTE *pb,
    ULONG cb)
{
    ASSERT(CritCheckIn(&m_cs));
    HRESULT hr = S_OK;

    ASSERT(m_IlMode == INTERLEAVE_FULL);

    if(m_dwlIleaveOffset + m_ibIleave != dwlOffset)
    {
        hr = FlushILeaveWrite();
        if(SUCCEEDED(hr)) {
            m_dwlIleaveOffset = dwlOffset;
        }
    }

    while(SUCCEEDED(hr) && cb > 0)
    {
        ULONG cbToWrite = min(cb, (CB_ILEAVE_BUFFER - m_ibIleave));
        CopyMemory(m_rgbIleave + m_ibIleave, pb, cbToWrite);
        m_ibIleave += cbToWrite;
        cb -= cbToWrite;
        pb += cbToWrite;

        ASSERT(m_ibIleave <= CB_ILEAVE_BUFFER);
        if(m_ibIleave == CB_ILEAVE_BUFFER)
        {
            hr = FlushILeaveWrite();
        }
    }

    return hr;
}

// ansi-only version of NAME macro (so that we don't need two
// CCopiedSample ctors.)
#ifdef DEBUG
#define NAME_A(x) (x)
#else
#define NAME_A(_x_) ((char *) NULL)
#endif


CCopiedSample::CCopiedSample(
    const AM_SAMPLE2_PROPERTIES *pprop,
    REFERENCE_TIME *pmtStart, REFERENCE_TIME *pmtEnd,
    HRESULT *phr) :
        CMediaSample(
            NAME_A("CCopiedSample"),
            (CBaseAllocator *)1, // keep assert from firing
            phr,
            0,                  // pbBuffer
            0)
{
    // fool SetProperties -- it refuses otherwise
    m_pBuffer = pprop->pbBuffer;
    m_cbBuffer = pprop->cbBuffer;

    if(SUCCEEDED(*phr))
    {
        *phr = SetProperties(sizeof(*pprop), (BYTE *)pprop);
    }
    if(SUCCEEDED(*phr))
    {
        SetMediaTime(pmtStart, pmtEnd);
    }

    // always initialize m_pBuffer so dtor can cleanup
    m_pBuffer = new BYTE[pprop->lActual];

    if(m_pBuffer)
    {
        CopyMemory(m_pBuffer, pprop->pbBuffer, pprop->lActual);
        ASSERT(m_cbBuffer >= pprop->lActual && m_lActual == pprop->lActual);
    }
    else
    {
        *phr = E_OUTOFMEMORY;
    }


}

CCopiedSample::~CCopiedSample()
{
    delete[] m_pBuffer;
}

// CMediaSample::Release puts the sample back on the allocator queue,
// but CCopiedSample doesn't have an allocator, so it just deletes
// itself.
ULONG CCopiedSample::Release()
{
    /* Decrement our own private reference count */
    LONG lRef = InterlockedDecrement(&m_cRef);

    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
        this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {
        delete this;
    }
    return (ULONG)lRef;
}

// converting dv type1 - > type 2: if the dv splitter drops enough
// frames and doesn't send audio, then the video pin blocks in
// Receive(), and the avi splitter is starved, and the conversion
// stops
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\avi\avimux\aviwrite.h ===
#pragma warning(disable: 4097 4511 4512 4514 4705)

//
// CAviWrite class declaration. generates an AVI file from a stream of
// Quartz samples
//

#ifndef _AviWrite_h
#define _AviWrite_h

#include "alloc.h"
#include "aviriff.h"

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Aviwrite class and structures
//

// maximum number of streams in an AVI file. comes from the 2 digit
// hexadecimal stream id. and some AVI players don't like stream #s
// greater than 0x7f (signed character?), and we use 0x7f for junk
// index entries. so 00-7E are valid AVI streams.
const unsigned C_MAX_STREAMS = 0x7f;

// maximum outer riff chunks (1Gb each).
const unsigned C_OUTERMOST_RIFF = 512;

struct AviWriteStreamConfig
{
  BOOL fOurAllocator;           // our allocator with a suffix
  CMediaType *pmt;
  ULONG cSamplesExpected;
  char *szStreamName;
};

class CAviWrite
{
  class StreamInfo;
  struct SizeAndPosition
  {
    DWORDLONG pos;
    DWORD size;
  };
  
public:

  CAviWrite(HRESULT *phr);
  ~CAviWrite();

  void GetMemReq(ULONG* pAlignment, ULONG *pcbPrefix, ULONG *pcbSuffix);
  HRESULT Initialize(
    int cPins,
    AviWriteStreamConfig *rgAwsc,
    IMediaPropertyBag *pCopyrightInfo);

  HRESULT Close();

  HRESULT Connect(CSampAllocator *pAlloc, IMemInputPin *pInPin);
  HRESULT Disconnect();

  // returns S_FALSE - stop quietly; error - filter should signal
  // error
  HRESULT Receive(
      int pinNum,
      IMediaSample *pSample,
      const AM_SAMPLE2_PROPERTIES *pSampProp);
    
  HRESULT EndOfStream(int pinNum);
  HRESULT EndOfStream(StreamInfo *psi);

  HRESULT QueryAccept(
    int pinNum,
    const AM_MEDIA_TYPE *pmt
    );
    

  HRESULT put_Mode(InterleavingMode mode);
  HRESULT get_Mode(InterleavingMode *pMode);
  HRESULT put_Interleaving(
      const REFERENCE_TIME *prtInterleave,
      const REFERENCE_TIME *prtAudioPreroll);
    
  HRESULT get_Interleaving(
      REFERENCE_TIME *prtInterleave,
      REFERENCE_TIME *prtAudioPreroll);

  HRESULT SetIgnoreRiff(BOOL fNoRiff);
  HRESULT GetIgnoreRiff(BOOL *pfNoRiff);
  HRESULT SetMasterStream(LONG iStream);
  HRESULT GetMasterStream(LONG *pStream);
  HRESULT SetOutputCompatibilityIndex(BOOL fOldIndex);
  HRESULT GetOutputCompatibilityIndex(BOOL *pfOldIndex);

  static FOURCC MpVideoGuidSubtype_Fourcc(const GUID *pGuidSubtype);

  ULONG GetCFramesDropped() { return m_cDroppedFrames; }

  void GetCurrentBytePos(LONGLONG *pllcbCurrent);
  void GetCurrentTimePos(REFERENCE_TIME *prtCurrent);
  void GetStreamInfo(int PinNum, AM_MEDIA_TYPE ** ppmt);
  HRESULT SetStreamName(WCHAR *wsz);
  HRESULT GetStreamName(WCHAR **pwsz);
    
private:

  HRESULT HandleSubindexOverflow(
      unsigned stream);

  HRESULT IndexSample(
    unsigned stream,
    DWORDLONG dwlPos,
    ULONG ulSize,
    BOOL fSynchPoint);

  HRESULT DoFlushIndex(StreamInfo &rStreamInfo);

  HRESULT ScheduleWrites();
  HRESULT BlockReceive(StreamInfo *pStreamInfo);
  CAMEvent m_evBlockReceive;
    
  void AllocateIdx1(BOOL bStreaming);
  void DbgCheckFilePos();

  HRESULT UpdateSuperIndex(unsigned stream, DWORDLONG dwlPos);
  HRESULT FlushIx(unsigned stream);
  HRESULT NewRiffAvi_();

  POSITION GetNextActiveStream(POSITION pos);
  
  static void SampleCallback(void *pMisc);

  HRESULT IStreamWrite(DWORDLONG dwlFilePos, BYTE *pb, ULONG cb);
  HRESULT IStreamRead(DWORDLONG dwlFilePos, BYTE *pb, ULONG cb);
  HRESULT IleaveWrite(const DWORDLONG &dwlOffset, BYTE *pb, ULONG cb);
  HRESULT FlushILeaveWrite();

  
  HRESULT HandleFormatChange(
    StreamInfo *pStreamInfo,
    const AM_MEDIA_TYPE *pmt);

  // used for writes
  IStream *m_pIStream;
  IMemInputPin *m_pIMemInputPin;
  class CSampAllocator *m_pSampAlloc;

  DWORDLONG m_dwlFilePos;
  DWORDLONG m_dwlCurrentRiffAvi_; // outermost RIFF chunk
  DWORD m_cOutermostRiff;
  ULONG m_cIdx1Entries;
  SizeAndPosition m_rgOutermostRiff[C_OUTERMOST_RIFF];

  // default size of indx chunks and super index chunks
  // ULONG m_cbIndx, m_cbIx;

  // default number of entries allocated for super and sub indexes.
  ULONG m_cEntriesMaxSuperIndex, m_cEntriesMaxSubIndex;

  // size of outer Riff chunks (approx 1Gb)
  ULONG m_cbRiffMax;

  ULONG m_cbBuffer, m_cBuffers;

  // how much empty space the user wanted in the header for future
  // edits
  ULONG m_cbHeaderJunk;

  // output old/compatibility index?
  BOOL m_bOutputIdx1;

  bool m_bSawDeltaFrame; 
 

  // if writing a compatibility index, also make the audio streams
  // start at time=0 for compatibility. we cannot do this if there are
  // any keyframes.
  inline BOOL DoVfwDwStartHack() { return m_bOutputIdx1 && !m_bSawDeltaFrame; }

  // these aren't valid until GetMemReq is called
  ULONG m_cbAlign;
  ULONG m_cbPrefix;
  ULONG m_cbSuffix;

  LONG m_cDroppedFrames;

private:
  unsigned m_cStreams;
  StreamInfo **m_rgpStreamInfo;;
  CGenericList<StreamInfo> m_lActiveStreams;
  POSITION m_posCurrentStream;

  // keeps track of Initialize() and Close() calls
  BOOL m_bInitialized;

  // pointers to structures in the AVI header
  RIFFLIST *m_pAvi_, *m_pHdrl;
  AVIMAINHEADER *m_pAvih;
  RIFFLIST *m_pOdml;
  AVIEXTHEADER *m_pDmlh;
  RIFFLIST *m_pMovi;
  ULONG m_posIdx1;
  ULONG m_cbIdx1;
  ULONG m_posFirstIx;

  // memory to dump to disk for the header
  BYTE *m_rgbHeader;   // allocated w/ new
  ULONG m_cbHeader;

  ULONG m_mpPinStream[C_MAX_STREAMS];

  // on stop->pause
  HRESULT InitializeHeader(IMediaPropertyBag *pProp);
  HRESULT InitializeIndex();
  HRESULT InitializeStrl(ULONG& iPos);
  HRESULT InitializeOptions();
  HRESULT InitializeInterleaving();

  BOOL RegGetDword(HKEY hk, TCHAR *tsz, DWORD *dw);
  long GuessFrameRate() { return 15; }
  

  // on pause->stop
  HRESULT CloseHeader();
  HRESULT CloseMainAviHeader();
  HRESULT CloseStreamHeader();
  HRESULT CloseStreamName();
  HRESULT CloseStreamFormat();
  HRESULT CloseIndex();
  HRESULT CloseOuterRiff();
  HRESULT BuildIdx1();

  // helper functions
  AVISTREAMHEADER *GetStrh(unsigned stream);
  BYTE *GetStrf(unsigned stream);
  AVIMETAINDEX *GetIndx(unsigned stream);
  void SetFrameRateAndScale(AVISTREAMHEADER *pStrh, StreamInfo *pSi, double dScaleMasterStream);

  HRESULT InitIx(unsigned stream);
  ULONG GetIndexSize(AVIMETAINDEX *pIndex);
  AVISTDINDEX *GetCurrentIx(unsigned stream);

  void AddJunk(DWORD& rdwSize, DWORD dwAlign, BYTE *pb);
  void AddJunkOtherAllocator(
    DWORD& rdwSize,             // size, updated
    DWORD dwAlign,
    BYTE *pb,
    IMediaSample *pSample,
    BYTE **ppJunkSector);       // additional junk sector to write or null
  
  ULONG GetCbJunk(DWORD dwSize, DWORD dwAlign);

  // space for junk sectors partitioned JU.NKSIZE, JUNK.SIZE, JUNKSI.ZE
  BYTE *m_rgpbJunkSector[3];
  BYTE *m_rgbJunkSectors;

  BYTE *m_rgbIleave;
  ULONG m_ibIleave;
  DWORDLONG m_dwlIleaveOffset;
  
  void SetList(void *pList, FOURCC ckid, DWORD dwSize, FOURCC listid);
  void SetChunk(void *pChunk, FOURCC ckid, DWORD dwSize);
  
  void Cleanup();

#ifdef DEBUG
  // performance counters
  DWORD m_dwTimeInit, m_dwTimeInited, m_dwTimeStopStreaming;
  DWORD m_dwTimeFirstSample, m_dwTimeClose, m_dwTimeClosed;
#endif /* DEBUG */

private:
  IMemAllocator *m_pAllocator;
  CCritSec m_cs;

  InterleavingMode m_IlMode;
  REFERENCE_TIME m_rtAudioPreroll;
  REFERENCE_TIME m_rtInterleaving;

  // don't count ticks but look at time stamps to interleave
  BOOL m_fInterleaveByTime;

  // adjust rates of all streams for drift from master stream. -1
  // means disabled.
  LONG m_lMasterStream;

#ifdef PERF
  int m_idPerfDrop;
#endif // PERF


private:

  // information kept per active stream
  class StreamInfo
  {
  public:
    ULONG m_pin;                /* filter pin mapped to this stream */
    ULONG m_stream;
    ULONG m_posStrl;            // start position of strl chunk
    ULONG m_posIndx;            // location of super index
    ULONG m_posFirstSubIndex;
    ULONG m_posStrf;
    ULONG m_posStrn;
    ULONG m_cbStrf;
    CHAR *m_szStrn;
    CMediaType m_mt;
    FOURCC m_moviDataCkid;      // eg 00db
    FOURCC m_moviDataCkidCompressed; // eg 00dc

    ULONG m_cSamples;           // number of times Receive was called
    DWORDLONG m_dwlcBytes;      // total number of bytes received

    // for interleaved audio: # bytes of stream written when a new sub
    // index was started
    DWORDLONG m_dwlcBytesLastSuperIndex;

    // byte offset of current SubIndex chunk for tightly interleaved
    // files.
    DWORDLONG m_dwlOffsetCurrentSubIndex;
    ULONG m_cbLargestChunk;

    CRefTime m_refTimeStart;    // start of first sample stream sees
    CRefTime m_refTimeEnd;      // end of last sample stream sees
    CRefTime m_mtEnd;           // last media time recorded, -1 if unset
    CRefTime m_mtStart;         // first media time recorded, -1 if unset

    IMediaSample *m_pSampleStdIx; // current standard index (IMediaSample)
    ULONG m_cIx;

    // index sizes for this stream. these must be less than the
    // defaults due to memory allocated
    ULONG m_cEntriesSuperIndex, m_cEntriesSubIndex;

    LONG m_iCurrentTick;        // next tick to write
    LONG m_cTicksRemaining;     // ticks left to write in this chunk

    LONG m_cTicksPerChunk;      // used by stream if it's the leading stream
    ULONG m_cTicksExpected;     // adjust the index sizes accordingly
    POSITION m_posActiveStream; // pos in CAviWrite::m_lActiveStreams

    BOOL m_fOurAllocator;       // our allocator with suffix
    BOOL m_fEosSeen;

    REFERENCE_TIME m_rtPreroll;

#ifdef PERF
    int m_idPerfReceive;
#endif // PERF

    // used when interleaving.
    CGenericList<IMediaSample> m_lIncoming;
    void EmptyQueue();

    CAviWrite *m_pAviWrite;

    StreamInfo(
      UINT iStream,
      UINT iPin,
      AviWriteStreamConfig *pAwsc,
      CAviWrite *pAviWrite,
      HRESULT *phr);
    ~StreamInfo();              // not virtual for now

    // write given sample
    virtual HRESULT WriteSample(IMediaSample *pSample);

    // pull sample off queue, write it
    virtual HRESULT WriteSample();
    
    virtual HRESULT EndOfStream() { return S_OK; }

    virtual void GetCbWritten(DWORDLONG *pdwlcb) { *pdwlcb = m_dwlcBytes; }

    // good place to record dropped frames.
    virtual HRESULT NotifyNewSample(
      IMediaSample *pSample,
      ULONG *pcTicks) = 0;

    // unblock other streams that can write
    HRESULT NotifyWrote(long cTicks);

    virtual REFERENCE_TIME ConvertTickToTime(ULONG cTicks) = 0;
    virtual ULONG ConvertTimeToTick(REFERENCE_TIME rt) = 0;

    // samples between m_refTimeStart and m_refTimeEnd
    virtual ULONG CountSamples() = 0;

    // S_FALSE means skip the sample. error means signal an error.
    virtual HRESULT AcceptRejectSample(IMediaSample *pSample) { return S_OK; }

    // compute what size super and sub indexes we will use
    void ComputeAndSetIndexSize();

    // is this stream trying to write out exactly sized index chunks
    BOOL PrecomputedIndexSizes();

    // If in DoVfwDwStartHack() mode, this number tells us how many
    // video frames need to be deleted up front. Valid after
    // ::CloseStreamHeader only.
    ULONG m_cInitialFramesToDelete;

  protected:

    // accounting for processed samples (stream length, # of Receives)
    HRESULT NewSampleRecvd(IMediaSample *pSample);
  };

  class CFrameBaseStream : public StreamInfo
  {
  public:
    CFrameBaseStream(
        UINT iStream,
        UINT iPin,
        AviWriteStreamConfig *pAwsc,
        CAviWrite *pAviWrite,
        HRESULT *phr);
    
    virtual REFERENCE_TIME ConvertTickToTime(ULONG cTicks);
    virtual ULONG ConvertTimeToTick(REFERENCE_TIME rt);

    ULONG GetTicksWritten(ULONG cbSample);

    HRESULT NotifyNewSample(
      IMediaSample *pSample,
      ULONG *pcTicks);

    ULONG CountSamples() { return m_cSamples; }
    
  protected:
    BOOL m_bDroppedFrames;

    // used only if avgTimePerFrame is not set in the media type
    REFERENCE_TIME m_rtDurationFirstFrame;
  };

  class CVideoStream : public CFrameBaseStream
  {
  public:
    CVideoStream(
        UINT iStream,
        UINT iPin,
        AviWriteStreamConfig *pAwsc,
        CAviWrite *pAviWrite,
        HRESULT *phr);
    REFERENCE_TIME ConvertTickToTime(ULONG cTicks);
    ULONG ConvertTimeToTick(REFERENCE_TIME rt);
    virtual HRESULT AcceptRejectSample(IMediaSample *pSample);
  };

  class CAudioStream : public StreamInfo
  {
  protected:
    ULONG ConvertTickToBytes(ULONG cTicks);
    ULONG ConvertBytesToTicks(ULONG cBytes);

    ULONG GetTicksWritten(ULONG cbSample);

    HRESULT NotifyNewSample(
      IMediaSample *pSample,
      ULONG *pcTicks);

    // set when the sample length isn't a multiple of nBlockAlign
    // because we don't handle that properly unless it's at the end.
    bool m_bAudioAlignmentError;

  public:
    CAudioStream(
        UINT iStream,
        UINT iPin,
        AviWriteStreamConfig *pAwsc,
        CAviWrite *pAviWrite,
        HRESULT *phr);

    LONG GetTicksInSample(DWORDLONG cbSample);
    REFERENCE_TIME ConvertTickToTime(ULONG cTicks);
    ULONG ConvertTimeToTick(REFERENCE_TIME rt);
    ULONG CountSamples();
  };

  // with interleaving code
  class CAudioStreamI : public CAudioStream
  {
    BOOL m_fUnfinishedChunk;    // start a new chunk with new sample?
    DWORDLONG m_dwlOffsetThisChunk; // byte offset in file of this chunk
    LONG m_cbThisChunk;         // bytes written to disk for this chunk
    LONG m_cbThisSample;        // byte written out from current sample

    // bytes expected for this chunk. we write out a riff chunk with
    // the .cb field being the number of bytes we expect. if we get an
    // EOS before that we need to go back and fix up that number
    LONG m_cbInRiffChunk;
    HRESULT FlushChunk();

    DWORDLONG m_dwlcbWritten; // total number of bytes written

#ifdef DEBUG
    // paranoia: save disk offset across Receive calls
    DWORDLONG m_dwlOffsetRecv;
#endif
    
  public:
    CAudioStreamI(
        UINT iStream,
        UINT iPin,
        AviWriteStreamConfig *pAwsc,
        CAviWrite *pAviWrite,
        HRESULT *phr);
    HRESULT WriteSample(IMediaSample *pSample);
    HRESULT WriteSample();    
    HRESULT EndOfStream();

    void GetCbWritten(DWORDLONG *pdwlcb);
  };

  // code to propagate index forward
  class CWalkIndex
  {
  public:
    CWalkIndex(CAviWrite *pAviWrite, StreamInfo *pSi);
    HRESULT Init();
    ~CWalkIndex();

    HRESULT Peek(DWORDLONG *dwlPos, DWORD *dwSize, BOOL *pfSyncPoint);
    HRESULT Advance();
    HRESULT Close();

  private:
    HRESULT ReadStdIndex();

    StreamInfo *m_pSi;

    AVISUPERINDEX *m_pSuperIndex;
    AVISTDINDEX *m_pStdIndex;

    CAviWrite *m_pAviWrite;

    ULONG m_offsetSuper;
    ULONG m_offsetStd;
    DWORDLONG m_dwlFilePosLastStd;
  };

  friend class CWalkIndex;
  friend class CFrameBaseStream;
  friend class StreamInfo;
  friend class CAudioStream;
  friend class CAudioStreamI;
};

class CCopiedSample :
    public CMediaSample
{
public:
    CCopiedSample(
        const AM_SAMPLE2_PROPERTIES *pprop,
        REFERENCE_TIME *pmtStart, REFERENCE_TIME *pmtEnd,
        HRESULT *phr);
    ~CCopiedSample();

    STDMETHODIMP_(ULONG) Release();
};


#endif // _AviWrite_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\msreader\alloc.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "alloc.h"
#include "reccache.h"

CRecAllocator::CRecAllocator(
  TCHAR *pName,
  LPUNKNOWN pUnk,
  HRESULT *phr) :
    CBaseAllocator(pName, pUnk, phr),
    m_cDelivered(0),
    m_heSampleReleased(0),
    m_pBuffer(NULL)
{
    if(SUCCEEDED(*phr))
    {
        m_heSampleReleased = CreateEvent(
            0,                      // security
            FALSE,                  // fManualReset
            FALSE,                  // fInitiallySignaled
            0);                     // name
        if(m_heSampleReleased == 0)
        {
            DWORD dw = GetLastError();
            *phr = AmHresultFromWin32(*phr);
        }
    }
}

STDMETHODIMP
CRecAllocator::SetProperties(
  ALLOCATOR_PROPERTIES* pRequest,
  ALLOCATOR_PROPERTIES* pActual)
{
    DbgLog((LOG_ERROR, 0,
            TEXT("nobody should be calling SetProperties on our allocator")));

    // but of course the l21 dec filter does call SetProperties on our
    // allocator and confuses us by giving us fewer buffers than we
    // requested. bug 13985?

    return E_UNEXPECTED;
}

STDMETHODIMP
CRecAllocator::SetPropertiesInternal(
  ALLOCATOR_PROPERTIES* pRequest,
  ALLOCATOR_PROPERTIES* pActual)
{
  HRESULT hr = CBaseAllocator::SetProperties(pRequest, pActual);
  if(FAILED(hr))
    return hr;

  m_cBuffersReported = pActual->cBuffers;
  return hr;
}

STDMETHODIMP CRecAllocator::GetProperties(ALLOCATOR_PROPERTIES* pAPOut)
{
  HRESULT hr = CBaseAllocator::GetProperties(pAPOut);
  if(FAILED(hr))
    return hr;

  // CBaseAllocator::GetProperties would have failed if this value was
  // not set in SetProperties
  pAPOut->cBuffers = m_cBuffersReported;
  return hr;
}

HRESULT CRecAllocator::SetCBuffersReported(UINT cBuffers)
{
  m_cBuffersReported = cBuffers;
  return S_OK;
}

// override this to allocate our resources when Commit is called.
//
// note that our resources may be already allocated when this is called,
// since we don't free them on Decommit. We will only be called when in
// decommit state with all buffers free.
//
// object locked by caller
HRESULT
CRecAllocator::Alloc(void)
{
    CAutoLock lck(this);

    /* Check he has called SetProperties */
    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
	return hr;
    }

    ASSERT(!m_pBuffer);         // never allocating here

    /* If the requirements haven't changed then don't reallocate */
    if (hr == S_FALSE) {
	return NOERROR;
    }

    /* Free the old resources */
    if (m_pBuffer) {
	ReallyFree();
    }

    /* Create the contiguous memory block for the samples
       making sure it's properly aligned (64K should be enough!)
    */
    ASSERT(m_lAlignment != 0 &&
	   m_lSize % m_lAlignment == 0);

    m_pBuffer = 0;

    CRecSample *pSample;

    ASSERT(m_lAllocated == 0);

    /* Create the new samples */
    for (; m_lAllocated < m_lCount; m_lAllocated++) {

	pSample = new CRecSample(NAME("Default memory media sample"),
				   this, &hr, 0, 0);

	if (FAILED(hr) || pSample == NULL) {
	    return E_OUTOFMEMORY;
	}

	m_lFree.Add(pSample);
    }

    m_bChanged = FALSE;
    return NOERROR;
}


// override this to free up any resources we have allocated.
// called from the base class on Decommit when all buffers have been
// returned to the free list.
//
// caller has already locked the object.

// in our case, we keep the memory until we are deleted, so
// we do nothing here. The memory is deleted in the destructor by
// calling ReallyFree()
void
CRecAllocator::Free(void)
{
    return;
}


// called from the destructor (and from Alloc if changing size/count) to
// actually free up the memory
void
CRecAllocator::ReallyFree(void)
{
  /* Should never be deleting this unless all buffers are freed */

  ASSERT(m_lAllocated == m_lFree.GetCount());

  /* Free up all the CRecSamples */

  CMediaSample *pSample;
  while (TRUE) {
    pSample = m_lFree.RemoveHead();
    if (pSample != NULL) {
      delete pSample;
    } else {
      break;
    }
  }

  m_lAllocated = 0;

}


/* Destructor frees our memory resources */

CRecAllocator::~CRecAllocator()
{
    Decommit();
    ReallyFree();

    ASSERT(m_cDelivered == 0);

    if(m_heSampleReleased)
      EXECUTE_ASSERT(CloseHandle(m_heSampleReleased));
}

HRESULT
CRecAllocator::GetBuffer(
  CRecSample **ppBuffer,
  REFERENCE_TIME *pStartTime,
  REFERENCE_TIME *pEndTime,
  DWORD dwFlags)
{
  UNREFERENCED_PARAMETER(pStartTime);
  UNREFERENCED_PARAMETER(pEndTime);
  UNREFERENCED_PARAMETER(dwFlags);
  CRecSample *pSample;

  *ppBuffer = NULL;
  while (TRUE) {

    {
      CAutoLock cObjectLock(this);

      /* Check we are committed */
      if (!m_bCommitted) {
        return VFW_E_NOT_COMMITTED;
      }
      pSample = (CRecSample *) m_lFree.RemoveHead();
      if (pSample == NULL) {
        SetWaiting();
      }
    }

    /* If we didn't get a sample then wait for the list to signal */

    if (pSample) {
      break;
    }
    ASSERT(m_hSem != NULL);
    WaitForSingleObject(m_hSem, INFINITE);
  }

  /* This QueryInterface should addref the buffer up to one. On release
     back to zero instead of being deleted, it will requeue itself by
     calling the ReleaseBuffer member function. NOTE the owner of a
     media sample must always be derived from CRecBaseAllocator */

  pSample->m_cRef = 1;
  *ppBuffer = pSample;

  pSample->SetUser(0);

  pSample->m_fDelivered = false;

  return NOERROR;
}


void CRecAllocator::IncrementDelivered()
{
    InterlockedIncrement(&m_cDelivered);
}

void CRecAllocator::DecrementDelivered()
{
    DbgLog((LOG_TRACE, 0x3f,
            TEXT("CRecAllocator::DecrementDelivered: %08x"), this));
    EXECUTE_ASSERT(InterlockedDecrement(&m_cDelivered) >= 0);
    EXECUTE_ASSERT(SetEvent(m_heSampleReleased));
}


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

CRecSample::CRecSample(
  TCHAR *pName,
  CBaseAllocator *pAllocator,
  HRESULT *phr,
  LPBYTE pBuffer,
  LONG length) :
    CMediaSample(pName, pAllocator, phr, pBuffer, length),
    m_pParentBuffer(0)              // no parent cache buffer

{
}


/* Destructor deletes the media type memory */

CRecSample::~CRecSample()
{
}

HRESULT CRecSample::SetParent(CRecBuffer *pRecBuffer)
{
  /* Check we are committed */
  ASSERT(m_pParentBuffer == 0);
  m_pParentBuffer = pRecBuffer;
  pRecBuffer->AddRef();

  return S_OK;
}

void CRecSample::MarkDelivered()
{
    m_fDelivered = true;
    ((CRecAllocator *)m_pAllocator)->IncrementDelivered();
}

STDMETHODIMP_(ULONG)
CRecSample::Release()
{
    /* Decrement our own private reference count */
    LONG lRef = InterlockedDecrement(&m_cRef);
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    CRecSample %X ref-- = %d"),
	    this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {
        /*  Free all resources */
        SetMediaType(NULL);
        m_dwFlags = 0;

        // decrement ref count on cache buffer.
        if(m_pParentBuffer)
        {
          m_pParentBuffer->Release();
          m_pParentBuffer = 0;
        }

        if(m_fDelivered) {
            ((CRecAllocator *)m_pAllocator)->DecrementDelivered();
        }

	/* This may cause us to be deleted */
	// Our refcount is reliably 0 thus no-one will mess with us
        m_pAllocator->ReleaseBuffer(this);
    }
    return (ULONG)lRef;
}

STDMETHODIMP
CRecSample::SetActualDataLength(LONG lActual)
{
  m_cbBuffer = lActual;
  return CMediaSample::SetActualDataLength(lActual);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\msreader\alloc.h ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// an allocator which can parcel out different samples within a record

#ifndef _alloc_h
#define _alloc_h

class CRecSample :
  public CMediaSample           // A non delegating IUnknown
{

private:

  class CRecBuffer   *m_pParentBuffer; // attached to this cache buffer
  DWORD m_dwUserContext;

  bool m_fDelivered;
  friend class CRecAllocator;

public:

  CRecSample(
    TCHAR *pName,
    CBaseAllocator *pAllocator,
    HRESULT *phr,
    LPBYTE pBuffer = NULL,
    LONG length = 0);

  ~CRecSample();

  HRESULT SetParent(CRecBuffer *pRecBuffer);

  void MarkDelivered();

  // zero means its a regular sample; o/w HandleData will be called.
  void SetUser(DWORD dwUser) { m_dwUserContext = dwUser; }
  DWORD GetUser() { return m_dwUserContext; }

  STDMETHODIMP SetActualDataLength(LONG lActual);
  STDMETHODIMP_(ULONG) Release();
};

// implementation of CBaseAllocator similar to CMemAllocator but
// doesn't allocate memory for GetBuffer();

class CRecAllocator : public CBaseAllocator
{
  // override to free the memory when decommit completes
  // - we actually do nothing, and save the memory until deletion.
  void Free(void);

  // called from the destructor (and from Alloc if changing size/count) to
  // actually free up the memory
  void ReallyFree(void);

  // overriden to allocate the memory when commit called
  HRESULT Alloc(void);

  BYTE *m_pBuffer;

  // We want to tell the audio renderer to buffer no more than some
  // amount of audio so that we are reading audio and video from the
  // same place in the file (audio is dwInitial frames ahead of video
  // in AVI). cbBuffer * cBuffers would do this except the audio
  // renderer makes cbBuffer at least 1/2 second and cBuffers is an
  // arbitrarily large number for us. So we want the audio renderer to
  // see this number. Even though it has 1/2 second buffers and we are
  // filling in say 1/15 of a second, this keeps it from running ahead.
  ULONG m_cBuffersReported;

  HANDLE m_heSampleReleased;

  LONG m_cDelivered;

  inline void IncrementDelivered();
  inline void DecrementDelivered();
  friend class CRecSample;

public:

  STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest,
                             ALLOCATOR_PROPERTIES* pActual);

  STDMETHODIMP SetPropertiesInternal(ALLOCATOR_PROPERTIES* pRequest,
                                     ALLOCATOR_PROPERTIES* pActual);

  STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pAPOut);

  STDMETHODIMP GetBuffer(CRecSample **ppBuffer,
                         REFERENCE_TIME * pStartTime,
                         REFERENCE_TIME * pEndTime,
                         DWORD dwFlags);

  CRecAllocator(TCHAR *, LPUNKNOWN, HRESULT *);
  ~CRecAllocator();

  HRESULT SetCBuffersReported(UINT cBuffers);

  inline int CSamplesDownstream() { return m_cDelivered; }

  HANDLE hGetDownstreamSampleReleased(){ return m_heSampleReleased; }
};

#endif // _alloc_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\filerend\filerend.cpp ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.


// Simple parser filter
//

#include <streams.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "filerend.h"

// ok to use this as it is not dereferenced
#pragma warning(disable:4355)


const AMOVIESETUP_MEDIATYPE
psudFileRendType[] = { { &MEDIATYPE_File       // 1. clsMajorType
                        , &MEDIASUBTYPE_NULL } }; //    clsMinorType


const AMOVIESETUP_MEDIATYPE
sudFileRendOutType = { &MEDIATYPE_NULL       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudFileRendPins[] =  { { L"Input"             // strName
		    , FALSE                // bRendered
		    , FALSE                // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , psudFileRendType }, // lpTypes
		         { L"Output"             // strName
		    , FALSE                // bRendered
		    , TRUE                 // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , &sudFileRendOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudFileRend = { &CLSID_FileRend     // clsID
               , L"File stream renderer"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudFileRendPins };   // lpPin



const AMOVIESETUP_MEDIATYPE
psudMultiParseType[] = { { &MEDIATYPE_Stream       // 1. clsMajorType
                        , &CLSID_MultFile } }; //    clsMinorType


const AMOVIESETUP_MEDIATYPE
sudMultiParseOutType = { &MEDIATYPE_NULL       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudMultiParsePins[] =  { { L"Input"             // strName
		    , FALSE                // bRendered
		    , FALSE                // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , psudMultiParseType }, // lpTypes
		         { L"Output"             // strName
		    , FALSE                // bRendered
		    , TRUE                 // bOutput
		    , FALSE                // bZero
		    , TRUE                 // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , &sudMultiParseOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudMultiParse = { &CLSID_MultFile     // clsID
               , L"Multi-file Parser"  // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudMultiParsePins };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"Multiple Source"
    , &CLSID_FileRend
    , CFileRendFilter::CreateInstance
    , NULL
    , &sudFileRend },
    { L"Multiple Source"
    , &CLSID_MultFile
    , CMultFilter::CreateInstance
    , NULL
    , &sudMultiParse }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

//
// CreateInstance
//
// Called by CoCreateInstance to create our filter
CUnknown *CFileRendFilter::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CFileRendFilter(NAME("Multiple file source"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


/* Implements the CFileRendFilter public member functions */


// constructors etc
CFileRendFilter::CFileRendFilter(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseFilter(pName, pUnk, &m_csLock, CLSID_FileRend),
      m_Input(this, &m_csLock, phr, L"Reader"),
      m_Output(NAME("Fake Output pin"), phr, this, &m_csLock, L"Out")
{
}

CFileRendFilter::~CFileRendFilter()
{
}


// pin enumerator calls this
int CFileRendFilter::GetPinCount() {
    // only expose output pin if we have a reader.
    return 2;
};

// return a non-addrefed pointer to the CBasePin.
CBasePin *
CFileRendFilter::GetPin(int n)
{
    if (n == 0)
	return &m_Input;

    if (n == 1)
	return &m_Output;

    return NULL;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CFileRendInPin::CFileRendInPin(CFileRendFilter *pFilter,
			   CCritSec *pLock,
			   HRESULT *phr,
			   LPCWSTR pPinName) :
   CBaseInputPin(NAME("in pin"), pFilter, pLock, phr, pPinName),
   m_pFilter(pFilter)
{
}

HRESULT CFileRendInPin::CheckMediaType(const CMediaType *pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_File)
        return E_INVALIDARG;

    // !!! further checking?

    return S_OK;
}

/* Implements the CFileRendStream class */


CFileRendStream::CFileRendStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CFileRendFilter * pFilter,
    CCritSec *pLock,
    LPCWSTR wszPinName)
    : CBaseOutputPin(pObjectName, pFilter, pLock, phr, wszPinName)
    , m_pFilter(pFilter)
{
}

CFileRendStream::~CFileRendStream()
{
}

STDMETHODIMP
CFileRendStream::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IStreamBuilder) {
	return GetInterface((IStreamBuilder *) this, ppv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}

// IPin interfaces


// this pin doesn't support any media types!
HRESULT
CFileRendStream::GetMediaType(int iPosition, CMediaType* pt)
{
    return VFW_S_NO_MORE_ITEMS;
}

// check if the pin can support this specific proposed type&format
HRESULT
CFileRendStream::CheckMediaType(const CMediaType* pt)
{
    ASSERT(0);
    return E_NOTIMPL;
}

HRESULT
CFileRendStream::DecideBufferSize(IMemAllocator * pAllocator,
			     ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(0);
    return E_NOTIMPL;
}


// IStreamBuilder::Render -- graph builder will call this
// to do something with our output pin
HRESULT CFileRendStream::Render(IPin * ppinOut, IGraphBuilder * pGraph)
{
    HRESULT hr;

    WCHAR * wsz = m_pFilter->m_Input.CurrentName();

    hr = pGraph->RenderFile(wsz, NULL);

    DbgLog((LOG_TRACE, 1, TEXT("RenderFile %ls returned %x"), wsz, hr));

    // !!! do I need to remember here that this pin has been
    // rendered and I shouldn't do it again?

    return hr;
}





// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1

//
// CreateInstance
//
// Called by CoCreateInstance to create our filter
CUnknown *CMultFilter::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CMultFilter(NAME("Multiple file source"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


/* Implements the CMultFilter public member functions */


// constructors etc
CMultFilter::CMultFilter(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseFilter(pName, pUnk, &m_csLock, CLSID_MultFile),
      m_Input(this, &m_csLock, phr, L"Reader"),
      m_pOutputs(NULL),
      m_nOutputs(0),
      m_pAsyncReader(NULL)
{
}

CMultFilter::~CMultFilter()
{
    ASSERT(!m_pOutputs);
}

HRESULT CMultFilter::CreateOutputPins()
{
    LONGLONG llTotal, llAvailable;

    m_pAsyncReader->Length(&llTotal, &llAvailable);

    DWORD cbFile = (DWORD) llTotal;

    char *lpFile = new char[cbFile];

    if (!lpFile)
	return E_OUTOFMEMORY;

    /* Try to read whole file */
    HRESULT hr = m_pAsyncReader->SyncRead(0, cbFile, (BYTE *) lpFile);

    if (hr != S_OK) {
	delete[] lpFile;
        return E_FAIL;
    }

    // !!! loop through file,

    char *lp = lpFile;
    int		nOutputs = 0;


    WCHAR wsz[200];
    int		cbWide = 0;

    while (cbFile--) {
	if (*lp == '\r' || *lp == '\n') {
	    wsz[cbWide] = L'\0';
	    if (cbWide > 0 && wsz[0] != L';') {
		++nOutputs;
	    }
	    cbWide = 0;
	} else {
	    wsz[cbWide++] = (WCHAR) *lp;
            if(cbWide >= NUMELMS(wsz)) {
                delete[] lpFile;
                return VFW_E_INVALID_FILE_FORMAT;
            }
	}
	lp++;
    }

    m_pOutputs = new CMultStream * [nOutputs];
    if (!m_pOutputs) {
	delete[] lpFile;
	return E_OUTOFMEMORY;
    }

    cbWide = 0;  lp = lpFile;
    cbFile = (DWORD) llTotal;
    while (cbFile--) {
	if (*lp == '\r' || *lp == '\n') {
	    if (cbWide > 0 && wsz[0] != L';') {
		wsz[cbWide] = L'\0';

		m_pOutputs[m_nOutputs++] =
			new CMultStream(NAME("file render output"),
					&hr,
					this,
					&m_csLock,
					wsz);

		if (FAILED(hr)) {
		    break;
		}

		m_pOutputs[m_nOutputs - 1]->AddRef();
	    }
	    cbWide = 0;
	} else {
	    wsz[cbWide++] = (WCHAR) *lp;
	}
	
	lp++;
    }

    delete[] lpFile;

    return hr;
}

HRESULT CMultFilter::RemoveOutputPins()
{
    for (int iStream = 0; iStream < m_nOutputs; iStream++) {
	CMultStream *pPin = m_pOutputs[iStream];
	IPin *pPeer = pPin->GetConnected();
	if(pPeer != NULL) {
	    pPeer->Disconnect();
	    pPin->Disconnect();
	}
	pPin->Release();
    }
    delete[] m_pOutputs;
    m_pOutputs = 0;
    m_nOutputs = 0;

    return S_OK;
}




// pin enumerator calls this
int CMultFilter::GetPinCount() {
    // only expose output pin if we have a reader.
    return m_nOutputs + 1;
};

// return a non-addrefed pointer to the CBasePin.
CBasePin *
CMultFilter::GetPin(int n)
{
    if (n == 0)
	return &m_Input;

    if (n > 0 && n <= m_nOutputs)
	return m_pOutputs[n-1];

    return NULL;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CFRInPin::CFRInPin(CMultFilter *pFilter,
			   CCritSec *pLock,
			   HRESULT *phr,
			   LPCWSTR pPinName) :
   CBasePin(NAME("in pin"), pFilter, pLock, phr, pPinName, PINDIR_INPUT),
   m_pFilter(pFilter)
{
}

HRESULT CFRInPin::CheckMediaType(const CMediaType *pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != CLSID_MultFile)
        return E_INVALIDARG;

    return S_OK;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.

HRESULT CFRInPin::CompleteConnect(
  IPin *pReceivePin)
{
    HRESULT hr = pReceivePin->QueryInterface(IID_IAsyncReader,
					     (void**)&m_pFilter->m_pAsyncReader);

    if(FAILED(hr))
	return hr;

    return m_pFilter->CreateOutputPins();
}

HRESULT CFRInPin::BreakConnect()
{
    if (m_pFilter->m_pAsyncReader) {
	m_pFilter->m_pAsyncReader->Release();
	m_pFilter->m_pAsyncReader = NULL;
    }

    m_pFilter->RemoveOutputPins();

    return CBasePin::BreakConnect();
}

/* Implements the CMultStream class */


CMultStream::CMultStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CMultFilter * pFilter,
    CCritSec *pLock,
    LPCWSTR wszPinName)
    : CBasePin(pObjectName, pFilter, pLock, phr, wszPinName, PINDIR_OUTPUT)
    , m_pFilter(pFilter)
{
    // initialize output media type
    m_mt.SetType(&MEDIATYPE_File);
    m_mt.SetSubtype(&CLSID_NULL);
    m_mt.SetFormatType(&MEDIATYPE_File);
    m_mt.SetFormat((BYTE *) wszPinName, (lstrlenW(wszPinName) + 1) * 2);
    // !!! fill in other fields?
}

CMultStream::~CMultStream()
{
}

STDMETHODIMP_(ULONG)
CMultStream::NonDelegatingAddRef()
{
    return CUnknown::NonDelegatingAddRef();
}


/* Override to decrement the owning filter's reference count */

STDMETHODIMP_(ULONG)
CMultStream::NonDelegatingRelease()
{
    return CUnknown::NonDelegatingRelease();
}

// IPin interfaces

HRESULT
CMultStream::GetMediaType(int iPosition, CMediaType* pt)
{
    if (iPosition != 0)
	return VFW_S_NO_MORE_ITEMS;

    *pt = m_mt;

    return S_OK;
}

// check if the pin can support this specific proposed type&format
HRESULT
CMultStream::CheckMediaType(const CMediaType* pt)
{
    return (*pt == m_mt) ? S_OK : E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\msreader\basemsr.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include "basemsr.h"

// ------------------------------------------------------------------------
// -------- Implements the CBaseMSRFilter public member functions ---------

#pragma warning(disable:4355)

// constructor
//
CBaseMSRFilter::CBaseMSRFilter(
  TCHAR *pName,
  LPUNKNOWN pUnk,
  CLSID clsid,
  HRESULT *phr) :
    CBaseFilter(pName, pUnk, this, clsid),
    C_MAX_REQS_PER_STREAM(64)
{
  m_cStreams = 0;

  m_pImplBuffer = 0;
  m_pAsyncReader = 0;

  m_rgpOutPin = 0;
  m_pInPin = 0;

  m_iStreamSeekingIfExposed = -1;
  m_heStartupSync = 0;
  m_ilcStreamsNotQueued = 0;

  if(FAILED(*phr))
    return;

  m_heStartupSync = CreateEvent(0, TRUE, FALSE, 0);
  if(m_heStartupSync == 0)
    *phr = AmHresultFromWin32(GetLastError());

  m_dwSeekingCaps = AM_SEEKING_CanSeekForwards
		  | AM_SEEKING_CanSeekBackwards
		  | AM_SEEKING_CanSeekAbsolute
		  | AM_SEEKING_CanGetStopPos
		  | AM_SEEKING_CanGetDuration;

  // too bad we can't call derived->CreateInputPin here
}

// destructor
//
CBaseMSRFilter::~CBaseMSRFilter()
{
  delete m_pInPin;

  if(m_pImplBuffer)
    m_pImplBuffer->Close();
  delete m_pImplBuffer;

  if(m_pAsyncReader)
    m_pAsyncReader->Release();

  if(m_rgpOutPin)
    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
      delete m_rgpOutPin[iStream];
  delete[] m_rgpOutPin;

  if(m_heStartupSync)
    CloseHandle(m_heStartupSync);
}

HRESULT CBaseMSRFilter::CreateInputPin(CBaseMSRInPin **ppInPin)
{
  HRESULT hr = S_OK;
  *ppInPin = new CBaseMSRInPin(this, &hr, L"input pin");
  if(*ppInPin == 0)
    return E_OUTOFMEMORY;

  return hr;
}

HRESULT CBaseMSRFilter::RemoveOutputPins()
{
  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    CBaseMSROutPin *pPin = m_rgpOutPin[iStream];
    IPin *pPeer = pPin->GetConnected();
    if(pPeer != NULL)
    {
      pPeer->Disconnect();
      pPin->Disconnect();
    }
    pPin->Release();
  }
  delete[] m_rgpOutPin;
  m_rgpOutPin = 0;

  m_cStreams = 0;

  return S_OK;
}

int CBaseMSRFilter::GetPinCount()
{
  // output pins + 1 input pin. valid before and after connections
  return m_cStreams + 1;
}

// return a non-addrefed pointer to the CBasePin.
CBasePin * CBaseMSRFilter::GetPin(int ii)
{
  if (m_cStreams > 0  &&  ii < (int)m_cStreams)
    return m_rgpOutPin[ii];

  if(ii == (int)m_cStreams)
    return m_pInPin;

  return 0;
}

//
// FindPin
//
// return the IPin that has the given pin id
//
// HRESULT CBaseMSRFilter::FindPin (
//   LPCWSTR pwszPinId,
//   IPin ** ppPin)
// {
//   // !!! handle bad ids.
//   unsigned short *pwszPinId_ = (unsigned short *)pwszPinId;
//   int ii = WstrToInt(pwszPinId_); // in sdk\classes\base\util
//   *ppPin = GetPin(ii);

//   if (*ppPin) {
//     (*ppPin)->AddRef();
//     return S_OK;
//   }

//   return VFW_E_NOT_FOUND;
// }

HRESULT CBaseMSRFilter::Pause()
{
  CAutoLock lock(this);
  HRESULT hr = S_OK;

  if(m_State == State_Stopped)
  {
    // pins on which Active is called will decrement
    // m_ilcStreamsNotQueued
    m_ilcStreamsNotQueued = 0;
    for (unsigned c = 0; c < m_cStreams; c++)
    {
      if(m_rgpOutPin[c]->IsConnected())
      {
        m_ilcStreamsNotQueued++;
      }
    }

    DbgLog((LOG_TRACE, 15,
	    TEXT("Pause: m_ilcStreamsNotQueued = %d"), m_ilcStreamsNotQueued));


    EXECUTE_ASSERT(ResetEvent(m_heStartupSync));

    if(m_State == State_Stopped && m_pImplBuffer)
    {
      // start the i/o thread. !!! this assumes that the upstream filter
      // has paused before us. why does it work?
      m_pImplBuffer->Start();
    }

    // this makes the pin threads push samples if we were stopped
    hr = CBaseFilter::Pause();

    // put all threads in known state so that subsequent Pauses don't
    // hang.
    if(FAILED(hr))
    {
      // base class won't call Inactive unless we change m_State;
      m_State = State_Paused;
      Stop();
    }
  } // State_Stopped
  else
  {
    hr = CBaseFilter::Pause();
  }


  return hr;
}

HRESULT CBaseMSRFilter::Stop()
{
  CAutoLock lock(this);
  if(m_pImplBuffer)
    m_pImplBuffer->BeginFlush();

  // tell each pin to stop
  HRESULT hr = CBaseFilter::Stop();

  if(m_pImplBuffer)
    m_pImplBuffer->EndFlush();

  ASSERT(m_ilcStreamsNotQueued == 0);

  return hr;
}

void CBaseMSRFilter::SetSeekingIf(ULONG iStream)
{
  CAutoLock lock(&m_csSeekingStream);
  m_iStreamSeekingIfExposed = iStream;
  DbgLog((LOG_TRACE, 5,
	  TEXT("CBaseFilter:SetSeekingIf: pin %d created seeking if"),
	  iStream));
}

BOOL
CBaseMSRFilter::RequestSeekingIf(ULONG iStream)
{
  CAutoLock lock(&m_csSeekingStream);
  ASSERT(iStream < m_cStreams);

  if(m_iStreamSeekingIfExposed == (long)iStream)
    return TRUE;

  if(m_iStreamSeekingIfExposed != -1)
  {
    DbgLog((LOG_TRACE, 5,
	    TEXT("CBaseFilter:RequestSeekingIf: refused %d. %d has it"),
	    iStream, m_iStreamSeekingIfExposed));
    return FALSE;
  }

  m_iStreamSeekingIfExposed = iStream;
  DbgLog((LOG_TRACE, 5,
	  TEXT("CBaseFilter:RequestSeekingIf: pin %d created seeking if"),
	  iStream));

  return TRUE;
}

HRESULT CBaseMSRFilter::SeekOtherStreams(
  ULONG iSeekingStream,
  REFERENCE_TIME *prtStart,
  REFERENCE_TIME *prtStop,
  double dRate,
  DWORD dwSeekFlags)
{
  for(ULONG iStream = 0; iStream < m_cStreams; iStream++)
  {
    if(iStream == iSeekingStream)
      continue;

    HRESULT hr = m_rgpOutPin[iStream]->UpdateSelectionAndTellWorker(
      prtStart,
      prtStop,
      0,
      dRate,
      &TIME_FORMAT_MEDIA_TIME,
      dwSeekFlags);
    if(FAILED(hr))
      return hr;
  }
  return S_OK;
}

HRESULT CBaseMSRFilter::StopFlushRestartAllStreams(DWORD dwSeekFlags)
{
  // big race between stopping and running worker since we have to
  // call endflush inbetween stopping and running the worker. but a
  // stop can't happen then. A run should be safe.

  CAutoLock lock(this);
  FILTER_STATE state = m_State;

  m_pImplBuffer->BeginFlush();

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    m_rgpOutPin[iStream]->StopWorker(
	dwSeekFlags & AM_SEEKING_NoFlush ? false : true);

    //  Update the segment number NOW - after this call we may complete
    //  and actually use it!
    //  But don't do it before StopWorker or the previous stream might
    //  complete with the wrong segment number
    if (dwSeekFlags & AM_SEEKING_Segment) {
	m_rgpOutPin[iStream]->m_dwSegmentNumber++;
	NotifyEvent(
	    EC_SEGMENT_STARTED,
	    (LONG_PTR)&m_rgpOutPin[iStream]->m_rtAccumulated,
	    m_rgpOutPin[iStream]->m_dwSegmentNumber);
    } else {
	m_rgpOutPin[iStream]->m_dwSegmentNumber = 0;
    }
    m_pImplBuffer->ClearPending(iStream);
  }

  m_pImplBuffer->EndFlush();

  if(state != State_Stopped)
  {
    m_pImplBuffer->Start();

    ResetEvent(m_heStartupSync);
    // RestartWorker will decrement m_ilcStreamsNotQueued
    m_ilcStreamsNotQueued = m_cStreams;

    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      m_rgpOutPin[iStream]->RestartWorker();
    }
  }

  return S_OK;
}

HRESULT CBaseMSRFilter::NotifyInputConnected(IAsyncReader *pAsyncReader)
{
  // these are reset when disconnected
  ASSERT(m_pImplBuffer == 0);
  ASSERT(m_pAsyncReader == 0);

  m_iStreamSeekingIfExposed = -1;

  // fail if any output pins are connected.
  UINT iStream;
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    if(m_rgpOutPin[iStream] && m_rgpOutPin[iStream]->GetConnected())
      // !!! can't find a good error.
      return VFW_E_FILTER_ACTIVE;
  }

  // remove any output pins left
  this->RemoveOutputPins();

  // done here because LoadHeader uses m_pAsyncReader
  m_pAsyncReader = pAsyncReader;
  pAsyncReader->AddRef();

  HRESULT hr = this->CreateOutputPins();
  if(FAILED(hr))
  {
    m_pAsyncReader->Release();
    m_pAsyncReader = 0;
    return hr;
  }

  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    hr = m_rgpOutPin[iStream]->InitializeOnNewFile();
    if(FAILED(hr))
    {
      m_pAsyncReader->Release();
      m_pAsyncReader = 0;
      return hr;
    }
  }

  StreamBufParam rgSbp[C_STREAMS_MAX];
  ULONG cbRead, cBuffers;
  int iLeadingStream;
  hr = this->GetCacheParams(rgSbp, &cbRead, &cBuffers, &iLeadingStream);
  ASSERT(SUCCEEDED(hr));

  DbgLog(( LOG_TRACE, 5,
	   TEXT("CBaseMSRFilter: cbRead %d, cBuffers %d, iLeadingStream %d"),
	   cbRead, cBuffers, iLeadingStream));

  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
      // callee will addref
      rgSbp[iStream].pAllocator = m_rgpOutPin[iStream]->m_pRecAllocator;
  }

  hr = CreateMultiStreamReader(
    pAsyncReader,
    m_cStreams,
    rgSbp,
    cbRead,
    cBuffers,
    iLeadingStream,
    &m_pImplBuffer);

  if(FAILED(hr))
  {
    pAsyncReader->Release();
    m_pAsyncReader = 0;

    ASSERT(m_pImplBuffer == 0);

    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
      delete m_rgpOutPin[iStream];
    delete[] m_rgpOutPin;
    m_rgpOutPin = 0;
    m_cStreams =0;
  }

  return hr;
}

HRESULT CBaseMSRFilter::NotifyInputDisconnected()
{
  if (m_pAsyncReader)
  {
    m_pAsyncReader->Release();
    m_pAsyncReader = 0;
  }

  this->RemoveOutputPins();

  delete m_pImplBuffer;
  m_pImplBuffer =0;


  return S_OK;
}

// allocate a hunk of memory and read the requested region of the
// file into it.
HRESULT CBaseMSRFilter::AllocateAndRead (
  BYTE **ppb,
  DWORD cb,
  DWORDLONG qwPos)
{
  *ppb = 0;
  LPBYTE lpb = new BYTE[cb];
  if ( ! lpb)
    return E_OUTOFMEMORY;

  HRESULT hr = m_pAsyncReader->SyncRead(qwPos, cb, lpb);

  // IAsyncReader::SyncRead() returns S_FALSE if it "[r]etrieved fewer bytes 
  // than requested." (MSDN Janurary 2002).
  if(S_OK == hr)
  {
    *ppb = lpb;
    return S_OK;
  } else if(SUCCEEDED(hr)) {
    hr = E_FAIL;
  }

  // the read was a failure. free the buffer and return NULL
  DbgLog((LOG_ERROR,1,TEXT("Failed to read %d bytes error = %08X"), cb, hr));
  delete[] lpb;
  return hr;
}

HRESULT CBaseMSRFilter::GetCacheParams(
  StreamBufParam *rgSbp,
  ULONG *pcbRead,
  ULONG *pcBuffers,
  int *piLeadingStream)
{
  *piLeadingStream = -1;        // no leading stream

  UINT iStream;
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    ZeroMemory(&rgSbp[iStream], sizeof(rgSbp[iStream]));
    rgSbp[iStream].cbSampleMax = m_rgpOutPin[iStream]->GetMaxSampleSize();
    rgSbp[iStream].cSamplesMax = C_MAX_REQS_PER_STREAM;
  }
  *pcbRead = 0;
  *pcBuffers = 0;

  return S_OK;
}

void CBaseMSRFilter::NotifyStreamQueuedAndWait()
{
  long lQueued = InterlockedDecrement(&m_ilcStreamsNotQueued);
  ASSERT(lQueued >= 0);
  if(lQueued == 0)
  {
    DbgLog((LOG_TRACE, 5,
	    TEXT("CBaseMSRFilter::NotifyStreamQueuedAndWait signal")));
    EXECUTE_ASSERT(SetEvent(m_heStartupSync));
  }
  else
  {
    DbgLog((LOG_TRACE, 5,
	    TEXT("CBaseMSRFilter::NotifyStreamQueuedAndWait block")));
    EXECUTE_ASSERT(
      WaitForSingleObject(m_heStartupSync, INFINITE) == WAIT_OBJECT_0);
  }
}

void CBaseMSRFilter::NotifyStreamQueued()
{
  long lQueued = InterlockedDecrement(&m_ilcStreamsNotQueued);
  ASSERT(lQueued >= 0);
  if(lQueued == 0)
  {
    DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRFilter::NotifyStreamQueued signal")));
    EXECUTE_ASSERT(SetEvent(m_heStartupSync));
  }
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CBaseMSRInPin::CBaseMSRInPin(
  CBaseMSRFilter *pFilter,
  HRESULT *phr,
  LPCWSTR pPinName) :
    CBasePin(NAME("in pin"), pFilter, pFilter, phr, pPinName, PINDIR_INPUT)
{
  m_pFilter = pFilter;
}

CBaseMSRInPin::~CBaseMSRInPin()
{
}

HRESULT CBaseMSRInPin::CheckMediaType(const CMediaType *mtOut)
{
  return m_pFilter->CheckMediaType(mtOut);
}

TimeFormat
CBaseMSRFilter::MapGuidToFormat(const GUID *const pGuidFormat)
{
  if(*pGuidFormat == TIME_FORMAT_MEDIA_TIME)
    return FORMAT_TIME;
  else if(*pGuidFormat == TIME_FORMAT_SAMPLE)
    return FORMAT_SAMPLE;
  else if(*pGuidFormat == TIME_FORMAT_FRAME)
    return FORMAT_FRAME;

  DbgBreak("?unknown format");
  return FORMAT_NULL;
}

HRESULT CBaseMSRInPin::CheckConnect(IPin * pPin)
{
  HRESULT hr;

  hr = CBasePin::CheckConnect(pPin);
  if(FAILED(hr))
    return hr;

  IAsyncReader *pAsyncReader = 0;
  hr = pPin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
  if(SUCCEEDED(hr))
    pAsyncReader->Release();

  // E_NOINTERFACE is a reasonable error
  return hr;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.

HRESULT CBaseMSRInPin::CompleteConnect(
  IPin *pReceivePin)
{
  HRESULT hr = CBasePin::CompleteConnect(pReceivePin);
  if(FAILED(hr))
    return hr;

  IAsyncReader *pAsyncReader = 0;
  hr = pReceivePin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
  if(FAILED(hr))
    return hr;

  hr = m_pFilter->NotifyInputConnected(pAsyncReader);
  pAsyncReader->Release();

  return hr;
}

HRESULT CBaseMSRInPin::BreakConnect()
{
  HRESULT hr = CBasePin::BreakConnect();
  if(FAILED(hr))
    return hr;

  return m_pFilter->NotifyInputDisconnected();
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// output pin

// ------------------------------------------------------------------------
// constructor

CBaseMSROutPin::CBaseMSROutPin(
  CBaseFilter *pOwningFilter,
  CBaseMSRFilter *pFilter,
  UINT iStream,
  IMultiStreamReader *&rpImplBuffer,
  HRESULT *phr,
  LPCWSTR pName) :
    CBaseOutputPin(NAME("source pin"), pOwningFilter, &m_cs, phr, pName),
    m_id(iStream),
    m_rpImplBuffer(rpImplBuffer),
    m_rtAccumulated(0),
    m_dwSegmentNumber(0)
{
  m_pFilter = pFilter;

  // have the pin addref the filter
  // these are dynamic pins and have an independent lifetime from the filter's 
  // perspective, but still require the parent filter to stay alive 
  m_pFilter->AddRef();
    
  m_pPosition = 0;
  m_pSelection = 0;
  m_pWorker = 0;
  m_pRecAllocator = 0;

  m_llImsStart = m_llImsStop = 0;
  m_dImsRate = 0;
  m_ilfNewImsValues = FALSE;
  m_fUsingExternalMemory = FALSE;

  m_guidFormat = TIME_FORMAT_MEDIA_TIME;

  if(FAILED(*phr))
    return;

  CRecAllocator *pAllocator = new CRecAllocator(
    NAME("CBaseMSROutPin allocator"),
    0,
    phr);
  if(pAllocator == 0)
    *phr = E_OUTOFMEMORY;
  if(FAILED(*phr))
    return;

  m_pRecAllocator = pAllocator;
  pAllocator->AddRef();

 ASSERT(m_pRecAllocator);

}

CBaseMSROutPin::~CBaseMSROutPin()
{
  // these have the same lifetime as the pin; the pin is responsible
  // for deleting them
  delete m_pPosition;
  delete m_pSelection;

  if(m_pWorker && m_pWorker->ThreadExists())
      m_pWorker->Exit();
  delete m_pWorker;

  if(m_pRecAllocator)
    m_pRecAllocator->Release();
    
  m_pFilter->Release();    

}

STDMETHODIMP
CBaseMSROutPin::NonDelegatingQueryInterface (
  REFIID riid,
  void ** pv)
{
  if(riid == IID_IMediaSeeking ||  riid == IID_IMediaPosition)
  {
    if(m_pSelection == 0)
    {
      HRESULT hr = CreateImplSelect();
      if(FAILED(hr))
	return hr;
      ASSERT(m_pSelection);
    }
    return m_pSelection->NonDelegatingQueryInterface(riid, pv);
  }
  else
  {
    return CBaseOutputPin::NonDelegatingQueryInterface(riid, pv);
  }
}

STDMETHODIMP_(ULONG)
CBaseMSROutPin::NonDelegatingAddRef()
{
    return CUnknown::NonDelegatingAddRef();
}


/* Override to decrement the owning filter's reference count */

STDMETHODIMP_(ULONG)
CBaseMSROutPin::NonDelegatingRelease()
{
    return CUnknown::NonDelegatingRelease();
}

// check if the pin can support this specific proposed type&format
//
HRESULT
CBaseMSROutPin::CheckMediaType (
  const CMediaType* pmt)
{
  // we support exactly the types we propose, and
  // no other.
  //
  for (int i = 0; ; i++) {
      CMediaType mt;
      if (S_OK == GetMediaType(i,&mt)) {
	  if (mt == *pmt)
	    return NOERROR;
      } else {
	  break;
      }
  }
  return E_INVALIDARG;
}

HRESULT
CBaseMSROutPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
  ASSERT(!m_fUsingExternalMemory);
  *ppAlloc = 0;
  ASSERT(m_pRecAllocator);

  if(UseDownstreamAllocator())
  {
    HRESULT hr = CBaseOutputPin::DecideAllocator(pPin, ppAlloc);
    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 2,
	      TEXT("CBaseMSROutPin::DecideAllocator: failed %08x"), hr));
      return hr;
    }
  }
  else
  {
    IAMDevMemoryAllocator *pDevAlloc;
    IMemAllocator *pAlloc;
    HRESULT hr;

    hr = pPin->GetAllocator(&pAlloc);
    if (SUCCEEDED(hr))
    {
      hr = pAlloc->QueryInterface(
	IID_IAMDevMemoryAllocator, (void **)&pDevAlloc);
      if(SUCCEEDED(hr))
      {
	hr = m_pFilter->NotifyExternalMemory(pDevAlloc);
	if(hr == S_OK)
	{
	  m_fUsingExternalMemory = TRUE;
	}

	pDevAlloc->Release();
      }
      pAlloc->Release();
    }

    hr = pPin->NotifyAllocator(m_pRecAllocator, TRUE);
    if(FAILED(hr))
    {
	DbgLog((LOG_ERROR, 2,
		TEXT("CBaseMSROutPin::DecideAllocator: notify failed %08x"), hr));
	return hr;
    }


    *ppAlloc = m_pRecAllocator;
    m_pRecAllocator->AddRef();
  }

  return S_OK;
}

// DecideBufferSize is pure in CBaseOutputPin so it's defined
// here. our DecideAllocator never calls it though.

HRESULT
CBaseMSROutPin::DecideBufferSize(
  IMemAllocator * pAlloc,
  ALLOCATOR_PROPERTIES *Properties)
{
  DbgBreak("this should never be called.");
  return E_UNEXPECTED;
}

HRESULT
CBaseMSROutPin::GetDeliveryBufferInternal(
  CRecSample ** ppSample,
  REFERENCE_TIME * pStartTime,
  REFERENCE_TIME * pEndTime,
  DWORD dwFlags)
{
  if(m_pAllocator == 0)
    return E_NOINTERFACE;

  // use m_pRecAllocator since we may be copying to m_pAllocator which
  // might be different.
  return m_pRecAllocator->GetBuffer(
    ppSample,
    pStartTime,
    pEndTime,
    dwFlags);
}

// ------------------------------------------------------------------------
// IMediaSelection helpers

HRESULT CBaseMSROutPin::IsFormatSupported(const GUID *const pFormat)
{
  return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
}

HRESULT CBaseMSROutPin::QueryPreferredFormat(GUID *pFormat)
{
  *pFormat = TIME_FORMAT_MEDIA_TIME;
  return S_OK;
}

HRESULT CBaseMSROutPin::SetTimeFormat(const GUID *const pFormat)
{
  if(IsFormatSupported(pFormat) != S_OK)
    return E_INVALIDARG;

  // prevent the filter from going active from under us
  CAutoLock lock(m_pFilter);

  // state changes do happen synchronously, so this will return
  // immediately.
  FILTER_STATE fs;
  HRESULT hr = m_pFilter->GetState(INFINITE, &fs);
  ASSERT(SUCCEEDED(hr));
  if(FAILED(hr))
    return hr;

  if(fs != State_Stopped)
    return VFW_E_WRONG_STATE;

  m_guidFormat = *pFormat;

  m_pFilter->SetSeekingIf(m_id);

  // we need to set the m_llImsStart and stop values. none were set,
  // so just use the entire file. we'll still play the right subset.
  m_llImsStart = m_llCvtImsStart;
  m_llImsStop = m_llCvtImsStop;

  // !!! what about TIME_FORMAT_KEYFRAMES and other formats
  if(m_guidFormat == TIME_FORMAT_MEDIA_TIME)
  {
    m_llImsStop = ConvertInternalToRT(m_llImsStop);
    m_llImsStart = ConvertInternalToRT(m_llImsStart);
  }

  return S_OK;
}

HRESULT CBaseMSROutPin::ConvertTimeFormat(
    LONGLONG * pTarget, const GUID * pTargetFormat,
    LONGLONG    Source, const GUID * pSourceFormat
)
{
    CheckPointer( pTarget, E_POINTER );

    // Assume the worst...
    HRESULT hr = E_INVALIDARG;

    // evaluate the format arguments
    const GUID *pSrcFmtEval = pSourceFormat ? pSourceFormat : &m_guidFormat;
    const GUID *pTargFmtEval = pTargetFormat ? pTargetFormat : &m_guidFormat;

    if ( *pTargFmtEval == *pSrcFmtEval)
    {
	*pTarget = Source;
	hr = NOERROR;
    }
    else if (*pTargFmtEval == TIME_FORMAT_MEDIA_TIME &&
	     (*pSrcFmtEval == TIME_FORMAT_SAMPLE ||
	      *pSrcFmtEval == TIME_FORMAT_FRAME))
    {

	*pTarget = ConvertInternalToRT( Source );
	hr = NOERROR;

    }
    else if (*pSrcFmtEval == TIME_FORMAT_MEDIA_TIME &&
	     (*pTargFmtEval == TIME_FORMAT_FRAME ||
	      *pTargFmtEval == TIME_FORMAT_SAMPLE))
    {

	*pTarget = ConvertRTToInternal( Source );
	hr = NOERROR;
    }

    return hr;
}

HRESULT CBaseMSROutPin::GetTimeFormat(GUID *pFormat)
{
  *pFormat = m_guidFormat;
  return S_OK;
}

HRESULT
CBaseMSROutPin::UpdateSelectionAndTellWorker(
  LONGLONG *pCurrent,
  LONGLONG *pStop,
  REFTIME *pTime,
  double dRate,
  const GUID *const pGuidFormat,
  DWORD dwSeekFlags)
{
  {
    // protect from worker thread
    CAutoLock lock(&m_csImsValues);

    HRESULT hr;
    if (dRate != 0) m_dImsRate = dRate;

    DbgLog((LOG_TRACE, 5, TEXT("CBaseMSROutPin::SetSelection: %d - %d"),
	    pCurrent ? (LONG)*pCurrent : -1,
	    pStop ? (LONG)*pStop : -1
	    ));

    hr = RecordStartAndStop(
	pCurrent,
	pStop,
	pTime,
	pGuidFormat ? pGuidFormat : &m_guidFormat);

    if(FAILED(hr)) return hr;

    if(pCurrent)
    {
      m_llImsStart = *pCurrent;
    }

    if(pStop)
      m_llImsStop = *pStop;

    m_dwSeekFlags = dwSeekFlags;
  }

  if(!pCurrent) {
      InterlockedExchange(&m_ilfNewImsValues, TRUE);
  }

  // if this is the one with the interface, seek the other streams
  if(m_pFilter->RequestSeekingIf(m_id))
  {
    ASSERT(m_guidFormat != TIME_FORMAT_NONE);
    // flush the file source and seek the other streams (in time
    // units)
    HRESULT hr;
    if(m_guidFormat == TIME_FORMAT_MEDIA_TIME)
    {
      hr = m_pFilter->SeekOtherStreams(
	m_id,
	pCurrent ? &m_llImsStart : 0,
	pStop    ? &m_llImsStop  : 0,
	m_dImsRate,
	dwSeekFlags);
    }
    else
    {
      REFERENCE_TIME rtStart =
	pCurrent ? ConvertInternalToRT(m_llCvtImsStart) : 0;
      REFERENCE_TIME rtStop =
	pStop    ? ConvertInternalToRT(m_llCvtImsStop)  : 0;

      ASSERT(m_guidFormat == TIME_FORMAT_SAMPLE ||
	     m_guidFormat == TIME_FORMAT_FRAME);
      hr = m_pFilter->SeekOtherStreams(
	m_id,
	pCurrent ? &rtStart : 0,
	pStop    ? &rtStop  : 0,
	m_dImsRate,
	dwSeekFlags);
    }
    if(FAILED(hr))
      return hr;

    if(pCurrent)
    {
      hr = m_pFilter->StopFlushRestartAllStreams(dwSeekFlags);
      if(FAILED(hr))
	return hr;
    }
  }
  return S_OK;
}

HRESULT CBaseMSROutPin::StopWorker(bool bFlush)
{
  // this lock should not be the same as the lock that protects
  // access to the start/stop/rate values. The worker thread will
  // need to lock that on some code paths before responding to a
  // Stop and thus will cause deadlock.

  // what we are locking here is access to the worker thread, and
  // thus we should hold the lock that prevents more than one client
  // thread from accessing the worker thread.

  if(m_pWorker == 0)
    return S_OK;

  CAutoLock lock(&m_pWorker->m_AccessLock);

  if(m_pWorker->ThreadExists())
  {
    DbgLog((LOG_TRACE, 5, TEXT("CBaseMSROutPin::RestartWorker")));

    // next time round the loop the worker thread will pick up the
    // position change.

    // We need to flush all the existing data - we must do that here
    // as our thread will probably be blocked in GetBuffer otherwise

    if (bFlush) {
	DeliverBeginFlush();
    }

    // make sure we have stopped pushing
    m_pWorker->Stop();

    // complete the flush
    if (bFlush) {
	DeliverEndFlush();

	// Clear segment stuff if flushing
	// but don't clear the number here - that only happens on
	// Stop() otherwise the filter graph can't reconcile
	// segment ends if SetPositions is called without NoFlush but
	// with Segment
	m_rtAccumulated = 0;
    }
  }

  return S_OK;
}


HRESULT CBaseMSROutPin::RestartWorker()
{
  // this lock should not be the same as the lock that protects
  // access to the start/stop/rate values. The worker thread will
  // need to lock that on some code paths before responding to a
  // Stop and thus will cause deadlock.

  // what we are locking here is access to the worker thread, and
  // thus we should hold the lock that prevents more than one client
  // thread from accessing the worker thread.

  if(m_pWorker == 0)
  {
    m_pFilter->NotifyStreamQueued();
    return S_OK;
  }

  CAutoLock lock(&m_pWorker->m_AccessLock);

  if(m_pWorker->ThreadExists())
  {
    m_pWorker->NotifyStreamActive();

    // restart
    m_pWorker->Run();
  }
  else
  {
    m_pFilter->NotifyStreamQueued();
  }

  return S_OK;
}



HRESULT CBaseMSROutPin::GetStopPosition(LONGLONG *pStop)
{
  if(m_guidFormat == TIME_FORMAT_NONE)
    return VFW_E_NO_TIME_FORMAT_SET;

  if(m_guidFormat == TIME_FORMAT_MEDIA_TIME)
  {
    *pStop = ConvertInternalToRT(m_llCvtImsStop);
  }
  else
  {
    *pStop = m_llCvtImsStop;
  }
  return S_OK;
}

// valid only if we haven't delivered any samples
HRESULT CBaseMSROutPin::GetCurrentPosition(LONGLONG *pCur)
{
  if(m_guidFormat == TIME_FORMAT_NONE)
    return VFW_E_NO_TIME_FORMAT_SET;

  if(m_guidFormat == TIME_FORMAT_MEDIA_TIME)
  {
    *pCur = ConvertInternalToRT( m_llCvtImsStart );
  }
  else
  {
    *pCur = m_llCvtImsStart;
  }
  return S_OK;
}

HRESULT CBaseMSROutPin::InitializeOnNewFile()
{

  // set start and stop times if none set using IMediaSelection. BUSTED!!!.
  ASSERT(m_dImsRate == 0);

  // set playback start and stop
  m_llCvtImsStart = 0;
  m_llCvtImsStop = GetStreamStart() + GetStreamLength();
  m_dImsRate = 1;

  // use TIME_FORMAT_MEDIA_TIME rather than checking if the derived class
  // supports frame/sample
  m_llImsStart = 0;
  m_llImsStop = ConvertInternalToRT(m_llCvtImsStop);
  m_guidFormat = TIME_FORMAT_MEDIA_TIME;
  m_dwSeekFlags = 0;

  return S_OK;
}


// ------ IMediaPosition implementation -----------------------

// HRESULT
// CBaseMSROutPin::CImplPosition::ChangeStart()
// {
//   DbgLog((LOG_TRACE, 2, TEXT("CImplPosition::ChangeStart: %dms"),
//           (ULONG)m_Start.Millisecs() ));

//   REFERENCE_TIME t = m_Start;
//   return m_pStream->SetSelection(
//     &t,
//     0,
//     0,
//     m_Rate,
//     &TIME_FORMAT_MEDIA_TIME);
// }

// HRESULT
// CBaseMSROutPin::CImplPosition::ChangeRate()
// {
//   DbgLog((LOG_TRACE, 2, TEXT("CImplPosition::Rate")));

//   return m_pStream->SetSelection(
//     0,
//     0,
//     0,
//     m_Rate,
//     &TIME_FORMAT_MEDIA_TIME);
// }

// HRESULT
// CBaseMSROutPin::CImplPosition::ChangeStop()
// {
//   DbgLog((LOG_TRACE, 2, TEXT("CImplPosition::ChangeStop: %dms"),
//           (ULONG)m_Stop.Millisecs() ));

//   REFERENCE_TIME t = m_Stop;
//   return m_pStream->SetSelection(
//     0,
//     &t,
//     0,
//     m_Rate,
//     &TIME_FORMAT_MEDIA_TIME);
// }

// // ok to use this as it is not dereferenced
// #pragma warning(disable:4355)

// CBaseMSROutPin::CImplPosition::CImplPosition(
//   TCHAR      * pName,
//   CBaseMSROutPin * pStream,
//   HRESULT    * phr)
//     : CSourcePosition(pName, pStream->GetOwner(), phr, (CCritSec*)this),
//       m_pStream(pStream)
// {
//   DbgBreak("IMediaPosition is being removed");
//   *phr = E_NOINTERFACE;

//   if(FAILED(*phr))
//     return;

//   *phr = m_pStream->CreateImplSelect();
//   if(FAILED(*phr))
//     return;

//   m_Duration = m_pStream->ConvertInternalToRT(
//     m_pStream->GetStreamStart() + m_pStream->GetStreamLength());

//   m_Stop = m_Duration;
//   m_Rate = 1;
//   m_Start = (LONGLONG)0;

//   *phr = S_OK;
//   return;
// }

// void CBaseMSROutPin::CImplPosition::GetValues(
//   CRefTime *ptStart,
//   CRefTime *ptStop,
//   double *pdRate)
// {
//   CAutoLock(this);
//   *ptStart = m_Start;
//   *ptStop = m_Stop;
//   *pdRate = m_Rate;
// }

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// IMediaSelection Implementation

HRESULT CBaseMSROutPin::CreateImplSelect()
{
  if(m_pSelection != 0)
  {
    return S_OK;
  }

  HRESULT hr = S_OK;
  m_pSelection = new CImplSelect(
    NAME("per stream CImplSelect"),
    this->GetOwner(),
    this,
    &hr);

  if(m_pSelection == 0)
    return E_OUTOFMEMORY;

  if(FAILED(hr))
  {
    delete m_pSelection;
    m_pSelection = 0;
    return hr;
  }

  return S_OK;
}

CBaseMSROutPin::CImplSelect::CImplSelect(
  TCHAR * name,
  LPUNKNOWN pUnk,
  CBaseMSROutPin *pPin,
  HRESULT * phr) :
    CMediaPosition(name, pUnk),
    m_pPin(pPin)
{
}

// advertise IMediaSelection
STDMETHODIMP
CBaseMSROutPin::CImplSelect::NonDelegatingQueryInterface(
  REFIID riid,
  void **ppv)
{
  CheckPointer(ppv,E_POINTER);
  ValidateReadWritePtr(ppv,sizeof(PVOID));
  if (riid == IID_IMediaSeeking) {
    return GetInterface( static_cast<IMediaSeeking *>(this), ppv);
  }
  else
  {
    // IID_IMediaPosition and unknown
    return CMediaPosition::NonDelegatingQueryInterface(riid, ppv);
  }
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::IsFormatSupported(const GUID * pFormat)
{
  return m_pPin->IsFormatSupported(pFormat);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::QueryPreferredFormat(GUID *pFormat)
{
  return m_pPin->QueryPreferredFormat(pFormat);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::SetTimeFormat(const GUID * pFormat)
{

  return m_pPin->SetTimeFormat(pFormat);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetTimeFormat(GUID *pFormat)
{
  return m_pPin->GetTimeFormat(pFormat);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::IsUsingTimeFormat(const GUID * pFormat)
{
  GUID TmpFormat;
  HRESULT hr = m_pPin->GetTimeFormat(&TmpFormat);
  if (SUCCEEDED(hr)) hr = (TmpFormat == *pFormat) ? S_OK : S_FALSE;
  return hr;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetDuration(LONGLONG *pDuration)
{
  return m_pPin->GetDuration(pDuration);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetStopPosition(LONGLONG *pStop)
{
  return m_pPin->GetStopPosition(pStop);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetCurrentPosition(LONGLONG *pCurrent)
{
  return m_pPin->GetCurrentPosition(pCurrent);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetCapabilities( DWORD * pCapabilities )
{
  *pCapabilities = m_pPin->m_pFilter->m_dwSeekingCaps;
  return NOERROR;
}


STDMETHODIMP
CBaseMSROutPin::CImplSelect::CheckCapabilities( DWORD * pCapabilities )
{
    DWORD dwCaps;
    HRESULT hr = GetCapabilities( &dwCaps );
    if (SUCCEEDED(hr))
    {
	dwCaps &= *pCapabilities;
	hr =  dwCaps ? ( dwCaps == *pCapabilities ? S_OK : S_FALSE ) : E_FAIL;
	*pCapabilities = dwCaps;
    }
    else *pCapabilities = 0;

    return hr;
}


STDMETHODIMP
CBaseMSROutPin::CImplSelect::ConvertTimeFormat
( LONGLONG * pTarget,  const GUID * pTargetFormat
, LONGLONG    Source,  const GUID * pSourceFormat
)
{
    return m_pPin->ConvertTimeFormat( pTarget, pTargetFormat, Source, pSourceFormat );
}


STDMETHODIMP
CBaseMSROutPin::CImplSelect::SetPositions
( LONGLONG * pCurrent, DWORD CurrentFlags
, LONGLONG * pStop,    DWORD StopFlags
)
{
    if(!m_pPin->m_pFilter->RequestSeekingIf(m_pPin->m_id))
    {
      // !!!!!!!!!@!!!
      //DbgBreak("someone tried to seek us even though we said we don't support seeking");
      return S_OK;
    }

    HRESULT hr;

    LONGLONG llCurrent = 0, llStop = 0;
    int CurrentPosBits, StopPosBits;

    CurrentPosBits = CurrentFlags & AM_SEEKING_PositioningBitsMask;
    if (CurrentPosBits == AM_SEEKING_AbsolutePositioning)              llCurrent = *pCurrent;
    else if (CurrentPosBits == AM_SEEKING_RelativePositioning)
    {
	hr = GetCurrentPosition( &llCurrent );
	if (FAILED(hr)) goto fail;
	llCurrent += *pCurrent;
    }

    StopPosBits = StopFlags & AM_SEEKING_PositioningBitsMask;
    if (StopPosBits == AM_SEEKING_AbsolutePositioning)              llStop = *pStop;
    else if (StopPosBits == AM_SEEKING_IncrementalPositioning)      llStop = llCurrent + *pStop;
    else if (StopPosBits == AM_SEEKING_RelativePositioning)
    {
	hr = GetStopPosition( &llStop );
	if (FAILED(hr)) goto fail;
	llStop += *pStop;
    }

    double dblStart;
    hr = m_pPin->UpdateSelectionAndTellWorker( CurrentPosBits ? &llCurrent : 0
			     , StopPosBits    ? &llStop    : 0
			     , CurrentPosBits ? &dblStart  : 0
			     , NULL
			     , 0
			     , CurrentFlags);

    if (FAILED(hr)) goto fail;

    if (CurrentPosBits)
    {
	const REFERENCE_TIME rtStart = LONGLONG(dblStart * 1e7 + 0.5);

	if (CurrentFlags & AM_SEEKING_ReturnTime)
	{
	    *pCurrent = rtStart;
	}

    }

    if (StopPosBits && (StopFlags & AM_SEEKING_ReturnTime))
    {
	EXECUTE_ASSERT(SUCCEEDED(
	    hr = ConvertTimeFormat( pStop, &TIME_FORMAT_MEDIA_TIME, llStop, 0 )
	));
    }

fail:
    return hr;
}



STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    ASSERT( pCurrent || pStop );    // Sanity check

    HRESULT hrCurrent, hrStop, hrResult;

    if (pCurrent)
    {
	hrCurrent = GetCurrentPosition( pCurrent );
    }
    else hrCurrent = NOERROR;

    if (pStop)
    {
	hrStop = GetStopPosition( pStop );
    }
    else hrStop = NOERROR;


    if (SUCCEEDED(hrCurrent))
    {
	if (SUCCEEDED(hrStop))  hrResult = S_OK;
	else                    hrResult = hrStop;
    }
    else
    {
	if (SUCCEEDED(hrStop))  hrResult = hrCurrent;
	else                    hrResult = (hrCurrent == hrStop) ? hrCurrent : E_FAIL;
    }

    return hrResult;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    return m_pPin->GetAvailable(pEarliest, pLatest);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::SetRate( double dRate)
{
    if(dRate > 0)
      return m_pPin->UpdateSelectionAndTellWorker(0, 0, 0, dRate, &TIME_FORMAT_MEDIA_TIME, 0);
    else
      return E_INVALIDARG;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::GetRate( double * pdRate)
{
    *pdRate = m_pPin->GetRate();
    return NOERROR;
}

//
// IMediaPosition. calls IMediaSeeking implementation
//

STDMETHODIMP
CBaseMSROutPin::CImplSelect::get_Duration(REFTIME FAR* plength)
{
    HRESULT hr = S_OK;
    if(plength)
    {
	LONGLONG llDurUnknownUnits;
	hr = GetDuration(&llDurUnknownUnits);
	if(SUCCEEDED(hr))
	{
	    LONGLONG llDurTimeUnits;
	    hr = ConvertTimeFormat(
		&llDurTimeUnits, &TIME_FORMAT_MEDIA_TIME,
		llDurUnknownUnits, 0);
	    if(SUCCEEDED(hr))
	    {
		*plength = (REFTIME)llDurTimeUnits / UNITS;
	    }
	}
    }
    else
    {
	 hr = E_POINTER;
    }

    return hr;
}

// IMediaPosition always rounds down. probably ok since we don't rely
// on IMediaPosition heavily. and probably only lose anything
// converting large doubles to int64s.

STDMETHODIMP
CBaseMSROutPin::CImplSelect::put_CurrentPosition(REFTIME llTime)
{
    HRESULT hr = S_OK;
    LONGLONG llPosTimeUnits = (LONGLONG)(llTime * UNITS);
    LONGLONG llPosUnknownUnits;
    hr = ConvertTimeFormat(
	&llPosUnknownUnits, 0,
	llPosTimeUnits, &TIME_FORMAT_MEDIA_TIME);
    if(SUCCEEDED(hr))
    {
	hr = SetPositions(
	    &llPosUnknownUnits, AM_SEEKING_AbsolutePositioning,
	    0, AM_SEEKING_NoPositioning);
    }

    return hr;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::get_CurrentPosition(REFTIME FAR* pllTime)
{
    // not tested !!!

    CheckPointer(pllTime, E_POINTER);
    LONGLONG llposUnknownUnits;
    HRESULT hr = GetCurrentPosition(&llposUnknownUnits);
    if(SUCCEEDED(hr))
    {
	LONGLONG llposTimeUnits;
	hr = ConvertTimeFormat(
	    &llposTimeUnits, &TIME_FORMAT_MEDIA_TIME,
	    llposUnknownUnits, 0);
	if(SUCCEEDED(hr))
	{
	    *pllTime = (REFTIME)llposTimeUnits / UNITS ;
	}
    }

    return hr;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::get_StopTime(REFTIME FAR* pllTime)
{
    CheckPointer(pllTime, E_POINTER);
    LONGLONG llposUnknownUnits;
    HRESULT hr = GetStopPosition(&llposUnknownUnits);
    if(SUCCEEDED(hr))
    {
	LONGLONG llposTimeUnits;
	hr = ConvertTimeFormat(
	    &llposTimeUnits, &TIME_FORMAT_MEDIA_TIME,
	    llposUnknownUnits, 0);
	if(SUCCEEDED(hr))
	{
	    *pllTime = (REFTIME)llposTimeUnits / UNITS;
	}
    }

    return hr;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::put_StopTime(REFTIME llTime)
{
    HRESULT hr = S_OK;
    LONGLONG llPosTimeUnits = (LONGLONG)(llTime * UNITS);
    LONGLONG llPosUnknownUnits;
    hr = ConvertTimeFormat(
	&llPosUnknownUnits, 0,
	llPosTimeUnits, &TIME_FORMAT_MEDIA_TIME);
    if(SUCCEEDED(hr))
    {
	hr = SetPositions(
	    0, AM_SEEKING_NoPositioning,
	    &llPosUnknownUnits, AM_SEEKING_AbsolutePositioning
	    );
    }

    return hr;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::get_PrerollTime(REFTIME FAR* pllTime)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::put_PrerollTime(REFTIME llTime)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::put_Rate(double dRate)
{
    return SetRate(dRate);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::get_Rate(double FAR* pdRate)
{
    return GetRate(pdRate);
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::CanSeekForward(long FAR* pCanSeekForward)
{
    CheckPointer(pCanSeekForward, E_POINTER);
    *pCanSeekForward = OATRUE;
    return S_OK;
}

STDMETHODIMP
CBaseMSROutPin::CImplSelect::CanSeekBackward(long FAR* pCanSeekBackward)
{
    CheckPointer(pCanSeekBackward, E_POINTER);
    *pCanSeekBackward = OATRUE;
    return S_OK;
}



// ------------------------------------------------------------------------
// ------------------------------------------------------------------------


// =================== IPin interfaces ===========================
//

// return an qzTaskMemAlloc'd string containing the name of the
// current pin.  memory allocated by qzTaskMemAlloc will be freed by
// the caller
//
// STDMETHODIMP CBaseMSROutPin::QueryId (
//   LPWSTR *ppwsz)
// {
//   *ppwsz = (LPWSTR)QzTaskMemAlloc(sizeof(WCHAR) * 28);
//   IntToWstr(m_id, *ppwsz);
//   return NOERROR;
// }

// this pin has gone active. Start the thread pushing
HRESULT
CBaseMSROutPin::Active()
{
  // filter base class must still be stopped
  ASSERT(m_pFilter->IsStopped());



  HRESULT hr = OnActive();
  if(SUCCEEDED(hr))
  {

    ASSERT(m_Connected);          // CBaseOutputPin::Pause
    ASSERT(m_pWorker);

    hr = CBaseOutputPin::Active();
    if(SUCCEEDED(hr))
    {

      // We may have two allocators on this output pin. commmit the one
      // not being used to deliver samples.
      if(UseDownstreamAllocator())
	m_pRecAllocator->Commit();

      // create the thread if it does not exist.  since the filter is
      // stopped, no one else can call this thread, so we don't take
      // the worker access lock
      ASSERT(CritCheckOut(&m_pWorker->m_AccessLock));

      if (m_pWorker->ThreadExists() || m_pWorker->Create(this))
      {
	m_pWorker->NotifyStreamActive();
	hr = m_pWorker->Run();

      }
      else
      {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseMSROutPin failed to create thread")));
	hr = E_OUTOFMEMORY;
      }
    }
  }

  // all paths which would not decrement m_ilcStreamsNotQueued need to
  // do it manually
  if(hr != S_OK)
  {
    DbgLog((LOG_ERROR, 1, TEXT("basemsr Active: unexpected failure")));
    m_pFilter->NotifyStreamQueued();
  }

  return hr;
}

// pin has gone inactive. Stop and exit the worker thread
//
HRESULT
CBaseMSROutPin::Inactive()
{
  if ( ! m_Connected)
    return NOERROR;

  if(m_pWorker)
  {
    CAutoLock lock(&m_pWorker->m_AccessLock);
    HRESULT hr;
    if (m_pWorker->ThreadExists())
    {
      hr = m_pWorker->Stop();
      ASSERT(SUCCEEDED(hr));

      hr = m_pWorker->Exit();
      ASSERT(SUCCEEDED(hr));
    }
  }

  if(UseDownstreamAllocator())
    m_pRecAllocator->Decommit();

  //  Clear source seeking variables
  m_dwSegmentNumber = 0;
  m_rtAccumulated   = 0;

  return CBaseOutputPin::Inactive();
}

HRESULT CBaseMSROutPin::BreakConnect()
{
  if(m_fUsingExternalMemory)
  {
    m_pFilter->NotifyExternalMemory(0);
    m_fUsingExternalMemory = FALSE;
  }
  return CBaseOutputPin::BreakConnect();
}

STDMETHODIMP
CBaseMSROutPin::Notify (
  IBaseFilter * pSender,
  Quality q)
{
  // ??? Try to adjust the quality to avoid flooding/starving the
  // components downstream.
  //
  // ideas anyone?

  // play every nth key frame

  return NOERROR;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

CBaseMSRWorker::CBaseMSRWorker(
  UINT stream,
  IMultiStreamReader *pReader) :
   m_pPin(NULL),
   m_id(stream),
   m_pReader(pReader)           // not addrefd
{
}

BOOL CBaseMSRWorker::Create(
   CBaseMSROutPin * pPin)
{
  CAutoLock lock(&m_AccessLock);

  if (m_pPin)
    return FALSE;
  m_pPin = pPin;

  // register perf log entries with stream id
#ifdef PERF
  char foo[1024];

  lstrcpy(foo, "pin00 basemsr Deliver");
  foo[4] += m_pPin->m_id % 10;
  foo[3] += m_pPin->m_id / 10;

  m_perfidDeliver = MSR_REGISTER(foo);

  lstrcpy(foo, "pin00 basemsr disk wait");
  foo[4] += m_pPin->m_id % 10;
  foo[3] += m_pPin->m_id / 10;

  m_perfidWaitI = MSR_REGISTER(foo);

  lstrcpy(foo, "pin00 basemsr !deliver");
  foo[4] += m_pPin->m_id % 10;
  foo[3] += m_pPin->m_id / 10;

  m_perfidNotDeliver = MSR_REGISTER(foo);

#endif // PERF

   return CAMThread::Create();
}

HRESULT CBaseMSRWorker::Run()
{
   return CallWorker(CMD_RUN);
}

HRESULT CBaseMSRWorker::Stop()
{
   return CallWorker(CMD_STOP);
}

HRESULT CBaseMSRWorker::Exit()
{
   CAutoLock lock(&m_AccessLock);

   HRESULT hr = CallWorker(CMD_EXIT);
   if (FAILED(hr))
      return hr;

   // wait for thread completion and then close
   // handle (and clear so we can start another later)
   //
   Close();

   m_pPin = NULL;
   return NOERROR;
}

HRESULT CBaseMSRWorker::NotifyStreamActive()
{
  m_fCalledNotifyStreamQueued = FALSE;
  return S_OK;
}

// called on the worker thread to do all the work. Thread exits when this
// function returns.
//
DWORD CBaseMSRWorker::ThreadProc()
{
    BOOL bExit = FALSE;
    while (!bExit)
    {
       Command cmd = GetRequest();
       switch (cmd)
       {
       case CMD_EXIT:
	   bExit = TRUE;
	   Reply(NOERROR);
	   break;

       case CMD_RUN:
	   Reply(NOERROR);
	   DoRunLoop();
	   break;

       case CMD_STOP:
	   Reply(NOERROR);
	   break;

       default:
	   Reply(E_NOTIMPL);
	   break;
       }
    }

    return NOERROR;
}

// sets the worker thread start, stop-time and rate variables. Called before push
// starts, and also when a put_Stop or put_Rate happens during running.
// If the start time changes, the worker thread will be restarted. If we change
// it here when running, the change won't be picked up.
HRESULT
CBaseMSRWorker::SetNewSelection(void)
{
  // keep worker thread from seeing inconsistent values when it's
  // pushing. the start values don't really need to be protected
  // because we restart the thread anyway when changing the start
  // value

  DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRWorker::SetNewSelection.") ));

  CAutoLock lock(&m_pPin->m_csImsValues);

  // this is in the derived class' internal units
  LONGLONG llStreamStop = m_pPin->GetStreamStart() + m_pPin->GetStreamLength();

  ASSERT(m_pPin->m_dImsRate != 0);

  // try to make changes atomic
  LONGLONG llPushStart;
  LONGLONG llPushStop;
  llPushStart = m_pPin->m_llCvtImsStart;
  llPushStop = m_pPin->m_llCvtImsStop;

  // check we are not going over the end. for video, put up the last
  // tick. for audio, nothing. if it's the clock, the clock for
  // -duration to get to present time.
  llPushStop = min(llStreamStop, llPushStop);

  if(llPushStart >= llStreamStop) {
      if(*m_pPin->CurrentMediaType().Type() != MEDIATYPE_Audio) {
	  llPushStart = llStreamStop - 1;
      }
  }

  if(llPushStop < llPushStart) {
    llPushStop = llPushStart;
  }


  m_ImsValues.dRate         = m_pPin->m_dImsRate;
  m_ImsValues.llTickStart   = llPushStart;
  m_ImsValues.llTickStop    = llPushStop;
  m_ImsValues.llImsStart    = m_pPin->m_llImsStart;
  m_ImsValues.llImsStop     = m_pPin->m_llImsStop;
  m_ImsValues.dwSeekFlags   = m_pPin->m_dwSeekFlags;

  if(m_ImsValues.llImsStop < m_ImsValues.llImsStart)
    m_ImsValues.llImsStop = m_ImsValues.llImsStart;

  return S_OK;
}


void CBaseMSRWorker::DoRunLoop(void)
{
  HRESULT hr;

  // snapshot start and stop times from the other thread
  for(;;)
  {
    // each time before re-entering the push loop, pick up changes in
    // start, stop or rate.


    // initialise the worker thread's start, stop and rate variables
    // this is pulled out separately as it can also be called
    // from a seeking thread when we are running.
    SetNewSelection();

    // race condition in this debug output
    DbgLog((LOG_TRACE, 2, TEXT("CBaseMSRWorker::DoRunLoop: pushing from %d-%d"),
	    (ULONG)m_ImsValues.llTickStart, (ULONG)m_ImsValues.llTickStop));

    m_cSamples = 0;


    if(m_pPin->m_dImsRate == 0)
      m_Format = FORMAT_NULL;
    else
      m_Format = CBaseMSRFilter::MapGuidToFormat(m_pPin->CurrentFormat());

    hr = PushLoop();

    m_pPin->m_rpImplBuffer->ClearPending(m_pPin->m_id);

    if(VFW_S_NO_MORE_ITEMS == hr)
    {
      // delivered the last sample successfully. can return something
      // if it's flushing or stopped. ignore those.
      DbgLog(( LOG_TRACE, 4, TEXT("avimsr: stream %d: sending EOS"),
	       m_id ));
      DoEndOfData();
      break;
    }
    else if(FAILED(hr))
    {
      // this filter detected an error
      DbgLog((LOG_TRACE, 5,
	      TEXT("CBaseMSRWorker::DoRunLoop: push loop returned %08x"),
	      hr));

      // push loop should supress these errors when they are detected
      // as they normally indicate we are about to stop
      ASSERT(hr != VFW_E_NOT_COMMITTED && hr != VFW_E_WRONG_STATE);

      // assume the derived class only tries to read past the end of
      // the file if the file is corrupt
      if(hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
	hr = VFW_E_INVALID_FILE_FORMAT;

      // tell the graph what happened.
      // Note: we previously sent EC_STREAM_ERROR_STOPPED here,
      // but this had the side affect of causing looping graphs on corrupt
      // files to loop infinitely instead off aborting. we should abort
      // anyway.
      m_pPin->m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);

      // the error was in our filter, so we have to make the downstream
      // guy clean up properly
      DbgLog(( LOG_TRACE, 4, TEXT("avimsr: stream %d: sending EOS on error"),
	       m_id ));
      DoEndOfData();

      break;
    }
    else if(hr == S_OK)
    {
      // not my error to report. or someone wants to stop. queitly
      // exit.
      break;
    }// else S_FALSE - go round again

    // push loop should not return anything else.
    ASSERT(hr == S_FALSE);

    Command com;
    if (CheckRequest(&com))
    {
      // if it's a run command, then we're already running, so
      // eat it now.
      if (com == CMD_RUN)
      {
	GetRequest();
	Reply(NOERROR);
      }
      else
      {
	break;
      }
    }
  }

  NotifyStreamQueued();

  // end streaming
  DbgLog((LOG_TRACE,2,TEXT("CBaseMSRWorker::DoRunLoop: Leaving streaming loop")));
}

//  Signal appropriately that we got to the end of the data
void CBaseMSRWorker::DoEndOfData()
{
    if (m_ImsValues.dwSeekFlags & AM_SEEKING_Segment) {
	m_pPin->m_rtAccumulated += m_ImsValues.llImsStop - m_ImsValues.llImsStart;
	DbgLog((LOG_TRACE, 3, TEXT("Filter Sending EC_END_OF_SEGMENT")));
	m_pPin->m_pFilter->NotifyEvent(EC_END_OF_SEGMENT,
				       (LONG_PTR)&m_pPin->m_rtAccumulated,
				       m_pPin->m_dwSegmentNumber);
    } else {
	m_pPin->DeliverEndOfStream();
    }
}

// inline
void CBaseMSRWorker::NotifyStreamQueued()
{
  if(!m_fCalledNotifyStreamQueued)
  {
    DbgLog(( LOG_TRACE, 5, TEXT("CBaseMSRWorker::NotifyStreamQueued") ));
    m_pPin->m_pFilter->NotifyStreamQueued();
    m_fCalledNotifyStreamQueued = TRUE;
  }
}

// inline
void CBaseMSRWorker::NotifyStreamQueuedAndWait()
{
  if(!m_fCalledNotifyStreamQueued)
  {
    DbgLog(( LOG_TRACE, 5, TEXT("CBaseMSRWorker::NotifyStreamQueuedAndWait")));
    m_pPin->m_pFilter->NotifyStreamQueuedAndWait();
    m_fCalledNotifyStreamQueued = TRUE;
  }
}

HRESULT CBaseMSRWorker::CopyData(
  IMediaSample **ppSampleOut,
  IMediaSample *pSampleIn)
{
  DbgBreak("CBaseMSRWorker::CopyData: override this.");
  return E_UNEXPECTED;
}

HRESULT CBaseMSRWorker::AboutToDeliver(
  IMediaSample *pSample)
{
  HRESULT               hr;

  AM_MEDIA_TYPE         *pmt;

  hr = pSample->GetMediaType(&pmt);

  if (hr == S_FALSE)
  {
    hr = S_OK;
  }
  else if (hr == S_OK)
  {
    DbgLog((LOG_TRACE,1,TEXT("CBaseMSRWorker::AboutToDeliver: checking if new format is acceptable")));

    hr = m_pPin->m_Connected->QueryAccept(pmt);

    DeleteMediaType(pmt);

    if (hr != S_OK)
    {
      DbgLog((LOG_TRACE,1,TEXT("CBaseMSRWorker::AboutToDeliver: QueryAccept failed, returned %x"), hr));
      hr = VFW_E_CHANGING_FORMAT;
    }
  }

  return hr;
}


HRESULT CBaseMSRWorker::TryDeliverSample(
  BOOL *pfDeliveredSample,
  BOOL *pfStopPlease)
{
  HRESULT hr;
  *pfDeliveredSample = FALSE;
  *pfStopPlease = FALSE;
  IMediaSample *pSampleIn = 0;
  IMediaSample *pSampleDeliver = 0;

  // timeout of 0
  hr = m_pReader->PollForSample(
    &pSampleIn,
    m_id);

  if(hr == VFW_E_TIMEOUT)
  {
    DbgLog((LOG_TRACE, 0x7f, TEXT("CBaseMSRWorker::TryDeliver: poll failed ") ));
    return S_OK;
  }

  if(FAILED(hr))
  {
    DbgLog((LOG_ERROR, 5,
	    TEXT("CBaseMSRWorker::TryDeliver: wait failed %08x "), hr ));
    return hr;
  }

  ASSERT(SUCCEEDED(hr));

  CRecSample *pRecSampleIn = (CRecSample *)pSampleIn;

#ifdef DEBUG
  if(pRecSampleIn->GetUser())
  {
    DbgLog((LOG_TRACE, 5,
	    TEXT("CBaseMSRWorker::TryDeliver: Got buffer, size=%5d, mt set"),
	    pSampleIn->GetSize()));
  }
  else
  {
    CRefTime tStart, tEnd;
    pSampleIn->GetTime(
      (REFERENCE_TIME *)&tStart,
      (REFERENCE_TIME *)&tEnd);

    DbgLog((LOG_TRACE, 5,
	    TEXT("CBaseMSRWorker::TryDeliver: Got buffer, size=%5d, %07d-%07d ms"),
	    pSampleIn->GetSize(), tStart.Millisecs(), tEnd.Millisecs()));

    //   DbgLog((LOG_TRACE, 5,
    //           TEXT("%08x%08x - %08x%08x"),
    //           (ULONG)(tStart.GetUnits() >> 32),
    //           (ULONG)tStart.GetUnits(),
    //           (ULONG)(tEnd.GetUnits() >> 32),
    //           (ULONG)(tEnd.GetUnits()) ));
  }
#endif // DEBUG

  hr = E_FAIL;                  // all paths should set this.

  // nonzero user context is passed to the derived class's HandleData()
  if(pRecSampleIn->GetUser())
  {
    hr = HandleData(pSampleIn, pRecSampleIn->GetUser());
    if(FAILED(hr))
      DbgLog((LOG_ERROR, 1, TEXT("TryDeliverSample: HandleData failed")));
    pSampleIn->Release();
    pSampleIn = 0;
  }
  else
  {
    // stop time changed, but samples already queued... don't deliver
    // them. note partial frames/audio are not handled; ok as it's
    // probably not a video editing scenario
    LONGLONG lltStart, lltStop;
    if(pSampleIn->GetMediaTime(&lltStart, &lltStop) == S_OK)
    {
      if(lltStart > m_ImsValues.llTickStop)
      {
	DbgLog((LOG_TRACE, 5, TEXT("basmsr: past new stop")));
	pSampleIn->Release();
	pSampleIn = 0;
	*pfStopPlease = TRUE;
	return VFW_S_NO_MORE_ITEMS;
      }
    }
    else
    {
      DbgBreak("mt not set");
    }

    if(m_pPin->UseDownstreamAllocator())
    {
      hr = CopyData(&pSampleDeliver, pSampleIn);
      pSampleIn->Release();
      pSampleIn = 0;
      if(FAILED(hr))
	DbgLog((LOG_ERROR, 1, TEXT("TryDeliverSample: CopyData failed")));
    }
    else
    {
      pSampleDeliver = pSampleIn;
      pSampleIn = 0;            // don't Release()
      hr = AboutToDeliver(pSampleDeliver);
      if(FAILED(hr)) {
	DbgLog((LOG_ERROR, 1, TEXT("TryDeliverSample: AboutToDeliver failed")));
      }
      else {
	// we want to track the lifetime of this sample because it's
	// sent downstream
	((CRecSample *)pSampleDeliver)->MarkDelivered();
      }
    }

    if(S_OK == hr)
    {
      ++m_cSamples;

      MSR_STOP(m_perfidNotDeliver);

      hr = m_pPin->Deliver(pSampleDeliver);

      MSR_START(m_perfidNotDeliver);

      // if receive failed, downstream filter will report error; we
      // exit quietly after delivering EndOfStream
      if(FAILED(hr))
      {
	hr = S_FALSE;           // S_FALSE means please stop
      }

    } // AboutToDeliver/CopyData succeeded
    else if (SUCCEEDED(hr))
    {
      //  OK - we didn't want to deliver it
      hr = S_OK;
    }
  } // sample not data

  // done with buffer. connected pin may have its own addref
  if(pSampleDeliver)
    pSampleDeliver->Release();

  // HandleData, CopyData, or AboutToDeliver failed.
  if(FAILED(hr))
  {
    DbgLog((LOG_ERROR, 2,
	    TEXT("CBaseMSRWorker::TryDeliverSample: failed %08x"), hr));
    return hr;
  }

  *pfDeliveredSample = TRUE;

  if(hr == S_FALSE)
    *pfStopPlease = TRUE;

  return hr;
}

HRESULT CBaseMSRWorker::NewSegmentHelper()
{
    // values not yet adjusted for preroll.

    //  NewSegment start and stop times should match seek times in
    //  REFERENCE_TIME units.  If the current time format is in
    //  reference time units just use the current seek values, if not
    //  convert the seek values to REFERENCE_TIME.  For this to be
    //  correct each stream can only support 2 formats - it's native
    //  format and REFERENCE_TIME units (TIME_FORMAT_TIME).

    REFERENCE_TIME rtNsStart, rtNsStop;
    if(m_Format == FORMAT_TIME)
    {
        rtNsStart = m_ImsValues.llImsStart;
        rtNsStop = m_ImsValues.llImsStop;
    }
    else
    {
        rtNsStart = m_pPin->ConvertInternalToRT(m_ImsValues.llTickStart);
        rtNsStop = m_pPin->ConvertInternalToRT(m_ImsValues.llTickStop);
    }

    DbgLog((LOG_TRACE, 5, TEXT("PushLoop: NewSegment: %dms - %dms"),
            (DWORD)(rtNsStart / (UNITS / MILLISECONDS)),
            (DWORD)(rtNsStop / (UNITS / MILLISECONDS))));


    return m_pPin->DeliverNewSegment(rtNsStart, rtNsStop, m_ImsValues.dRate);
}

HRESULT
CBaseMSRWorker::PushLoop()
{
  HRESULT hr = S_OK;

  m_pReader->MarkStreamRestart(m_id);

  DbgLog((LOG_TRACE, 5, TEXT("PushLoop: tstart: %li, tstop %li"),
          (ULONG)m_ImsValues.llTickStart, (ULONG)m_ImsValues.llTickStop));

  // values not yet adjusted for preroll.
  hr = NewSegmentHelper();
  if(FAILED(hr))
    return hr;

  // just send EOS if start is after end of stream.
  LONGLONG llStreamStop = m_pPin->GetStreamStart() + m_pPin->GetStreamLength();
  if(m_ImsValues.llTickStart >= llStreamStop) {
      return VFW_S_NO_MORE_ITEMS;
  }

  LONGLONG llCurrent;
  hr = PushLoopInit(&llCurrent, &m_ImsValues);

  if(hr == VFW_S_NO_MORE_ITEMS)
    return VFW_S_NO_MORE_ITEMS;

  if(hr == VFW_E_NOT_COMMITTED || hr == VFW_E_WRONG_STATE)
    return S_OK;

  if(FAILED(hr))
    return hr;

  m_llPushFirst = llCurrent;    // remember the first thing we're sending

  // we send one sample at sStopAt, but we set the time stamp such that
  // it won't get rendered except for media types that understand static
  // rendering (eg video). This means that play from 10 to 10 does the right
  // thing (completing, with frame 10 visible and no audio).

  DbgLog((LOG_TRACE,5,TEXT("PushLoop: tcurrent: %li"),
	  (ULONG)(llCurrent / MILLISECONDS)));

  // queued all reads. continue waiting on and delivering samples
  BOOL fFinishDelivering = FALSE;

  // number of undelivered samples
  ULONG cQueuedReads = 0;

  for(;;)
  {
    // successfully queued a read in this iteration of push loop
    BOOL fQueuedRead = FALSE;

    // successfully waited on sample in this iteration of push loop
    BOOL fWaitedForSample = FALSE;

    DbgLog((LOG_TRACE, 0x7f,
	    TEXT("CBaseMSRWorker::PushLoop: fFinish %d, cQueued: %d"),
	    fFinishDelivering, cQueuedReads));

    // update our ims values?
    if(InterlockedExchange(&m_pPin->m_ilfNewImsValues, FALSE))
    {
      DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRWorker::PushLoop - values changed")));
      SetNewSelection();

      hr = NewSegmentHelper();

      if(fFinishDelivering && m_ImsValues.llTickStop > llCurrent)
      {
	DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRWorker: restarting queueing")));
	fFinishDelivering = FALSE;
      }
    }

    if(!fFinishDelivering)      // still queuing new reads?
    {
      for(;;)
      {
	hr = TryQueueSample(llCurrent, fQueuedRead, &m_ImsValues);
	if(FAILED(hr))
	{
	  DbgLog((LOG_ERROR, 5,
		  TEXT("CBaseMSRWorker::PushLoop: TryQueueSample failed %08x"),
		  hr ));
	  // supress errors when we are stopping
	  return (hr == VFW_E_NOT_COMMITTED || hr == VFW_E_WRONG_STATE) ?
	    S_OK : hr;
	}

	if(fQueuedRead)
	{
	  cQueuedReads++;
	  // MSR_INTEGER(m_perfidiSample, m_cSamples + cQueuedReads);
	}

	// this may happen if size of sample is 0. Report that we did
	// queue a read but don't increment cQueuedReads
	if(hr == S_OK /* && !fQueuedRead */ )
	  fQueuedRead = TRUE;

	if(hr == VFW_S_NO_MORE_ITEMS)
	{
	  // may or may not have queued a sample; handled above. now
	  // just continue delivering what's queued
	  fFinishDelivering = TRUE;
	  m_pReader->MarkStreamEnd(m_id);

	  // break out of inner try queue loop
	  break;
	}

	if(hr == S_FALSE)
	{
	  // could not queue sample for some non-error reason (like
	  // the queue is full)
	  ASSERT(!fQueuedRead);

	  // break out of inner try queue loop
	  break;
	}
      } // inner try queue loop

      // tried to queue a sample. even if we didn't, signal
      // NotifyStreamQueued so other threads can proceed
      NotifyStreamQueuedAndWait();

    } // we haven't queued the last sample yet

    // a chance to deliver something
    if(cQueuedReads > 0)
    {
      BOOL fDelivered, fPleaseStop;
      hr = TryDeliverSample(&fDelivered, &fPleaseStop);
      if(FAILED(hr))
      {
	ASSERT(!fDelivered);
	DbgLog((LOG_ERROR, 5,
		TEXT("CBaseMSRWorker::PushLoop: TryDeliverSample failed %08x"),
		hr ));
	// supress errors when we are stopping
	  return (hr == VFW_E_NOT_COMMITTED || hr == VFW_E_WRONG_STATE) ?
	    S_OK : hr;
      }

      if(fDelivered)
      {
	cQueuedReads--;
	fWaitedForSample = TRUE;
      }

      if(fPleaseStop)
      {
	DbgLog((LOG_TRACE, 5,
		TEXT("CBaseMSRWorker::PushLoop: TryDeliverSample request stop")));
	return hr == VFW_S_NO_MORE_ITEMS ? VFW_S_NO_MORE_ITEMS : S_OK;
      }
    }

    if(cQueuedReads == 0 && fFinishDelivering)
    {
      DbgLog((LOG_TRACE, 2,
	      TEXT("CBaseMSRWorker::PushLoop: delivered last sample")));
      // the one success condition
      return VFW_S_NO_MORE_ITEMS;
    }

    // all operations failed; block until a sample is ready.
    if(!fQueuedRead && !fWaitedForSample)
    {
      DbgLog((LOG_TRACE,5,TEXT("CBaseMSRWorker::PushLoop: blocking")));
      MSR_START(m_perfidWaitI);

      // infinite timeout.
      hr = m_pReader->WaitForSample(m_id);

      MSR_STOP(m_perfidWaitI);

      if(FAILED(hr) && hr != VFW_E_TIMEOUT)
      {
	// VFW_E_NOT_COMMITTED means that we stopped
	DbgLog((LOG_ERROR,5,
		TEXT("CBaseMSRWorker::PushLoop: block failed %08x"), hr));
	// supress errors when we are stopping
	return (hr == VFW_E_NOT_COMMITTED || hr == VFW_E_WRONG_STATE) ?
	  S_OK : hr;
      }
    }

    // any other requests ?
    Command com;
    if(CheckRequest(&com))
    {
      DbgLog((LOG_TRACE,5,
	      TEXT("CBaseMSRWorker::PushLoop: other command detected")));
      // S_FALSE means check for a new command
      return S_FALSE;
    }
  } // outer push loop

  // should never break out of the outer for(;;) loop
  DbgBreak("CBaseMSRWorker::PushLoop: internal error.");
  return E_UNEXPECTED;          // return something
}

//  Hacking MPEG time stamps - used by wave and Avi

bool FixMPEGAudioTimeStamps(
    IMediaSample *pSample,
    BOOL bFirstSample,
    const WAVEFORMATEX *pwfx
)
{
    PBYTE pbData;
    pSample->GetPointer(&pbData);
    PBYTE pbTemp = pbData;
    LONG lData = pSample->GetActualDataLength();

    //  For the first sample advance to a sync code
    if (bFirstSample) {
	while (lData >= 2 &&
	       (pbTemp[0] != 0xFF || (pbTemp[1] & 0xF0) != 0xF0)){
	    lData--;
	    pbTemp++;
	}
	if (lData < 2) {
	    return false;
	}
	if (pbTemp != pbData) {
	    memmoveInternal(pbData, pbTemp, lData);
	    pSample->SetActualDataLength(lData);
	    REFERENCE_TIME rtStart, rtStop;
	    if (S_OK == pSample->GetTime(&rtStart, &rtStop)) {
		rtStart += MulDiv((LONG)(pbTemp - pbData),
				  (LONG)UNITS,
				  pwfx->nAvgBytesPerSec);
		pSample->SetTime(&rtStart, &rtStop);
	    }
	}
    } else {
	if (lData < 2 || pbData[0] != 0xFF || (pbData[1] & 0xF0) != 0xF0) {
	    pSample->SetTime(NULL, NULL);
	    pSample->SetSyncPoint(FALSE);
	}
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\msreader\reader.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// reader.cpp: IMultiStreamReader implementations


#include <streams.h>
#include "reader.h"
#include "reccache.h"
#include "alloc.h"

#ifdef DEBUG
#define DEBUG_EX(x) x
#else
#define DEBUG_EX(x)
#endif

// try to read this much each time
const ULONG CB_MIN_RECORD = 16 * 1024;


HRESULT CreateMultiStreamReader(
  IAsyncReader *pAsyncReader,
  ULONG cStreams,
  StreamBufParam *rgStreamBufParam,
  ULONG cbRead,
  ULONG cBuffersRead,
  int iLeadingStream,
  IMultiStreamReader **ppReader)
{
  IMemAllocator *pOurAllocator = 0;
  IMemAllocator *pAllocatorActual = 0;
  CRecCache *pRecCache = 0;
  IMultiStreamReader *pReader = 0;
  *ppReader = 0;
  ULONG cbLargestSample = 0;
  UINT iStream;

  // determine which implementation of IMultiStreamReader to use

  if(cStreams >= C_STREAMS_MAX || cStreams == 0)
    return E_INVALIDARG;

  HRESULT hr = S_OK;
  pRecCache = new CRecCache(&hr);
  if(pRecCache == 0)
    hr = E_OUTOFMEMORY;
  if(FAILED(hr))
    goto Cleanup;

  hr = pRecCache->QueryInterface(IID_IMemAllocator, (void **)&pOurAllocator);
  if(FAILED(hr))
    goto Cleanup;

  for(iStream = 0; iStream < cStreams; iStream++)
    if(rgStreamBufParam[iStream].cbSampleMax > cbLargestSample)
      cbLargestSample = rgStreamBufParam[iStream].cbSampleMax;

  // suggest values for his allocator to use
  ALLOCATOR_PROPERTIES apReq;
  ZeroMemory(&apReq, sizeof(apReq));
  apReq.cbPrefix = 0;
  apReq.cbBuffer = cbLargestSample;
  apReq.cBuffers = cStreams;
  apReq.cbAlign = 1;

  // this gives us an addrefd allocator
  hr = pAsyncReader->RequestAllocator(pOurAllocator, &apReq, &pAllocatorActual);
  if(FAILED(hr))
    goto Cleanup;

  if(pAllocatorActual == pOurAllocator)
  {
    hr = S_OK;
    pReader = new CImplReader_1(
      pAsyncReader,
      cStreams,
      rgStreamBufParam,
      cbRead,
      cBuffersRead,
      iLeadingStream,
      pRecCache,
      &hr);
    if(pReader == 0)
      hr = E_OUTOFMEMORY;
    if(FAILED(hr))
      goto Cleanup;

    *ppReader = pReader;
    hr = S_OK;
  }
  else
  {
    hr = S_OK;
//     pReader = new CImplReader_2(
//       pAsyncReader,
//       &hr);

    DbgBreak("not yet implemented");
    hr = E_UNEXPECTED;
  }

  // anyone who wanted our cache / allocator has its own addref now
  pAllocatorActual->Release();
  pOurAllocator->Release();
  return hr;

Cleanup:

  if(pOurAllocator)
    pOurAllocator->Release();
  else
    delete pRecCache;

  if(pAllocatorActual)
    pAllocatorActual->Release();

  delete pReader;
  *ppReader = 0;

  return hr;
}

// number of max-sized samples from each stream in a record (eg 5
// audio and 5 video samples) if none is specified. at 15fps, this
// means 2 second buffering. at 30 fps, 1 second... that's why it
// should be specified.
const unsigned C_SAMPLES_PER_RECORD = 5;

// ------------------------------------------------------------------------
// constructor

CImplReader_1::CImplReader_1(
  IAsyncReader *pAsyncReader,
  UINT cStreams,
  StreamBufParam *rgStreamBufParam,
  ULONG cbRead,
  ULONG cBuffersRead,
  int iLeadingStream,
  CRecCache *pRecCache,
  HRESULT *phr)
{
  m_cStreams = 0;
  m_pAsyncReader = 0;
  m_llFileLength = 0;

  m_fFileOpen = FALSE;
  m_bInitialized = FALSE;
  m_bFlushing = FALSE;
  m_pRecCache = 0;
  m_rgpStreamInfo = 0;
  m_dwAlign = 0;
  m_cRecords = 0;
  m_ilcPendingReads = 0;
  m_qwLastReadEnd = 0;
  m_qwEndLastCompletedRead = 0;
  m_iLeadingStream = iLeadingStream;
  m_iLeadingStreamSaved = iLeadingStream;

  if(FAILED(*phr))
    return;

  HRESULT hr = S_OK;

  m_cStreams = cStreams;

#ifdef PERF
  m_perfidDisk = MSR_REGISTER(TEXT("read disk buffer"));
  m_perfidSeeked = MSR_REGISTER(TEXT("disk seek"));
#endif // PERF

  ULONG cbLargestSample = 0;
  ULONG cbRecord = 0, cbRecordPadded = 0;

  m_cRecords = max(cStreams, cBuffersRead);
  m_cRecords = max(m_cRecords, 2);

  // needed to configure CRecCache
  ULONG rgStreamSize[C_STREAMS_MAX];

  ALLOCATOR_PROPERTIES apActual;
  hr = pRecCache->GetProperties(&apActual);
  if(FAILED(hr))
    goto Cleanup;

  // want at least DWORD alignment so that if frames are DWORD aligned
  // in the file, they will be DWORD aligned in memory
  m_dwAlign = max(apActual.cbAlign, sizeof(DWORD));

  // data structure for maintaining read requests
  m_rgpStreamInfo = new CStreamInfo*[m_cStreams];
  if(m_rgpStreamInfo == 0)
  {
    hr = E_OUTOFMEMORY;
    goto Cleanup;
  }

  UINT iStream;
  for(iStream = 0; iStream < m_cStreams; iStream++)
    m_rgpStreamInfo[iStream] = 0;

  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    hr = S_OK;
    m_rgpStreamInfo[iStream] = new CStreamInfo(
      &rgStreamBufParam[iStream],
      &hr);
    if(m_rgpStreamInfo[iStream] == 0)
    {
      hr = E_OUTOFMEMORY;
      goto Cleanup;
    }
    if(FAILED(hr))
      goto Cleanup;

    if(rgStreamBufParam[iStream].cbSampleMax > cbLargestSample)
      cbLargestSample = rgStreamBufParam[iStream].cbSampleMax;

    rgStreamSize[iStream] = AlignUp(rgStreamBufParam[iStream].cbSampleMax) +
      m_dwAlign;
  }

  if(cbRead == 0)
  {

    // cache buffers need to be able to hold C_SAMPLES_PER_RECORD
    // samples from each stream 1) if each sample starts on a new
    // m_dwAlign boundary or 2) if that amount requires padding to an
    // extra m_dwAlign on either side.

    for(iStream = 0; iStream < m_cStreams; iStream++)
    {
      // !!! these should really add room for the RiffChunk which may be
      // what's aligned. Think about whether the rec chunk should be
      // added too
      cbRecord += rgStreamBufParam[iStream].cbSampleMax * C_SAMPLES_PER_RECORD;
      cbRecordPadded +=
        AlignUp(rgStreamBufParam[iStream].cbSampleMax) * C_SAMPLES_PER_RECORD;

      // !!! temporary solution for the REC chunk problem
      cbRecordPadded += m_dwAlign;
    }

    // 2) need at least two sectors padding in case the samples are not
    // all aligned
    if(cbRecordPadded - cbRecord < (m_dwAlign -1 ) * 2)
      cbRecordPadded = AlignUp(cbRecord + (m_dwAlign -1 ) * 2);

    if(cbRecordPadded < CB_MIN_RECORD)
      cbRecordPadded = CB_MIN_RECORD;

    m_cbRecord = cbRecordPadded;

  } // cbRead == 0
  else
  {
    if(cbRead < CB_MIN_RECORD)
      cbRead = CB_MIN_RECORD;

    // we are responsible for adding alignment on both sides of the
    // buffer.
    cbRead += m_dwAlign * 2; 
    m_cbRecord = AlignUp(cbRead);
  }

  hr = pRecCache->Configure(
    m_cRecords,
    m_cbRecord,
    m_dwAlign,
    cStreams,
    rgStreamSize                // used with reserve buffers
    );
  if(FAILED(hr))
    goto Cleanup;

  LONGLONG llTmp;
  hr = pAsyncReader->Length(&m_llFileLength, &llTmp);
  if(FAILED(hr))
    goto Cleanup;

  pAsyncReader->AddRef();
  m_pAsyncReader = pAsyncReader;

  // start/configure worker thread
  if(!m_workerRead.Create(this))
  {
    hr = E_UNEXPECTED;
    goto Cleanup;
  }

  pRecCache->AddRef();
  m_pRecCache = pRecCache;

  m_bInitialized = TRUE;
  *phr = S_OK;
  return;

Cleanup:

  m_bInitialized = FALSE;

  if(m_rgpStreamInfo)
    for(iStream = 0; iStream < m_cStreams; iStream++)
      delete m_rgpStreamInfo[iStream];
  delete[] m_rgpStreamInfo;
  m_rgpStreamInfo = 0;

  delete m_pRecCache;
  m_pRecCache = 0;

  m_cRecords = 0;
  m_cStreams = 0;

  *phr = hr;
}

CImplReader_1::~CImplReader_1()
{
  m_workerRead.Exit();

  FreeAndReset();
}

// ------------------------------------------------------------------------
// IMultiStreamReader methods

HRESULT CImplReader_1::Close()
{
  {
    CAutoLock lock(&m_cs);

    if(!m_fFileOpen)
      return S_FALSE;
    ASSERT(m_pAsyncReader);

    m_fFileOpen = FALSE;
  }

  if(m_rgpStreamInfo)
  {
    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      if(m_rgpStreamInfo[iStream])
        ClearPending(iStream);
    }
  }

  FreeAndReset();
  return S_OK;
}

HRESULT CImplReader_1::Start()
{
  // reset m_qwEndLastCompletedRead to the last successful read that
  // came in. may be zero on startup. !!! when we seek, need to update
  // this to the earliest of all streams we're playing.
  m_qwLastReadEnd = m_qwEndLastCompletedRead;

  // value changed in checkissueread
  m_iLeadingStream = m_iLeadingStreamSaved;

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    m_rgpStreamInfo[iStream]->Start();

  return m_workerRead.Run();
}

HRESULT CImplReader_1::BeginFlush()
{
  ASSERT(!m_bFlushing);
  {
      CAutoLock lck(&m_cs);
      m_bFlushing = TRUE;
  }

  DbgLog(( LOG_TRACE, 2, TEXT("CImplReader_1::BeginFlush") ));

  m_pAsyncReader->BeginFlush();
  return m_workerRead.Stop();
}

HRESULT CImplReader_1::EndFlush()
{
  ASSERT(m_bFlushing);
  DbgLog(( LOG_TRACE, 2, TEXT("CImplReader_1::EndFlush") ));

  HRESULT hr = m_pAsyncReader->EndFlush();
  m_bFlushing = FALSE;

  return hr;
}

HRESULT CImplReader_1::QueueReadSample(
  DWORDLONG fileOffset,
  ULONG cbData,
  CRecSample *pSample,
  unsigned stream,
  bool fOooOk)
{
  CAutoLock lock(&m_cs);
  if(!m_bInitialized)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplReader_1:QueueReadSample:not initialized.")));
    return E_FAIL;
  }

  if(stream >= m_cStreams)
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplReader_1::QueueReadSample stream out of range.")));
    return E_INVALIDARG;
  }

  CStreamInfo *pSi = m_rgpStreamInfo[stream];

  if(pSi->m_bFlushing)
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CImplReader_1::QueueReadSample flushing.")));
    return E_UNEXPECTED;
  }

  if(cbData > pSi->GetCbLargestSample())
  {
    DbgLog(( LOG_ERROR, 2, TEXT("CImplReader_1::Read sample large.")));

    // VFW_E_INVALID_FILE_FORMAT ?
    return VFW_E_BUFFER_OVERFLOW;
  }

  if(m_llFileLength && (LONGLONG)(fileOffset + cbData) > m_llFileLength)
    return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);

  SampleReq *pSampleReq = pSi->PromoteFirst(SampleReq::FREE);
  if(pSampleReq == 0)
  {
    DbgLog(( LOG_TRACE, 2, TEXT("CImplReader_1::QRS out of sreqs.")));
    return E_OUTOFMEMORY;
  }
  ASSERT(pSampleReq != 0);

  pSampleReq->fOooOk = fOooOk;
  
  pSampleReq->pSample = pSample;
  pSample->AddRef();
  pSampleReq->fileOffset = fileOffset;
  pSampleReq->cbReq = cbData;
  pSampleReq->stream = stream;

  DbgLog((LOG_TRACE, 0x45, TEXT("queueing %08x with %08x"),
          pSampleReq, pSample));

//   if((fileOffset + cbData > m_qwLastReadEnd + m_cbRecord) ||
//      pSi->NeedsQueued())
//   {
//     CAutoLock lock(&m_cs);
//     hr = CheckIssueRead();
//     if(FAILED(hr))
//     {
//       DbgLog((LOG_ERROR, 2,
//               TEXT("::QueueReadSample: CheckIssueRead failed.")));
//       return hr;
//     }
//   }

  return S_OK;
}

HRESULT CImplReader_1::PollForSample(
  IMediaSample **ppSample,
  unsigned stream)
{
  if(stream >= m_cStreams)
  {
    DbgBreak("CImplReader_1::PollForSample: bad stream");
    return E_INVALIDARG;
  }

  CStreamInfo *pSi = m_rgpStreamInfo[stream];
//   if(pSi->m_bFlushing)
//   {
//     DbgLog(( LOG_ERROR, 2, TEXT("CImplReader_1::PollForSample flushing.")));
//     return E_UNEXPECTED;
//   }

  if(pSi->WantsQueued())
  {
    CAutoLock lock(&m_cs);
    HRESULT hr = CheckIssueRead();
    if(FAILED(hr))
      return hr;
  }

  HRESULT hr;

  HRESULT hrSampleError;
  hr = pSi->PromoteFirstComplete(ppSample, &hrSampleError);
  if(FAILED(hr))
  {
    ASSERT(*ppSample == 0);
    return hr;
  }

  // !!! problems like this should be handled better.
  if(hrSampleError == VFW_E_TIMEOUT)
    hrSampleError = VFW_E_WRONG_STATE;

  DEBUG_EX(pSi->Dbg_Dump(stream, TEXT("PollForSample dump")));  

  return hrSampleError;
}

HRESULT CImplReader_1::WaitForSample(UINT stream)
{
 HRESULT hr = S_OK;
  CStreamInfo *pSi = m_rgpStreamInfo[stream];
  if(pSi->NeedsQueued())
  {
    CAutoLock lock(&m_cs);
    hr = CheckIssueRead();
    if(FAILED(hr))
      return hr;
  }

  DEBUG_EX(ULONG cLoopDbg = 0);

  while(!pSi->get_c_i_and_c())
  {
    DEBUG_EX(if(++cLoopDbg > 200) DbgBreak("possible spin"));

    // block until downstream filter releases a sample. Another stream
    // may issue a sample, so wait on completed samples as well
    HANDLE rghs[2];
    rghs[0] = m_rgpStreamInfo[stream]->m_hsCompletedReq;
    rghs[1] = pSi->GetSampleReleasedHandle();

    // will return because downstream filters must eventually release
    // buffers. (behaves like GetBuffer on allocator)
    DWORD dw = WaitForMultipleObjects(2, rghs, FALSE, INFINITE);
    ASSERT(dw < WAIT_OBJECT_0 + 2);

    if(dw == WAIT_OBJECT_0) {
        EXECUTE_ASSERT(ReleaseSemaphore(rghs[0], 1, 0));
    }

    DbgLog(( LOG_TRACE, 5,
             TEXT("::WaitForSample: unblocked because %s"),
             (dw - WAIT_OBJECT_0 == 0) ?
             TEXT("sample completed") :
             TEXT("sample released")));

    // Lock must be held while calling CheckIssueRead
    CAutoLock lck(&m_cs);
    hr = CheckIssueRead();
    if(FAILED(hr))
      return hr;
  }

  DWORD dw = WaitForSingleObject(
    m_rgpStreamInfo[stream]->m_hsCompletedReq,
    INFINITE);

  ASSERT(dw == WAIT_OBJECT_0);
  EXECUTE_ASSERT(ReleaseSemaphore(
    m_rgpStreamInfo[stream]->m_hsCompletedReq,
    1,
    0));
  return S_OK;
}

HRESULT CImplReader_1::MarkStreamEnd(UINT stream)
{
  CStreamInfo *pSi = m_rgpStreamInfo[stream];
  pSi->MarkStreamEnd();
  return S_OK;
}

HRESULT CImplReader_1::MarkStreamRestart(UINT stream)
{
  CStreamInfo *pSi = m_rgpStreamInfo[stream];
  pSi->MarkStreamRestart();
  return S_OK;
}

// the caller is reqiured not to be queueing new reads on this stream
// or waiting for completed reads on this stream.
HRESULT CImplReader_1::ClearPending(
  unsigned stream)
{
  HRESULT hr = S_OK;
  CStreamInfo *pSi = m_rgpStreamInfo[stream];

  // remove all samplereqs in state PENDING so that they cannot be
  // issued while flushing. this leaves the array in an inconsistent
  // state, reset later.

  {
    CAutoLock lock(&m_cs);

    if(pSi->m_bFlushing)
      return E_UNEXPECTED;
    pSi->m_bFlushing = TRUE;

    // PENDING reqs always accessed with m_cs locked, so this is safe
    pSi->CancelPending();
    ASSERT(pSi->GetCState(SampleReq::PENDING) == 0);
  }

  // handle all those that are complete.
  while(pSi->get_c_i_and_c())
  {
    hr = WaitForSample(stream);
    ASSERT(SUCCEEDED(hr));

    IMediaSample *pSample = 0;
    hr = PollForSample(&pSample, stream);
    if(SUCCEEDED(hr))
    {
      ASSERT(pSample);
      pSample->Release();
    }
    else
    {
      ASSERT(!pSample);
    }
  }

  ASSERT(pSi->GetCState(SampleReq::COMPLETE) == 0);
  ASSERT(pSi->GetCState(SampleReq::ISSUED) == 0);
  ASSERT(pSi->GetCState(SampleReq::PENDING) == 0);

  // this reset is necessary because removing the PENDING requests
  // without promoting them through ISSUED, COMPLETE puts the array
  // in CStreamInfo in an inconsistent state.
  pSi->Reset();

  pSi->m_bFlushing = FALSE;

  return hr;
}

HRESULT CImplReader_1::SynchronousRead(
  BYTE *pb,
  DWORDLONG fileOffset,
  ULONG cbData)
{
  return m_pAsyncReader->SyncRead(fileOffset, cbData, pb);
}

// ------------------------------------------------------------------------
// helpers

ULONG CImplReader_1::AlignUp(ULONG x)
{
  if(x % m_dwAlign != 0)
    x += m_dwAlign - x % m_dwAlign;
  return x;
}

ULONG CImplReader_1::AlignDown(ULONG x)
{
  if(x % m_dwAlign != 0)
    x -= x % m_dwAlign;
  return x;
}

// ------------------------------------------------------------------------
// extract samples from the cache buffer. the buffer may not have been
// issued (on a failed Read Request)

HRESULT
CImplReader_1::ProcessCompletedBuffer(
  CRecBuffer *pRecBuffer,
  HRESULT hrReadError)
{
  HRESULT hr;
  SampleReq *pSampleReq;

  ASSERT(CritCheckIn(&m_cs));

  if(SUCCEEDED(hrReadError))
  {
    ASSERT(pRecBuffer->m_fReadComplete);
    ASSERT(!pRecBuffer->m_fWaitingOnBuffer);
  }

  if(SUCCEEDED(pRecBuffer->m_hrRead))
    pRecBuffer->m_hrRead = hrReadError;

  // if this buffer is waiting on another, it has a refcount on us, so
  // let it process us.
  if(pRecBuffer->m_fWaitingOnBuffer)
    return S_OK;


  // make sure a buffer waiting on us sees an error. !!! is this done
  // in the caller?
  if(pRecBuffer->m_overlap.pBuffer &&
     SUCCEEDED(pRecBuffer->m_overlap.pBuffer->m_hrRead))
    pRecBuffer->m_overlap.pBuffer->m_hrRead = hrReadError;

  if(pRecBuffer->m_hrRead == S_OK)
    pRecBuffer->MarkValid();
  else
    pRecBuffer->MarkValidWithFileError();

  while(pSampleReq = pRecBuffer->sampleReqList.RemoveHead(),
        pSampleReq)
  {
    pSampleReq->hrError = pRecBuffer->m_hrRead;
    ASSERT(pSampleReq->state == SampleReq::ISSUED);
    hr = m_rgpStreamInfo[pSampleReq->stream]->
      PromoteIssued(pSampleReq);
    ASSERT(SUCCEEDED(hr));
  }
  ASSERT(pRecBuffer->sampleReqList.GetCount() == 0);

  return S_OK;
}

HRESULT
CImplReader_1:: NotifyExternalMemory(
    IAMDevMemoryAllocator *pDevMem)
{
    return m_pRecCache->NotifyExternalMemory(pDevMem);
}

HRESULT CImplReader_1::CheckIssueRead()
{
  HRESULT hr;
  DWORDLONG recStart, recEnd;
  ASSERT(CritCheckIn(&m_cs));
  if (m_bFlushing) {
      return VFW_E_WRONG_STATE;
  }

  // if the leading stream has queued all it's going to queue, exit
  // Interleaved mode.
  if(IsInterleavedMode() && m_rgpStreamInfo[m_iLeadingStream]->GetStreamEnd())
  {
    DbgLog((LOG_TRACE, 5,
            TEXT("CImplReader_1::CheckIssueRead: leaving interleaved mode" )));
    // reset in ::Start
    m_iLeadingStream = -1;
  }

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    while(ProcessCacheHit(iStream) == S_OK)
      ;
  }

  UINT iStarvedStream;
  CRecBuffer *pRecBuffer;

  for(;;)
  {
    CStreamInfo *pSi = 0;
    for(UINT i = 0; i < m_cStreams; i++)
    {
      if(IsInterleavedMode())
      {
        iStarvedStream = (i + m_iLeadingStream) % m_cStreams;
      }
      else
      {
        iStarvedStream = i;
      }
              
      pSi = m_rgpStreamInfo[iStarvedStream];
      if(pSi->WantsQueued())
        break;
    }
    if(i == m_cStreams)
    {
      break;
    }

    hr = m_pRecCache->GetBuffer(&pRecBuffer);
    if(FAILED(hr))
    {
      DbgLog((LOG_TRACE, 0x3f, TEXT("CheckIssueRead: couldnt get a buffer")));
      break;
    }

    DbgLog(( LOG_TRACE, 5, TEXT("CImplReader_1::CheckIssueRead: stream %i"),
             iStarvedStream ));
    DEBUG_EX(pSi->Dbg_Dump(iStarvedStream, TEXT("CIRead dump")));

    ASSERT((*pRecBuffer)() != 0);
    DbgLog(( LOG_TRACE, 15,
             TEXT("CImplReader_1::CIRead: Got Buffer %08x"), pRecBuffer));
    recStart = recEnd = 0;
    hr = StuffBuffer(pRecBuffer, iStarvedStream, recStart, recEnd);
    if(FAILED(hr))
    {
      DbgBreak("unexpected");
      pRecBuffer->Release();
      return hr;
    }

    ASSERT(pRecBuffer->sampleReqList.GetCount() != 0);

    hr = IssueRead(pRecBuffer, recStart, recEnd);
    pRecBuffer->Release();
    if(FAILED(hr))
      return hr;
  }

  //
  // try a reserve buffer now.
  //

  for(iStarvedStream = 0; iStarvedStream < m_cStreams; iStarvedStream++)
  {
    CStreamInfo *pSi = m_rgpStreamInfo[iStarvedStream];
    if(!pSi->NeedsQueued())
      continue;


    // see if we can get a reserve buffer for this stream
    hr = m_pRecCache->GetReserveBuffer(&pRecBuffer, iStarvedStream);
    if(SUCCEEDED(hr))
    {
      DbgLog(( LOG_TRACE, 15,
               TEXT("CImplReader_1::CIRead: Got Reserve Buf %08x"),
               pRecBuffer));
      recStart = recEnd = 0;

      // queue only the starved stream in this buffer
      hr = StuffReserveBuffer(pRecBuffer, iStarvedStream, recStart, recEnd);
      if(FAILED(hr))
      {
        DbgBreak("unexpected");
        pRecBuffer->Release();
        return hr;
      }

      // at least the first starved sample on this stream in the list
      ASSERT(pRecBuffer->sampleReqList.GetCount() != 0);
      hr = IssueRead(pRecBuffer, recStart, recEnd);
      pRecBuffer->Release();
      if(FAILED(hr))
        return hr;

      continue;
    }
    else if(hr == E_OUTOFMEMORY)
    {
      DbgLog(( LOG_TRACE, 15,
               TEXT("CImplReader_1::CIRead: couldnt get reserve buffer")));

      // could not get a buffer. try the next starved stream
      continue;
    }
    else
    {
      // unknown from GetBuffer / unhandled error
      return hr;
    }
  }

  // all starved streams examined
  return S_OK;
}

HRESULT CImplReader_1::IssueRead(
  CRecBuffer *pRecBuffer,
  DWORDLONG recStart,
  DWORDLONG recEnd)
{
  // extra to read (from sector start to first byte we want)
  ULONG cbLeading = (ULONG)(recStart % m_dwAlign);

  // sector aligned amount to read
  ULONG cbRead = AlignUp(ULONG(recEnd - recStart) + cbLeading);

  // amount at front that overlaps with another buffer
  ULONG cbBytesToSkip = 0;

  DWORDLONG recStartReading = recStart - cbLeading;

  pRecBuffer->m_fileOffsetValid = recStart - cbLeading;
  pRecBuffer->m_cbValid = cbRead;
  pRecBuffer->m_fWaitingOnBuffer = FALSE;
  pRecBuffer->m_fReadComplete = FALSE;
  pRecBuffer->m_hrRead = S_OK;

// #if (DEBUG > 1)
//   FillMemory((*pRecBuffer)(), pRecBuffer->GetSize(), 0xcd);
// #endif // DEBUG > 1

  ZeroMemory(&pRecBuffer->m_overlap, sizeof(pRecBuffer->m_overlap));

  if(m_dwAlign > 1)
  {
    CRecBuffer *pCacheBuffer;
    HRESULT hr = m_pRecCache->GetOverlappedCacheHit(
      recStart - cbLeading,
      m_dwAlign,
      &pCacheBuffer);
    if(hr == S_OK)
    {
      if(pCacheBuffer->GetState() == CRecBuffer::VALID_ACTIVE ||
         pCacheBuffer->GetState() == CRecBuffer::VALID_INACTIVE)
      {
        DbgLog(( LOG_TRACE, 5,
                 TEXT("CImplReader_1::IssueRead: overlap hit, active %08x@%08x"),
                 pCacheBuffer,
                 (ULONG)recStart ));

        CopyMemory(
          (*pRecBuffer)(),
          pCacheBuffer->GetPointer(recStartReading),
          m_dwAlign);

        recStartReading += m_dwAlign;
        cbRead -= m_dwAlign;
        cbBytesToSkip = m_dwAlign;
      }
      else
      {
        ASSERT(pCacheBuffer->GetState() == CRecBuffer::PENDING);
        DbgLog(( LOG_TRACE, 5,
                 TEXT("CImplReader_1::IssueRead: overlap hit, pending %08x@%08x"),
                 pCacheBuffer,
                 (ULONG)recStart ));

        if(pCacheBuffer->m_overlap.pBuffer == 0)
        {
          pRecBuffer->m_fWaitingOnBuffer = TRUE;
          pRecBuffer->AddRef();
          pCacheBuffer->m_overlap.pBuffer = pRecBuffer;
          pCacheBuffer->m_overlap.qwOverlapOffset = recStartReading;
          pCacheBuffer->m_overlap.cbOverlap = m_dwAlign;

          recStartReading += m_dwAlign;
          cbRead -= m_dwAlign;
          cbBytesToSkip = m_dwAlign;
        }
        else
        {
          DbgLog(( LOG_TRACE, 5,
                   TEXT("CImplReader_1::IssueRead: buffer already has one") ));
        }
      }

      pCacheBuffer->Release();
    } // hr == s_OK
  } // m_dwAlign > 1

  // configure the request through IAsyncReader
  LONGLONG tStartThis = recStartReading * UNITS;
  LONGLONG tStopThis = (recStartReading + cbRead) * UNITS;
  pRecBuffer->m_sample.SetTime(&tStartThis, &tStopThis);
  pRecBuffer->m_sample.SetPointer((*pRecBuffer)() + cbBytesToSkip, cbRead);

  BOOL fSeeked = (recStartReading != m_qwLastReadEnd);

  // doesn't handle playing backwards !!!
  m_qwLastReadEnd = recStartReading + cbRead;

  ASSERT((*pRecBuffer)() != 0);
  ASSERT((tStopThis - tStartThis) / UNITS <= pRecBuffer->GetSize());

  // configure all samples in this record with pointers to the data
  POSITION pos = pRecBuffer->sampleReqList.GetHeadPosition();
  ULONG cSample =0;
  while(pos != 0)
  {
    SampleReq *pSampleReq = pRecBuffer->sampleReqList.Get(pos);

    pSampleReq->pSample->SetPointer(
      pRecBuffer->GetPointer(pSampleReq->fileOffset),
      pSampleReq->cbReq);

    pos = pRecBuffer->sampleReqList.Next(pos);
    cSample++;
  }

  DbgLog(( LOG_TRACE, 2,
           TEXT("CImplReader_1::CIRead issue (%x%c%x) = %08x, cSample: %d, b: %x"),
           (DWORD)(tStartThis / UNITS),
           fSeeked ? 'X' : '-',
           (DWORD)(tStopThis / UNITS),
            (DWORD)((tStopThis - tStartThis) / UNITS),
           cSample,
           pRecBuffer));
  if(fSeeked)
    MSR_NOTE(m_perfidSeeked);

  // IAsyncReader does not know to addref the buffer
  pRecBuffer->AddRef();

  ASSERT(!m_bFlushing);
  pRecBuffer->MarkPending();
  InterlockedIncrement(&m_ilcPendingReads);

  MSR_INTEGER(m_perfidDisk, (long)(tStartThis / UNITS));
  HRESULT hr;
  hr = m_pAsyncReader->Request(
    &pRecBuffer->m_sample,
    (DWORD_PTR)pRecBuffer);

  if(FAILED(hr))
  {
    DbgLog(( LOG_ERROR, 2,
             TEXT("CImplReader_1::Issue: Request failed. %08x."), hr));
    InterlockedDecrement(&m_ilcPendingReads);
    pRecBuffer->m_fReadComplete = TRUE;
    ProcessCompletedBuffer(pRecBuffer, hr);

    // never set because the cache is still locked
    ASSERT(!pRecBuffer->m_overlap.pBuffer);
    pRecBuffer->Release();
    return hr;
  }

  return S_OK;
}

HRESULT CImplReader_1::StuffReserveBuffer(
  class CRecBuffer *pRecBuffer,
  UINT iStarvedStream,
  DWORDLONG &rRecStart,
  DWORDLONG &rRecEnd)
{
  ASSERT(rRecStart == 0 && rRecEnd == 0);
  HRESULT hr;

  hr = AttachSampleReq(
    pRecBuffer,
    iStarvedStream,
    rRecStart,
    rRecEnd);

  if(FAILED(hr))
      return hr;

  // called with starved stream. must be able to attach first pending
  // sample to empty buffer
  ASSERT(hr == S_OK);

  for(;;)
  {
    hr = AttachSampleReq(
      pRecBuffer,
      iStarvedStream,
      rRecStart,
      rRecEnd);

    if(FAILED(hr))
      return hr;

    if(hr == S_FALSE)
      break;
  }

  return S_OK;
}

HRESULT CImplReader_1::StuffBuffer(
  class CRecBuffer *pRecBuffer,
  UINT iStarvedStream,
  DWORDLONG &rRecStart,
  DWORDLONG &rRecEnd)
{
  ASSERT(rRecStart == 0 && rRecEnd == 0);
  HRESULT hr;

  hr = AttachSampleReq(
    pRecBuffer,
    iStarvedStream,
    rRecStart,
    rRecEnd);

  if(FAILED(hr))
      return hr;

  // called with starved stream. must be able to attach first pending
  // sample to empty buffer
  ASSERT(hr == S_OK);

  // see if that sample left a hole which we can fill in. we have to
  // go back an extra m_dwAlign to handle a read which was not yet
  // requested but results in no buffers containing the entire data.
  DWORDLONG qwStartTarget;
  if(m_qwLastReadEnd < m_dwAlign)
  {
    qwStartTarget = 0;
  }
  else
  {
    qwStartTarget = m_qwLastReadEnd - (m_dwAlign == 1 ? 0 : m_dwAlign);
  }

  // different rules for interleaved files:
  if(IsInterleavedMode())
  {
    // got one sample in the buffer; now use the rest of the
    // buffer to fill in the hole.
    if(rRecStart > qwStartTarget &&
       rRecStart - qwStartTarget < m_cbRecord)
    {
      if(rRecEnd - qwStartTarget <= pRecBuffer->GetSize())
      {
        DbgLog(( LOG_TRACE, 5, TEXT("removed seek from %08x to %08x"),
                 (ULONG)m_qwLastReadEnd,
                 (ULONG)rRecStart ));
        rRecStart = qwStartTarget;
      }
    }
  }
  else
  {
    // leave some room at the end.
    if(rRecStart > qwStartTarget &&
       rRecStart - qwStartTarget < m_cbRecord / 4 * 3)
    {
      if(rRecEnd - qwStartTarget <= pRecBuffer->GetSize() - m_dwAlign * 2)
      {
        DbgLog(( LOG_TRACE, 5, TEXT("removed seek from %08x to %08x"),
                 (ULONG)m_qwLastReadEnd,
                 (ULONG)rRecStart ));
        rRecStart = qwStartTarget;
      }
    }
  }

  // stuff whatever more we can into this buffer so they don't have to
  // rely on cache hits.
  for(;;)
  {
    BOOL fAttachedSample = FALSE;

    for(UINT iStream = 0; iStream < m_cStreams; iStream++)
    {
      hr = AttachSampleReq(
        pRecBuffer,
        iStream,
        rRecStart,
        rRecEnd);

      if(FAILED(hr))
          return hr;

      if(hr == S_OK)
        fAttachedSample = TRUE;

      ASSERT(SUCCEEDED(hr));
    }

    // no stream could contribute.
    if(!fAttachedSample)
      break;
  }

  return S_OK;
}

//
// process the first cache hit for this stream
//

HRESULT CImplReader_1::ProcessCacheHit(UINT iStream)
{
  ASSERT(CritCheckIn(&m_cs));

  HRESULT hr;
  CStreamInfo *pSi = m_rgpStreamInfo[iStream];

  SampleReq *pSampleReq = pSi->GetFirst(SampleReq::PENDING);
  if(!pSampleReq)
    return S_FALSE;

  CRecBuffer *pBuffer;
  hr = m_pRecCache->GetCacheHit(pSampleReq, &pBuffer);
  if(hr != S_OK)
    return S_FALSE;

  // this addref's the buffer
  pSampleReq->pSample->SetParent(pBuffer);

  pSampleReq->pSample->SetPointer(
    pBuffer->GetPointer(pSampleReq->fileOffset),
    pSampleReq->cbReq);

  DbgLog(( LOG_TRACE, 5, TEXT("cache hit stream %d, %08x"),
           iStream,
           (ULONG)pSampleReq->fileOffset));

  // remove our refcount from GetCacheHit, rely on the one from the
  // SetParent call
  pBuffer->Release();

  if(pBuffer->GetState() == CRecBuffer::PENDING)
  {
    // make SampleReq ISSUED.  m_cs is locked by the caller, so we
    // can safely let ProcessCompletedRead take care of the
    // SampleReq

    SampleReq *pSrHit = pSi->PromoteFirst(SampleReq::PENDING);
    ASSERT(pSrHit == pSampleReq);
  }
  else
  {
    // make SampleReq PENDING->ISSUED->COMPLETE. m_cs must be locked
    // by the caller.

    SampleReq *pSrHit = pSi->PromoteFirst(SampleReq::PENDING);
    pSrHit->hrError = S_OK;
    ASSERT(pSrHit == pSampleReq);

    // this complete occurs out of order
    pSi->PromoteIssued(pSrHit);
  }

  return S_OK;
}

HRESULT CImplReader_1::AttachSampleReq(
  CRecBuffer *pRecBuffer,
  UINT iStream,
  DWORDLONG &rRecStart,
  DWORDLONG &rRecEnd)
{
  if(ProcessCacheHit(iStream) == S_OK)
    return S_OK;

  CStreamInfo *pSi = m_rgpStreamInfo[iStream];
  SampleReq *pSampleReq;

  pSampleReq = pSi->GetFirst(SampleReq::PENDING);
  if(pSampleReq == 0)
    return S_FALSE;

  ASSERT(pSi->GetCState(SampleReq::PENDING) != 0);
  ASSERT(pSampleReq->cbReq <= pRecBuffer->GetSize());

  // will sample req fit into the record?
  if(rRecStart == 0 && rRecEnd == 0)
  {
    rRecStart = pSampleReq->fileOffset;
    rRecEnd = rRecStart + pSampleReq->cbReq;
    ASSERT(rRecEnd - rRecStart <= pRecBuffer->GetSize() - m_dwAlign);
  }
  else if(max((pSampleReq->fileOffset + pSampleReq->cbReq), rRecEnd ) -
          min((pSampleReq->fileOffset), rRecStart) <
          pRecBuffer->GetSize() - 2 * m_dwAlign)
  {
    rRecStart = min((pSampleReq->fileOffset), rRecStart);
    rRecEnd = max((pSampleReq->fileOffset + pSampleReq->cbReq), rRecEnd );
  }
  else
  {
    pSampleReq = 0;
  }

  if(pSampleReq != 0)
  {
    // this samplereq fit.
    SampleReq *pSampleReq2 = pSi->PromoteFirst(SampleReq::PENDING);
    ASSERT(pSampleReq2 == pSampleReq);

    if(!pRecBuffer->sampleReqList.AddTail(pSampleReq))
        return E_OUTOFMEMORY;
    
    pSampleReq->pSample->SetParent(pRecBuffer);

    DbgLog(( LOG_TRACE, 15,
             TEXT("CImplReader_1::AttachSampleReq attached %08x, stream %d" ),
             (ULONG)pSampleReq->fileOffset, iStream));

    return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}

// ------------------------------------------------------------------------


CImplReader_1::CStreamInfo::CStreamInfo(
  StreamBufParam *pSbp,
  HRESULT *phr) :
        m_cMaxReqs(pSbp->cSamplesMax),
        m_lstFree(NAME("parser free list"), m_cMaxReqs),
        m_lstPending(NAME("parser pending list"), m_cMaxReqs),
        m_lstIssued(NAME("parser issued list"), m_cMaxReqs),
        m_lstComplete(NAME("parser complete list"), m_cMaxReqs),
        m_rgSampleReq(0)
{
  m_sbp.pAllocator = 0;
  m_bFlushing = FALSE;
  m_bFirstSampleQueued = FALSE;
  m_hsCompletedReq = 0;

  if(FAILED(*phr))
    return;

  m_sbp = *pSbp;
  pSbp->pAllocator->AddRef();

  m_rgSampleReq = new SampleReq[m_cMaxReqs];
  if(m_rgSampleReq == 0)
  {
    *phr = E_OUTOFMEMORY;
    return;
  }

  m_bFlushing = FALSE;
  m_hsCompletedReq = CreateSemaphore(
    0,                          // lpSemaphoreAttributes
    0,                          // lInitialCount
    m_cMaxReqs,                 // lMaximumCount
    0);                         // lpName
  if(m_hsCompletedReq == 0)
  {
    *phr = AmHresultFromWin32(GetLastError());
    return;
  }

  // no list operations should allocate memory because we never exceed
  // the number of elements with which the list was initialized --
  // don't check failures. we have to build the node cache now to
  // accomplish this
  for(unsigned iReq = 0; iReq < m_cMaxReqs; iReq++)
  {
    m_rgSampleReq[iReq].state = SampleReq::FREE;

    if(!(m_lstFree.AddHead(&m_rgSampleReq[iReq]) &&
         m_lstPending.AddHead((SampleReq *)0) &&
         m_lstIssued.AddHead((SampleReq *)0) &&
         m_lstComplete.AddHead((SampleReq *)0)))
    {
      *phr = E_OUTOFMEMORY;
      return;
    }
  }

  m_lstPending.RemoveAll();
  m_lstIssued.RemoveAll();
  m_lstComplete.RemoveAll();

  m_rgpLsts[SampleReq::FREE] = &m_lstFree;
  m_rgpLsts[SampleReq::PENDING] = &m_lstPending;
  m_rgpLsts[SampleReq::ISSUED] = &m_lstIssued;
  m_rgpLsts[SampleReq::COMPLETE] = &m_lstComplete;

  DbgValidateLists();
}

CImplReader_1::CStreamInfo::~CStreamInfo()
{
  DbgValidateLists();

  ASSERT(m_lstFree.GetCount() == (LONG)m_cMaxReqs);

#ifdef DEBUG
  for(unsigned iReq = 0; iReq < m_cMaxReqs; iReq ++)
    ASSERT(m_rgSampleReq[iReq].state == SampleReq::FREE);
#endif

  delete[] m_rgSampleReq;

  CloseHandle(m_hsCompletedReq);

  if(m_sbp.pAllocator)
      m_sbp.pAllocator->Release();
}

SampleReq *CImplReader_1::CStreamInfo::PromoteFirst(SampleReq::State state)
{
  CAutoLock lock(&m_cs);
  DbgValidateLists();

  ASSERT(state == SampleReq::PENDING || state == SampleReq::FREE);

  SampleReq *pSampleReq = m_rgpLsts[state]->RemoveHead();
  if(pSampleReq)
  {
      m_rgpLsts[state + 1]->AddTail(pSampleReq);
      PromoteState(pSampleReq->state);
  }
  
  return pSampleReq;
}



HRESULT CImplReader_1::CStreamInfo::PromoteFirstComplete(
  IMediaSample **ppSample, HRESULT *phrError)
{
  *ppSample = 0;
  *phrError = E_FAIL;

  CAutoLock lock(&m_cs);

  DbgValidateLists();
  
  SampleReq *pSampleReq = m_lstComplete.RemoveHead();
  if(pSampleReq)
  {
    EXECUTE_ASSERT(WaitForSingleObject(m_hsCompletedReq, 0) == WAIT_OBJECT_0);

    DbgLog(( LOG_TRACE, 10,
             TEXT("PromoteFirstComplete: promoted %x sem %08x"),
             pSampleReq, m_hsCompletedReq));

    m_lstFree.AddTail(pSampleReq);
    pSampleReq->state = SampleReq::FREE;

    if(FAILED(pSampleReq->hrError))
    {
        pSampleReq->pSample->Release();
        *ppSample = 0;
    }
    else
    {
        *ppSample = pSampleReq->pSample;
    }
    *phrError = pSampleReq->hrError;
  }
  else
  {
    return VFW_E_TIMEOUT;
  }

  DbgValidateLists();

  return S_OK;
}

// wait for all issued reads
HRESULT CImplReader_1::CStreamInfo::FlushIC()
{
  while(get_c_i_and_c() > 0)
  {
    IMediaSample *pSample;
    HRESULT hrSample;
    HRESULT hr = PromoteFirstComplete(&pSample, &hrSample);

    if(SUCCEEDED(hr) && SUCCEEDED(hrSample))
      ASSERT(pSample);

    if(pSample)
      pSample->Release();
  }

  return S_OK;
}

// mark issued reqs complete. only do this if it's the first in the
// list because we want things to complete in order. when the first
// one is completed, completed reads after it are moved to the
// completed queue. things marked with fOooOk are moved out of order.

HRESULT CImplReader_1::CStreamInfo::PromoteIssued(SampleReq *pSampleReq)
{
  CAutoLock lock(&m_cs);
  ASSERT(pSampleReq->state == SampleReq::ISSUED);

  SampleReq *psrFirstIssued = m_lstIssued.GetHead();
  ASSERT(pSampleReq->stream == psrFirstIssued->stream);

  pSampleReq->state = SampleReq::COMPLETE;

  if(psrFirstIssued != pSampleReq && !pSampleReq->fOooOk)
  {
    // not first and must be completed in order.
    DbgLog(( LOG_TRACE, 10,
             TEXT("PromoteIssued: completed %08x ooo"), pSampleReq));
    return S_FALSE;
  }
  else if(pSampleReq->fOooOk)
  {
    POSITION posOoo = m_lstIssued.Find(pSampleReq); // linear search
    ASSERT(posOoo);
    m_lstIssued.Remove(posOoo);
    m_lstComplete.AddHead(pSampleReq);

    long lPrevCount = -1;
    EXECUTE_ASSERT(ReleaseSemaphore(m_hsCompletedReq, 1, &lPrevCount));
    DbgLog(( LOG_TRACE, 10,
             TEXT("PromoteIssued: completed ooo %08x on %d sem %08x = %d"),
             pSampleReq, pSampleReq->stream, m_hsCompletedReq, lPrevCount + 1));

    
    return S_OK;
  }
  else
  {
    // first one completed

    do
    {
      // handle ooo issued nodes
      EXECUTE_ASSERT(psrFirstIssued == m_lstIssued.RemoveHead());
      
      m_lstComplete.AddTail(psrFirstIssued);

      long lPrevCount = -1;
      EXECUTE_ASSERT(ReleaseSemaphore(m_hsCompletedReq, 1, &lPrevCount));
      DbgLog(( LOG_TRACE, 10,
               TEXT("PromoteIssued: completed %08x on %d sem %08x = %d"),
               psrFirstIssued, pSampleReq->stream, m_hsCompletedReq, lPrevCount + 1));

      psrFirstIssued = m_lstIssued.GetHead();
      
    } while (psrFirstIssued &&
             psrFirstIssued->state == SampleReq::COMPLETE);

    return S_OK;
  }
}


SampleReq *CImplReader_1::CStreamInfo::GetFirst(SampleReq::State state)
{
  CAutoLock lock(&m_cs);
  DbgValidateLists();
  
  return m_rgpLsts[state]->GetHead();
}

void
CImplReader_1::CStreamInfo::PromoteState(
  SampleReq::State &rState)
{
  switch(rState)
  {
    case SampleReq::FREE:
      rState = SampleReq::PENDING;
      break;

    case SampleReq::PENDING:
      ASSERT(!m_bFlushing);
      rState = SampleReq::ISSUED;
      break;

    case SampleReq::ISSUED:
      rState = SampleReq::COMPLETE;
      break;

    case SampleReq::COMPLETE:
      rState = SampleReq::FREE;
      break;

    default:
      DbgBreak("invalid statew");
  }


  DbgValidateLists();
}

ULONG
CImplReader_1::CStreamInfo::GetCState(
  SampleReq::State state)
{
  return m_rgpLsts[state]->GetCount();
}

ULONG
CImplReader_1::CStreamInfo::get_c_i_and_c()
{
  CAutoLock lock(&m_cs);
  return GetCState(SampleReq::ISSUED) + GetCState(SampleReq::COMPLETE);
}

void CImplReader_1::CStreamInfo::CancelPending()
{
  CAutoLock lock(&m_cs);
  for(SampleReq *psr; psr = m_lstPending.RemoveHead();)
  {
    psr->state = SampleReq::FREE;
    psr->pSample->Release();
    psr->pSample = 0;
    m_lstFree.AddTail(psr);
  }

  DbgValidateLists();
}

// ------------------------------------------------------------------------
// should we go out of our way to read data for this stream (is it
// starved?)
BOOL
CImplReader_1::CStreamInfo::NeedsQueued()
{
  CAutoLock lock(&m_cs);

  ULONG c_i_and_c = GetCState(SampleReq::ISSUED) + GetCState(SampleReq::COMPLETE);

//   DbgLog((LOG_TRACE, 0x3f,
//           TEXT("CImplReader_1::NeedsQueued stream %x: %d samples downstream"),
//           this, m_pRecAllocator->CSamplesDownstream() ));

  return (m_sbp.pAllocator->CSamplesDownstream() == 0) &&
      (GetCState(SampleReq::PENDING) != 0) &&
       (c_i_and_c < 1);
}

BOOL
CImplReader_1::CStreamInfo::WantsQueued()
{
  CAutoLock lock(&m_cs);

  BOOL fRetVal = FALSE;

  // something to read. we want to issue reads for free samples too
  // because it may mean new reads could not be queued because the pin
  // is waiting for an index to come in.
  ULONG cPending = GetCState(SampleReq::PENDING);
  ULONG cPendingOrFree = cPending + GetCState(SampleReq::FREE);

  if(cPending == 0)
    fRetVal = FALSE;
  else if(cPendingOrFree >= m_cMaxReqs / 4)
    fRetVal = TRUE;
  else if(m_fStreamEnd)
    fRetVal = TRUE;

  return fRetVal;
}

// output something like this
// AVIRDR.DLL(tid dd) : : 222222222222222221111111111111111
// AVIRDR.DLL(tid dd) : : p: 17,47, i: 0,17, c: 0,0, f: 0,0
//
#ifdef DEBUG

void CImplReader_1::CStreamInfo::Dbg_Dump(
  int iStream, 
  TCHAR *sz)
{

  CAutoLock lock(&m_cs);

  static const char rgc[] = "fpic";

  TCHAR szDbg[1024];
  TCHAR *pch = szDbg;
  for(unsigned i = 0; i < m_cMaxReqs; i++)
    *pch++ = rgc[m_rgSampleReq[i].state];
  *pch = 0;

  DbgLog(( LOG_TRACE, 5, TEXT("%02x, %20.20s: %s"), iStream, sz, szDbg));
  DbgLog(( LOG_TRACE, 5,
           TEXT("%s: p: %2i, i: %2i c: %2i, f: %2i"), sz,
           GetCState(SampleReq::PENDING),
           GetCState(SampleReq::ISSUED),
           GetCState(SampleReq::COMPLETE),
           GetCState(SampleReq::FREE)));
}

void CImplReader_1::CStreamInfo::DbgValidateLists()
{
  CAutoLock lock(&m_cs);

  ASSERT(m_lstFree.GetCount() + m_lstPending.GetCount() +       
         m_lstIssued.GetCount() + m_lstComplete.GetCount() ==   
         (LONG)m_cMaxReqs);

  for(int i = 0; i < 4; i++)
  {
    CGenericList<SampleReq> *pLst = m_rgpLsts[i];

    for(POSITION pos = pLst->GetHeadPosition();
        pos;
        pos = pLst->Next(pos))
    {
      if(i == SampleReq::ISSUED)
      {
        ASSERT(pLst->Get(pos)->state == i ||
               pLst->Get(pos)->state == i + 1);
      }
      else
      {
        ASSERT(pLst->Get(pos)->state == i);
      }
    }
  }
}

#endif // DEBUG



void CImplReader_1::CStreamInfo::Reset()
{
#ifdef DEBUG
  CAutoLock lock(&m_cs);

  ASSERT(GetCState(SampleReq::FREE) == m_cMaxReqs);

  DbgValidateLists();
#endif
}

void CImplReader_1::CStreamInfo::Start()
{
  ASSERT(GetCState(SampleReq::COMPLETE) == 0);
  ASSERT(GetCState(SampleReq::ISSUED) == 0);
  ASSERT(GetCState(SampleReq::PENDING) == 0);
  ASSERT(GetCState(SampleReq::FREE) == m_cMaxReqs);

  m_fStreamEnd = FALSE;
}

void CImplReader_1::CStreamInfo::MarkStreamEnd()
{
  m_fStreamEnd = TRUE;
}

void CImplReader_1::FreeAndReset()
{
  if(m_pRecCache)
    m_pRecCache->Release();
  m_pRecCache = 0;

  ASSERT(!m_fFileOpen);
  m_fFileOpen = FALSE;

  m_dwAlign = 0;

  if(m_pAsyncReader)
    m_pAsyncReader->Release();
  m_pAsyncReader = 0;

  if(m_rgpStreamInfo != 0)
    for(unsigned i = 0; i < m_cStreams; i++)
      delete m_rgpStreamInfo[i];
  delete[] m_rgpStreamInfo;
  m_rgpStreamInfo = 0;

  ASSERT(m_ilcPendingReads == 0);
  m_ilcPendingReads = 0;

  m_fFileOpen = FALSE;
  m_cStreams = 0;
  m_bInitialized = FALSE;
  m_bFlushing = FALSE;
  m_cRecords = 0;
}

// // ------------------------------------------------------------------------

// CAlignedMemObject::CAlignedMemObject(ULONG cbData, ULONG cbAlign)
// {
//   m_pbAllocated = new BYTE[cbData + 2 * cbAlign];
//   m_pbAlign = m_pbAllocated;
//   ULONG remainder = (DWORD)m_pbAlign % cbAlign;
//   if(remainder != 0)
//     m_pbAlign += cbAlign - remainder;
//   ASSERT((DWORD)m_pbAlign % cbAlign == 0);

//   m_pbData = 0;
// }

CImplReader_1Worker::CImplReader_1Worker()
{
}

BOOL CImplReader_1Worker::Create(CImplReader_1 *pReader)
{
  CAutoLock lock(&m_AccessLock);
  m_pReader = pReader;
  return CAMThread::Create();
}

HRESULT CImplReader_1Worker::Run()
{
   return CallWorker(CMD_RUN);
}

HRESULT CImplReader_1Worker::Stop()
{
   return CallWorker(CMD_STOP);
}

HRESULT CImplReader_1Worker::Exit()
{
   CAutoLock lock(&m_AccessLock);

   HRESULT hr = CallWorker(CMD_EXIT);
   if (FAILED(hr))
      return hr;

   // wait for thread completion and then close handle (and clear so
   // we can start another later)
   //
   Close();

   return NOERROR;
}

// called on the worker thread to do all the work. Thread exits when this
// function returns.
//
DWORD CImplReader_1Worker::ThreadProc()
{
    BOOL bExit = FALSE;
    while (!bExit)
    {
       Command cmd = GetRequest();
       switch (cmd)
       {
       case CMD_EXIT:
           bExit = TRUE;
           Reply(NOERROR);
           break;

       case CMD_RUN:
           Reply(NOERROR);
           DoRunLoop();
           break;

       case CMD_STOP:
           Reply(NOERROR);
           break;

       default:
           Reply(E_NOTIMPL);
           break;
       }
    }

    return NOERROR;
}

void CImplReader_1Worker::DoRunLoop(void)
{
  HRESULT hr;
  for(;;)
  {
    IMediaSample *pSample = 0;
    DWORD_PTR dwUser = 0;
    HRESULT hrDiskError = S_OK;

    if(m_pReader->m_bFlushing && m_pReader->m_ilcPendingReads == 0)
    {
      // the IAsyncReader lets us block even though we are flushing.
      DbgLog(( LOG_TRACE, 5,
               TEXT("CImplReader_1Worker::DoRunLoop: flushing, 0 pending")));
      break;
    }

    hr = m_pReader->m_pAsyncReader->WaitForNext(INFINITE, &pSample, &dwUser);

    // we clear reads in a controlled way. so this only happens when
    // we call BeginFlush
    if(pSample == 0 || dwUser == 0)
    {
      break;
    }

    EXECUTE_ASSERT(InterlockedDecrement(&m_pReader->m_ilcPendingReads) >= 0);

    if(hr != S_OK)
    {
      // source filter might have notified the graph when it detected
      // an error. the error can be a disk error or a timeout if we
      // are stopping

      DbgLog(( LOG_TRACE, 5,
               TEXT("CImplReader_1Worker::loop: disk error %08x."), hr ));

      // short file?
      if(SUCCEEDED(hr))
        hr = VFW_E_INVALID_FILE_FORMAT;

      hrDiskError = hr;
    }

    {
      // necessary to keep from accessing the cache simultaneously
      // with IssueRead
      CAutoLock lock(&m_pReader->m_cs);

      // buffer has addref for us from Request() call
      CRecBuffer *pRecBuffer = (CRecBuffer *)dwUser;

      if(hrDiskError == S_OK)
      {
        REFERENCE_TIME tStart, tStop;
        if(pSample->GetTime(&tStart, &tStop) == S_OK)
        {
          m_pReader->m_qwEndLastCompletedRead = tStop / UNITS;
          MSR_INTEGER(m_pReader->m_perfidDisk, -(long)(tStart / UNITS));
        }
      }

      // !!! invalid assertion. indicates read completed out of order
      // ASSERT(!!!pRecBuffer->m_fWaitingOnBuffer);

      pRecBuffer->m_fReadComplete = TRUE;
      DbgLog(( LOG_TRACE, 5,
               TEXT("CImplReader_1Worker::loop: buffer %08x came in"),
               pRecBuffer));

      // inner dependent buffer chain loop
      for(;;)
      {
        if(!pRecBuffer->m_fReadComplete)
          break;

        hr = m_pReader->ProcessCompletedBuffer(pRecBuffer, hrDiskError);
        ASSERT(SUCCEEDED(hr));

        CRecBuffer *pDestBuffer = pRecBuffer->m_overlap.pBuffer;
        pRecBuffer->m_overlap.pBuffer = 0;

        if(pDestBuffer == 0)
        {
          pRecBuffer->Release();
          break;
        }

        // remove source buffer's ref count on the destination
        // buffer. since the destination buffer must have samples, its
        // refcount must be > 0
        EXECUTE_ASSERT(pDestBuffer->Release() > 0);

        DbgLog(( LOG_TRACE, 5,
                 TEXT("CImplReader_1Worker::loop: csrc= %08x cb=%08x  to %08x@%08x"),
                 pRecBuffer,
                 pRecBuffer->m_overlap.cbOverlap,
                 pDestBuffer->GetPointer(pRecBuffer->m_overlap.qwOverlapOffset),
                 pDestBuffer ));

        CopyMemory(
          pDestBuffer->GetPointer(pRecBuffer->m_overlap.qwOverlapOffset),
          pRecBuffer->GetPointer(pRecBuffer->m_overlap.qwOverlapOffset),
          pRecBuffer->m_overlap.cbOverlap);

        pRecBuffer->Release();

        pDestBuffer->m_fWaitingOnBuffer = FALSE;

        // ASSERT(!!!pDestBuffer->m_overlap.pBuffer); // temporary

        // buffer will be processed when what it's waiting for completes
        if(!pDestBuffer->m_fReadComplete)
          break;

        // need to process buffer now
        pRecBuffer = pDestBuffer;
        pRecBuffer->AddRef();   // loop wants addrefd buffer.
        continue;
      } // inner dependent buffer chain loop
    } // critsec

    Command com;
    if (CheckRequest(&com))
    {
      // if it's a run command, then we're already running, so
      // eat it now.
      if (com == CMD_RUN)
      {
        GetRequest();
        Reply(NOERROR);
      }
      else if(com == CMD_STOP)
      {
        // continue processing requests until all queued reads return
        ASSERT(m_pReader->m_bFlushing);
        continue;
      }
      else
      {
        break;
      }
    }
  }

  // this assert introduces a race condition
  // ASSERT(m_pReader->m_ilcPendingReads == 0);
  DbgLog((LOG_TRACE,2,
          TEXT("CImplReader_1Worker::DoRunLoop: Leaving streaming loop")));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\msreader\basemsr.h ===
#pragma warning(disable: 4097 4511 4512 4514 4705)

// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef _basemsr_h
#define _basemsr_h

#include "reader.h"
#include "alloc.h"

// forward declarations
class CBaseMSRInPin;
class CBaseMSRFilter;
class CBaseMSROutPin;

// use this to avoid comparing guids frequently in the push
// loop. could compare pointers to the guids as long as they're
// ours...
enum TimeFormat
{
  FORMAT_NULL,
  FORMAT_TIME,
  FORMAT_SAMPLE,
  FORMAT_FRAME
};

struct ImsValues
{
  double dRate;

  // tick values
  LONGLONG llTickStart, llTickStop;

  // values IMediaSelection or IMediaPosition sent us. used for
  // partial frames
  LONGLONG llImsStart, llImsStop;

  // Flags for the seek
  DWORD dwSeekFlags;
};

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// CBaseMSRFilter represents a media file with one or more streams
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
// supports
//  -- CBaseFilter
//

class AM_NOVTABLE CBaseMSRFilter :
  public CBaseFilter,
  public CCritSec
{
public:

  // constructors etc
  CBaseMSRFilter(TCHAR *pszFilter, LPUNKNOWN pUnk, CLSID clsid, HRESULT *phr);
  virtual ~CBaseMSRFilter();

  // input pin notifies filter of connection and gives the
  // IAsyncReader interface this way. parse the file here and create
  // output pins (leave pins in a state ready to connect downstream).
  virtual HRESULT NotifyInputConnected(IAsyncReader *pAsyncReader);

  virtual HRESULT NotifyInputDisconnected();

  // information about the file/streams the cache
  // wants. iLeadingStream indicates that this stream should drive,
  // and the others should follow. negative otherwise
  virtual HRESULT GetCacheParams(
    StreamBufParam *pSbp,
    ULONG *pcbRead,
    ULONG *pcBuffers,
    int *piLeadingStream);

  // stream has queued a sample. block until all streams are ready
  void NotifyStreamQueuedAndWait();

  // don't block (if pin is not active, for example)
  void NotifyStreamQueued();

  // ------ CBaseFilter methods ------
  int GetPinCount();
  CBasePin * GetPin(int ix);

  // STDMETHODIMP FindPin(LPCWSTR pwszPinId, IPin **ppPin);

  virtual STDMETHODIMP Pause();
  virtual STDMETHODIMP Stop();

  // constant: how many QueueReadsSamples can exist
  const ULONG C_MAX_REQS_PER_STREAM;

  // pin method. here to avoid new input pin class for one method.
  virtual HRESULT CheckMediaType(const CMediaType* mtOut) = 0;

  static TimeFormat MapGuidToFormat(const GUID *const pGuidFormat);

  // used to parse header. addrefd
  struct IAsyncReader *m_pAsyncReader;

  // Seeking caps
  DWORD m_dwSeekingCaps;

  // stream requests seeking if through this interface. Only one will
  // succeed
  BOOL RequestSeekingIf(ULONG iStream);

  // SetSeekingIf should only be called from a (successful)
  // IMediaSeeking::SetTimeFormat.  Whichever pin is supporting
  // a specific time format has GOT to be the preferred seeking
  // pin.
  void SetSeekingIf(ULONG iStream);

  // distributes the seek to all the streams except the one that
  // called. This just updates workers start and stop times.
  HRESULT SeekOtherStreams(
    ULONG iStream,
    REFERENCE_TIME *prtStart,
    REFERENCE_TIME *prtStop,
    double dRate,
    DWORD dwSeekFlags);

  // if the start time is changing, we'll need to restart the worker
  HRESULT StopFlushRestartAllStreams(DWORD dwSeekFlags);

  HRESULT NotifyExternalMemory(IAMDevMemoryAllocator *pDevMem) {
    return m_pImplBuffer->NotifyExternalMemory(pDevMem);
  }


protected:

  // helper
  HRESULT AllocateAndRead (BYTE **ppb, DWORD cb, DWORDLONG qwPos);

  // allocated here
  CBaseMSRInPin *m_pInPin;
  CBaseMSROutPin **m_rgpOutPin;

  // number of streams and pins
  UINT m_cStreams;

  // allocated here
  IMultiStreamReader *m_pImplBuffer;

  // create input pin when filter is created
  virtual HRESULT CreateInputPin(CBaseMSRInPin **ppInPin);

private:

  // parse the file. create output pins in m_rgpOutPin. set m_cStreams
  virtual HRESULT CreateOutputPins() = 0;

  virtual HRESULT RemoveOutputPins();

  // event set when all streams have queued samples on startup. after
  // Active() (NotifyStreamActive) all streams MUST call
  // NotifyStreamQueued even on error paths
  HANDLE m_heStartupSync;
  long m_ilcStreamsNotQueued;

  // we want only one pin to expose a seeking if so that we can more
  // easily flush the file source filter. Reset (-1) when the input
  // pin is connected. need to track which pin can expose it (not just
  // first) in case the if is released
  long m_iStreamSeekingIfExposed;

  // protect the above
  CCritSec m_csSeekingStream;
};

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. uses IAsyncReader and not IMemInputPin

class CBaseMSRInPin : public CBasePin
{
protected:
  class CBaseMSRFilter* m_pFilter;

public:
  CBaseMSRInPin(
    class CBaseMSRFilter *pFilter,
    HRESULT *phr,
    LPCWSTR pPinName);

  virtual ~CBaseMSRInPin();

  // CBasePin / CBasePin overrides
  virtual HRESULT CheckMediaType(const CMediaType* mtOut);
  virtual HRESULT CheckConnect(IPin * pPin);
  virtual HRESULT CompleteConnect(IPin *pReceivePin);
  virtual HRESULT BreakConnect();

  STDMETHODIMP BeginFlush(void) { return E_UNEXPECTED; }
  STDMETHODIMP EndFlush(void) { return E_UNEXPECTED; }
};


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// worker thread object
//
class AM_NOVTABLE CBaseMSRWorker : public CAMThread
{
public:
  // sets the worker thread start, stop and rate variables. Called before push
  // starts, and also when a put_Stop happens during running.
  virtual HRESULT SetNewSelection(void);

protected:

  CBaseMSROutPin * m_pPin;

  // type-corrected overrides of communication funcs
  //
  enum Command
  {
    CMD_RUN, CMD_STOP, CMD_EXIT
  };

  Command GetRequest()
  {
    return (Command) CAMThread::GetRequest();
  }

  BOOL CheckRequest(Command * pCom)
  {
    return CAMThread::CheckRequest((DWORD *)pCom);
  }

  void DoRunLoop(void);

  void DoEndOfData();

  HRESULT NewSegmentHelper();

  // return VFW_S_NO_MORE_ITEMS if we reached sStop. S_FALSE if
  // position changed or received. fail if it's our error to
  // signal. S_OK if someone else wants us to stop.
  virtual HRESULT PushLoop();

  // Set the current time (some amount before m_tStart), accounting
  // for preroll.
  virtual HRESULT PushLoopInit(
    LONGLONG *pllCurrentOut,
    ImsValues *pImsValues) = 0;

  // override this if you need to munge the sample before
  // delivery. careful changing the buffer contents as you are
  // changing what's in the cache
  virtual HRESULT AboutToDeliver(IMediaSample *pSample);

  virtual HRESULT CopyData(
    IMediaSample **ppSampleOut,
    IMediaSample *pSampleIn);

  // override this if you deal with data that should not be delivered
  // (eg palette changes or in stream index nodes)
  virtual HRESULT HandleData(IMediaSample *pSample, DWORD dwUser)
  { return S_OK; }

  // see if read has completed, deliver it. Deliver can block.
  virtual HRESULT TryDeliverSample(
    BOOL *pfDeliveredSample,
    BOOL *pfStopPlease);

  // return S_OK if we queued a sample or it's a zero byte sample. set
  // rfQueuedSample if we queued a sample. VFW_S_NO_MORE_ITEMS if we
  // reached the end (end of index or reached m_tStop). S_FALSE if the
  // queue was full. update rtCurrent. call m_pReader->QueueReadSample
  virtual HRESULT TryQueueSample(
    LONGLONG &rllCurrent,       // [in, out]
    BOOL &rfQueuedSample,       // [out]
    ImsValues *pImsValues
    ) = 0;

  // internal state shared by the functions in the push loop. cannot
  // change when worker is running
  TimeFormat m_Format;
  LONGLONG m_llPushFirst;

  // this causes problems if you mix PERF and non PERF builds...
#ifdef PERF
  int m_perfidDeliver;              /* MSR_id for Deliver() time */
  int m_perfidWaitI;                /* block for read operation */
  int m_perfidNotDeliver;           // time between delivers
#endif // PERF

  ULONG m_cSamples;

  // pin/stream number
  UINT m_id;

  // not addrefd
  IMultiStreamReader *m_pReader;


public:

  // constructor
  CBaseMSRWorker(UINT stream, IMultiStreamReader *pReader);
  virtual ~CBaseMSRWorker() {;}

  // actually create the stream and bind it to a thread
  virtual BOOL Create(CBaseMSROutPin * pPin);

  // the thread executes this function, then exits
  DWORD ThreadProc();

  // commands we can give the thread
  HRESULT Run();
  HRESULT Stop();
  HRESULT Exit();

  // tell thread to reset itself
  HRESULT NotifyStreamActive();

private:

  // snapshot of start and stop times of push loop. protect access
  // from worker thread
  ImsValues m_ImsValues;

  // helper to call filter.
  inline void NotifyStreamQueued();
  inline void NotifyStreamQueuedAndWait();

  // whether this thread has yet told the filter it has queued a read
  BOOL m_fCalledNotifyStreamQueued;
};


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// CBaseMSROutPin represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CBaseMSROutPin object and
// returned via the EnumPins interface.
//

class AM_NOVTABLE CBaseMSROutPin :
    public CBaseOutputPin
{

public:
  CBaseMSROutPin(
    CBaseFilter *pOwningFilter,
    CBaseMSRFilter *pFilter,
    UINT iStream,
    IMultiStreamReader *&rpImplBuffer,
    HRESULT *phr,
    LPCWSTR pName);

  virtual ~CBaseMSROutPin();

  // expose IMediaPosition, IMediaSelection and what CBaseOutputPin
  // provides
  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

  // allow output pin different life time than filter
  STDMETHODIMP_(ULONG) NonDelegatingRelease();
  STDMETHODIMP_(ULONG) NonDelegatingAddRef();

  // CBaseOutPin and IPin methods

  // STDMETHODIMP QueryId(LPWSTR *Id);

  HRESULT GetMediaType(int iPosition, CMediaType* pt) = 0;
  HRESULT CheckMediaType(const CMediaType*);

  HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);

  virtual HRESULT DecideBufferSize(
    IMemAllocator * pAlloc,
    ALLOCATOR_PROPERTIES *pProperties);

  // note this returns a cRecSample, not an IMediaSample
  HRESULT GetDeliveryBufferInternal(
    CRecSample ** ppSample,
    REFERENCE_TIME * pStartTime,
    REFERENCE_TIME * pEndTime,
    DWORD dwFlags);

  virtual HRESULT Active();
  virtual HRESULT Inactive();

  // derived class should create its worker.
  virtual HRESULT OnActive() = 0;

  HRESULT BreakConnect();

  // ----- called by worker thread ---

  // override to receive Notification messages
  STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

  virtual ULONG GetMaxSampleSize() = 0;
  virtual BOOL UseDownstreamAllocator() { return FALSE; }

  // IMediaSelection stuff.

  // override these to support something other than time_format_none
  virtual HRESULT IsFormatSupported(const GUID *const pFormat);

  virtual HRESULT QueryPreferredFormat(GUID *pFormat);

  virtual HRESULT SetTimeFormat(const GUID *const pFormat);
  virtual HRESULT GetTimeFormat(GUID *pFormat);
  virtual HRESULT GetDuration(LONGLONG *pDuration) = 0;
  virtual HRESULT GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
    {
        return E_NOTIMPL;
    }


  HRESULT UpdateSelectionAndTellWorker(
    LONGLONG *pCurrent,
    LONGLONG *pStop,
    REFTIME *pTime,
    double dRate,
    const GUID *const pGuidFormat,
    DWORD dwSeekFlags
    );

  HRESULT StopWorker(bool bFlush);
  HRESULT RestartWorker();

  // for renderers only
  virtual HRESULT GetStopPosition(LONGLONG *pStop);
  virtual HRESULT GetCurrentPosition(LONGLONG *pCurrent);

  // derived class should return REFTIME value. set m_llCvtIms values
  virtual HRESULT RecordStartAndStop(
    LONGLONG *pCurrent,
    LONGLONG *pStop,
    REFTIME *pTime,
    const GUID *const pGuidFormat
    ) = 0;

  virtual HRESULT ConvertTimeFormat(
      LONGLONG * pTarget, const GUID * pTargetFormat,
      LONGLONG    Source, const GUID * pSourceFormat
      );

  double GetRate() const { return m_dImsRate; }

protected:

  // format IMediaSelection is using can only changed when worker is
  // stopped
  GUID m_guidFormat;

  // IMediaSelection values. zero rate indicates these values are
  // unset. in m_guidFormat units
  double m_dImsRate;
  LONGLONG m_llImsStart, m_llImsStop;
  DWORD    m_dwSeekFlags;

  // converted to ticks in RecordStartAndStop(). also set on startup
  // in InitializeOnNewFile()
  LONGLONG m_llCvtImsStart, m_llCvtImsStop;

  // lock when setting the above to protect worker thread
  CCritSec m_csImsValues;

  long m_ilfNewImsValues;

  //
  // Source seeking variables
  //
public:
  REFERENCE_TIME m_rtAccumulated;   // Ref time accumulated
  DWORD          m_dwSegmentNumber; // Segment number

public:

  CMediaType& CurrentMediaType() { return m_mt; }
  GUID* CurrentFormat() { return &m_guidFormat; }

  // return stream start and length in internal units.
  virtual LONGLONG GetStreamStart() = 0;
  virtual LONGLONG GetStreamLength() = 0;

  virtual HRESULT InitializeOnNewFile();

  // convert internal units to REFERENCE_TIME units. !!! really
  // needed? only used for DeliverNewSegment().
  virtual REFERENCE_TIME ConvertInternalToRT(const LONGLONG llVal) = 0;
  virtual LONGLONG ConvertRTToInternal(const REFERENCE_TIME llVal) = 0;

  HRESULT CreateImplSelect();

protected:

  CBaseMSRFilter *m_pFilter;

  IMultiStreamReader *&m_rpImplBuffer;

  // helper to return a FCC code with our stream id and
  // the upper two characters of the fcc code
  //
  // FOURCC TwoCC(WORD tcc);

  UINT m_id;                    // stream number

  friend class CBaseMSRWorker;
  CBaseMSRWorker *m_pWorker;

  // the one allocator created on creation of this pin. The
  // allocator's lifetime may be longer than the pin's, so it's
  // created separately
  friend class CBaseMSRFilter;
  CRecAllocator *m_pRecAllocator;

  CCritSec m_cs;

  // implementation of IMediaPosition
  class CImplPosition : public CSourcePosition, public CCritSec
  {

  protected:

    CBaseMSROutPin * m_pStream;
    HRESULT ChangeStart();
    HRESULT ChangeStop();
    HRESULT ChangeRate();

  public:

    CImplPosition(TCHAR*, CBaseMSROutPin*, HRESULT*);
    void GetValues(CRefTime *ptStart, CRefTime *ptSop, double *pdRate);
  };

  class CImplSelect :
    public IMediaSeeking,
    public CMediaPosition
  {
  private:
    CBaseMSROutPin *m_pPin;

  public:
    CImplSelect(TCHAR *, LPUNKNOWN, CBaseMSROutPin *pPin, HRESULT *);

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // returns S_OK if mode is supported, S_FALSE otherwise
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);

    // can only change the mode when stopped (returns
    // VFE_E_WRONG_STATE otherwise) !!!
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);

    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);

    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );

    STDMETHODIMP ConvertTimeFormat( LONGLONG * pTarget, const GUID * pTargetFormat,
                                    LONGLONG    Source, const GUID * pSourceFormat );

    STDMETHODIMP SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags
			     , LONGLONG * pStop,  DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );

    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll) { return E_NOTIMPL; }

    /* IMediaPosition methods */
    STDMETHOD(get_Duration)(THIS_ REFTIME FAR* plength) ;
    STDMETHOD(put_CurrentPosition)(THIS_ REFTIME llTime);
    STDMETHOD(get_CurrentPosition)(THIS_ REFTIME FAR* pllTime);
    STDMETHOD(get_StopTime)(THIS_ REFTIME FAR* pllTime) ;
    STDMETHOD(put_StopTime)(THIS_ REFTIME llTime) ;
    STDMETHOD(get_PrerollTime)(THIS_ REFTIME FAR* pllTime) ;
    STDMETHOD(put_PrerollTime)(THIS_ REFTIME llTime) ;
    STDMETHOD(put_Rate)(THIS_ double dRate) ;
    STDMETHOD(get_Rate)(THIS_ double FAR* pdRate) ;
    STDMETHOD(CanSeekForward)(THIS_ long FAR* pCanSeekForward) ;
    STDMETHOD(CanSeekBackward)(THIS_ long FAR* pCanSeekBackward) ;
  };

  // friend class CImplPosition;
  friend STDMETHODIMP CImplSelect::SetRate( double dRate);
  friend STDMETHODIMP CImplSelect::GetCapabilities(DWORD * pCapabilities );
  friend STDMETHODIMP CBaseMSROutPin::CImplSelect::SetPositions (
    LONGLONG * pCurrent,
    DWORD CurrentFlags ,
    LONGLONG * pStop,
    DWORD StopFlags);

  CImplPosition * m_pPosition;
  CImplSelect *m_pSelection;

  BOOL m_fUsingExternalMemory;
};

//  Audio stuff required by AVI and Wave
bool FixMPEGAudioTimeStamps(
    IMediaSample *pSample,
    BOOL bFirstSample,
    const WAVEFORMATEX *pwfx
);

#endif // _basemsr_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\filerend\filerend.h ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

// CLSID_FileRend,
// {D51BD5A5-7548-11cf-A520-0080C77EF58A}
DEFINE_GUID(CLSID_FileRend,
0xd51bd5A5, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);


//
// Quartz "transform" filter which really opens a file
//

// forward declarations

class CFileRendInPin;	   // input pin
class CFileRendStream;     // output pin, just placeholder for IStreamBuilder
class CFileRendFilter;     // overall container class

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. doesn't really need any data at all

class CFileRendInPin : public CBaseInputPin
{
protected:
    class CFileRendFilter* m_pFilter;

public:
    CFileRendInPin(
		 class CFileRendFilter *pFilter,
		 CCritSec *pLock,
		 HRESULT *phr,
		 LPCWSTR pPinName);


    // CBasePin overrides
    HRESULT CheckMediaType(const CMediaType* mtOut);

    // don't try to touch allocator, we don't use it.
    HRESULT Inactive(void) { return S_OK; }

    WCHAR * CurrentName() { return (WCHAR *) m_mt.Format(); }

};

// CFileRendStream
// output pin, supports IPin, IStreamBuilder
//
// never actually connects, just provides a place for graph builder to
// look for an IStreamBuilder
//


class CFileRendStream : public CBaseOutputPin, public IStreamBuilder
{

public:

    CFileRendStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CFileRendFilter * pFilter,
	CCritSec *pLock,
	LPCWSTR wszPinName);

    ~CFileRendStream();

    // expose IMediaPosition via CImplPosition, rest via CBaseOutputPin
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    // IPin

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    // say how big our buffers should be and how many we want
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);



    STDMETHODIMP Render(IPin * ppinOut, IGraphBuilder * pGraph);

    // we can't back anything out....
    STDMETHODIMP Backout(IPin * ppinOut, IGraphBuilder * pGraph) { return E_NOTIMPL; };

    DECLARE_IUNKNOWN

    CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
	    
private:

    CFileRendFilter * m_pFilter;
};

//
// CFileRendFilter 
//

class CFileRendFilter : public CBaseFilter
{
public:

    // constructors etc
    CFileRendFilter(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CFileRendFilter();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // pin enumerator calls this
    int GetPinCount();

    CBasePin * GetPin(int n);

private:

    friend class CFileRendStream;
    friend class CFileRendInPin;

    CFileRendStream m_Output;
    CFileRendInPin m_Input;

    CCritSec m_csLock;
};






// CLSID_MultFile,
// {D51BD5A3-7548-11cf-A520-0080C77EF58A}
DEFINE_GUID(CLSID_MultFile,
0xd51bd5a3, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);

//
// Quartz filter with fake output pin which supports IStreamBuilder to render
// lots of separate files
//

// forward declarations

class CMultStream;     // owns a particular stream
class CMultFilter;     // overall container class

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. uses IAsyncReader and not IMemInputPin

class CFRInPin : public CBasePin
{
protected:
    class CMultFilter* m_pFilter;

public:
    CFRInPin(
		 class CMultFilter *pFilter,
		 CCritSec *pLock,
		 HRESULT *phr,
		 LPCWSTR pPinName);


    // CBasePin overrides
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT BreakConnect();

    STDMETHODIMP BeginFlush(void) { return E_UNEXPECTED; }
    STDMETHODIMP EndFlush(void) { return E_UNEXPECTED; }
};

// CMultStream
// output pin, supports IPin
//



class CMultStream : public CBasePin
{

public:

    CMultStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CMultFilter * pFilter,
	CCritSec *pLock,
	LPCWSTR wszPinName);

    ~CMultStream();

    // IPin

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    STDMETHODIMP BeginFlush(void) { return S_OK; }
    STDMETHODIMP EndFlush(void) { return S_OK; }

    // allow output pin different life time than filter
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();


private:
    CMultFilter * m_pFilter;
};

//
// CMultFilter represents an avifile
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
//

class CMultFilter : public CBaseFilter
{
public:

    // constructors etc
    CMultFilter(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMultFilter();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // pin enumerator calls this
    int GetPinCount();

    CBasePin * GetPin(int n);

    HRESULT CreateOutputPins();
    HRESULT RemoveOutputPins();
private:

    friend class CMultStream;
    friend class CFRInPin;

    int	m_nOutputs;
    CMultStream **m_pOutputs;
    CFRInPin m_Input;

    CCritSec m_csLock;
    
public:
    IAsyncReader *m_pAsyncReader;
};


extern const AMOVIESETUP_FILTER sudMultiParse;
extern const AMOVIESETUP_FILTER sudFileRend;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\msreader\reader.h ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// reader.h. IMultiStreamReader definition: asynchronous buffering
// implementations optimized to read files with multiple streams
// (sequential access, random access, interleaved and uninterleaved)

#ifndef _Reader_H
#define _Reader_H

#include "alloc.h"

class CRecCache;
class CRecSample;
class IMultiStreamReader;

// SampleRequest - information kept while a sample is active.
struct SampleReq
{
  enum State { FREE = 0, PENDING, ISSUED, COMPLETE, C_STATES };
  State state;

  // sample gotten from QueueReadSample
  CRecSample *pSample;

  // region in file this sample occupies
  DWORDLONG fileOffset;
  ULONG cbReq;

  // file error reading media saved here.
  HRESULT hrError;

  // stream to return sample to
  UINT stream;

  // ok to complete this sample out of order
  bool fOooOk;
};

// structure used to configure each stream
struct StreamBufParam
{
  ULONG cbSampleMax;            // largest sample this stream will see
  ULONG cSamplesMax;            /* max # active samples */
  class CRecAllocator *pAllocator;
};

HRESULT CreateMultiStreamReader(
  struct IAsyncReader *pAsyncReader,
  ULONG cStreams,
  StreamBufParam *rgStreamBufParam,
  ULONG cbRead,
  ULONG cBuffers,
  int iLeadingStream,
  IMultiStreamReader **ppReader);

// ------------------------------------------------------------------------
// IMultiStreamReader interface

class AM_NOVTABLE IMultiStreamReader
{
public:

  // succeed even if the file is not open
  virtual HRESULT Close() = 0;

  virtual HRESULT BeginFlush() = 0;
  virtual HRESULT EndFlush() = 0;

  // read sample in a stream. ERROR_NOT_ENOUGH_MEMORY means too many
  // pending requests. VFW_E_NOT_COMMITTED means someone pressed
  // "stop"
  virtual HRESULT QueueReadSample(
    DWORDLONG fileOffset,
    ULONG cbData,               // # bytes to read
    CRecSample *pSample,
    UINT stream,
    bool fOooOk = false) = 0;

  // get the next sample if available (returned in request
  // order). VFW_E_TIMEOUT or S_OK. VFW_E_NOT_COMMITTED means someone
  // pressed "stop"
  virtual HRESULT PollForSample(
    IMediaSample **ppSample,    // may be 0
    UINT stream) = 0;

  virtual HRESULT WaitForSample(UINT stream) = 0;

  virtual HRESULT MarkStreamEnd(UINT stream) = 0;
  virtual HRESULT MarkStreamRestart(UINT stream) = 0;

  // discard pending requests. blocks.
  virtual HRESULT ClearPending(
    UINT stream) = 0;

  // read/copy non-stream data into supplied buffer.
  virtual HRESULT SynchronousRead(
    BYTE *pMem,
    DWORDLONG fileOffset,
    ULONG cbData) = 0;

  virtual HRESULT Start() = 0;

  virtual HRESULT NotifyExternalMemory(
      IAMDevMemoryAllocator *pDevMem) = 0;

  virtual ~IMultiStreamReader() { }
};

// ------------------------------------------------------------------------
// implementation of IMultiStreamReader with internal cache, coalesced
// reads

// arbitrary limit.
const UINT C_STREAMS_MAX = 0x80;

class CImplReader_1Worker : public CAMThread
{
private:
  class CImplReader_1 *m_pReader;
  enum Command
  {
    CMD_RUN,
    CMD_STOP,
    CMD_EXIT
  };

  Command GetRequest()
  {
    return (Command) CAMThread::GetRequest();
  }

  BOOL CheckRequest(Command * pCom)
  {
    return CAMThread::CheckRequest((DWORD *)pCom);
  }

  void DoRunLoop(void);

public:

  CImplReader_1Worker();

  // actually create the stream and bind it to a thread
  BOOL Create(CImplReader_1 *pReader);

  // the thread executes this function, then exits
  DWORD ThreadProc();

  // commands we can give the thread
  HRESULT Run();
  HRESULT Stop();
  HRESULT Exit();
};

class CImplReader_1 : public IMultiStreamReader
{
public:

  CImplReader_1(
    IAsyncReader *pAsyncReader,
    UINT cStreams,
    StreamBufParam *rgStreamBufParam,
    ULONG cbRead,
    ULONG cBuffers,
    int iLeadingStream,
    CRecCache *pRecCache,
    HRESULT *phr);

  ~CImplReader_1();

  HRESULT Close();

  HRESULT Start();

  HRESULT BeginFlush();

  HRESULT EndFlush();

  HRESULT QueueReadSample(
    DWORDLONG fileOffset,
    ULONG cbData,
    CRecSample *pSample,
    UINT stream,
    bool fOooOk);

  HRESULT PollForSample(
    IMediaSample **ppSample,
    UINT stream);

  HRESULT WaitForSample(UINT stream);

  HRESULT MarkStreamEnd(UINT stream);
  HRESULT MarkStreamRestart(UINT stream);

  HRESULT ClearPending(
    UINT stream);

  HRESULT SynchronousRead(
    BYTE *pb,
    DWORDLONG fileOffset,
    ULONG cbData);

  HRESULT ProcessCompletedBuffer(
    class CRecBuffer *pRecBuffer,
    HRESULT hrDiskError);

  HRESULT NotifyExternalMemory(IAMDevMemoryAllocator *pDevMem);

private:

  BOOL m_bInitialized;

  BOOL m_bFlushing;

  UINT m_cStreams;
  UINT m_cRecords;              // # records
  ULONG m_cbRecord;

  // for interleaved files, if we have one stream that leads (eg audio
  // in avi files). -1 o/w
  int m_iLeadingStream;
  int m_iLeadingStreamSaved;
  BOOL IsInterleavedMode() { return m_iLeadingStream >= 0; }

  long m_ilcPendingReads;

  LONGLONG m_llFileLength;

  //
  // CStreamInfo. manipulates lists of SampleReq's. requests start off
  // on the the free list. as the parser thread requests data, it's
  // put on the pending queue. when there are enough pending requests
  // to make a disk read worthwhile, they are put on the issued
  // queue. when the disk read completes, they go on the completed
  // queue.
  //
  class CStreamInfo
  {
  public:

    CStreamInfo(StreamBufParam *pSbp, HRESULT *phr);
    ~CStreamInfo();

    // make a free node pending, a pending node issued
    SampleReq *PromoteFirst(SampleReq::State state);

    // return the first one w/o promoting it
    SampleReq *GetFirst(SampleReq::State state);

    HRESULT PromoteFirstComplete(
      IMediaSample **ppSample,
      HRESULT *phrError);

    // wait for all issued reads to complete
    HRESULT FlushIC();

    // put Issued reads on the completed queue (and handle those that
    // can't be handled out of order)
    HRESULT PromoteIssued(SampleReq *pSampleReq);

    void CancelPending();

    // count of SampleReqs in state state
    inline ULONG GetCState(SampleReq::State state);

    // count of issued + completed (atomic)
    ULONG get_c_i_and_c();

    // no-op in retail builds
    inline void Reset();

    void Start();

    void MarkStreamEnd();
    void MarkStreamRestart() { m_fStreamEnd = FALSE; }
    BOOL GetStreamEnd() { return m_fStreamEnd; }

    ULONG GetCbLargestSample() { return m_sbp.cbSampleMax; }
    BOOL NeedsQueued();
    BOOL WantsQueued();

    HANDLE GetSampleReleasedHandle() {
        return m_sbp.pAllocator->hGetDownstreamSampleReleased();
    }

#ifdef DEBUG
    void Dbg_Dump(int iStream, TCHAR *psz);
    void DbgValidateLists();
#else
    inline void Dbg_Dump(int iStream, TCHAR *psz) {; }
    inline void DbgValidateLists() {; }
#endif

    BOOL m_bFlushing;

    // at least one sample queued on this stream
    BOOL m_bFirstSampleQueued;

    HANDLE m_hsCompletedReq;
    CCritSec m_cs;              // !!! per stream cs not needed

  private:

    void IncrementIReq(ULONG &riReq);
    void PromoteState(SampleReq::State &rState);

    StreamBufParam m_sbp;
    ULONG m_cMaxReqs;

    SampleReq *m_rgSampleReq;

    CGenericList<SampleReq> m_lstFree;
    CGenericList<SampleReq> m_lstPending;
    CGenericList<SampleReq> m_lstIssued;
    CGenericList<SampleReq> m_lstComplete;

    CGenericList<SampleReq>* m_rgpLsts[SampleReq::C_STATES];

    BOOL m_fStreamEnd;

  } **m_rgpStreamInfo;


  // does not lock. returns immediately
  HRESULT CheckIssueRead();

  // process cache hits. does not lock. returns immediately
  HRESULT ProcessCacheHit(UINT iStream);

  // called with starved stream and empty buffer
  HRESULT StuffBuffer(
    class CRecBuffer *pRecBuffer,
    UINT iStream,
    DWORDLONG &rRecStart,
    DWORDLONG &rRecEnd);

  // called with starved stream and empty buffer
  HRESULT StuffReserveBuffer(
    class CRecBuffer *pRecBuffer,
    UINT iStream,
    DWORDLONG &rRecStart,
    DWORDLONG &rRecEnd);

  HRESULT AttachSampleReq(
    class CRecBuffer *pRecBuffer,
    UINT iStream,
    DWORDLONG &rRecStart,
    DWORDLONG &rRecEnd);

  HRESULT IssueRead(
    class CRecBuffer *pRecBuffer,
    DWORDLONG recStart,
    DWORDLONG recEnd);

  void FreeAndReset();

  // thread that processes completed reads
  CImplReader_1Worker m_workerRead;

  // end of last read issued. used to avoid issuing non-contiguous
  // reads by filling in holes
  DWORDLONG m_qwLastReadEnd;

  // end of last read completed successfully. when stopping, the file
  // source times out pending reads. may cause us to seek unless we
  // track that here.
  DWORDLONG m_qwEndLastCompletedRead;

  // file info
  struct IAsyncReader *m_pAsyncReader;
  DWORD m_dwAlign;

  BOOL m_fFileOpen;

  // helpers
  ULONG AlignUp(ULONG x);
  ULONG AlignDown(ULONG x);

  CRecCache *m_pRecCache;

  CCritSec m_cs;

  friend class CImplReader_1Worker;

#ifdef PERF
  int m_perfidDisk;
  int m_perfidSeeked;
#endif /* PERF */
};

#endif // _Reader_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\msreader\reccache.h ===
// Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
#ifndef _reccache_h
#define _reccache_h

#include "reader.h"

class CRecCache;

class CRecBuffer
{
public:
  enum State {
    INVALID,                    // uninitialized
    PENDING,                    // waiting on disk
    VALID_ACTIVE,               // valid w/ refcounts
    VALID_INACTIVE };           // valid w/ no refcounts

  CRecBuffer(
    CRecCache *pParentCache,
    ULONG cbBuffer,
    BYTE *pb,
    HRESULT *phr,
    int stream = -1);

  void SetPointer(BYTE *pb);

  ~CRecBuffer();

  void Reset();

  BYTE *operator()() { return m_pbAligned; }
  BYTE *GetPointer(DWORDLONG fileOffset);

  // this sample is used for the read request 
  CMediaSample m_sample;
  
  DWORDLONG m_fileOffsetValid;
  ULONG m_cbValid;
  HRESULT m_hrRead;

  // list of sample reqs; valid only while the buffer is in state
  // PENDING
  CGenericList<SampleReq> sampleReqList;

  ULONG AddRef();
  ULONG Release();
  ULONG GetSize() { return m_cbReported; }

  void MarkPending();
  void MarkValid();
  void MarkValidWithFileError();

  State GetState() { return m_state; }

  // restriction: this buffer may overlap with only one other
  // buffer. this is not necessarily the case with reserve buffers,
  // and this causes extra seeks and reads. a better thing to do: give
  // sample requests a list of buffers on which they wait.
  struct Overlap
  {
    // buffer waiting on this one.
    class CRecBuffer *pBuffer;

    DWORDLONG qwOverlapOffset;
    ULONG cbOverlap;
  } m_overlap;

  BOOL m_fWaitingOnBuffer;
  BOOL m_fReadComplete;

private:

  // memory associated w/ this buffer, allocated elsewhere
  BYTE *m_pbAligned;

  // memory reported, adjusted for alignment
  ULONG m_cbReported;

  CRecCache *m_pParentCache;

  State m_state;

  long m_cRef;

  // stream # for reserve buffers -1 means not associated with stream
  int m_stream;

  // needed to remove from the active buffer list in constant time.
  POSITION m_posSortedList;

  void ResetPointer(BYTE *pb);

  friend class CRecCache;
};

class CRecCache :
  public CBaseAllocator
{

public:
  CRecCache(HRESULT *phr);
  ~CRecCache();

  HRESULT Configure(
    UINT CRecBuffers,
    ULONG cbBuffer,
    ULONG cbAlign,
    UINT cStreams,
    ULONG *rgStreamSize);

  HRESULT GetBuffer(CRecBuffer **ppRecBuffer);

  HRESULT GetReserveBuffer(
    CRecBuffer **ppRecBuffer,
    UINT stream);
  
  // put RecBuffer on free list on final release
  ULONG ReleaseBuffer(
    CRecBuffer *pRecBuffer);

  // return the AddRef'd buffer which can contain the SampleReq. mark
  // the buffer Active. S_FALSE: cache miss
  HRESULT GetCacheHit(
    SampleReq *pSampleReq,      /* [in] */
    CRecBuffer **ppBuffer);     /* [out] */

  // return the AddRef'd buffer which contains or will contain
  // overlapping sector. S_FALSE on cache miss
  HRESULT GetOverlappedCacheHit(
    DWORDLONG filePos,
    ULONG cbData,
    CRecBuffer **ppBuffer);     /* [out] */

  HRESULT BufferMarkPending(
    CRecBuffer *pBuffer);

  HRESULT NotifyExternalMemory(IAMDevMemoryAllocator *pDevMem);

  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

private:

  CRecBuffer *LocateBuffer(
    CGenericList<CRecBuffer> *pList,
    DWORDLONG qwFileOffset,
    ULONG cbBuffer);

  void MakeActive(CRecBuffer *pBuffer);

  void InvalidateCache();

  struct PerStreamBuffer
  {
    CRecBuffer *pBuffer;
  };

  PerStreamBuffer *m_rgPerStreamBuffer;
  UINT m_cStreams;

  // buffers with no refcounts (fifo)
  CGenericList<CRecBuffer> m_lFreeBuffers;

  // initial number of buffers in the free list (but not in the
  // reserve buffer pool)
  ULONG m_cBuffers;

  // buffers that are valid. may be in both this and the free
  // list. really should be a balancing tree.
  CGenericList<CRecBuffer> m_lSortedBuffers;

  CCritSec m_cs;

  int m_idPerfBufferReleased;

  void FreeBuffer();
  IAMDevMemoryAllocator *m_pDevMem;
  IUnknown *m_pDevConInner;
  BYTE *m_pbAllBuffers;

private:

  // CBaseAllocator overrides
  void Free(void);

  STDMETHODIMP SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual);

};

#endif /* _reccache_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\amextra2.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: amextra2.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#ifndef __AMEXTRA2__
#define __AMEXTRA2__


class CMediaSeeking :
    public IMediaSeeking,
    public CUnknown
{
    CBaseDispatch m_basedisp;


public:

    CMediaSeeking(const TCHAR *, LPUNKNOWN);
    CMediaSeeking(const TCHAR *, LPUNKNOWN, HRESULT *phr);
    virtual ~CMediaSeeking();

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
};


// A utility class which handles media position controls for many input pins
// connected to a single output pin

class CMultiPinPosPassThru :
    public CMediaSeeking
{
protected:

    IMediaSeeking **m_apMS;
    CRefTime *m_apOffsets;
    int m_iPinCount;
    CRefTime m_rtStartTime;
    CRefTime m_rtStopTime;
    double m_dRate;

    static const DWORD m_dwPermittedCaps;

public:

    CMultiPinPosPassThru(TCHAR *pName,LPUNKNOWN pUnk);
    ~CMultiPinPosPassThru();

    HRESULT SetPins(CBasePin **apPins,CRefTime *apOffsets,int iPinCount);
    HRESULT ResetPins(void);

//     // IMediaPosition methods

//     STDMETHODIMP get_Duration(REFTIME * plength);
//     STDMETHODIMP put_CurrentPosition(REFTIME llTime);
//     STDMETHODIMP get_StopTime(REFTIME * pllTime);
//     STDMETHODIMP put_StopTime(REFTIME llTime);
//     STDMETHODIMP get_PrerollTime(REFTIME * pllTime);
//     STDMETHODIMP put_PrerollTime(REFTIME llTime);
//     STDMETHODIMP get_Rate(double * pdRate);
//     STDMETHODIMP put_Rate(double dRate);

//     STDMETHODIMP get_CurrentPosition(REFTIME *pllTime) {
//         return E_NOTIMPL;
//     };

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsFormatSupported( const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                   LONGLONG    Source, const GUID * pSourceFormat );
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetDuration( LONGLONG *pDuration);
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll );
};

#endif // __AMEXTRA2__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\simpread\simpread.cpp ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.


// Simple parser filter
//
// Positional information is supported by the pins, which expose IMediaPosition.
// upstream pins will use this to tell us the start/stop position and rate to
// use
//

#include <streams.h>
#include "simpread.h"

// ok to use this as it is not dereferenced
#pragma warning(disable:4355)


/* Implements the CSimpleReader public member functions */


// constructors etc
CSimpleReader::CSimpleReader(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    REFCLSID refclsid,
    CCritSec *pLock,
    HRESULT *phr)
    : m_pLock(pLock),
      CBaseFilter(pName, pUnk, pLock, refclsid),
      m_Input(this, pLock, phr, L"Reader"),
      m_Output(NAME("Output pin"), phr, this, pLock, L"Out"),
      m_pAsyncReader(NULL)
{
}

CSimpleReader::~CSimpleReader()
{
}


// pin enumerator calls this
int CSimpleReader::GetPinCount() {
    // only expose output pin if we have a reader.
    return m_pAsyncReader ? 2 : 1;
};

// return a non-addrefed pointer to the CBasePin.
CBasePin *
CSimpleReader::GetPin(int n)
{
    if (n == 0)
	return &m_Input;

    if (n == 1)
	return &m_Output;
    
    return NULL;
}

HRESULT CSimpleReader::NotifyInputConnected(IAsyncReader *pAsyncReader)
{
    // these are reset when disconnected
    ASSERT(m_pAsyncReader == 0);

    // m_iStreamSeekingIfExposed = -1;

    // fail if any output pins are connected.
    if (m_Output.GetConnected()) {
	// !!! can't find a good error.
	return VFW_E_FILTER_ACTIVE;
    }

    // done here because CreateOutputPins uses m_pAsyncReader
    m_pAsyncReader = pAsyncReader;
    pAsyncReader->AddRef();

    HRESULT hr = ParseNewFile();

    if (FAILED(hr)) {
	m_pAsyncReader->Release();
	m_pAsyncReader = 0;
	return hr;
    }

    // set duration and length of stream
    m_Output.SetDuration(m_sLength, SampleToRefTime(m_sLength));
    
     // !!! anything else to set up here?
    
    return hr;
}

HRESULT CSimpleReader::NotifyInputDisconnected()
{
    if (m_pAsyncReader) {
	m_pAsyncReader->Release();
	m_pAsyncReader = 0;
    }

    // !!! disconnect output???

    return S_OK;
}


HRESULT CSimpleReader::SetOutputMediaType(const CMediaType* mtOut)
{
    m_Output.SetMediaType(mtOut);

    return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CReaderInPin::CReaderInPin(CSimpleReader *pFilter,
			   CCritSec *pLock,
			   HRESULT *phr,
			   LPCWSTR pPinName) :
   CBasePin(NAME("in pin"), pFilter, pLock, phr, pPinName, PINDIR_INPUT)
{
    m_pFilter = pFilter;
}

CReaderInPin::~CReaderInPin()
{
}

HRESULT CReaderInPin::CheckMediaType(const CMediaType *mtOut)
{
    return m_pFilter->CheckMediaType(mtOut);
}

HRESULT CReaderInPin::CheckConnect(IPin * pPin)
{
    HRESULT hr;

    hr = CBasePin::CheckConnect(pPin);
    if (FAILED(hr))
	return hr;

    IAsyncReader *pAsyncReader = 0;
    hr = pPin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
    if(SUCCEEDED(hr))
	pAsyncReader->Release();

    // E_NOINTERFACE is a reasonable error
    return hr;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.

HRESULT CReaderInPin::CompleteConnect(
  IPin *pReceivePin)
{
    HRESULT hr = CBasePin::CompleteConnect(pReceivePin);
    if(FAILED(hr))
	return hr;

    IAsyncReader *pAsyncReader = 0;
    hr = pReceivePin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
    if(FAILED(hr))
	return hr;

    hr = m_pFilter->NotifyInputConnected(pAsyncReader);
    pAsyncReader->Release();

    return hr;
}

HRESULT CReaderInPin::BreakConnect()
{
    HRESULT hr = CBasePin::BreakConnect();
    if(FAILED(hr))
	return hr;

    return m_pFilter->NotifyInputDisconnected();
}

/* Implements the CReaderStream class */


CReaderStream::CReaderStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CSimpleReader * pFilter,
    CCritSec *pLock,
    LPCWSTR wszPinName)
    : CBaseOutputPin(pObjectName, pFilter, pLock, phr, wszPinName)
    , CSourceSeeking(NAME("source position"), (IPin*) this, phr, &m_WorkerLock)
    , m_pFilter(pFilter)
{
}

CReaderStream::~CReaderStream()
{
}

STDMETHODIMP
CReaderStream::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IMediaSeeking) {
	return GetInterface((IMediaSeeking *) this, ppv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


// IPin interfaces


// return default media type & format
HRESULT
CReaderStream::GetMediaType(int iPosition, CMediaType* pt)
{
    // check it is the single type they want
    if (iPosition<0) {
	return E_INVALIDARG;
    }
    if (iPosition>0) {
	return VFW_S_NO_MORE_ITEMS;
    }

    CopyMediaType(pt, &m_mt);

    return S_OK;
}

// check if the pin can support this specific proposed type&format
HRESULT
CReaderStream::CheckMediaType(const CMediaType* pt)
{
    // we support exactly the type specified in the file header, and
    // no other.

    if (m_mt == *pt) {
	return NOERROR;
    } else {
	return E_INVALIDARG;
    }
}

HRESULT
CReaderStream::DecideBufferSize(IMemAllocator * pAllocator,
			     ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(pAllocator);
    ASSERT(pProperties);

    // !!! how do we decide how many to get ?
    pProperties->cBuffers = 4;

    pProperties->cbBuffer = m_pFilter->GetMaxSampleSize();

    // ask the allocator for these buffers
    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
	return hr;
    }

    return NOERROR;
}

// this pin has gone active. Start the thread pushing
HRESULT
CReaderStream::Active()
{
    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
	return hr;
    }


    // start the thread
    if (!ThreadExists()) {
	if (!Create()) {
	    return E_FAIL;
	}
    }

    return RunThread();
}

// pin has gone inactive. Stop and exit the worker thread
HRESULT
CReaderStream::Inactive()
{
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr;
    if (ThreadExists()) {
	hr = StopThread();

	if (FAILED(hr)) {
	    return hr;
	}

	hr = ExitThread();
	if (FAILED(hr)) {
	    return hr;
	}
    }
    return CBaseOutputPin::Inactive();
}

#if 0  // MIDL and structs don't match well
STDMETHODIMP
CReaderStream::Notify(IBaseFilter * pSender, Quality q)
{
   // ??? Try to adjust the quality to avoid flooding/starving the
   // components downstream.
   //
   // ideas anyone?

   return E_NOTIMPL;  // We are (currently) NOT handling this
}
#endif

// worker thread stuff


BOOL
CReaderStream::Create()
{
    CAutoLock lock(&m_AccessLock);

    return CAMThread::Create();
}


HRESULT
CReaderStream::RunThread()
{
    return CallWorker(CMD_RUN);
}

HRESULT
CReaderStream::StopThread()
{
    return CallWorker(CMD_STOP);
}


HRESULT
CReaderStream::ExitThread()
{
    CAutoLock lock(&m_AccessLock);

    HRESULT hr = CallWorker(CMD_EXIT);
    if (FAILED(hr)) {
	return hr;
    }

    // wait for thread completion and then close
    // handle (and clear so we can start another later)
    Close();

    return NOERROR;
}


// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CReaderStream::ThreadProc()
{

    BOOL bExit = FALSE;
    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }
    return NOERROR;
}

void
CReaderStream::DoRunLoop(void)
{
    // snapshot start and stop times from the other thread
    CRefTime tStart, tStopAt;
    double dRate;
    LONG sStart;
    LONG sStopAt;

    while (TRUE) {

	// each time before re-entering the push loop, check for changes
	// in start, stop or rate. If start has not changed, pick up from the
	// same current position.
	{
	    CAutoLock lock(&m_WorkerLock);

	    tStart = Start();
	    tStopAt = Stop();
	    dRate = Rate();

	    sStart = m_pFilter->RefTimeToSample(tStart);
	    sStopAt = m_pFilter->RefTimeToSample(tStopAt);

	    // if the stream is temporally compressed, we need to start from
	    // the previous key frame and play from there. All samples until the
	    // actual start will be marked with negative times.
	    // we send tStart as time 0, and start from tCurrent which may be
	    // negative

	}

	LONG sCurrent = m_pFilter->StartFrom(sStart);

	// check we are not going over the end
	sStopAt = min(sStopAt, (LONG) m_pFilter->m_sLength-1);

	// set the variables checked by PushLoop - these can also be set
	// on the fly
	SetRateInternal(dRate);
	SetStopAt(sStopAt, tStopAt);
	ASSERT(sCurrent >= 0);

	// returns S_OK if reached end
	HRESULT hr = PushLoop(sCurrent, sStart, tStart, dRate);
	if (VFW_S_NO_MORE_ITEMS == hr) {

	    DbgLog((LOG_ERROR,1,TEXT("Sending EndOfStream")));
	    // all done
	    // reached end of stream - notify downstream
	    DeliverEndOfStream();
	
	    break;
	} else if (FAILED(hr)) {

	    // signal an error to the filter graph and stop

	    // This could be the error reported from GetBuffer when we
	    // are stopping. In that case, nothing is wrong, really
	    if (hr != VFW_E_NOT_COMMITTED) {
		DbgLog((LOG_ERROR,1,TEXT("PushLoop failed! hr=%lx"), hr));
		m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);

		DeliverEndOfStream();
	    } else {
		DbgLog((LOG_TRACE,1,TEXT("PushLoop failed! But I don't care")));
	    }

	    break;
	} else if(hr == S_OK) {
	    // not my error to report. or someone wants to stop. queitly
	    // exit.
	    break;
	} // else S_FALSE - go round again

	Command com;
	if (CheckRequest(&com)) {
	    // if it's a run command, then we're already running, so
	    // eat it now.
	    if (com == CMD_RUN) {
		GetRequest();
		Reply(NOERROR);
	    } else {
		break;
	    }
	}
    }

    DbgLog((LOG_TRACE,1,TEXT("Leaving streaming loop")));
}


// return S_OK if reach sStop, S_FALSE if pos changed, or else error
HRESULT
CReaderStream::PushLoop(
    LONG sCurrent,
    LONG sStart,
    CRefTime tStart,
    double dRate
    )
{
    DbgLog((LOG_TRACE,1,TEXT("Entering streaming loop: start = %d, stop=%d"),
	    sCurrent, GetStopAt()));

    LONG sFirst = sCurrent; // remember the first thing we're sending

    // since we are starting on a new segment, notify the downstream pin
    DeliverNewSegment(tStart, GetStopTime(), GetRate());


    // we send one sample at m_sStopAt, but we set the time stamp such that
    // it won't get rendered except for media types that understand static
    // rendering (eg video). This means that play from 10 to 10 does the right
    // thing (completing, with frame 10 visible and no audio).

    while (sCurrent <= GetStopAt()) {

	DWORD sCount;

	// get a buffer
	DbgLog((LOG_TRACE,5,TEXT("Getting buffer...")));

	IMediaSample *pSample;
	HRESULT hr = GetDeliveryBuffer(&pSample, NULL, NULL, 0);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("Error %lx getting delivery buffer"), hr));
	    return hr;
	}

	DbgLog((LOG_TRACE,5,TEXT("Got buffer, size=%d"), pSample->GetSize()));

	// mark sample as preroll or not....
	pSample->SetPreroll(sCurrent < sStart);
	
	// If this is the first thing we're sending, it is discontinuous
	// from the last thing they received.
	if (sCurrent == sFirst)
	    pSample->SetDiscontinuity(TRUE);
	else
	    pSample->SetDiscontinuity(FALSE);

	// !!! actually get data here!!!!!!
	hr = m_pFilter->FillBuffer(pSample, sCurrent, &sCount);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("FillBuffer failed!  hr = %x"), hr));

	    return hr;
	}
	
	// set the start/stop time for this sample.
	CRefTime tThisStart = m_pFilter->SampleToRefTime(sCurrent) - tStart;
	CRefTime tThisEnd = m_pFilter->SampleToRefTime(sCurrent + sCount) - tStart;

	// we may have pushed a sample past the stop time, but we need to
	// make sure that the stop time is correct
	tThisEnd = min(tThisEnd, GetStopTime());

	// adjust both times by Rate... unless Rate is 0

	if (dRate && (dRate!=1.0)) {
	    tThisStart = LONGLONG( tThisStart.GetUnits() / dRate);
	    tThisEnd = LONGLONG( tThisEnd.GetUnits() / dRate);
	}

	pSample->SetTime((REFERENCE_TIME *)&tThisStart,
			 (REFERENCE_TIME *)&tThisEnd);


	DbgLog((LOG_TRACE,5,TEXT("Sending buffer, size = %d"), pSample->GetActualDataLength()));
	hr = Deliver(pSample);

	// done with buffer. connected pin may have its own addref
	DbgLog((LOG_TRACE,4,TEXT("Sample is delivered - releasing")));
	pSample->Release();
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("... but sample FAILED to deliver! hr=%lx"), hr));
	    // pretend everything's OK.  If we return an error, we'll panic
	    // and send EC_ERRORABORT and EC_COMPLETE, which is the wrong thing
	    // to do if we've tried to deliver something downstream.  Only
	    // if the downstream guy never got a chance to see the data do I
	    // feel like panicing.  For instance, the downstream guy could
	    // be failing because he's already seen EndOfStream (this thread
	    // hasn't noticed it yet) and he's already sent EC_COMPLETE and I
	    // would send another one!
	    return S_OK;
	}
	sCurrent += sCount;
	
	// what about hr==S_FALSE... I thought this would mean that
	// no more data should be sent down the pipe.
	if (hr == S_FALSE) {
	    DbgLog((LOG_ERROR,1,TEXT("Received S_FALSE from Deliver, stopping delivery")));
	    return S_OK;
	}
	
	// any other requests ?
	Command com;
	if (CheckRequest(&com)) {
	    return S_FALSE;
	}

    }

    DbgLog((LOG_TRACE,1,TEXT("Leaving streaming loop: current = %d, stop=%d"),
	    sCurrent, GetStopAt()));
    return VFW_S_NO_MORE_ITEMS;
}

// ------ IMediaPosition implementation -----------------------

HRESULT
CReaderStream::ChangeStart()
{
    // this lock should not be the same as the lock that protects access
    // to the start/stop/rate values. The worker thread will need to lock
    // that on some code paths before responding to a Stop and thus will
    // cause deadlock.

    // what we are locking here is access to the worker thread, and thus we
    // should hold the lock that prevents more than one client thread from
    // accessing the worker thread.

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {

	// next time round the loop the worker thread will
	// pick up the position change.
	// We need to flush all the existing data - we must do that here
	// as our thread will probably be blocked in GetBuffer otherwise

	DeliverBeginFlush();

	// make sure we have stopped pushing
	StopThread();

	// complete the flush
	DeliverEndFlush();

	// restart
	RunThread();
    }
    return S_OK;
}

HRESULT
CReaderStream::ChangeRate()
{
    // changing the rate can be done on the fly
    if( Rate() > 0 ) // we only support positive rates
    {
        SetRateInternal(Rate());
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT
CReaderStream::ChangeStop()
{
    // we don't need to restart the worker thread to handle stop changes
    // and in any case that would be wrong since it would then start
    // pushing from the wrong place. Set the variables used by
    // the PushLoop
    REFERENCE_TIME tStopAt;
    {
        CAutoLock lock(&m_WorkerLock);
        tStopAt = Stop();
    }
    LONG sStopAt = m_pFilter->RefTimeToSample(tStopAt);
    SetStopAt(sStopAt, tStopAt);

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\msreader\reccache.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "reccache.h"
#include "alloc.h"

static inline DWORD_PTR AlignUp(DWORD_PTR dw, DWORD_PTR dwAlign) {
  // align up: round up to next boundary
  return (dw + (dwAlign -1)) & ~(dwAlign -1);
};

static inline BYTE *AlignUp(BYTE *pb, ULONG cbAlign)
{
  return (BYTE *)(AlignUp((DWORD_PTR)pb, cbAlign));
}


CRecBuffer::CRecBuffer(
  CRecCache *pParentCache,
  ULONG cbBuffer,
  BYTE *pb,
  HRESULT *phr,
  int stream) :
    sampleReqList(NAME("rec buffer sample req list"), 50),
    m_sample(NAME("buffer sample"), pParentCache, phr)
{
  m_pParentCache = pParentCache;
  m_state = INVALID;
  m_posSortedList = 0;
  ZeroMemory(&m_overlap, sizeof(m_overlap));
  m_cRef = 0;
  m_stream = stream;

  m_fWaitingOnBuffer = FALSE;
  m_fReadComplete = FALSE;
  m_hrRead = E_FAIL;

  ASSERT(m_cRef == 0);
  if(FAILED(*phr))
    return;

  m_pbAligned = pb;

  // report the aligned amount
  m_cbReported = cbBuffer;
}

CRecBuffer::~CRecBuffer()
{
  ASSERT(sampleReqList.GetCount() == 0);
  ASSERT(m_cRef == 0);
}

void CRecBuffer::Reset()
{
  m_fileOffsetValid = 0;
  m_cbValid = 0;

  ASSERT(sampleReqList.GetCount() == 0);
  ASSERT(m_overlap.pBuffer == 0);
  ASSERT(m_fWaitingOnBuffer == FALSE);
  m_fReadComplete = FALSE;
  m_hrRead = E_FAIL;

  ASSERT(m_cRef == 0);
}

void CRecBuffer::ResetPointer(BYTE *pb)
{
  m_state = INVALID;
  m_pbAligned = pb;
}

BYTE *CRecBuffer::GetPointer(DWORDLONG fileOffset)
{
  return m_pbAligned + (fileOffset - m_fileOffsetValid);
}

ULONG CRecBuffer::AddRef()
{
  InterlockedIncrement(&m_cRef);
  m_pParentCache->AddRef();
  ASSERT(m_cRef > 0);
  return m_cRef;
}

ULONG CRecBuffer::Release()
{
  // call RecCache's ReleaseBuffer so that its critical section can be
  // locked. otherwise there is a race condition between the
  // InterlockedDecrement to zero and entering the cs in CRecCache.
  ULONG c = m_pParentCache->ReleaseBuffer(this);
  m_pParentCache->Release();
  return c;
}

void CRecBuffer::MarkPending()
{
  m_pParentCache->BufferMarkPending(this);
}

void CRecBuffer::MarkValid()
{
  ASSERT(m_state == PENDING);
  m_state = VALID_ACTIVE;
}

void CRecBuffer::MarkValidWithFileError()
{
  ASSERT(m_state == PENDING);
  m_state = VALID_ACTIVE;
  m_cbValid = 0;
}

CRecCache::CRecCache(HRESULT *phr) :
    m_lFreeBuffers(NAME("free buffer list"), 10, FALSE),
    m_lSortedBuffers(NAME("Sorted buffer list"), 10, FALSE),
    CBaseAllocator(NAME("cache allocator"), 0, phr)
{
  m_cStreams = 0;
  m_cBuffers = 0;
  m_rgPerStreamBuffer = 0;
  m_pDevMem = 0;
  m_pDevConInner = 0;
  m_pbAllBuffers = 0;

#ifdef PERF
  m_idPerfBufferReleased = MSR_REGISTER(TEXT("basemsr buffer released"));
#endif // PERF
}

CRecCache::~CRecCache()
{
  ASSERT(m_lFreeBuffers.GetCount() == (long)m_cBuffers);

  for(ULONG iBuffer = 0; iBuffer < m_cBuffers; iBuffer++)
  {
    CRecBuffer *pRecBuffer = m_lFreeBuffers.RemoveHead();
    ASSERT(pRecBuffer);
    delete pRecBuffer;
  }

  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    delete m_rgPerStreamBuffer[iStream].pBuffer;
  }

  m_lSortedBuffers.RemoveAll();

  delete[] m_rgPerStreamBuffer;

  FreeBuffer();
}

HRESULT CRecCache::Configure(
  UINT cBuffers,
  ULONG cbBuffer,
  ULONG cbAlign,
  UINT cStreams,
  ULONG *rgStreamSize)
{
  HRESULT hr;
  UINT iStream;

  ASSERT(m_rgPerStreamBuffer == 0);
  ASSERT(m_lFreeBuffers.GetCount() == 0);

  m_cStreams = cStreams;
  m_rgPerStreamBuffer = new PerStreamBuffer[cStreams];

  if(m_rgPerStreamBuffer == 0)
    return E_OUTOFMEMORY;

  for(iStream = 0; iStream < cStreams; iStream++)
  {
    m_rgPerStreamBuffer[iStream].pBuffer = 0;
  }

  ULONG cbAllocate = 0;
  for(iStream = 0; iStream < cStreams; iStream++)
    cbAllocate += (DWORD)AlignUp(rgStreamSize[iStream], cbAlign);
  cbAllocate += cBuffers * (DWORD)AlignUp(cbBuffer, cbAlign);
  ASSERT(AlignUp(cbAllocate, cbAlign) == cbAllocate);

  BYTE *pbAligned;
  m_pbAllBuffers = new BYTE[cbAllocate + cbAlign];
  if(m_pbAllBuffers == 0)
    return E_OUTOFMEMORY;
  pbAligned = AlignUp(m_pbAllBuffers, cbAlign);

  DbgLog(( LOG_TRACE, 5, TEXT("CRecCache::Configure: %i reserve"), cStreams ));
  for(iStream = 0; iStream < cStreams; iStream++)
  {
    hr = S_OK;
    m_rgPerStreamBuffer[iStream].pBuffer = new CRecBuffer(
      this,
      rgStreamSize[iStream],
      pbAligned,
      &hr,
      iStream);

    if(!m_rgPerStreamBuffer[iStream].pBuffer)
      hr = E_OUTOFMEMORY;
    if(FAILED(hr))
      goto Bail;

    pbAligned += AlignUp(rgStreamSize[iStream], cbAlign);

  }

  {
    DbgLog(( LOG_TRACE, 5,
             TEXT("CRecCache::Configure: %i (%i) buffers"),
             cBuffers, cbBuffer ));
    for(UINT iBuffer = 0; iBuffer < cBuffers; iBuffer++)
    {
      hr = S_OK;
      CRecBuffer *pRecBuffer = new CRecBuffer(this, cbBuffer, pbAligned, &hr);
      if(pRecBuffer == 0)
        hr = E_OUTOFMEMORY;
      if(FAILED(hr))
      {
        delete pRecBuffer;
        goto Bail;
      }

      pbAligned += AlignUp(cbBuffer, cbAlign);

      m_lFreeBuffers.AddHead(pRecBuffer);
    }
    m_cBuffers = cBuffers;
  }

  ASSERT(cBuffers != 0);

  return S_OK;

Bail:

  for(iStream = 0; iStream < cStreams; iStream++)
  {
    delete m_rgPerStreamBuffer[iStream].pBuffer;
    m_rgPerStreamBuffer[iStream].pBuffer = 0;
  }

  delete [] m_rgPerStreamBuffer;
  m_rgPerStreamBuffer = 0;

  CRecBuffer *pRecBuffer;
  while(pRecBuffer = m_lFreeBuffers.RemoveHead(),
        pRecBuffer)
  {
    delete pRecBuffer;
  }

  m_cStreams = 0;

  ASSERT(FAILED(hr));
  return hr;
}


HRESULT CRecCache::GetBuffer(
  CRecBuffer **ppRecBuffer)
{
  CAutoLock lock(&m_cs);

  *ppRecBuffer = m_lFreeBuffers.RemoveHead();
  if(!*ppRecBuffer) {
      return E_OUTOFMEMORY;
  }

  ASSERT(*ppRecBuffer);

  (*ppRecBuffer)->Reset();
  ASSERT((*ppRecBuffer)->m_state == CRecBuffer::INVALID ||
         (*ppRecBuffer)->m_state == CRecBuffer::VALID_INACTIVE);
  ASSERT((**ppRecBuffer)() != 0);

  (*ppRecBuffer)->AddRef();

  if((*ppRecBuffer)->m_state == CRecBuffer::VALID_INACTIVE)
  {
    DbgLog(( LOG_TRACE, 5,
             TEXT("CRecCache::GetBuffer: invalidate %08x"),
             (ULONG)((**ppRecBuffer).m_fileOffsetValid) ));
  }
  (*ppRecBuffer)->m_state = CRecBuffer::INVALID;

  POSITION pos = (**ppRecBuffer).m_posSortedList;
  if(pos != 0)
    m_lSortedBuffers.Remove(pos);

  return S_OK;
}

HRESULT CRecCache::GetReserveBuffer(
  CRecBuffer **ppRecBuffer,
  UINT stream)
{
  CAutoLock lock(&m_cs);

  *ppRecBuffer = m_rgPerStreamBuffer[stream].pBuffer;
  if(!*ppRecBuffer) {
      return E_OUTOFMEMORY;
  }
  m_rgPerStreamBuffer[stream].pBuffer = 0;

  ASSERT(*ppRecBuffer);

  (*ppRecBuffer)->Reset();
  ASSERT((*ppRecBuffer)->m_state == CRecBuffer::INVALID ||
         (*ppRecBuffer)->m_state == CRecBuffer::VALID_INACTIVE);

  (*ppRecBuffer)->AddRef();

  if((*ppRecBuffer)->m_state == CRecBuffer::VALID_INACTIVE)
  {
    DbgLog(( LOG_TRACE, 5,
             TEXT("CRecCache::GetBuffer: invalidate %08x"),
             (ULONG)((**ppRecBuffer).m_fileOffsetValid) ));
  }
  (*ppRecBuffer)->m_state = CRecBuffer::INVALID;

  POSITION pos = (**ppRecBuffer).m_posSortedList;
  if(pos != 0)
    m_lSortedBuffers.Remove(pos);

  return S_OK;
}


ULONG CRecCache::ReleaseBuffer(
  CRecBuffer *pRecBuffer)
{

  CAutoLock lock(&m_cs);

  // this is done here to avoid a race condition. if this is the final
  // release, only CRecCache can addref it with m_cs locked.
  long c = InterlockedDecrement(&pRecBuffer->m_cRef);
  ASSERT(c >= 0);

  DbgLog(( LOG_MEMORY, 3, TEXT("::ReleaseBuffer: %08x = %d"),
           pRecBuffer, pRecBuffer->m_cRef ));

  if(c > 0)
    return c;

  ASSERT(c == 0);
//   if(c != 0) _asm int 3;

  ASSERT(pRecBuffer->sampleReqList.GetCount() == 0);
  ASSERT(pRecBuffer->m_cRef == 0);
  ASSERT((*pRecBuffer)() != 0);

  ASSERT(pRecBuffer->m_overlap.pBuffer == 0);
  ASSERT(pRecBuffer->m_fWaitingOnBuffer == FALSE);

  if(pRecBuffer->m_state == CRecBuffer::VALID_ACTIVE)
  {
    pRecBuffer->m_state = CRecBuffer::VALID_INACTIVE;
    ASSERT(pRecBuffer->m_posSortedList != 0);
  }
  else
  {
    pRecBuffer->m_state = CRecBuffer::INVALID;
    ASSERT(pRecBuffer->m_posSortedList == 0);
  }

  if(pRecBuffer->m_stream == -1)
  {
    m_lFreeBuffers.AddTail(pRecBuffer);
  }
  else
  {
    ASSERT(m_rgPerStreamBuffer[pRecBuffer->m_stream].pBuffer == 0);
    m_rgPerStreamBuffer[pRecBuffer->m_stream].pBuffer = pRecBuffer;
  }

  DbgLog(( LOG_MEMORY, 2, TEXT("::ReleaseBuffer: %08x = %d"),
           pRecBuffer, pRecBuffer->m_cRef ));

  DbgLog((LOG_TRACE, 0x3f, TEXT("CRecCache: buffer %08x freed"),
          pRecBuffer));

  MSR_NOTE(m_idPerfBufferReleased);

  return 0;
}

// return addref'd buffer

HRESULT CRecCache::GetCacheHit(
  SampleReq *pSampleReq,
  CRecBuffer **ppBuffer)
{
  CAutoLock lock(&m_cs);

  *ppBuffer = 0;
  CRecBuffer *&rpBuffer = *ppBuffer;

  rpBuffer = LocateBuffer(
    &m_lSortedBuffers,
    pSampleReq->fileOffset,
    pSampleReq->cbReq);

  if(rpBuffer)
  {
    // reserve buffer for a different stream?
    if(rpBuffer->m_stream != -1 &&
       rpBuffer->m_stream != (signed)pSampleReq->stream)
    {
      rpBuffer = 0;
      return S_FALSE;
    }

    rpBuffer->AddRef();

    if(rpBuffer->m_state == CRecBuffer::PENDING)
      rpBuffer->sampleReqList.AddTail(pSampleReq);

    // take this buffer off the free list
    if(rpBuffer->m_state == CRecBuffer::VALID_INACTIVE)
    {
      MakeActive(rpBuffer);
    }

    return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}

HRESULT CRecCache::GetOverlappedCacheHit(
  DWORDLONG filePos,
  ULONG cbData,
  CRecBuffer **ppBuffer)
{
  CAutoLock lock(&m_cs);

  CRecBuffer *&rpBuffer = *ppBuffer;
  rpBuffer = LocateBuffer(
    &m_lSortedBuffers,
    filePos,
    cbData);

  if(rpBuffer)
  {
    rpBuffer->AddRef();

    // take this buffer off the free list
    if(rpBuffer->m_state == CRecBuffer::VALID_INACTIVE)
    {
      MakeActive(rpBuffer);
    }

     return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}

void CRecCache::MakeActive(CRecBuffer *pBuffer)
{
  ASSERT(CritCheckIn(&m_cs));
  ASSERT(pBuffer->sampleReqList.GetCount() == 0);
  // remove it from the free list. !!! linear search.
  if(pBuffer->m_stream == -1)
  {
    POSITION pos = m_lFreeBuffers.Find(pBuffer);
    ASSERT(pos != 0);
    m_lFreeBuffers.Remove(pos);
  }
  else
  {
    ASSERT(m_rgPerStreamBuffer[pBuffer->m_stream].pBuffer != 0);
    m_rgPerStreamBuffer[pBuffer->m_stream].pBuffer = 0;
  }
  pBuffer->m_state = CRecBuffer::VALID_ACTIVE;
}

// this is done here rather instead of in the buffer so that we can
// lock CRecCache and prevent LocateBuffer from finding
// m_posSortedList unset.

HRESULT CRecCache::BufferMarkPending(
  CRecBuffer *pBuffer)
{
  CAutoLock lock(&m_cs);

  ASSERT(pBuffer->m_state == CRecBuffer::INVALID);
  pBuffer->m_state = CRecBuffer::PENDING;

  // list is not sorted for the moment
  POSITION pos = m_lSortedBuffers.AddHead(pBuffer);
  pBuffer->m_posSortedList = pos;

  return S_OK;
}

STDMETHODIMP
CRecCache::NonDelegatingQueryInterface (
  REFIID riid,
  void ** pv)
{
  if(m_pDevConInner && riid == IID_IAMDevMemoryControl)
  {
    return m_pDevConInner->QueryInterface(riid, pv);
  }
  else
  {
    return CBaseAllocator::NonDelegatingQueryInterface(riid, pv);
  }
}

// called when an output pin finds that this filter can use memory
// from the downstream filter. null means stop using any external
// allocator

HRESULT CRecCache::NotifyExternalMemory(
    IAMDevMemoryAllocator *pDevMem)
{
  DbgLog((LOG_TRACE, 5, TEXT("CRecCache::NotifyExternalMemory")));
  InvalidateCache();

  HRESULT hr = S_OK;

  // not running
  ASSERT(m_lFreeBuffers.GetCount() == (long)m_cBuffers);

  // allocated when input pin connected
  ASSERT(m_pbAllBuffers);

  if(pDevMem == 0 && m_pDevMem == 0)
  {
    DbgLog((LOG_TRACE, 5, TEXT("CRecCache: keeping internal allocator")));
    return S_OK;
  }

  ALLOCATOR_PROPERTIES apThis;
  GetProperties(&apThis);
  ASSERT(apThis.cbAlign != 0);

  //
  // count how much memory to allocate
  //
  ULONG cbAllocate = 0;
  POSITION pos = m_lFreeBuffers.GetHeadPosition();
  while(pos)
  {
    CRecBuffer *pBuffer = m_lFreeBuffers.Get(pos);
    ASSERT(pBuffer->GetSize() % apThis.cbAlign == 0);
    cbAllocate += pBuffer->GetSize();
    pos = m_lFreeBuffers.Next(pos);
  }
  for(UINT iStream = 0; iStream < m_cStreams; iStream++)
  {
    CRecBuffer *pBuffer = m_rgPerStreamBuffer[iStream].pBuffer;
    ASSERT(pBuffer->GetSize() % apThis.cbAlign == 0);
    cbAllocate += pBuffer->GetSize();
  }

  DbgLog((LOG_TRACE, 5, TEXT("CRecCache: computed cbAllocate= %d"),
          cbAllocate));

  BYTE *pbMem;
  if(pDevMem)
  {
    if(m_pDevMem)
    {
      DbgLog((LOG_TRACE, 5, TEXT("CRecCache: keeping external allocator")));
      return S_OK;
    }

    DbgLog((LOG_TRACE, 5, TEXT("CRecCache: trying external allocator")));

#ifdef DEBUG
    DWORD dwTotalFree, dwLargestFree, dwTotalMem, dwMinChunk;
    hr = pDevMem->GetInfo(
      &dwTotalFree, &dwLargestFree, &dwTotalMem, &dwMinChunk);
    DbgLog((LOG_TRACE, 3,
            TEXT("DevMemInfo: hr = %08x, total free: %08x,")
	    TEXT("largest free: %08x, total mem: %08x, min chunk: %08x"),
            hr, dwTotalFree, dwLargestFree, dwTotalMem, dwMinChunk));
#endif // DEBUG

    DWORD dwcb = (DWORD)AlignUp(cbAllocate, apThis.cbAlign);
    hr = pDevMem->Alloc(&pbMem, &dwcb);
    if(FAILED(hr))
    {
      return S_FALSE;
    }
    else if(dwcb < cbAllocate)
    {
      DbgLog((LOG_ERROR, 1, TEXT("reccache: insufficent memory from DevMem")));
      EXECUTE_ASSERT(SUCCEEDED(pDevMem->Free(pbMem)));
      return S_FALSE;
    }


    FreeBuffer();

    IUnknown *pDevConUnk;
    hr = pDevMem->GetDevMemoryObject(&pDevConUnk, GetOwner());
    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 1, TEXT("CRecCache: GetDevMemoryObject: %08x"), hr));
      EXECUTE_ASSERT(SUCCEEDED(pDevMem->Free(pbMem)));
      return hr;
    }

    m_pDevMem = pDevMem;
    m_pDevConInner = pDevConUnk; // already addrefd
    pDevMem->AddRef();
    m_pbAllBuffers = pbMem;
    pbMem = AlignUp(pbMem, apThis.cbAlign);
  }
  else
  {
    DbgLog((LOG_TRACE, 5, TEXT("CRecCache: back to internal allocator")));
    ASSERT(m_pDevMem);
    FreeBuffer();

    m_pbAllBuffers = new BYTE[cbAllocate + apThis.cbAlign];
    if(m_pbAllBuffers == 0)
      return E_OUTOFMEMORY;

    pbMem = AlignUp(m_pbAllBuffers, apThis.cbAlign);
  }

  DbgAssertAligned(pbMem, apThis.cbAlign );
  BYTE *pbMemStart = pbMem;

  pos = m_lFreeBuffers.GetHeadPosition();
  while(pos)
  {
    CRecBuffer *pBuffer = m_lFreeBuffers.Get(pos);
    pBuffer->ResetPointer(pbMem);
    ASSERT(pBuffer->GetSize() % apThis.cbAlign == 0);
    pbMem += pBuffer->GetSize();

    pos = m_lFreeBuffers.Next(pos);
  }
  for(iStream = 0; iStream < m_cStreams; iStream++)
  {
    CRecBuffer *pBuffer = m_rgPerStreamBuffer[iStream].pBuffer;
    pBuffer->ResetPointer(pbMem);
    ASSERT(pBuffer->GetSize() % apThis.cbAlign == 0);
    pbMem += pBuffer->GetSize();
  }
  ASSERT(pbMem <= pbMemStart + cbAllocate);

  return S_OK;
}

void CRecCache::FreeBuffer()
{
  if(m_pDevMem)
  {
    EXECUTE_ASSERT(SUCCEEDED(m_pDevMem->Free(m_pbAllBuffers)));
    m_pDevMem->Release();
    m_pDevConInner->Release();
    m_pDevMem = 0;
    m_pDevConInner = 0;
  }
  else
  {
    delete[] m_pbAllBuffers;
  }
  m_pbAllBuffers = 0;
}

void CRecCache::InvalidateCache()
{
  POSITION pos;
  while(pos = m_lSortedBuffers.GetHeadPosition(),
        pos)
  {
    m_lSortedBuffers.Get(pos)->m_state = CRecBuffer::INVALID;
    m_lSortedBuffers.Get(pos)->m_posSortedList = 0;
    m_lSortedBuffers.RemoveHead();
  }
}

CRecBuffer *CRecCache::LocateBuffer(
  CGenericList<CRecBuffer> *pList,
  DWORDLONG qwFileOffset,
  ULONG cbBuffer)
{
  ASSERT(CritCheckIn(&m_cs));
  POSITION pos = pList->GetHeadPosition();

  // list is not sorted for the moment
  while(pos)
  {
    CRecBuffer *pBuffer = pList->Get(pos);
    ASSERT(pBuffer);

    ASSERT(pBuffer->m_state != CRecBuffer::INVALID);
    ASSERT(pBuffer->m_state == CRecBuffer::PENDING ||
           pBuffer->m_state == CRecBuffer::VALID_INACTIVE ||
           pBuffer->m_state == CRecBuffer::VALID_ACTIVE);

    // if it fits in this buffer
    if((pBuffer->m_fileOffsetValid <= qwFileOffset) &&
       (pBuffer->m_fileOffsetValid + pBuffer->m_cbValid >=
        qwFileOffset + cbBuffer))
    {
      return pBuffer;
    }

    pList->GetNext(pos);
  }

  return 0;
}


// ------------------------------------------------------------------------
// CBaseAllocator overrides

void CRecCache::Free()
{
}

//
// just remember the numbers
//
STDMETHODIMP
CRecCache::SetProperties(
  ALLOCATOR_PROPERTIES* pRequest,
  ALLOCATOR_PROPERTIES* pActual)
{
  CAutoLock cObjectLock(this);
  CheckPointer(pRequest, E_POINTER);
  CheckPointer(pActual, E_POINTER);
  ValidateReadWritePtr(pActual, sizeof(ALLOCATOR_PROPERTIES));

  ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

  ASSERT(pRequest->cbBuffer > 0);

  /* Can't do this if already committed, there is an argument that says we
     should not reject the SetProperties call if there are buffers still
     active. However this is called by the source filter, which is the same
     person who is holding the samples. Therefore it is not unreasonable
     for them to free all their samples before changing the requirements */

  if (m_bCommitted) {
    return VFW_E_ALREADY_COMMITTED;
  }

  /* Must be no outstanding buffers */

  if (m_lAllocated != m_lFree.GetCount()) {
    return VFW_E_BUFFERS_OUTSTANDING;
  }

  /* There isn't any real need to check the parameters as they
     will just be rejected when the user finally calls Commit */

  pActual->cbBuffer = m_lSize = pRequest->cbBuffer;
  pActual->cBuffers = m_lCount = pRequest->cBuffers;
  pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
  pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

  m_bChanged = TRUE;
  return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\core\simpread\simpread.h ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

//
//
// implements quartz stream handler interfaces by mapping to avifile apis.
//

// forward declarations

#ifndef __SIMPLEREADER__
#define __SIMPLEREADER__

class CReaderStream;     // owns a particular stream
class CSimpleReader;     // overall container class

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. uses IAsyncReader and not IMemInputPin

class CReaderInPin : public CBasePin
{
protected:
    class CSimpleReader* m_pFilter;

public:
    CReaderInPin(
		 class CSimpleReader *pFilter,
		 CCritSec *pLock,
		 HRESULT *phr,
		 LPCWSTR pPinName);

    virtual ~CReaderInPin();

    // CBasePin overrides
    virtual HRESULT CheckMediaType(const CMediaType* mtOut);
    virtual HRESULT CheckConnect(IPin * pPin);
    virtual HRESULT CompleteConnect(IPin *pReceivePin);
    virtual HRESULT BreakConnect();

    STDMETHODIMP BeginFlush(void) { return E_UNEXPECTED; }
    STDMETHODIMP EndFlush(void) { return E_UNEXPECTED; }
};

// CReaderStream
// represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CSimpleReader object and
// returned via the EnumPins interface.
//

class CReaderStream : public CBaseOutputPin, public CAMThread, public CSourceSeeking
{

public:

    CReaderStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CSimpleReader * pFilter,
	CCritSec *pLock,
	LPCWSTR wszPinName);

    ~CReaderStream();

    // expose IMediaPosition via CImplPosition, rest via CBaseOutputPin
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    // IPin

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    // say how big our buffers should be and how many we want
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // Override to start & stop thread
    HRESULT Active();
    HRESULT Inactive();


    // ----- called by worker thread ---

    // access the stop and rate variables used by PushLoop
    // called by worker thread and
    double GetRate(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        return m_dRate;
    }
    void SetRateInternal(double dRate) {
        // not atomic so hold critsec
        CAutoLock lock(&m_WorkerLock);
        m_dRate = dRate;
    }
    LONG GetStopAt(void) {
        // atomic so no critsec
        return m_sStopAt;
    }
    REFERENCE_TIME GetStopTime(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        return m_rtStop;
    }
    void SetStopAt(DWORD sStop, REFERENCE_TIME tStop) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        m_rtStop = tStop;
	m_sStopAt = sStop;
    }

    void SetDuration(DWORD sDuration, REFERENCE_TIME tDuration) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);

	m_sStopAt = sDuration;

        // set them in the base class
	m_rtDuration = tDuration;
	m_rtStop = tDuration;
    }

private:

    CSimpleReader * m_pFilter;

    // CSourcePosition stuff
    // the worker thread PushLoop is checking against these for every sample
    // Use Get/SetRate Get/SetStop to access from worker thread
    LONG m_sStopAt;


    HRESULT ChangeStart();
    HRESULT ChangeStop();
    HRESULT ChangeRate();

#if 0    // MIDL and structs don't match well
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
#endif
    
    double Rate() {
	return m_dRateSeeking;
    };
    CRefTime Start() {
        // not atomic, so use critsec
        ASSERT(CritCheckIn(&m_WorkerLock));
	return m_rtStart;
    };
    CRefTime Stop() {
        // not atomic, so use critsec
        ASSERT(CritCheckIn(&m_WorkerLock));
	return m_rtStop;
    };

    // worker thread stuff
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    void DoRunLoop(void);

    // return S_OK if reach sStop, S_FALSE if pos changed, or else error
    HRESULT PushLoop(
		LONG sCurrent,
		LONG sStart,
		CRefTime tStart,
		double dRate
		);

    CCritSec m_WorkerLock;
    CCritSec m_AccessLock;
    
public:
    BOOL Create();

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT RunThread();
    HRESULT StopThread();

    HRESULT ExitThread();

};

//
// CSimpleReader represents an avifile
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
//

class CSimpleReader : public CBaseFilter
{
public:

    // constructors etc
    CSimpleReader(TCHAR *, LPUNKNOWN, REFCLSID, CCritSec *, HRESULT *);
    ~CSimpleReader();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // pin enumerator calls this
    int GetPinCount();

    CBasePin * GetPin(int n);

    // input pin notifies filter of connection and gives the
    // IAsyncReader interface this way. parse the file here and create
    // output pins (leave pins in a state ready to connect downstream).
    virtual HRESULT NotifyInputConnected(IAsyncReader *pAsyncReader);

    virtual HRESULT NotifyInputDisconnected();

    // these must be overridden....
    virtual HRESULT ParseNewFile() = 0;
    virtual HRESULT CheckMediaType(const CMediaType* mtOut) = 0;
    virtual LONG StartFrom(LONG sStart) = 0;
    virtual HRESULT FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *cSamples) = 0;
    
    HRESULT SetOutputMediaType(const CMediaType* mtOut);
    
    
private:

    friend class CReaderStream;
    friend class CReaderInPin;

    CReaderStream m_Output;
    CReaderInPin m_Input;

    CCritSec *m_pLock;
    
public:
    IAsyncReader *m_pAsyncReader;
    DWORD	m_sLength;

protected:
    // returns the sample number starting at or after time t
    virtual LONG RefTimeToSample(CRefTime t) = 0;

    // returns the RefTime for s (media time)
    virtual CRefTime SampleToRefTime(LONG s) = 0;

    virtual ULONG GetMaxSampleSize() = 0;
};


#endif // __SIMPLEREADER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\audmix.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: audmix.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>

#include "AudMix.h"
#include "prop.h"
#include "..\util\filfuncs.h"
#include "..\util\dexmisc.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

#define MAX_LONG 0x7fffffff
#define MAX_REFERENCE_TIME 0x7fffffffffffffff

#define HOT_JUMP_SLOPE 5000
#define MAX_CLIP 5000

//############################################################################
// 
//############################################################################

void CAudMixer::ClearHotnessTable( )
{
    for( int i = 0 ; i < HOTSIZE ; i++ )
    {
        m_nHotness[i] = 32767L;
    }
    m_nLastHotness = 32767;
}

//
// Constructor
//
CAudMixer::CAudMixer(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    CPersistStream(pUnk, phr),
    m_InputPinsList(NAME("AudMixer Input Pins list")),
    m_cInputs(0), 
    m_pOutput(NULL),
    m_iOutputBufferCount(4),      //4 buffers
    // !!! needs to be as big as input buffers!
    m_msPerBuffer(250),  //250 mSecond/buffer
    CBaseFilter(NAME("AudMixer"), pUnk, this, CLSID_AudMixer),
    m_fEOSSent(FALSE),
    m_rtLastStop(0),    //??? can be set by APP
    m_cFlushDelivery(0), m_bNewSegmentDelivered(FALSE),
    m_pPinMix(NULL), m_pPinTemp(NULL), m_pStartTemp(NULL), m_pStopTemp(NULL)
{
    ASSERT(phr);

    // set default mixer mediatype that we accept
    //
    m_MixerMt.majortype = MEDIATYPE_Audio;
    m_MixerMt.subtype = MEDIASUBTYPE_PCM;
    m_MixerMt.formattype = FORMAT_WaveFormatEx;
    m_MixerMt.AllocFormatBuffer( sizeof( WAVEFORMATEX ) );

    // set the mediatype format block
    //
    WAVEFORMATEX * vih = (WAVEFORMATEX*) m_MixerMt.Format( );
    ZeroMemory( vih, sizeof( WAVEFORMATEX ) );
    vih->wFormatTag = WAVE_FORMAT_PCM;
    vih->nChannels = 2;
    vih->nSamplesPerSec = 44100;
    vih->nBlockAlign = 4;
    vih->nAvgBytesPerSec = vih->nBlockAlign * vih->nSamplesPerSec;
    vih->wBitsPerSample = 16;

    m_MixerMt.SetSampleSize(vih->nBlockAlign);  //lSampleSize

    // clear the input pins list (it should already be blank anyhow)
    InitInputPinsList();
    // Create a single input pin at this time and add it to the list
    CAudMixerInputPin *pInputPin = CreateNextInputPin(this);

    // create the single output pin as well
    m_pOutput = new CAudMixerOutputPin(NAME("Output Pin"), this, phr, L"Output");

    ClearHotnessTable( );

} /* CAudMixer::CAudMixer */


//############################################################################
// 
//############################################################################

//
// Destructor
//
CAudMixer::~CAudMixer()
{
    // clear out the input pins
    //
    InitInputPinsList();

    // delete the output pin, too
    //
    if (m_pOutput)
    {
        delete m_pOutput;
    }

    // free the media type format block
    //
    SaferFreeMediaType(m_MixerMt);

} /* CAudMixer::~CAudMixer */


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::Pause()
{
    CAutoLock cAutolock(m_pLock);
 
    // if we're going into paused mode from stopped, allocate a bunch of
    // arrays for mixing. 
    //
    m_rtLastStop=0;
    if (m_State == State_Stopped) 
    {
        ClearHotnessTable( );

        m_pPinTemp = (CAudMixerInputPin **)QzTaskMemAlloc(m_cInputs *
                    sizeof(CAudMixerInputPin *));
        if (m_pPinTemp == NULL)
            goto Pause_Error;
            m_pPinMix = (BYTE **)QzTaskMemAlloc(m_cInputs *
                        sizeof(CAudMixerInputPin *));
        if (m_pPinMix == NULL)
            goto Pause_Error;
            m_pStartTemp = (REFERENCE_TIME *)QzTaskMemAlloc(m_cInputs *
                        sizeof(REFERENCE_TIME));
        if (m_pStartTemp == NULL)
            goto Pause_Error;
            m_pStopTemp = (REFERENCE_TIME *)QzTaskMemAlloc(m_cInputs *
                        sizeof(REFERENCE_TIME));
        if (m_pStopTemp == NULL)
            goto Pause_Error;
    }
    // !!! check the return value of pause to make sure to leave these arrays
    // allocated
    //
    return CBaseFilter:: Pause();       

Pause_Error:

    // free up our arrays
    //
    if (m_pPinTemp)
    QzTaskMemFree(m_pPinTemp);
    m_pPinTemp = 0;
    if (m_pPinMix)
    QzTaskMemFree(m_pPinMix);
    m_pPinMix = 0;
    if (m_pStartTemp)
    QzTaskMemFree(m_pStartTemp);
    m_pStartTemp = 0;
    if (m_pStopTemp)
    QzTaskMemFree(m_pStopTemp);
    m_pStopTemp = 0;
    return E_OUTOFMEMORY;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::Stop()
{
    CAutoLock cAutolock(m_pLock);

    // make sure receive is done, or freeing these things will fault!
    CAutoLock foo(&m_csReceive);

    // free up our arrays. This looks suspiciously like the above free methods
    //
    if (m_pPinTemp)
    QzTaskMemFree(m_pPinTemp);
    m_pPinTemp = 0;
    if (m_pPinMix)
    QzTaskMemFree(m_pPinMix);
    m_pPinMix = 0;
    if (m_pStartTemp)
    QzTaskMemFree(m_pStartTemp);
    m_pStartTemp = 0;
    if (m_pStopTemp)
    QzTaskMemFree(m_pStopTemp);
    m_pStopTemp = 0;

    return CBaseFilter::Stop();       
}

//############################################################################
// 
//############################################################################

//
// GetPinCount
//
int CAudMixer::GetPinCount()
{
    return 1 + m_cInputs;
} /* CAudMixer::GetPinCount */


//############################################################################
// 
//############################################################################

//
// GetPin
//
CBasePin *CAudMixer::GetPin(int n)
{
    // Pin zero is the one and only output pin
    if( n == 0 )
    return m_pOutput;

    // return the input pin at position(n) (zero based)  We can use n, and not
    // n-1, because we have already decremented n if an Output pin exists.
    return GetPinNFromList(n-1);

} /* CAudMixer::GetPin */

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IAudMixer) {
    return GetInterface((IAudMixer *) this, ppv);
    } else  if (IsEqualIID(IID_ISpecifyPropertyPages, riid)) {
    return GetInterface((ISpecifyPropertyPages *)this, ppv);
    } else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    } else {
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
} // NonDelegatingQueryInterface


//############################################################################
// 
//############################################################################

//
// IPersistStream method
//
STDMETHODIMP CAudMixer::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_AudMixer;
    return S_OK;  
}


//############################################################################
// 
//############################################################################

typedef struct {
    int version;    // version
    AM_MEDIA_TYPE mt;    // audio mixer format is hidden after the array
    int cBuffers;    // OutputBufferNumber
    int msBuffer;    // OutputBuffermSecond
    int nInputPins;    // total input pin number m_cInputs
    int cbExtra;    // m_MixerMt.cbFormat+ all input pin's Envelope table +output pin's Envelope table
    LPBYTE pExtra;
    // format is hidden here
    // also hidden here is the list of envelopes and ranges
} saveMix;


//
// IPersistStream method
//
// persist ourself - we have a bunch of random stuff to save, our media type
// (sans format), an array of queued connections, and finally the format of
// the media type
//
HRESULT CAudMixer::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CAudMixer::WriteToStream")));
    CheckPointer(pStream, E_POINTER);

    // we're looking at the envelope, which can change at any moment
    CAutoLock l(&m_csVol);

    saveMix *px;

    // how big will our saved data be?
    int nEnvelopes = 0;
    int savesize = sizeof(saveMix) - sizeof(LPBYTE) + m_MixerMt.cbFormat;

    //memory space for saving all input pin's Envelope table
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
    savesize += sizeof(int) + pInputPin->m_VolumeEnvelopeEntries *
                        sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    savesize += sizeof(int) + pInputPin->m_cValid * sizeof(REFERENCE_TIME)
                    * 2;
    }

    //memory space for saving the output pin's Envelope talbe
    savesize += sizeof(int) + m_pOutput->m_VolumeEnvelopeEntries *
                        sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);

    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));

    px = (saveMix *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
    return E_OUTOFMEMORY;
    }

    //
    px->version = 1;
    px->mt = m_MixerMt; // AM_MEDIA_TYPE
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk = NULL;        // !!!
    px->nInputPins = m_cInputs;
    px->cBuffers = m_iOutputBufferCount;
    px->msBuffer = m_msPerBuffer;

    // the format goes after the array
    LPBYTE pSave = (LPBYTE)&px->pExtra;
    CopyMemory(pSave, m_MixerMt.pbFormat, m_MixerMt.cbFormat);
    int cbExtra = m_MixerMt.cbFormat;
    pSave += m_MixerMt.cbFormat;

    // then comes the input pins envelopes and ranges prefixed by the number for each pin
    pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        nEnvelopes = (int)pInputPin->m_VolumeEnvelopeEntries;
        *(int *)pSave = nEnvelopes;
    pSave += sizeof(int);
    if (nEnvelopes)
        CopyMemory(pSave, pInputPin->m_pVolumeEnvelopeTable, nEnvelopes *
                sizeof(DEXTER_AUDIO_VOLUMEENVELOPE));
    pSave += nEnvelopes * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);


        int nRanges = (int)pInputPin->m_cValid;
        *(int *)pSave = nRanges;
    pSave += sizeof(int);
    if (nRanges)
        CopyMemory(pSave, pInputPin->m_pValidStart, nRanges *
                        sizeof(REFERENCE_TIME));
    pSave += nRanges * sizeof(REFERENCE_TIME);
    if (nRanges)
        CopyMemory(pSave, pInputPin->m_pValidStop, nRanges *
                        sizeof(REFERENCE_TIME));
    pSave += nRanges * sizeof(REFERENCE_TIME);

    cbExtra += 2 * sizeof(int) + nEnvelopes *
        sizeof(DEXTER_AUDIO_VOLUMEENVELOPE) + nRanges * 2 *
        sizeof(REFERENCE_TIME);
    }

    // then comes the output pin envelopes and ranges prefixed by the number for each pin
    nEnvelopes = (int)m_pOutput->m_VolumeEnvelopeEntries;
    *(int *)pSave = nEnvelopes;
    pSave += sizeof(int);
    if (nEnvelopes)
        CopyMemory(pSave, m_pOutput->m_pVolumeEnvelopeTable, nEnvelopes *
            sizeof(DEXTER_AUDIO_VOLUMEENVELOPE));
    pSave += nEnvelopes * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);

    cbExtra +=  sizeof(int) + nEnvelopes * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    

    px->cbExtra = cbExtra;    // how big the extra stuff is


    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

//
// IPersistStream method
//
// load ourself back in
//
HRESULT CAudMixer::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CAudMixer::ReadFromStream")));
    CheckPointer(pStream, E_POINTER);

    // we don't yet know how big the save data is...
    // all we know we have for sure is the beginning of the struct
    int savesize1 = sizeof(saveMix) - sizeof(LPBYTE);
    saveMix *px = (saveMix *)QzTaskMemAlloc(savesize1);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
        return E_OUTOFMEMORY;
    }
    
    HRESULT hr = pStream->Read(px, savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if (px->version != 1) {
        DbgLog((LOG_ERROR,1,TEXT("*** ERROR! Bad version file")));
        QzTaskMemFree(px);
        return S_OK;
    }

    // how much saved data was there, really?  Get the rest
    int savesize = savesize1 + px->cbExtra;
    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));
    px = (saveMix *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
        return E_OUTOFMEMORY;
    }

    LPBYTE pSave = (LPBYTE)&px->pExtra;
    hr = pStream->Read(pSave, savesize - savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    // create the rest of the input pins we need
    for (int x=1; x<px->nInputPins; x++) {
        CAudMixerInputPin *pInputPin = CreateNextInputPin(this);
        if(pInputPin != NULL)
            IncrementPinVersion();
    }

    AM_MEDIA_TYPE mt = px->mt;
    mt.pbFormat = (BYTE *)QzTaskMemAlloc(mt.cbFormat);
    // remember, the format is after the array
    CopyMemory(mt.pbFormat, pSave, mt.cbFormat);
    pSave += mt.cbFormat;

    set_OutputBuffering(px->cBuffers, px->msBuffer);

    // then comes the envelopes and ranges prefixed by the number for each pin
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        int nEnvelopes = *(int *)pSave;
        pSave += sizeof(int);
        pInputPin->put_VolumeEnvelope((DEXTER_AUDIO_VOLUMEENVELOPE *)pSave,
                        nEnvelopes);
        pSave += nEnvelopes * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
        int nRanges = *(int *)pSave;
        pSave += sizeof(int);
        pInputPin->InvalidateAll();
        REFERENCE_TIME *pStart = (REFERENCE_TIME *)pSave;
        pSave += nRanges * sizeof(REFERENCE_TIME);
        REFERENCE_TIME *pStop = (REFERENCE_TIME *)pSave;
        pSave += nRanges * sizeof(REFERENCE_TIME);
        for (x=0; x<nRanges; x++) {
            pInputPin->ValidateRange(*pStart, *pStop);
            pStart++; pStop++;
        }
    }

    // then comes the envelopes for ouput pin
    int nEnvelopes = *(int *)pSave;
    pSave += sizeof(int);

    if( nEnvelopes )
    {
        m_pOutput->put_VolumeEnvelope((DEXTER_AUDIO_VOLUMEENVELOPE *)pSave,
                        nEnvelopes);
        pSave += nEnvelopes * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    }
    
    put_MediaType(&mt);
    SaferFreeMediaType(mt);
    QzTaskMemFree(px);
    return S_OK;
}

//############################################################################
// 
//############################################################################

// how big is our save data?
//
int CAudMixer::SizeMax()
{
    int savesize = sizeof(saveMix) - sizeof(LPBYTE) + m_MixerMt.cbFormat;
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
    savesize += sizeof(int) + pInputPin->m_VolumeEnvelopeEntries *
                        sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    savesize += sizeof(int) + pInputPin->m_cValid * sizeof(REFERENCE_TIME)
                    * 2;
    }

    // output pin
    savesize += sizeof(int) + m_pOutput->m_VolumeEnvelopeEntries *
                        sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    
    return savesize;
}



//############################################################################
// this returns the next enumerated pin, used for property pages. 
//############################################################################

STDMETHODIMP CAudMixer::NextPin(IPin **ppIPin)
{
    CAutoLock ListLock(&m_csPinList);
    POSITION pos = m_InputPinsList.GetHeadPosition();
    

    //find first not shown input pin
    int i=m_cInputs - m_ShownPinPropertyPageOnFilter;
    int j=0;
    CAudMixerInputPin *pInputPin=NULL;
    while(i>j)
    {
       pInputPin = m_InputPinsList.GetNext(pos);
       i--;
    }

    if(pInputPin)
    {
    *ppIPin=(IPin *) pInputPin;
    }
    else
    {
    //output pin
    if( m_pOutput )
    {
        ASSERT(m_cInputs==m_ShownPinPropertyPageOnFilter);
        *ppIPin=(IPin *)  m_pOutput;
    }

    }

    ASSERT(*ppIPin!=NULL);
    m_ShownPinPropertyPageOnFilter++;
    return NOERROR;
}


//############################################################################
// 
//############################################################################

//
// InitInputPinsList
//
void CAudMixer::InitInputPinsList()
{
    // Release all pins in the list and remove them from the list.
    CAutoLock ListLock(&m_csPinList);
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        pInputPin->Release();
    }
    m_cInputs = 0;     // Reset the pin count to 0.
    m_InputPinsList.RemoveAll();

} /* CAudMixer::InitInputPinsList */

//############################################################################
// 
//############################################################################

//
// CreateNextInputPin
//
CAudMixerInputPin *CAudMixer::CreateNextInputPin(CAudMixer *pFilter)
{
    DbgLog((LOG_TRACE,1,TEXT("CAudMixer: Create an input pin")));

    TCHAR szbuf[16];        // Temporary scratch buffer, can be smaller depending on max # of input pins
    int NextInputPinNumber =m_cInputs+1; // Next number to use for pin
    HRESULT hr = NOERROR;

    wsprintf(szbuf, TEXT("Input%d"), NextInputPinNumber);
#ifdef _UNICODE
    CAudMixerInputPin *pPin = new CAudMixerInputPin(NAME("Mixer Input"), pFilter,
        &hr, szbuf, NextInputPinNumber);
#else
    WCHAR wszbuf[16];
// SEC: string
    ::MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szbuf, -1, wszbuf, 16 );
    CAudMixerInputPin *pPin = new CAudMixerInputPin(NAME("Mixer Input"), pFilter,
        &hr, wszbuf, NextInputPinNumber);
#endif

    if( FAILED( hr ) || pPin == NULL )
    {
        delete pPin;
        pPin = NULL;
    }
    else
    {
        pPin->AddRef();
    pFilter->m_cInputs++;
    pFilter->m_InputPinsList.AddTail(pPin);
    }

    return pPin;
} /* CAudMixer::CreateNextInputPin */


//############################################################################
// 
//############################################################################

//
// DeleteInputPin
//
void CAudMixer::DeleteInputPin(CAudMixerInputPin *pPin)
{
    // Iterate our input pin list looking for the specified pin.
    // If we find the pin, delete it and remove it from the list.
    CAutoLock ListLock(&m_csPinList);
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        POSITION posold = pos;         // Remember this position
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        if( pInputPin == pPin )
        {
            m_InputPinsList.Remove(posold);
            m_cInputs--;
            IncrementPinVersion();
            
            delete pPin;
            break;
        }
    }
} /* CAudMixer::DeleteInputPin */


//############################################################################
// 
//############################################################################

//
// GetNumFreePins
//
int CAudMixer::GetNumFreePins()
{
    // Iterate our pin list, counting pins that are not connected.
    int n = 0;
    CAutoLock ListLock(&m_csPinList);
    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        if( !pInputPin->IsConnected() )
        {
            n++;
        }
    }
    return n;
} /* CAudMixer::GetNumFreePins */


//############################################################################
// 
//############################################################################

//
// GetPinNFromList
//
CAudMixerInputPin *CAudMixer::GetPinNFromList(int n)
{
    CAudMixerInputPin *pInputPin = NULL;
    // Validate the position being asked for
    CAutoLock ListLock(&m_csPinList);
    if( n < m_cInputs && n >= 0 )
    {
        // Iterate through the list, returning the pin at position n+1
        POSITION pos = m_InputPinsList.GetHeadPosition();
        n++;        // Convert zero starting index to 1

        while( n )
        {
            pInputPin = m_InputPinsList.GetNext(pos);
            n--;
        }
    }
    return pInputPin;
} /* CAudMixer::GetPinNFromList */

//############################################################################
// We have to inform the pospassthru about the input pins. Called by an
// output pin.
// !!! move this function to the output pin's?
//############################################################################

HRESULT CAudMixer::SetInputPins()
{
    HRESULT hr = S_OK;
    CAudMixerInputPin **ppInputPins, *pPin;

    // Iterate the list of input pins, storing all connected input pins
    // in an array.  Pass this array to CMultiPinPosPassThru::SetPins.
    ppInputPins = new CAudMixerInputPin * [m_cInputs];
    if( !ppInputPins )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        //--- fill in the array of input pins
        int i = 0;
        CAutoLock ListLock(&m_csPinList);
        POSITION pos = m_InputPinsList.GetHeadPosition();
        while( pos )
        {
            pPin = m_InputPinsList.GetNext(pos);
            if( pPin->IsConnected() )
            {
                ppInputPins[i++] = pPin;
            }
        }

    if (m_pOutput)
        hr = m_pOutput->m_pPosition->SetPins( (CBasePin**)ppInputPins, NULL, i );
    }

    delete [] ppInputPins;
    return hr;

} /* CAudMixer::SetInputPins */

//############################################################################
// 
//############################################################################

//
// ISpecifyPropertyPages
//
STDMETHODIMP CAudMixer::GetPages(CAUUID *pPages)
{
    pPages->cElems = m_pOutput ? (2 + m_cInputs): (1+m_cInputs);  //1 for output, 1 for filter
    

    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*(pPages->cElems));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    
    //Filter property page
    pPages->pElems[0] = CLSID_AudMixPropertiesPage;

    // Input pin property page 
    for ( int i=1; i<= m_cInputs; i++)
        pPages->pElems[i] = CLSID_AudMixPinPropertiesPage;

    // Output pin Property page
    if( m_pOutput )
    pPages->pElems[i] = CLSID_AudMixPinPropertiesPage;

    //to show all pins property page,
    //m_ShownPinPropertyPageOnFilter can only modified by this function and NextPin() function
    m_ShownPinPropertyPageOnFilter = 0;

    return NOERROR;
}

//############################################################################
// called from input pin's ClearCachedData. Every input pin that gets
// told to ClearCachedData will flush the output pin's volenventry. wonder why?
//############################################################################

void CAudMixer::ResetOutputPinVolEnvEntryCnt()
{
    if(m_pOutput) 
    {
        m_pOutput->m_iVolEnvEntryCnt=0;
    }
}

//############################################################################
// 
//############################################################################


// IAudMixer
STDMETHODIMP CAudMixer::get_MediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(m_pLock);

    CheckPointer(pmt,E_POINTER);
    
    return CopyMediaType(pmt, &m_MixerMt);
}

//############################################################################
// 
// Media type can be changed only if the output pin is not connected yet.
//
//############################################################################

// IAudMixer
STDMETHODIMP CAudMixer::put_MediaType(const AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(m_pLock);

    CheckPointer(pmt,E_POINTER);
    DbgLog((LOG_TRACE, 1, TEXT("CAudMixer::put_MediaType")));
    
    //if output already connected, refuse get new number
    if(m_pOutput)
    if ( m_pOutput->IsConnected() )
        return VFW_E_ALREADY_CONNECTED;

    POSITION pos = m_InputPinsList.GetHeadPosition();
    while( pos )
    {
        CAudMixerInputPin *pInputPin = m_InputPinsList.GetNext(pos);
        if( pInputPin && pInputPin->IsConnected() )
        return VFW_E_ALREADY_CONNECTED;
    }
   
    //check media 
    if( (pmt->majortype  != MEDIATYPE_Audio )    ||
    (pmt->subtype     != MEDIASUBTYPE_PCM)    ||
    (pmt->formattype != FORMAT_WaveFormatEx)||
    (pmt->cbFormat     < sizeof( WAVEFORMATEX ) ) )
    return VFW_E_TYPE_NOT_ACCEPTED;

    //only support 8, 16bits, pcm, mono or stereo
    WAVEFORMATEX * vih = (WAVEFORMATEX*) (pmt->pbFormat);
    
    if( ( vih->nChannels > 2)  ||
    ( vih->nChannels <1 )  ||
    ( ( vih->wBitsPerSample != 16 ) && 
      ( vih->wBitsPerSample != 8 )  ) )
      return VFW_E_TYPE_NOT_ACCEPTED;

    // !!! only accept 16 bit for now
    //
    if( vih->wBitsPerSample != 16 )
    {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    SaferFreeMediaType(m_MixerMt);
    // reconnect input pins?
    return CopyMediaType(&m_MixerMt, pmt);
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::put_InputPins( long Pins )
{
    if( m_cInputs >= Pins )
    {
        return NOERROR;
    }
    long diff = Pins - m_cInputs;
    for( long i = 0 ; i < diff ; i++ )
    {
        CAudMixerInputPin * pPin = CreateNextInputPin( this );
        if( !pPin )
        {
            // let the destructor take care of cleaning up pins
            //
            return E_OUTOFMEMORY;
        }
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::set_OutputBuffering(const int iNumber, const int mSecond )
{
    DbgLog((LOG_TRACE, 1, TEXT("CAudMixer: %d buffers %dms"), iNumber, mSecond));
    if(m_pOutput)
    {
        if ( m_pOutput->IsConnected() )
            return VFW_E_ALREADY_CONNECTED;
    }
    m_iOutputBufferCount=iNumber;
    m_msPerBuffer=mSecond; return NOERROR;
}

STDMETHODIMP CAudMixer::get_OutputBuffering( int *piNumber, int *pmSecond )
{ 
    CheckPointer( piNumber, E_POINTER );
    CheckPointer( pmSecond, E_POINTER );
    *piNumber=m_iOutputBufferCount;
    *pmSecond=m_msPerBuffer; return NOERROR;
}

//############################################################################
// called by the RenderEngine to wholesale clear all our pin's envelope
// boundaries
//############################################################################

STDMETHODIMP CAudMixer::InvalidatePinTimings( )
{
    for( int i = 0 ; i < m_cInputs ; i++ )
    {
        CAudMixerInputPin * pPin = GetPinNFromList( i );
        pPin->InvalidateAll( );
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixer::get_CurrentAveragePower(double *pdAvePower)
{
    return E_NOTIMPL;
}

//############################################################################
// global function that sets a pin's property setter
//############################################################################

HRESULT PinSetPropertySetter( IAudMixerPin * pPin, const IPropertySetter * pSetter )
{
    CheckPointer( pPin, E_POINTER );
    CheckPointer( pSetter, E_POINTER );

    HRESULT hr;

    long Params = 0;
    DEXTER_PARAM * pParam = NULL;
    DEXTER_VALUE * pValue = NULL;
    IPropertySetter * ps = (IPropertySetter*) pSetter;
    hr = ps->GetProps( &Params, &pParam, &pValue );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // no parameters, so do nothing
    //
    if( Params == 0 )
    {
        return NOERROR;
    }

    long ValueOffset = 0;
    for( int i = 0 ; i < Params ; i++ )
    {
        DEXTER_PARAM * p = pParam + i;
        if( !DexCompareW(p->Name, L"Vol" ))
        {
            // found a volume param, go look at the values
            //
            long index = ValueOffset;
            long values = p->nValues;

            DEXTER_AUDIO_VOLUMEENVELOPE * pEnv = new DEXTER_AUDIO_VOLUMEENVELOPE[values];
            if( !pEnv )
            {
                return E_OUTOFMEMORY;
            }

            for( int v = 0 ; v < values ; v++ )
            {
                DEXTER_VALUE * dvp = pValue + v + index;
                VARIANT var = dvp->v;
                VARIANT var2;
                VariantInit( &var2 );
                hr = VariantChangeTypeEx( &var2, &var, US_LCID, 0, VT_R8 );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    // !!! what should we do here?
                    //
                    delete [] pEnv;
                    return hr;
                }
                double level = 0.0;
                level = var2.dblVal;
                REFERENCE_TIME time = dvp->rt;
                pEnv[v].rtEnd = time;
                pEnv[v].dLevel = level;
                if( dvp->dwInterp == DEXTERF_JUMP )
                {
                    pEnv[v].bMethod = DEXTER_AUDIO_JUMP;
                }
                else if( dvp->dwInterp == DEXTERF_INTERPOLATE )
                {
                    pEnv[v].bMethod = DEXTER_AUDIO_INTERPOLATE;
                }
                else
                {
                    pEnv[v].bMethod = DEXTER_AUDIO_JUMP;
                }
            } // for all values for this param

            hr = pPin->put_VolumeEnvelope( pEnv, values );
	        delete [] pEnv;
            if( FAILED( hr ) )
            {
                return hr;
            }
        } // if it was "Vol"

        // !!! other Param types go here, like "Pan"
        // !!! what about other types that aren't recognized?

        // keep track of this
        //
        ValueOffset += p->nValues;

    } // for all Params

    hr = ps->FreeProps( Params, pParam, pValue );

    return NOERROR;
}

//############################################################################
// called on an input pin's EndOfStream, or in an input pin's Receive.
//############################################################################

HRESULT CAudMixer::TryToMix(REFERENCE_TIME rtReceived)
{

    DbgLog((LOG_TRACE,3,TEXT("MIX: TryToMix")));

    // all done
    if (m_fEOSSent) {
        DbgLog((LOG_TRACE,3,TEXT("EOS...")));
    return S_OK;
    }

    HRESULT hr = S_OK;
    LONG lSamplesToMix = 0;
    REFERENCE_TIME rtNewSeg = 0;

    // the first input audio pin...
    //
    POSITION pos = m_InputPinsList.GetHeadPosition();

    // set this to zero, we'll add 'em up as we go
    //
    int MixedPins=0;

    // go through each pin and find out how many samples it wants to mix
    // and where it's mixing from.
    //
    while( pos )
    {
        CAudMixerInputPin * pInput = m_InputPinsList.GetNext(pos);
    
        // don't do anything if it's not connected
        //
        if( !pInput->IsConnected( ) )
        {
            continue;
        }

        // don't do anything if this pin isn't enabled
        //
        BOOL fEnable = pInput->m_fEnable;
        if(fEnable==FALSE)
        {
            continue;
        }    

            // !!! optimize this
            //
        int count = pInput->m_SampleList.GetCount();
        if (count == 0) 
        {
            if( !pInput->m_fEOSReceived && ( pInput->IsValidAtTime( rtReceived ) == TRUE ) )
            {
                // we're expecting data from this pin.  Wait for it
                DbgLog((LOG_TRACE,3,TEXT("Still waiting for pin %d"), pInput->m_iPinNo));
                return S_OK;
            }

            continue;
        }
    
        //get the sample
        //
        IMediaSample *pSample = pInput->GetHeadSample();

        //get this sample's start and stop time.
        //
        REFERENCE_TIME        rtStart, rtStop;
        hr = pSample->GetTime( &rtStart, &rtStop );
        ASSERT(SUCCEEDED(hr));

        // add in the segment's times?
        //
        rtStart += pInput->m_tStart;
        rtStop += pInput->m_tStart;

        // set the variables in our array that tell what we're mixing
        //
        m_pPinTemp[MixedPins] = pInput;
        m_pStartTemp[MixedPins]     = rtStart; 
        m_pStopTemp[MixedPins]     = rtStop;

        // how many samples are we mixing? (left and right combined)
        //
        LONG ll = pSample->GetActualDataLength() / m_pOutput->BytesPerSample();

        // if we're the first pin, save off how many samples, so we can
        // make sure all other pins try to mix the same
        //
        if (MixedPins == 0) 
        {
            rtNewSeg = pInput->m_tStart;
            lSamplesToMix = ll;
        } 
        else if (lSamplesToMix != ll) 
        {
            ASSERT(FALSE);
            m_pOutput->DeliverEndOfStream();	// don't hang
            return E_FAIL;
        }

        // All pins should receive samples with equal time stamps
        //
        if (MixedPins > 0) 
        {
            if (m_pStartTemp[MixedPins-1] != rtStart || m_pStopTemp[MixedPins-1] != rtStop) 
            {
                ASSERT(FALSE);
                m_pOutput->DeliverEndOfStream();	// don't hang
                return E_FAIL;
            }
        }
    
        ASSERT( MixedPins < m_cInputs );
        MixedPins++;

    } //while(pos)

    // did we find any pins to mix? If not, send EOS and return
    //
    if(!MixedPins)
    {
        m_fEOSSent = TRUE;
        DbgLog((LOG_TRACE,3,TEXT("All done!")));
        return m_pOutput->DeliverEndOfStream();
    }

    // this is the time we start mixing
    //
    REFERENCE_TIME rtStart = m_pStartTemp[0];
    REFERENCE_TIME rtStop = m_pStopTemp[0];

    DbgLog((LOG_TRACE,3,TEXT("Mix %d pins, (%d, %d)"), MixedPins,
             (int)(rtStart / 10000), (int)(rtStop / 10000)));
    DbgLog((LOG_TRACE,3,TEXT("Mix %d samples"), lSamplesToMix));

    //get the output buffer
    //
    IMediaSample *pOutSample;
    rtStart -= rtNewSeg; // don't use NewSeg
    rtStop -= rtNewSeg;
    hr = m_pOutput->m_pAllocator->GetBuffer( &pOutSample, &rtStart, &rtStop, 0 );
    if (FAILED(hr))
    {
        return hr;
    }

    // get output buffer size
    //
    LONG lSize = pOutSample->GetSize() / m_pOutput->BytesPerSample();

    // if our buffer's too small, we're dead
    //
    if (lSize < lSamplesToMix)
    {
        ASSERT(FALSE); // leak
        return E_FAIL;
    }

    long DiscontOverdrive = 0;
    long Channels = m_pOutput->BytesPerSample() / ( m_pOutput->BitsPerSample() / 8 );
    long SamplesT = lSamplesToMix * Channels;

    long x; // always set below, ignore warning
    long dx; // always set below, ignore warning

remix:

    // load up our array of pointers
    //
    for(int j=0; j<MixedPins; j++)
    {
        IMediaSample *pSample = m_pPinTemp[j]->GetHeadSample();
        pSample->GetPointer(&m_pPinMix[j]);
    }

    // get the pointer to the output buffer
    //
    BYTE * pOut;
    pOutSample->GetPointer(&pOut);
    
#ifdef DEBUG
    static long lTotalSamplesMixed = 0;
    static DWORD dwTotalTime = 0;
    static double avgTime = 0.0;
    static DWORD dwMinTime = 0;
    static DWORD dwMaxTime = 0;
#endif

#ifdef DEBUG
    DWORD tick = timeGetTime();
#endif

    if( MixedPins > 1 )
    {
        // calculate the maximum hotness for the last HOTSIZE
        // buffers we processed. This allows the ramp to change
        // more slowly over time, almost like an average
        //
        long max = 0;
        for( int l = 0 ; l < HOTSIZE ; l++ )
        {
            max = max( max, m_nHotness[l] );
        }

        // if we didnt' have to remix because of a large jump in the audio,
        // then figure out the ramp
        //
        if( DiscontOverdrive == 0 )
        {
            // we need to ramp audio from the last one to the current one
            //
            long rLastMax = 32767 * 32768 / m_nLastHotness;
            long rMax = 32767 * 32768 / max;
            DbgLog( ( LOG_TRACE, 2, "lhot: %ld, max: %ld, r: %ld to %ld", m_nLastHotness, max, rLastMax - 32768, rMax - 32768 ) );
            m_nLastHotness = max;

            // set the starting dividend, and the deltra increasor,
            // sorta like brezenham's or something
            //
            x = rLastMax;
            dx = ( rMax - rLastMax ) / SamplesT;
        }

        // set the max hotness to "full volume", if it gets hotter,
        // this number will only increase. (thus, it's never possible for
        // a hotness value in the hot array to be BELOW this maximum)
        //
        long max_pre = 32767;
        long max_post = 32767;
#ifdef DEBUG
        static long avgmaxclip = 0;
        static long avgmaxclipsamples = 0;
#endif

        __int16 * pDest = (__int16*) pOut;

        for( l = SamplesT - 1 ; l >= 0 ; l-- )
        {
            // add each of the pins
            //
            register t = 0;
            for( j = MixedPins - 1 ; j >= 0 ; j-- )
            {
                // this is an array of pointers to bytes
                t += *((short*)(m_pPinMix[j]));
                m_pPinMix[j] += 2;
            }

            // see how much it's over driving the signal, if any
            // half-wave analysis is good enough
            //
            if( t > max_pre )
            {
                max_pre = t;
            }

            // multiply by the ramp to apply the volume envelope limiter
            // if our input signal is just clipping, hotness will be 32768,
            // and x = 32767 * 32768 / 32768. so t = t * 32767 * 32768 / ( 32768 * 32768 ),
            // or t = t * 32767 / 32768, and if t = 32768, then t = 32767. So 
            // it all works. No off by 1 errors.
            //
            t *= x;
            t = t >> 15;

            // ramp the volume divider to where it's supposed to end up
            //
            x = x + dx;

            // clip the result so we don't hear scratchies
            //
            if( t > 32767L )
            {
                // half-wave analysis is good enough
                max_post = max( max_post, t );

                t = 32767L;
            }
            else if( t < -32768L )
            {
                t = -32768L;
            }

#ifdef DEBUG
            avgmaxclip = avgmaxclip + max_post;
            avgmaxclipsamples++;
#endif

            *pDest++ = (__int16) t;
        }

        // if the maximum clip was too much, we need to stick in
        // a discontinuity for the hotness, go back and remix
        //
        if( max_post > MAX_CLIP + 32768 )
        {
            // force a discontinuity
            //
            DbgLog( ( LOG_TRACE, 2, "WAYYYYYYYYYY too hot (%ld), remixing with discontinuity jump", max_pre ) );
            DiscontOverdrive = max_pre;
            dx = 0;
            x = 32768 * 32768 / max_pre;
            goto remix;
        }

#ifdef DEBUG
        DbgLog( ( LOG_TRACE, 2, "            max = %ld, clip = %ld, avgc = %ld\r\n", max_pre, max_post - 32768, ( avgmaxclip / avgmaxclipsamples ) - 32768 ) );
#endif

        // shift the average buffer and stuff a new one in
        //
        CopyMemory( &m_nHotness[0], &m_nHotness[1], ( HOTSIZE - 1 ) * sizeof( long ) );

        // don't less hotness jump by more than a set amount, unless we got a 
        // serious discontinuity
        //
        if( DiscontOverdrive == 0 )
        {
            if( max_pre > m_nHotness[HOTSIZE-1] + HOT_JUMP_SLOPE )
            {
                max_pre = m_nHotness[HOTSIZE-1] + HOT_JUMP_SLOPE;
            }
            else if( max_pre < m_nHotness[HOTSIZE-1] - HOT_JUMP_SLOPE )
            {
                max_pre = m_nHotness[HOTSIZE-1] - HOT_JUMP_SLOPE;
            }
        }
        else
        {
            max_pre = DiscontOverdrive;
        }

        // set the new hotness
        //
        m_nHotness[HOTSIZE-1] = max_pre;
    }
    else
    {
        CopyMemory(pOut,m_pPinMix[0],m_pOutput->BytesPerSample() * lSamplesToMix);
    }

#ifdef DEBUG
    tick = timeGetTime() - tick;

    lTotalSamplesMixed++;
    dwTotalTime += tick;
    avgTime = dwTotalTime / ((double) lTotalSamplesMixed);
    if( (!dwMinTime) || (dwMinTime > tick) )
    {
        dwMinTime = tick;
    }
    if(dwMaxTime < tick)
    {
        dwMaxTime = tick;
    }

    DbgLog((LOG_TRACE, 2, TEXT("tick: %d, avgTime: %f, min: %d, max: %d"), tick, avgTime, dwMinTime, dwMaxTime));
#endif
    
    pOutSample->SetPreroll(FALSE);
    // !!! Discontinuity property
    pOutSample->SetDiscontinuity(FALSE);
    //set actual data Length
    pOutSample->SetActualDataLength(lSamplesToMix *
                        m_pOutput->BytesPerSample());

    //from new on, rtStart is the time without NewSeg
    pOutSample->SetTime(&rtStart,&rtStop);

    
    DbgLog((LOG_TRACE,3,TEXT("Delivering (%d, %d)"),
             (int)(rtStart / 10000), (int)(rtStop / 10000)));

    // Send sample downstream
    if( SUCCEEDED( hr ) )
    {
        //Pan output pin
        CMediaType *pmt=&(m_pOutput->m_mt);
        WAVEFORMATEX *pwfx    = (WAVEFORMATEX *) pmt->Format();
        if( (m_pOutput->m_dPan!=0.0) &&  (pwfx->nChannels==2) )
        PanAudio(pOut,m_pOutput->m_dPan, pwfx->wBitsPerSample, (int) lSamplesToMix);

        //apply volume envelope to output pin
        if(m_pOutput->m_pVolumeEnvelopeTable)
        {
    	    // we're looking at the envelope, which can change at any moment
    	    CAutoLock l(&m_csVol);

            // have to skew timeline time to offset time
            //
            REFERENCE_TIME Start = rtStart - m_pOutput->m_rtEnvStart;
            REFERENCE_TIME Stop = rtStop - m_pOutput->m_rtEnvStart;

            ApplyVolEnvelope( Start,  //output sample start time
                Stop,    //output sample stop time
                m_pOutput->m_rtEnvStop - m_pOutput->m_rtEnvStart, // duration of the envelope
                pOutSample,    //point to the sample
                pwfx,     //output sample format
                &(m_pOutput->m_VolumeEnvelopeEntries), //total table entries
                &(m_pOutput->m_iVolEnvEntryCnt),  //current table entry pointer
                m_pOutput->m_pVolumeEnvelopeTable); //envelope table

        }

        hr = m_pOutput->Deliver(pOutSample);
    }
    pOutSample->Release();

    for (int z=0; z<MixedPins; z++) 
    {
    IMediaSample *pSample = m_pPinTemp[z]->GetHeadSample();
    m_pPinTemp[z]->m_SampleList.RemoveHead();
    pSample->Release();
    }

    return hr;
} /* CAudMixerInputPin::TryToMix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\amextra2.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: amextra2.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>        // ActiveMovie base class definitions
#include <mmsystem.h>       // Needed for definition of timeGetTime
#include <limits.h>         // Standard data type limit definitions
#include <measure.h>        // Used for time critical log functions

#include "amextra2.h"

#pragma warning(disable:4355)


// Implements the CMultiPinPosPassThru class

// restrict capabilities to what we know about today and don't allow
// AM_SEEKING_CanGetCurrentPos and AM_SEEKING_CanPlayBackwards;
const DWORD CMultiPinPosPassThru::m_dwPermittedCaps = AM_SEEKING_CanSeekAbsolute |
    AM_SEEKING_CanSeekForwards |
    AM_SEEKING_CanSeekBackwards |
    AM_SEEKING_CanGetStopPos |
    AM_SEEKING_CanGetDuration;

CMultiPinPosPassThru::CMultiPinPosPassThru(TCHAR *pName,LPUNKNOWN pUnk) :
    m_apMS(NULL),
    m_iPinCount(0),
    CMediaSeeking(pName, pUnk)
{
}


HRESULT CMultiPinPosPassThru::SetPins(CBasePin **apPins,
				      CRefTime *apOffsets,
				      int iPinCount)
{
    int i;

    // Discard our current pointers
    ResetPins();

    // Reset our start/stop times
    m_rtStartTime = 0;
    m_rtStopTime = 0;
    m_dRate = 1.0;

    // Check that all pointers are valid
    if (!apPins) {
        DbgBreak("bad pointer");
        return E_POINTER;
    }

    // We need each pin to be connected
    for (i = 0; i < iPinCount; i++)
        if (apPins[i] == NULL)
            return E_POINTER;

    // Allocate an array of pointers to the pin's IMediaSeeking interfaces.
    m_apMS = new IMediaSeeking*[iPinCount];

    if (m_apMS == NULL) {
        return E_OUTOFMEMORY;
    }

    // Reset in case of trouble
    for (i = 0; i < iPinCount; i++) {
        m_apMS[i] = NULL;
    }

    m_iPinCount = iPinCount;

    // Get the IMediaSeeking interface for each pin
    for (i = 0; i < iPinCount; i++) {
        IPin *pConnected;

        HRESULT hr = apPins[i]->ConnectedTo(&pConnected);
        if (FAILED(hr)) {
            ResetPins();
            return hr;
        }

        IMediaSeeking * pMS;
        hr = pConnected->QueryInterface(IID_IMediaSeeking, (void **) &pMS);
        pConnected->Release();

        if (FAILED(hr)) {
            ResetPins();
            return hr;
        }
        m_apMS[i] = pMS;
    }

    // Finally set the pointer up if all went well

    m_apOffsets = apOffsets;

    //get_Duration(&m_rtStopTime);
    return NOERROR;
}


HRESULT CMultiPinPosPassThru::ResetPins(void)
{
    // Must be called when a pin is connected
    if (m_apMS != NULL) {
        for (int i = 0; i < m_iPinCount; i++)
            if( m_apMS[i] )
                m_apMS[i]->Release();

        delete [] m_apMS;
        m_apMS = NULL;
    }
    return NOERROR;
}


CMultiPinPosPassThru::~CMultiPinPosPassThru()
{
    ResetPins();
}

// IMediaSeeking methods
STDMETHODIMP CMultiPinPosPassThru::GetCapabilities( DWORD * pCapabilities )
{
	CheckPointer( pCapabilities, E_POINTER );
    // retrieve the mask of capabilities that all upstream pins
    // support
    DWORD dwCapMask = m_dwPermittedCaps;

    for(int i = 0; i < m_iPinCount; i++)
    {
        DWORD dwCaps;
        m_apMS[i]->GetCapabilities(&dwCaps);
        dwCapMask &= dwCaps;

        if(dwCapMask == 0)
            break;
    }

    *pCapabilities = dwCapMask;
    return S_OK;
}

STDMETHODIMP CMultiPinPosPassThru::CheckCapabilities( DWORD * pCapabilities )
{
	CheckPointer( pCapabilities, E_POINTER );
    // retrieve the mask of capabilities that all upstream pins
    // support

    DWORD dwCapRequested = *pCapabilities;
    (*pCapabilities) &= m_dwPermittedCaps;
    
    for(int i = 0; i < m_iPinCount; i++)
    {
        m_apMS[i]->GetCapabilities(pCapabilities);
    }

    return dwCapRequested ?
        ( dwCapRequested == *pCapabilities ? S_OK : S_FALSE ) :
        E_FAIL;
}

STDMETHODIMP CMultiPinPosPassThru::SetTimeFormat(const GUID * pFormat)
{
	CheckPointer( pFormat, E_POINTER );
	HRESULT hr = E_FAIL;

    for(int i = 0; i < m_iPinCount; i++)
    {
        hr = m_apMS[i]->SetTimeFormat( pFormat );
		if( FAILED( hr ) ) return hr;
    }

	return hr;
}

STDMETHODIMP CMultiPinPosPassThru::GetTimeFormat(GUID *pFormat)
{
	// They're all the same, so return the first
    return m_apMS[0]->GetTimeFormat( pFormat );
}

STDMETHODIMP CMultiPinPosPassThru::IsUsingTimeFormat(const GUID * pFormat)
{
	CheckPointer( pFormat, E_POINTER );
	GUID guidFmt;
	HRESULT hr = m_apMS[0]->GetTimeFormat( &guidFmt );
	if( SUCCEEDED( hr ) )
	{
		return *pFormat == guidFmt ? S_OK : S_FALSE;
	}
	return hr;
}

STDMETHODIMP CMultiPinPosPassThru::IsFormatSupported( const GUID * pFormat)
{
	CheckPointer( pFormat, E_POINTER );
	HRESULT hr = S_FALSE;

	// All inputs must support the format
    for(int i = 0; i < m_iPinCount; i++)
    {
        hr = m_apMS[i]->IsFormatSupported( pFormat );
		if( hr == S_FALSE ) return hr;
    }
	return hr;
}

STDMETHODIMP CMultiPinPosPassThru::QueryPreferredFormat( GUID *pFormat)
{
	CheckPointer( pFormat, E_POINTER );
	HRESULT hr;
	// Take the first input with a preferred format that's supported by all
	// other inputs (for now)
    for(int i = 0; i < m_iPinCount; i++)
    {
        hr = m_apMS[i]->QueryPreferredFormat( pFormat );
		if( hr == S_OK )
		{
			if( S_OK == IsFormatSupported( pFormat ) )
			{
				return S_OK;
			}
		}
    }
    return S_FALSE;
}

STDMETHODIMP CMultiPinPosPassThru::ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                               LONGLONG    Source, const GUID * pSourceFormat )
{
    // We used to check pointers here, but since we don't actually derefernce any of them here just
    // pass them through.  If anyone we call cares, they should check them.

    HRESULT hr;
    // Find an input that can do the conversion
    for(int i = 0; i < m_iPinCount; i++)
    {
	hr = m_apMS[i]->ConvertTimeFormat(pTarget, pTargetFormat, Source, pSourceFormat);
	if( hr == NOERROR ) return hr;
    }
    return E_FAIL;
}

STDMETHODIMP CMultiPinPosPassThru::SetPositions(
    LONGLONG * pCurrent, DWORD CurrentFlags,
    LONGLONG * pStop, DWORD StopFlags )
{
	CheckPointer( pCurrent, E_POINTER );
	CheckPointer( pStop, E_POINTER );

    m_rtStartTime = *pCurrent;
    m_rtStopTime = *pStop;
    
    HRESULT hr = S_OK;
    for(int i = 0; i < m_iPinCount; i++)
    {
        LONGLONG llCurrent = *pCurrent;
        LONGLONG llStop = *pStop;
        if(m_apOffsets)
        {
            llCurrent += m_apOffsets[i];
            llStop += m_apOffsets[i];
        }

        hr = m_apMS[i]->SetPositions(&llCurrent, CurrentFlags, &llStop, StopFlags);
        if(FAILED(hr))
            break;
    }

    return hr;
}


STDMETHODIMP CMultiPinPosPassThru::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    HRESULT hr = m_apMS[0]->GetPositions(pCurrent, pStop);
    if(SUCCEEDED(hr))
    {
        if(m_apOffsets)
        {
	    if (pCurrent)
		(*pCurrent) -= m_apOffsets[0];
	    if (pStop)
		(*pStop) -= m_apOffsets[0];
        }

    
        for(int i = 1; i < m_iPinCount; i++)
        {
            LONGLONG llCurrent = 0;
            LONGLONG llStop = 0;

	    if (pCurrent)
	    {
		if (pStop)
		    hr = m_apMS[i]->GetPositions(&llCurrent, &llStop);
		else
		    hr = m_apMS[i]->GetPositions(&llCurrent, NULL);
	    }
	    else
	    {
		if (pStop)
                {
		    hr = m_apMS[i]->GetPositions(NULL, &llStop);
                    ASSERT( !FAILED( hr ) );
                }
		else
		{
		    ASSERT(!"Called GetPositions with 2 NULL pointers!!");
		    break;
		}
	    }



            if(SUCCEEDED(hr))
            {
                if(m_apOffsets)
                {
		    llCurrent -= m_apOffsets[i];
		    llStop -= m_apOffsets[i];
                }

		if (pCurrent)
		    *pCurrent = min(llCurrent, *pCurrent);
		if (pStop)
		    *pStop = max(llStop, *pStop);
            }
            else
            {
                break;
            }
        }
    } 

    return hr;
}

STDMETHODIMP CMultiPinPosPassThru::GetCurrentPosition( LONGLONG * pCurrent )
{
	// This will be the same for all our inputs
	CheckPointer( pCurrent, E_POINTER );
    return m_apMS[0]->GetCurrentPosition( pCurrent );
}

STDMETHODIMP CMultiPinPosPassThru::GetStopPosition( LONGLONG * pStop )
{
    CheckPointer( pStop, E_POINTER );
    return GetPositions(NULL, pStop);
}

STDMETHODIMP CMultiPinPosPassThru::SetRate( double dRate)
{
    m_dRate = dRate;
    
    HRESULT hr = S_OK;
    for(int i = 0; i < m_iPinCount; i++)
    {
        hr =m_apMS[i]->SetRate(dRate);
        if(FAILED(hr))
            break;
    }
    return hr;
}

STDMETHODIMP CMultiPinPosPassThru::GetRate( double * pdRate)
{
	CheckPointer( pdRate, E_POINTER );
    *pdRate = m_dRate;
    return S_OK;
}

STDMETHODIMP CMultiPinPosPassThru::GetDuration( LONGLONG *pDuration)
{
    CheckPointer( pDuration, E_POINTER );
    LONGLONG llStop;
    HRESULT hr = E_FAIL;

    *pDuration = 0;

    for(int i = 0; i < m_iPinCount; i++)
    {
        hr = m_apMS[i]->GetDuration(&llStop);

        if(SUCCEEDED(hr))
            *pDuration = max(llStop, *pDuration);
        else
            break;
    }

    DbgLog((LOG_TRACE, 4, TEXT("CMultiPinPosPassThru::GetDuration returning %d"), *pDuration));
    return hr;
}

STDMETHODIMP CMultiPinPosPassThru::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
	CheckPointer( pEarliest, E_POINTER );
	CheckPointer( pLatest, E_POINTER );
	LONGLONG llMin, llMax;
	HRESULT hr = m_apMS[0]->GetAvailable( pEarliest, pLatest );

	// Return the maximum early and the minimum late times
	if( SUCCEEDED( hr ) )
	{
		for(int i = 1; i < m_iPinCount; i++)
		{
			hr = m_apMS[i]->GetAvailable( &llMin, &llMax );
			if(FAILED(hr))
				break;
			if( llMin > *pEarliest ) *pEarliest = llMin;
			if( llMax < *pLatest ) *pLatest = llMax;
		}
	}

	// Make sure our earliest time is less than or equal to our latest time
	if( SUCCEEDED( hr ) )
	{
		if( *pEarliest > *pLatest )
		{
			*pEarliest = 0;
			*pLatest = 0;
			hr = S_FALSE;
		}
	}

    return hr;
}

STDMETHODIMP CMultiPinPosPassThru::GetPreroll( LONGLONG *pllPreroll )
{
	CheckPointer( pllPreroll, E_POINTER );
	LONGLONG llPreroll;
	HRESULT hr = m_apMS[0]->GetPreroll( pllPreroll );

	// return the minimum preroll of all our inputs
	if( SUCCEEDED( hr ) )
	{
		for(int i = 1; i < m_iPinCount; i++)
		{
			hr = m_apMS[i]->GetPreroll( &llPreroll );
			if(FAILED(hr))
				break;
			if( *pllPreroll > llPreroll ) *pllPreroll = llPreroll;
		}
	}
	return hr;
}


// --- CMediaSeeking implementation ----------


CMediaSeeking::CMediaSeeking(const TCHAR * name,LPUNKNOWN pUnk) :
    CUnknown(name, pUnk)
{
}

CMediaSeeking::CMediaSeeking(const TCHAR * name,
                               LPUNKNOWN pUnk,
                               HRESULT * phr) :
    CUnknown(name, pUnk)
{
    UNREFERENCED_PARAMETER(phr);
}

CMediaSeeking::~CMediaSeeking()
{
}


// expose our interfaces IMediaPosition and IUnknown

STDMETHODIMP
CMediaSeeking::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IMediaSeeking) {
	return GetInterface( (IMediaSeeking *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\audmix.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: audmix.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// AudMix.h : Declaration of the Audio Mixer and  pin objects

#ifndef __AudMixer__
#define __AudMixer__

#include <qeditint.h>
#include <qedit.h>
#include "amextra2.h"

extern const AMOVIESETUP_FILTER sudAudMixer;

#define HOTSIZE 14

class CAudMixer;
class CAudMixerOutputPin;

//
// class for the input pin
// A input pin has its own property page
//
class CAudMixerInputPin : public CBaseInputPin
            , public IAudMixerPin
            , public ISpecifyPropertyPages
            , public IAMAudioInputMixer
{
    friend class CAudMixerOutputPin;
    friend class CAudMixer;

protected:
    CAudMixer *     m_pFilter;      // Main filter object
    LONG            m_cPinRef;      // Pin's reference count
    const int       m_iPinNo;       // Identifying number of this pin

    //IAMAudioInputMixer
    double          m_dPan;         // -1 = full left, 0 = centre, 1 = right
    BOOL            m_fEnable;

    //point to VolumeEnvelopeTable
    DEXTER_AUDIO_VOLUMEENVELOPE *m_pVolumeEnvelopeTable;
    int             m_VolumeEnvelopeEntries;
    int             m_iVolEnvEntryCnt;

    int             m_cValid;       // how many entries?
    int             m_cValidMax;    // allocated space for this many entries
    REFERENCE_TIME *m_pValidStart, *m_pValidStop;    // the entries
    REFERENCE_TIME  m_rtEnvStart, m_rtEnvStop;

    CCritSec        m_csMediaList;  // Critical section for accessing our media types list

    // The samples are held in a First in, First Out queue.
public:
    CGenericList<IMediaSample>    m_SampleList;
    LONG            m_lBytesUsed;
    BOOL            m_fEOSReceived;            // Received an EOS yet?

    long	m_UserID;	// given by user

    IMediaSample *GetHeadSample(void)
        { return m_SampleList.Get(m_SampleList.GetHeadPosition()); }

    HRESULT ClearCachedData();
    BOOL IsValidAtTime(REFERENCE_TIME);

public:

    // Constructor and destructor
    CAudMixerInputPin(
        TCHAR *pObjName,
        CAudMixer *pFilter,
        HRESULT *phr,
        LPCWSTR pPinName,
        int iPinNo);
    ~CAudMixerInputPin();

    DECLARE_IUNKNOWN

    //  ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

    // INonDelegatingUnknown overrides
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    //expose IAudMixerPin, ISpecifyPropertyPages, IAMAudioInputMixer
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppvoid);

    // IPin overrides
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP EndOfStream();
    STDMETHODIMP NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);

    // CBasePin overrides
    HRESULT BreakConnect();
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT GetMediaType( int iPosition, CMediaType *pmt );
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT CompleteConnect(IPin *pReceivePin);

    HRESULT Inactive();

    // CBaseInputPin overrides
    STDMETHODIMP Receive(IMediaSample *pSample);


    // internal methods
    IPin * CurrentPeer() { return m_Connected; }
    CMediaType& CurrentMediaType() { return m_mt; }

    long BytesPerSample() { return (LONG) ((WAVEFORMATEX *) m_mt.pbFormat)->nBlockAlign; }
    long BitsPerSample() { return (LONG) ((WAVEFORMATEX *) m_mt.pbFormat)->wBitsPerSample; }
    DWORD SamplesPerSec(){ return ((WAVEFORMATEX *) m_mt.pbFormat)->nSamplesPerSec; };

    //IAudMixerPin; support volume envelope, The volume envelope is a set of
    // ordered pairs of (time,attenuation)

    STDMETHODIMP get_VolumeEnvelope(
            DEXTER_AUDIO_VOLUMEENVELOPE **ppsAudioVolumeEnvelopeTable,
            int *ipEntries );

    STDMETHODIMP put_VolumeEnvelope(
            const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable,
            const int iEntries);

    STDMETHODIMP ClearVolumeEnvelopeTable(); //clear existed VolumeEnvelope Array

    STDMETHODIMP InvalidateAll();
    STDMETHODIMP ValidateRange(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop);
    STDMETHODIMP SetEnvelopeRange( REFERENCE_TIME rtStart, REFERENCE_TIME rtStop );
    STDMETHODIMP put_PropertySetter( const IPropertySetter * pSetter );

    // Implement IAMAudioInputMixer
    STDMETHODIMP put_Enable(BOOL fEnable);    //enable or disable an input in mix
    STDMETHODIMP get_Enable(BOOL *pfEnable);
    STDMETHODIMP put_Mono(BOOL fMono){ return E_NOTIMPL; }; //combine all channels to a mono
    STDMETHODIMP get_Mono(BOOL *pfMono){ return E_NOTIMPL; };
    STDMETHODIMP put_Loudness(BOOL fLoudness){ return E_NOTIMPL; };//turn loadness control on or off
    STDMETHODIMP get_Loudness(BOOL *pfLoudness){ return E_NOTIMPL; };
    STDMETHODIMP put_MixLevel(double Level){ return E_NOTIMPL; }; //set record level for this input
    STDMETHODIMP get_MixLevel(double FAR* pLevel){ return E_NOTIMPL; };
    STDMETHODIMP put_Pan(double Pan);
    STDMETHODIMP get_Pan(double FAR* pPan);
    STDMETHODIMP put_Treble(double Treble){ return E_NOTIMPL; }; //set treble equalization for this pin
    STDMETHODIMP get_Treble(double FAR* pTreble){ return E_NOTIMPL; };
    STDMETHODIMP get_TrebleRange(double FAR* pRange){ return E_NOTIMPL; };
    STDMETHODIMP put_Bass(double Bass){ return E_NOTIMPL; };//set pass equalization for this pin
    STDMETHODIMP get_Bass(double FAR* pBass){ return E_NOTIMPL; };
    STDMETHODIMP get_BassRange(double FAR* pRange){ return E_NOTIMPL; };//retriet pass range for this pin
    STDMETHODIMP get_UserID(long *pID);
    STDMETHODIMP put_UserID(long ID);
    STDMETHODIMP OverrideVolumeLevel(double dVol);

};


// Class for the Audio Mixer's Output pin.

class CAudMixerOutputPin
    : public CBaseOutputPin
    , public ISpecifyPropertyPages
    , public IAudMixerPin
{
    friend class CAudMixerInputPin;
    friend class CAudMixer;

    //point to VolumeEnvelopeTable
    DEXTER_AUDIO_VOLUMEENVELOPE *m_pVolumeEnvelopeTable;
    int m_VolumeEnvelopeEntries;
    int m_iVolEnvEntryCnt;


    CAudMixer *m_pFilter;         // Main filter object pointer
    CMultiPinPosPassThru *m_pPosition;  // Pass seek calls upstream
    double m_dPan;        // -1 = full left, 0 = centre, 1 = right

protected:

    // need to know the start/stop time we'll be called so we can offset the
    // mix offset times
    //
    REFERENCE_TIME m_rtEnvStart, m_rtEnvStop;

    long m_UserID;	// set by user

public:

    // Constructor and destructor
    CAudMixerOutputPin(TCHAR *pObjName, CAudMixer *pFilter, HRESULT *phr,
        LPCWSTR pPinName);
    ~CAudMixerOutputPin();

    DECLARE_IUNKNOWN


    //  ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);


    //IAudMixerPin; support volume envelope, Th evolume envelope is a set of ordered pairs of (time,attenuation)
    STDMETHODIMP get_VolumeEnvelope(
            DEXTER_AUDIO_VOLUMEENVELOPE **ppsAudioVolumeEnvelopeTable,
            int *ipEntries );

    STDMETHODIMP put_VolumeEnvelope(
            const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable,
            const int iEntries);

    STDMETHODIMP ClearVolumeEnvelopeTable(); //clear existed VolumeEnvelope Array

    STDMETHODIMP InvalidateAll() {return E_NOTIMPL;}
    STDMETHODIMP ValidateRange(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop);
    STDMETHODIMP SetEnvelopeRange( REFERENCE_TIME rtStart, REFERENCE_TIME rtStop );
    STDMETHODIMP put_PropertySetter( const IPropertySetter * pSetter );
    STDMETHODIMP put_UserID(long ID);
    STDMETHODIMP get_UserID(long *pID);
    STDMETHODIMP OverrideVolumeLevel(double dVol);

    // INonDelegatingUnknown overrides
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppvoid);

    // CBasePin overrides
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT GetMediaType( int iPosition, CMediaType *pmt );
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);


    // CBaseOutputPin overrides
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
        ALLOCATOR_PROPERTIES * ppropInputRequest);

    // internal methods
    IPin *  CurrentPeer() { return m_Connected; }
    CMediaType& CurrentMediaType() { return m_mt; };

    long BytesPerSample() { return (LONG) ((WAVEFORMATEX *) m_mt.pbFormat)->nBlockAlign; };
    long BitsPerSample() { return (LONG) ((WAVEFORMATEX *) m_mt.pbFormat)->wBitsPerSample; }
    DWORD SamplesPerSec(){ return ((WAVEFORMATEX *) m_mt.pbFormat)->nSamplesPerSec; };


};

//
//  Class for the Audio Mixer
//  1. It supports an interface where you can tell it what media type to accept
//    All pins will only accept this type.
//  2. The filter property page will bring all input pins property pages.

class CAudMixer
    : public CBaseFilter
    , public IAudMixer
    , public CCritSec
    , public ISpecifyPropertyPages
    , public CPersistStream

{
    // Let the pins access our internal state
    friend class CAudMixerInputPin;
    friend class CAudMixerOutputPin;
    typedef CGenericList <CAudMixerInputPin> CInputList;

    // filters output pin
    CAudMixerOutputPin *m_pOutput;    // Filter's output pin

    // input pin count
    INT m_cInputs;

    // m_ShownPinPropertyPageOnFilter can only modified by GetPages()
    // function and NextPin() function
    INT m_ShownPinPropertyPageOnFilter;

    // list of the output pins
    CInputList m_InputPinsList;
    // Critical section for accessing our input pin list
    CCritSec m_csPinList;
    // Critical section for delivering media samples
    CCritSec m_csReceive;
    // Critical section for dicking with the volume envelope
    CCritSec m_csVol;

    //  The following variables are used to ensure that we deliver the associated commands only once
    // to the output pin even though we have multiple input pins.
    BOOL m_bNewSegmentDelivered;
    // We only send BeginFlush when this is 0 and EndFlush when it equals 1
    LONG m_cFlushDelivery;

    // how to configure output buffers
    int m_iOutputBufferCount;
    int m_msPerBuffer;

    //output sample time stamp
    REFERENCE_TIME m_rtLastStop;

    // temp space for the mixing code
    CAudMixerInputPin **m_pPinTemp;
    BYTE **m_pPinMix;
    REFERENCE_TIME *m_pStartTemp;
    REFERENCE_TIME *m_pStopTemp;

    BOOL m_fEOSSent;

    long m_nHotness[HOTSIZE];
    long m_nLastHotness;

public:
    CAudMixer(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CAudMixer();
    DECLARE_IUNKNOWN;

    STDMETHODIMP Pause();
    STDMETHODIMP Stop();

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

    // CBaseFilter overrides
    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    //expose IAudMixer, ISpecifyPropertyPages
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

    //IAudMixer
    STDMETHODIMP put_InputPins( long Pins );
    STDMETHODIMP get_MediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP put_MediaType(const AM_MEDIA_TYPE *pmt);
    STDMETHODIMP get_CurrentAveragePower(double *pdAvePower);
    STDMETHODIMP NextPin(IPin **ppIPin );  //fetch next input pin.
    STDMETHODIMP InvalidatePinTimings( );
    STDMETHODIMP set_OutputBuffering(const int iNumber, const int mSecond );
    STDMETHODIMP get_OutputBuffering( int *piNumber, int *pmSecond );

protected:

    // mediatype which input pins and output pin only accept
    CMediaType      m_MixerMt;

    // List management of our input pins
    void InitInputPinsList();
    CAudMixerInputPin *GetPinNFromList(int n);
    CAudMixerInputPin *CreateNextInputPin(CAudMixer *pFilter);
    void DeleteInputPin(CAudMixerInputPin *pPin);
    int GetNumFreePins();

    //
    // Other helpers
    //

    // refresh the output pin's pospassthru about the input pins
    HRESULT SetInputPins();
    void ResetOutputPinVolEnvEntryCnt();
    HRESULT TryToMix(REFERENCE_TIME rt);
    void ClearHotnessTable( );
};

// global prototypes
//
HRESULT PinSetPropertySetter( IAudMixerPin * pPin, const IPropertySetter * pSetter );

void PanAudio(BYTE *pIn,    //source buffer
          double dPan,
          int Bits,        //8bit,16tis audio
          int nSamples  //how manmy audio samples which be panned
          );

void VolEnvelopeAudio(BYTE *pIn,        //source buffer
           WAVEFORMATEX * vih,    //source audio format
           int nSamples,    // how many audio samples which will be applied with this envelope
           double dStartLev,    //start level
           double dStopLev);    //stop level, If(dStartLev==sStopLev) dMethod=DEXTER_AUDIO_JUMP

void ApplyVolEnvelope( REFERENCE_TIME rtStart,  //output sample start time
             REFERENCE_TIME rtStop,    //output sample stop time
             REFERENCE_TIME rtEnvelopeDuration,
             IMediaSample *pSample,    //point to the sample
             WAVEFORMATEX *vih,     //output sample format
             int *pVolumeEnvelopeEntries,
             int *piVolEnvEntryCnt,
             DEXTER_AUDIO_VOLUMEENVELOPE *pVolumeEnvelopeTable);

void putVolumeEnvelope(    const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable, //current input table
            const int ipEntries, // current input entries
            DEXTER_AUDIO_VOLUMEENVELOPE **ppVolumeEnvelopeTable    , //existed table
            int *ipVolumeEnvelopeEntries); //existed table netries

#endif // __AudMixer__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\prop.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: prop.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

//
// prop.h , 
//

//
//property page  for audio mixer input pin
//
// {BDF23680-C1E5-11d2-9EF7-006008039E37}
DEFINE_GUID(CLSID_AudMixPinPropertiesPage, 
0xbdf23680, 0xc1e5, 0x11d2, 0x9e, 0xf7, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37);

class CAudMixPinProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
         
private:
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void SetDirty();

    CAudMixPinProperties(LPUNKNOWN lpunk, HRESULT *phr);


    STDMETHODIMP GetFromDialog();

    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg
                            // to prevent theDirty flag from being set.

    REFERENCE_TIME	m_rtStartTime;  //*1000
    REFERENCE_TIME	m_rtDuration;	//*1000
    double		m_dStartLevel;	//*100	
    double		m_dPan;	//*100	
    int			m_iEnable;	//IDC_AUDMIXPIN_ENABLE	

    //IAudMixerPin interface
    IAudMixerPin	*m_pIAudMixPin;
    IAudMixerPin	*pIAudMixPin(void) { ASSERT(m_pIAudMixPin); return m_pIAudMixPin; }

    IAMAudioInputMixer  *m_IAMAudioInputMixer;


};

//
// property page  for the audio mixer filter
//
// {67F07E00-CCEF-11d2-9EF9-006008039E37}
DEFINE_GUID(CLSID_AudMixPropertiesPage, 
0x67f07e00, 0xccef, 0x11d2, 0x9e, 0xf9, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37);

class CAudMixProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
         
private:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void SetDirty();

    CAudMixProperties(LPUNKNOWN lpunk, HRESULT *phr);


    STDMETHODIMP GetFromDialog();

    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg
                            // to prevent theDirty flag from being set.

    int m_nSamplesPerSec;
    int m_nChannelNum;
    int m_nBits;
    int m_iOutputbufferNumber;
    int m_iOutputBufferLength;
    
    //IAudMixer interface
    IAudMixer	*m_pIAudMix;
    IAudMixer	*pIAudMix(void) { ASSERT(m_pIAudMix); return m_pIAudMix; }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by filter.rc
//
#define IDS_AudMix			350
#define IDD_AudMix			351
#define IDC_SampleRate			352
#define IDC_ChannelNum                  353
#define IDC_Bits			354
#define IDC_OutputBufferNumber          355
#define IDC_OutputBufferLength          156

#define IDS_AudMixPin			360
#define IDD_AudMixPin			361
#define IDC_StartTime			362
#define IDC_Pan				363
#define IDC_AUDMIXPIN_ENABLE		364
#define IDC_Duration			365
#define IDC_StartVolume			366

#ifndef IDS_STATIC
#define IDS_STATIC                      -1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\outpin.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: outpin.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "AudMix.h"
#include "prop.h"

//############################################################################
// 
//############################################################################

////////////////////////////////////////////////////////////////////////////////////////
//
// CAudMixerOutputPin constructor
//
CAudMixerOutputPin::CAudMixerOutputPin(TCHAR *pName, CAudMixer *pFilter,
    HRESULT *phr, LPCWSTR pPinName) :
    CBaseOutputPin(pName, pFilter, pFilter, phr, pPinName), m_pPosition(NULL),
    m_VolumeEnvelopeEntries(0),
    m_iVolEnvEntryCnt(0),
    m_pFilter(pFilter),
    m_dPan(0.0),
    m_rtEnvStart(0), m_rtEnvStop(0),
    m_UserID(0)
{
    m_pVolumeEnvelopeTable=(DEXTER_AUDIO_VOLUMEENVELOPE *)NULL;
} /* CAudMixerOutputPin::CAudMixerOutputPin */


//############################################################################
// 
//############################################################################

//
// CAudMixerOutputPin destructor
//
CAudMixerOutputPin::~CAudMixerOutputPin()
{
    delete m_pPosition;
    if(m_pVolumeEnvelopeTable)
    QzTaskMemFree( m_pVolumeEnvelopeTable );

} /* CAudMixerOutputPin::~CAudMixerOutputPin */

// ISpecifyPropertyPages 
STDMETHODIMP CAudMixerOutputPin::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*1);
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    pPages->pElems[0] = CLSID_AudMixPinPropertiesPage;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

//
// NonDelegatingQueryInterface
//
// This function is overwritten to expose IMediaPosition and IMediaSeeking
//
STDMETHODIMP CAudMixerOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    *ppv = NULL;

    // See what interface the caller is interested in.
    if( riid == IID_IMediaPosition || riid == IID_IMediaSeeking )
    {
        if( m_pPosition )
        {
            return m_pPosition->NonDelegatingQueryInterface(riid, ppv);
        }
    }
    else if (IsEqualIID(IID_ISpecifyPropertyPages, riid))
        return GetInterface((ISpecifyPropertyPages *)this, ppv);
    else if (riid == IID_IAudMixerPin) 
        return GetInterface((IAudMixerPin *) this, ppv);
    else
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);

    // Create implementation of this dynamically as sometimes we may never
    // try and seek.
    m_pPosition = new CMultiPinPosPassThru( NAME("CAudMixer::m_pPosition"), GetOwner() );
    if( m_pPosition == NULL )
    {
        return E_OUTOFMEMORY;
    }
    HRESULT hr = m_pFilter->SetInputPins();
    if(SUCCEEDED(hr)) {
        hr = NonDelegatingQueryInterface(riid, ppv);
    }
    return hr;
} /* CAudMixerOutputPin::NonDelegatingQueryInterface */


//############################################################################
// 
//############################################################################

//
// DecideBufferSize 
//
//
HRESULT CAudMixerOutputPin::DecideBufferSize(IMemAllocator *pAllocator,
    ALLOCATOR_PROPERTIES * pProp)
{
    CheckPointer( pAllocator, E_POINTER );
    CheckPointer( pProp, E_POINTER );
    
    pProp->cBuffers = m_pFilter->m_iOutputBufferCount;

    WAVEFORMATEX * vih = (WAVEFORMATEX*) m_mt.Format( );
    pProp->cbBuffer = vih->nBlockAlign*vih->nSamplesPerSec *
                m_pFilter->m_msPerBuffer / 1000; 

    ASSERT( pProp->cbBuffer );

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProp,&Actual);

    if( SUCCEEDED( hr ) )
    {
        if (pProp->cBuffers > Actual.cBuffers || pProp->cbBuffer > Actual.cbBuffer)
        {
            hr = E_FAIL;
        }
    }
    return hr;
} /* CAudMixerOutputPin::DecideBufferSize */

//############################################################################
// 
//############################################################################

//
// CheckMediaType
//
HRESULT CAudMixerOutputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    DbgLog((LOG_TRACE,3,TEXT("CAudMixOut::CheckMediaType")));
    CheckPointer(pmt, E_POINTER);

    // Check major type
    const CLSID *pType = pmt->Type();
    if( MEDIATYPE_Audio != *pType )
        return VFW_E_TYPE_NOT_ACCEPTED;

    // Check subtypes
    const CLSID *pSubtype = pmt->Subtype();
    if( *pSubtype == MEDIASUBTYPE_PCM )
    {
    
    // check that sample rate & bitrate match user watned
    
    WAVEFORMATEX *pwfx    = (WAVEFORMATEX *) pmt->Format();
    CMediaType *pmtNow    = &m_pFilter->m_MixerMt;
    WAVEFORMATEX *pwfxNow    = (WAVEFORMATEX *) pmtNow->Format();

    if (pwfx->nChannels != pwfxNow->nChannels) {
        DbgLog((LOG_TRACE, 1, TEXT("output # channels doesn't match.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    
    if (pwfx->nSamplesPerSec != pwfxNow->nSamplesPerSec ||
        pwfx->wBitsPerSample != pwfxNow->wBitsPerSample) 
    {
        DbgLog((LOG_TRACE, 1, TEXT("output format doesn't match user wanted fromat.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    if (pwfx->wBitsPerSample != pwfxNow->wBitsPerSample) {
        DbgLog((LOG_TRACE, 1, TEXT("Output pin's bits/sample doesn't match.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    
        return NOERROR;
    }

    return VFW_E_TYPE_NOT_ACCEPTED;
} /* CAudMixerOutputPin::CheckMediaType */

//############################################################################
// 
//############################################################################

//
// Notify
//
STDMETHODIMP CAudMixerOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    return E_FAIL;

} /* CAudMixerOutputPin::Notify */

//############################################################################
// 
//############################################################################

//
// GetMediaType
//
HRESULT CAudMixerOutputPin::GetMediaType( int iPosition, CMediaType *pmt )
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    CheckPointer(pmt, E_POINTER);

    if( iPosition < 0 )
    {
        return E_INVALIDARG;
    }

    if ( iPosition > 0 )
    {
    return VFW_S_NO_MORE_ITEMS;
    
   }

    //get media type from filter( user gives media type he/she wanted)
    *pmt= m_pFilter->m_MixerMt;

    if (!pmt)
    return VFW_S_NO_MORE_ITEMS;

#ifdef DEBUG
    DisplayType(TEXT("Audio mixer ouput pin::GetMediaType"), pmt);
#endif

    return NOERROR;
} /* CAudMixerOutputPin::GetMediaType */

STDMETHODIMP CAudMixerOutputPin::get_VolumeEnvelope(DEXTER_AUDIO_VOLUMEENVELOPE **ppsAudioVolumeEnvelopeTable, 
            int *ipEntries )
{
    // we're looking at the envelope, which can change at any moment
    CAutoLock l(&m_pFilter->m_csVol);

    CheckPointer(ipEntries,E_POINTER);
    CheckPointer(*ppsAudioVolumeEnvelopeTable, E_POINTER);

    *ipEntries=m_VolumeEnvelopeEntries;

    if(*ppsAudioVolumeEnvelopeTable != NULL)
    {
        int iSize=*ipEntries * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
        CopyMemory( (PBYTE)*ppsAudioVolumeEnvelopeTable,(PBYTE)m_pVolumeEnvelopeTable, iSize);
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerOutputPin::put_VolumeEnvelope(const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable,
                const int iEntries)
{ 
    // we're touching the envelope
    CAutoLock l(&m_pFilter->m_csVol);

    if (!iEntries) return NOERROR;

    DbgLog((LOG_TRACE, 1, TEXT("CAudMixOut::put_Envelope %d"), iEntries));
    
    CheckPointer(psAudioVolumeEnvelopeTable,E_POINTER);

    putVolumeEnvelope( psAudioVolumeEnvelopeTable, //current input table
            iEntries, // current input entries
            &m_pVolumeEnvelopeTable    , //existed table    
            &m_VolumeEnvelopeEntries); //existed table netries
    
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerOutputPin::ClearVolumeEnvelopeTable()
{ 
    // we're touching the envelope
    CAutoLock l(&m_pFilter->m_csVol);

    //clear existed VolumeEnvelope Array entry cnt
    m_VolumeEnvelopeEntries =0;

    //free pre-exist talbe
    if (m_pVolumeEnvelopeTable)
        QzTaskMemFree(m_pVolumeEnvelopeTable);
    m_pVolumeEnvelopeTable = NULL;

    //reset entry point
    m_iVolEnvEntryCnt=0;

    return NOERROR;
}

STDMETHODIMP CAudMixerOutputPin::put_PropertySetter( const IPropertySetter * pSetter )
{
    return PinSetPropertySetter( this, pSetter );
}

STDMETHODIMP CAudMixerOutputPin::ValidateRange( REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    return E_NOTIMPL;
}

STDMETHODIMP CAudMixerOutputPin::SetEnvelopeRange( REFERENCE_TIME rtStart,
                                                   REFERENCE_TIME rtStop )
{
    m_rtEnvStart = rtStart;
    m_rtEnvStop = rtStop;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerOutputPin::put_UserID(long ID)
{
    m_UserID = ID;
    return S_OK;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerOutputPin::get_UserID(long *pID)
{
    CheckPointer(pID, E_POINTER);
    *pID = m_UserID;
    return S_OK;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerOutputPin::OverrideVolumeLevel(double dVol)
{
    DEXTER_AUDIO_VOLUMEENVELOPE env;
    env.rtEnd = 0;
    env.dLevel = dVol;
    env.bMethod = DEXTERF_JUMP;

    ClearVolumeEnvelopeTable();
    HRESULT hr = put_VolumeEnvelope(&env, 1);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\mixfuncs.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: mixfuncs.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "AudMix.h"
#include "prop.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

//############################################################################
// 
//############################################################################

void VolEnvelopeAudio(BYTE *pIn,		//source buffer
		   WAVEFORMATEX * vih,	//source audio format
		   int nSamples,	// how many audio samples which will be applied with this envelope
		   double dStartLev,	//start level 
		   double dStopLev)	//stop level, If(dStartLev==sStopLev) dMethod=DEXTER_AUDIO_JUMP
{
    BYTE    *pb=pIn;
    short   *pShort=(short *)pIn;
    int iCnt;
    int iTmp;
    double dTmp;


    //more code, but faster
    if( dStartLev==dStopLev)
    {
	//+++++++++++
	//DEXTER_AUDIO_JUMP
	//+++++++++++
        if(dStartLev==0.0)
        {
            FillMemory(pb,nSamples *vih->nBlockAlign,0);
            return;
        }

	if( (vih->wBitsPerSample == 16) && (vih->nChannels ==2) )
	{
	    //16bits, stereo
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dTmp = (double)*pShort * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++= (short)0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++= (short)-32768; //underflow
		else
		    *pShort++=(short)( iTmp );

		dTmp = (double)*pShort * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++= (short)0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++= (short)-32768; //underflow
		else
		    *pShort++=(short)( iTmp );

	    }
	}
	else if( vih->wBitsPerSample == 16) 
	{
	    ASSERT( vih->nChannels ==1);

	    //16 bits mono
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dTmp = (double)*pShort * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++= (short)0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++= (short)-32768; //underflow
		else
		    *pShort++=(short)( iTmp );
	    }

	}
	else if( ( vih->wBitsPerSample == 8) && (vih->nChannels ==2) )
	{
	    //8bits, stereo
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dTmp = (double)*pb * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= (BYTE)0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++=(BYTE) 0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );

		dTmp = (double)*pb * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= (BYTE)0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++= (BYTE)0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );
	    }
	}
	else
	{
	    ASSERT( vih->wBitsPerSample == 8);
	    ASSERT( vih->nChannels ==1);

	    //8bits, mono
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dTmp = (double)*pb * dStopLev;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= (BYTE)0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++= (BYTE)0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );
	    }
	}
    }
    else
    {
	//++++++++++++++++++
	//DEXTER_AUDIO_INTERPOLATE
	//++++++++++++++++++
	double dLevel;
	double dDeltaLevel=dStopLev-dStartLev;

	if( (vih->wBitsPerSample == 16) && (vih->nChannels ==2) )
	{
	    //16bits, stereo
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dLevel = dDeltaLevel*iCnt/nSamples+dStartLev ;

		dTmp = (double)*pShort * dLevel;

		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++=0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++=(short)-32768; //underflow
		else
		    *pShort++=(short)( iTmp );

		dTmp = (double)*pShort * dLevel;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++= 0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++=(short)-32768; //underflow
		else
		    *pShort++=(short)( iTmp );

	    }
	}
	else if( vih->wBitsPerSample == 16) 
	{
	    ASSERT( vih->nChannels ==1);

	    //16 bits mono
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dLevel = dDeltaLevel*iCnt/nSamples+dStartLev ;

		dTmp = (double)*pShort * dLevel;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7fff )
		    *pShort++= 0x7fff; //overflow
		else if( iTmp < -32768 )
		    *pShort++= (short)-32768; //underflow
		else
		    *pShort++=(short)( iTmp );
	    }

	}
	else if( (vih->wBitsPerSample == 8) && (vih->nChannels ==2) )
	{
	    //8bits, stereo
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dLevel = dDeltaLevel*iCnt/nSamples+dStartLev ;

		dTmp = (double)*pb * dLevel;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= 0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++= (BYTE)0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );

		dTmp = (double)*pb * dLevel;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= 0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++= (BYTE)0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );
	    }
	}
	else
	{
	    ASSERT( vih->wBitsPerSample == 8);
	    ASSERT( vih->nChannels ==1);

	    //8bits, mono
	    for(iCnt=0; iCnt<nSamples; iCnt++)
	    {
		dLevel = dDeltaLevel*iCnt/nSamples+dStartLev ;

		dTmp = (double)*pb * dLevel;
		if(dTmp>=0.0)
		    iTmp=(int)(dTmp+0.5);
		else
		    iTmp=(int)(dTmp-0.5);
		
		if( iTmp > 0x7f )
		    *pb++= 0x7f; //overflow
		else if( iTmp < -128 )
		    *pb++= (BYTE)0x80; //underflow
		else
		    *pb++=(BYTE)( iTmp );
	    }
	}
    }
}


//############################################################################
// 
//############################################################################

void PanAudio(BYTE *pIn,double dPan, int Bits, int nSamples)
{
    //assuming stereo audio:  left  right

    //full right(1.0)
    DWORD dwMask    =0x00ff00ff;
    DWORD dwOrMask  =0x80008000;

    //for right( dPan 0-1.0) keeps the current , low left
    BYTE *pb=pIn;
    short  *pShort=(short *)pIn;

    if( (dPan==-1.0 ) || (dPan==1.0 ) )
    {
	//assuming input audio buffer would be 4 bytes Align, but in case
	    
	int nDWORD  = 0;
	DWORD *pdw=(DWORD *)pIn;

	if( Bits == 8)
	{
	    //very dword take care two samples
	    nDWORD  = nSamples >> 1 ;
	    int nRem    = nSamples%2;

	    if(dPan==-1.0 )
		//full left, right silence 
	    {
		dwMask	=0xff00ff00;
		dwOrMask=0x00800080;
	    }
	    // elsed wMask=0x00ff00ff;

	    //input audio buffer would be 4 bytes Align, but in case
	    while(nDWORD--)
		*pdw++  = (*pdw & dwMask ) | dwOrMask;

	    //what left
	    pShort=(short *)(pdw);
	    short sMask =(short)(dwMask >> 16);
	    short sOrMask =(short)(dwOrMask >> 16);
	    while(nRem--)
		*pShort++  = (*pShort & sMask ) | sOrMask;

	}
	else
	{
	    ASSERT(Bits ==16);

	    //very dword take care 0ne samples
	    nDWORD  = nSamples ;
	
	    if(dPan==-1.0)
		dwMask=0xffff0000;
	    else
		dwMask=0x0000ffff;

	    while(nDWORD--)
		*pdw  &= dwMask ;

	}
    }
    else
    {
	double dIndex = (dPan > 0.0 ) ? ( 1.0-dPan):(1.0+dPan);

	if(dPan < 0.0 )
	{
	    //left change keeps current value, low right channel 
	    pb++;
	    pShort++;
	}

	if( Bits == 8)
	{

	    for(int j=0; j<nSamples; j++)
	    {
		*pb++ = (BYTE) ( (double)(*pb) * dIndex +0.5);

		pb++;
	    }

	}
	else
	{
	    ASSERT(Bits==16);
	    for(int j=0; j<nSamples; j++)
	    {
		*pShort++=(short)( (double)(*pShort) * dIndex +0.5);
		pShort++;

	    }
	}
    }
}

//############################################################################
// 
//############################################################################

void ApplyVolEnvelope( REFERENCE_TIME rtStart,  //output sample start time
		     REFERENCE_TIME rtStop,	//output sample stop time
                     REFERENCE_TIME rtEnvelopeDuration,
		     IMediaSample *pSample,	//point to the sample
		     WAVEFORMATEX *vih,     //output sample format
		     int *pVolumeEnvelopeEntries,  //total table entries
		     int *piVolEnvEntryCnt,   //current table entry point
		     DEXTER_AUDIO_VOLUMEENVELOPE *pVolumeEnvelopeTable) //table
{
    DbgLog((LOG_TRACE,1,TEXT("Entry=%d rt=%d val=%d/10"), *piVolEnvEntryCnt,
		pVolumeEnvelopeTable[*piVolEnvEntryCnt].rtEnd,
		(int)(pVolumeEnvelopeTable[*piVolEnvEntryCnt].dLevel * 10)));
    //there is an volume envelope table

    BYTE * pIn;  //input buffer point
    int iL;

    if( (&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->rtEnd >=rtStop &&
        (&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->bMethod ==DEXTER_AUDIO_JUMP  )
    {
        //no envelope from rtStart to rtStop
        if( !*piVolEnvEntryCnt )
            return; 
        else if( (&pVolumeEnvelopeTable[*piVolEnvEntryCnt-1])->dLevel ==1.0 ) 
            return;
    }

    //get input buffer pointer
    pSample->GetPointer(&pIn);
    long Length=pSample->GetActualDataLength(); //how many bytes in this buffer
    
    //calc how many bytes in this sample
    Length /=(long)( vih->nBlockAlign );   //how many samples in this buffer
    int iSampleLeft=(int)Length;


    //envelope levels and time
    double      dPreLev=1.0, dCurLev, dStartLev, dStopLev;  
    REFERENCE_TIME rtPre=0, rtCur, rtTmp, rt0=rtStart, rt1;

    if(*piVolEnvEntryCnt)  //if current table  entry is not 0, fetch pre-level as start leve
    {
      	dPreLev=(&pVolumeEnvelopeTable[*piVolEnvEntryCnt-1])->dLevel;
        rtPre=(&pVolumeEnvelopeTable[*piVolEnvEntryCnt-1])->rtEnd;
    }
    dCurLev=(&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->dLevel;
    rtCur =(&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->rtEnd;

    //apply envelope
    while( ( *pVolumeEnvelopeEntries-*piVolEnvEntryCnt) >0 )
    {	
        if(  ( rt0 >=rtCur )  &&
             (*pVolumeEnvelopeEntries== *piVolEnvEntryCnt+1) )
        {
            if( rt0 > rtEnvelopeDuration ) 
            {
                //CASE 0: at end of envelope, for REAL. back to 1.0
                dStopLev = dStartLev = 1.0;
                rt1 = rtStop;
            }
            else
            {
                //CASE 1: at end of envelope,  keep the last level
                dStopLev=dStartLev=dCurLev;
                rt1=rtStop;
            }
        }
        else if( rt0 >= rtCur ) 
        {
            //CASE 2: forword one more envelope
            rt1=rt0;
            goto NEXT_ENVELOPE;
        }
        else 
        {
            ASSERT( rt0 < rtCur);

            if( rtStop <= rtCur )
                //CASE 3: 
                rt1=rtStop;
            else
                //CASE 4:
                rt1=rtCur;
    
            if( (&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->bMethod==DEXTER_AUDIO_JUMP )
                dStopLev=dStartLev=dPreLev;  //keep pre. level
            else
            {
                //interpolate

                double dDiff=dCurLev-dPreLev;
                rtTmp       =rtCur-rtPre;

                //envelope level
                dStartLev=dPreLev+ dDiff*(rt0 - rtPre ) /rtTmp;
                dStopLev =dPreLev+ dDiff*(rt1 - rtPre ) /rtTmp;

             }
        }

        //apply current envelope from rt0 to rt1
        iL=(int)( (rt1-rt0)*Length /(rtStop-rtStart) ); 

        // avoid off by 1 errors.  If we're supposed to use the rest of the
        // buffer, make sure we use the rest of the buffer!  iL might be 1 too
        // small due to rounding errors
        if (rt1 == rtStop)
            iL = iSampleLeft;

	ASSERT(iL<=iSampleLeft);

        if( dStartLev !=1.0 || dStopLev!=1.0 )
	    VolEnvelopeAudio(pIn,	    //source buffer
	    	vih,	    //source audio format
		iL,	    // how many audio samples which will be applied with this envelope
		dStartLev, //start level 
		dStopLev); //stop level, If(dStartLev==sStopLev) dMethod=DEXTER_AUDIO_JUMP
        
        pIn +=(iL* vih->nBlockAlign);
	iSampleLeft-=iL;

	if( rt1==rtStop )
	{
            ASSERT(!iSampleLeft);
	    return;
	}
	else
        {
NEXT_ENVELOPE:
            ASSERT(iSampleLeft);

            dPreLev= dCurLev;
            rtPre=rtCur;
            *piVolEnvEntryCnt+=1;
            dCurLev=(&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->dLevel;
            rtCur =(&pVolumeEnvelopeTable[*piVolEnvEntryCnt])->rtEnd;
            rt0=rt1;
        }
	        
    } //end of while()

}

//############################################################################
// 
//############################################################################

void putVolumeEnvelope(	const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable, //current input table
			const int iEntries, // current input entries
			DEXTER_AUDIO_VOLUMEENVELOPE **ppVolumeEnvelopeTable	, //existed table	
			int *ipVolumeEnvelopeEntries) //existed table netries
{

    DEXTER_AUDIO_VOLUMEENVELOPE *pVolumeEnvelopeTable;
    pVolumeEnvelopeTable=*ppVolumeEnvelopeTable;

    int iSize;

    //is a table existed
    if(pVolumeEnvelopeTable)
    {	
	//MAX Entries, may be too big, but we do not care
	iSize=(iEntries +*ipVolumeEnvelopeEntries)* sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);

	//allocate memory for new table, I can use Realloc(), but this way is eaiser to insert
	DEXTER_AUDIO_VOLUMEENVELOPE *pNewTable=
	    (DEXTER_AUDIO_VOLUMEENVELOPE *)QzTaskMemAlloc(iSize); 

	//insert the new input table to the existed table
	int iInput=0;  //input table cnt
	int iExist=0;  //exist table cnt
	int iNew=0;  //new table cnt

	int iExtraEntries=0;   

	//how many more entries
	while (	iInput<iEntries )
	{
	    if( ( iExist == *ipVolumeEnvelopeEntries ) )
	    {
	        //copy rest input table
	        CopyMemory( (PBYTE)(&pNewTable[iNew]), 
		    (PBYTE)(&psAudioVolumeEnvelopeTable[iInput]),
		    (iEntries-iInput)*sizeof(DEXTER_AUDIO_VOLUMEENVELOPE));
	        iExtraEntries+=(iEntries-iInput);
	        break;
	    }
	    else if( psAudioVolumeEnvelopeTable[iInput].rtEnd <= pVolumeEnvelopeTable[iExist].rtEnd )
	    {
		//insert or replace 
		CopyMemory( (PBYTE)(&pNewTable[iNew++]), 
			    (PBYTE)(&psAudioVolumeEnvelopeTable[iInput]),
			    sizeof(DEXTER_AUDIO_VOLUMEENVELOPE));

		if( psAudioVolumeEnvelopeTable[iInput].rtEnd == pVolumeEnvelopeTable[iExist].rtEnd )
		    //replace existed one
		    iExist++;
		else
		    //insert new one
		    iExtraEntries++;
		
		iInput++;
	    }
	    else 
	    {
		//how many existed elements will be copied
		int iCnt=1;

		if(iExist < *ipVolumeEnvelopeEntries )
		{
		    iExist++;

		    while( ( iExist < *ipVolumeEnvelopeEntries) &&
			( psAudioVolumeEnvelopeTable[iInput].rtEnd > pVolumeEnvelopeTable[iExist].rtEnd) )
		    {
			iCnt++;
			iExist++;
		    }
		}

		//copy iCnt elements from existed table to the new table
		CopyMemory( (PBYTE)(&pNewTable[iNew]), 
			    (PBYTE)(&pVolumeEnvelopeTable[(iExist-iCnt)]),
			    iCnt*sizeof(DEXTER_AUDIO_VOLUMEENVELOPE));
		iNew+=iCnt;
	    }
	}

	//new table entries
	*ipVolumeEnvelopeEntries =*ipVolumeEnvelopeEntries+iExtraEntries;

	//free pre-exist talbe
	QzTaskMemFree(pVolumeEnvelopeTable);

	//point to new table
	*ppVolumeEnvelopeTable=pNewTable;   

    }
    else
    {
	//input table = pVolumeEnvelopeTable(), memory size
	iSize=iEntries * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);

	*ppVolumeEnvelopeTable = (DEXTER_AUDIO_VOLUMEENVELOPE *)QzTaskMemAlloc(iSize);
    	CopyMemory( (PBYTE)(*ppVolumeEnvelopeTable), (PBYTE)psAudioVolumeEnvelopeTable, iSize);
	*ipVolumeEnvelopeEntries =(int)iEntries;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\prop.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: prop.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

//
//prop.cpp
//

#include <streams.h>
#include <atlbase.h>
#include <qeditint.h>
#include <qedit.h>
#include "..\util\filfuncs.h"

#include "resource.h"
#include "prop.h"

inline void SAFE_RELEASE(IUnknown **ppObj)
{
    if ( *ppObj != NULL )
    {
        ULONG cRef = (*ppObj)->Release();
        *ppObj = NULL;
    }
}

// *
// * CAudMixPinProperties
// *


//
// CreateInstance
//
CUnknown *CAudMixPinProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CAudMixPinProperties(lpunk, phr);
    if (punk == NULL)
    {
	*phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CAudMixPinProperties::Constructor
//
CAudMixPinProperties::CAudMixPinProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("Audio Mixer Pin Property Page"),pUnk,
        IDD_AudMixPin, IDS_AudMixPin)
    , m_pIAudMixPin(NULL)
    , m_IAMAudioInputMixer(NULL)
    , m_bIsInitialized(FALSE)
{
}

// Override CBasePropertyPage's GetPageInfo
STDMETHODIMP CAudMixPinProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo)
{
    HRESULT hr = CBasePropertyPage::GetPageInfo(pPageInfo);
    if (FAILED(hr))  return hr;

    //get IPin interface
    ASSERT(m_pIAudMixPin!=NULL);
    ASSERT(m_IAMAudioInputMixer!=NULL);

    IPin *pIPin;
    hr = m_pIAudMixPin->QueryInterface(IID_IPin, (void**) &pIPin);
    if (FAILED(hr))  return hr;

    // Figure out which input pin it is, and concat the pin number to
    // property page's title
    {
        PIN_INFO PinInfo;
        PinInfo.pFilter = NULL;
        hr = pIPin->QueryPinInfo( &PinInfo );
        SAFE_RELEASE( (LPUNKNOWN *) &PinInfo.pFilter );

        // Get the default page title
        WCHAR wszTitle[STR_MAX_LENGTH];
        WideStringFromResource(wszTitle,m_TitleId);

        // Put the original title and pin name together
        wsprintfWInternal(wszTitle+lstrlenWInternal(wszTitle), L"%ls", PinInfo.achName);

        // Allocate dynamic memory for the new property page title
        int Length = (lstrlenWInternal(wszTitle) + 1) * sizeof(WCHAR);
        LPOLESTR pszTitle = (LPOLESTR) QzTaskMemAlloc(Length);
        if (pszTitle == NULL) {
            NOTE("No caption memory");
	    pIPin->Release();
            return E_OUTOFMEMORY;
        }
        CopyMemory(pszTitle,wszTitle,Length);

        // Free the memory of the old title string
        if (pPageInfo->pszTitle)
            QzTaskMemFree(pPageInfo->pszTitle);
        pPageInfo->pszTitle = pszTitle;

	pIPin->Release();
    }

    return hr;
}

//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CAudMixPinProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
}


INT_PTR CAudMixPinProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
	    //start time
	    SetDlgItemInt(hwnd, IDC_StartTime, (int)(m_rtStartTime / 10000),FALSE);
	
	    //duration
	    SetDlgItemInt(hwnd, IDC_Duration, (int)(m_rtDuration/ 10000), FALSE);

	    //start volume level
	    SetDlgItemInt(hwnd, IDC_StartVolume, (int)(m_dStartLevel*100), FALSE);

	    //start volume level
	    SetDlgItemInt(hwnd, IDC_Pan, (int)(m_dPan*100), FALSE);

            return (LRESULT) 1;
        }
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
            return (LRESULT) 1;
        }
    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}

HRESULT CAudMixPinProperties::OnConnect(IUnknown *pUnknown)
{
    // Get IAudMixPin interface
    ASSERT(m_pIAudMixPin == NULL);
    ASSERT(m_IAMAudioInputMixer == NULL);
    HRESULT hr = S_OK;

    // Query for IAudMixer, if added for the filter
    CComPtr<IAudMixer> pIAudMix = NULL;

    hr = pUnknown->QueryInterface(IID_IAudMixer, (void **) &pIAudMix);
    if (SUCCEEDED(hr))
    {
	//added from filter
	IPin *pIPin=NULL;
	hr = pIAudMix->NextPin(&pIPin);
        if (FAILED(hr)) {
            return hr;
	}

        hr = pIPin->QueryInterface(IID_IAudMixerPin, (void**) &m_pIAudMixPin);
        if (FAILED(hr))
	{
	    pIPin->Release();
	    return hr;
	}

        hr = pIPin->QueryInterface(IID_IAMAudioInputMixer, (void**) &m_IAMAudioInputMixer);
	pIPin->Release();

        if (FAILED(hr)) {
	    return hr;
	}
    }
    else
    {

	
	//added for pin only
	HRESULT hr = pUnknown->QueryInterface(IID_IAudMixerPin, (void **) &m_pIAudMixPin);
	if (FAILED(hr))
	    return E_NOINTERFACE;

	hr = pUnknown->QueryInterface(IID_IAMAudioInputMixer, (void **) &m_IAMAudioInputMixer);
	if (FAILED(hr))
	    return E_NOINTERFACE;

    }

    ASSERT(m_pIAudMixPin);
    ASSERT(m_IAMAudioInputMixer);

    // get init data
//    pIAudMixPin()->get_VolumeEnvelope(&m_rtStartTime,&m_rtDuration,&m_dStartLevel);
    m_IAMAudioInputMixer->get_Pan(&m_dPan);
    BOOL fEnable=TRUE;
    m_IAMAudioInputMixer->get_Enable(&fEnable);
    if(fEnable==TRUE)
	m_iEnable=IDC_AUDMIXPIN_ENABLE;
    else
	m_iEnable=0;
	

    m_bIsInitialized = FALSE ;

    return NOERROR;
}

HRESULT CAudMixPinProperties::OnDisconnect()
{
    // Release the interface

    if( (m_pIAudMixPin == NULL) || (m_IAMAudioInputMixer ==NULL) )
    {
	// !!! why does this happen?
        return(E_UNEXPECTED);
    }
    m_pIAudMixPin->Release();
    m_pIAudMixPin = NULL;

    m_IAMAudioInputMixer->Release();
    m_IAMAudioInputMixer=NULL;
    return NOERROR;
}


// We are being activated

HRESULT CAudMixPinProperties::OnActivate()
{
    CheckRadioButton(m_Dlg, IDC_AUDMIXPIN_ENABLE, IDC_AUDMIXPIN_ENABLE, m_iEnable);
    m_bIsInitialized = TRUE;
    return NOERROR;
}


// We are being deactivated

HRESULT CAudMixPinProperties::OnDeactivate(void)
{
    // remember present effect level for next Activate() call

    GetFromDialog();
    return NOERROR;
}

//
// get data from Dialog

STDMETHODIMP CAudMixPinProperties::GetFromDialog(void)
{
    //get start time
    m_rtStartTime = GetDlgItemInt(m_Dlg, IDC_StartTime, NULL, FALSE);
    m_rtStartTime *= 10000;

    //get duration
    m_rtDuration = GetDlgItemInt(m_Dlg, IDC_Duration, NULL, FALSE);
    m_rtDuration *= 10000;

    //get start volume level
    int n = GetDlgItemInt(m_Dlg, IDC_StartVolume, NULL, FALSE);
    m_dStartLevel = (double)(n / 100.);

    //get Pan
    n = GetDlgItemInt(m_Dlg, IDC_Pan, NULL, FALSE);
    m_dPan = (double)(n / 100.);

    //get enable
    n=IDC_AUDMIXPIN_ENABLE;
    if (IsDlgButtonChecked(m_Dlg, n))
	m_iEnable=n;
    else
	m_iEnable=0;

    // cehck if all data is valid ??
    return NOERROR;
}


HRESULT CAudMixPinProperties::OnApplyChanges()
{
    GetFromDialog();

    HRESULT hr=NOERROR;

    m_bDirty  = FALSE; // the page is now clean

    // get current data
    REFERENCE_TIME rtStart, rtDuration;
    rtStart =0;
    rtDuration=0;
    double dLevel=0.0;
    double dPan=0.0;
    int iEnable=0;
    BOOL fEnable=FALSE;

    //get old data
//    pIAudMixPin()->get_VolumeEnvelope(&rtStart,&rtDuration,&dLevel);
    m_IAMAudioInputMixer->get_Pan(&dPan);
    m_IAMAudioInputMixer->get_Enable(&fEnable);
    if(fEnable==TRUE)
	iEnable =IDC_AUDMIXPIN_ENABLE;

    //set new enable data
    if(m_iEnable==IDC_AUDMIXPIN_ENABLE)
	fEnable=TRUE;
    else
	fEnable=FALSE;


    if( (rtStart != m_rtStartTime)	||
	(rtDuration != m_rtDuration )	||
	(dLevel != m_dStartLevel )	||
	(dPan	!= m_dPan)		||
	(iEnable!= m_iEnable) )
    {
	//put new data

	//hr=pIAudMixPin()->put_VolumeEnvelope(m_rtStartTime,m_rtDuration,m_dStartLevel);
	hr=NOERROR;

	HRESULT hr1= m_IAMAudioInputMixer->put_Pan(m_dPan);
	HRESULT hr2= m_IAMAudioInputMixer->put_Enable(fEnable);

	if(hr!=NOERROR && hr1!=NOERROR && hr2!=NOERROR )
	    return E_FAIL;
    }

    return(hr);

}

//#########################################
// *
// * CAudMixProperties
// *
//##############################################

CUnknown *CAudMixProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CAudMixProperties(lpunk, phr);
    if (punk == NULL)
    {
	*phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CAudMixProperties::Constructor
//
CAudMixProperties::CAudMixProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("Audio Mixer Property Page"),pUnk,
	IDD_AudMix, IDS_AudMix)
    , m_pIAudMix(NULL)
    , m_bIsInitialized(FALSE)
{
}


//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CAudMixProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
}


INT_PTR CAudMixProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
	    //Sampling rate
	    SetDlgItemInt(hwnd, IDC_SampleRate, (int)m_nSamplesPerSec,FALSE);
	
	    //channel Number
	    SetDlgItemInt(hwnd, IDC_ChannelNum, (int)m_nChannelNum, FALSE);

	    //channel bits
	    SetDlgItemInt(hwnd, IDC_Bits, (int)m_nBits, FALSE);

    	    //buffer number
	    SetDlgItemInt(hwnd, IDC_OutputBufferNumber, (int)m_iOutputbufferNumber, FALSE);

	    //buffer lenght in mSecond
	    SetDlgItemInt(hwnd, IDC_OutputBufferLength, (int)m_iOutputBufferLength, FALSE);

            return (LRESULT) 1;
        }
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
            return (LRESULT) 1;
        }
    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}

HRESULT CAudMixProperties::OnConnect(IUnknown *pUnknown)
{
    // Get IAudMix interface
    ASSERT(m_pIAudMix == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IAudMixer, (void **) &m_pIAudMix);
    if (FAILED(hr))
	return E_NOINTERFACE;

    ASSERT(m_pIAudMix);

    // get init data
    CMediaType mt;
    mt.AllocFormatBuffer( sizeof( WAVEFORMATEX ) );

    pIAudMix()->get_MediaType( &mt );

    WAVEFORMATEX * vih = (WAVEFORMATEX*) mt.Format( );

    m_nSamplesPerSec	=vih->nSamplesPerSec;
    m_nChannelNum	=vih->nChannels;
    m_nBits		=(int)vih->wBitsPerSample;

    //buffer number, lenght in mSecond
    pIAudMix()->get_OutputBuffering( &m_iOutputbufferNumber, &m_iOutputBufferLength );

    m_bIsInitialized	= FALSE ;

    SaferFreeMediaType(mt);

    return NOERROR;
}

HRESULT CAudMixProperties::OnDisconnect()
{
    // Release the interface

    if (m_pIAudMix == NULL)
    {
        return(E_UNEXPECTED);
    }
    m_pIAudMix->Release();
    m_pIAudMix = NULL;
    return NOERROR;
}


// We are being activated

HRESULT CAudMixProperties::OnActivate()
{

    m_bIsInitialized = TRUE;
    return NOERROR;
}


// We are being deactivated

HRESULT CAudMixProperties::OnDeactivate(void)
{
    // remember present effect level for next Activate() call

    GetFromDialog();
    return NOERROR;
}

//
// get data from Dialog

STDMETHODIMP CAudMixProperties::GetFromDialog(void)
{

    // Sampling rate
    m_nSamplesPerSec = GetDlgItemInt(m_Dlg, IDC_SampleRate, NULL, FALSE);

    // audio chanenl
    m_nChannelNum = GetDlgItemInt(m_Dlg, IDC_ChannelNum, NULL, FALSE);

    // bits
    m_nBits = GetDlgItemInt(m_Dlg, IDC_Bits, NULL, FALSE);

    //buffer number
    m_iOutputbufferNumber=GetDlgItemInt(m_Dlg, IDC_OutputBufferNumber, NULL, FALSE);

    //buffer lenght in mSecond
    m_iOutputBufferLength=GetDlgItemInt(m_Dlg, IDC_OutputBufferLength, NULL, FALSE);

    return NOERROR;
}


HRESULT CAudMixProperties::OnApplyChanges()
{
    GetFromDialog();

    HRESULT hr=NOERROR;

    m_bDirty  = FALSE; // the page is now clean

    //get current media type
    CMediaType mt;
    mt.AllocFormatBuffer( sizeof( WAVEFORMATEX ) );

    //old format
    hr=pIAudMix()->get_MediaType( &mt );
    if(hr!=NOERROR)
    {
	SaferFreeMediaType(mt);
	return E_FAIL;
    }

    int iNumber=0, mSecond=0;
    hr=pIAudMix()->get_OutputBuffering( &iNumber, &mSecond);
    if(hr!=NOERROR)
    {
	
	SaferFreeMediaType(mt);
	return E_FAIL;
    }

    WAVEFORMATEX * vih = (WAVEFORMATEX*) mt.Format( );
    if( (m_nSamplesPerSec!= (int)(vih->nSamplesPerSec) ) ||
	(m_nChannelNum	 !=vih->nChannels )  ||
	(m_nBits	 !=(int)vih->wBitsPerSample)  ||
	(iNumber	 !=m_iOutputbufferNumber    ) ||
	(mSecond	 !=m_iOutputBufferLength) )
    {
	vih->nSamplesPerSec = m_nSamplesPerSec;
	vih->nChannels	    = (WORD)m_nChannelNum;
	vih->wBitsPerSample = (WORD)m_nBits;
	vih->nBlockAlign    = vih->wBitsPerSample * vih->nChannels / 8;
	vih->nAvgBytesPerSec = vih->nBlockAlign * vih->nSamplesPerSec;
	
	hr= pIAudMix()->put_MediaType( &mt );
	if(hr!=NOERROR){
	    	SaferFreeMediaType(mt);
		return E_FAIL;
	}

	hr= pIAudMix()->set_OutputBuffering(m_iOutputbufferNumber,m_iOutputBufferLength);
	if(hr!=NOERROR){
	    	SaferFreeMediaType(mt);
		return E_FAIL;
	}
    }

    SaferFreeMediaType(mt);
    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\inpin.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: inpin.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "AudMix.h"
#include "prop.h"
#include "..\util\filfuncs.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

//##############################################
//
// CAudMixerInputPin constructor
//
//###############################################

CAudMixerInputPin::CAudMixerInputPin(TCHAR *pName, CAudMixer *pFilter,
    HRESULT *phr, LPCWSTR pPinName, int iPinNo) :
    CBaseInputPin(pName, pFilter, pFilter, phr, pPinName), m_pFilter(pFilter),
    m_iPinNo(iPinNo), 
    m_cPinRef(0), 
    m_dPan(0.0),
    m_fEnable(TRUE),
    m_VolumeEnvelopeEntries(0),
    m_iVolEnvEntryCnt(0),
    m_rtEnvStart(0),
    m_rtEnvStop(0),
    m_UserID(0),
    m_SampleList(NAME("Queue of input samples"))
{
    ASSERT(pFilter);
    m_pVolumeEnvelopeTable=(DEXTER_AUDIO_VOLUMEENVELOPE *)NULL;
    ClearCachedData();

    // by default, this pin is on always
    m_cValid = 1;
    m_cValidMax = 10;
    m_pValidStart = (REFERENCE_TIME *)QzTaskMemAlloc(sizeof(REFERENCE_TIME) *
                    m_cValidMax);
    if (m_pValidStart == NULL)
        *phr = E_OUTOFMEMORY;
    m_pValidStop = (REFERENCE_TIME *)QzTaskMemAlloc(sizeof(REFERENCE_TIME) *
                    m_cValidMax);
    if (m_pValidStop == NULL) {
        *phr = E_OUTOFMEMORY;
        QzTaskMemFree(m_pValidStart);
        m_pValidStart = NULL;
    }
    if (m_pValidStart)
        *m_pValidStart = 0;
    if (m_pValidStop)
        *m_pValidStop = MAX_TIME;

} /* CAudMixerInputPin::CAudMixerInputPin */


//############################################################################
// 
//############################################################################

//
// CAudMixerInputPin destructor
//

CAudMixerInputPin::~CAudMixerInputPin()
{
    if (m_pValidStart)
        QzTaskMemFree(m_pValidStart);
    if (m_pValidStop)
        QzTaskMemFree(m_pValidStop);

    if(m_pVolumeEnvelopeTable)
        QzTaskMemFree( m_pVolumeEnvelopeTable );


} /* CAudMixerInputPin::~CAudMixerInputPin */


//############################################################################
// 
//############################################################################

//
// NonDelegatingAddRef
//
// We need override this method so that we can do proper reference counting
// on each input pin. The CBasePin implementation of NonDelegatingAddRef
// refcounts the filter, but this won't work for use since we need to know
// when we should delete individual pins.
//
STDMETHODIMP_(ULONG) CAudMixerInputPin::NonDelegatingAddRef()
{
#ifdef DEBUG
    // Update the debug only variable maintained by the base class
    m_cRef++;
    ASSERT(m_cRef > 0);
#endif

    // Now update our reference count
    m_cPinRef++;
    ASSERT(m_cPinRef > 0);

    // If our reference count == 2, then someone besides the filter has referenced
    // us.  Therefore we need to AddRef the filter.  The reference on the filter will
    // be released when our ref count gets back to 1.
//    if (2 == m_cPinRef)
//    m_pFilter->AddRef();

    return m_cPinRef;
} /* CAudMixerInputPin::NonDelegatingAddRef */


//############################################################################
// 
//############################################################################

//
// NonDelegatingRelease
//
// CAudMixerInputPin overrides this class so that we can take the pin out of our
// input pins list and delete it when its reference count drops to 1 and there
// is at least two free pins.
//
// Note that CreateNextInputPin holds a reference count on the pin so that
// when the count drops to 1, we know that no one else has the pin.
//
STDMETHODIMP_(ULONG) CAudMixerInputPin::NonDelegatingRelease()
{
#ifdef DEBUG
    // Update the debug only variable in CBasePin
    m_cRef--;
    ASSERT(m_cRef >= 0);
#endif

    // Now update our reference count
    m_cPinRef--;
    ASSERT(m_cPinRef >= 0);

    // if the reference count on the object has gone to one, remove
    // the pin from our output pins list and physically delete it
    // provided there are atealst two free pins in the list(including
    // this one)

    // Also, when the ref count drops to 0, it really means that our
    // filter that is holding one ref count has released it so we
    // should delete the pin as well.

    // since DeleteINputPin will wipe out "this"'s stack, we need
    // to save this off as a local variable.
    //
    ULONG ul = m_cPinRef;

    if ( 0 == ul )
    {
    m_pFilter->DeleteInputPin(this);
    }
    return ul;
} /* CAudMixerInputPin::NonDelegatingRelease */

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::NonDelegatingQueryInterface (REFIID riid, void **ppv)
{ 

    if (IsEqualIID(IID_ISpecifyPropertyPages, riid))
    return GetInterface((ISpecifyPropertyPages *)this, ppv);
    else if (riid == IID_IAudMixerPin) 
    return GetInterface((IAudMixerPin *) this, ppv);
    else if (riid == IID_IAMAudioInputMixer) 
    return GetInterface((IAMAudioInputMixer *) this, ppv);
    else
    return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);

} // NonDelegatingQueryInterface //

//############################################################################
// 
//############################################################################

//
// CheckMediaType, inputpin
//
HRESULT CAudMixerInputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    DbgLog((LOG_TRACE,3,TEXT("CAudMixIn::CheckMediaType")));
    CheckPointer(pmt, E_POINTER);

    // Check major type
    const CLSID *pType = pmt->Type();
    if( MEDIATYPE_Audio != *pType )
        return VFW_E_TYPE_NOT_ACCEPTED;

    // Check subtypes
    const CLSID *pSubtype = pmt->Subtype();
    if( *pSubtype == MEDIASUBTYPE_PCM )
    {
    
    // check that sample rate & bitrate match user wanted
    
    WAVEFORMATEX *pwfx    = (WAVEFORMATEX *) pmt->Format();
    CMediaType *pmtNow    = &m_pFilter->m_MixerMt;
    WAVEFORMATEX *pwfxNow    = (WAVEFORMATEX *) pmtNow->Format();

    if (pwfx->nChannels != pwfxNow->nChannels) {
        DbgLog((LOG_TRACE, 1, TEXT("input's # channels doesn't match.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    
    if (pwfx->nSamplesPerSec != pwfxNow->nSamplesPerSec ||
        pwfx->wBitsPerSample != pwfxNow->wBitsPerSample) 
    {
        DbgLog((LOG_TRACE, 1, TEXT("input format doesn't match user wanted format.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    if (pwfx->wBitsPerSample != pwfxNow->wBitsPerSample) {
        DbgLog((LOG_TRACE, 1, TEXT("input's bits/sample doesn't match.")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    
        return NOERROR;
    }

    return VFW_E_TYPE_NOT_ACCEPTED;
    
} /* CAudMixerInputPin::CheckMediaType */

//############################################################################
// 
//############################################################################

//
// GetMediaType
//
HRESULT CAudMixerInputPin::GetMediaType( int iPosition, CMediaType *pmt )
{
    if( iPosition < 0 )
    {
        return E_INVALIDARG;
    }

    switch( iPosition )
    {
    case 0:
    {
        //
        // All input pins only accept one kind media type ===> which is filter's m_MixerMt
        //
        return CopyMediaType( pmt, &m_pFilter->m_MixerMt );
    }
    default:
        return VFW_S_NO_MORE_ITEMS;

    }

} /* CAudMixerInputPin::GetMediaType */

//############################################################################
// 
//############################################################################

//
// SetMediaType
//
HRESULT CAudMixerInputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    HRESULT hr;
    hr = CBasePin::SetMediaType(pmt);

    return hr;
}

//############################################################################
// 
//############################################################################

//
// BreakConnect
//
HRESULT CAudMixerInputPin::BreakConnect()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    m_mt.SetType(&GUID_NULL);

    return CBaseInputPin::BreakConnect();
} /* CAudMixerInputPin::BreakConnect */


//############################################################################
// 
//############################################################################

//
// EndOfStream
//
HRESULT CAudMixerInputPin::EndOfStream()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    HRESULT hr = S_OK;

    CAutoLock ReceiveLock(&m_pFilter->m_csReceive);

    m_fEOSReceived = TRUE;
    
    m_pFilter->TryToMix(MAX_TIME);

    return hr;

} /* CAudMixerInputPin::EndOfStream */


//############################################################################
// 
//############################################################################

HRESULT CAudMixerInputPin::Inactive()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    // make sure receive is done
    CAutoLock l(&m_pFilter->m_csReceive);
    ClearCachedData();

    return CBaseInputPin::Inactive();
}

//############################################################################
// 
//############################################################################

HRESULT CAudMixerInputPin::ClearCachedData()
{

    IMediaSample *pSample;
    while (pSample = GetHeadSample()) {
    pSample->Release();

    m_SampleList.RemoveHead();
    }
    m_lBytesUsed = 0;
    m_fEOSReceived = FALSE;

    m_pFilter->m_fEOSSent = FALSE;
    m_iVolEnvEntryCnt=0;
    
    //reset output pin's cnt
    m_pFilter->ResetOutputPinVolEnvEntryCnt();
    
    return S_OK;
}

//############################################################################
// 
//############################################################################

//
// BeginFlush
//
HRESULT CAudMixerInputPin::BeginFlush()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    // sending the message downstream. 
    HRESULT hr = S_OK;
    
    if (0 == m_pFilter->m_cFlushDelivery++ && m_pFilter->m_pOutput) {
        DbgLog((LOG_TRACE,3,TEXT("CAudMixIn::BeginFlush")));
    hr = m_pFilter->m_pOutput->DeliverBeginFlush();
    }

    if( SUCCEEDED( hr ) )
        hr = CBaseInputPin::BeginFlush();

    // wait for receive to finish before nuking its data
    CAutoLock l(&m_pFilter->m_csReceive);

    m_pFilter->ClearHotnessTable( );

    // nuke away!
    ClearCachedData();
    
    return hr;
} /* CAudMixerInputPin::BeginFlush */


//############################################################################
// 
//############################################################################

//
// EndFlush
//
HRESULT CAudMixerInputPin::EndFlush()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);


    // sending the message downstream.
    HRESULT hr = S_OK;

    if (1 == m_pFilter->m_cFlushDelivery-- && m_pFilter->m_pOutput)
    {
        DbgLog((LOG_TRACE,3,TEXT("CAudMixIn::EndFlush")));
    hr = m_pFilter->m_pOutput->DeliverEndFlush();
    m_pFilter->m_bNewSegmentDelivered = FALSE;
    }

    if( SUCCEEDED( hr ) )
        hr = CBaseInputPin::EndFlush();

    return hr;
} /* CAudMixerInputPin::EndFlush */

//############################################################################
// 
//############################################################################

//
// NewSegment
//                
HRESULT CAudMixerInputPin::NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop,
    double dRate)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    // a new time needs to be delivered again - we might not be flushed
    if (tStart != m_tStart)
    m_pFilter->m_bNewSegmentDelivered = FALSE;
    
    HRESULT hr = S_OK;
    
    if (!m_pFilter->m_bNewSegmentDelivered && m_pFilter->m_pOutput) {
        DbgLog((LOG_TRACE,3,TEXT("CAudMixIn::NewSegment %d"),
                        (int)(tStart / 10000)));
    hr = m_pFilter->m_pOutput->DeliverNewSegment(tStart, tStop, dRate);
    }

    if( SUCCEEDED( hr ) )
    {
    m_pFilter->m_bNewSegmentDelivered = TRUE;
        hr = CBaseInputPin::NewSegment(tStart, tStop, dRate);
    }

    return hr;
} /* CAudMixerInputPin::NewSegment */


//############################################################################
// 
//############################################################################

//
// Receive
//
HRESULT CAudMixerInputPin::Receive(IMediaSample *pSample)
{
    // We are receiving data, we better have an output pin
    ASSERT(m_pFilter->m_pOutput);
    
    CAutoLock ReceiveLock(&m_pFilter->m_csReceive);

    if( m_fEOSReceived )
        return S_FALSE;

    if(m_fEnable==FALSE)
    return NOERROR;

    HRESULT hr = CBaseInputPin::Receive(pSample);

    if( SUCCEEDED( hr ) )
    {
    // Keep this sample and add it to the sample list
    pSample->AddRef();                  // keep new one
    m_SampleList.AddTail(pSample);

    //Pan audio?
    WAVEFORMATEX * vih = (WAVEFORMATEX*) m_mt.Format( );
    if( (m_dPan!=0.0) &&  (vih->nChannels==2) )
    {
        
        BYTE * pIn;
        pSample->GetPointer(&pIn);
        long Length=pSample->GetActualDataLength();

        Length /=(long)( vih->nBlockAlign );

        PanAudio(pIn,m_dPan, vih->wBitsPerSample, (int) Length);
    }

    REFERENCE_TIME rtStart, rtStop;
    hr = pSample->GetTime(&rtStart, &rtStop);
    if (FAILED(hr))
        return hr;    // we can't mix without time stamps!
     DbgLog((LOG_TRACE,3,TEXT("MIX: Receive pin %d (%d, %d) %d bytes"),
            m_iPinNo, (int)(rtStart/10000), (int)(rtStop/10000),
            (int)(pSample->GetActualDataLength())));

    rtStart += m_tStart;
    rtStop += m_tStart;
    DbgLog((LOG_TRACE,3,TEXT("Adding NewSeg of %d"),(int)(m_tStart/10000)));

    //apply volume envelope
    if(m_pVolumeEnvelopeTable)
    {
	// we're looking at the envelope, which can change at any moment
        CAutoLock l(&m_pFilter->m_csVol);

        // the volume enveloping code assumes that
        // the incoming times are in terms of it's offsets,
        // not in terms of timeline time. If this pin has an audio
        // envelope, ValidateRange will have been called on it,
        // and it will be the first validate range called.
        //
        REFERENCE_TIME Start, Stop;
        Start = rtStart - m_rtEnvStart;
        Stop = rtStop - m_rtEnvStart;
    
      ApplyVolEnvelope( Start,  //output sample start time
             Stop,    //output sample stop time
             m_rtEnvStop - m_rtEnvStart,
             pSample,    //point to the sample
             vih,     //output sample format
             &m_VolumeEnvelopeEntries,   //total Envelope Entries
             &m_iVolEnvEntryCnt,    //current Entry point
             m_pVolumeEnvelopeTable);    //Envelope Table
    }
    
    // !!! I am assuming everything received is wholly within a valid range!

    // mix
    hr = m_pFilter->TryToMix(rtStart);

    } // endif SUCCEEDED(hr) base pin receive.

    return hr;
}

//############################################################################
// 
//############################################################################

BOOL CAudMixerInputPin::IsValidAtTime(REFERENCE_TIME rt)
{
    for (int z=0; z<m_cValid; z++) {
    if (rt >= m_pValidStart[z] && rt < m_pValidStop[z])
        return TRUE;
    }
    return FALSE;
}

//############################################################################
// 
//############################################################################

//
// CompleteConnect
//
HRESULT CAudMixerInputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);

    // Since this pin has been connected up, create another input pin
    // if there are no unconnected pins.
    if( SUCCEEDED( hr ) )
    {
        int n = m_pFilter->GetNumFreePins();

        if( n == 0 )
        {
            // No unconnected pins left so spawn a new one
            CAudMixerInputPin *pInputPin = m_pFilter->CreateNextInputPin(m_pFilter);
            if( pInputPin != NULL )
                m_pFilter->IncrementPinVersion();
        }

    }

    return hr;
} /* CAudMixerInputPin::CompleteConnect */


//############################################################################
// 
//############################################################################

// ISpecifyPropertyPages 
STDMETHODIMP CAudMixerInputPin::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*1);
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    pPages->pElems[0] = CLSID_AudMixPinPropertiesPage;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

//
// methords in  IAMAudioInputMixer
//    
STDMETHODIMP CAudMixerInputPin::put_Pan(double Pan)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    //can not change property if the filter is not currently stopped
    if(!IsStopped() )
      return E_FAIL;    //VFW_E_WRONG_STATE;
  
    m_dPan = Pan;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::get_Pan( double FAR* pPan )
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    CheckPointer(pPan,E_POINTER);

    *pPan = m_dPan;

    return NOERROR;

} // get_Pan

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::put_Enable(BOOL fEnable)
{
 
    CAutoLock cAutolock(m_pFilter->m_pLock);

    //can not change property if the filter is not currently stopped
    if(!IsStopped() )
      return E_FAIL;        //VFW_E_WRONG_STATE;
  
    m_fEnable = fEnable;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::get_Enable(BOOL *pfEnable)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    CheckPointer(pfEnable,E_POINTER);

    *pfEnable=m_fEnable;

    return NOERROR;

} // get_Enable


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::InvalidateAll()
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    m_cValid = 0;
    return NOERROR;
}


STDMETHODIMP CAudMixerInputPin::ValidateRange(REFERENCE_TIME rtStart,
                        REFERENCE_TIME rtStop)
{
    CAutoLock cAutolock(m_pFilter->m_pLock);

    if (m_cValid == m_cValidMax) {
        m_cValidMax += 10;
        m_pValidStart = (REFERENCE_TIME *)QzTaskMemRealloc(m_pValidStart,
                sizeof(REFERENCE_TIME) * m_cValidMax);
        if (m_pValidStart == NULL)
            return E_OUTOFMEMORY;
        m_pValidStop = (REFERENCE_TIME *)QzTaskMemRealloc(m_pValidStop,
                sizeof(REFERENCE_TIME) * m_cValidMax);
        if (m_pValidStop == NULL)
            return E_OUTOFMEMORY;
    }

    m_pValidStart[m_cValid] = rtStart;
    m_pValidStop[m_cValid] = rtStop;
    m_cValid++;

    return NOERROR;
}

STDMETHODIMP CAudMixerInputPin::SetEnvelopeRange( REFERENCE_TIME rtStart,
                                                 REFERENCE_TIME rtStop )
{
    m_rtEnvStart = rtStart;
    m_rtEnvStop = rtStop;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

//
// When *ppsAudioVolumeEnvelopeTable=NULL return m_VolumeEnvelopeEntries
// so, user can allocte/release memory space
//
STDMETHODIMP CAudMixerInputPin::get_VolumeEnvelope(DEXTER_AUDIO_VOLUMEENVELOPE **ppsAudioVolumeEnvelopeTable, 
            int *ipEntries )
{
    // we're looking at the envelope, which can change at any moment
    CAutoLock l(&m_pFilter->m_csVol);

    CheckPointer(ipEntries,E_POINTER);

    *ipEntries=m_VolumeEnvelopeEntries;

    if(*ppsAudioVolumeEnvelopeTable != NULL)
    {
    int iSize=*ipEntries * sizeof(DEXTER_AUDIO_VOLUMEENVELOPE);
    
    CopyMemory( (PBYTE)*ppsAudioVolumeEnvelopeTable,(PBYTE)m_pVolumeEnvelopeTable, iSize);
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

//
// if (m_pVolumeEnvelopeTable!=NULL)
//    insert input envelope table to existed m_pVolumeEnvelopeTable table
//  else
//    input table =m_pVolumeEnvelopeTable
//
STDMETHODIMP CAudMixerInputPin::put_VolumeEnvelope(const DEXTER_AUDIO_VOLUMEENVELOPE *psAudioVolumeEnvelopeTable,
                const int iEntries)
{ 
    // we're touching the envelope
    CAutoLock l(&m_pFilter->m_csVol);

    if(!iEntries) return NOERROR;

    DbgLog((LOG_TRACE, 1, TEXT("CAudMixIn::put_Envelope %d"), iEntries));

    CheckPointer(psAudioVolumeEnvelopeTable,E_POINTER);

    putVolumeEnvelope( psAudioVolumeEnvelopeTable, //current input table
            iEntries, // current input entries
            &m_pVolumeEnvelopeTable    , //existed table    
            &m_VolumeEnvelopeEntries); //existed table netries

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::ClearVolumeEnvelopeTable()
{ 

    // we're touching the envelope
    CAutoLock l(&m_pFilter->m_csVol);

    //clear existed VolumeEnvelope Array entry cnt
    m_VolumeEnvelopeEntries =0;

    //free pre-exist table
    if (m_pVolumeEnvelopeTable)
        QzTaskMemFree(m_pVolumeEnvelopeTable);
    m_pVolumeEnvelopeTable = NULL;

    //reset entry point
    m_iVolEnvEntryCnt=0;

    return NOERROR;

}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::put_PropertySetter( const IPropertySetter * pSetter )
{
    return PinSetPropertySetter( this, pSetter );
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::put_UserID(long ID)
{
    m_UserID = ID;
    return S_OK;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::get_UserID(long *pID)
{
    CheckPointer(pID, E_POINTER);
    *pID = m_UserID;
    return S_OK;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAudMixerInputPin::OverrideVolumeLevel(double dVol)
{
    DEXTER_AUDIO_VOLUMEENVELOPE env;
    env.rtEnd = 0;
    env.dLevel = dVol;
    env.bMethod = DEXTERF_JUMP;

    ClearVolumeEnvelopeTable();
    HRESULT hr = put_VolumeEnvelope(&env, 1);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audmix\setup.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: setup.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "AudMix.h"
#include "prop.h"

// Using this pointer in constructor
#pragma warning(disable:4355)

// Setup data

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Audio,   // Major CLSID
    &MEDIASUBTYPE_PCM  // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",            // Pin's string name - this pin is what pulls the filter into the graph
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      NULL,                 // Connects to pin
      1,                    // Number of types
      &sudPinTypes },	    // Pin information
    { L"Output",            // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes }        // Pin information
};

const AMOVIESETUP_FILTER sudAudMixer =
{
    &CLSID_AudMixer,       // CLSID of filter
    L"Audio Mixer",     // Filter's name
    MERIT_DO_NOT_USE,             // Filter merit
    2,                          // Number of pins to start
    psudPins                    // Pin information
};

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CAudMixer::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CAudMixer(NAME("Audio Mixer"), pUnk, phr);
} /* CAudMixer::CreateInstance */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audpack\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#define IDD_AUDREPACK 	    800
#define IDC_AUD_RATE        810
#define IDC_AUD_SKEW        811
#define IDC_AUD_START       812
#define IDC_AUD_STOP        813
#define IDS_AUDPROP_TITLE   820
#ifndef IDC_STATIC
#define IDC_STATIC          -1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audpack\audpack.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: audpack.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

class CAudPassThru;     // IMediaSeeking support
class CAudRepack;

extern const AMOVIESETUP_FILTER sudAudRepack;

class CAudWorker : public CAMThread
{

    CAudRepack * m_pAud;

public:
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

private:
    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    HRESULT DoRunLoop(void);

public:
    CAudWorker();

    BOOL Create(CAudRepack * pAud);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();

    HRESULT Exit();
};

class CAudRepack 
    : public CTransformFilter
    , public IDexterSequencer
    , public CPersistStream
    , public ISpecifyPropertyPages
{

    friend class CAudRepackInputPin;
    friend class CAudRepackOutputPin;
    friend class CAudPassThru;
    friend class CAudWorker;

public:

    static CUnknown * CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    // These implement the custom IDexterSequencer interface
    // FrmRate == FrmPerSecond
    STDMETHODIMP get_OutputFrmRate(double *dpFrmRate);
    STDMETHODIMP put_OutputFrmRate(double dFrmRate);
    STDMETHODIMP get_Skew(REFERENCE_TIME *pSkew);
    STDMETHODIMP put_Skew(REFERENCE_TIME Skew);
    STDMETHODIMP get_MediaType( AM_MEDIA_TYPE * pMediaType );
    STDMETHODIMP put_MediaType(const AM_MEDIA_TYPE * pMediaType );

    STDMETHODIMP GetStartStopSkew(REFERENCE_TIME *pStart, REFERENCE_TIME *pStop, REFERENCE_TIME *pSkew, double *pdRate);
    STDMETHODIMP AddStartStopSkew(REFERENCE_TIME Start, REFERENCE_TIME Stop, REFERENCE_TIME Skew, double dRate);
    STDMETHODIMP ClearStartStopSkew();
    STDMETHODIMP GetStartStopSkewCount(int *pCount);

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages (CAUUID *);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

private:

    DECLARE_IUNKNOWN;

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);
    HRESULT CheckInputType( const CMediaType * pmt );
    HRESULT DecideBufferSize( IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * pPropInputRequest );
    HRESULT GetMediaType( int iPosition, CMediaType *pMediaType );
    HRESULT CheckTransform( const CMediaType * p1, const CMediaType * p2 );
    // this is NEVER called
    HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut) { return E_FAIL; }
    HRESULT NewSegment( REFERENCE_TIME tStart, REFERENCE_TIME tStop, double Rate );
    HRESULT Receive(IMediaSample * pSample);
    HRESULT EndOfStream( );
    HRESULT BeginFlush( );
    HRESULT EndFlush( );
    HRESULT StartStreaming();
    HRESULT StopStreaming();
    STDMETHODIMP Stop();
    CBasePin *GetPin(int n);

    HRESULT NextSegment(BOOL);
    HRESULT SeekNextSegment();

protected:
    // Constructor
    CAudRepack(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
    ~CAudRepack();

    double m_dOutputFrmRate; // set by IDexterSequencer

    bool m_bFirstSample;
    REFERENCE_TIME m_trStopLast;	// last stop time received
    BYTE * m_pCache;
    long m_nCacheSize;
    long m_nInCache;
    double m_dError;	// error propagation
    BYTE * m_pReadPointer;
    LONGLONG m_llStartFrameOffset;	// after a seek, the first frame sent
    LONGLONG m_llSamplesDelivered;
    LONGLONG m_llPacketsDelivered;
    CMediaType m_mtAccept;		// all pins only connect with this
    bool m_bMediaTypeSetByUser;


    int m_nSPS;		// samples per second we're working with
    int m_nSampleSize;	// bytes per sample at this format

    REFERENCE_TIME m_Tare;	// to line up the sample times

    void Free( );
    HRESULT Init( );
    HRESULT DeliverOutSample(BYTE *, int, REFERENCE_TIME, REFERENCE_TIME);

    // StartStopSkew stuff

    typedef struct {
        REFERENCE_TIME rtMStart;
        REFERENCE_TIME rtMStop;
        REFERENCE_TIME rtSkew;
        REFERENCE_TIME rtTLStart;
        REFERENCE_TIME rtTLStop;
        double dRate;
    } AUDSKEW;

    AUDSKEW *m_pSkew;
    int m_cTimes;	// # of items in skew
    int m_cMaxTimes;	// size allocated for this many items
    int m_nCurSeg;	// current index of array being played
    int m_nSeekCurSeg;	// new value being set by the seek

    REFERENCE_TIME m_rtLastSeek;	// last timeline time seek command
    REFERENCE_TIME m_rtNewLastSeek;	// next value for m_rtLastSeek
    REFERENCE_TIME m_rtNewSeg;		// NewSeg we sent downstream
    REFERENCE_TIME m_rtPinNewSeg;	// NewSeg we were given

    BOOL m_fSeeking;	// in the middle of a seek?
    HANDLE m_hEventSeek;

    LPBYTE m_pResample;	// place for resampled audio
    int m_cResample;

    CAudWorker m_worker;
    HANDLE m_hEventThread;
    BOOL m_fThreadMustDie;
    BOOL m_fThreadCanSeek;
    BOOL m_fSpecialSeek;
    CCritSec m_csThread;

    BOOL m_fStopPushing;
    BOOL m_fFlushWithoutSeek;

};



// overridden to provide major type audio on GetMediaType. This IMMENSELY
// speeds up intelligent connects
//
class CAudRepackInputPin : public CTransformInputPin
{
public:
    CAudRepackInputPin( TCHAR *pObjectName
                             , CAudRepack *pAudRepack
                             , HRESULT * phr
                             , LPCWSTR pName
                             );
    ~CAudRepackInputPin();

    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

private:
    CAudRepack     	  *m_pAudRepack;
};


//
// CAudRepackOutputPin class
//
class CAudRepackOutputPin : public CTransformOutputPin
{
    friend class CAudRepack;
    friend class CAudRepackInputPin;

public:
    CAudRepackOutputPin( TCHAR *pObjectName
                             , CAudRepack *pAudRepack
                             , HRESULT * phr
                             , LPCWSTR pName
                             );
    ~CAudRepackOutputPin();

    // expose IMediaSeeking
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);
   
private:
    CAudRepack     	  *m_pAudRepack;
    CAudPassThru	  *m_pAudPassThru;
};


class CAudPropertyPage : public CBasePropertyPage
{

    public:

      static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    private:

      INT_PTR OnReceiveMessage (HWND, UINT ,WPARAM ,LPARAM);

      HRESULT OnConnect (IUnknown *);
      HRESULT OnDisconnect (void);
      HRESULT OnActivate (void);
      HRESULT OnDeactivate (void);
      HRESULT OnApplyChanges (void);

      void SetDirty (void);

      CAudPropertyPage (LPUNKNOWN, HRESULT *);

      void GetControlValues (void);

      IDexterSequencer *m_pifrc;

      // Temporary variables (until OK/Apply)

      double          m_dFrameRate;
      REFERENCE_TIME  m_rtSkew;
      REFERENCE_TIME  m_rtMediaStart;
      REFERENCE_TIME  m_rtMediaStop;
      double          m_dRate;
      BOOL            m_bInitialized;
};  // CAudPropertyPage //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audpack\prop.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: prop.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;


#include <windows.h>
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "audpack.h"
#include "seek.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////
//
// CAudPropertyPage
//
//////////////////////////////////////////////////////////////////////////

//
// CreateInstance
//
CUnknown *CAudPropertyPage::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)

  { // CreateInstance //

    CUnknown *punk = new CAudPropertyPage(lpunk, phr);

    if (NULL == punk)
	    *phr = E_OUTOFMEMORY;

    return punk;

  } // CreateInstance //

CAudPropertyPage::CAudPropertyPage(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("Audio Repackager Property Page"), pUnk, IDD_AUDREPACK, IDS_AUDPROP_TITLE)
    , m_pifrc(NULL)
    , m_bInitialized(FALSE)
    , m_dFrameRate( 0 )
    , m_rtSkew( 0 )
    , m_rtMediaStart( 0 )
    , m_rtMediaStop( 0 )
    , m_dRate( 0 )
{
}

void CAudPropertyPage::SetDirty()
{ // SetDirty //

      m_bDirty = TRUE;

      if (m_pPageSite)
	m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

  } // SetDirty //

HRESULT CAudPropertyPage::OnActivate (void)

  { // OnActivate //

    m_bInitialized = TRUE;

    return NOERROR;

  } // OnActivate //

HRESULT CAudPropertyPage::OnDeactivate (void)

  { // OnDeactivate //

    m_bInitialized = FALSE;

    GetControlValues();

    return NOERROR;

  } // OnDeactivate //

INT_PTR CAudPropertyPage::OnReceiveMessage (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

  { // OnReceiveMessage //

    ASSERT(m_pifrc != NULL);

    switch(uMsg)

      { // Switch

	case WM_COMMAND:

	  if (!m_bInitialized)
	    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

	  m_bDirty = TRUE;

	  if (m_pPageSite)
	    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

	  return TRUE;

        case WM_INITDIALOG:
          SetDlgItemInt(hwnd, IDC_AUD_RATE, (int)(m_dFrameRate * 100), FALSE);
          SetDlgItemInt(hwnd, IDC_AUD_SKEW, (int)(m_rtSkew / 10000), TRUE);
          SetDlgItemInt(hwnd, IDC_AUD_START, (int)(m_rtMediaStart / 10000),
									FALSE);
          SetDlgItemInt(hwnd, IDC_AUD_STOP, (int)(m_rtMediaStop / 10000),
									FALSE);
          return TRUE;
          break;

	default:
	  return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
	  break;

      } // Switch

  } // OnReceiveMessage //

HRESULT CAudPropertyPage::OnConnect (IUnknown *pUnknown)

  { // OnConnect //
    HRESULT hr;
    
    pUnknown->QueryInterface(IID_IDexterSequencer, (void **)&m_pifrc);

    CheckPointer( m_pifrc, E_POINTER );

    ASSERT(m_pifrc != NULL);

    // Defaults from filter's current values (via IFrameRateConverter)
    hr = m_pifrc->get_OutputFrmRate(&m_dFrameRate);
    if( FAILED( hr ) )
    {
        return hr;
    }

    // !!! we only support one start/stop/skew in this prop page
    int c;
    hr = m_pifrc->GetStartStopSkewCount(&c);
    if( FAILED( hr ) )
    {
        return hr;
    }

    REFERENCE_TIME *pStart = (REFERENCE_TIME *)QzTaskMemAlloc(c * 3 *
				sizeof(REFERENCE_TIME) + c * sizeof(double));
    if (pStart == NULL) {
	return E_OUTOFMEMORY;
    }
    REFERENCE_TIME *pStop = pStart + c;
    REFERENCE_TIME *pSkew = pStop + c;
    double *pRate = (double *)(pSkew + c);

    hr = m_pifrc->GetStartStopSkew(pStart, pStop, pSkew, pRate);
    if( FAILED( hr ) )
    {
        return hr;
    }

    m_rtMediaStart = *pStart;
    m_rtMediaStop = *pStop;
    m_rtSkew = *pSkew;
    m_dRate = *pRate;

    m_bInitialized = FALSE;

    QzTaskMemFree(pStart);

    return NOERROR;

  }

HRESULT CAudPropertyPage::OnDisconnect()

  { // OnDisconnect //

    if (m_pifrc)

      { // Release

	m_pifrc->Release();
	m_pifrc = NULL;

      } // Release

    m_bInitialized = FALSE;

    return NOERROR;

  } // OnDisconnect //

HRESULT CAudPropertyPage::OnApplyChanges()

  { // OnApplyChanges //

    ASSERT(m_pifrc != NULL);

    GetControlValues();

    HRESULT hr;
    hr = m_pifrc->put_OutputFrmRate(m_dFrameRate);
    if( FAILED( hr ) )
    {
        return hr;
    }
    hr = m_pifrc->ClearStartStopSkew();
    if( FAILED( hr ) )
    {
        return hr;
    }
    hr = m_pifrc->AddStartStopSkew(m_rtMediaStart, m_rtMediaStop, m_rtSkew, m_dRate);
    if( FAILED( hr ) )
    {
        return hr;
    }

    return NOERROR;

  } // OnApplyChanges //

void CAudPropertyPage::GetControlValues (void)

  { // GetControlValues //

    int n;

    // Frame rate
    n = GetDlgItemInt(m_Dlg, IDC_AUD_RATE, NULL, FALSE);
    m_dFrameRate = (double)(n / 100.);

    // Skew
    n = GetDlgItemInt(m_Dlg, IDC_AUD_SKEW, NULL, TRUE);
    m_rtSkew = (REFERENCE_TIME)n * 10000;

    // Media times
    n = GetDlgItemInt(m_Dlg, IDC_AUD_START, NULL, FALSE);
    m_rtMediaStart = (REFERENCE_TIME)n * 10000;
    n = GetDlgItemInt(m_Dlg, IDC_AUD_STOP, NULL, FALSE);
    m_rtMediaStop = (REFERENCE_TIME)n * 10000;

  } // GetControlValues //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audpack\seek.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: seek.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// {DBF8F620-53F0-11d2-9EE6-006008039E37}
DEFINE_GUID(CLSID_AudPassThru, 
0xdbf8f620, 0x53f0, 0x11d2, 0x9e, 0xe6, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37);

class CAudPassThru : public CPosPassThru
		    
{
    friend class CAudRepack;
    friend class CAudRepackOutputPin;

public:

    CAudPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *, CAudRepack *pAud);

    //only support IMediaSeeking
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities ); 
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);	
    STDMETHODIMP GetTimeFormat(GUID *pFormat);		    
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);  
    STDMETHODIMP IsFormatSupported( const GUID * pFormat); 
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);	    
    
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll ) { if( pllPreroll) *pllPreroll =0; return S_OK; };
    
    //methods we do not support
    STDMETHODIMP SetRate( double dRate)	    { return E_NOTIMPL; };
    // STDMETHODIMP GetRate( double * pdRate); //use the base class
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
				   LONGLONG    Source, const GUID * pSourceFormat ){ return E_NOTIMPL ;};


private:
    
    // converts clip time to timeline time
    HRESULT FixTime(REFERENCE_TIME *prt, int nCurSeg);
    // converts timeline time to clip time
    int FixTimeBack(REFERENCE_TIME *prt, BOOL fRound);

    CAudRepack	*m_pAudRepack;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audpack\seek.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: seek.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "audpack.h"
#include "seek.h"

BOOL SafeSetEvent(HANDLE h);

CAudPassThru::CAudPassThru(const TCHAR *pName,
			   LPUNKNOWN pUnk,
			   HRESULT *phr,
			   IPin *pPin,
			   CAudRepack *pAud) :
    CPosPassThru(pName,pUnk, phr, pPin),
    m_pAudRepack( pAud )
{
}

// Expose our IMediaSeeking interfaces
STDMETHODIMP
CAudPassThru::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    *ppv = NULL;

    if (riid == IID_IMediaSeeking)
    {
	return GetInterface( static_cast<IMediaSeeking *>(this), ppv);
    }
    else {
	//we only support the IID_DIMediaSeeking
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// fix a clip time into timeline time, bounding it by the legal area
//
HRESULT CAudPassThru::FixTime(REFERENCE_TIME *prt, int nCurSeg)
{
    CheckPointer(prt, E_POINTER);

    REFERENCE_TIME rtStart, rtStop, rtSkew;
    double dRate;
    rtSkew = m_pAudRepack->m_pSkew[nCurSeg].rtSkew;
    rtStart = m_pAudRepack->m_pSkew[nCurSeg].rtMStart;
    rtStop = m_pAudRepack->m_pSkew[nCurSeg].rtMStop;
    dRate = m_pAudRepack->m_pSkew[nCurSeg].dRate;
    if (*prt < rtStart)
	*prt = rtStart;
    if (*prt > rtStop)
	*prt = rtStop;
    *prt = (REFERENCE_TIME)(rtStart + rtSkew + (*prt - rtStart) / dRate);
    return S_OK;
}


// fix a timeline time back into clip time, bounding it by the legal area
//
int CAudPassThru::FixTimeBack(REFERENCE_TIME *prt, BOOL fRound)
{
    CheckPointer(prt, E_POINTER);
    REFERENCE_TIME rtStart, rtStop, rtSkew;
    REFERENCE_TIME rtTLStart, rtTLStop;
    double dRate;

    if (m_pAudRepack->m_cTimes == 0) {
	ASSERT(FALSE);
	return 0;
    }

    REFERENCE_TIME rtSave; // gets inited below
    for (int z = 0; z < m_pAudRepack->m_cTimes; z++) {
        rtSkew = m_pAudRepack->m_pSkew[z].rtSkew;
        rtStart = m_pAudRepack->m_pSkew[z].rtMStart;
        rtStop = m_pAudRepack->m_pSkew[z].rtMStop;
        dRate = m_pAudRepack->m_pSkew[z].dRate;
	rtTLStart = rtStart + rtSkew;
	rtTLStop = rtStart + rtSkew +
			(REFERENCE_TIME) ((rtStop - rtStart) / dRate);
	if (*prt < rtTLStart) {
	    *prt = rtStart;
	    break;
	} else if (*prt >= rtTLStop) {
	    // just in case there is no next segment, this is the final value
	    rtSave = rtStop;
	} else {
    	    *prt = (REFERENCE_TIME)(rtStart + (*prt - (rtStart + rtSkew)) *
								dRate);
	    break;
	}
    }
    if (z == m_pAudRepack->m_cTimes) {
	z--;
	*prt = rtSave;
    }
    return z;
}


// --- IMediaSeeking methods ----------

STDMETHODIMP
CAudPassThru::GetCapabilities(DWORD * pCaps)
{
    return CPosPassThru::GetCapabilities(pCaps);
}


STDMETHODIMP
CAudPassThru::CheckCapabilities(DWORD * pCaps)
{
    return CPosPassThru::CheckCapabilities(pCaps);
}


STDMETHODIMP
CAudPassThru::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

STDMETHODIMP
CAudPassThru::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

STDMETHODIMP
CAudPassThru::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);

    if(*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return E_FAIL;
}

STDMETHODIMP
CAudPassThru::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    return S_OK;
}

STDMETHODIMP
CAudPassThru::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    if (*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return S_FALSE;
}

// The biggie!
//
STDMETHODIMP
CAudPassThru::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
    // make sure our re-using sources thread isn't seeking at the moment.
    // Wait till it's done, so the app seek happens last, and that the thread
    // won't seek anymore from now on

    CAutoLock cAutolock(&m_pAudRepack->m_csThread);

    // make sure we don't change state during this
    CAutoLock c(&m_pAudRepack->m_csFilter);

    m_pAudRepack->m_fThreadCanSeek = FALSE;

    HRESULT hr;
    REFERENCE_TIME rtStart;
    int nCurSeg = m_pAudRepack->m_nCurSeg;

    // we don't do segments
    if ((CurrentFlags & AM_SEEKING_Segment) ||
				(StopFlags & AM_SEEKING_Segment)) {
    	DbgLog((LOG_TRACE,1,TEXT("AudPack: ERROR-Seek used EC_ENDOFSEGMENT!")));
	return E_INVALIDARG;
    }

    // !!! We ignore stop times, because of the way we re-use sources and play
    // things in segments.  We will always send a stop time upstream equal to
    // the end of the current segment, and only pay attention to changes in the
    // start time.  This will work only because the switch will ignore things
    // we send after we were supposed to stop and stop us.

    DWORD dwFlags = (CurrentFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	rtStart = *pCurrent;
	nCurSeg = FixTimeBack(&rtStart, FALSE);
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	hr = CPosPassThru::GetCurrentPosition(&rtStart);
	if (hr != S_OK)
	    return hr;
	FixTime(&rtStart, m_pAudRepack->m_nCurSeg);
	rtStart += *pCurrent;
	nCurSeg = FixTimeBack(&rtStart, FALSE);
    } else if (dwFlags) {
    	DbgLog((LOG_TRACE,1,TEXT("AudPack::Invalid Current Seek flags")));
	return E_INVALIDARG;
    }

    if (!(CurrentFlags & AM_SEEKING_PositioningBitsMask)) {
	return S_OK;	// nothing to do
    }

    DWORD CFlags = CurrentFlags & ~AM_SEEKING_PositioningBitsMask;
    DWORD SFlags = StopFlags & ~AM_SEEKING_PositioningBitsMask;
    CFlags |= AM_SEEKING_AbsolutePositioning;
    SFlags |= AM_SEEKING_AbsolutePositioning;
    DbgLog((LOG_TRACE,1,TEXT("AudPack: Seek to %dms"),
					(int)(rtStart / 10000)));

    // we're in the middle of seeking.  This thread will generate flushes
    m_pAudRepack->m_fSeeking = TRUE;

    // we can't set the LastSeek variable until we've been flushed, and old
    // data has stopped arriving.  It must be send between the flush and the
    // next NewSegment call, so we'll set it in EndFlush to this value
    m_pAudRepack->m_rtNewLastSeek = rtStart;
    FixTime(&m_pAudRepack->m_rtNewLastSeek, nCurSeg);

    // the flush generated by the seek below needs to know this
    m_pAudRepack->m_nSeekCurSeg = nCurSeg;

    // I know we were asked to play until time n, but I'm going to tell it to
    // play all the way to the end.  If there's a gap in the file, and the stop
    // time is during the gap, we won't get enough samples to fill the whole
    // playing time.  If we play until the end, we'll get the first sample
    // after the gap, notice it's after the time we originally wanted to stop
    // at, and send silence to fill the gap, noticing there has been a gap.
    // The alternative is just trigger sending silence to fill the gap when
    // we get an EOS earlier than we expected.
    hr = CPosPassThru::SetPositions(&rtStart, CFlags, NULL, 0);
    if (hr != S_OK) {
        // MPEG1 parser audio pin fails seek, but that's ok.  video does it
        DbgLog((LOG_TRACE,1,TEXT("AudPack: SEEK ERROR!")));
    }

    // if the push thread was stopped, we won't get flushed, and this won't
    // have been updated
    // !!! I ASSUME the push thread won't be started until this thread does it
    // when this function returns, or there is a race condition
    m_pAudRepack->m_rtLastSeek = m_pAudRepack->m_rtNewLastSeek;

    // OK, no longer seeking
    m_pAudRepack->m_fSeeking = FALSE;

    // Not necessary. Flush & StartStreaming do this, which is what matters
    // m_pAudRepack->Init();

    // in case we weren't flushed
    m_pAudRepack->m_nCurSeg = nCurSeg;

    // (see comment about sharing a source filter at the top of audpack.cpp)
    // We were waiting for this seek, ever since we got a surprise flush.
    // Now that the switch knows about the seek, we can resume sending it
    // new data, and allow Receive to be entered (set the Seek event)
    // making sure we've set all our variables first before releasing the hounds
    //
    if (m_pAudRepack->m_fFlushWithoutSeek) {
	m_pAudRepack->m_fFlushWithoutSeek = FALSE;
    	DbgLog((LOG_TRACE,1,TEXT("SURPRISE FLUSH followed by a SEEK - OK to resume")));

        // DO NOT FLUSH! The push thread has already started delivering the new
        // post-seek data... flushing will kill it and hang us!
	
    } else if (m_pAudRepack->m_State == State_Paused) {
	// Set this so that if a flush ever happens without a seek later,
	// we'll know that flush was AFTER the seek, not before
	m_pAudRepack->m_fFlushWithoutSeek = TRUE;
    	DbgLog((LOG_TRACE,1,TEXT("AudPack SEEK - State=3")));
    }

    // after the seek, all receives block until we fix the calculations above.
    // Now it's ok to receive again.
    SafeSetEvent(m_pAudRepack->m_hEventSeek);

    return S_OK;
}

STDMETHODIMP
CAudPassThru::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop)
{
    HRESULT hr=CPosPassThru::GetPositions(pCurrent, pStop);
    if(hr== S_OK)
    {
	FixTime(pCurrent, m_pAudRepack->m_nCurSeg);
	FixTime(pStop, m_pAudRepack->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CAudPassThru::GetCurrentPosition(LONGLONG *pCurrent)
{
    HRESULT hr = CPosPassThru::GetCurrentPosition(pCurrent);
    if(hr== S_OK)
    {
	FixTime(pCurrent, m_pAudRepack->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CAudPassThru::GetStopPosition(LONGLONG *pStop)
{
    HRESULT hr=CPosPassThru::GetStopPosition(pStop);
    if( hr == S_OK)
    {
	FixTime(pStop, m_pAudRepack->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CAudPassThru::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
    CheckPointer(pEarliest, E_POINTER);
    CheckPointer(pLatest, E_POINTER);

    *pEarliest = m_pAudRepack->m_pSkew[m_pAudRepack->m_nCurSeg].rtMStart;
    *pLatest = m_pAudRepack->m_pSkew[m_pAudRepack->m_nCurSeg].rtMStop;

    FixTime(pEarliest, m_pAudRepack->m_nCurSeg);
    FixTime(pLatest, m_pAudRepack->m_nCurSeg);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\audpack\audpack.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: audpack.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// !!! The MEDIA TIMES are not fixed up!  This could mess up live data!

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "AudPack.h"
#include "seek.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"

#define CHANNELS 2
#define BITSPERSAMPLE 16

// NOTES ON SHARING A SOURCE FILTER:  The same source filter may be used in
// the video group, and the audio group, to avoid opening it twice. Seeking
// such a graph is complicated.  For the AVI parser, here's the behaviour...
// a seek on the video pin is obeyed, and seeks on the audio pin are ignored.
// (they better be identical anyway).  So what happens if the video switch is
// seeked first, is that that will cause the splitter to flush and send the
// new data to the audio branch, much to the surprise of the audio branch.
// Then later, the audio switch will see the seek, and the audio chain will
// ignore it.
// If the audio switch is seeked first, then we will see the seek, but nothing
// will happen, and then later when the video group is seeked, the audio chain
// will get flushed, and new data delivered, again, much to our surprise.
//
// So, if we get flushed during a seek, that's the normal case.  But now there
// are 2 other cases:
// 1. We get flushed out of nowhere. Wait for the seek we know is coming, and
//    then allow ourself to deliver data again (we need to wait for the switch
//    to be expecting the new data)
// 2. We get a seek, then a surprise flush.  We can start sending new data right
//    away without waiting for another seek.
//
//
// TO BE CONTINUED in switch.cpp



const AMOVIESETUP_MEDIATYPE sudPinTypes[1] =
{
    {&MEDIATYPE_Audio, &MEDIASUBTYPE_NULL}
};

const AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input"            // strName
        , FALSE               // bRendered
        , FALSE               // bOutput
        , FALSE               // bZero
        , FALSE               // bMany
        , &CLSID_NULL         // clsConnectsToFilter
        , L"Output"           // strConnectsToPin
        , 1                   // nTypes
        , &sudPinTypes[0]
    },
    {
        L"Output"           // strName
        , FALSE               // bRendered
        , TRUE                // bOutput
        , FALSE               // bZero
        , FALSE               // bMany
        , &CLSID_NULL         // clsConnectsToFilter
        , L"Input"            // strConnectsToPin
        , 1                   // nTypes
        , &sudPinTypes[0]
    }
};   // lpTypes


const AMOVIESETUP_FILTER sudAudRepack =
{
    &CLSID_AudRepack
    , L"Audio Repackager"        // strName
    , MERIT_DO_NOT_USE           // dwMerit
    , 2                          // nPins
    , psudPins                   // lpPin
};

const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

BOOL SafeResetEvent(HANDLE h);
BOOL SafeSetEvent(HANDLE h);

CAudRepack::CAudRepack(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr)
    : CTransformFilter( tszName, punk, CLSID_AudRepack )
    , CPersistStream(punk, phr)
    , m_dOutputFrmRate(4.0)    // default output frame rate
    , m_rtLastSeek(-1)        // nobody has seeked us yet
    , m_nCacheSize(0)
    , m_fSeeking(FALSE)
    , m_pCache(NULL)
    , m_pResample(NULL)
    , m_cResample(0)
    , m_bMediaTypeSetByUser( false )
    , m_pSkew(NULL)
    , m_cTimes(0)
    , m_cMaxTimes(0)
    , m_fSpecialSeek(FALSE)
    , m_fStopPushing(FALSE)
    , m_fFlushWithoutSeek(FALSE)
    , m_hEventSeek(0)
    , m_hEventThread(0)
{
    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE));
    m_mtAccept.majortype = MEDIATYPE_Audio;	// at least we know this much

    // by default, play the movie normally
    *phr = AddStartStopSkew(0, MAX_TIME, 0, 1.0);
    m_nCurSeg = 0;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CAudRepack")));
}

CAudRepack::~CAudRepack( )
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("~CAudRepack")));
    Free();
    if (m_pResample)
	QzTaskMemFree(m_pResample);
    if (m_pSkew)
	QzTaskMemFree(m_pSkew);

    ASSERT(m_hEventThread == 0);
    ASSERT(m_hEventSeek == 0);
}

void CAudRepack::Free()
{
    if( m_pCache )
    {
        delete [] m_pCache;
        m_pCache = NULL;
    }
}

CUnknown *CAudRepack::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CAudRepack *pNewObject = new CAudRepack( NAME("AudRepack"), punk, phr);
    if (pNewObject == NULL)
        *phr = E_OUTOFMEMORY;
    return pNewObject;
}

//
// NonDelegatingQueryInterface
//
// Reveals IDexterSequencer, IPersistStream and ISpecifyPropertyPages
//
STDMETHODIMP CAudRepack::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (IsEqualIID(IID_ISpecifyPropertyPages, riid)) {
      return GetInterface((ISpecifyPropertyPages *)this, ppv);
    } else if (riid == IID_IDexterSequencer) {
    return GetInterface((IDexterSequencer *) this, ppv);
    } else if (riid == IID_IPersistStream) {
    return GetInterface((IPersistStream *) this, ppv);
    } else {
    return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }
} // NonDelegatingQueryInterface


CBasePin *CAudRepack::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if not already done
    if (m_pInput == NULL) {
        m_pInput = new CAudRepackInputPin(
                          NAME("Audio Repackager input pin")
                          , this       // Owner filter
                          , &hr        // Result code
                          , L"Input"  // Pin name
                          );

        // Constructor can't fail
        ASSERT(SUCCEEDED(hr));
    }

    // Create an output pin if not already done
    if (m_pInput!=NULL && m_pOutput == NULL)
    {
        m_pOutput = new CAudRepackOutputPin(
                            NAME("Audio Repackager output pin")
                          , this       // Owner filter
                          , &hr        // Result code
                          , L"Output"  // Pin name
                          );

        // a failed return code should delete the object

        ASSERT(SUCCEEDED(hr));
        if (m_pOutput == NULL)
        {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Return the appropriate pin
    ASSERT (n>=0 && n<=1);
    if (n == 0) {
        return m_pInput;
    } else if (n==1) {
        return m_pOutput;
    } else {
        return NULL;
    }
} // GetPin


HRESULT CAudRepack::NextSegment(BOOL fUseOtherThread)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Done Segment %d"), m_nCurSeg));

    if (m_nCurSeg < m_cTimes) {
        m_nCurSeg++;
    }

    if (m_nCurSeg == m_cTimes) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:ALL done")));
	// deliver EOS only after all segs done
	CTransformFilter::EndOfStream();
	return S_OK;
    }

    // WE CANNOT SEEK ON the source's pushing thread, or you hang.
    // (That's just the rule).  So we have a separate thread that can seek
    // for us in that case.  Let's wake it up.
    if (fUseOtherThread) {
        m_fThreadCanSeek = TRUE;
        SetEvent(m_hEventThread);
    } else {
	m_fThreadCanSeek = TRUE;
	SeekNextSegment();
    }

    return S_OK;
}


// called by our special thread to do the seek to the next segment
//
HRESULT CAudRepack::SeekNextSegment()
{
    // our thread can't seek at the same time the app seeks us
    CAutoLock cAutolock(&m_csThread);

    // it is not safe for our thread to seek
    if (!m_fThreadCanSeek) {
	return S_OK;
    }
    m_fThreadCanSeek = FALSE;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Delayed Seek for NextSegment")));

    // in timeline time (which includes skew), this is where we are starting
    m_rtNewLastSeek = m_pSkew[m_nCurSeg].rtTLStart;
    m_nSeekCurSeg = m_nCurSeg;	// EndFlush looks at this

    // just in case we don't get a NewSeg (paranoia?)
    m_rtNewSeg = m_rtNewLastSeek;
    m_llStartFrameOffset = Time2Frame( m_rtNewSeg, m_dOutputFrmRate );

    // note we're seeking during the flush that this will generate
    m_fSeeking = TRUE;
    m_fSpecialSeek = TRUE;

    IMediaSeeking *pMS;
    IPin *pPin = m_pInput->GetConnected();
    HRESULT hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pMS);
    // !!! Right now we count on all sources being seekable
    if (FAILED(hr))
	return E_FAIL;
    // Make sure we're talking MEDIA TIME
    hr = pMS->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);
    // this will FAIL if we're not stopped, and that's OK

    // We don't make the source do the rate, we do it ourselves
    hr = pMS->SetRate(1.0);
    // this could fail if not stopped

    // I know we were asked to play until time n, but I'm going to tell it to
    // play all the way to the end.  If there's a gap in the file, and the stop
    // time is during the gap, we won't get enough samples to fill the whole
    // playing time.  If we play until the end, we'll get the first sample
    // after the gap, notice it's after the time we originally wanted to stop
    // at, and send silence to fill the gap, noticing there has been a gap.
    // The alternative is just trigger sending silence to fill the gap when
    // we get an EOS earlier than we expected.
    hr = pMS->SetPositions(&m_pSkew[m_nCurSeg].rtMStart,
			AM_SEEKING_AbsolutePositioning, NULL, 0);
    if (hr != S_OK) {
        // MPEG1 audio pin fails seek (the video pin does them) so we must
        // ignore this benign error.  (IVF parser may have a bug that makes it
        // not work with Dexter, but that's not our fault)
    }

    pMS->Release();

    // if the push thread was stopped, we won't get flushed, and this won't
    // have been updated
    // !!! I ASSUME the push thread won't be started until this thread does it
    // when this function returns, or there is a race condition
    m_rtLastSeek = m_rtNewLastSeek;

    // all done
    m_fSpecialSeek = FALSE;
    m_fSeeking = FALSE;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Seg=%d  Seeking source to %d,%d ms"),
				m_nCurSeg,
				(int)(m_pSkew[m_nCurSeg].rtMStart / 10000),
				(int)(m_pSkew[m_nCurSeg].rtMStop / 10000)));

    // reset same stuff we reset when we start streaming
    hr = Init();

    // only now that the above calculations were made, can we accept data again
    SetEvent(m_hEventSeek);

    return hr;
}


HRESULT CAudRepack::CheckInputType( const CMediaType * pmtIn )
{
    // always make sure major type is valid
    //
    if( *pmtIn->Type( ) != MEDIATYPE_Audio )
    {
        return E_INVALIDARG;
    }

    // always make sure minor type is valid
    //
    if( ( *pmtIn->Subtype( ) != MEDIASUBTYPE_PCM ) && ( *pmtIn->Subtype( ) != MEDIASUBTYPE_NULL ) )
    {
        return E_INVALIDARG;
    }

    // if user hasn't set a particular format, then accept it
    //
    if( !m_bMediaTypeSetByUser )
    {
        return NOERROR;
    }

    if( pmtIn->cbFormat != m_mtAccept.cbFormat )
    {
        return E_INVALIDARG;
    }

    LPBYTE lp1 = pmtIn->Format();
    LPBYTE lp2 = m_mtAccept.pbFormat;
    if (memcmp(lp1, lp2, pmtIn->FormatLength()) != 0)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}


HRESULT CAudRepack::DecideBufferSize( IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * pProp )
{

    WAVEFORMATEX *pwfx =(WAVEFORMATEX *)(m_pInput->CurrentMediaType().Format());
    m_nSPS = pwfx->nSamplesPerSec;
    m_nSampleSize = pwfx->nChannels * ((pwfx->wBitsPerSample + 7) / 8);
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Using %dHz %dbit %d"), m_nSPS,
            pwfx->wBitsPerSample, pwfx->nChannels));
    // !!! Why do we need to add 2?  Double check the math!
    m_nCacheSize = (int)(m_nSPS / m_dOutputFrmRate + 2); // round up to fit it!
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Cache will hold %d samples"), m_nCacheSize));
    m_nCacheSize *= m_nSampleSize;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Cache is %d bytes"), m_nCacheSize));

    {
        // !!! is this right?
        pProp->cBuffers = 8;
        pProp->cbBuffer = m_nCacheSize;
	if (pProp->cbAlign == 0)
            pProp->cbAlign = 1;

        ALLOCATOR_PROPERTIES propActual;

        HRESULT hr = pAlloc->SetProperties(pProp, &propActual);
        if (FAILED(hr))
        {
            return hr;
        }

        if ((pProp->cBuffers > propActual.cBuffers)
            || (pProp->cbBuffer > propActual.cbBuffer)
           )
        {
            return E_FAIL;
        }
    }

    return NOERROR;
}

HRESULT CAudRepack::GetMediaType( int iPosition, CMediaType *pMediaType )
{
    if( !m_pInput->IsConnected( ) )
    {
        return E_INVALIDARG;
    }

    if( iPosition < 0 )
    {
        return E_INVALIDARG;
    }
    if( iPosition >= 1 )
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    *pMediaType = m_pInput->CurrentMediaType();

    return NOERROR;
}


HRESULT CAudRepack::CheckTransform( const CMediaType * p1, const CMediaType * p2 )
{
    if (*p1 != *p2)
    {
        DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:CheckTransform - INVALID")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    return NOERROR;
}


HRESULT CAudRepack::NewSegment( REFERENCE_TIME tStart, REFERENCE_TIME tStop, double Rate )
{
    ASSERT(Rate==1);   //since we only support this now.

    // ignore - we're all done, and m_nCurSeg is an invalid value to use
    if (m_nCurSeg == m_cTimes)
        return S_OK;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:NewSegment %d-%dms"),
            (int)(tStart / 10000), (int)(tStop / 10000)));

    // convert to timeline time
    REFERENCE_TIME rtNewStart, rtNewStop;
    // !!!! include rate in this calculation, since downstream will include it?
    if (m_rtLastSeek < 0) {
        // Never been seeked, so this is the beginning of what we're sending
        rtNewStart = m_pSkew[m_nCurSeg].rtTLStart;
        rtNewStop = m_pSkew[m_nCurSeg].rtTLStart + tStop - tStart;
    } else {
        // Skew the #'s, and send 'em on!
	rtNewStart = tStart;
        rtNewStop = tStop;
        if (rtNewStart < m_pSkew[m_nCurSeg].rtMStart)
	    rtNewStart = m_pSkew[m_nCurSeg].rtMStart;
        if (rtNewStart > m_pSkew[m_nCurSeg].rtMStop)
	    rtNewStart = m_pSkew[m_nCurSeg].rtMStop;
        rtNewStart = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
		(rtNewStart - m_pSkew[m_nCurSeg].rtMStart) /
		m_pSkew[m_nCurSeg].dRate);
        if (rtNewStop < m_pSkew[m_nCurSeg].rtMStart)
	    rtNewStop = m_pSkew[m_nCurSeg].rtMStart;
        if (rtNewStop > m_pSkew[m_nCurSeg].rtMStop)
	    rtNewStop = m_pSkew[m_nCurSeg].rtMStop;
        rtNewStop = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
		 (rtNewStop - m_pSkew[m_nCurSeg].rtMStart) /
		 m_pSkew[m_nCurSeg].dRate);

	m_rtLastSeek = rtNewStart;	// pretend we were seeked here
    }
    m_rtNewSeg = rtNewStart;
    DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("NewSeg:Skewing %dms to %dms"),
			(int)(tStart / 10000), (int)(m_rtNewSeg / 10000)));

    m_rtPinNewSeg = tStart;	// save this too so we don't have to override
				// the pin class

    // What packet were we seeked into?
    m_llStartFrameOffset = Time2Frame( m_rtNewSeg, m_dOutputFrmRate );
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Seek was to packet %d"),
						(int)m_llStartFrameOffset));

    return CTransformFilter::NewSegment( rtNewStart, rtNewStop, Rate );
}


HRESULT CAudRepack::Init()
{
    Free();

    m_pCache = new BYTE[m_nCacheSize];
    m_nInCache = 0;
    m_dError = 0.;
    m_pReadPointer = m_pCache;
    m_llSamplesDelivered = 0;
    m_llPacketsDelivered = 0;
    m_bFirstSample = TRUE;
    // flushing must reset this so that a real seek will kill a pending
    // segment seek, or else the segment seek will hang (won't flush the switch)
    m_fThreadCanSeek = FALSE;
    return m_pCache ? NOERROR : E_OUTOFMEMORY;
}


HRESULT CAudRepack::StartStreaming()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:StartStreaming")));

    // if we were stopped when this was set, it will not be reset, since we
    // won't have gotten an EndFlush from the seek trying to start us again
    m_fStopPushing = FALSE;

    if (m_cTimes == 0)
	return E_UNEXPECTED;

    // make the event BEFORE creating the thread... it uses this!
    m_hEventThread = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hEventThread == NULL) {
        return E_OUTOFMEMORY;
    }

    m_hEventSeek = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (m_hEventSeek == NULL) {
	CloseHandle(m_hEventThread);
	m_hEventThread = NULL;
        return E_OUTOFMEMORY;
    }

    // We need a thread to seek on if we are re-using our source
    if (m_cTimes > 1) {
	m_fThreadMustDie = FALSE;
	m_fThreadCanSeek = FALSE;
        if (m_worker.Create(this)) {
            m_worker.Run();
	}
    }

#ifdef DEBUG
    // before we begin, make sure all timeline times are on a frame boundary
    // !!! Play.  Stop.  Change the frame rate.  Play. These numbers will drift.
    //
    for (int z=0; z<m_cTimes; z++)
    {
	// !!! actually align instead of asserting?
    	LONGLONG llOffset = Time2Frame( m_pSkew[z].rtTLStart,
							m_dOutputFrmRate );
    	REFERENCE_TIME rtTest = Frame2Time( llOffset, m_dOutputFrmRate );
	ASSERT(rtTest == m_pSkew[z].rtTLStart);
    }
#endif

    HRESULT hr = Init();
    if( FAILED( hr ) )
    {
        return hr;
    }
    // can't do this in Init.. BeginFlush mustn't reset this
    m_fFlushWithoutSeek = FALSE;

    IPin *pPin = m_pInput->GetConnected();
    if (pPin == NULL)
        return CTransformFilter:: StartStreaming();

    // if we weren't seeked, but we're just playing ordinarily, we never
    // seeked upstream to get the piece of movie we're interested in.  Do it now
    if (m_rtLastSeek < 0) {
	ASSERT(m_nCurSeg == 0);
	m_nCurSeg--;
	NextSegment(FALSE);
    }

    return CTransformFilter:: StartStreaming();
}


HRESULT CAudRepack::StopStreaming()
{
    // make sure we're not in receive (redundant!)
    CAutoLock foo(&m_csReceive);

    if (m_hEventSeek) {
        CloseHandle(m_hEventSeek);
        m_hEventSeek = NULL;
    }
    if (m_hEventThread) {
        CloseHandle(m_hEventThread);
        m_hEventThread = NULL;
    }
    return CTransformFilter::StopStreaming();
}


STDMETHODIMP CAudRepack::Stop()
{
    // If we have a thread, kill it. This thread can take our filter critsec,
    // so we must do this OUTSIDE of that crit sec!
    if (m_hEventThread && m_cTimes > 1) {
	m_fThreadMustDie = TRUE;
	SetEvent(m_hEventThread);
	m_worker.Stop();
	m_worker.Exit();
	m_worker.Close();
    }

    CAutoLock lck1(&m_csFilter);
    if (m_State == State_Stopped) {
        return NOERROR;
    }

    // Succeed the Stop if we are not completely connected

    ASSERT(m_pInput == NULL || m_pOutput != NULL);
    if (m_pInput == NULL || m_pInput->IsConnected() == FALSE ||
        m_pOutput->IsConnected() == FALSE) {
                m_State = State_Stopped;
                m_bEOSDelivered = FALSE;
                return NOERROR;
    }

    ASSERT(m_pInput);
    ASSERT(m_pOutput);

    // decommit the input pin before locking or we can deadlock
    m_pInput->Inactive();

    // synchronize with Receive calls

    CAutoLock lck2(&m_csReceive);
    m_pOutput->Inactive();

    // allow a class derived from CTransformFilter
    // to know about starting and stopping streaming

    HRESULT hr = StopStreaming();
    if (SUCCEEDED(hr)) {
	// complete the state transition
	m_State = State_Stopped;
	m_bEOSDelivered = FALSE;
    }
    return hr;
}


HRESULT CAudRepack::Receive(IMediaSample * pIn)
{
    // Stop pushing data to me!
    if (m_fStopPushing) {
	return E_FAIL;
    }

    HRESULT hr = 0;
    CAutoLock foo(&m_csReceive);

    // maybe we're in the middle of seeking and are supposed to wait before
    // accepting data
    WaitForSingleObject(m_hEventSeek, INFINITE);

    // if we hit the end of our times, we're done.
    if (m_nCurSeg == m_cTimes) {
	return E_FAIL;
    }

    // We should never see a preroll!
    ASSERT(pIn->IsPreroll() != S_OK);
    if (pIn->IsPreroll() == S_OK)
        return NOERROR;

    // make sure sample size is not zero
    long InLen = pIn->GetActualDataLength();
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Received %d bytes"), InLen));
    if (!InLen) {
        return NOERROR;
    }

    // get the sample times, this will always work
    //
    REFERENCE_TIME trStart = 0;
    REFERENCE_TIME trStop = 0;
    hr = pIn->GetTime(&trStart, &trStop);
    trStart += m_rtPinNewSeg;
    trStop += m_rtPinNewSeg;
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Receive Start=%d Stop=%d ms"),
        (int)(trStart / 10000), (int)(trStop / 10000)));

    // the time stamp we just received... skewed and rate converted
    trStart = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
				(trStart - m_pSkew[m_nCurSeg].rtMStart) /
				m_pSkew[m_nCurSeg].dRate);
    trStop = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
				(trStop - m_pSkew[m_nCurSeg].rtMStart) /
				m_pSkew[m_nCurSeg].dRate);

    // What packet is the sample we first received a part of?
    REFERENCE_TIME llOffset = Time2Frame( trStart, m_dOutputFrmRate );
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Audio received starts at packet %d"),
                        (int)llOffset));

    // what time stamp the thing we deliver needs to have
    REFERENCE_TIME rtPacketStart, rtPacketStop;
    rtPacketStart = Frame2Time(m_llStartFrameOffset + m_llPacketsDelivered,
							m_dOutputFrmRate );
    rtPacketStop = Frame2Time(m_llStartFrameOffset + m_llPacketsDelivered + 1,
							m_dOutputFrmRate );

    BYTE *pSampleData = NULL;
    hr = pIn->GetPointer(&pSampleData);
    if (hr != NOERROR)
    {
        return E_FAIL;
    }

    // !!! We won't always be delivered audio samples where the time stamps
    // are what we expect, given how much PCM data we get.  EG:
    //
    // 1. If the rate is supposed to be 44100.3, that can't be expressed
    // (integers only allowed) so the source filter will probably handle that
    // by having the time stamps slightly off so we can tell we're supposed
    // to play the audio at 44100.3, even though the format is 44100
    //
    // 2. Live capture, using a random clock, will have time stamps WAY OFF
    // compared to #1.  We need to trust the time stamps
    //
    // !!! We are going to drift out of sync in these cases!  To prevent it,
    // we need to sample rate convert everything coming in so the amount of
    // data matches the time stamps exactly.  Just dropping samples, or adding
    // silence will harm the audio quality, probably immensely. Even doing a
    // sample rate conversion on the whole packet will hurt the audio unless
    // it's anti-aliased.
    //
    // !!! So right now, this problem is ignored, and there is possible drift!

    BYTE * pFreeMe = NULL;

    // I am going to drop/add samples from the first thing ever delivered to
    // me, so the sync starts out right.  But I am NOT going to do this
    // during playback to try and keep in sync (see above)

    // we received stuff that belongs in an earlier packet... get rid of it!
    if (trStart < rtPacketStart && m_bFirstSample) {

	// throw away this many bytes, (account for rate)
	// CAREFUL:  Make sure bytes is a multiple of 4
	int samples = (int)((rtPacketStart - trStart) * m_nSPS / 10000000
					 * m_pSkew[m_nCurSeg].dRate);
	int bytes = samples * m_nSampleSize;
        DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:throw away %d inbytes"),
                        				(int)bytes));
	if (bytes >= InLen) {
	    m_trStopLast = trStop;
	    return S_OK;
	}
	pSampleData += bytes;
	InLen -= bytes;
    }

    // we received stuff later than what we expected... prepend with silence
    // Or, we have a discontinuity... let's at least get back in sync after
    // each discontinuity.
    // !!! Ick, memory copy

    BOOL fPrependSilence = FALSE;
    REFERENCE_TIME rtSilenceStart; // always gets inited before it's used
    if (rtPacketStart < trStart && m_bFirstSample) {
	fPrependSilence = TRUE;
	rtSilenceStart = rtPacketStart;
    }
    if (pIn->IsDiscontinuity() == S_OK && trStart > m_trStopLast + 1 &&
						m_bFirstSample == FALSE) {
	fPrependSilence = TRUE;
	rtSilenceStart = m_trStopLast;
    }

    if (fPrependSilence) {

	// put some silence in front of what we got (account for rate)
	// CAREFUL:  Make sure bytes is a multiple of 4
	int samples = (int)((trStart - rtSilenceStart) * m_nSPS / 10000000
					 * m_pSkew[m_nCurSeg].dRate);
	int bytes = samples * m_nSampleSize;
	if (bytes > 0) {
	    BYTE *pNew = (BYTE *)QzTaskMemAlloc(bytes + InLen);
	    if (pNew == NULL) {
		return E_OUTOFMEMORY;
	    }
            DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Added %d bytes of silence"),
                        				(int)bytes));
	    ZeroMemory(pNew, bytes);
	    CopyMemory(pNew + bytes, pSampleData, InLen);
	    pSampleData = pNew;
	    InLen += bytes;
	    pFreeMe = pSampleData;
	}
    }
    m_bFirstSample = FALSE;
    m_trStopLast = trStop;

    // !!! Only works for 16 bit stereo
    // !!! Anti-alias it!

    // Now convert the samples using this inefficent algorithm.
    // Don't let errors propogate... at least I do one thing cleverly
    if (m_pSkew[m_nCurSeg].dRate != 1.0) {
	LONG nIn = InLen / 4;
	ASSERT(nIn * 4 == InLen);
 	double dOut = nIn / m_pSkew[m_nCurSeg].dRate;
	LONG nOut = (LONG)(dOut + m_dError);

	LPDWORD lpIn = (LPDWORD)pSampleData;
	if (m_cResample == 0) {
	    m_pResample = (LPBYTE)QzTaskMemAlloc(nOut * 4);
	    m_cResample = nOut * 4;
	} else if (nOut * 4 > m_cResample) {
	    m_pResample = (LPBYTE)QzTaskMemRealloc(m_pResample, nOut * 4);
	    m_cResample = nOut * 4;
 	}
	LPDWORD lpOut = (LPDWORD)m_pResample;
	if (lpOut == NULL) {
	    if (pFreeMe)
		QzTaskMemFree(pFreeMe);
	    return E_OUTOFMEMORY;
	}

	double d = (double)nOut / nIn;
	double dErr = 0.;
        LPDWORD lpdwEnd = (LPDWORD)(pSampleData + InLen);
	do {
	    LONG n = (LONG)(d + dErr);
            for (int z=0; z < n; z++)
	        *lpOut++ = *lpIn;
	    lpIn++;
	    dErr = d + dErr - n;
	} while (lpIn < lpdwEnd);

	// fix up these variables to fall through
	if (pFreeMe)
	    QzTaskMemFree(pFreeMe);
	pFreeMe = NULL;
	pSampleData = m_pResample;
        // how many bytes did we output?
	InLen = (LONG) ((LPBYTE)lpOut - (LPBYTE)m_pResample);
        // update the running error with how much we made vs. wanted to make
	m_dError = dOut - InLen / 4;
        DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:RATE ADJUSTED: Became %d bytes"), InLen));
    }

    // as long as we have data in the incoming buffer,
    // copy it to the cache, and possibly deliver it
    //
    while(InLen > 0) {
        int nBytesToSend, nSamplesToSend;

	// !!! this is the same code as EndOfStream!  there are 2 copies!

	// don't send anything after our end time... it'll confuse the switch
	// (the RHS could round too low, so fudge by 1ms)
	if (rtPacketStart + 10000 >= m_pSkew[m_nCurSeg].rtTLStop) {
	    // looks like we're done
	    EndOfStream();
	    if (pFreeMe)
		QzTaskMemFree(pFreeMe);
	    // We can't trust sources to stop pushing, and unfortunately, Dexter
	    // will hang if it doesn't. (Seeking ourself to the next segment
	    // doesn't let the flush go downstream or it confuses other filters,
	    // so we have to make sure the push thread can't ever block).
	    // So, from now on, fail any calls to GetBuffer or Receive
	    m_fStopPushing = TRUE;
            return E_FAIL;
	}

	// if this sample is too early, don't send it or you'll confuse the
	// switch - skip this GetBuffer and Deliver
	BOOL fAvoid = FALSE;
	if (rtPacketStart < m_pSkew[m_nCurSeg].rtTLStart) {
	    fAvoid = TRUE;
	}

        // how many samples will need to have been sent after this packet
        // goes out?
        LONGLONG ll = Time2Frame( rtPacketStop, m_nSPS );

        // How many samples would have gone out if we had started at the
	// beginning and sent up to the point we were seeked to (and really
	// began from?)
        REFERENCE_TIME rt = Frame2Time( m_llStartFrameOffset, m_dOutputFrmRate );
        llOffset = Time2Frame( rt, m_nSPS );

        // That tells us how many samples need to go out this time
        nSamplesToSend = (int)(ll - (m_llSamplesDelivered + llOffset));
	ASSERT(nSamplesToSend > 0);	// we're messed up and about to die!
	if (nSamplesToSend <= 0) {
	    hr = E_UNEXPECTED;
	    EndOfStream();
	    break;		// try not to hang
	}
        nBytesToSend = nSamplesToSend * m_nSampleSize;
        DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Need to send %d bytes %d samples"),
						nBytesToSend, nSamplesToSend));

        // calculate how much more the cache needs
        long CacheFreeSpace = nBytesToSend - m_nInCache;

        // calculate how much we can copy
        long CopySize = min(CacheFreeSpace, InLen);
	ASSERT(CopySize >= 0);

	if (CopySize > 0) {
            CopyMemory(m_pReadPointer, pSampleData, CopySize);
	}

        // advance the pointers, etc
        //
        m_pReadPointer += CopySize;
        pSampleData += CopySize;
        InLen -= CopySize;
        m_nInCache += CopySize;

        // do we have enough to deliver?
        //
        if (m_nInCache == nBytesToSend)
        {
            // yep.

	    hr = S_OK;
	    if (!fAvoid) {
                hr = DeliverOutSample(m_pCache, nBytesToSend, rtPacketStart,
                            rtPacketStop);
	    }
            if (hr != S_OK) {
                DbgLog((LOG_ERROR,1,TEXT("*AUD:Deliver FAILED - DIE!")));
                // don't send an extra EOS, that will screw up the switch
                m_fStopPushing = TRUE;
                break;
	    }

            m_llSamplesDelivered += nSamplesToSend;
            m_llPacketsDelivered += 1;
            m_nInCache = 0;
            m_pReadPointer = m_pCache;
        }

        // packet size varies by as much as 1 sample each time.  How many
        // bytes are we supposed to send this time? (prepare for next loop)
        rtPacketStart = Frame2Time(m_llStartFrameOffset + m_llPacketsDelivered,
							m_dOutputFrmRate);
        rtPacketStop = Frame2Time(m_llStartFrameOffset+m_llPacketsDelivered + 1,
							m_dOutputFrmRate );
    }

    if (pFreeMe)
	QzTaskMemFree(pFreeMe);

    return hr;
}

HRESULT CAudRepack::DeliverOutSample(BYTE * pData, int nBytesToSend, REFERENCE_TIME rtPacketStart, REFERENCE_TIME rtPacketStop)
{
    if (nBytesToSend <= 0) {
	return S_OK;
    }

    IMediaSample * pOutSample = NULL;

    // remove the new segment offset from the time stamps before stamping
    rtPacketStart -= m_rtNewSeg;
    rtPacketStop -= m_rtNewSeg;

    HRESULT hr = m_pOutput->GetDeliveryBuffer(&pOutSample, &rtPacketStart,
							&rtPacketStop, 0);
    if( FAILED(hr)) {
        m_llPacketsDelivered = MAX_TIME;        // don't recurse
        EndOfStream();  // our fault
        return hr;
    }

    // !!! more?
    pOutSample->SetDiscontinuity(FALSE);
    pOutSample->SetSyncPoint(TRUE);

    hr = pOutSample->SetTime(&rtPacketStart, &rtPacketStop);
    if( FAILED(hr))
    {
        pOutSample->Release( );
        m_llPacketsDelivered = MAX_TIME;        // don't recurse
        EndOfStream();  // our fault we're not delivering anymore
        return hr;
    }
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("AUD:Sent %d bytes as %d,%d"), nBytesToSend,
        (int)(rtPacketStart / 10000), (int)(rtPacketStop / 10000)));

    BYTE *pOutBuffer = NULL;
    pOutSample->GetPointer(&pOutBuffer);
    long OutLen = pOutSample->GetSize( );
    if( nBytesToSend > OutLen )
    {
        return VFW_E_BUFFER_OVERFLOW;
    }
    CopyMemory(pOutBuffer, pData, nBytesToSend);
    pOutSample->SetActualDataLength(nBytesToSend);

    hr = m_pOutput->Deliver(pOutSample);

    pOutSample->Release( );

    return hr;
}


HRESULT CAudRepack::BeginFlush()
{
    HRESULT hr = S_OK;
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("AUD:BeginFlush")));

    // make sure Receive is not blocked
    SafeSetEvent(m_hEventSeek);

    // don't flush downstream if we're doing a special seek to the next segment
    if (!m_fSpecialSeek) {
        hr = CTransformFilter::BeginFlush();
    }

    // make sure receive is done before calling init on the variables used in
    // receive
    CAutoLock foo(&m_csReceive);

    // do the flush
    hr = Init();

    // if we get flushed without a seek having been made, that's a surprise.
    // It hopefully means the other chain of our shared source caused the seek
    if (m_fSeeking) {
	m_fFlushWithoutSeek = FALSE;
    } else {
	// wait for EndFlush to set m_fFlushWithoutSeek
    }

    return hr;
}


HRESULT CAudRepack::EndFlush()
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("AUD:EndFlush")));

    // hold off the new receives that will come in until we're ready for them
    if (m_fSeeking) {
	m_rtLastSeek = m_rtNewLastSeek;	// time to update this
	m_nCurSeg = m_nSeekCurSeg;	// the NewSeg about to be generated
					// needs this set
    	SafeResetEvent(m_hEventSeek);
    } else {
	// This needs to be set before the NewSeg that's about to arrive after
	// the flush.  When sharing a source, we never have multiple segments
	m_nCurSeg = 0;
	if (m_fFlushWithoutSeek) {
	    // If this is set, we've already seen a seek.  Now that the flush
	    // has arrived, we're done
    	    DbgLog((LOG_TRACE,2,TEXT("OK to proceed")));
	    m_fFlushWithoutSeek = FALSE;
	} else {
	    // We haven't seen a seek yet.  This is a surprise flush
    	    DbgLog((LOG_TRACE,2,TEXT("state=2. Wait for Seek")));
    	    SafeResetEvent(m_hEventSeek);
	    m_fFlushWithoutSeek = TRUE;
	}
    }

    m_fStopPushing = FALSE;	// OK to deliver to me again

    // If we got flushed without seeking, it probably means our shared source
    // got seeked by the other stream.  We'll get a seek later, and only then
    // can we resume delivering, or the switch won't be ready to receive the
    // new data yet.

    // don't flush downstream if we're doing a special seek to the next segment
    if (!m_fSpecialSeek) {
        return CTransformFilter::EndFlush();
    }
    return S_OK;
}


HRESULT CAudRepack::EndOfStream( )
{
    HRESULT hr = S_OK;

    if (m_fStopPushing) {
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("AUD: Ignoring bogus EOS")));
	return S_OK;
    }

    // ignore - we're all done, and m_nCurSeg is an invalid value to use
    if (m_nCurSeg == m_cTimes)
        return S_OK;

    DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("AUD:EndOfStream")));

    // Uh oh!  We got an end of stream before we sent enough data to keep
    // the switch from panicing! We MUST deliver the last stuff in our buffer
    // followed by silence until we've sent enough
    // DO NOT, however, deliver past the end time we're supposed to, or we'll
    // mess the switch up! If the number of samples left to send is some tiny
    // fraction of the amount we send each time, it means we really are done,
    // sending even 1 more packet will be too much

    while (m_pCache)
    {
        // fill the rest of the cache with 0's
        //
        long CacheFreeSpace = m_nCacheSize - m_nInCache;
        ZeroMemory(m_pCache + m_nInCache, CacheFreeSpace);

        REFERENCE_TIME rtStart, rtStop;

        // !!! this is the same code as Receive!  there are 2 copies!

        // packet size varies by as much as 1 sample each time.  How many
        // bytes are we supposed to send this time?
        rtStart = Frame2Time( m_llStartFrameOffset + m_llPacketsDelivered, m_dOutputFrmRate );
        rtStop = Frame2Time( m_llStartFrameOffset + m_llPacketsDelivered + 1, m_dOutputFrmRate );

	// we're all done
	// (the RHS could round too low, so fudge by 1ms)
	if (rtStart + 10000 >= m_pSkew[m_nCurSeg].rtTLStop) {
	    // looks like we're done
            break;
	}

        DbgLog((LOG_TRACE,2,TEXT("Delivering the left over bits")));

        // how many samples should have been sent (total) after this packet
        // goes out?
        LONGLONG ll = Time2Frame( rtStop, m_nSPS );

        // How many samples would have gone out if we had started at the
	// beginning and sent up to the point we were seeked to (and really
	// began from?)
        REFERENCE_TIME rt = Frame2Time( m_llStartFrameOffset, m_dOutputFrmRate );
        LONGLONG llOffset = Time2Frame( rt, m_nSPS );


        // That tells us how many samples need to go out this time
        int nSamplesToSend = (int)(ll - (m_llSamplesDelivered + llOffset));
        if (nSamplesToSend <= 0)
            break;      // we're all done
        int nBytesToSend = nSamplesToSend * m_nSampleSize;

        hr = DeliverOutSample(m_pCache, nBytesToSend, rtStart, rtStop);
	// What if this fails?
	if (FAILED(hr)) {
            DbgLog((LOG_ERROR,1,TEXT("Deliver FAILED - we're dead?")));
	    break;
	}

	m_nInCache = 0;
	m_llSamplesDelivered += nSamplesToSend;
	m_llPacketsDelivered += 1;
    }

    // all done this segment, now for the next one
    hr = NextSegment(TRUE);

    // DONT propogate the EOS until ALL SEGMENTS done
    return hr;
}


// IPersistStream

// tell our clsid
//
STDMETHODIMP CAudRepack::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_AudRepack;
    return S_OK;
}

typedef struct _AUDSave {
    int version;
    double dFrmRate;
    int cTimes;
} AUDSave;

// persist ourself
// !!! save the media type someday?
//
HRESULT CAudRepack::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:WriteToStream")));

    CheckPointer(pStream, E_POINTER);

    int savesize = sizeof(AUDSave) + m_cTimes * sizeof(AUDSKEW);
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Persisted data is %d bytes"), savesize));

    AUDSave *px = (AUDSave *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("AUD:*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    px->version = 1;
    px->dFrmRate = m_dOutputFrmRate;
    px->cTimes = m_cTimes;

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(AUDSave);
    if (m_cTimes) {
        CopyMemory(pb, m_pSkew, sizeof(AUDSKEW) * m_cTimes);
        pb += sizeof(AUDSKEW) * m_cTimes;
    }

    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** AUD:WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself
//
HRESULT CAudRepack::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:ReadFromStream")));

    CheckPointer(pStream, E_POINTER);

    int savesize=sizeof(AUDSave);

    // we don't yet know how many saved connections there are
    // all we know we have for sure is the beginning of the struct
    AUDSave *px = (AUDSave *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("AUD:*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("AUD:*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    put_OutputFrmRate(px->dFrmRate);

    // how much saved data was there, really?  Get the rest
    savesize += px->cTimes * sizeof(AUDSKEW);
    px = (AUDSave *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("AUD:*** Out of memory")));
        return E_OUTOFMEMORY;
    }

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:Persisted data is %d bytes"), savesize));

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(AUDSave) ;
    hr = pStream->Read(pb, (savesize-sizeof(AUDSave)), 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("AUD:*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    ClearStartStopSkew();
    for (int z=0; z<px->cTimes; z++) {
        AUDSKEW *pSkew = (AUDSKEW *)pb;
	REFERENCE_TIME rtStart = pSkew->rtMStart;
	REFERENCE_TIME rtStop = pSkew->rtMStop;
	REFERENCE_TIME rtSkew = pSkew->rtSkew;
	double dRate = pSkew->dRate;
        AddStartStopSkew(rtStart, rtStop, rtSkew, dRate);
	pb += sizeof(AUDSKEW);
    }

    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}


// how big is our save data?
//
int CAudRepack::SizeMax()
{
    return sizeof(AUDSave) + m_cTimes * 3 * sizeof(REFERENCE_TIME) +
			    m_cTimes * sizeof(double);
}



//
// IDexterSequencer implementation
//


//
// get_OutputFrmRate(double *PFS)
//
STDMETHODIMP CAudRepack::get_OutputFrmRate(double *dpFrmRate)
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(dpFrmRate,E_POINTER);
    *dpFrmRate = m_dOutputFrmRate;
    return NOERROR;
}


//
// put_OutputFrmRate
//
// Set the required FrmRateSpeed
//
STDMETHODIMP CAudRepack::put_OutputFrmRate(double dFrmRate)
{
    CAutoLock cAutolock(&m_csFilter);
    if (dFrmRate == m_dOutputFrmRate) {
        return S_OK;    // what-EVER!
    }
    if (m_State != State_Stopped) {
	return VFW_E_NOT_STOPPED;
    }
    BOOL fReconnect = FALSE;
    if (m_pInput && m_pInput->IsConnected() && dFrmRate < m_dOutputFrmRate) {
        fReconnect = TRUE;
    }

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:put_OutputFrmRate to %d/10 fps"),
                        (int)(dFrmRate * 10)));
    m_dOutputFrmRate = dFrmRate;
    SetDirty(TRUE);

    // a smaller frame rate may mean bigger buffers needed in this allocator
    if (fReconnect) {
        m_pGraph->Reconnect(m_pOutput);
    }

    return NOERROR;
}


STDMETHODIMP CAudRepack::GetStartStopSkew(REFERENCE_TIME *pStart, REFERENCE_TIME *pStop, REFERENCE_TIME *pSkew, double *pdRate)
{
    CAutoLock cAutolock(&m_csFilter);

    CheckPointer(pStart,E_POINTER);
    CheckPointer(pStop,E_POINTER);
    CheckPointer(pSkew,E_POINTER);
    CheckPointer(pdRate,E_POINTER);

    for (int i = 0; i < m_cTimes; i++) {
        pStart[i] = m_pSkew[i].rtMStart;
        pStop[i] = m_pSkew[i].rtMStop;
        pSkew[i] = m_pSkew[i].rtSkew;
        pdRate[i] = m_pSkew[i].dRate;
    }

    return NOERROR;
}


// Sort the new one into the list
//
STDMETHODIMP CAudRepack::AddStartStopSkew(REFERENCE_TIME Start, REFERENCE_TIME Stop, REFERENCE_TIME Skew, double dRate)
{
    CAutoLock cAutolock(&m_csFilter);

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:ADD Start %d  Stop %d  Skew %d ms  Rate %d/100"),
				(int)(Start / 10000), (int)(Stop / 10000),
				(int)(Skew / 10000), (int)(dRate * 100)));

    //can not change times if our filter is not currently stopped
    if(!IsStopped() )
	return VFW_E_WRONG_STATE;

    if (m_cTimes == m_cMaxTimes) {
	m_cMaxTimes += 10;
	if (m_pSkew)
	    m_pSkew = (AUDSKEW *)QzTaskMemRealloc(m_pSkew,
					m_cMaxTimes * sizeof(AUDSKEW));
	else
	    m_pSkew = (AUDSKEW *)QzTaskMemAlloc(m_cMaxTimes * sizeof(AUDSKEW));
	if (m_pSkew == NULL) {
	    m_cMaxTimes = 0;
            m_cTimes = 0;
	    return E_OUTOFMEMORY;
	}
    }

    if( dRate == 0.0 )
    {
        // go look for the time we want to extend
        //
#ifdef DEBUG
        bool fHosed = true;
#endif
        for( int z = 0 ; z < m_cTimes ; z++ ) {
            REFERENCE_TIME rtLastTLStop = m_pSkew[z].rtTLStop;

            if( AreTimesAndRateReallyClose( rtLastTLStop, Start + Skew,
                        m_pSkew[z].rtMStop, Start, 0.0, 0.0, m_dOutputFrmRate))
            {
                m_pSkew[z].rtMStop += Stop - Start;
                m_pSkew[z].rtTLStop = m_pSkew[z].rtMStart + m_pSkew[z].rtSkew +
                    (REFERENCE_TIME)((m_pSkew[z].rtMStop - m_pSkew[z].rtMStart)
                                / m_pSkew[z].dRate);
                // the above math will have a rounding error, and rtTLStop won't
                // be frame aligned, so we better fix that
                LONGLONG ll = RoundTime2Frame(m_pSkew[z].rtTLStop, m_dOutputFrmRate);
                m_pSkew[z].rtTLStop = Frame2Time(ll, m_dOutputFrmRate);
#ifdef DEBUG
                fHosed = false;
#endif
                break;
            }
        }
#ifdef DEBUG
        if (fHosed) ASSERT(FALSE);    // we're dead!
#endif
    }
    else
    {
        // merge it sorted by timeline time into the list
        //
        for (int z=0; z<m_cTimes; z++)
        {
	    if (Start + Skew < m_pSkew[z].rtTLStart)
            {
    	        for (int y = m_cTimes - 1; y >= z; y--)
                {
    		    m_pSkew[y + 1] = m_pSkew[y];
	        }
	        break;
	    }
        }

        m_pSkew[z].rtMStart = Start;
        m_pSkew[z].rtMStop = Stop;
        m_pSkew[z].rtSkew = Skew;
        m_pSkew[z].dRate = dRate;
        m_pSkew[z].rtTLStart = Start + Skew;
        m_pSkew[z].rtTLStop = Start + Skew +
                                (REFERENCE_TIME)((Stop - Start) / dRate);

        m_cTimes++;
    }

    SetDirty(TRUE);
    return S_OK;
}


STDMETHODIMP CAudRepack::GetStartStopSkewCount(int *pCount)
{
    CheckPointer(pCount, E_POINTER);
    *pCount = m_cTimes;
    return NOERROR;
}


STDMETHODIMP CAudRepack::ClearStartStopSkew()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("AUD:ClearStartStopSkew")));
    CAutoLock cAutolock(&m_csFilter);

    //can not change duration if our filter is not currently stopped
    if(!IsStopped() )
      return VFW_E_WRONG_STATE;

    if (m_pSkew)
	QzTaskMemFree(m_pSkew);
    m_pSkew = NULL;

    m_cTimes = 0;
    m_cMaxTimes = 0;
    SetDirty(TRUE);

    return NOERROR;
}


STDMETHODIMP CAudRepack::get_MediaType( AM_MEDIA_TYPE * pmt )
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(pmt, E_POINTER);
    if (!m_bMediaTypeSetByUser)
	return E_UNEXPECTED;
    return CopyMediaType(pmt, &m_mtAccept);
}

STDMETHODIMP CAudRepack::put_MediaType( const AM_MEDIA_TYPE * pmt )
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(pmt, E_POINTER);
    if (m_State != State_Stopped)
        return VFW_E_NOT_STOPPED;

    if (m_pInput && m_pInput->IsConnected())
        return VFW_E_ALREADY_CONNECTED;

    if (m_pOutput && m_pOutput->IsConnected())
        return VFW_E_ALREADY_CONNECTED;

    SaferFreeMediaType(m_mtAccept);
    HRESULT hr = CopyMediaType(&m_mtAccept, pmt);
    SetDirty(TRUE);
    m_bMediaTypeSetByUser = true;
    return hr;
}


// --- ISpecifyPropertyPages ---

STDMETHODIMP CAudRepack::GetPages (CAUUID *pPages)

  { // GetPages //

    pPages->cElems = 1;
    pPages->pElems = (GUID *)CoTaskMemAlloc(sizeof(GUID));

    if (pPages->pElems == NULL)
    return E_OUTOFMEMORY;

    *(pPages->pElems) = CLSID_AUDProp;

    return NOERROR;

  } // GetPages



//////////////////////////////////////////////////////////////////////////
//
// CAudRepackInputPin
//
//////////////////////////////////////////////////////////////////////////
CAudRepackInputPin::CAudRepackInputPin(TCHAR       *pObjectName,
           CAudRepack *pBaseFilter,
           HRESULT     *phr,
           LPCWSTR      pPinName)
    : CTransformInputPin(pObjectName, pBaseFilter, phr, pPinName),
      m_pAudRepack(pBaseFilter)
{
}


CAudRepackInputPin::~CAudRepackInputPin()
{
}

// Offer MajorType AUDIO so intelligent connect can be way faster
// Don't offer a complete Mediatype... this exposes a bug in the MP3 decoder
// which will cease to function
//
HRESULT CAudRepackInputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (iPosition < 0) {
        return E_INVALIDARG;
    }
    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    SaferFreeMediaType(*pMediaType); // just in case
    pMediaType->SetType(&MEDIATYPE_Audio);
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//
// CAudRepackOutputPin
//
//////////////////////////////////////////////////////////////////////////
CAudRepackOutputPin::CAudRepackOutputPin(TCHAR       *pObjectName,
           CAudRepack *pBaseFilter,
           HRESULT     *phr,
           LPCWSTR      pPinName)
    : CTransformOutputPin(pObjectName, pBaseFilter, phr, pPinName),
      m_pAudRepack(pBaseFilter),
      m_pAudPassThru(NULL)
{
    ASSERT(pBaseFilter);
    DbgLog((LOG_TRACE, 2, TEXT("CAudRepackOutputPin()")));

}

CAudRepackOutputPin::~CAudRepackOutputPin()
{
    if( m_pAudPassThru)
    delete m_pAudPassThru;
    DbgLog((LOG_TRACE, 2, TEXT("~CAudRepackOutputPin()")));
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP CAudRepackOutputPin::NonDelegatingQueryInterface (REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;

    if (riid == IID_IMediaSeeking ) {
    //
    // Create a seeking implementation
    //
    ASSERT(m_pAudRepack->m_pInput != NULL);

    if (m_pAudPassThru == NULL)
    {
        HRESULT hr = S_OK;
        m_pAudPassThru = new  CAudPassThru (NAME("Audio Pass Through"),
                    GetOwner(),
                    &hr,
                     (IPin *)m_pAudRepack->m_pInput,
                     m_pAudRepack);

        if (FAILED(hr)) {
        return hr;
        }
    }
     return m_pAudPassThru->NonDelegatingQueryInterface(riid, ppv);
    }
    else {
    return CTransformOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}



CAudWorker::CAudWorker()
{
}

BOOL CAudWorker::Create(CAudRepack *pAud)
{
    m_pAud = pAud;

    return CAMThread::Create();
}

HRESULT CAudWorker::Run()
{
    return CallWorker(CMD_RUN);
}

HRESULT CAudWorker::Stop()
{
    return CallWorker(CMD_STOP);
}

HRESULT CAudWorker::Exit()
{
    return CallWorker(CMD_EXIT);
}



// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD CAudWorker::ThreadProc()
{
    BOOL bExit = FALSE;

    QzInitialize(NULL);

    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }

    QzUninitialize();

    return NOERROR;
}

HRESULT CAudWorker::DoRunLoop()
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 2, TEXT("AUD:entering worker thread")));

    while (1) {
	Command com;
	if (CheckRequest(&com)) {
	    if (com == CMD_STOP)
		break;
	}

	// no more blocking if we're waiting to get stopped
	if (!m_pAud->m_fThreadMustDie) {
            WaitForSingleObject(m_pAud->m_hEventThread, INFINITE);
	}

	// might have gotten set while we were blocked
	if (!m_pAud->m_fThreadMustDie && m_pAud->m_fThreadCanSeek) {
	    m_pAud->SeekNextSegment();
	}
    }

    DbgLog((LOG_TRACE, 2, TEXT("AUD:getting ready to leave worker thread")));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\black\black.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: black.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;


// !!! use 2 RO buffers, fill with black by calling GetBuffer twice

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "black.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"
#include "..\util\dexmisc.h"

#define MAXBUFFERCNT   2

// Setup data

const AMOVIESETUP_MEDIATYPE sudOpPinTypes =
{
    &MEDIATYPE_Video,       // Major type
    &MEDIASUBTYPE_NULL      // Minor type
};

const AMOVIESETUP_PIN sudOpPin =
{
    L"Output",              // Pin string name
    FALSE,                  // Is it rendered
    TRUE,                   // Is it an output
    FALSE,                  // Can we have none
    FALSE,                  // Can we have many
    &CLSID_NULL,            // Connects to filter
    NULL,                   // Connects to pin
    1,                      // Number of types
    &sudOpPinTypes };       // Pin details

const AMOVIESETUP_FILTER sudBlkVid =
{
    &CLSID_GenBlkVid,    // Filter CLSID
    L"Generate Solid Colour",  // String name
    MERIT_DO_NOT_USE,       // Filter merit
    1,                      // Number pins
    &sudOpPin               // Pin details
};

//
// CreateInstance
//
// Create GenBlkVid filter
//
CUnknown * WINAPI CGenBlkVid::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CGenBlkVid(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;

} // CreateInstance


//
// Constructor
//
// Initialise a CBlkVidStream object so that we have a pin.
//
CGenBlkVid::CGenBlkVid(LPUNKNOWN lpunk, HRESULT *phr) :
    CSource(NAME("Generate Solid Colour") ,lpunk,CLSID_GenBlkVid)
   ,CPersistStream(lpunk, phr)

{
    DbgLog((LOG_TRACE,3,TEXT("BLACK::")));

    CAutoLock cAutoLock(pStateLock());

    m_paStreams    = (CSourceStream **) new CBlkVidStream*[1];
    if (m_paStreams == NULL) {
        *phr = E_OUTOFMEMORY;
	return;
    }

    m_paStreams[0] = new CBlkVidStream(phr, this, L"Generate Solid Colour");
    if (m_paStreams[0] == NULL) {
        *phr = E_OUTOFMEMORY;
	return;
    }

} // (Constructor)


CGenBlkVid::~CGenBlkVid()
{
    DbgLog((LOG_TRACE,3,TEXT("~BLACK::")));
}


STDMETHODIMP CGenBlkVid::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IPersistStream) {
	return GetInterface((IPersistStream *) this, ppv);
    } else if (riid == IID_IDispatch) {
        return GetInterface((IDispatch *)this, ppv);
    } else {
	return CSource::NonDelegatingQueryInterface(riid, ppv);
    }
} // NonDelegatingQueryInterface



// IDispatch
//
STDMETHODIMP CGenBlkVid::GetTypeInfoCount(unsigned int *)
{
    return E_NOTIMPL;
}


STDMETHODIMP CGenBlkVid::GetTypeInfo(unsigned int,unsigned long,struct ITypeInfo ** )
{
    return E_NOTIMPL;
}


STDMETHODIMP CGenBlkVid::GetIDsOfNames(const struct _GUID &guid,unsigned short **pName ,unsigned int num,unsigned long loc,long *pOut)
{
    WCHAR *pw = *pName;
    if(
        (!DexCompareW(L"colour", pw))
        ||
        (!DexCompareW(L"color", pw))
    )
    {
	*pOut = 1;
	return S_OK;
    }
	
    return E_FAIL;
}


STDMETHODIMP CGenBlkVid::Invoke(long dispid,const struct _GUID &,unsigned long,unsigned short,struct tagDISPPARAMS *pDisp,struct tagVARIANT *,struct tagEXCEPINFO *,unsigned int *)
{
    if (dispid != 1)
	return E_FAIL;

    CBlkVidStream *pOutpin=( CBlkVidStream *)m_paStreams[0];

    #define US_LCID MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)
    VARIANT v;
    VariantInit(&v);
    HRESULT hr = VariantChangeTypeEx(&v, pDisp->rgvarg, US_LCID, 0, VT_R8);
    ASSERT(hr == S_OK);

    double f = V_R8(&v);
    pOutpin->m_dwRGBA = (DWORD)f;

    return S_OK;
}


// IPersistStream

// tell our clsid
//
STDMETHODIMP CGenBlkVid::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_GenBlkVid;
    return S_OK;
}

typedef struct _BLKSave {
    double		dOutputFrmRate;	// Output frm rate frames/second
    LONG		dwRGBA;
    AM_MEDIA_TYPE mt; 			// format is hidden after the array
} BLKSav;

// persist ourself
//
HRESULT CGenBlkVid::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CGenBlkVid::WriteToStream")));

    CheckPointer(pStream, E_POINTER);
    CheckPointer(m_paStreams[0], E_POINTER);

    BLKSav *px;
    CBlkVidStream *pOutpin=( CBlkVidStream *)m_paStreams[0];

    //get current media type
    CMediaType MyMt;
    pOutpin->get_MediaType( &MyMt );

    int savesize = sizeof(BLKSav) + MyMt.cbFormat;

    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));

    px = (BLKSav *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	SaferFreeMediaType(MyMt);
	return E_OUTOFMEMORY;
    }

    px->dOutputFrmRate	= pOutpin->m_dOutputFrmRate;
    px->dwRGBA		= pOutpin->m_dwRGBA;

    px->mt	    = MyMt;
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk	    = NULL;		// !!!

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(BLKSav);

    // the format goes after the array
    CopyMemory(pb, MyMt.pbFormat, MyMt.cbFormat);

    HRESULT hr = pStream->Write(px, savesize, 0);
    SaferFreeMediaType(MyMt);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself
//
HRESULT CGenBlkVid::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CenBlkVid::ReadFromStream")));

    CheckPointer(pStream, E_POINTER);
    CheckPointer(m_paStreams[0], E_POINTER);

    int savesize=sizeof(BLKSav);

    // we don't yet know how many saved connections there are
    // all we know we have for sure is the beginning of the struct
    BLKSav *px = (BLKSav *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if(px->mt.cbFormat)
    {
	// how much saved data was there, really?  Get the rest
	savesize +=  px->mt.cbFormat;
	px = (BLKSav *)QzTaskMemRealloc(px, savesize);
	if (px == NULL) {
	    DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	    return E_OUTOFMEMORY;
	}

    }
    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(BLKSav) ;
    hr = pStream->Read(pb, (savesize-sizeof(BLKSav)), 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    CBlkVidStream *pOutpin=( CBlkVidStream *)m_paStreams[0];

    pOutpin->put_OutputFrmRate(px->dOutputFrmRate);
    pOutpin->put_RGBAValue(px->dwRGBA);

    AM_MEDIA_TYPE MyMt = px->mt;
    MyMt.pbFormat = (BYTE *)QzTaskMemAlloc(MyMt.cbFormat);

    // remember, the format is after the array
    CopyMemory(MyMt.pbFormat, pb, MyMt.cbFormat);

    pOutpin->put_MediaType (&MyMt);
    SaferFreeMediaType(MyMt);
    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}

// how big is our save data?
int CGenBlkVid::SizeMax()
{
    if (!m_paStreams || !m_paStreams[0]) {
	return 0;

    }
    CBlkVidStream *pOutpin=( CBlkVidStream *)m_paStreams[0];
    int savesize = sizeof(BLKSav) + pOutpin->m_mtAccept.cbFormat;
    return savesize;
}


//
// output pin Constructor
//
CBlkVidStream::CBlkVidStream(HRESULT *phr,
                         CGenBlkVid *pParent,
                         LPCWSTR pPinName) :
    CSourceStream(NAME("Generate Solid Colour"),phr, pParent, pPinName),
    m_iBufferCnt(0),    //How many buffers we get
    m_lDataLen (0),	//output buffer data length
    m_dOutputFrmRate(15.0),
    m_dwRGBA( 0xFF000000 ),
    m_ppbDstBuf(NULL),
    m_fMediaTypeIsSet(FALSE),
    m_pImportBuffer(NULL),
    m_rtNewSeg(0),		// last NewSeg given
    // includes the NewSeg value
    m_rtStartTime(0),		// start at the beginning
    m_rtDuration(MAX_TIME/1000),// MUST DEFAULT TO INFINITE LENGTH because
				// dexter never sets a stop time! (don't be
				// too big that math on it will overflow)
    m_llSamplesSent(0)
{
    pParent->m_pStream	= this;

    //build a default media type
    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE));
    m_mtAccept.majortype = MEDIATYPE_Video;
    m_mtAccept.subtype = MEDIASUBTYPE_ARGB32;
    m_mtAccept.formattype = FORMAT_VideoInfo;

    m_mtAccept.bFixedSizeSamples = TRUE;
    m_mtAccept.bTemporalCompression = FALSE;

    m_mtAccept.pbFormat = (BYTE *)QzTaskMemAlloc(sizeof(VIDEOINFOHEADER));
    m_mtAccept.cbFormat = sizeof(VIDEOINFOHEADER);
    ZeroMemory(m_mtAccept.pbFormat, m_mtAccept.cbFormat);

    LPBITMAPINFOHEADER lpbi = HEADER(m_mtAccept.pbFormat);
    lpbi->biSize = sizeof(BITMAPINFOHEADER);
    lpbi->biCompression = BI_RGB;
    lpbi->biBitCount	= 32;
    lpbi->biWidth	= 320;
    lpbi->biHeight	= 240;
    lpbi->biPlanes	= 1;
    lpbi->biSizeImage = DIBSIZE(*lpbi);
    m_mtAccept.lSampleSize = DIBSIZE(*lpbi);
    ((VIDEOINFOHEADER *)(m_mtAccept.pbFormat))->AvgTimePerFrame = Frame2Time( 1, m_dOutputFrmRate );
    ((VIDEOINFOHEADER *)(m_mtAccept.pbFormat))->dwBitRate =
				(DWORD)(DIBSIZE(*lpbi) * m_dOutputFrmRate);

} // (Constructor)

    //X
// destructor
CBlkVidStream::~CBlkVidStream()
{
    /* BUFFER POINTER */
    if (m_ppbDstBuf)  delete [] m_ppbDstBuf;

    if (m_pImportBuffer){ delete [] m_pImportBuffer; m_pImportBuffer=NULL;};

    SaferFreeMediaType(m_mtAccept); // in destructor
}

//
// IGenVideo, IDexterSequencer
// ISpecifyPropertyPages
//
STDMETHODIMP CBlkVidStream::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv
    )
{
    if (IsEqualIID(IID_IGenVideo, riid))
      return GetInterface((IGenVideo *) this, ppv);

    if (IsEqualIID(IID_IDexterSequencer, riid))
      return GetInterface((IDexterSequencer *) this, ppv);

    if (IsEqualIID(IID_ISpecifyPropertyPages, riid))
      return GetInterface((ISpecifyPropertyPages *) this, ppv);

    if (IsEqualIID(IID_IMediaSeeking, riid))
      return GetInterface((IMediaSeeking *) this, ppv);

    return CSourceStream::NonDelegatingQueryInterface(riid, ppv);
}


//
// DoBufferProcessingLoop - overridden to put time stamps on GetBuffer
//
// Grabs a buffer and calls the users processing function.
// Overridable, so that different delivery styles can be catered for.
HRESULT CBlkVidStream::DoBufferProcessingLoop(void) {

    Command com;

    DbgLog((LOG_TRACE, 3, TEXT("Entering DoBufferProcessing Loop")));

    OnThreadStartPlay();

    do {
	while (!CheckRequest(&com)) {
	    IMediaSample *pSample;

    	    // What time stamps will this buffer get? Use that in GetBuffer
	    // because the switch needs to know.  MAKE SURE to use the same
	    // algorithm as FillBuffer!
    	    LONGLONG llOffset = Time2Frame( m_rtStartTime, m_dOutputFrmRate );
    	    REFERENCE_TIME rtStart = Frame2Time( llOffset + m_llSamplesSent,
							m_dOutputFrmRate );
    	    REFERENCE_TIME rtStop = Frame2Time( llOffset + m_llSamplesSent + 1,
							m_dOutputFrmRate );

    	    if ( rtStart > m_rtStartTime + m_rtDuration ||
		(rtStart == m_rtStartTime + m_rtDuration && m_rtDuration > 0)) {
		DbgLog((LOG_TRACE,2,TEXT("Black: Finished")));
		//m_llSamplesSent = 0;
		DeliverEndOfStream();
		return S_OK;
    	    }

    	    rtStart -= m_rtNewSeg;
    	    rtStop -= m_rtNewSeg;

    	    DbgLog((LOG_TRACE,2,TEXT("Black: GetBuffer %d"),
						(int)(rtStart / 10000)));
	    HRESULT hr = GetDeliveryBuffer(&pSample,&rtStart,&rtStop,0);
	    if (FAILED(hr)) {
    	        DbgLog((LOG_TRACE,2,TEXT("Black: FAILED %x"), hr));
		return S_OK;
	    }

	    // Virtual function user will override.
	    hr = FillBuffer(pSample);

	    if (hr == S_OK) {
		hr = Deliver(pSample);
                pSample->Release();

                // downstream filter returns S_FALSE if it wants us to
                // stop or an error if it's reporting an error.
                if(hr != S_OK)
                {
                  DbgLog((LOG_TRACE, 2, TEXT("Deliver() returned %08x; stopping"), hr));
		  // NO NO! DeliverEndOfStream();
		  // !!! EC_ERRORABORT if FAILED?
                  return hr;
                }

	    } else if (hr == S_FALSE) {
                // derived class wants us to stop pushing data
		pSample->Release();
		DeliverEndOfStream();
		return S_OK;
	    } else {
                // derived class encountered an error
                pSample->Release();
		DbgLog((LOG_ERROR, 1, TEXT("Error %08lX from FillBuffer!!!"), hr));
                DeliverEndOfStream();
                m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
                return hr;
	    }

            // all paths release the sample
	}

        // For all commands sent to us there must be a Reply call!

	if (com == CMD_RUN || com == CMD_PAUSE) {
	    Reply(NOERROR);
	} else if (com != CMD_STOP) {
	    Reply((DWORD) E_UNEXPECTED);
	    DbgLog((LOG_ERROR, 1, TEXT("Unexpected command!!!")));
	}
    } while (com != CMD_STOP);

    return S_FALSE;
}


//
// FillBuffer called by HRESULT CSourceStream::DoBufferProcessingLoop(void) {
//
// Plots a Blk video into the supplied video buffer
//
// Give  a start time, a duration, and a frame rate,
// it sends  a certain size (ARGB32, RGB555,RGB24 ) black frames out time stamped appropriately starting
// at the start time.
//
HRESULT CBlkVidStream::FillBuffer(IMediaSample *pms)
{
    CAutoLock foo(&m_csFilling);

    ASSERT( m_ppbDstBuf != NULL );
    ASSERT( m_iBufferCnt );
    ASSERT( m_dOutputFrmRate != 0.0);

    // !!! If NewSeg > 0, this is broken!

    // calc the output sample times the SAME WAY FRC DOES, so the FRC will
    // not need to modify anything
    LONGLONG llOffset = Time2Frame( m_rtStartTime, m_dOutputFrmRate );
    REFERENCE_TIME rtStart = Frame2Time( llOffset + m_llSamplesSent,
							m_dOutputFrmRate );
    REFERENCE_TIME rtStop = Frame2Time( llOffset + m_llSamplesSent + 1,
							m_dOutputFrmRate );
    if ( rtStart > m_rtStartTime + m_rtDuration ||
		(rtStart == m_rtStartTime + m_rtDuration && m_rtDuration > 0)) {
	DbgLog((LOG_TRACE,2,TEXT("Black: Finished")));
	//m_llSamplesSent = 0;
	DeliverEndOfStream();
	return S_FALSE;
    }

    rtStart -= m_rtNewSeg;
    rtStop -= m_rtNewSeg;

    BYTE *pData;

    //pms: output media sample pointer
    pms->GetPointer(&pData);	    //get pointer to output buffer

    if( m_bZeroBufCnt < m_iBufferCnt  )	
    {
	//
	// there is no guarantee the buffer we just get is not initilized before
	//
	int	i	= 0;
	BOOL	bInit	= FALSE;
	while ( i <  m_bZeroBufCnt )
	{
	    if( m_ppbDstBuf[ i++ ] == pData)
	    {
		bInit	= TRUE;
		break;
	    }
	}

	if( bInit   == FALSE )
	{
	    long lDataLen = pms->GetSize(); //get output buffer size
	    if(!m_dwRGBA)
	    {
		//import buffer
		if(m_pImportBuffer)
		    CopyMemory(pData,m_pImportBuffer,lDataLen);
		else
		    //TRANSPARENT black
    		    ZeroMemory( pData, lDataLen );  //clear memory
	    }
	    else
	    {
		long *pl    =	(long *)pData;
		BYTE *p=(BYTE *)pl;
		int iCnt= lDataLen/12;
		
		switch(HEADER(m_mtAccept.pbFormat)->biBitCount)
		{
		case 32:
		    while(lDataLen)
		    {
			*pl++=m_dwRGBA;
			lDataLen-=4;
		    }
		    break;
		case 24:
		    long dwVal[3];
		    dwVal[0]= ( m_dwRGBA & 0xffffff )       | ( (m_dwRGBA & 0xff) << 24);
		    dwVal[1]= ( (m_dwRGBA & 0xffff00) >>8 ) | ( (m_dwRGBA & 0xffff) << 16);
		    dwVal[2]= ( (m_dwRGBA & 0xff0000) >>16 )| ( (m_dwRGBA & 0xffffff) << 8);
		    while(iCnt)
		    {
			*pl++=dwVal[0];
			*pl++=dwVal[1];
			*pl++=dwVal[2];
			iCnt--;
		    }
		    while(iCnt)
		    {
			*p++=(BYTE)( m_dwRGBA & 0xff );
			*p++=(BYTE)( ( m_dwRGBA & 0xff00 ) >> 8) ;
			*p++=(BYTE)( ( m_dwRGBA & 0xff0000 ) >> 16) ;
			iCnt--;
		    }
		    break;
		case 16:
		    WORD wTmp=(WORD)(  ((m_dwRGBA & 0xf8)    >>3 )      //R
				    | ((m_dwRGBA & 0xf800)  >>6 )      //G
				    | ((m_dwRGBA & 0xf80000)>>9 ) );	//B
		    WORD *pw=(WORD *)pData;
		    while(lDataLen)
		    {
			*pw++=wTmp;
			lDataLen-=2;
		    }
		    break;
		}
	    }
	    m_ppbDstBuf[ i ]	= pData;    //save this data pointer	
	    m_bZeroBufCnt++;
	}
    }

    DbgLog((LOG_TRACE,2,TEXT("Black: Deliver %d"), (int)(rtStart / 10000)));
    pms->SetTime( &rtStart,&rtStop);

    m_llSamplesSent++;
    pms->SetActualDataLength(m_lDataLen);
    pms->SetSyncPoint(TRUE);
    return NOERROR;

} // FillBuffer


//
// GetMediaType
//
HRESULT CBlkVidStream::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock cAutoLock(m_pFilter->pStateLock());

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Have we run off the end of types
    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    return get_MediaType( pmt );

} // GetMediaType


// set media type
//
HRESULT CBlkVidStream::SetMediaType(const CMediaType* pmt)
{
    DbgLog((LOG_TRACE,2,TEXT("SetMediaType %x %dbit %dx%d"),
		HEADER(pmt->Format())->biCompression,
		HEADER(pmt->Format())->biBitCount,
		HEADER(pmt->Format())->biWidth,
		HEADER(pmt->Format())->biHeight));

// !!! check for the frame rate given, and use it?

    return CSourceStream::SetMediaType(pmt);
}

//
// CheckMediaType
//
// We accept mediatype =vids, subtype =MEDIASUBTYPE_ARGB32, RGB24, RGB555
// Returns E_INVALIDARG if the mediatype is not acceptable
//
HRESULT CBlkVidStream::CheckMediaType(const CMediaType *pMediaType)
{
    CAutoLock cAutoLock(m_pFilter->pStateLock());

    if (   ( (*pMediaType->Type())   != MEDIATYPE_Video )  	// we only output video!
	|| (    (*pMediaType->Subtype())!= MEDIASUBTYPE_ARGB32
	     && (*pMediaType->Subtype())!= MEDIASUBTYPE_RGB24
	     && (*pMediaType->Subtype())!= MEDIASUBTYPE_RGB555
	    )
       )
                return E_INVALIDARG;

    // Get the format area of the media type
    VIDEOINFO *pvi = (VIDEOINFO *) pMediaType->Format();

    if (pvi == NULL)
	return E_INVALIDARG;

    // Check the image size.
    if ( (pvi->bmiHeader.biWidth  != HEADER(m_mtAccept.pbFormat)->biWidth )  ||
	 (pvi->bmiHeader.biHeight != HEADER(m_mtAccept.pbFormat)->biHeight ) ||
	 (pvi->bmiHeader.biBitCount != HEADER(m_mtAccept.pbFormat)->biBitCount ))
    {
	return E_INVALIDARG;
    }

    if( !IsRectEmpty( &pvi->rcTarget) ) {
	if (pvi->rcTarget.top != 0 || pvi->rcTarget.left !=0 ||
		pvi->rcTarget.right != pvi->bmiHeader.biWidth ||
		pvi->rcTarget.bottom != pvi->bmiHeader.biHeight) {
	    return VFW_E_TYPE_NOT_ACCEPTED;
	}
    }
    if( !IsRectEmpty( &pvi->rcSource) ) {
	if (pvi->rcSource.top != 0 || pvi->rcSource.left !=0 ||
		pvi->rcSource.right != pvi->bmiHeader.biWidth ||
		pvi->rcSource.bottom != pvi->bmiHeader.biHeight) {
	    return VFW_E_TYPE_NOT_ACCEPTED;
	}
    }
	
    return S_OK;  // This format is acceptable.

} // CheckMediaType


HRESULT CBlkVidStream::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, TRUE);		//read only buffer
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, TRUE);  //READ-only buffer
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;
}

//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. So we have a look at m_mt to see what size image we agreed.
// Then we can ask for buffers of the correct size to contain them.
//
HRESULT CBlkVidStream::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock cAutoLock(m_pFilter->pStateLock());

    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    VIDEOINFO *pvi = (VIDEOINFO *) m_mt.Format();

    pProperties->cBuffers = MAXBUFFERCNT;   //only one read-only buffer
    pProperties->cbBuffer = pvi->bmiHeader.biSizeImage;


    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }

    //because I am not insisting my own buffer, I may get more than MAXBUFFERCNT buffers.
    m_iBufferCnt =Actual.cBuffers; //how many buffer need to be set to 0

    return NOERROR;

} // DecideBufferSize



//
// OnThreadCreate
//
//
HRESULT CBlkVidStream::OnThreadCreate()
{
    // we have to have at least MAXBUFFERCNT buffer
    ASSERT(m_iBufferCnt >= MAXBUFFERCNT);

    //output frame cnt
    m_llSamplesSent	    =0;

    //how many buffer is already set to 0.
    m_bZeroBufCnt	    =0;

    // actual output buffer's data size
    m_lDataLen= HEADER(m_mtAccept.pbFormat)->biHeight * (DWORD)WIDTHBYTES((DWORD)HEADER(m_mtAccept.pbFormat)->biWidth * HEADER(m_mtAccept.pbFormat)->biBitCount);

    // will be used to zero the Dst buffers
    delete [] m_ppbDstBuf;
    m_ppbDstBuf		= new BYTE *[ m_iBufferCnt ];   //NULL;
    if( !m_ppbDstBuf )
    {
        return E_OUTOFMEMORY;
    }

    // don't reset m_rtNewSeg!  We might have seeked while stopped

    for (int i=0; i<m_iBufferCnt; i++)
	m_ppbDstBuf[i]=NULL;

    return NOERROR;

} // OnThreadCreate


//
// Notify
//
//
STDMETHODIMP CBlkVidStream::Notify(IBaseFilter * pSender, Quality q)
{
    //Even I am later, I do not care. I still send my time frame as nothing happened.
    return NOERROR;

} // Notify

//
// GetPages
//
// Returns the clsid's of the property pages we support
//
STDMETHODIMP CBlkVidStream::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL)
    {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_GenVidPropertiesPage;
    return NOERROR;

} // GetPages

//
// IDexterSequencer
//

STDMETHODIMP CBlkVidStream::get_OutputFrmRate( double *dpFrmRate )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());

    CheckPointer(dpFrmRate,E_POINTER);

    *dpFrmRate = m_dOutputFrmRate;

    return NOERROR;

} // get_OutputFrmRate

//
// Frame rate can be changed as long as the filter is stopped.
//
STDMETHODIMP CBlkVidStream::put_OutputFrmRate( double dFrmRate )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());

    //can not change property if our filter is not currently stopped
    if(!IsStopped() )
      return VFW_E_WRONG_STATE;

    // don't blow up
    if (dFrmRate == 0.0)
	dFrmRate = 0.1;
    m_dOutputFrmRate = dFrmRate;

    return NOERROR;

} // put_OutputFrmRate

STDMETHODIMP CBlkVidStream::get_MediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pmt,E_POINTER);

    return CopyMediaType(pmt, &m_mtAccept);
}

//
// size can be changed only the output pin is not connected yet.
//
STDMETHODIMP CBlkVidStream::put_MediaType(const AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pmt,E_POINTER);

    if ( IsConnected() )
	return VFW_E_ALREADY_CONNECTED;

    if ( HEADER(pmt->pbFormat)->biBitCount != 32 &&
	 HEADER(pmt->pbFormat)->biBitCount != 24 &&
	 HEADER(pmt->pbFormat)->biBitCount != 16)
	return E_INVALIDARG;

    if (HEADER(pmt->pbFormat)->biWidth == 16 &&
	pmt->subtype != MEDIASUBTYPE_RGB555)
	return E_INVALIDARG;

    SaferFreeMediaType(m_mtAccept);
    HRESULT hr = CopyMediaType(&m_mtAccept, pmt);

    m_fMediaTypeIsSet =TRUE;

    return hr;
}


// We don't support this, the frame rate converter does

STDMETHODIMP CBlkVidStream::GetStartStopSkewCount(int *piCount)
{
    return E_NOTIMPL;
}


STDMETHODIMP CBlkVidStream::GetStartStopSkew( REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop, REFERENCE_TIME *prtSkew, double *pdRate )
{
    return E_NOTIMPL;
}

STDMETHODIMP CBlkVidStream::AddStartStopSkew( REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, REFERENCE_TIME rtSkew , double dRate)
{
    return E_NOTIMPL;
}


//
// Duration can be changed as long as the filter is stopped.
//
STDMETHODIMP CBlkVidStream::ClearStartStopSkew()
{
    return E_NOTIMPL;
}


//
// IGenVideo
//


STDMETHODIMP CBlkVidStream::get_RGBAValue( long *pdwRGBA )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pdwRGBA,E_POINTER);

    *pdwRGBA=m_dwRGBA ;

    return NOERROR;

}

STDMETHODIMP CBlkVidStream::put_RGBAValue( long dwRGBA )
{

    CAutoLock cAutolock(m_pFilter->pStateLock());

    //can not change duration if our filter is not currently stopped
    if(!IsStopped() )
      return VFW_E_WRONG_STATE;

    m_dwRGBA = dwRGBA;

    return NOERROR;

}


// --- IMediaSeeking methods ----------

STDMETHODIMP
CBlkVidStream::GetCapabilities(DWORD * pCaps)
{
    CheckPointer(pCaps,E_POINTER);
    // we always know the current position
    *pCaps =     AM_SEEKING_CanSeekAbsolute
		   | AM_SEEKING_CanSeekForwards
		   | AM_SEEKING_CanSeekBackwards
		   | AM_SEEKING_CanGetCurrentPos
		   | AM_SEEKING_CanGetStopPos
		   | AM_SEEKING_CanGetDuration;
		   //| AM_SEEKING_CanDoSegments
		   //| AM_SEEKING_Source;
    return S_OK;
}


STDMETHODIMP
CBlkVidStream::CheckCapabilities(DWORD * pCaps)
{
    CheckPointer(pCaps,E_POINTER);

    DWORD dwMask = 0;
    GetCapabilities(&dwMask);
    *pCaps &= dwMask;

    return S_OK;
}


STDMETHODIMP
CBlkVidStream::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

STDMETHODIMP
CBlkVidStream::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);

    if(*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return E_FAIL;
}

STDMETHODIMP
CBlkVidStream::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    if (*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return S_FALSE;
}

// The biggie!
//
STDMETHODIMP
CBlkVidStream::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
    // make sure we're not filling a buffer right now
    m_csFilling.Lock();

    HRESULT hr;
    REFERENCE_TIME rtStart, rtStop;

    // we don't do segments
    if ((CurrentFlags & AM_SEEKING_Segment) ||
				(StopFlags & AM_SEEKING_Segment)) {
    	DbgLog((LOG_TRACE,1,TEXT("FRC: ERROR-Seek used EC_ENDOFSEGMENT!")));
        m_csFilling.Unlock();
	return E_INVALIDARG;
    }

    // default to current values unless this seek changes them
    // these numbers already include new segment times
    GetCurrentPosition(&rtStart);
    GetStopPosition(&rtStop);

    // figure out where we're seeking to
    DWORD dwFlags = (CurrentFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	rtStart = *pCurrent;
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	hr = GetCurrentPosition(&rtStart);
	rtStart += *pCurrent;
    } else if (dwFlags) {
    	DbgLog((LOG_TRACE,1,TEXT("Switch::Invalid Current Seek flags")));
        m_csFilling.Unlock();
	return E_INVALIDARG;
    }

    dwFlags = (StopFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pStop, E_POINTER);
	rtStop = *pStop;
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pStop, E_POINTER);
	hr = GetStopPosition(&rtStop);
	rtStop += *pStop;
    } else if (dwFlags == AM_SEEKING_IncrementalPositioning) {
	CheckPointer(pStop, E_POINTER);
	hr = GetCurrentPosition(&rtStop);
	rtStop += *pStop;
    }

    // !!! We ignore the seek stop time!

    DbgLog((LOG_TRACE,2,TEXT("Seek BLACK:  Start=%d Stop=%d"),
			(int)(rtStart / 10000), (int)(rtStop / 10000)));

    // flush first, so that our thread won't be blocked delivering
    DeliverBeginFlush();

    // Unlock/Stop so that our thread can wake up and stop without hanging
    m_csFilling.Unlock();
    Stop();

    m_rtStartTime = rtStart;
    m_rtDuration = rtStop - rtStart;
    m_llSamplesSent = 0;

    // now finish flushing
    DeliverEndFlush();

    DeliverNewSegment(rtStart, rtStop, 1.0);
    m_rtNewSeg = rtStart;

    // reset same stuff we reset when we start streaming
    m_bZeroBufCnt = 0;

    // now start the thread up again
    Pause();

    DbgLog((LOG_TRACE,2,TEXT("Completed BLACK seek")));

    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop)
{
    CheckPointer(pCurrent, E_POINTER);
    CheckPointer(pStop, E_POINTER);
    GetCurrentPosition(pCurrent);
    GetStopPosition(pStop);
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetCurrentPosition(LONGLONG *pCurrent)
{
    CheckPointer(pCurrent, E_POINTER);
    *pCurrent = m_rtStartTime + Frame2Time( m_llSamplesSent, m_dOutputFrmRate );
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetStopPosition(LONGLONG *pStop)
{
    CheckPointer(pStop, E_POINTER);
    *pStop = m_rtStartTime + m_rtDuration;
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
    CheckPointer(pEarliest, E_POINTER);
    CheckPointer(pLatest, E_POINTER);
    *pEarliest = 0;
    *pLatest = MAX_TIME;
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetDuration( LONGLONG *pDuration )
{
    CheckPointer(pDuration, E_POINTER);
    *pDuration = m_rtDuration;
    return S_OK;
}

STDMETHODIMP
CBlkVidStream::GetRate( double *pdRate )
{
    CheckPointer(pdRate, E_POINTER);
    *pdRate = 1.0;
    return S_OK;
}


STDMETHODIMP
CBlkVidStream::SetRate( double dRate )
{
    if (dRate == 1.0)
	return S_OK;
    ASSERT(FALSE);
    return E_INVALIDARG;
}


/*X* When you make the filter, it always asks for a filename
    because it's based on a file source filter.
    So, solid colour filter support ImportSrcBuffer(), Stillvid filter does not) *X*/
STDMETHODIMP CBlkVidStream::ImportSrcBuffer(const AM_MEDIA_TYPE *pmt, const BYTE *pBuf)
{

    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pBuf, E_POINTER);

    if ( IsConnected() )
	return VFW_E_ALREADY_CONNECTED;

    HRESULT hr = put_MediaType(pmt);
    if (FAILED(hr))
	return hr;

    if( m_pImportBuffer!=NULL )
	delete [] m_pImportBuffer;

    VIDEOINFO *pvi = (VIDEOINFO *) m_mt.Format();
    LONG lSize = pvi->bmiHeader.biSizeImage;

    m_pImportBuffer = new BYTE [lSize ];   //NULL;
    if( !m_pImportBuffer )
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(m_pImportBuffer, (PBYTE) pBuf, sizeof(BYTE)*lSize);
    //m_fMediaTypeIsSet = FALSE;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\black\black.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: black.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// !!! Support IGenVideo, IDexterSequencer on the FILTER, not the pin?

extern const AMOVIESETUP_FILTER sudBlkVid;


// Generates Black Video 

class CBlkVidStream;
class CGenVidProperties;

// Main object for a Generate Black Video
class CGenBlkVid :  public CSource
	    , public CPersistStream, public IDispatch

{
    friend class CBlkVidStream;

public:
    CGenBlkVid(LPUNKNOWN lpunk, HRESULT *phr);
    ~CGenBlkVid();
    DECLARE_IUNKNOWN;

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(unsigned int *);
    STDMETHODIMP GetTypeInfo(unsigned int,unsigned long,struct ITypeInfo ** );
    STDMETHODIMP GetIDsOfNames(const struct _GUID &,unsigned short ** ,unsigned int,unsigned long,long *);
    STDMETHODIMP Invoke(long,const struct _GUID &,unsigned long,unsigned short,struct tagDISPPARAMS *,struct tagVARIANT *,struct tagEXCEPINFO *,unsigned int *);

    // Create GenBlkVid filter!
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

private:

    CBlkVidStream *m_pStream;

    friend class CBlkVidStream;

}; // CGenBlkVid


// CBlkVidStream manages the data flow from the output pin.
class CBlkVidStream :	public CSourceStream
			, public IGenVideo
			, public IDexterSequencer
			, public ISpecifyPropertyPages
			, public IMediaSeeking
{
    friend class CGenBlkVid ;
    friend class CGenVidProperties ;

public:

    CBlkVidStream(HRESULT *phr, CGenBlkVid *pParent, LPCWSTR pPinName);
    ~CBlkVidStream();

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities ); 
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);	
    STDMETHODIMP GetTimeFormat(GUID *pFormat);		    
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);  
    STDMETHODIMP IsFormatSupported( const GUID * pFormat); 
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);	    
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );
    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetDuration( LONGLONG *pDuration );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll )
	{ if( pllPreroll) *pllPreroll =0; return S_OK; };
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP ConvertTimeFormat(LONGLONG *pTarget, const GUID *pTargetFormat,
				   LONGLONG Source, const GUID *pSourceFormat )
	{ return E_NOTIMPL ;};


    //IGenVideo, IDexterSequencer, and ISpecifyPropertyPages
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);
    STDMETHODIMP GetPages(CAUUID *pPages);
    DECLARE_IUNKNOWN;

    // put blank ARGB32 video into the supplied video frame
    HRESULT DoBufferProcessingLoop(void);
    HRESULT FillBuffer(IMediaSample *pms);

    // To say "read only buffer"
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);

    // Ask for buffers of the size appropriate to the agreed media type
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);


    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType* pmt);

    // Resets the stream time to zero
    HRESULT OnThreadCreate(void);


    //IDexterSequencer
    STDMETHODIMP get_OutputFrmRate(double *dpFrmRate);
    STDMETHODIMP put_OutputFrmRate(double dFrmRate);
    STDMETHODIMP get_MediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP put_MediaType(const AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetStartStopSkewCount(int *piCount);
    STDMETHODIMP GetStartStopSkew(REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop, REFERENCE_TIME *prtSkew, double *pdRate);
    STDMETHODIMP AddStartStopSkew(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, REFERENCE_TIME rtSkew, double dRate);
    STDMETHODIMP ClearStartStopSkew();

    //IGenVideo
    STDMETHODIMP ImportSrcBuffer(const AM_MEDIA_TYPE *pmt, const BYTE *pBuf);
    STDMETHODIMP get_RGBAValue(long *dwRGBA);
    STDMETHODIMP put_RGBAValue(long dwRGBA);

    // DO NO SUPPORT Quality control notifications sent to us
    // STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

protected:

    REFERENCE_TIME	m_rtStartTime;	// start time to play
    REFERENCE_TIME	m_rtDuration;	// duration

    REFERENCE_TIME	m_rtNewSeg;	// last NewSeg given

    LONG		m_lDataLen;		//actual output data lenght
    CMediaType 		m_mtAccept;		// accept only this type
    LONGLONG		m_llSamplesSent;	// output frame cnt
    double		m_dOutputFrmRate;	// Output frm rate frames/second
    LONG		m_dwRGBA;		// solid colour to generate
    BYTE		m_bIntBufCnt;		// CNT for first 2 sampel	
    int			m_iBufferCnt;		//record how many buffer it can gets
    BYTE		m_bZeroBufCnt;		// How many buffer already set to 0
    BYTE		**m_ppbDstBuf;
    BOOL		m_fMediaTypeIsSet;	//flag : whether put_MediaType() is called first
    PBYTE		m_pImportBuffer;	//pointer to import data buffer

    CCritSec    m_csFilling;	// are we delivering?

}; // CBlkVidStream
	

class CGenVidProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
         
private:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void SetDirty();

    CGenVidProperties(LPUNKNOWN lpunk, HRESULT *phr);


    STDMETHODIMP GetFromDialog();

    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg
                            // to prevent theDirty flag from being set.

    REFERENCE_TIME	m_rtStartTime;
    REFERENCE_TIME	m_rtDuration;
    LONG		m_biWidth;			// output video Width
    LONG		m_biHeight;			// output video Height
    WORD		m_biBitCount;			// support 16,24,32
    double		m_dOutputFrmRate;		// Output frm rate frames/second
    long		m_dwRGBA;	// solid colour to generate


    CBlkVidStream	*m_pCBlack;
    IGenVideo		*m_pGenVid;
    IDexterSequencer	*m_pDexter;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\black\resource.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by prop.rc
//
#define IDS_TITLE                       300
#define IDD_GenVid                      301
#define IDC_EFFECT                      302
#define IDB_DEFAULT                     303
#define IDC_START                       304
#define IDC_DURATION                    305
#define IDC_FRAMERATE                   306
#define IDC_BITCOUNT			307
#define IDC_VIDWIDTH                    308
#define IDC_VIDHEIGHT                   309
#define IDC_COLOR_R			310
#define IDC_COLOR_G			311
#define IDC_COLOR_B			312
#define IDC_COLOR_A			313
#ifndef IDS_STATIC
#define IDS_STATIC                      -1
#endif

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\comp\comp.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: comp.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtCompositor.cpp : Implementation of CDxtCompositor
#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "Comp.h"
#include <math.h>

/////////////////////////////////////////////////////////////////////////////
// CDxtCompositor

CDxtCompositor::CDxtCompositor( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nSurfaceWidth = 0;
    m_nSurfaceHeight = 0;
    m_nDstX = 0;
    m_nDstY = 0;
    m_nDstWidth = -1;
    m_nDstHeight = -1;
    m_nSrcX = 0;
    m_nSrcY = 0;
    m_nSrcWidth = -1;
    m_nSrcHeight = -1;
    m_pRowBuffer = NULL;
    m_pDestRowBuffer = NULL;
}

CDxtCompositor::~CDxtCompositor( )
{
    if( m_pRowBuffer )
    {
        delete [] m_pRowBuffer;
        m_pRowBuffer = NULL;
    }

    if(m_pDestRowBuffer)
    {
        delete [] m_pDestRowBuffer;
        m_pDestRowBuffer = NULL;
    }
}

HRESULT CDxtCompositor::OnSetup( DWORD dwFlags )
{
    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nSurfaceWidth = OutBounds.Width( );
    m_nSurfaceHeight = OutBounds.Height( );
    if( ( m_nSrcX < 0 ) || ( m_nSrcWidth + m_nSrcX > m_nSurfaceWidth ) )
    {
        return E_INVALIDARG;
    }
    if( ( m_nSrcY < 0 ) || ( m_nSrcHeight + m_nSrcY > m_nSurfaceHeight ) )
    {
        return E_INVALIDARG;
    }
    if( m_nSrcWidth == -1 )
    {
        m_nSrcWidth = m_nSurfaceWidth;
    }
    if( m_nSrcHeight == -1 )
    {
        m_nSrcHeight = m_nSurfaceHeight;
    }
    if( m_nDstWidth == -1 )
    {
        m_nDstWidth = m_nSurfaceWidth;
    }
    if( m_nDstHeight == -1 )
    {
        m_nDstHeight = m_nSurfaceHeight;
    }

    if( m_pRowBuffer )
    {
        delete [] m_pRowBuffer;
        m_pRowBuffer = NULL;
    }

    m_pRowBuffer = new DXPMSAMPLE[ m_nSurfaceWidth ];
    if( !m_pRowBuffer )
    {
        return E_OUTOFMEMORY;
    }

    // try to allocate the destination row buffer (needed when we scale up)
    if(m_pDestRowBuffer)
    {
        delete [] m_pDestRowBuffer;
        m_pDestRowBuffer = NULL;
    }

    m_pDestRowBuffer = new DXPMSAMPLE[ m_nSurfaceWidth ];
    if( !m_pDestRowBuffer )
    {
        // delete the row buffer
        delete [] m_pRowBuffer;
        m_pRowBuffer = NULL;

        // signal error
        return E_OUTOFMEMORY;
    }

    return NOERROR;
}

HRESULT CDxtCompositor::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nSurfaceWidth = 0;
    m_nSurfaceHeight = 0;
    m_nDstX = 0;
    m_nDstY = 0;
    m_nDstWidth = -1;
    m_nDstHeight = -1;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CDxtCompositor::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;

    CComPtr<IDXARGBReadPtr> pInA;
    hr = InputSurface( 0 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInA, NULL );
    if( FAILED( hr ) ) return hr;

    CComPtr<IDXARGBReadPtr> pInB;
    hr = InputSurface( 1 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInB, NULL );
    if( FAILED( hr ) ) return hr;

    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
    if( FAILED( hr ) ) return hr;

    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // no dithering! Ever!
    //
    if (DoDither())
    {
        return 0;
    }

    long t1 = timeGetTime( );

    ULONG OutY;

    // copy the background (A) to the resultant picture. You cannot do this as a block
    // copy, it will fail.
    //
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        pInA->MoveToRow( OutY );
        pOut->MoveToRow( OutY );
        pOut->CopyAndMoveBoth( (DXBASESAMPLE*) m_pRowBuffer, pInA, Width, FALSE );
    }

    // don't draw if destination is completely out of bounds
    //
    if( m_nDstX + m_nDstWidth < 0 ||
        m_nDstX > m_nSurfaceWidth ||
        m_nDstY + m_nDstHeight < 0 ||
        m_nDstY > m_nSurfaceHeight )
    {
        return 0;
    }

    if( m_nDstWidth < 0 )
    {
        return E_INVALIDARG;
    }

    if( m_nDstWidth == 0 )
    {
        return NOERROR;
    }

    // calculate the ration of the source to the destination, as integer math
    //
    long width_divider = (m_nSrcWidth << 16) / m_nDstWidth;

    long DstWidth = m_nDstWidth;
    long DstX = m_nDstX;
    long SrcWidth = m_nSrcWidth;
    long SrcX = m_nSrcX;

    // bring it within range
    //
    if( DstX < 0 )
    {
        long diff = -DstX;
        SrcX += diff * width_divider / 65536;
        SrcWidth -= diff * width_divider / 65536;
        DstWidth -= diff;
        DstX = 0;
    }
    if( DstX + DstWidth > (long) Width )
    {
        long diff = DstX + DstWidth - Width;
        SrcWidth -= ( diff * width_divider ) / 65536;
        DstWidth -= diff;
    }
    if( ( SrcX < 0 ) || ( SrcX + SrcWidth > m_nSurfaceWidth ) )
    {
        return E_INVALIDARG;
    }
    if( ( m_nSrcY < 0 ) || ( m_nSrcY + m_nSrcHeight > m_nSurfaceHeight ) )
    {
        return E_INVALIDARG;
    }

    // we don't check DstY or DxtY + DstHeight because
    // if they're OOB, we just ignore it in the loop below

    // what if SrcX is still out of bounds?

    long DstRight = DstX + DstWidth; // ( width_divider * DstWidth ) >> 16;
    DbgLog( ( LOG_TRACE, 3, ", Dest X1 = %ld, Wid = %ld, Dest X2 = %ld", m_nDstX, DstWidth, DstRight ) );

    for( OutY = 0 ; OutY < (ULONG) m_nDstHeight ; OutY++ )
    {
        // avoid out of bounds Y conditions. This can happen
        // because it's on Dst, it's not a source-only calculation
        //
        if( long( OutY + m_nDstY ) < 0 )
        {
            continue;
        }
        if( OutY + m_nDstY >= Height )
        {
            continue;
        }

        // unpack a row of the source to a row buffer, starting at the source's offset.
        // the unpacking is done without scaling, from the source image.
        // (don't allow unpacking from an invalid source Y location)
        //
        long SourceY = m_nSrcY + ( OutY * m_nSrcHeight ) / m_nDstHeight;

        pInB->MoveToXY( SrcX, SourceY );
        pInB->UnpackPremult( m_pRowBuffer, SrcWidth, FALSE );

        // seek to where we're going to draw to on the Y axis.
        //
        pOut->MoveToXY( DstX, OutY + m_nDstY );

        // copy DstWidth of samples from the source row buffer into the dest. row buffer
        // note: we can scale up or down
        //
        long runx = 0;
        for( int x = 0 ; x < DstWidth ; x++ )
        {
            m_pDestRowBuffer[x] = m_pRowBuffer[runx>>16];

            // move to the next (source row index << 16)
            runx += width_divider;
        }

        pOut->OverArrayAndMove( m_pRowBuffer, m_pDestRowBuffer, DstWidth );
    }

    long t2 = timeGetTime( );

    long t3 = t2 - t1;

    return hr;
}


STDMETHODIMP CDxtCompositor::get_OffsetX(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nDstX;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_OffsetX(long newVal)
{
    m_nDstX = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_OffsetY(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nDstY;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_OffsetY(long newVal)
{
    m_nDstY = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_Width(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nDstWidth;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_Width(long newVal)
{
    m_nDstWidth = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_Height(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nDstHeight;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_Height(long newVal)
{
    m_nDstHeight = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_SrcOffsetX(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nSrcX;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_SrcOffsetX(long newVal)
{
    // don't check for values out of range here, do it in the effect loop
    m_nSrcX = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_SrcOffsetY(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nSrcY;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_SrcOffsetY(long newVal)
{
    // don't check for values out of range here, do it in the effect loop
    m_nSrcY = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_SrcWidth(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nSrcWidth;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_SrcWidth(long newVal)
{
    // don't check for values out of range here, do it in the effect loop
    m_nSrcWidth = newVal;
    return NOERROR;
}

STDMETHODIMP CDxtCompositor::get_SrcHeight(long *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nSrcHeight;
    return S_OK;
}

STDMETHODIMP CDxtCompositor::put_SrcHeight(long newVal)
{
    // don't check for values out of range here, do it in the effect loop
    m_nSrcHeight = newVal;
    return NOERROR;
}


//-----------------------------------------------------------
// private methods

// CDxtCompositor::PerformBoundsCheck()
// This assumes that both input and output surfaces have the same size
// i.e. single params for width and height
HRESULT
CDxtCompositor::PerformBoundsCheck(long lWidth, long lHeight)
{
    // if anything is out of bounds, then fail out
    if( (m_nDstX < 0)
        || (m_nDstY < 0)
        || (m_nDstX >= lWidth)
        || (m_nDstY >= lHeight)
        || (m_nDstWidth <= 0)
        || (m_nDstHeight <= 0)
        || (m_nDstX + m_nDstWidth > lWidth)
        || (m_nDstY + m_nDstHeight > lHeight)
        || (m_nSrcX < 0)
        || (m_nSrcY < 0)
        || (m_nSrcX >= lWidth)
        || (m_nSrcY >= lHeight)
        || (m_nSrcWidth <= 0)
        || (m_nSrcHeight <= 0)
        || (m_nSrcX + m_nSrcWidth > lWidth)
        || (m_nSrcY + m_nSrcHeight > lHeight) )
    {
        return E_FAIL;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\black\prop.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: prop.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

//
//prop.cpp
//

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "black.h"
#include "resource.h"

// *
// * CGenVidProperties
// *


//
// CreateInstance
//
CUnknown *CGenVidProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CGenVidProperties(lpunk, phr);
    if (punk == NULL)
    {
	*phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CGenVidProperties::Constructor
//
CGenVidProperties::CGenVidProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("GenBlkVid Property Page"),pUnk,
        IDD_GenVid, IDS_TITLE)
    , m_pGenVid(NULL)
    , m_pDexter(NULL)
    , m_pCBlack(NULL)
    , m_bIsInitialized(FALSE)
{
}


//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CGenVidProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
}


INT_PTR CGenVidProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
	    //start time
	    SetDlgItemInt(hwnd, IDC_START, (int)(m_rtStartTime / 10000),FALSE);
	
	    //frame rate
	    SetDlgItemInt(hwnd, IDC_FRAMERATE, (int)(m_dOutputFrmRate * 100), FALSE);
	
	    //width
	    SetDlgItemInt(hwnd, IDC_VIDWIDTH, (int)(m_biWidth), FALSE);
	
	    //height
	    SetDlgItemInt(hwnd, IDC_VIDHEIGHT, (int)(m_biHeight), FALSE);

	    //biBitCount
	    SetDlgItemInt(hwnd, IDC_BITCOUNT, (int)(m_biBitCount), FALSE);

	    //duration
	    SetDlgItemInt(hwnd, IDC_DURATION, (int)(m_rtDuration/ 10000), FALSE);

	    // bit 31	    |		|	|     0
	//	    Alph    |	Red	|Green	|Blue

	    //Color B
	    SetDlgItemInt(hwnd, IDC_COLOR_B, (int)(m_dwRGBA & 0xff), FALSE);

	    //Color G
	    SetDlgItemInt(hwnd, IDC_COLOR_G, (int)((m_dwRGBA >> 8) & 0xff), FALSE);

	    //Color R
	    SetDlgItemInt(hwnd, IDC_COLOR_R, (int)((m_dwRGBA >> 16) & 0xff), FALSE);

	    //Color A
	    SetDlgItemInt(hwnd, IDC_COLOR_A, (int)((m_dwRGBA >> 24) & 0xff), FALSE);


            return (LRESULT) 1;
        }
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
            return (LRESULT) 1;
        }
    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}

HRESULT CGenVidProperties::OnConnect(IUnknown *pUnknown)
{

    ASSERT(m_pGenVid == NULL);
    ASSERT(m_pDexter == NULL);
    ASSERT(m_pCBlack == NULL);
    HRESULT hr = pUnknown->QueryInterface(IID_IGenVideo, (void **) &m_pGenVid);
    if (FAILED(hr)) {
	return E_NOINTERFACE;
    }
    hr = pUnknown->QueryInterface(IID_IDexterSequencer, (void **) &m_pDexter);
    if (FAILED(hr)) {
	return E_NOINTERFACE;
    }

    m_pCBlack = static_cast<CBlkVidStream*>( m_pDexter );
    if (m_pCBlack == NULL) {
	return E_NOINTERFACE;
    }
    m_pCBlack->AddRef();

    ASSERT(m_pGenVid);
    ASSERT(m_pDexter);
    ASSERT(m_pCBlack);

    // get init data

    //get FrmRate
    m_pDexter->get_OutputFrmRate( &m_dOutputFrmRate );

    //get width, height and bitCoutn
    AM_MEDIA_TYPE mt;
    ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE));
    mt.pbFormat = (BYTE *)QzTaskMemAlloc(SIZE_PREHEADER +
						sizeof(BITMAPINFOHEADER));
    mt.cbFormat = SIZE_PREHEADER + sizeof(BITMAPINFOHEADER);
    ZeroMemory(mt.pbFormat, mt.cbFormat);

    m_pDexter->get_MediaType(&mt);

    m_biWidth = HEADER(mt.pbFormat)->biWidth;
    m_biHeight = HEADER(mt.pbFormat)->biHeight;
    m_biBitCount = HEADER(mt.pbFormat)->biBitCount;

    //get starttime/duration
    m_rtStartTime = m_pCBlack->m_rtStartTime;
    m_rtDuration = m_pCBlack->m_rtDuration;

    //get Color
    m_pGenVid->get_RGBAValue( &m_dwRGBA );

    m_bIsInitialized = FALSE ;

    return NOERROR;
}

HRESULT CGenVidProperties::OnDisconnect()
{
    // Release the interface

    if (m_pGenVid)
        m_pGenVid->Release();
    m_pGenVid = NULL;
    if (m_pDexter)
        m_pDexter->Release();
    m_pDexter = NULL;
    if (m_pCBlack)
        m_pCBlack->Release();
    m_pCBlack = NULL;
    return NOERROR;
}


// We are being activated

HRESULT CGenVidProperties::OnActivate()
{
    m_bIsInitialized = TRUE;
    return NOERROR;
}


// We are being deactivated

HRESULT CGenVidProperties::OnDeactivate(void)
{
    // remember present effect level for next Activate() call

    GetFromDialog();
    return NOERROR;
}

//
// get data from Dialog

STDMETHODIMP CGenVidProperties::GetFromDialog(void)
{
    int n;

    //get start time
    m_rtStartTime = GetDlgItemInt(m_Dlg, IDC_START, NULL, FALSE);
    m_rtStartTime *= 10000;

    //get frame rate
    n = GetDlgItemInt(m_Dlg, IDC_FRAMERATE, NULL, FALSE);
    m_dOutputFrmRate = (double)(n / 100.);

    //Video Width
    m_biWidth = GetDlgItemInt(m_Dlg, IDC_VIDWIDTH, NULL, FALSE);

    // Video Height
    m_biHeight = GetDlgItemInt(m_Dlg, IDC_VIDHEIGHT, NULL, FALSE);

    // bitCount
    m_biBitCount = (WORD) GetDlgItemInt(m_Dlg, IDC_BITCOUNT, NULL, FALSE);

    // duration
    m_rtDuration = GetDlgItemInt(m_Dlg, IDC_DURATION, NULL, FALSE);
    m_rtDuration *= 10000;

    // bit 31	    |		|	|     0
    //	    Alph    |	Red	|Green	|Blue

    // Color B
    m_dwRGBA = GetDlgItemInt(m_Dlg, IDC_COLOR_B, NULL, FALSE);

    // Color G
    m_dwRGBA |=(  GetDlgItemInt(m_Dlg, IDC_COLOR_G, NULL, FALSE)  <<8 );

    // Color R
    m_dwRGBA |=(  GetDlgItemInt(m_Dlg, IDC_COLOR_R, NULL, FALSE)  <<16 );

    // Color A
    m_dwRGBA |=(  GetDlgItemInt(m_Dlg, IDC_COLOR_A, NULL, FALSE)  <<32 );


    // cehck if all data is valid
    if( (   (m_biBitCount ==16)  ||
	    (m_biBitCount ==24)  ||
	    (m_biBitCount ==32)
	)
	&& (m_rtDuration>=0)
       )	
	return NOERROR;
    else
	return E_FAIL;
}


HRESULT CGenVidProperties::OnApplyChanges()
{
    GetFromDialog();

    HRESULT hr=NOERROR;

    m_bDirty  = FALSE; // the page is now clean

    // set Frame rate
    double dw;
    m_pDexter->get_OutputFrmRate(&dw);

    if(dw != m_dOutputFrmRate )
	hr= m_pDexter->put_OutputFrmRate( m_dOutputFrmRate );

    if(hr==NOERROR)
    {	
	// set Width, Height, andd BitCount
	AM_MEDIA_TYPE mt;
	m_pDexter->get_MediaType( &mt);

	if(    (HEADER(mt.pbFormat)->biWidth    != m_biWidth)
	    || (HEADER(mt.pbFormat)->biHeight   != m_biHeight)
	    || (HEADER(mt.pbFormat)->biBitCount != m_biBitCount) )
	{

	    HEADER(mt.pbFormat)->biWidth    = m_biWidth;
	    HEADER(mt.pbFormat)->biHeight   = m_biHeight;
	    HEADER(mt.pbFormat)->biBitCount = m_biBitCount;
	    HEADER(mt.pbFormat)->biSizeImage = DIBSIZE(*HEADER(mt.pbFormat));

	    hr=m_pDexter->put_MediaType( &mt);
	}

	if(hr ==NOERROR )
	{	
	    m_pCBlack->m_rtStartTime = m_rtStartTime;
	    m_pCBlack->m_rtDuration = m_rtDuration;

	    //set Color
	    hr = m_pGenVid->put_RGBAValue( m_dwRGBA );
	}
    }

    if(hr!=NOERROR)
	return E_FAIL;
    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\comp\alpha.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: alpha.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtAlphaSetter.cpp : Implementation of CDxtAlphaSetter
#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "Comp.h"

/////////////////////////////////////////////////////////////////////////////
// CDxtAlphaSetter

CDxtAlphaSetter::CDxtAlphaSetter( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 1;
    m_ulNumInRequired = 1;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
    m_nAlpha = -1;
    m_dAlphaRamp = -1.0;
}

CDxtAlphaSetter::~CDxtAlphaSetter( )
{
}

HRESULT CDxtAlphaSetter::OnSetup( DWORD dwFlags )
{
    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    return NOERROR;
}

HRESULT CDxtAlphaSetter::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 1;
    m_ulNumInRequired = 1;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
    m_nAlpha = -1;
    m_dAlphaRamp = -1.0;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CDxtAlphaSetter::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;

    //--- Get input sample access pointer for the requested region.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> pInput;
    hr = InputSurface( 0 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInput, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Allocate a working buffer
    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // allocate a scratch buffer fer us
    //
    DXSAMPLE *pOverlayBuffer = DXSAMPLE_Alloca( Width );

    // no dithering
    //
    if (DoDither())
    {
        return 0;
    }

    if( m_nAlpha >= 0 && m_dAlphaRamp >= 0.0 )
    {
        return E_INVALIDARG;
    }

    float Percent = 1.0;
    get_Progress( &Percent );

    BYTE a = (BYTE) m_nAlpha;
    for( unsigned long OutY = 0 ; OutY < Height ; ++OutY )
    {
        pInput->MoveToRow( OutY );
        pOut->MoveToRow( OutY );

        pInput->Unpack( pOverlayBuffer, Width, FALSE );

        if( m_nAlpha >= 0 )
        {
            for( int i = Width - 1 ; i >= 0 ; i-- )
            {
                pOverlayBuffer[i].Alpha = a;
            }
        }
        else
        {
            for( int i = Width - 1 ; i >= 0 ; i-- )
            {
                pOverlayBuffer[i].Alpha = BYTE( double( pOverlayBuffer[i].Alpha ) * m_dAlphaRamp );
            }
        }

        pOut->PackAndMove( pOverlayBuffer, Width );
    }

    return hr;
}

HRESULT CDxtAlphaSetter::put_Alpha( long Alpha )
{
    m_nAlpha = Alpha;
    return NOERROR;
}

HRESULT CDxtAlphaSetter::get_Alpha( long * pAlpha )
{
    CheckPointer( pAlpha, E_POINTER );
    *pAlpha = m_nAlpha;
    return NOERROR;
}

HRESULT CDxtAlphaSetter::put_AlphaRamp( double Alpha )
{
    m_dAlphaRamp = Alpha;
    return NOERROR;
}

HRESULT CDxtAlphaSetter::get_AlphaRamp( double * pAlpha )
{
    CheckPointer( pAlpha, E_POINTER );
    *pAlpha = m_dAlphaRamp;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\comp\comp.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: comp.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtCompositor.h : Declaration of the CDxtCompositor

#ifndef __DxtCompositor_H_
#define __DxtCompositor_H_

#ifndef DTBase_h
    #include <DTBase.h>
#endif

#include <qeditint.h>
#include <qedit.h>
#include "resource.h"       // main symbols

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

/////////////////////////////////////////////////////////////////////////////
// CDxtCompositor
class ATL_NO_VTABLE CDxtCompositor :
    public CDXBaseNTo1,
    public CComCoClass<CDxtCompositor, &CLSID_DxtCompositor>,
    public CComPropertySupport<CDxtCompositor>, // property support
    public IDispatchImpl<IDxtCompositor, &IID_IDxtCompositor, &LIBID_DexterLib>
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    long m_nSurfaceWidth;
    long m_nSurfaceHeight;
    long m_nDstX;
    long m_nDstY;
    long m_nDstWidth;
    long m_nDstHeight;
    long m_nSrcX;
    long m_nSrcY;
    long m_nSrcWidth;
    long m_nSrcHeight;
    DXPMSAMPLE * m_pRowBuffer;
    DXPMSAMPLE * m_pDestRowBuffer;

    // private methods
    HRESULT PerformBoundsCheck(long lWidth, long lHeigth);


public:
        DECLARE_POLY_AGGREGATABLE(CDxtCompositor)
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_DxtCompositor, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()

	CDxtCompositor();
        ~CDxtCompositor();

//BEGIN_PROP_MAP(CDxtCompositor)
//END_PROP_MAP()

BEGIN_COM_MAP(CDxtCompositor)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
        COM_INTERFACE_ENTRY(IDXEffect)
	COM_INTERFACE_ENTRY(IDxtCompositor)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

	SIZE m_sizeExtent;  //current extents in himetric

BEGIN_PROPERTY_MAP(CDxtCompositor)
    PROP_ENTRY("OffsetX",           1, CLSID_NULL)
    PROP_ENTRY("OffsetY",           2, CLSID_NULL)
    PROP_ENTRY("Width",             3, CLSID_NULL)
    PROP_ENTRY("Height",            4, CLSID_NULL)
    PROP_ENTRY("SrcOffsetX",        5, CLSID_NULL)
    PROP_ENTRY("SrcOffsetY",        6, CLSID_NULL)
    PROP_ENTRY("SrcWidth",          7, CLSID_NULL)
    PROP_ENTRY("SrcHeight",         8, CLSID_NULL)
    PROP_PAGE(CLSID_NULL)
END_PROPERTY_MAP()

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );

// IDxtCompositor
public:
	STDMETHOD(get_Height)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Height)(/*[in]*/ long newVal);
	STDMETHOD(get_Width)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Width)(/*[in]*/ long newVal);
	STDMETHOD(get_OffsetY)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_OffsetY)(/*[in]*/ long newVal);
	STDMETHOD(get_OffsetX)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_OffsetX)(/*[in]*/ long newVal);

        STDMETHOD(get_SrcHeight)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SrcHeight)(/*[in]*/ long newVal);
	STDMETHOD(get_SrcWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SrcWidth)(/*[in]*/ long newVal);
	STDMETHOD(get_SrcOffsetY)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SrcOffsetY)(/*[in]*/ long newVal);
	STDMETHOD(get_SrcOffsetX)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SrcOffsetX)(/*[in]*/ long newVal);
};

/////////////////////////////////////////////////////////////////////////////
// CDxtAlphaSetter
class ATL_NO_VTABLE CDxtAlphaSetter :
    public CDXBaseNTo1,
    public CComCoClass<CDxtAlphaSetter, &CLSID_DxtAlphaSetter>,
    public IDispatchImpl<IDxtAlphaSetter, &IID_IDxtAlphaSetter, &LIBID_DexterLib>,
    public CComPropertySupport<CDxtCompositor> // property support
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;
    long m_nAlpha;
    double m_dAlphaRamp;

public:
        DECLARE_POLY_AGGREGATABLE(CDxtAlphaSetter)
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_DxtAlphaSetter, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()

	CDxtAlphaSetter();
        ~CDxtAlphaSetter();

BEGIN_PROPERTY_MAP(CDxtCompositor)
    PROP_ENTRY("Alpha",           1, CLSID_NULL)
    PROP_ENTRY("AlphaRamp",       2, CLSID_NULL)
END_PROPERTY_MAP()

BEGIN_COM_MAP(CDxtAlphaSetter)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
        COM_INTERFACE_ENTRY(IDXEffect)
	COM_INTERFACE_ENTRY(IDxtAlphaSetter)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );

// IDxtAlphaSetter
public:
    STDMETHODIMP get_Alpha(long *pVal);
    STDMETHODIMP put_Alpha(long newVal);
    STDMETHODIMP get_AlphaRamp(double *pVal);
    STDMETHODIMP put_AlphaRamp(double newVal);
};

#endif //__DxtCompositor_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\comp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DxtCompositorDll.rc
//
#define IDS_PROJNAME                         1605
#define IDR_DxtCompositor                    1600
#define IDS_TITLEDxtCompositorPP             1601
#define IDS_HELPFILEDxtCompositorPP          1602
#define IDS_DOCSTRINGDxtCompositorPP         1603
#define IDR_DxtAlphaSetter                   1604

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1606
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\comp\stdafx.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stdafx.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _ATL_APARTMENT_THREADED
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
//#define _WIN32_WINNT 0x0400
//#define _ATL_APARTMENT_THREADED
//#define _ATL_STATIC_REGISTRY

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
//
//  To allow us to compile with warning level 4, we need to disable
//  three warnings that ATLCTL generates at this warning level.
//
#pragma warning(disable: 4510 4610 4100)
#include <atlctl.h>
#pragma warning(default: 4510 4610 4100)
#include <DXTmpl.h>
#include <streams.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\common.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: common.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED
//#define _ATL_STATIC_REGISTRY
#ifndef _USRDLL
#define _USRDLL
#endif

#include <atlbase.h>
extern CComModule _Module;;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\vidfx1.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: vidfx1.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "vidfx1.h"
#include <initguid.h>

DEFINE_GUID(CLSID_VideoEffects1Rejects, 0xcc7bfb46, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);

// we make 2 registry keys that the DXTWrapper will use to get what effect to
// use... the effect guid, and how many input pins to expose
const TCHAR g_szGUIDBag[] = TEXT("guid");
const TCHAR g_szInputsBag[] = TEXT("inputs");
TCHAR g_szReject[] = TEXT("Software\\Microsoft\\ActiveMovie");

CVidFX1ClassManager::CVidFX1ClassManager() :
	// value of this key is given to me in MatchString
        CClassManagerBase(g_szGUIDBag),
	m_cFX(0),
        m_hD3DRMCreate(NULL),
        m_pfnDirect3DRMCreate(NULL)
{
    DbgLog((LOG_TRACE,1,TEXT("Video Effects 1 Constructor")));

    // so we don't have to link to d3drm.dll
    //
    // GetProcAddress only takes a char
    const char sz_Direct3DRMCreate[] = "Direct3DRMCreate";
    if(m_hD3DRMCreate = LoadLibrary(TEXT("d3drm.dll")))
    {
        m_pfnDirect3DRMCreate = (PD3DRMCreate)GetProcAddress(m_hD3DRMCreate,
						sz_Direct3DRMCreate);
        if(m_pfnDirect3DRMCreate == 0) {
            DWORD dwLastError = GetLastError();
            FreeLibrary(m_hD3DRMCreate);
            m_hD3DRMCreate = 0;
            // !!! *phr = HRESULT_FROM_WIN32(dwLastError);
	    return;
        }
    } else {
        DWORD dwLastError = GetLastError();
        // !!! *phr = HRESULT_FROM_WIN32(dwLastError);
	return;
    }

}

CVidFX1ClassManager::~CVidFX1ClassManager()
{
    DbgLog((LOG_TRACE,1,TEXT("Video Effects 1 Destructor")));
    for (ULONG i = 0; i < m_cFX; i++) {
	CoTaskMemFree(m_rgFX[i]->wszDescription);
	delete m_rgFX[i];
    }
    if (m_hD3DRMCreate) {
        FreeLibrary(m_hD3DRMCreate);
    }
}

HRESULT CVidFX1ClassManager::ReadLegacyDevNames()
{
    DbgLog((LOG_TRACE,1,TEXT("FX1: ReadLegacyDevNames")));

    // fills m_rgFX and sets m_cFX
    InitializeEffectList();

    m_cNotMatched = m_cFX;
    return S_OK;
}

BOOL CVidFX1ClassManager::MatchString(const TCHAR *szDevName)
{
    DbgLog((LOG_TRACE,3,TEXT("FX1: MatchString %s"), szDevName));
    USES_CONVERSION;
    for (UINT i = 0; i < m_cFX; i++)
    {
        GUID guid;
	CLSIDFromString((WCHAR *) T2CW(szDevName), &guid);
        if (guid == m_rgFX[i]->guid)
        {
    	    DbgLog((LOG_TRACE,3,TEXT("MATCHED")));
            return TRUE;
        }

    }
    DbgLog((LOG_TRACE,3,TEXT("NOT MATCHED")));
    return FALSE;
}

HRESULT CVidFX1ClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    DbgLog((LOG_TRACE,1,TEXT("FX1: CreateRegKeys")));

    ResetClassManagerKey(CLSID_VideoEffects1Category);
    USES_CONVERSION;
    HRESULT hr = S_OK;

    ReadLegacyDevNames();
    for (UINT i = 0; i < m_cFX; i++)
    {
        WCHAR wszUniq[120];
	StringFromGUID2(m_rgFX[i]->guid, wszUniq, 120);

        DWORD dwFlags = 0;

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = 0;
        rf2.rgPins = NULL;

        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_DXTWrap,
	    // friendly name presented to user
            m_rgFX[i]->wszDescription,
            &pMoniker,
            &CLSID_VideoEffects1Category,
	    // effect GUID is the unique identifier
            wszUniq,
            &rf2);
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(wszUniq);
                if(var.bstrVal) {
                    hr = pPropBag->Write(T2CW(g_szGUIDBag), &var);
                    SysFreeString(var.bstrVal);
                } else {
                    hr = E_OUTOFMEMORY;
                }
		if (hr == S_OK) {
                    var.vt = VT_I4;
                    var.lVal = 1;	// I am a 1 input effect
                    hr = pPropBag->Write(T2CW(g_szInputsBag), &var);
		}

                pPropBag->Release();
            }
            pMoniker->Release();
        }
	if (FAILED(hr))
	    break;
    }
    return hr;
}


HRESULT CVidFX1ClassManager::AddClassToList(HKEY hkClsIdRoot, CLSID &clsid, ULONG Index)
{
    USES_CONVERSION;
    OLECHAR wszGUID[MAX_PATH];
    StringFromGUID2(clsid, wszGUID, MAX_PATH);
    TCHAR *szTcharGUID = W2T(wszGUID);

    m_rgFX[Index] = new FXGuid;
    if (m_rgFX[Index] == NULL)
    {
        return E_OUTOFMEMORY;
    }
    long cbSizeW = _MAX_PATH * sizeof(WCHAR);
// SEC: check return code
    m_rgFX[Index]->wszDescription = (LPWSTR)CoTaskMemAlloc(cbSizeW);
    m_rgFX[Index]->wszDescription[0] = 0;
    TCHAR szDesc[_MAX_PATH];
    long cbSize = sizeof(szDesc); // sec: correct
// SEC: Registery
    LONG rrv = RegQueryValue(hkClsIdRoot, szTcharGUID, szDesc, &cbSize);
    if (rrv == ERROR_SUCCESS) {
	// sec: safe, szDesc cannot be bigger than MAXPATH which is the size of wszDescription too.
	lstrcpyW(m_rgFX[Index]->wszDescription, T2W(szDesc));
   	DbgLog((LOG_TRACE,1,TEXT("%S"), m_rgFX[Index]->wszDescription));
    }
    // okay to not check the value from RegQueryXXX since all it's doing
    // is filling in the description
    m_rgFX[Index]->guid = (GUID)clsid;
    m_cFX++;
    return S_OK;
}


HRESULT CVidFX1ClassManager::AddCatsToList(ICatInformation *pCatInfo, const GUID &catid)
{
#include "..\..\..\pnp\devenum\util.h"
#define NUM_GUIDS 10	// 10 types of inputs allowed per effect
    USES_CONVERSION;
    IEnumCLSID *pEnumCLSID;
    GUID aguid[NUM_GUIDS];
    ULONG cguid;

    HRESULT hr = pCatInfo->EnumClassesOfCategories(1, (GUID *)&catid,
						0, NULL, &pEnumCLSID);
    if (FAILED(hr)) {
   	DbgLog((LOG_ERROR,1,TEXT("No effects in this category at all")));
	return hr;
    }

    HKEY hkClsIdRoot;
// SEC: Registery
    if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &hkClsIdRoot) != ERROR_SUCCESS)
    {
        DbgLog((LOG_ERROR,1,TEXT("Failed to open CLSID registry key")));
        pEnumCLSID->Release();
        return E_OUTOFMEMORY;
    }

    // go through all the effects in the system
    while (1) {
        ULONG ulUsed;
	GUID guid[25];
	ulUsed = 0;
        hr = pEnumCLSID->Next(25, guid, &ulUsed);
	if (FAILED(hr) || ulUsed == 0) {
	    break;
	}
	while (ulUsed-- > 0) {
   	    DbgLog((LOG_TRACE,3,TEXT("Found a possible effect...")));

	    // If this clsid is already in the category, we don't need to query
	    // it and waste countless hours. some DXTs can take 700ms each to
	    // create and query!!

    	    HKEY hk;
    	    OLECHAR szReg[MAX_PATH];
	    // sec: safe, szReg is big enough
	    lstrcpyW(szReg, T2W(g_szCmRegPath));
    	    OLECHAR szGUID[MAX_PATH];
    	    StringFromGUID2(CLSID_VideoEffects1Category, szGUID,
							MAX_PATH);
    	    lstrcatW(szReg, L"\\"); // safe
    	    lstrcatW(szReg, szGUID); // safe
    	    lstrcatW(szReg, L"\\"); // safe
    	    StringFromGUID2(guid[ulUsed], szGUID, MAX_PATH);
    	    lstrcatW(szReg, szGUID); // safe
    	    TCHAR *TszReg = W2T(szReg);
    	    TCHAR XX[_MAX_PATH];
	    // SEC: need to init XX[0] to 0
// SEC: Registery
    	    long rrv = RegOpenKey(g_hkCmReg, TszReg, &hk);
	    if (rrv == ERROR_SUCCESS) {
	        DWORD cb = sizeof(XX);
// SEC: Registery
    	        rrv = RegQueryValueEx(hk, TEXT("FriendlyName"), NULL, NULL,
						(BYTE *)XX, &cb);
// SEC: Registery
    	        RegCloseKey(hk);
	        if (rrv == ERROR_SUCCESS) {
    	    	    m_rgFX[m_cFX] = new FXGuid;
		    if (m_rgFX[m_cFX] == NULL) {
		        return E_OUTOFMEMORY;
		    }
    	    	    long cbSizeW = _MAX_PATH * sizeof(WCHAR);
    	    	    m_rgFX[m_cFX]->wszDescription =
						(LPWSTR)CoTaskMemAlloc(cbSizeW);
	    	    if (m_rgFX[m_cFX]->wszDescription == NULL) {
		        return E_OUTOFMEMORY;
	    	    }
		    // safe copy, since XX is bounded to max_path by now
                    // sec: unsafe, use bounded string function
    	    	    lstrcpyW(m_rgFX[m_cFX]->wszDescription, T2W(XX));
    	    	    m_rgFX[m_cFX]->guid = (GUID)guid[ulUsed];
    	    	    m_cFX++;
    	            DbgLog((LOG_TRACE,2,TEXT("Found in Registry: Saved making it!")));
		    continue;
	        }
	    }

	    // If this clsid is already in the reject registry, we've tried it
	    // and know it doesn't belong. Don't waste up to 800ms creating it!
	    // !!! If I was a good citizen, unregistering would delete this key

// SEC: Registery
    	    RegOpenKey(HKEY_CURRENT_USER, g_szReject, &hk);
	    if (hk) {
    	        StringFromGUID2(CLSID_VideoEffects1Rejects, szReg,
								MAX_PATH);
    	        lstrcatW(szReg, L"\\"); // safe
    	        StringFromGUID2(guid[ulUsed], szGUID, MAX_PATH);
    	        lstrcatW(szReg, szGUID); // safe
    	        TszReg = W2T(szReg);
	        long cb = sizeof(XX);
// SEC: Registery
    	        rrv = RegQueryValue(hk, TszReg, XX, &cb);
// SEC: Registery
    	        RegCloseKey(hk);
	        if (rrv == ERROR_SUCCESS) {
    	            DbgLog((LOG_TRACE,2,TEXT("Found in REJECT Registry: Saved making it!")));
		    continue;
	        }
	    }

	    IDXTransform *pDXT;
    	    hr = CoCreateInstance(guid[ulUsed], NULL, CLSCTX_INPROC,
					IID_IDXTransform, (void **)&pDXT);
	    if (hr == S_OK) {
		DWORD dw;
		// find out about input pin #0
    		cguid = NUM_GUIDS;
		hr = pDXT->GetInOutInfo(FALSE, 0, &dw, aguid, &cguid, NULL);
		if (hr == S_OK) {
		    // make sure it can accept a 2D surface input
		    for (ULONG j = 0; j < cguid; j++) {
		        if (IsEqualGUID(aguid[j], IID_IDXSurface))
			    break;
		    }
		    if (j < cguid) {
			// find out about input pin #1
			cguid = NUM_GUIDS;
		        hr = pDXT->GetInOutInfo(FALSE, 1, &dw, aguid,
						&cguid, NULL);
			// if there is no pin 1, or it's optional, this is a
			// 1 input effect
		        if (hr == S_FALSE || (hr == S_OK &&
						(dw & DXINOUTF_OPTIONAL))) {
   	    	            DbgLog((LOG_TRACE,2,TEXT("This can operate with 1 2D input")));
                            AddClassToList(hkClsIdRoot, guid[ulUsed], m_cFX);
			} else {
   	    	            DbgLog((LOG_TRACE,3,TEXT("REJECT: needs 2 inputs")));
		    	    AddToRejectList(guid[ulUsed]);
			}
		    } else {
   	    	        DbgLog((LOG_TRACE,3,TEXT("REJECT: 3D only")));
		    	AddToRejectList(guid[ulUsed]);
		    }
		} else {
		    DbgLog((LOG_TRACE,3,TEXT("REJECT: Can't get pin info")));
		    AddToRejectList(guid[ulUsed]);
		}

		pDXT->Release();
	    } else {
		DbgLog((LOG_TRACE,3,TEXT("REJECT: Can't create it")));
		AddToRejectList(guid[ulUsed]);
	    }
	}
    }

    pEnumCLSID->Release();
// SEC: Registery
    RegCloseKey(hkClsIdRoot);

    return hr;
}


HRESULT CVidFX1ClassManager::AddToRejectList(const GUID &guid)
{
    // Add this CLSID to the reject registry

    USES_CONVERSION;
    HKEY hk;
    OLECHAR szReg[MAX_PATH];
    szReg[0] = 0;
    lstrcatW(szReg, T2W(g_szReject)); // safe
    lstrcatW(szReg, L"\\"); // safe
    OLECHAR szGUIDFX[MAX_PATH];
    StringFromGUID2(CLSID_VideoEffects1Rejects, szGUIDFX, MAX_PATH);
    lstrcatW(szReg, szGUIDFX); // safe
    lstrcatW(szReg, L"\\"); // safe
    StringFromGUID2(guid, szGUIDFX, MAX_PATH);
    lstrcatW(szReg, szGUIDFX); // safe
    TCHAR *TszReg = W2T(szReg);
// SEC: Registery
    RegCreateKey(HKEY_CURRENT_USER, TszReg, &hk);
    if (hk) {
    	DbgLog((LOG_TRACE,3,TEXT("Added to REJECT list")));
// SEC: Registery
        RegCloseKey(hk);
	return NOERROR;
    } else {
    	DbgLog((LOG_TRACE,3,TEXT("ERROR: Can't add to REJECT list")));
	return E_OUTOFMEMORY;
    }
}


HRESULT CVidFX1ClassManager::InitializeEffectList()
{

    // already done
    if (m_cFX)
	return S_OK;

    // You need DXF6 (Chrome 1.0, Win98SP1, or NT5) to get 3D effects
    // !!! After installing DX6, make sure this code runs again!
    m_f3DSupported = FALSE;
    IDirect3DRM *pD3DRM;
    IDirect3DRM3 *pD3DRM3;
    HRESULT hr = m_pfnDirect3DRMCreate(&pD3DRM);
    if (hr == NOERROR) {
	hr = pD3DRM->QueryInterface(IID_IDirect3DRM3, (void **)&pD3DRM3);
	pD3DRM->Release();
        if (hr == NOERROR) {
            DbgLog((LOG_TRACE,1,TEXT("***This OS supports 3D transforms")));
	    pD3DRM3->Release();
	    m_f3DSupported = TRUE;
        }
    }

    ICatInformation *pCatInfo;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
			CLSCTX_ALL, IID_ICatInformation, (void **)&pCatInfo);
    if (SUCCEEDED(hr)) {
   	DbgLog((LOG_TRACE,1,TEXT("Initializing 1 input 2D effects")));
        hr = AddCatsToList(pCatInfo, CATID_DXImageTransform);
	if (m_f3DSupported) {
   	    DbgLog((LOG_TRACE,1,TEXT("Initializing 1 input 3D effects")));
            hr = AddCatsToList(pCatInfo, CATID_DX3DTransform);
	}
        pCatInfo->Release();
    } else {
   	DbgLog((LOG_ERROR,1,TEXT("There are no effects at all")));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\dxtenum.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxtenum.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\vidfx1.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: vidfx1.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include "dxtrans.h"
#include "..\..\..\pnp\devenum\cmgrbase.h"
#include "common.h"

// !!!
#define MAX_1EFFECTS 100

typedef HRESULT(STDAPICALLTYPE *PD3DRMCreate)(IDirect3DRM **pD3DRM);

class CVidFX1ClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CVidFX1ClassManager,&CLSID_VideoEffects1Category>
{
    struct FXGuid
    {
        GUID guid;
        LPWSTR wszDescription;
    } *m_rgFX[MAX_1EFFECTS];

    ULONG m_cFX;

    BOOL m_f3DSupported;

    // for dynamically linking to D3DRMCreate
    HMODULE m_hD3DRMCreate;
    PD3DRMCreate m_pfnDirect3DRMCreate;

public:

    CVidFX1ClassManager();
    ~CVidFX1ClassManager();

    BEGIN_COM_MAP(CVidFX1ClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CVidFX1ClassManager) ;
    DECLARE_REGISTRY_RESOURCEID(IDR_REGISTRY);
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
    BOOL CheckForOmittedEntries() { return FALSE; }

    HRESULT AddClassToList(HKEY hkClsIdRoot, CLSID &clsid, ULONG Index);
    HRESULT AddCatsToList(ICatInformation *pCatInfo, const GUID &catid);
    HRESULT InitializeEffectList();
    HRESULT AddToRejectList(const GUID &guid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\vidfx2.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: vidfx2.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include "dxtrans.h"
#include "..\..\..\pnp\devenum\cmgrbase.h"
#include "common.h"

// !!!
#define MAX_2EFFECTS 100

typedef HRESULT(STDAPICALLTYPE *PD3DRMCreate)(IDirect3DRM **pD3DRM);

class CVidFX2ClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CVidFX2ClassManager,&CLSID_VideoEffects2Category>
{
    struct FXGuid
    {
        GUID guid;
        LPWSTR wszDescription;
    } *m_rgFX[MAX_2EFFECTS];

    ULONG m_cFX;

    BOOL m_f3DSupported;

    // for dynamically linking to D3DRMCreate
    HMODULE m_hD3DRMCreate;
    PD3DRMCreate m_pfnDirect3DRMCreate;

public:

    CVidFX2ClassManager();
    ~CVidFX2ClassManager();

    BEGIN_COM_MAP(CVidFX2ClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CVidFX2ClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
    BOOL CheckForOmittedEntries() { return FALSE; }

    HRESULT AddClassToList(HKEY hkClsIdRoot, CLSID &clsid, ULONG Index);
    HRESULT AddCatsToList(ICatInformation *pCatInfo, const GUID &catid);
    HRESULT InitializeEffectList();
    HRESULT AddToRejectList(const GUID &guid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\dxtwrap\dxt.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxt.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

/*

This filter wraps DirectX Transforms.  It has the DXT take the bits we receive
and do the transform, and output its bits right into the buffer we deliver
downstream (no extra data copies).

It can host 1 input or 2 input DXTs.  It can host multiple at a time.

For 1 input:  it can host any number of them, each with its own lifetime.  If
these times overlap, it will perform all the effects in sequence.

For 2 input:  it can host any number of them at different times, as long as
the times don't overlap.  (It can be a different DXT at different times)

*/


//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>

// you MUST include these IID's BEFORE including qedit.h because it includes
// these header files and when ddraw.h is included BEFORE encountering an
// <initguid.h>, it will not be included the second time and you will not
// be able to link
//

#include <qeditint.h>
#include <qedit.h>
#include <dxbounds.h>
#include "dxt.h"
#include "..\..\util\filfuncs.h"
#include "..\..\util\dexmisc.h"

const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Video,        // Major CLSID
    &MEDIASUBTYPE_NULL       // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",             // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypes },       // Pin information
    { L"Output",           // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes }       // Pin information
};

const AMOVIESETUP_FILTER sudDXTWrap =
{
    &CLSID_DXTWrap,       // CLSID of filter
    L"DirectX Transform Wrapper",          // Filter's name
    MERIT_DO_NOT_USE,       // Filter merit
    2,                      // Number of pins
    psudPins                // Pin information
};

// Using this pointer in constructor
#pragma warning(disable:4355)

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CDXTWrap::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CDXTWrap(NAME("DirectX Transform Wrapper"), pUnk, phr);
}

// ================================================================
// CDXTWrap Constructor
// ================================================================

CDXTWrap::CDXTWrap(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_pQHead(NULL),	// no queued effects
    m_cInputs(0),	// no pins
    m_cOutputs(0),
    m_punkDXTransform(NULL),
    m_pDXTransFact(NULL),
    m_pTempBuffer(NULL),
    m_DefaultEffect( GUID_NULL ),
    // DXTMode means we were created by choosing a specific effect from one of
    // the effects categories.  In this mode, we are always this effect, and we
    // have a property page.  Otherwise, we are created empty with no pins and
    // need to be programmed to be useful.
    m_fDXTMode(FALSE),
    CBaseFilter(NAME("DirectX Transform Wrapper"), pUnk, this, CLSID_DXTWrap),
    CPersistStream(pUnk, phr)
{
    ASSERT(phr);

    DbgLog((LOG_TRACE,3,TEXT("CDXTWrap constructor")));
    // do not accept connections until somebody tells us what media type to use
    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE));
    m_mtAccept.majortype = GUID_NULL;
    m_TransCAUUID.cElems = 0;
    m_TransCAUUID.pElems = NULL;
}


//
// Destructor
//
CDXTWrap::~CDXTWrap()
{
    while (m_cInputs--) delete m_apInput[m_cInputs];
    while (m_cOutputs--) delete m_apOutput[m_cOutputs];
    QPARAMDATA *p = m_pQHead, *p2;
    while (p) {
	p2 = p->pNext;
	if (p->Data.pSetter)
	    p->Data.pSetter->Release();
	delete p;
 	p = p2;
    }
    if (m_punkDXTransform)
	m_punkDXTransform->Release();
    if (m_TransCAUUID.pElems)
	CoTaskMemFree(m_TransCAUUID.pElems);
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap destructor")));
    SaferFreeMediaType( m_mtAccept );
}


//
// GetPinCount
//
int CDXTWrap::GetPinCount()
{
    //DbgLog((LOG_TRACE,TRACE_MEDIUM+1,TEXT("GetPinCount = %d"), m_cInputs + m_cOutputs));
    return (m_cInputs + m_cOutputs);
}


//
// GetPin
//
CBasePin *CDXTWrap::GetPin(int n)
{
    //DbgLog((LOG_TRACE,TRACE_MEDIUM+1,TEXT("GetPin(%d)"), n));

    if (n < 0 || n >= m_cInputs + m_cOutputs)
        return NULL ;

    if (n < m_cInputs)
	return m_apInput[n];
    else
	return m_apOutput[n - m_cInputs];
}


// Pause
//
STDMETHODIMP CDXTWrap::Pause()
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::Pause")));

    if (m_cInputs == 0) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("NO PINS - nothing to do")));
	return S_OK;
    }
    int j = 0;
    for (int i = 0; i < m_cInputs; i++) {
	if (m_apInput[i]->IsConnected())
	    j++;
    }
    // if anything is connected, everything better be
    if (j > 0 && j < m_cInputs)
	return VFW_E_NOT_CONNECTED;
    if (j > 0 && !m_apOutput[0]->IsConnected())
 	return VFW_E_NOT_CONNECTED;
    if (j == 0 && m_cOutputs && m_apOutput[0]->IsConnected())
 	return VFW_E_NOT_CONNECTED;

    if (m_State == State_Stopped) {

        // Make a transform factory for our pins to use
        hr = CoCreateInstance(CLSID_DXTransformFactory, NULL, CLSCTX_INPROC,
			IID_IDXTransformFactory, (void **)&m_pDXTransFact);
        if (hr != S_OK) {
            DbgLog((LOG_ERROR,1,TEXT("Error instantiating transform factory")));
	    return hr;
	}

	// Let the pins create their DXSurfaces using the factory
        hr = CBaseFilter::Pause();
	if (FAILED(hr)) {
	    m_pDXTransFact->Release();
	    m_pDXTransFact = NULL;
	    return hr;
	}

        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Pause complete")));
	return NOERROR;
    }

    return CBaseFilter::Pause();
}


// Stop
//
STDMETHODIMP CDXTWrap::Stop()
{
    CAutoLock cObjectLock(m_pLock);
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::Stop")));

    // do this now so future receives will fail, or they will blow up after
    // we free everything
    m_State = State_Stopped;

    // Now, call Inactive on every pin

    HRESULT hr = NOERROR;
    int cPins = GetPinCount();
    for (int c = 0; c < cPins; c++) {
	CBasePin *pPin = GetPin(c);
        if (pPin->IsConnected()) {
            HRESULT hrTmp = pPin->Inactive();
            if (FAILED(hrTmp) && SUCCEEDED(hr)) {
                    hr = hrTmp;
            }
        }
    }

    // all done with these !!! leave them open?
    QPARAMDATA *p = m_pQHead;
    while (p) {
        if (p->pDXT)
	    p->pDXT->Release();
        p->pDXT = NULL;
	p = p->pNext;
    }
    if (m_pDXTransFact)
	m_pDXTransFact->Release();
    m_pDXTransFact = NULL;
    if (m_pTempBuffer)
	QzTaskMemFree(m_pTempBuffer);
    m_pTempBuffer = NULL;

    return hr;
}


// IPersistPropertyBag - This means somebody is creating us by choosing an
// 	effect from one of the effect categories.
//
STDMETHODIMP CDXTWrap::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXTWrap::Load")));

    CAutoLock cObjectLock(m_pLock);
    if(m_State != State_Stopped) {
        return VFW_E_WRONG_STATE;
    }
    if (pPropBag == NULL) {
	return E_INVALIDARG;
    }
    ASSERT(m_pQHead == NULL);
    if (m_pQHead)
	return E_UNEXPECTED;

    GUID guid;
    int  iNumInputs;
    VARIANT var;
    var.vt = VT_BSTR;
    HRESULT hr = pPropBag->Read(L"guid", &var, 0);
    if(SUCCEEDED(hr)) {
	CLSIDFromString(var.bstrVal, &guid);
        SysFreeString(var.bstrVal);
        var.vt = VT_I4;
        HRESULT hr = pPropBag->Read(L"inputs", &var, 0);
        if(SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Entering DXT wrapper Mode...")));

	    // first, we are told how many inputs we have
	    iNumInputs = var.lVal;
	    SetNumInputs(iNumInputs);

	    // by default, the effect lasts for 10 seconds
	    DEXTER_PARAM_DATA dpd;
	    ZeroMemory(&dpd, sizeof(dpd));
	    dpd.rtStart = 0;
	    dpd.rtStop = 10*UNITS;
	    dpd.fSwapInputs = FALSE;
	    hr = QParamData(0, MAX_TIME, guid, NULL, &dpd);
	    if (FAILED(hr)) {
        	DbgLog((LOG_ERROR,1,TEXT("*** ??? Bad Effect ???")));
		return hr;
	    }

	    // we need to keep this effect created for all time, so the property
	    // pages will work.
    	    hr = CoCreateInstance(guid, (IUnknown *)(IBaseFilter *)this,
		CLSCTX_INPROC, IID_IUnknown, (void **)&m_punkDXTransform);
	    if (FAILED(hr)) {
        	DbgLog((LOG_ERROR,1,TEXT("*** Can't create effect")));
		return hr;
	    }

	    // we provide a property page to set more reasonable level/durations
    	    ISpecifyPropertyPages *pSPP;
    	    hr = m_punkDXTransform->QueryInterface(IID_ISpecifyPropertyPages,
							(void **)&pSPP);
    	    if (SUCCEEDED(hr)) {
	        pSPP->GetPages(&m_TransCAUUID);
	        pSPP->Release();
    	    }

	    // we default to this
	    AM_MEDIA_TYPE mt;
	    ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE));
            mt.majortype = MEDIATYPE_Video;
            mt.subtype = MEDIASUBTYPE_RGB32;
            mt.formattype = FORMAT_VideoInfo;
            mt.bFixedSizeSamples = TRUE;
            mt.bTemporalCompression = FALSE;
            mt.pbFormat = (BYTE *)QzTaskMemAlloc(SIZE_PREHEADER +
						sizeof(BITMAPINFOHEADER));
            mt.cbFormat = SIZE_PREHEADER + sizeof(BITMAPINFOHEADER);
            ZeroMemory(mt.pbFormat, mt.cbFormat);
            LPBITMAPINFOHEADER lpbi = HEADER(mt.pbFormat);
            lpbi->biSize = sizeof(BITMAPINFOHEADER);
            lpbi->biCompression = BI_RGB;
            lpbi->biBitCount = 32;
	    lpbi->biWidth = 320;
  	    lpbi->biHeight = 240;
            lpbi->biPlanes = 1;
            lpbi->biSizeImage = DIBSIZE(*lpbi);
            mt.lSampleSize = DIBSIZE(*lpbi);
	    // !!! AvgTimePerFrame?  dwBitRate?
	    SetMediaType(&mt);
	    SaferFreeMediaType(mt);

	    // do this AFTER calling QParamData
	    m_fDXTMode = TRUE;	// instantiated with Load
	}
    }

    // we might be loaded with an empty bag, that's no problem
    return S_OK;
}

STDMETHODIMP CDXTWrap::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CDXTWrap::InitNew()
{
    // fine. just call load
    return S_OK;
}

// override this to say what interfaces we support where
//
STDMETHODIMP CDXTWrap::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    // this stuff is for the non-Dexter DXT wrapper
    // for our property page - only offer this for DXT wrapper mode
    if (riid == IID_ISpecifyPropertyPages && m_fDXTMode) {
        return GetInterface((ISpecifyPropertyPages *)this, ppv);
    } else if (riid == IID_IAMDXTEffect) {
        return GetInterface((IAMDXTEffect *)this, ppv);

    // to persist the transform we are using
    } else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *)this, ppv);
    } else if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag *)this, ppv);
    } else if (riid == IID_IAMMixEffect) {
        return GetInterface((IAMMixEffect *)this, ppv);
    } else if (riid == IID_IAMSetErrorLog) {
        return GetInterface((IAMSetErrorLog *)this, ppv);
    }

    // pass it along to the transform - its property page QI's come through us
    if (m_fDXTMode && m_punkDXTransform && riid != IID_IUnknown) {
	HRESULT hr = m_punkDXTransform->QueryInterface(riid, ppv);

  	if (SUCCEEDED(hr))
	    return hr;
    }

    // nope, try the base class.
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


HRESULT VariantFromGuid(VARIANT *pVar, BSTR *pbstr, GUID *pGuid)
{
    WCHAR wszClsid[50];
    StringFromGUID2(*pGuid, wszClsid, 50);
    VariantInit(pVar);
    HRESULT hr = NOERROR;
    *pbstr = SysAllocString( wszClsid );
    if( !pbstr )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pVar->vt = VT_BSTR;
        pVar->bstrVal = *pbstr;
    }
    return hr;
}


// This function is called to make sure we have opened and initialized all
// the DXTs we need to use at this point in time (rtStart)
//
// S_OK    == all set up
// S_FALSE == eat this sample, nothing to do
// E_????? == oops
//
HRESULT CDXTWrap::PrimeEffect(REFERENCE_TIME rtStart)
{
    QPARAMDATA *pQ = m_pQHead;
    BOOL fFound = FALSE;
    HRESULT hr;

    // walk through the list of all effects we are hosting
    // make sure that all the effects needed at this time are open
    while (pQ) {
	// oh look, a transform that we need to use at this time
	if (pQ->rtStart <= rtStart && rtStart < pQ->rtStop) {
	    fFound = TRUE;

	    // it hasn't been opened yet!
	    if (pQ->pDXT == NULL) {
    	        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT: %dms - Setup a new transform"),
					(int)(rtStart / 10000)));

		// In DXT mode, we host one DXT only, and we've already opened
		// it.
    		if (m_fDXTMode && m_punkDXTransform) {
		    // in DXTMode, the effect was already created. Just QI.
        	    hr = m_punkDXTransform->QueryInterface(IID_IDXTransform,
		                                (void **)&pQ->pDXT);
    		} else {
                    if (!pQ->pEffectUnk) {

                        // cannot reuse dxts because we cannot reset
                        // their state

                        hr = CoCreateInstance( pQ->EffectGuid, NULL,
                                               CLSCTX_INPROC, IID_IDXTransform,
                                               (void **)&pQ->pDXT );
                        if (FAILED(hr)) {
                            // the effect they gave us was bad!
                            VARIANT var;
                            BSTR bstr;
                            VariantFromGuid(&var, &bstr, &pQ->EffectGuid);
                            _GenerateError(2, DEX_IDS_INVALID_DXT,
                                           E_INVALIDARG, &var);
                            if (var.bstrVal)
                                SysFreeString(var.bstrVal);
                        }
                        if (FAILED(hr) && (m_DefaultEffect != GUID_NULL)) {
                            // the effect they gave us was bad!  Try default
                            //
                            pQ->EffectGuid = m_DefaultEffect;
                            hr = CoCreateInstance(m_DefaultEffect, NULL,
                                                  CLSCTX_INPROC, IID_IDXTransform,
                                                  (void**) &pQ->pDXT );
                            if (FAILED(hr)) {
                                VARIANT var;
                                BSTR bstr;
                                VariantFromGuid(&var,&bstr,&pQ->EffectGuid);
                                _GenerateError(2,DEX_IDS_INVALID_DEFAULT_DXT
                                               ,E_INVALIDARG, &var);
                                if (var.bstrVal)
                                    SysFreeString(var.bstrVal);
                            }
			}
    		    } else {
			hr = pQ->pEffectUnk->QueryInterface(IID_IDXTransform,
							(void **)&pQ->pDXT);
			// !!! Need to fallback on default if this is bad?
		    }
                }
    		if (FAILED(hr)) {
        	    DbgLog((LOG_ERROR,1,TEXT("*** ERROR making transform")));
		    return hr;
    		}

                // ask the transform if it can REALLY vary over time
                //
                IDXEffect *pDXEffect;
                pQ->fCanDoProgress = TRUE;
                hr = pQ->pDXT->QueryInterface(IID_IDXEffect, (void **)&pDXEffect);
                if (hr != NOERROR)
                {
                    DbgLog((LOG_ERROR,1,TEXT("QI for IDXEffect didn't work, effect will not vary")));
                    pQ->fCanDoProgress = FALSE;
                } else {
		    pDXEffect->Release();
		}

    		// initialize the transform we're hosting with the surfaces.
    		// initialize until we hit an unconnected pin.
    		IUnknown *pIn[MAX_EFFECT_INPUTS];
    		IUnknown *pOut[MAX_EFFECT_OUTPUTS];
    		int cIn = 0, cOut = 0;
    		for (int i = 0; i < m_cInputs; i++) {
		    if (m_apInput[i]->IsConnected()) {
			// maybe we want to switch the inputs around
                        // !?! whoever wrote the following 2 lines of code should be shot.
	    		pIn[i] = m_apInput[pQ->Data.fSwapInputs ? m_cInputs
				 -1 - i : i] ->m_pDXSurface;
	    		cIn++;
		    } else {
	    		break;
		    }
    		}
    		for (i = 0; i < m_cOutputs; i++) {
		    if (m_apOutput[i]->IsConnected()) {
        	        pOut[i] = m_apOutput[i]->m_pDXSurface;
	    		cOut++;
		    } else {
	    		break;
		    }
    		}

    	 	// nothing connected? nothing to do.  If we only have an
    	 	// output connected, we need the CreateTransform to fail so that
    	 	// the renderer won't be expecting frames and hang
    	 	ASSERT(cIn != 0 && cOut != 0);

		// now set the static properties BEFORE INTITIALIZING the
		// transform to avoid this call making it re-initialize
                if (pQ->Data.pSetter) {
                    CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pLogger( pQ->Data.pSetter );
                    if( pLogger )
                    {
                        pLogger->put_ErrorLog( m_pErrorLog );
                    }
                    hr = pQ->Data.pSetter->SetProps(pQ->pDXT, -1);
                    if (FAILED(hr)) {
                        DbgLog((LOG_ERROR,0,TEXT("* ERROR setting static properties")));
                    }
                }

    		hr = m_pDXTransFact->InitializeTransform(pQ->pDXT,
					pIn, cIn, pOut, cOut, NULL, NULL);
    		if (hr != S_OK) {
        	    DbgLog((LOG_ERROR,0,TEXT("* ERROR %x transform SETUP"),hr));
		    VARIANT var;
		    BSTR bstr;
		    VariantFromGuid(&var, &bstr, &pQ->EffectGuid);
		    _GenerateError(2, DEX_IDS_BROKEN_DXT, E_INVALIDARG,&var);
		    return hr;
    		}

    		// tell the transform that outputs are uninitialized
    		DWORD dw;
    		hr = pQ->pDXT->GetMiscFlags(&dw);
    		dw &= ~DXTMF_BLEND_WITH_OUTPUT;
    		hr = pQ->pDXT->SetMiscFlags((WORD)dw);
    		if (hr != S_OK) {
        	    DbgLog((LOG_ERROR,0,TEXT("* ERROR setting output flags")));
		    VARIANT var;
		    BSTR bstr;
		    VariantFromGuid(&var, &bstr, &pQ->EffectGuid);
		    _GenerateError(2, DEX_IDS_BROKEN_DXT, E_INVALIDARG,&var);
		    return hr;
    		}

    		DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("*** New Transform is all setup!")));
	    }
	}
	pQ = pQ->pNext;
    }

    // no effect at this time
    if (fFound == FALSE)
	return S_FALSE;

    return S_OK;
}


// This is the function that executes the transform, called once all inputs
// are ready
//
HRESULT CDXTWrap::DoSomething()
{
    HRESULT hr;

    // only want one pin in here at a time
    CAutoLock cObjectLock(&m_csDoSomething);

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::DoSomething")));

    // If another pin was waiting for this lock, the work might already have
    // been done by the pin that had the lock

    for (int n = 0; n < m_cInputs; n++) {
	if (m_apInput[n]->IsConnected() &&
					!m_apInput[n]->m_fSurfaceFilled) {
   	    DbgLog((LOG_ERROR,1,TEXT("*** DoSomething has nothing to do")));
	    return NOERROR;
	}
    }

    // give our outputs the same time stamps as our first input
    IMediaSample *pOutSample[MAX_EFFECT_OUTPUTS];
    for (n = 0; n < m_cOutputs; n++) {
	pOutSample[n] = NULL;
    }
    LONGLONG llStart, llStop;
    llStart = m_apInput[0]->m_llSurfaceStart;
    llStop = m_apInput[0]->m_llSurfaceStop;

    // when we calculate when to show an effect, we include newsegment offset.
    // when we deliver downstream, we don't
    // !!! what if the pins have different new segments?
    REFERENCE_TIME DeliverStart = llStart - m_apInput[0]->m_tStart;
    REFERENCE_TIME DeliverStop = llStop - m_apInput[0]->m_tStart;

    // assume we're just going to pass through the data without using a DXT
    BOOL fCallTransform = FALSE;

    // not the first time through the loop of all transforms to call
    BOOL fWasCalled = FALSE;

    QPARAMDATA *pQ = m_pQHead;
    int count = 0;
    int iteration = 0;

    // make sure the right effects for this time are loaded and set up
    hr = PrimeEffect(llStart);
    if (FAILED(hr))
	goto DoError;
    if (hr == S_FALSE)
	goto Swallow;	// nothing to do... eat these samples

    // count how many transforms we need to do consecutively right now
    while (pQ) {
        // this effect is active now! (inside the active period)
        if (pQ->Data.rtStart <= llStart && llStart < pQ->Data.rtStop) {
	    count++;
	}
      pQ = pQ->pNext;
    }

    // we need a temp buffer to do multiple transforms
    if (count > 1 && m_pTempBuffer == NULL) {
	int iSize = m_apInput[0]->m_pSampleHeld->GetActualDataLength();
	m_pTempBuffer = (BYTE *)QzTaskMemAlloc(iSize);
	if (m_pTempBuffer == NULL) {
            hr = E_OUTOFMEMORY;
            goto DoError;
        }
    }

    // Get all our output samples
    for (n = 0; n < m_cOutputs; n++) {
	// !!! we're supposed to deliver immediately after calling this to make
	// the video renderer happy with DDraw, but we're not doing that.
        hr = m_apOutput[n]->GetDeliveryBuffer(&pOutSample[n], &DeliverStart,
							&DeliverStop, 0);
	if (hr != S_OK) {
   	    DbgLog((LOG_ERROR,1,TEXT("Error from GetDeliveryBuffer")));
	    goto DoError;
	}
    }

    // now call all the transforms we need to call, in the right order
    //

    // Here's how it works:  If we are only doing one DXT, we do it from the
    // input to the output.  If we have 2 DXTs to do, we do #1 from the input
    // to a temp buffer, and #2 from the temp buffer to the output.  If we have
    // 3 DXTs to do, we do #1 from the input to the output, #2 from the output
    // to the temp buffer, and #3 from the temp buffer to the output.  (Always
    // make sure we end up in the output buffer, and NEVER hurt the input bits
    // because they are usually read only!  In order to figure out which
    // place to get the input bits, and where to put the output bits, involves
    // basically seeing if the total count of DXTs we are doing, and this
    // current iteration (eg #2 of 3) are both even or both odd, or different.

    // We only allow multiple DXTs to be used at once like this for 1 input
    // effects.  The situation will never come up for 2 input.

    pQ = m_pQHead;
    while (pQ) {

       // this effect is active now! (inside the active period)
       if (pQ->Data.rtStart <= llStart && llStart < pQ->Data.rtStop) {

	  iteration++;	// which transform is this? (total to do is "count")

	  fCallTransform = TRUE;	// we will be calling a transform today
	  fWasCalled = TRUE;

    	  // what % of effect do we want at this time?
    	  float Percent;
    	  if (llStart == pQ->Data.rtStart)
	    Percent = 0.;
    	  else
	    Percent = (float)((llStart - pQ->Data.rtStart)  * 100 /
				(pQ->Data.rtStop - pQ->Data.rtStart)) / 100;
    	  if (Percent < 0.)
	    Percent = 0.;
    	  if (Percent > 1.)
	    Percent = 1.;

          // Tell the transform where all the input surface bits are
    	  for (n = 0; n < m_cInputs && m_apInput[n]->IsConnected(); n++) {

	      DXRAWSURFACEINFO dxraw;

              BYTE *pSrc;
              hr = m_apInput[n]->m_pSampleHeld->GetPointer(&pSrc);
	      ASSERT(hr == S_OK);
              BYTE *pDst;
              hr = pOutSample[0]->GetPointer(&pDst);
	      ASSERT(hr == S_OK);
	      BYTE *p = m_pTempBuffer;

	      // where are the input bits?  depends on which iteration this is
	      if (iteration > 1) {
		  if (count / 2 * 2 == count) {
		      if (iteration / 2 * 2 != iteration)
		    	    p = pDst;
		  } else if (iteration / 2 * 2 == iteration) {
		    	p = pDst;
		  }
	      } else {
		  p = pSrc;
	      }

              // ask our input for it's raw surface interface
              //
	      IDXRawSurface *pRaw;
	      hr = m_apInput[n]->m_pRaw->QueryInterface(
				IID_IDXRawSurface, (void **)&pRaw);
	      if (hr != NOERROR) {
                  DbgLog((LOG_ERROR,1,TEXT("Can't get IDXRawSurface")));
                  goto DoError;
	      }

	      // Tell our DXSurface to use the bits in the media sample
	      // (avoids a copy!)
	      LPBITMAPINFOHEADER lpbi = HEADER(m_apInput[n]->m_mt.Format());
    	      dxraw.pFirstByte = p + DIBWIDTHBYTES(*lpbi) *
						(lpbi->biHeight - 1);

    	      dxraw.lPitch = -(long)DIBWIDTHBYTES(*lpbi);
    	      dxraw.Width = lpbi->biWidth;
    	      dxraw.Height = lpbi->biHeight;
    	      dxraw.pPixelFormat = m_apInput[n]->m_mt.Subtype();

              // since when in 32 bit mode, we really are DDPF_ARGB32, we can
              // just set the subtype

              dxraw.hdc = NULL;
    	      dxraw.dwColorKey = 0;
	      // !!! Will crash for 8 bit input
    	      dxraw.pPalette = NULL;

	      m_apInput[n]->m_pRaw->SetSurfaceInfo(&dxraw);

              // ask our pin's "surface" for an initialization pointer, so we
              // can tell it just below where it's bits are
              //
              IDXARGBSurfaceInit *pInit;
	      hr = m_apInput[n]->m_pDXSurface->QueryInterface(
				IID_IDXARGBSurfaceInit, (void **)&pInit);
	      if (hr != NOERROR) {
                  DbgLog((LOG_ERROR,1,TEXT("Can't get IDXARGBSurfaceInit")));
                  goto DoError;
	      }

              // tell the DXSurface to become the raw surface we just set up
              //
	      hr = pInit->InitFromRawSurface(pRaw);
	      if (hr != NOERROR) {
                  DbgLog((LOG_ERROR,1,TEXT("* Error in InitFromRawSurface")));
	   	  pInit->Release();
	   	  pRaw->Release();
                  goto DoError;
	      }
	      pInit->Release();
	      pRaw->Release();
	  }

          // Tell the transform where all the output surface bits are
    	  for (n = 0; n < m_cOutputs; n++) {

	        DXRAWSURFACEINFO dxraw;

                BYTE *pDst;
                hr = pOutSample[n]->GetPointer(&pDst);
		ASSERT(hr == S_OK);
		BYTE *p = pDst;

		// where do the output bits go?  depends on the iteration
		if (count / 2 * 2 == count) {
		    if (iteration / 2 * 2 != iteration)
		    	p = m_pTempBuffer;
		} else if (iteration / 2 * 2 == iteration) {
		    p = m_pTempBuffer;
		}

	        IDXRawSurface *pRaw;
	        hr = m_apOutput[n]->m_pRaw->QueryInterface(
				IID_IDXRawSurface, (void **)&pRaw);
	        if (hr != NOERROR) {
                    DbgLog((LOG_ERROR,1,TEXT("Can't get IDXRawSurface")));
                    goto DoError;
	        }

	        // Tell our DXSurface to use the bits in the media sample
	        // (avoids a copy!)
	        LPBITMAPINFOHEADER lpbi = HEADER(m_apOutput[n]->m_mt.Format());
    	        dxraw.pFirstByte = p + DIBWIDTHBYTES(*lpbi) *
						(lpbi->biHeight - 1);

    	        dxraw.lPitch = -(long)DIBWIDTHBYTES(*lpbi);
    	        dxraw.Width = lpbi->biWidth;
    	        dxraw.Height = lpbi->biHeight;
    	        dxraw.pPixelFormat = m_apOutput[n]->m_mt.Subtype();

                // since when in 32 bit mode, we really are DDPF_ARGB32, we can
                // just set the subtype

    	        dxraw.hdc = NULL;
    	        dxraw.dwColorKey = 0;
	        // !!! Will crash for 8 bit input
    	        dxraw.pPalette = NULL;

                m_apOutput[n]->m_pRaw->SetSurfaceInfo(&dxraw);

                IDXARGBSurfaceInit *pInit;
	        hr = m_apOutput[n]->m_pDXSurface->QueryInterface(
				IID_IDXARGBSurfaceInit, (void **)&pInit);
	        if (hr != NOERROR) {
                    DbgLog((LOG_ERROR,1,TEXT("Can't get IDXARGBSurfaceInit")));
                    goto DoError;
	        }

	        hr = pInit->InitFromRawSurface(pRaw);
	        if (hr != NOERROR) {
                    DbgLog((LOG_ERROR,1,TEXT("* Error in InitFromRawSurface")));
		    pInit->Release();
		    pRaw->Release();
                    goto DoError;
	        }
	        pInit->Release();
	        pRaw->Release();
	  }

	  if (pQ->fCanDoProgress) {
            IDXEffect *pDXEffect;
            hr = pQ->pDXT->QueryInterface(IID_IDXEffect,
							(void **)&pDXEffect);
            if (hr != NOERROR) {
                DbgLog((LOG_ERROR,1,TEXT("QI for IDXEffect FAILED")));
	        goto DoError;
            }

	    // do we hae specific PROGRESS values we want to set?  Then don't
	    // do the default linear curve
	    BOOL fAvoidProgress = FALSE;
	    if (pQ->Data.pSetter) {
		LONG c;
		DEXTER_PARAM *pParam;
		DEXTER_VALUE *pValue;
		hr = pQ->Data.pSetter->GetProps(&c, &pParam, &pValue);
                ASSERT( !FAILED( hr ) );
		if (SUCCEEDED(hr)) {
		    for (LONG zz=0; zz<c; zz++) {
		        if (!DexCompareW(pParam[zz].Name, L"Progress"))
			    fAvoidProgress = TRUE;
		    }
		    pQ->Data.pSetter->FreeProps(c, pParam, pValue);
		}
                else
                {
                    // !!! should we error log this, Danny?
                    DbgLog((LOG_ERROR,1,TEXT("*** GetProps FAILED!!")));
            	    pDXEffect->Release();
                    goto DoError;
                }
	    }

	    // this will get overridden by the Property Setter if there is one.
	    // Default is a linear curve
	    if (!fAvoidProgress) {
                hr = pDXEffect->put_Progress(Percent);
                if (hr != NOERROR) {
                    DbgLog((LOG_ERROR,1,TEXT("*** put_Progress FAILED!!")));
                }
	    }
            pDXEffect->Release();
	  }

	  // set the varying properties
	  if (pQ->Data.pSetter) {
                CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pLogger( pQ->Data.pSetter );
                if( pLogger )
                {
                    pLogger->put_ErrorLog( m_pErrorLog );
                }
                hr = pQ->Data.pSetter->SetProps(pQ->pDXT, llStart -
				                pQ->Data.rtStart);
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,0,TEXT("* ERROR setting dynamic properties")));
    	      }
	  }

          long dwTime = timeGetTime();
          hr = pQ->pDXT->Execute(NULL, NULL, NULL);
          dwTime = timeGetTime() - dwTime;
          DbgLog((LOG_TIMING,TRACE_MEDIUM,TEXT("Execute: %dms"), dwTime));
          if (hr != NOERROR) {
              DbgLog((LOG_ERROR,1,TEXT("*** Execute FAILED: %x"), hr));
	      goto DoError;
          }
          DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("EXECUTED Transform: %d%%"),
						(int)(Percent * 100)));

          // Now tell DXT to stop looking in our media sample bits so we can
          // release the samples
          for (n = 0; n < m_cInputs && m_apInput[n]->IsConnected(); n++) {
	      IDXARGBSurfaceInit *pInit;
	      hr = m_apInput[n]->m_pDXSurface->QueryInterface(
				IID_IDXARGBSurfaceInit, (void **)&pInit);
	      if (hr != NOERROR) {
                  DbgLog((LOG_ERROR,1,TEXT("Can't get IDXARGBSurfaceInit")));
                  DbgLog((LOG_ERROR,1,TEXT("*** LEAKING!")));
	          ASSERT(FALSE);
	      } else {
	          pInit->InitFromRawSurface(NULL);
	          pInit->Release();
	      }
          }

          // this only needs doing if we setup the 2D stuff
          for (n = 0; n < m_cOutputs; n++) {
	      IDXARGBSurfaceInit *pInit;
	      hr = m_apOutput[n]->m_pDXSurface->QueryInterface(
				IID_IDXARGBSurfaceInit, (void **)&pInit);
	      if (hr != NOERROR) {
                  DbgLog((LOG_ERROR,1,TEXT("Can't get IDXARGBSurfaceInit")));
                  DbgLog((LOG_ERROR,1,TEXT("*** LEAKING!")));
	          ASSERT(FALSE);
	      } else {
	          pInit->InitFromRawSurface(NULL);
	          pInit->Release();
	      }
          }
      }
      pQ = pQ->pNext;
    }


    // Deliver all of our outputs
    for (n = 0; n < m_cOutputs; n++) {
	BYTE *pDst;
    long DstSize =  pOutSample[n]->GetSize();
	
    hr = pOutSample[n]->GetPointer(&pDst);
	if (hr != S_OK) {
   	    DbgLog((LOG_ERROR,1,TEXT("Error from GetPointer")));
	    goto DoError;
	}



	// the output sample will be this big unless otherwise noted
	int iSize = DIBSIZE(*HEADER(m_apOutput[n]->m_mt.Format()));

	if (!fCallTransform) {

	    // If we're not in the active range of a tranform, but still in its
	    // lifetime, we follow this rule:  Before the active range, pass
	    // input A. After the active range, pass input B. There may be more
	    // than one transform alive right now, just use the first one found
	    BOOL fA = FALSE;
	    QPARAMDATA *pQ = m_pQHead;
    	    while (pQ) {
	        if (pQ->rtStart <= llStart && llStart < pQ->rtStop) {
		    if (llStart < pQ->Data.rtStart)
		        fA = TRUE;
		    break;
	        }
	        pQ = pQ->pNext;
	    }

            // Tell the transform where all the input surface bits are
	    LPBYTE pSrc;
	    if (fA) {
                hr = m_apInput[0]->m_pSampleHeld->GetPointer(&pSrc);
		// iSize is needed later in this function!
	        iSize = m_apInput[0]->m_pSampleHeld->GetActualDataLength();
	    } else if (m_cInputs > 1 && m_apInput[1]->IsConnected()) {
                hr = m_apInput[1]->m_pSampleHeld->GetPointer(&pSrc);
	        iSize = m_apInput[1]->m_pSampleHeld->GetActualDataLength();
	    } else {
                hr = m_apInput[0]->m_pSampleHeld->GetPointer(&pSrc);
	        iSize = m_apInput[0]->m_pSampleHeld->GetActualDataLength();
	    }
            if (hr != NOERROR) {
                DbgLog((LOG_ERROR,1,TEXT("*** GetSrc bits Error %x"), hr));
                goto DoError;
            }

	    // COPY memory from the src sample to the output sample
  	    // !!! make it inplace?
  	    // no funny strides?
	    DWORD dwTime = timeGetTime();
        if (DstSize <iSize)
        {
            // Buffer is not big enough, Copying memory will cause a buffer overrun
            DbgLog (( LOG_ERROR, 1, TEXT("Destination Buffer too small, failing to prevent buffer overrun")));
            hr =  VFW_E_BUFFER_OVERFLOW;
            goto DoError;
        }
	    CopyMemory(pDst, pSrc, iSize);
	    dwTime = timeGetTime() - dwTime;
            DbgLog((LOG_TIMING,TRACE_MEDIUM,TEXT("Only copy: %dms"), dwTime));
        }

	// Set all the sample properties - (make sure iSize has been set)
	pOutSample[n]->SetActualDataLength(iSize);
	pOutSample[n]->SetTime((REFERENCE_TIME *)&DeliverStart,
				(REFERENCE_TIME *)&DeliverStop);
	pOutSample[n]->SetDiscontinuity(FALSE);	// !!! if input #1 is?
	pOutSample[n]->SetSyncPoint(TRUE);
	pOutSample[n]->SetPreroll(FALSE);		// !!! if input #1 is?

	// The video renderer will block us when going from run->pause
	hr = m_apOutput[n]->Deliver(pOutSample[n]);
        if (hr != NOERROR) {
            DbgLog((LOG_ERROR,1,TEXT("Deliver FAILED!")));
            goto DoError;
        }

        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Delivered output %d"), n));
    }

    for (n = 0; n < m_cOutputs; n++) {
	pOutSample[n]->Release();
	pOutSample[n] = NULL;
    }

Swallow:
    // We're done with input #1.  We're done with other inputs whose stop
    // times are not bigger than #1's stop time.
    for (n = 0; n < m_cInputs; n++) {
	// grab 'em all during the next for loop
	m_apInput[n]->m_csSurface.Lock();
    }
    for (n = 0; n < m_cInputs; n++) {
	if (n == 0) {
	    // unblock receive
            DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Done with input #0")));
	    if (m_apInput[n]->m_fSurfaceFilled) {
	        m_apInput[n]->m_fSurfaceFilled = FALSE;
	        m_apInput[n]->m_pSampleHeld->Release();
	        SetEvent(m_apInput[n]->m_hEventSurfaceFree);
	    }
	} else {
	    if (m_apInput[n]->IsConnected() &&
				(m_apInput[n]->m_llSurfaceStop == 0 ||
	    			m_apInput[n]->m_llSurfaceStop <= llStop)) {
	        // unblock receive
                DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Done with input #%d"), n));
	        if (m_apInput[n]->m_fSurfaceFilled) {
	            m_apInput[n]->m_fSurfaceFilled = FALSE;
	            m_apInput[n]->m_pSampleHeld->Release();
	            SetEvent(m_apInput[n]->m_hEventSurfaceFree);
		}
	    }
	}
    }
    for (n = 0; n < m_cInputs; n++) {
	m_apInput[n]->m_csSurface.Unlock();
    }

    return NOERROR;

DoError:
    for (n = 0; n < m_cOutputs; n++) {
        if (pOutSample[n])
            pOutSample[n]->Release();
    }

    // Release all the inputs we're holding, or we'll hang
    for (n = 0; n < m_cInputs; n++) {
	// grab 'em all during the next for loop
	m_apInput[n]->m_csSurface.Lock();
    }
    for (n = 0; n < m_cInputs; n++) {
        // unblock receive
        if (m_apInput[n]->m_fSurfaceFilled) {
            m_apInput[n]->m_fSurfaceFilled = FALSE;
            m_apInput[n]->m_pSampleHeld->Release();
            SetEvent(m_apInput[n]->m_hEventSurfaceFree);
        }
    }
    for (n = 0; n < m_cInputs; n++) {
	m_apInput[n]->m_csSurface.Unlock();
    }

    return hr;

}


		
// this stuff is for the non-Dexter DXT wrapper - we also show DXT pages too
//
STDMETHODIMP CDXTWrap::GetPages(CAUUID *pPages)
{
   CheckPointer(pPages, E_POINTER);
   DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT::GetPages")));

   // we have one page, and the transform may have some too
   pPages->cElems = 1 + m_TransCAUUID.cElems;
   pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems);
   if ( ! pPages->pElems)
       return E_OUTOFMEMORY;

   pPages->pElems[0] = CLSID_DXTProperties;
   CopyMemory(&pPages->pElems[1], m_TransCAUUID.pElems,
					sizeof(GUID) * m_TransCAUUID.cElems);
   return NOERROR;
}


// IAMDXTEffect implementation - for the non-Dexter DXT wrapper that only does
// 	one effect

//
HRESULT CDXTWrap::SetDuration(LONGLONG llStart, LONGLONG llStop)
{
    CAutoLock cObjectLock(m_pLock);

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("IAMDXTEffect::SetDuration:")));

    if (m_pQHead == NULL)
	return E_UNEXPECTED;
    ASSERT(m_pQHead->rtStart == 0);
    ASSERT(m_pQHead->rtStop == MAX_TIME);
    m_pQHead->Data.rtStart = llStart;
    m_pQHead->Data.rtStop = llStop;
    return NOERROR;
}


HRESULT CDXTWrap::GetDuration(LONGLONG *pllStart, LONGLONG *pllStop)
{
    CAutoLock cObjectLock(m_pLock);

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("IAMDXTEffect::GetDuration:")));
    CheckPointer(pllStart, E_POINTER);
    CheckPointer(pllStop, E_POINTER);

    if (m_pQHead == NULL)
	return E_UNEXPECTED;
    ASSERT(m_pQHead->rtStart == 0);
    ASSERT(m_pQHead->rtStop == MAX_TIME);

    *pllStart = m_pQHead->Data.rtStart;
    *pllStop = m_pQHead->Data.rtStop;
    return NOERROR;
}



// tell our clsid
//
STDMETHODIMP CDXTWrap::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_DXTWrap;
    return S_OK;
}


typedef struct {
    int version;
    int pins;
    BOOL fDXTMode;
    int count;
    int nPropSize;	// # of bytes of properties at the end
    AM_MEDIA_TYPE mt; // format is hidden after the array
    GUID DefaultEffect;
    QPARAMDATA qp[1];
    // properties hidden after the array
} saveThing;

// persist ourself
// we save some random stuff, our media type (sans format), an array of queued
// effects, the format of the media type, and the properties
//
HRESULT CDXTWrap::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::WriteToStream")));

    CheckPointer(pStream, E_POINTER);
    HRESULT hr;
    int count = 0;
    LONG savesize;
    saveThing *px;

    QPARAMDATA *p = m_pQHead;

    LONG cSave = 0;
    LONG cSaveMax = 1000;
    BYTE *pSave = (BYTE *)CoTaskMemAlloc(cSaveMax);
    if (pSave == NULL)
	return E_OUTOFMEMORY;

    // how many effects are queued?  while we're at it, get their properties
    // and their total size (put them all in a big binary glob at pSave)
    while (p) {
	count++;	// count the number of effects in this linked list

	LONG cSaveT = 0;
	BYTE *pSaveT = NULL;

	// get the properties of this effect
	if (p->Data.pSetter) {
	    hr = p->Data.pSetter->SaveToBlob(&cSaveT, &pSaveT);
	    if (FAILED(hr)) {
		CoTaskMemFree(pSave);
		return hr;
	    }
	}

	if (cSaveT + (LONG)sizeof(LONG) + cSave > cSaveMax) {
	    cSaveMax += cSaveT + cSave - cSaveMax + 1000;
	    BYTE * pSaveTT = (BYTE *)CoTaskMemRealloc(pSave, cSaveMax);
	    if (pSaveTT == NULL) {
		CoTaskMemFree(pSaveT);
                CoTaskMemFree(pSave);
		return E_OUTOFMEMORY;
	    }
            pSave = pSaveTT;
	}

	*(LONG *)(pSave + cSave) = cSaveT;
	cSave += sizeof(LONG);

	if (cSaveT)
	    CopyMemory(pSave + cSave, pSaveT, cSaveT);
	cSave += cSaveT;

	if (pSaveT)
	    CoTaskMemFree(pSaveT);
	p = p->pNext;
    }
    DbgLog((LOG_TRACE,2,TEXT("CDXT:Total property size: %d"), cSave));

    // how many bytes do we need to save?
    savesize = sizeof(saveThing) + (count - 1) * sizeof(QPARAMDATA) +
					m_mtAccept.cbFormat + cSave;
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Persisted data is %d bytes"), savesize));
    px = (saveThing *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	CoTaskMemFree(pSave);
	return E_OUTOFMEMORY;
    }
    px->version = 2;
    px->pins = m_cInputs;
    px->fDXTMode = m_fDXTMode;
    px->DefaultEffect = m_DefaultEffect;
    px->nPropSize = cSave;
    px->count = 0;

    p = m_pQHead;
    while (p) {
	px->qp[px->count] = *p;
	// These pointers can't be persisted
	px->qp[px->count].pNext = NULL;
	//px->qp[px->count].Data.pCallback = NULL;
	//px->qp[px->count].Data.pData = NULL;	// !!!
	px->qp[px->count].Data.pSetter = NULL;	// can't save them like this
        px->count++;
	p = p->pNext;
    }
    px->mt = m_mtAccept; // AM_MEDIA_TYPE
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk = NULL;		// !!!

    // put the media type format at the end of the array
    LPBYTE pProps = (LPBYTE)(&px->qp[px->count]);
    CopyMemory(pProps, m_mtAccept.pbFormat, m_mtAccept.cbFormat);
    pProps += m_mtAccept.cbFormat;

    // finally, put the property junk in
    if (cSave)
        CopyMemory(pProps, pSave, cSave);
    if (pSave)
        CoTaskMemFree(pSave);

    hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself
//
HRESULT CDXTWrap::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::ReadFromStream")));
    CheckPointer(pStream, E_POINTER);

    Reset();	// start over

    // all we know we have for sure is the beginning of the struct (there may
    // be no queued effects)
    LONG savesize1 = sizeof(saveThing) - sizeof(QPARAMDATA);
    saveThing *px = (saveThing *)QzTaskMemAlloc(savesize1);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if (px->version != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*** ERROR! Old version file")));
        QzTaskMemFree(px);
	return S_OK;
    }

    // now we know how many queued effects are their properties are here and
    // how many more bytes we need to read
    LONG savesize = sizeof(saveThing) + (px->count - 1) * sizeof(QPARAMDATA) +
				 px->mt.cbFormat + px->nPropSize;
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Persisted data is %d bytes"), savesize));
    DbgLog((LOG_TRACE,2,TEXT("Effect properties: %d bytes"), px->nPropSize));
    px = (saveThing *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    hr = pStream->Read(&(px->qp[0]), savesize - savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if (px->pins)
        SetNumInputs(px->pins);

    // find the props
    BYTE *pProps = (BYTE *)&(px->qp[px->count]);
    pProps += px->mt.cbFormat;

    // program all the queued effects, including their properties
    for (int i = 0; i < px->count; i++) {

	LONG cSize = *(LONG *)pProps;
	pProps += sizeof(LONG);
        IPropertySetter *pSetter = NULL;
	if (cSize) {
            hr = CoCreateInstance(CLSID_PropertySetter, NULL, CLSCTX_INPROC,
			IID_IPropertySetter, (void **)&pSetter);
	    if (pSetter == NULL) {
        	QzTaskMemFree(px);
		return E_OUTOFMEMORY;
	    }
	    pSetter->LoadFromBlob(cSize, pProps);
	    pProps += cSize;
	}
	px->qp[i].Data.pSetter = pSetter;
	QParamData(px->qp[i].rtStart, px->qp[i].rtStop, px->qp[i].EffectGuid,
						NULL, &(px->qp[i].Data));
	if (px->qp[i].Data.pSetter)
	    px->qp[i].Data.pSetter->Release();
    }

    // This must go AFTER QParamData is called
    m_fDXTMode = px->fDXTMode;

    // in DXTMode, we have a property page, and we keep the transform open
    // constantly (for the page to work)
    if (m_fDXTMode) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Entering DXT wrapper Mode...")));
	hr = CoCreateInstance(px->qp[0].EffectGuid, (IUnknown *)(IBaseFilter *)this,
		CLSCTX_INPROC, IID_IUnknown, (void **)&m_punkDXTransform);
	if (FAILED(hr)) {
            DbgLog((LOG_ERROR,1,TEXT("*** Can't create effect")));
	    QzTaskMemFree(px);
	    return hr;
	}
    	ISpecifyPropertyPages *pSPP;
    	hr = m_punkDXTransform->QueryInterface(IID_ISpecifyPropertyPages,
							(void **)&pSPP);
    	if (SUCCEEDED(hr)) {
	    pSPP->GetPages(&m_TransCAUUID);
	    pSPP->Release();
    	}
    }

    AM_MEDIA_TYPE mt = px->mt;
    mt.pbFormat = (BYTE *)QzTaskMemAlloc(mt.cbFormat);
    // remember, the format is hidden after the array of queued effects
    CopyMemory(mt.pbFormat, &(px->qp[px->count]), mt.cbFormat);
    SetMediaType(&mt);
    SaferFreeMediaType(mt);

    SetDefaultEffect(&px->DefaultEffect);

    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}


// how big is our save data?
//
int CDXTWrap::SizeMax()
{
    int count = 0;
    int savesize;
    QPARAMDATA *p = m_pQHead;
    while (p) {
	count++;
	p = p->pNext;
    }
    savesize = sizeof(saveThing) + (count - 1) * sizeof(QPARAMDATA) +
						m_mtAccept.cbFormat;
    return savesize;
}


// IAMMixEffect stuff

// get rid of all queued data
//
HRESULT CDXTWrap::Reset()
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::Reset")));

    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    m_fDXTMode = FALSE;	// can't use DXT wrapper mode anymore

    QPARAMDATA *p = m_pQHead, *p2;
    while (p) {
	p2 = p->pNext;
	if (p->Data.pSetter)
	    p->Data.pSetter->Release();
	if (p->pDXT)
	    p->pDXT->Release();
        if( p->pEffectUnk )
            p->pEffectUnk->Release( );
	delete p;
 	p = p2;
    }
    m_pQHead = NULL;
    SetDirty(TRUE);
    return S_OK;
}


// what media type do we connect with?
//
HRESULT CDXTWrap::SetMediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT::SetMediaType")));
    CheckPointer(pmt, E_POINTER);
    CheckPointer(pmt->pbFormat, E_POINTER);

    // somebody already connected?  Too late!
    for (int i = 0; i < m_cInputs; i++) {
	if (m_apInput[i]->IsConnected())
	    return E_UNEXPECTED;
    }
    if (m_cOutputs && m_apOutput[0]->IsConnected())
	return E_UNEXPECTED;

/*
    if (m_mtAccept.majortype != GUID_NULL) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: already called")));
	return E_UNEXPECTED;
    }
*/
    if (pmt->majortype != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }
    // check this is a VIDEOINFOHEADER type
    if (pmt->formattype != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

    // !!! What if subtype doesn't match biCompression/biBitCount?

    // We only accept RGB
    if (HEADER(pmt->pbFormat)->biCompression != BI_BITFIELDS &&
    			HEADER(pmt->pbFormat)->biCompression != BI_RGB) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: Not RGB")));
	return E_INVALIDARG;
    }
    if (!HEADER(pmt->pbFormat)->biWidth || !HEADER(pmt->pbFormat)->biHeight) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: bad size")));
	return E_INVALIDARG;
    }

    // DXT cannot output 8 bit, so don't allow it

    HRESULT hr = E_INVALIDARG;
    if (HEADER(pmt->pbFormat)->biBitCount == 24)
        hr = NOERROR;
    // !!! better have alpha=11111111, or don't use alpha
    if (HEADER(pmt->pbFormat)->biBitCount == 32)
        hr = NOERROR;
    if (HEADER(pmt->pbFormat)->biBitCount == 16) {
        if (HEADER(pmt->pbFormat)->biCompression == BI_RGB)
            hr = NOERROR;
	else {
	    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmt->pbFormat;
            if (BITMASKS(pvi)[0] == 0xf800 &&
        	    BITMASKS(pvi)[1] == 0x07e0 &&
        	    BITMASKS(pvi)[2] == 0x001f) {
                hr = NOERROR;
	    }
	}
    }

    if (hr == NOERROR) {
	SaferFreeMediaType(m_mtAccept);
        hr = CopyMediaType(&m_mtAccept, pmt);
	SetDirty(TRUE);
    } else
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: bad bitcount/masks")));

    return hr;
}


// what media type are we connecting with?
//
HRESULT CDXTWrap::GetMediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cObjectLock(m_pLock);

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT::GetMediaType")));
    CheckPointer(pmt, E_POINTER);
    return CopyMediaType(pmt, &m_mtAccept);
}


// are we a one or two input effect?
//
HRESULT CDXTWrap::SetNumInputs(int nInputs)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::SetNumInputs %d"), nInputs));

    // already been called
    if (m_cInputs || m_cOutputs) {

        // it's okay if it's the same, as far as I'm concerned
        if( m_cInputs == nInputs ) return NOERROR;

	return E_UNEXPECTED;
    }

    for (int z = 0; z < nInputs; z++) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("making an input pin...")));
	WCHAR wach[80];
	wsprintfW(wach, L"DXT Input %d", m_cInputs);
        m_apInput[m_cInputs] = new CDXTInputPin(NAME("DXT input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          wach);             // Pin name

        //  Can't fail. !!! ehr - why not?
        ASSERT(SUCCEEDED(hr));
        if (m_apInput[m_cInputs] == NULL) {
            goto SetNumInputs_Error;
        }
	m_cInputs++;
    }

    // Make an output pin

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("making an output pin...")));
    WCHAR wach[80];
    wsprintfW(wach, L"DXT Output");
    m_apOutput[m_cOutputs] = new CDXTOutputPin(NAME("DXT output pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          wach);             // Pin name

    //  Can't fail
    ASSERT(SUCCEEDED(hr));
    if (m_apOutput[m_cOutputs] == NULL) {
        goto SetNumInputs_Error;
    }
    m_cOutputs++;

    IncrementPinVersion();	// !!! graphedit still won't notice
    return NOERROR;

SetNumInputs_Error:
    DbgLog((LOG_ERROR,1,TEXT("*** Error making pins")));
    while (m_cInputs--) delete m_apInput[m_cInputs];
    while (m_cOutputs--) delete m_apOutput[m_cOutputs];
    return E_OUTOFMEMORY;
}


// Queue up an effect.  There are 2 start times and 2 stop times.  The lifetime
// of this particular effect is from rtStart to rtStop, and the effect will be
// turned on to some degree between pData->rtStart and pData->rtStop (which must
// be inside the lifetime).  For the lifetime of the effect that the effect is
// not turned out the effect is off (1 input) or all A or all B (2 input)
//
HRESULT CDXTWrap::QParamData(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, REFGUID guiddummy, IUnknown * pEffectUnk, DEXTER_PARAM_DATA *pData)
{

    // save this off so we can modify it, since a REFGUID is constant
    //
    GUID guid = guiddummy;

    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTWrap::QParamData")));

    if (m_cInputs == 0) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("NO PINS - error")));
	return E_UNEXPECTED;
    }
    CheckPointer(pData, E_FAIL);

    // times are bogus
    if (rtStop < rtStart || pData->rtStart < rtStart || pData->rtStop > rtStop)
	return E_INVALIDARG;
    if ( IsEqualGUID(guid, GUID_NULL) && !pEffectUnk )
	return E_INVALIDARG;

    if (pData->nVersion != 0)
	return E_INVALIDARG;

    // now queue this in our linked list, sorted in the order given to us for
    // 1 input effects, and sorted by lifetimes that can't overlap for 2 input
    // (1 input effects can have times that overlap, and we will perform
    //  multiple effects at a time)

    QPARAMDATA *p = m_pQHead, *pNew, *pP = NULL;
    if (m_cInputs == 2) {
        while (p && p->rtStart < rtStart) {
	    pP = p;
	    p = p->pNext;
	}
        if (p && p->rtStart < rtStop)
	    return E_INVALIDARG;
        if (pP && pP->rtStop > rtStart)
	    return E_INVALIDARG;
    } else {
        while (p) {
	    pP = p;
	    p = p->pNext;
        }
    }

    pNew = new QPARAMDATA;
    if (pNew == NULL)
	return E_OUTOFMEMORY;
    pNew->Data = *pData;
    if (pNew->Data.pSetter)
        pNew->Data.pSetter->AddRef();	// hold onto this
    pNew->rtStart = rtStart;
    pNew->rtStop = rtStop;
    pNew->fCanDoProgress = FALSE;	// don't know yet;
    pNew->pDXT = NULL;
    pNew->pEffectUnk = NULL;
    pNew->EffectGuid = guid;
    if( pEffectUnk )
    {
        pNew->EffectGuid = GUID_NULL;	// use given instantiated one instead
        pNew->pEffectUnk = pEffectUnk;
        pEffectUnk->AddRef( );
    }
    if (pP)
    {
	pP->pNext = pNew;
    }
    pNew->pNext = NULL;
    if (m_pQHead == NULL || p == m_pQHead)
	m_pQHead = pNew;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("New Effect successfully queued")));
#ifdef DEBUG
    DumpQ();
#endif

    m_fDXTMode = FALSE;	// not anymore!
    SetDirty(TRUE);

    return S_OK;
}


#ifdef DEBUG
HRESULT CDXTWrap::DumpQ()
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT::DumpQ")));
    QPARAMDATA *p = m_pQHead;
    while (p) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("%8d-%8d ms"), (int)(p->rtStart / 10000),
						(int)(p->rtStop / 10000)));
	p = p->pNext;
    }
    return S_OK;
}
#endif


// !!! need a way to reset # of pins? (switch too)

// !!! can't get the CAPS of an effect



////////////////////////////////////////////////////////////////////////////
//////////////   INPUT PIN  ////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


CDXTInputPin::CDXTInputPin(TCHAR *pObjectName, CDXTWrap *pFilter, HRESULT * phr, LPCWSTR pName)
    : CBaseInputPin(pObjectName, pFilter, pFilter->m_pLock, phr, pName)
{
    m_pFilter = pFilter;
    m_pDXSurface = NULL;
    m_fSurfaceFilled = FALSE;
    m_pRaw = NULL;
    m_hEventSurfaceFree = NULL;
}

// Normally, we only accept the media type we were told to accept
// In DXT wrapper mode, we allow a number of RGB types, but all connections must
// be of the same type
//
HRESULT CDXTInputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("CDXTIn::CheckMediaType")));

    if (pmt == NULL || pmt->Format() == NULL) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: type/format is NULL")));
	return E_INVALIDARG;
    }

    // Normal mode - accept only what we were told to
    if (!m_pFilter->m_fDXTMode) {
        if (m_pFilter->m_mtAccept.majortype == GUID_NULL) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: no type set yet")));
	    return E_INVALIDARG;
        }
        if (pmt->majortype != m_pFilter->m_mtAccept.majortype ||
			pmt->subtype != m_pFilter->m_mtAccept.subtype ||
			pmt->formattype != m_pFilter->m_mtAccept.formattype) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: GUID mismatch")));
	    return E_INVALIDARG;
        }
        // !!! c runtime
        if (memcmp(HEADER(pmt->pbFormat),HEADER(m_pFilter->m_mtAccept.pbFormat),
					sizeof(BITMAPINFOHEADER))) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: Invalid BITMAPINFOHEADER")));
	    return E_INVALIDARG;
        }
	return NOERROR;
    }

    // DXT Wrapper mode - all inputs must be the same type

    // we only support MEDIATYPE_Video
    if (*pmt->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmt->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

    // !!! What if subtype doesn't match biCompression/biBitCount?

    // We only accept RGB
    if (HEADER(pmt->Format())->biCompression == BI_BITFIELDS &&
    			HEADER(pmt->Format())->biBitCount != 16) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: Invalid BITFIELDS")));
	return E_INVALIDARG;
    }
    if (HEADER(pmt->Format())->biCompression != BI_BITFIELDS &&
    			HEADER(pmt->Format())->biCompression != BI_RGB) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: Not RGB")));
	return E_INVALIDARG;
    }

    int nWidth = 0, nHeight = 0, nBitCount = 0;
    DWORD dwCompression = 0;
    for (int n = 0; n < m_pFilter->m_cInputs; n++) {
	if (m_pFilter->m_apInput[n]->IsConnected()) {
	    nWidth = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->biWidth;
	    nHeight = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->biHeight;
	    nBitCount = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->
								biBitCount;
	    dwCompression = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->
								biCompression;
	    break;
	}
    }
    if (nWidth == 0) {
	if (m_pFilter->m_apOutput[0]->IsConnected()) {
	    nWidth = HEADER(m_pFilter->m_apOutput[0]->m_mt.Format())->biWidth;
	    nHeight = HEADER(m_pFilter->m_apOutput[0]->m_mt.Format())->biHeight;
	    nBitCount = HEADER(m_pFilter->m_apOutput[0]->m_mt.Format())->
								biBitCount;
	    dwCompression = HEADER(m_pFilter->m_apOutput[0]->m_mt.Format())->
								biCompression;
	}
    }

    // all pins must connect with the same size bitmap
    // !!! and same bitcount so we can efficiently pass through (not really
    // imposed by DXT)
    //
    if (nWidth && (nWidth != HEADER(pmt->Format())->biWidth ||
    			nHeight != HEADER(pmt->Format())->biHeight ||
    			nBitCount != HEADER(pmt->Format())->biBitCount ||
    			dwCompression !=HEADER(pmt->Format())->biCompression)) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: Formats don't match")));
	return E_INVALIDARG;
    }

    if (HEADER(pmt->Format())->biBitCount == 24)
        return NOERROR;
    // !!! better have alpha=11111111, or don't use alpha
    if (HEADER(pmt->Format())->biBitCount == 32)
        return NOERROR;
    if (HEADER(pmt->Format())->biBitCount == 16) {
        if (HEADER(pmt->Format())->biCompression == BI_RGB)
            return NOERROR;
	VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmt->Format();
        if (BITMASKS(pvi)[0] == 0xf800 &&
        	BITMASKS(pvi)[1] == 0x07e0 &&
        	BITMASKS(pvi)[2] == 0x001f) {
            return NOERROR;
	}
    }
    return E_INVALIDARG;
}


// !!! each input pin will fwd these to all outputs.  Wait until last input
// get it, then send to all?

// EndOfStream
//
HRESULT CDXTInputPin::EndOfStream()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pFilter->m_cOutputs);
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT::EndOfStream")));

// !!! This will ABORT playback if one stream ends early!  We should pass
// through the other stream.  If both streams end early, we'rein trouble!
// (MPEG seeking bug)

// Possible hang in BeginFlush too? Can only 1 pin be flushed?

    // Walk through the output pins list, sending the message downstream

    for (int n = 0; n < m_pFilter->m_cOutputs; n++) {
        CDXTOutputPin *pOutputPin = m_pFilter->m_apOutput[n];
	ASSERT(pOutputPin);
        if (pOutputPin) {
            hr = pOutputPin->DeliverEndOfStream();
            if (FAILED(hr))
                return hr;
        }
    }
    return CBaseInputPin::EndOfStream();
}


// BeginFlush
//
HRESULT CDXTInputPin::BeginFlush()
{
    HRESULT hr;

    CAutoLock lock_it(m_pLock);
    ASSERT(m_pFilter->m_cOutputs);

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT::BeginFlush")));

    // first, make sure receive will fail from now on
    HRESULT hrD = CBaseInputPin::BeginFlush();

    // unblock receive
    m_csSurface.Lock();
    if (m_fSurfaceFilled) {
        m_fSurfaceFilled = FALSE;
        m_pSampleHeld->Release();
        SetEvent(m_hEventSurfaceFree);
    }
    m_csSurface.Unlock();

    // Walk through the output pins list, sending the message downstream,
    // to unblock the deliver to the renderer
    for (int n = 0; n < m_pFilter->m_cOutputs; n++) {
        CDXTOutputPin *pOutputPin = m_pFilter->m_apOutput[n];
	ASSERT(pOutputPin);
        if (pOutputPin) {
            hr = pOutputPin->DeliverBeginFlush();
            if (FAILED(hr))
                return hr;
        }
    }

    // now make sure Receive has finished
    CAutoLock lock_2(&m_csReceive);

    // make sure Receive didn't hold the sample
    m_csSurface.Lock();
    if (m_fSurfaceFilled) {
        m_fSurfaceFilled = FALSE;
        m_pSampleHeld->Release();
        SetEvent(m_hEventSurfaceFree);
    }
    m_csSurface.Unlock();

    return hrD;
}


// EndFlush
//
HRESULT CDXTInputPin::EndFlush()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pFilter->m_cOutputs);
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT::EndFlush")));

    // Walk through the output pins list, sending the message downstream

    for (int n = 0; n < m_pFilter->m_cOutputs; n++) {
        CDXTOutputPin *pOutputPin = m_pFilter->m_apOutput[n];
	ASSERT(pOutputPin);
        if (pOutputPin) {
            hr = pOutputPin->DeliverEndFlush();
            if (FAILED(hr))
                return hr;
        }
    }
    return CBaseInputPin::EndFlush();
}


//
// NewSegment
//

HRESULT CDXTInputPin::NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop,
                                 double dRate)
{
    // !!! no no no we'll hang CAutoLock lock_it(m_pLock);

    ASSERT(m_pFilter->m_cOutputs);
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXT::NewSegment - %dms - pass it down"),
					(int)(tStart / 10000)));
    // !!! both input pins will pass this down
    for (int n = 0; n < m_pFilter->m_cOutputs; n++) {
        CDXTOutputPin *pOutputPin = m_pFilter->m_apOutput[n];
	ASSERT(pOutputPin);
        if (pOutputPin) {
            hr = pOutputPin->DeliverNewSegment(tStart, tStop, dRate);
            if (FAILED(hr))
                return hr;
        }
    }
    return CBaseInputPin::NewSegment(tStart, tStop, dRate);
}


// our Receive methods can block
STDMETHODIMP CDXTInputPin::ReceiveCanBlock()
{
    return S_OK;
}


//
// Receive
//
// In DEXTER, we're well behaved and both pins will get data at exactly the
// same frame rate.  But this filter is written to work with 2 inputs that
// are at different frame rates (to be useful outside Dexter).  We will use the
// first pin's frame rate and time stamps to decide how often to output samples.
//
// Pin number 1 is the master.  For other pins, if that frame ends before pin
// #1's data starts, it is too early and discarded.  Once all pins have valid
// data, we call the transform (there may be one or 2 inputs)
//
HRESULT CDXTInputPin::Receive(IMediaSample *pSample)
{
    // DEATH if you take the filter crit sect in receive and block
    // CAutoLock lock_it(m_pLock);

    CAutoLock cObjectLock(&m_csReceive);

    LONGLONG llStart = 0, llStop = 0;
    HRESULT hr = pSample->GetTime(&llStart, &llStop);

    // Skew time stamps by new segment values to get the real time
    llStart += m_tStart;
    llStop += m_tStart;
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT:Skewed Receive time (%d,%d)ms"),
						(int)(llStart / 10000),
						(int)(llStop / 10000)));

    if (!m_pFilter->m_apOutput[0]->IsConnected()) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Receive FAILED: Output not connected")));
	return S_OK;
    }
    // If we're not supposed to receive anymore because we're stopped,
    // waiting on the event will hang forever
    if (m_pFilter->m_State == State_Stopped) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Receive FAILED: Stopped")));
	return VFW_E_WRONG_STATE;
    }

    // this pin already has something waiting to be processed.  Block.
    if (m_fSurfaceFilled) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT: Waiting for surface to be free")));
        WaitForSingleObject(m_hEventSurfaceFree, INFINITE);
    }

    // Check that we still want to receive after waiting - maybe we unblocked
    // because the graph is stopping
    hr = NOERROR;
    hr = CBaseInputPin::Receive(pSample);
    if (hr != NOERROR) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT:Receive base class ERROR!")));
        return hr;
    }

    // the other way we can tell we're stopping and not supposed to continue
    // is if the surface really isn't free after the event was set
    if (m_fSurfaceFilled) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXT:Event fired saying STOP!")));
        return S_FALSE;
    }

    // PROTECT our logic deciding what to do
    m_csSurface.Lock();

    // we aren't the first input, and the first input has some data.
    // Throw our data away if it's too early
    if (this != m_pFilter->m_apInput[0] &&
				m_pFilter->m_apInput[0]->m_fSurfaceFilled) {
	if (llStop > 0 && llStop <= m_pFilter->m_apInput[0]->m_llSurfaceStart){
            DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("TOO EARLY: Discard ourself")));
	    m_csSurface.Unlock();
	    return NOERROR;
	}
    }

    // we are the first input.  throw others away that are already queued up
    // but that we now realize are too early.
    if (llStop > 0 && this == m_pFilter->m_apInput[0]) {
	for (int i = 1; i < m_pFilter->m_cInputs; i++) {
	    m_pFilter->m_apInput[i]->m_csSurface.Lock();
	    if (m_pFilter->m_apInput[i]->m_fSurfaceFilled &&
			m_pFilter->m_apInput[i]->m_llSurfaceStop > 0 &&
			m_pFilter->m_apInput[i]->m_llSurfaceStop <= llStart) {
                DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Pin #%d TOO EARLY: Discard it"),i));
		m_pFilter->m_apInput[i]->m_fSurfaceFilled = FALSE;
	        m_pFilter->m_apInput[i]->m_pSampleHeld->Release();
		SetEvent(m_pFilter->m_apInput[i]->m_hEventSurfaceFree);
	    }
	    m_pFilter->m_apInput[i]->m_csSurface.Unlock();
	}
    }

    m_pSampleHeld = pSample;
    pSample->AddRef();

    // We have valid data in our surface now.  Next time we'll block
    m_fSurfaceFilled = TRUE;
    m_llSurfaceStart = llStart;	// time stamps of the valid data
    m_llSurfaceStop = llStop;
    ResetEvent(m_hEventSurfaceFree);	// need a new SetEvent

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Input has received something")));

    // not everybody has data yet.  We're done
    for (int i = 0; i < m_pFilter->m_cInputs; i++) {
	if (m_pFilter->m_apInput[i]->IsConnected() &&
				!m_pFilter->m_apInput[i]->m_fSurfaceFilled) {
    	    m_csSurface.Unlock();
	    return NOERROR;
	}
    }

    // OK, should be safe now
    m_csSurface.Unlock();

    // Everybody has data!  Time to call the effect!
    hr = m_pFilter->DoSomething();
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,1,TEXT("DXT's DoSomething FAILED!!!!!!")));
        // !!! If the Deliver inside DoSomething failed, then technically we shouldn't
        // send this EOS
	m_pFilter->m_apOutput[0]->DeliverEndOfStream();
    }

    return hr;
}


// make a surface we can use for the transform
//
HRESULT CDXTInputPin::Active()
{
    HRESULT hr;
    IDXSurfaceFactory *pF;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CDXTIn::Active")));

    ASSERT(!m_fSurfaceFilled);

    // auto reset event - fired to unblock receive
    m_hEventSurfaceFree = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hEventSurfaceFree == NULL)
	return E_OUTOFMEMORY;

    // Make a surface the same type as our input
    hr = m_pFilter->m_pDXTransFact->QueryInterface(IID_IDXSurfaceFactory,
							(void **)&pF);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("Error making surface factory")));
	CloseHandle(m_hEventSurfaceFree);
        m_hEventSurfaceFree = NULL;
	return hr;
    }

    CDXDBnds bnds;
    bnds.SetXYSize(HEADER(m_mt.Format())->biWidth,
					HEADER(m_mt.Format())->biHeight);

    hr = pF->CreateSurface(NULL, NULL, m_mt.Subtype( ), &bnds, 0, NULL,
				IID_IDXSurface, (void **)&m_pDXSurface);
    pF->Release();
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("In: Error Creating surface")));
	CloseHandle(m_hEventSurfaceFree);
        m_hEventSurfaceFree = NULL;
	return hr;
    }
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("In: Created surface")));

    m_pRaw = new CMyRaw();
    if (m_pRaw == NULL) {
	CloseHandle(m_hEventSurfaceFree);
        m_hEventSurfaceFree = NULL;
	m_pDXSurface->Release();
	m_pDXSurface = NULL;
 	return E_OUTOFMEMORY;
    }
    m_pRaw->AddRef();

    return CBaseInputPin::Active();
}


HRESULT CDXTInputPin::Inactive()
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("DXTIn::Inactive")));

    // we need to stop every input pin, not just this one, because any receive
    // uses the data from both pins.
    //
    for (int n=0; n<m_pFilter->m_cInputs; n++) {

        // first, unblock all the receives
        SetEvent(m_pFilter->m_apInput[n]->m_hEventSurfaceFree);

        // now make sure that any pending receives are finished so we don't blow
        // up shutting down
        m_pFilter->m_apInput[n]->m_csReceive.Lock();
    }

    for (n=0; n<m_pFilter->m_cInputs; n++) {

        // now make sure receive didn't hold onto a sample
        m_pFilter->m_apInput[n]->m_csSurface.Lock();
        if (m_pFilter->m_apInput[n]->m_fSurfaceFilled) {
            m_pFilter->m_apInput[n]->m_fSurfaceFilled = FALSE;
            m_pFilter->m_apInput[n]->m_pSampleHeld->Release();
            SetEvent(m_pFilter->m_apInput[n]->m_hEventSurfaceFree);
        }
        m_pFilter->m_apInput[n]->m_csSurface.Unlock();

        // Decommit the allocators, to ensure nobody's receives get entered
	// again.  DON'T DO THIS until we've unblocked receive above and
        // released all the samples
        HRESULT hr = m_pFilter->m_apInput[n]->CBaseInputPin::Inactive();
    }

    for (n=0; n<m_pFilter->m_cInputs; n++) {
        m_pFilter->m_apInput[n]->m_csReceive.Unlock();
    }

    // all done with this pin's variables... the other Inactive will do nothing
    // above, but kill its variables below
    //
    if (m_pDXSurface)
	m_pDXSurface->Release();
    m_pDXSurface = NULL;

    if (m_pRaw)
        m_pRaw->Release();
    m_pRaw = NULL;

    // all done
    if (m_hEventSurfaceFree)
    {
        CloseHandle(m_hEventSurfaceFree);
        m_hEventSurfaceFree = NULL;
    }

    return S_OK;
}


STDMETHODIMP CMyRaw::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{

    // our private interface to say what transform to use and when
    if (riid == IID_IDXRawSurface) {
        return GetInterface((IDXRawSurface *)this, ppv);
    }

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

HRESULT STDMETHODCALLTYPE CMyRaw::GetSurfaceInfo(DXRAWSURFACEINFO *pdxraw)
{
    DbgLog((LOG_TRACE,TRACE_MEDIUM+1,TEXT("*** GetSurfaceInfo")));

    if (pdxraw == NULL)
	return E_POINTER;

    *pdxraw = m_DXRAW;
    DbgLog((LOG_TRACE,TRACE_MEDIUM+1,TEXT("giving %x: %dx%d"), pdxraw->pFirstByte,
				pdxraw->Width, pdxraw->Height));
    return NOERROR;
}

HRESULT CMyRaw::SetSurfaceInfo(DXRAWSURFACEINFO *pdxraw)
{
    m_DXRAW = *pdxraw;
    return NOERROR;
}


////////////////////////////////////////////////////////////////////////////
//////////////   OUTPUT PIN  ///////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

CDXTOutputPin::CDXTOutputPin(TCHAR *pObjectName, CDXTWrap *pFilter, HRESULT * phr, LPCWSTR pPinName)
    : CBaseOutputPin(pObjectName, pFilter, pFilter->m_pLock, phr, pPinName)
    , m_pPosition(NULL)
{
    m_pFilter = pFilter;
    m_pDXSurface = NULL;
    m_pRaw = NULL;
}

CDXTOutputPin::~CDXTOutputPin()
{
    if (m_pPosition)
	m_pPosition->Release();
}


//
// DecideBufferSize
//
// This has to be present to override the PURE virtual class base function
//
HRESULT CDXTOutputPin::DecideBufferSize(IMemAllocator *pAllocator,
                                      ALLOCATOR_PROPERTIES * pProperties)
{

    ASSERT(m_mt.IsValid());
    ASSERT(pAllocator);
    ASSERT(pProperties);

    // make sure we have at least 1 buffer
    // !!! more?
    if (pProperties->cBuffers == 0)
        pProperties->cBuffers = 1;

    // set the size of buffers based on the expected output frame size
    if (pProperties->cbBuffer < (LONG)m_mt.GetSampleSize())
        pProperties->cbBuffer = m_mt.GetSampleSize();
    ASSERT(pProperties->cbBuffer);

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error in SetProperties")));
	return hr;
    }

    if (Actual.cbBuffer < pProperties->cbBuffer) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - buffer too small")));
	return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Using %d buffers of size %d"),
					Actual.cBuffers, Actual.cbBuffer));

    return NOERROR;

}


//
// CheckMediaType
//
// Normally, we only accept the media type we were told to accept
// In DXT wrapper mode, we allow a number of RGB types, but all connections must
// be of the same type
//
HRESULT CDXTOutputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    DbgLog((LOG_TRACE,5,TEXT("CDXTOut::CheckMediaType")));

    if (pmt == NULL || pmt->Format() == NULL) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: type/format is NULL")));
	return E_INVALIDARG;
    }

    // Normal mode - accept only what we were told to
    if (!m_pFilter->m_fDXTMode) {
        if (m_pFilter->m_mtAccept.majortype == GUID_NULL) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: no type set yet")));
	    return E_INVALIDARG;
        }
        if (pmt->majortype != m_pFilter->m_mtAccept.majortype ||
		    pmt->subtype != m_pFilter->m_mtAccept.subtype ||
		    pmt->formattype != m_pFilter->m_mtAccept.formattype) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: GUID mismatch")));
	    return E_INVALIDARG;
        }
        // !!! runtime
        if (memcmp(HEADER(pmt->pbFormat),HEADER(m_pFilter->m_mtAccept.pbFormat),
					sizeof(BITMAPINFOHEADER))) {
            DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Rejecting: Invalid BITMAPINFOHEADER")));
	    return E_INVALIDARG;
        }
	return NOERROR;
    }

    // DXT Wrapper mode - all inputs must be the same type

    // we only support MEDIATYPE_Video
    if (*pmt->Type() != MEDIATYPE_Video) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: not VIDEO")));
	return E_INVALIDARG;
    }

    // check this is a VIDEOINFOHEADER type
    if (*pmt->FormatType() != FORMAT_VideoInfo) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: format not VIDINFO")));
        return E_INVALIDARG;
    }

    // !!! what if subtype doesn't match biCompression/biBitCount?

    // We only accept RGB
    if (HEADER(pmt->Format())->biCompression == BI_BITFIELDS &&
    			HEADER(pmt->Format())->biBitCount != 16) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: Invalid BITFIELDS")));
	return E_INVALIDARG;
    }
    if (HEADER(pmt->Format())->biCompression != BI_BITFIELDS &&
    			HEADER(pmt->Format())->biCompression != BI_RGB) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Rejecting: Not RGB")));
	return E_INVALIDARG;
    }

    // all pins must connect with the same size bitmap
    // !!! and same bitcount so we can efficiently pass through (not really
    // imposed by DXT)
    //
    int nWidth = 0, nHeight = 0, nBitCount = 0;
    DWORD dwCompression = 0;
    for (int n = 0; n < m_pFilter->m_cInputs; n++) {
	if (m_pFilter->m_apInput[n]->IsConnected()) {
	    nWidth = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->biWidth;
	    nHeight = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->biHeight;
	    nBitCount = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->									biBitCount;
	    dwCompression = HEADER(m_pFilter->m_apInput[n]->m_mt.Format())->
								biCompression;
	    break;
        }
    }

    // all pins must connect with the same type
    //
    if (nWidth != HEADER(pmt->Format())->biWidth ||
    			nHeight != HEADER(pmt->Format())->biHeight ||
    			nBitCount != HEADER(pmt->Format())->biBitCount ||
    			dwCompression !=HEADER(pmt->Format())->biCompression) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Reject: formats don't match")));
	return E_INVALIDARG;
    }

    // DXT CANNOT output 8 bit

    if (HEADER(pmt->Format())->biBitCount == 24)
        return NOERROR;
    // !!! better have alpha=11111111, or don't use alpha
    if (HEADER(pmt->Format())->biBitCount == 32)
        return NOERROR;
    if (HEADER(pmt->Format())->biBitCount == 16) {
        if (HEADER(pmt->Format())->biCompression == BI_RGB)
            return NOERROR;
	VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmt->Format();
        if (BITMASKS(pvi)[0] == 0xf800 &&
        	BITMASKS(pvi)[1] == 0x07e0 &&
        	BITMASKS(pvi)[2] == 0x001f) {
            return NOERROR;
	}
    }
    return E_INVALIDARG;
}



//
// GetMediaType - offer what we've been told to use
// 	In DXT Mode, offer the same as our input
//
HRESULT CDXTOutputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
//    LARGE_INTEGER li;
//    VIDEOINFOHEADER *pf;

    DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("*::GetMediaType #%d"), iPosition));

    if (pmt == NULL) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM+3,TEXT("Media type is NULL, no can do")));
	return E_INVALIDARG;
    }

    if (iPosition < 0) {
        return E_INVALIDARG;
    }
    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    if (m_pFilter->m_fDXTMode) {
	// DXT Mode - offer our input type
        for (int n = 0; n < m_pFilter->m_cInputs; n++) {
            if (m_pFilter->m_apInput[n]->IsConnected()) {
	        return CopyMediaType( pmt, &m_pFilter->m_apInput[n]->m_mt );
	    }
        }
        return E_UNEXPECTED;
    }

    return CopyMediaType( pmt, &m_pFilter->m_mtAccept );
}


//
// SetMediaType
//
HRESULT CDXTOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    return CBaseOutputPin::SetMediaType(pmt);

}


//
// Notify
//
STDMETHODIMP CDXTOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    // !!! Quality management is unneccessary?
    return E_NOTIMPL;
}


// Make a DXSurface for the pin to use, the same format as its mediatype
//
HRESULT CDXTOutputPin::Active()
{
    HRESULT hr;
    IDXSurfaceFactory *pF;

    if (1) {
        m_pRaw = new CMyRaw();
        if (m_pRaw == NULL) {
	    // !!! more error checking in this function?
 	    return E_OUTOFMEMORY;
        }
	m_pRaw->AddRef();

        hr = m_pFilter->m_pDXTransFact->QueryInterface(IID_IDXSurfaceFactory,
							(void **)&pF);
        if (hr != NOERROR) {
            DbgLog((LOG_ERROR,1,TEXT("Error making factory")));
	    m_pRaw->Release();
	    m_pRaw = NULL;
 	    return hr;
        }

        CDXDBnds bnds;
        bnds.SetXYSize(HEADER(m_mt.Format())->biWidth,
					HEADER(m_mt.Format())->biHeight);

        hr = pF->CreateSurface(NULL, NULL, m_mt.Subtype( ), &bnds, 0, NULL,
				IID_IDXSurface, (void **)&m_pDXSurface);

        pF->Release();
        if (hr != NOERROR) {
            DbgLog((LOG_ERROR,1,TEXT("Out: Error Creating surface")));
	    m_pRaw->Release();
	    m_pRaw = NULL;
 	    return hr;
        }
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("Out: Created 2D surface")));
    }

    return CBaseOutputPin::Active();
}


HRESULT CDXTOutputPin::Inactive()
{
    if (1) {
        if (m_pDXSurface)
	    m_pDXSurface->Release();
        m_pDXSurface = NULL;

	if (m_pRaw)
            m_pRaw->Release();
        m_pRaw = NULL;
    }

    return CBaseOutputPin::Inactive();
}


// !!! Need MULTI-PIN pass thru for 2 input effects!
//
STDMETHODIMP CDXTOutputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IMediaSeeking && m_pFilter->m_cInputs == 1) {
        if (m_pPosition == NULL) {
            HRESULT hr = CreatePosPassThru(
                             GetOwner(),
                             FALSE,
                             (IPin *)m_pFilter->m_apInput[0],
                             &m_pPosition);
            if (FAILED(hr)) {
                return hr;
            }
        }
        return m_pPosition->QueryInterface(riid, ppv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}

STDMETHODIMP CDXTWrap::SetDefaultEffect( GUID * pEffect )
{
    CheckPointer( pEffect, E_POINTER );
    m_DefaultEffect = *pEffect;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\dxtenum\vidfx2.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: vidfx2.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "vidfx2.h"
#include <initguid.h>

DEFINE_GUID(CLSID_VideoEffects2Rejects, 0xcc7bfb47, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);

// we make 2 registry keys that the DXTWrapper will use to get what effect to
// use... the effect guid, and how many input pins to expose
const TCHAR g_szGUIDBag[] = TEXT("guid");
const TCHAR g_szInputsBag[] = TEXT("inputs");
extern TCHAR g_szReject[];

CVidFX2ClassManager::CVidFX2ClassManager() :
	// value of this key is given to me in MatchString
        CClassManagerBase(g_szGUIDBag),
	m_cFX(0),
        m_hD3DRMCreate(NULL),
        m_pfnDirect3DRMCreate(NULL)
{
    DbgLog((LOG_TRACE,1,TEXT("Video Effects 2 Constructor")));

    // so we don't have to link to d3drm.dll
    //
    // GetProcAddress only takes a char
    static const char sz_Direct3DRMCreate[] = "Direct3DRMCreate";
    if(m_hD3DRMCreate = LoadLibrary(TEXT("d3drm.dll")))
    {
        m_pfnDirect3DRMCreate = (PD3DRMCreate)GetProcAddress(m_hD3DRMCreate,
						sz_Direct3DRMCreate);
        if(m_pfnDirect3DRMCreate == 0) {
            DWORD dwLastError = GetLastError();
            FreeLibrary(m_hD3DRMCreate);
            m_hD3DRMCreate = 0;
            // !!! *phr = HRESULT_FROM_WIN32(dwLastError);
	    return;
        }
    } else {
        DWORD dwLastError = GetLastError();
        // !!! *phr = HRESULT_FROM_WIN32(dwLastError);
	return;
    }

}

CVidFX2ClassManager::~CVidFX2ClassManager()
{
    DbgLog((LOG_TRACE,1,TEXT("Video Effects 2 Destructor")));
    for (ULONG i = 0; i < m_cFX; i++) {
	CoTaskMemFree(m_rgFX[i]->wszDescription);
	delete m_rgFX[i];
    }
    if (m_hD3DRMCreate) {
        FreeLibrary(m_hD3DRMCreate);
    }
}

HRESULT CVidFX2ClassManager::ReadLegacyDevNames()
{
    DbgLog((LOG_TRACE,1,TEXT("FX2: ReadLegacyDevNames")));

    // fills m_rgFX and sets m_cFX
    InitializeEffectList();

    m_cNotMatched = m_cFX;
    return S_OK;
}

BOOL CVidFX2ClassManager::MatchString(const TCHAR *szDevName)
{
    USES_CONVERSION;
    DbgLog((LOG_TRACE,3,TEXT("FX2: MatchString %s"), szDevName));
    for (UINT i = 0; i < m_cFX; i++)
    {
        GUID guid;
	CLSIDFromString((WCHAR *) T2CW(szDevName), &guid);
        if (guid == m_rgFX[i]->guid)
        {
    	    DbgLog((LOG_TRACE,3,TEXT("MATCHED")));
            return TRUE;
        }

    }
    DbgLog((LOG_TRACE,3,TEXT("NOT MATCHED")));
    return FALSE;
}

HRESULT CVidFX2ClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    DbgLog((LOG_TRACE,1,TEXT("FX2: CreateRegKeys")));

    USES_CONVERSION;
    ResetClassManagerKey(CLSID_VideoEffects2Category);
    HRESULT hr = S_OK;

    ReadLegacyDevNames();
    for (UINT i = 0; i < m_cFX; i++)
    {
        WCHAR wszUniq[120];
	StringFromGUID2(m_rgFX[i]->guid, wszUniq, 120);

        DWORD dwFlags = 0;

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = 0;
        rf2.rgPins = NULL;

        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_DXTWrap,
	    // friendly name presented to user
            m_rgFX[i]->wszDescription,
            &pMoniker,
            &CLSID_VideoEffects2Category,
	    // effect GUID is the unique identifier
            wszUniq,
            &rf2);
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(wszUniq);
                if(var.bstrVal) {
                    hr = pPropBag->Write(T2CW(g_szGUIDBag), &var);
                    SysFreeString(var.bstrVal);
                } else {
                    hr = E_OUTOFMEMORY;
                }
		if (hr == S_OK) {
                    var.vt = VT_I4;
                    var.lVal = 2;
                    hr = pPropBag->Write(T2CW(g_szInputsBag), &var);
		}

                pPropBag->Release();
            }
            pMoniker->Release();
        }
	if (FAILED(hr))
	    break;
    }
    return hr;
}


HRESULT CVidFX2ClassManager::AddClassToList(HKEY hkClsIdRoot, CLSID &clsid, ULONG Index)
{
    USES_CONVERSION;
    OLECHAR wszGUID[MAX_PATH];
    StringFromGUID2(clsid, wszGUID, MAX_PATH);
    TCHAR *szTcharGUID = W2T(wszGUID);

    m_rgFX[Index] = new FXGuid;
    if (m_rgFX[Index] == NULL)
    {
        return E_OUTOFMEMORY;
    }
    long cbSizeW = _MAX_PATH * sizeof(WCHAR);
// SEC: check return code
    m_rgFX[Index]->wszDescription = (LPWSTR)CoTaskMemAlloc(cbSizeW);
    m_rgFX[Index]->wszDescription[0] = 0;
    TCHAR szDesc[_MAX_PATH];
    long cbSize = sizeof(szDesc);
// SEC: Registery
    LONG rrv = RegQueryValue(hkClsIdRoot, szTcharGUID, szDesc, &cbSize);
    if (rrv == ERROR_SUCCESS) {
	// sec: safe, szDesc cannot be bigger than MAXPATH which is the size of wszDescription too.
	lstrcpyW(m_rgFX[Index]->wszDescription, T2W(szDesc));
   	DbgLog((LOG_TRACE,1,TEXT("%S"), m_rgFX[Index]->wszDescription));
    }
    m_rgFX[Index]->guid = (GUID)clsid;
    m_cFX++;
    return S_OK;
}


HRESULT CVidFX2ClassManager::AddCatsToList(ICatInformation *pCatInfo, const GUID &catid)
{
#include "..\..\..\pnp\devenum\util.h"
#define NUM_GUIDS 10
    USES_CONVERSION;
    IEnumCLSID *pEnumCLSID;
    GUID aguid[NUM_GUIDS];
    ULONG cguid;

    HRESULT hr = pCatInfo->EnumClassesOfCategories(1, (GUID *)&catid,
						0, NULL, &pEnumCLSID);
    if (SUCCEEDED(hr)) {
        HKEY hkClsIdRoot;
// SEC: Registery
       if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &hkClsIdRoot) != ERROR_SUCCESS)
        {
            DbgLog((LOG_ERROR,1,TEXT("Failed to open CLSID registry key")));
            pEnumCLSID->Release();
            return E_OUTOFMEMORY;
        }
        while (1) {
            ULONG ulUsed;
	    GUID guid[25];
	    ulUsed = 0;
            hr = pEnumCLSID->Next(25, guid, &ulUsed);
	    if (FAILED(hr) || ulUsed == 0) {
		break;
	    }
	    while (ulUsed-- > 0) {
   	        DbgLog((LOG_TRACE,3,TEXT("Found a possible effect...")));

	        // If this clsid is already in the category, we don't need to
		// query it and waste countless hours. some DXTs can take 700ms
		// each to create and query!!

    	        HKEY hk;
    	        OLECHAR szReg[MAX_PATH];
	        // sec: safe, szReg is big enough
	        lstrcpyW(szReg, T2W(g_szCmRegPath));
    	        OLECHAR szGUID[MAX_PATH];
    	        StringFromGUID2(CLSID_VideoEffects2Category, szGUID,
							MAX_PATH);
    	        lstrcatW(szReg, L"\\"); // safe
    	        lstrcatW(szReg, szGUID); // safe
    	        lstrcatW(szReg, L"\\"); // safe
    	        StringFromGUID2(guid[ulUsed], szGUID, MAX_PATH);
    	        lstrcatW(szReg, szGUID); // safe
    	        TCHAR *TszReg = W2T(szReg);
    	        TCHAR XX[_MAX_PATH];
// SEC: Registery
    	        long rrv = RegOpenKey(g_hkCmReg, TszReg, &hk);
	        if (rrv == ERROR_SUCCESS) {
	            DWORD cb = sizeof(XX);
// SEC: Registery
    	            rrv = RegQueryValueEx(hk, TEXT("FriendlyName"), NULL, NULL,
						(BYTE *)XX, &cb);
// SEC: Registery
    	            RegCloseKey(hk);
	            if (rrv == ERROR_SUCCESS) {
    	    	        m_rgFX[m_cFX] = new FXGuid;
		        if (m_rgFX[m_cFX] == NULL) {
		            return E_OUTOFMEMORY;
		        }
    	    	        long cbSizeW = _MAX_PATH * sizeof(WCHAR);
    	    	        m_rgFX[m_cFX]->wszDescription =
					    (LPWSTR)CoTaskMemAlloc(cbSizeW);
	    	        if (m_rgFX[m_cFX]->wszDescription == NULL) {
		            return E_OUTOFMEMORY;
	    	        }
			// safe copy, since XX is bounded to max_path by now
	                // sec: unsafe, use bounded string function
    	    	        lstrcpyW(m_rgFX[m_cFX]->wszDescription, T2W(XX));
    	    	        m_rgFX[m_cFX]->guid = (GUID)guid[ulUsed];
    	    	        m_cFX++;
    	                DbgLog((LOG_TRACE,2,TEXT("Found in Registry: Saved making it!")));
		        continue;
	            }
	        }

	        // If this clsid is already in the reject registry, we've tried
	        // it and know it doesn't belong. Don't waste up to 800ms
		// creating it!

// SEC: Registery
    	        RegOpenKey(HKEY_CURRENT_USER, g_szReject, &hk);
	        if (hk) {
    	            StringFromGUID2(CLSID_VideoEffects2Rejects, szReg,
							MAX_PATH);
    	            lstrcatW(szReg, L"\\"); // safe
    	            StringFromGUID2(guid[ulUsed], szGUID, MAX_PATH);
    	            lstrcatW(szReg, szGUID); // safe
    	            TszReg = W2T(szReg);
	            long cb = sizeof(XX);
// SEC: Registery
    	            rrv = RegQueryValue(hk, TszReg, XX, &cb);
// SEC: Registery
    	            RegCloseKey(hk);
	            if (rrv == ERROR_SUCCESS) {
    	                DbgLog((LOG_TRACE,2,TEXT("Found in REJECT Registry: Saved making it!")));
		        continue;
	            }
		}

	        IDXTransform *pDXT;
    	        hr = CoCreateInstance(guid[ulUsed], NULL, CLSCTX_INPROC,
					IID_IDXTransform, (void **)&pDXT);
	        if (hr == S_OK) {
		    ULONG k = 0;
		    DWORD dw;
    		    cguid = NUM_GUIDS;	// reset!
		    while ((hr = pDXT->GetInOutInfo(FALSE, k++, &dw, aguid,
						&cguid, NULL)) == S_OK) {
		        for (ULONG j = 0; j < cguid; j++) {
		            if (IsEqualGUID(aguid[j], IID_IDXSurface))
			        break;
		        }
		        if (j >= cguid) {
   	    	            DbgLog((LOG_TRACE,3,TEXT("Input %d can't accept surfaces"), k));
			    break;
		        } else {
    		            cguid = NUM_GUIDS;	// reset!
			    continue;
		        }
		    }

		    if (hr == S_FALSE && k > 2) {
			// if there are 2 good inputs we can use, and pin 3
			// is optional, this is a 2 input effect
    		        cguid = NUM_GUIDS;
		        hr = pDXT->GetInOutInfo(FALSE, 2, &dw, aguid,
								&cguid, NULL);
		        if (hr == S_FALSE || (hr == S_OK &&
						(dw & DXINOUTF_OPTIONAL))) {
   	    	            DbgLog((LOG_TRACE,3,TEXT("This can operate with 2 2D inputs")));
                            AddClassToList(hkClsIdRoot, guid[ulUsed], m_cFX);
			} else {
   	    	            DbgLog((LOG_TRACE,3,TEXT("REJECT: >2 inputs")));
		            AddToRejectList(guid[ulUsed]);
			}
		    } else {
   	    	        DbgLog((LOG_TRACE,3,TEXT("REJECT: <2 inputs")));
		        AddToRejectList(guid[ulUsed]);
		    }
		    pDXT->Release();
		} else {
   	    	    DbgLog((LOG_TRACE,3,TEXT("REJECT: Can't create it")));
		    AddToRejectList(guid[ulUsed]);
		}
	    }
        }
        pEnumCLSID->Release();
// SEC: Registery
        RegCloseKey(hkClsIdRoot);
    } else {
   	DbgLog((LOG_ERROR,1,TEXT("No effects in this category at all")));
    }
    return hr;
}


HRESULT CVidFX2ClassManager::AddToRejectList(const GUID &guid)
{
    // Add this CLSID to the reject registry

    USES_CONVERSION;
    HKEY hk;
    OLECHAR szReg[MAX_PATH];
    szReg[0] = 0;
    lstrcatW(szReg, T2W(g_szReject)); // safe
    lstrcatW(szReg, L"\\"); // safe
    OLECHAR szGUIDFX[MAX_PATH];
    StringFromGUID2(CLSID_VideoEffects2Rejects, szGUIDFX, MAX_PATH);
    lstrcatW(szReg, szGUIDFX); // safe
    lstrcatW(szReg, L"\\"); // safe
    StringFromGUID2(guid, szGUIDFX, MAX_PATH);
    lstrcatW(szReg, szGUIDFX); // safe
    TCHAR *TszReg = W2T(szReg);
// SEC: Registery
    RegCreateKey(HKEY_CURRENT_USER, TszReg, &hk);
    if (hk) {
    	DbgLog((LOG_TRACE,3,TEXT("Added to REJECT list")));
// SEC: Registery
        RegCloseKey(hk);
	return NOERROR;
    } else {
    	DbgLog((LOG_TRACE,3,TEXT("ERROR: Can't add to REJECT list")));
	return E_OUTOFMEMORY;
    }
}


HRESULT CVidFX2ClassManager::InitializeEffectList()
{

    // already done
    if (m_cFX)
	return S_OK;

    // You need DXF6 (Chrome 1.0, Win98SP1, or NT5) to get 3D effects
    // !!! After installing DX6, make sure this code runs again!
    m_f3DSupported = FALSE;
    IDirect3DRM *pD3DRM;
    IDirect3DRM3 *pD3DRM3;
    HRESULT hr = m_pfnDirect3DRMCreate(&pD3DRM);
    if (hr == NOERROR) {
	hr = pD3DRM->QueryInterface(IID_IDirect3DRM3, (void **)&pD3DRM3);
	pD3DRM->Release();
        if (hr == NOERROR) {
            DbgLog((LOG_TRACE,1,TEXT("***This OS supports 3D transforms")));
	    pD3DRM3->Release();
	    m_f3DSupported = TRUE;
        }
    }

    ICatInformation *pCatInfo;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
			CLSCTX_ALL, IID_ICatInformation, (void **)&pCatInfo);
    if (SUCCEEDED(hr)) {
   	DbgLog((LOG_TRACE,1,TEXT("Initializing 2 input 2D effects")));
        hr = AddCatsToList(pCatInfo, CATID_DXImageTransform);
	if (m_f3DSupported) {
   	    DbgLog((LOG_TRACE,1,TEXT("Initializing 2 input 3D effects")));
            hr = AddCatsToList(pCatInfo, CATID_DX3DTransform);
	}
        pCatInfo->Release();
    } else {
   	DbgLog((LOG_ERROR,1,TEXT("There are no effects at all")));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\dxtwrap\dxt.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxt.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#ifndef __DXTWRAP__
#define __DXTWRAP__

// !!!
#define MAX_EFFECTS 		50
#define MAX_EFFECT_INPUTS 	10
#define MAX_EFFECT_OUTPUTS 	10

#include <dxtrans.h>
#include "..\..\errlog\cerrlog.h"

extern const AMOVIESETUP_FILTER sudDXTWrap;

class CDXTWrap;

typedef struct _QParamData {
    REFERENCE_TIME rtStart;	// when to use this GUID. pData's times are
    REFERENCE_TIME rtStop;	// when a and b are mixed
    GUID EffectGuid;
    IUnknown * pEffectUnk;
    BOOL fCanDoProgress;
    DEXTER_PARAM_DATA Data;
    IDXTransform *pDXT;		// once opened
    _QParamData *pNext;
} QPARAMDATA;

// this stuff is for the non-Dexter DXT wrapper
DEFINE_GUID(CLSID_DXTProperties,
0x1B544c24, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x20);

class CDXTInputPin;
class CDXTOutputPin;

class CMyRaw : public CUnknown, public IDXRawSurface
{
    DXRAWSURFACEINFO m_DXRAW;	// surface to use

public:

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    CMyRaw() : CUnknown(TEXT("Raw Surface"), NULL) {};

    // IDXRawSurface
    HRESULT STDMETHODCALLTYPE GetSurfaceInfo( 
            DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo);

    HRESULT SetSurfaceInfo(DXRAWSURFACEINFO *pSurfaceInfo);
};



// class for the Tee filter's Input pin
//
class CDXTInputPin : public CBaseInputPin
{
    friend class CDXTOutputPin;
    friend class CDXTWrap;

    CDXTWrap *m_pFilter;

    // the interface used by this pin
    IDXSurface *m_pDXSurface;
    CMyRaw *m_pRaw;	// object to initialize the surface

    BOOL m_fSurfaceFilled;
    IMediaSample *m_pSampleHeld;
    HANDLE m_hEventSurfaceFree;
    LONGLONG m_llSurfaceStart, m_llSurfaceStop;
    CCritSec m_csReceive;
    CCritSec m_csSurface;	// for holding onto samples

public:

    // Constructor and destructor
    CDXTInputPin(TCHAR *pObjName,
                 CDXTWrap *pFilter,
                 HRESULT *phr,
                 LPCWSTR pPinName);

    //~CDXTInputPin();

    // Used to check the input pin connection
    HRESULT CheckMediaType(const CMediaType *pmt);

    HRESULT Active();
    HRESULT Inactive();

    // Pass through calls downstream
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);

    STDMETHODIMP ReceiveCanBlock();

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    int m_cBuffers;	    // number of buffers in allocator
};


// Class for the filter's Output pins.
//
class CDXTOutputPin : public CBaseOutputPin
{
    friend class CDXTInputPin;
    friend class CDXTWrap;

    CDXTWrap *m_pFilter;

    IDXSurface *m_pDXSurface;

    CMyRaw *m_pRaw;	// object to initialize the surface

    IUnknown *m_pPosition;	// CPosPassThru
public:

    // Constructor and destructor

    CDXTOutputPin(TCHAR *pObjName,
                   CDXTWrap *pTee,
                   HRESULT *phr,
                   LPCWSTR pPinName);

    ~CDXTOutputPin();

    DECLARE_IUNKNOWN

    // CPosPassThru
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    HRESULT Active();
    HRESULT Inactive();

    //
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);
};

// Class for the DXTransform Wrapper filter

class CDXTWrap: public CCritSec, public CBaseFilter,
		public ISpecifyPropertyPages,
                public IPersistPropertyBag, public CPersistStream,
		public IAMMixEffect,
		public CAMSetErrorLog,
		// for non-Dexter DXT wrapper
		public IAMDXTEffect
{

    DECLARE_IUNKNOWN

    QPARAMDATA *m_pQHead;			// list of cued effects
#ifdef DEBUG
    HRESULT DumpQ();
#endif

    IUnknown *m_punkDXTransform;
    CAUUID m_TransCAUUID;
    GUID m_DefaultEffect;

    BOOL m_fDXTMode;			// instantiated as the old DXT wrapper?

    IDirectDraw *m_pDDraw;
    IDXTransformFactory *m_pDXTransFact;

    // Let the pins access our internal state
    friend class CDXTInputPin;
    friend class CDXTOutputPin;

    // Declare an input pin.
    CDXTInputPin *m_apInput[MAX_EFFECT_INPUTS];
    int m_cInputs;
    CDXTOutputPin *m_apOutput[MAX_EFFECT_INPUTS];
    int m_cOutputs;

    CCritSec m_csDoSomething;
    HRESULT DoSomething();	// the heart that calls the transform
    HRESULT PrimeEffect(REFERENCE_TIME);// set up the correct effect

    AM_MEDIA_TYPE m_mtAccept;

    BYTE *m_pTempBuffer;	// when doing >1 transform at a time

public:

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // This stuff is for the non-dexter DXT wrapper
    // ISpecifyPropertyPages methods
    STDMETHODIMP GetPages(CAUUID *pPages);

    // IAMDXTEffect stuff
    STDMETHODIMP SetDuration(LONGLONG llStart, LONGLONG llStop);
    STDMETHODIMP GetDuration(LONGLONG *pllStart, LONGLONG *pllStop);

    // IAMMixEffect stuff
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP SetNumInputs(int iNumInputs);
    STDMETHODIMP QParamData(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop,
		REFGUID guid, IUnknown *pEffect, DEXTER_PARAM_DATA *pData);
    STDMETHODIMP Reset();
    STDMETHODIMP SetDefaultEffect(GUID *);

    CDXTWrap(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CDXTWrap();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    // Send EndOfStream if no input connection
    //STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Pause();
    STDMETHODIMP Stop();

    // IPersistPropertyBag methods
    STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);
    STDMETHODIMP InitNew();

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();
};


// this stuff is for the non-Dexter DXT wrapper
// property page class to show list of installed effects
//
class CPropPage : public CBasePropertyPage
{
    IAMDXTEffect *m_pOpt;    	// object that we are showing options from
    HWND m_hwnd;

public:

   CPropPage(TCHAR *, LPUNKNOWN, HRESULT *);

   // create a new instance of this class
   //
   static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

   HRESULT OnConnect(IUnknown *pUnknown);
   HRESULT OnDisconnect();
   HRESULT OnApplyChanges();
   INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
};

#endif // __DXTWRAP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\dxtwrap\resource.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#define IDS_NAME	200
#define IDD_PROPERTIES  201
#define IDC_EFFECTLIST  202
#define IDC_STARTTIME  	203
#define IDC_ENDTIME  	204
#define IDC_CONSTANT  	205
#define IDC_VARIES  	206
#define IDC_LEVEL  	207
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\dxtjpegpp.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxtjpegpp.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtJpegPP.h : Declaration of the CDxtJpegPP

#ifndef __DXTJPEGPP_H_
#define __DXTJPEGPP_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_DxtJpegPP;

/////////////////////////////////////////////////////////////////////////////
// CDxtJpegPP
class ATL_NO_VTABLE CDxtJpegPP :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDxtJpegPP, &CLSID_DxtJpegPP>,
	public IPropertyPageImpl<CDxtJpegPP>,
	public CDialogImpl<CDxtJpegPP>
{
public:
	CDxtJpegPP() 
	{
		m_dwTitleID = IDS_TITLEDxtJpegPP;
		m_dwHelpFileID = IDS_HELPFILEDxtJpegPP;
		m_dwDocStringID = IDS_DOCSTRINGDxtJpegPP;
    m_bNumOverFile = TRUE;
	}

	enum {IDD = IDD_DXTJPEGPP};

DECLARE_REGISTRY_RESOURCEID(IDR_DXTJPEGPP)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDxtJpegPP) 
#if(_ATL_VER < 0x0300)
	COM_INTERFACE_ENTRY_IMPL(IPropertyPage)
#else
	COM_INTERFACE_ENTRY(IPropertyPage)
#endif
END_COM_MAP()

BEGIN_MSG_MAP(CDxtJpegPP)
        COMMAND_HANDLER(IDC_NUMOVERFILE, BN_CLICKED, OnNumOverFile)
        COMMAND_HANDLER(IDC_PICKFILE, BN_CLICKED, OnSelectFile)
        COMMAND_HANDLER(IDC_RESTOREDEFAULTS, BN_CLICKED, OnFactorySettings)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	CHAIN_MSG_MAP(IPropertyPageImpl<CDxtJpegPP>)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 
    LRESULT OnNumOverFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelectFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnFactorySettings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    STDMETHOD(Apply)(void);

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    // Helper methods
    void SetPPMaskProperties(IDxtJpeg *);
    void SetPPScalingProperties(IDxtJpeg *);
    void SetPPReplicationProperties(IDxtJpeg *);
    void SetPPBorderProperties(IDxtJpeg *);
    void SetMaskPropertiesFromPP(IDxtJpeg *);
    void SetScalingPropertiesFromPP(IDxtJpeg *);
    void SetPReplicationPropertiesFromPP(IDxtJpeg *);
    void SetBorderPropertiesFromPP(IDxtJpeg *);

    BOOL m_bWhyIsApplyCalledTwice;
    BOOL m_bNumOverFile;

};


#endif //__DXTJPEGPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\dxtjpeg.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxtjpeg.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtJpeg.cpp : Implementation of CDxtJpeg
#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "DxtJpeg.h"
#include "..\util\filfuncs.h"
#include "..\util\dexmisc.h"
#pragma warning (disable:4244)

/////////////////////////////////////////////////////////////////////////////
// CDxtJpeg

CDxtJpeg::CDxtJpeg( )
{
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_pInBufA = NULL;
    m_pInBufB = NULL;
    m_pOutBuf = NULL;
    m_pMaskBuf = NULL;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
    m_szMaskName[0] = 0;
    m_nMaskNum = 1;
    m_pisImageRes = NULL;
    m_bFlipMaskH = FALSE;
    m_bFlipMaskV = FALSE;
    m_pidxsRawMask = NULL;
    m_ulMaskWidth = 0;
    m_ulMaskHeight = 0;

    memset(&m_ddsd, 0, sizeof(m_ddsd));

    m_ddsd.dwSize = sizeof(m_ddsd);
    m_ddsd.dwFlags = DDSD_CAPS | DDSD_PIXELFORMAT;
    m_ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
    m_ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    m_ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
    m_ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
    m_ddsd.ddpfPixelFormat.dwRBitMask = 0x00ff0000;
    m_ddsd.ddpfPixelFormat.dwGBitMask = 0x0000ff00;
    m_ddsd.ddpfPixelFormat.dwBBitMask = 0x000000ff;

    m_dwFlush = 0x0;

    LoadDefSettings();
    //Initialize GDI +
    GdiplusStartupInput gdiplusStartupInput;
    GdiplusStartup (&m_GdiplusToken, &gdiplusStartupInput, NULL);

    
}

CDxtJpeg::~CDxtJpeg( )
{
    FreeStuff( );

    // keep this cached
    if (m_pidxsRawMask)
      m_pidxsRawMask->Release();
    GdiplusShutdown(m_GdiplusToken);


    
}

void CDxtJpeg::FreeStuff( )
{
    if( m_pInBufA ) delete [] m_pInBufA;
    m_pInBufA = NULL;
    if( m_pInBufB ) delete [] m_pInBufB;
    m_pInBufB = NULL;
    if( m_pOutBuf ) delete [] m_pOutBuf;
    m_pOutBuf = NULL;
    if( m_pMaskBuf ) delete [] m_pMaskBuf;
    m_pMaskBuf = NULL;

    if (m_pisImageRes)
      m_pisImageRes->Release();
    m_pisImageRes = NULL;

    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
}

STDMETHODIMP CDxtJpeg::get_MaskNum(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }
    *pVal = m_nMaskNum;
    return S_OK;
}

STDMETHODIMP CDxtJpeg::put_MaskNum(long newVal)
{
    if (newVal < 0)
    {
        return E_INVALIDARG;
    }
    DbgLog((LOG_TRACE,2,TEXT("JPEG::put_MaskNum to %d"), (int)newVal));
    m_nMaskNum = newVal;
    m_dwFlush |= MASK_FLUSH_CHANGEMASK;
    m_szMaskName[0] = TCHAR('\0');
    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_MaskName(BSTR *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }
    *pVal = SysAllocString( m_szMaskName );

    if (!pVal)
        return E_OUTOFMEMORY;

    return S_OK;
}

STDMETHODIMP CDxtJpeg::put_MaskName(BSTR newVal)
{

    HRESULT hr = ValidateFilename(newVal, _MAX_PATH, FALSE);
    if (FAILED (hr))
    {
        return hr;
    }

    if (DexCompareW(m_szMaskName, newVal))
    {
        DbgLog((LOG_TRACE,2,TEXT("JPEG::put_MaskName")));
        lstrcpyW( m_szMaskName, newVal );     // Safe, we validated above.
        m_dwFlush |= MASK_FLUSH_CHANGEMASK;
    }

    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_ScaleX(double *pvalue)
{
    if(DXIsBadWritePtr(pvalue, sizeof(*pvalue)))
      return E_POINTER;

    *pvalue = m_xScale;
    return S_OK;
}

STDMETHODIMP CDxtJpeg::put_ScaleX(double value)
{
      if (m_xScale != value)
      {
          m_xScale = value;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_ScaleY(double *pvalue)
{
    if(DXIsBadWritePtr(pvalue, sizeof(*pvalue)))
      return E_POINTER;

    *pvalue = m_yScale;
    return NOERROR;
}

STDMETHODIMP CDxtJpeg::put_ScaleY(double value)
{
    if (m_yScale != value)
      {
          m_yScale = value;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_OffsetX(long *pvalue )
{
    if(DXIsBadWritePtr(pvalue, sizeof(*pvalue)))
      return E_POINTER;

    *pvalue = m_xDisplacement;
    return S_OK;
}

STDMETHODIMP CDxtJpeg::put_OffsetX(long value)
{
    if (m_xDisplacement != value)
      {
          m_xDisplacement = value;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_OffsetY(long *pvalue)
{
    if(DXIsBadWritePtr(pvalue, sizeof(*pvalue)))
      return E_POINTER;

    *pvalue = m_yDisplacement;
    return NOERROR;
}

STDMETHODIMP CDxtJpeg::put_OffsetY(long value)
{
    if (m_yDisplacement != value)
      {
          m_yDisplacement = value;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

    return S_OK;
}

STDMETHODIMP CDxtJpeg::get_ReplicateX(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }

    *pVal = m_ReplicateX;

	  return S_OK;
}

STDMETHODIMP CDxtJpeg::put_ReplicateX(long newVal)
{
    if (m_ReplicateX != newVal)
      {
          m_ReplicateX = newVal;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

	  return S_OK;
}

STDMETHODIMP CDxtJpeg::get_ReplicateY(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }

    *pVal = m_ReplicateY;
	return S_OK;
}

STDMETHODIMP CDxtJpeg::put_ReplicateY(long newVal)
{
    if (m_ReplicateY != newVal)
      {
          m_ReplicateY = newVal;
          m_dwFlush |= MASK_FLUSH_CHANGEPARMS;
      }

	  return S_OK;
}

STDMETHODIMP CDxtJpeg::get_BorderColor(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }

  *pVal = 0;

  *pVal = (m_rgbBorder.rgbRed << 16)+(m_rgbBorder.rgbGreen << 8)+m_rgbBorder.rgbBlue;

	return S_OK;
}

STDMETHODIMP CDxtJpeg::put_BorderColor(long newVal)
{
        m_rgbBorder.rgbRed = (BYTE)((newVal & 0xFF0000) >> 16);
        m_rgbBorder.rgbGreen = (BYTE)((newVal & 0xFF00) >> 8);
        m_rgbBorder.rgbBlue = (BYTE)(newVal & 0xFF);
	return S_OK;
}

STDMETHODIMP CDxtJpeg::get_BorderWidth(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }

    *pVal = m_lBorderWidth;

	  return S_OK;
}

STDMETHODIMP CDxtJpeg::put_BorderWidth(long newVal)
{
    if (newVal != m_lBorderWidth) {
        m_lBorderWidth = newVal;
    }
    return S_OK;
}


STDMETHODIMP CDxtJpeg::get_BorderSoftness(long *pVal)
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) )
    {
        return E_POINTER;
    }

    *pVal = m_lBorderSoftness;

	  return S_OK;
}

STDMETHODIMP CDxtJpeg::put_BorderSoftness(long newVal)
{
    if (newVal != m_lBorderSoftness) {
        m_lBorderSoftness = newVal;
    }
    return S_OK;
}

HRESULT CDxtJpeg::OnSetup( DWORD dwFlags )
{
    DbgLog((LOG_TRACE,2,TEXT("JPEG::OnSetup")));

    // delete any stored stuff we have, or memory allocated
    FreeStuff( );

    HRESULT hr = NOERROR;

    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    // Load default mask (#1) if nothing...
    if ((m_nMaskNum == 0) && !lstrlenW(m_szMaskName))
      {
        m_dwFlush |= MASK_FLUSH_CHANGEMASK;
        m_nMaskNum = 1;
      }

    return InitializeMask();
}

HRESULT CDxtJpeg::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    DbgLog((LOG_TRACE,3,TEXT("JPEG::WorkProc")));

    if (m_dwFlush) {
        DbgLog((LOG_TRACE,2,TEXT("JPEG::Options have changed!")));
	InitializeMask();
    }

    // !!! Doesn't support non-complete bounds

    HRESULT hr = S_OK;

    //--- Get input sample access pointer for the requested region.
    //    Note: Lock may fail due to a lost surface.

    CComPtr<IDXARGBReadPtr> pInA = NULL;
    CComPtr<IDXARGBReadPtr> pInB = NULL;
    DXSAMPLE * pInBufA = NULL;
    DXSAMPLE * pInBufB = NULL;

    long cInputSamples = m_nInputHeight * m_nInputWidth;

    hr = InputSurface( 0 )->LockSurface
        (NULL,
        m_ulLockTimeOut,
        DXLOCKF_READ,
        IID_IDXARGBReadPtr,
        (void**)&pInA,
        NULL
        );
    if( FAILED( hr ) )
    {
        return hr;
    }

// !!! avoid a copy if it's natively 32 bit?

    MakeSureBufAExists( cInputSamples );
    pInBufA = m_pInBufA;
    DXPACKEDRECTDESC x;
    x.pSamples = m_pInBufA;
    x.bPremult = FALSE;
    x.rect.top = 0; x.rect.left = 0;
    x.rect.bottom = m_nInputHeight;
    x.rect.right = m_nInputWidth;
    x.lRowPadding = 0;
    pInA->UnpackRect(&x);

    hr = InputSurface( 1 )->LockSurface
        (NULL,
        m_ulLockTimeOut,
        DXLOCKF_READ,
        IID_IDXARGBReadPtr,
        (void**)&pInB,
        NULL
        );
    if( FAILED( hr ) )
    {
        return hr;
    }

// !!! avoid a copy if it's natively 32 bit?

    MakeSureBufBExists( cInputSamples );
    pInBufB = m_pInBufB;
    x.pSamples = m_pInBufB;
    x.bPremult = FALSE;
    x.rect.top = 0; x.rect.left = 0;
    x.rect.bottom = m_nInputHeight;
    x.rect.right = m_nInputWidth;
    x.lRowPadding = 0;
    pInB->UnpackRect(&x);

    // no dithering !!!

    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface
        (NULL, // !!! &WI.OutputBnds,
        m_ulLockTimeOut,
        DXLOCKF_READWRITE,
        IID_IDXARGBReadWritePtr,
        (void**)&pOut,
        NULL
        );

    if( FAILED( hr ) )
    {
        return hr;
    }

    // output surface may not be the same size as the input surface
    //

    // !!! SCARY !!!

    IDXSurface * pOutSurface = NULL;
    pOut->GetSurface( IID_IDXSurface, (void**) &pOutSurface );
    DXBNDS RealOutBnds;
    pOutSurface->GetBounds( &RealOutBnds );
    pOutSurface->Release();
    CDXDBnds RealOutBnds2( RealOutBnds );
    long RealOutWidth = RealOutBnds2.Width( );
    long RealOutHeight = RealOutBnds2.Height( );

    // we'll do the effect on a buffer that's as big as our
    // inputs, then pack it into the destination

    // make sure the buffer's big enough
    //
    MakeSureOutBufExists( cInputSamples );

    // do the effect
    //
    DoEffect( m_pOutBuf, pInBufA, pInBufB, cInputSamples );

    // if the output is bigger than our input, then fill it first
    // !!! don't fill the whole thing!
    if (RealOutHeight > m_nInputHeight || RealOutWidth > m_nInputWidth) {

        RECT rc;
        rc.left = 0;
        rc.top = 0;
        rc.right = RealOutWidth;
        rc.bottom = RealOutHeight;
        DXPMSAMPLE FillValue;
        FillValue.Blue = 0;
        FillValue.Red = 0;
        FillValue.Green = 0;
        FillValue.Alpha = 0;
        pOut->FillRect( &rc, FillValue, false );
    }


    DXPACKEDRECTDESC PackedRect;
    RECT rc;

    int h = min(RealOutHeight, m_nInputHeight);
    int w = min(RealOutWidth, m_nInputWidth);
    rc.left = RealOutWidth / 2 - w / 2;
    rc.top = RealOutHeight /2 - h / 2;
    rc.right = rc.left + w;
    rc.bottom = rc.top + h;
    PackedRect.pSamples = (DXBASESAMPLE*)m_pOutBuf;
    if (m_nInputHeight > RealOutHeight)
        PackedRect.pSamples += ((m_nInputHeight - RealOutHeight) / 2) *
                m_nInputWidth;
    if (m_nInputWidth > RealOutWidth)
        PackedRect.pSamples += (m_nInputWidth - RealOutWidth) / 2;
    PackedRect.bPremult = true;
    PackedRect.rect = rc;
    if (m_nInputWidth > RealOutWidth)
        PackedRect.lRowPadding = m_nInputWidth - RealOutWidth;
    else
        PackedRect.lRowPadding = 0;

    pOut->PackRect( &PackedRect );

    return S_OK;
}

HRESULT CDxtJpeg::MakeSureBufAExists( long Samples )
{
    // If it exists, it must be the right size already
    if( m_pInBufA )
    {
        return NOERROR;
    }
    m_pInBufA = new DXSAMPLE[ Samples ];
    if( !m_pInBufA )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtJpeg::MakeSureBufBExists( long Samples )
{

    // If it exists, it must be the right size already
    if( m_pInBufB )
    {
        return NOERROR;
    }
    m_pInBufB = new DXSAMPLE[ Samples ];
    if( !m_pInBufB )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtJpeg::MakeSureOutBufExists( long Samples )
{

    // If it exists, it must be the right size already

    if( m_pOutBuf )
    {
        return NOERROR;
    }
    m_pOutBuf = new DXSAMPLE[ Samples ];
    if( !m_pOutBuf )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

HRESULT CDxtJpeg::DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples )
{
    if( !m_pMaskBuf )
    {
        return NOERROR;
    }

    float Percent = 0.5;
    get_Progress( &Percent );

    long Threshold = long((256+m_lBorderWidth+m_lBorderSoftness)*Percent)-(m_lBorderWidth+m_lBorderSoftness);

    DXSAMPLE *pA    = pInA;
    DXSAMPLE *pB    = pInB;
    DXSAMPLE *pO    = pOut;
    DXSAMPLE *pMask = m_pMaskBuf;

    DXSAMPLE bc;  // border coloring

    bc.Red = m_rgbBorder.rgbRed;
    bc.Green = m_rgbBorder.rgbGreen;
    bc.Blue = m_rgbBorder.rgbBlue;
    bc.Alpha = 0;

    for (long i = 0; i < Samples; ++i)
      {
        long avg = pMask->Blue;
        long diff = avg - Threshold;

        if( ( diff >= 0 ) && ( diff < m_lBorderWidth+m_lBorderSoftness ) )
        {
            if( m_lBorderWidth == 0 )
            {
                // do an anti-alias based on the difference
                //
                float p = float( diff ) / float( m_lBorderSoftness );
                pO->Blue = (BYTE)(pA->Blue * p + pB->Blue * ( 1.0 - p ));
                pO->Green = (BYTE)(pA->Green * p + pB->Green * ( 1.0 - p ));
                pO->Red = (BYTE)(pA->Red * p + pB->Red * ( 1.0 - p ));
                pO->Alpha = 0;

            }
            else if ( m_lBorderSoftness == 0 )
            {
                pO->Blue = bc.Blue;
                pO->Green = bc.Green;
                pO->Red = bc.Red;
                pO->Alpha = 0;
            }
            else /* both border width and softness */
            {
                if (diff < m_lBorderSoftness/2)  // Blending BC->B
                    {
                      float p = float(diff) / float(m_lBorderSoftness/2);
                      pO->Blue = (BYTE)(bc.Blue * p + pB->Blue * ( 1.0 - p ));
                      pO->Green = (BYTE)(bc.Green * p + pB->Green * ( 1.0 - p ));
                      pO->Red = (BYTE)(bc.Red * p + pB->Red * ( 1.0 - p ));
                      pO->Alpha = 0;
                    }

                else if (diff >= m_lBorderWidth + m_lBorderSoftness/2)  // Blending A->BC
                    {
                      diff -= m_lBorderWidth + m_lBorderSoftness/2;
                      float p = float(diff) / float(m_lBorderSoftness/2);
                      pO->Blue = (BYTE)(pA->Blue * p + bc.Blue * ( 1.0 - p ));
                      pO->Green = (BYTE)(pA->Green * p + bc.Green * ( 1.0 - p ));
                      pO->Red = (BYTE)(pA->Red * p + bc.Red * ( 1.0 - p ));
                      pO->Alpha = 0;
                    }

                else
                    { // Border
                      pO->Blue = bc.Blue;
                      pO->Green = bc.Green;
                      pO->Red = bc.Red;
                      pO->Alpha = bc.Alpha;
                    }
            }

        }
        else
        {
            if( avg >= Threshold )
            {
                *pO = *pA;
            }
            else
            {
                *pO = *pB;
            }
        }
        ++pA;
        ++pB;
        ++pO;
        ++pMask;
      }

    return NOERROR;
}

HRESULT CDxtJpeg::InitializeMask( )
{
    // do we need to do anything?
    if (m_dwFlush == 0)
	return S_OK;

    HRESULT hr = NOERROR;

    if (m_dwFlush & (MASK_FLUSH_CHANGEMASK)) {
      if (409 == m_nMaskNum)
          hr = CreateRandomMask();
      else
          hr = LoadMaskResource();
    }

    if(FAILED(hr))
      return hr;

    m_dwFlush = 0;

    // !!! must call - sets m_pidxsMask
    hr = ScaleByDXTransform();	// do displacement, scale, offset, & replicate

    if (FAILED(hr))
      return hr;

    ULONG GenID = 0;
    IDXARGBReadPtr * pRgbPtr = NULL;

    hr = m_pidxsMask->LockSurface(
        NULL,
        INFINITE,
        DXLOCKF_READ,
        IID_IDXARGBReadPtr,
        (void**) &pRgbPtr,
        &GenID
        );

    if( m_pMaskBuf )
    {
        delete [] m_pMaskBuf;
    }

    m_pMaskBuf = new DXSAMPLE[m_nInputWidth*m_nInputHeight];

    if (NULL == m_pMaskBuf)
        return E_OUTOFMEMORY;

    DXPACKEDRECTDESC dpdd;

    dpdd.pSamples = m_pMaskBuf;
    dpdd.bPremult = FALSE;
    dpdd.rect.top = 0;
    dpdd.rect.left = 0;
    dpdd.rect.bottom = m_nInputHeight;
    dpdd.rect.right = m_nInputWidth;
    dpdd.lRowPadding = 0;

    pRgbPtr->UnpackRect(&dpdd);
    pRgbPtr->Release();

    m_pidxsMask->Release();
    m_pidxsMask = NULL;

    RescaleGrayscale();

    m_dwFlush = 0x00;

    return NOERROR;
}

void CDxtJpeg::MapMaskToResource(long *lMaskNum)
{

  m_bFlipMaskH = FALSE;
  m_bFlipMaskV = FALSE;

  switch(*lMaskNum)

    {

      case   1: /* Base images */
      case   2:
      case   3:
      case   7:
      case   8:
      case  21:
      case  22:
      case  23:
      case  24:
      case  41:
      case  43:
      case  44:
      case  45:
      case  47:
      case  48:
      case  61:
      case  62:
      case  65:
      case  66:
      case  71:
      case  72:
      case  73:
      case  74:
      case 101:
      case 102:
      case 103:
      case 104:
      case 107:
      case 108:
      case 111:
      case 113:
      case 114:
      case 119:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124:
      case 125:
      case 127:
      case 128:
      case 129:
      case 130:
      case 131:
      case 201:
      case 202:
      case 205:
      case 206:
      case 207:
      case 221:
      case 211:
      case 212:
      case 213:
      case 214:
      case 222:
      case 225:
      case 226:
      case 227:
      case 228:
      case 231:
      case 232:
      case 235:
      case 236:
      case 241:
      case 245:
      case 246:
      case 251:
      case 252:
      case 261:
      case 262:
      case 263:
      case 264:
      case 301:
      case 302:
      case 303:
      case 310:
      case 311:
      case 320:
      case 322:
      case 324:
      case 326:
      case 328:
      case 340:
      case 342:
      case 344:
      case 345:
      case 350:
      case 352:
      case 409:
        break;

      case   4: *lMaskNum = 3;   m_bFlipMaskH = TRUE; break;
      case   5: *lMaskNum = 3;   m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case   6: *lMaskNum = 3;   m_bFlipMaskV = TRUE; break;
      case  25: *lMaskNum = 23;  m_bFlipMaskV = TRUE; break;
      case  26: *lMaskNum = 24;  m_bFlipMaskH = TRUE; break;
      case  42: *lMaskNum = 41;  m_bFlipMaskH = TRUE; break;
      case  46: *lMaskNum = 45;  m_bFlipMaskH = TRUE; break;
      case  63: *lMaskNum = 61;  m_bFlipMaskV = TRUE; break;
      case  64: *lMaskNum = 62;  m_bFlipMaskH = TRUE; break;
      case  67: *lMaskNum = 65;  m_bFlipMaskV = TRUE; break;
      case  68: *lMaskNum = 66;  m_bFlipMaskH = TRUE; break;
      case 105: *lMaskNum = 103; m_bFlipMaskV = TRUE; break;
      case 106: *lMaskNum = 104; m_bFlipMaskH = TRUE; break;
      case 109: *lMaskNum = 107; m_bFlipMaskV = TRUE; break;
      case 110: *lMaskNum = 108; m_bFlipMaskH = TRUE; break;
      case 112: *lMaskNum = 111; m_bFlipMaskV = TRUE; break;
      case 203: *lMaskNum = 201; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 204: *lMaskNum = 202; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 223: *lMaskNum = 221; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 224: *lMaskNum = 222; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 233: *lMaskNum = 231; m_bFlipMaskV = TRUE; break;
      case 234: *lMaskNum = 232; m_bFlipMaskH = TRUE; break;
      case 242: *lMaskNum = 241; m_bFlipMaskV = TRUE; break;
      case 243: *lMaskNum = 241; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 244: *lMaskNum = 241; m_bFlipMaskH = TRUE; break;
      case 253: *lMaskNum = 251; m_bFlipMaskV = TRUE; break;
      case 254: *lMaskNum = 252; m_bFlipMaskH = TRUE; break;
      case 304: *lMaskNum = 303; m_bFlipMaskH = TRUE; break;
      case 305: *lMaskNum = 303; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 306: *lMaskNum = 303; m_bFlipMaskV = TRUE; break;
      case 312: *lMaskNum = 310; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 313: *lMaskNum = 311; m_bFlipMaskH = TRUE; m_bFlipMaskV = TRUE; break;
      case 314: *lMaskNum = 311; m_bFlipMaskH = TRUE; break;
      case 315: *lMaskNum = 310; m_bFlipMaskH = TRUE; break;
      case 316: *lMaskNum = 311; m_bFlipMaskV = TRUE; break;
      case 317: *lMaskNum = 310; m_bFlipMaskV = TRUE; break;
      case 321: *lMaskNum = 320; m_bFlipMaskV = TRUE; break;
      case 323: *lMaskNum = 322; m_bFlipMaskV = TRUE; break;
      case 325: *lMaskNum = 324; m_bFlipMaskH = TRUE; break;
      case 327: *lMaskNum = 326; m_bFlipMaskH = TRUE; break;
      case 329: *lMaskNum = 328; m_bFlipMaskH = TRUE; break;
      case 341: *lMaskNum = 340; m_bFlipMaskV = TRUE; break;
      case 343: *lMaskNum = 342; m_bFlipMaskH = TRUE; break;
      case 351: *lMaskNum = 350; m_bFlipMaskH = TRUE; break;
      case 353: *lMaskNum = 352; m_bFlipMaskH = TRUE; break;

      default:
        *lMaskNum = 1; m_bFlipMaskH = FALSE; m_bFlipMaskV = FALSE;

    }
}

void CDxtJpeg::FlipSmpteMask()
{
    DbgLog((LOG_TRACE,2,TEXT("JPEG::Flip mask")));
    IDXARGBReadWritePtr *prw = NULL;

    ULONG GenID = 0;

    HRESULT hr = m_pidxsRawMask->LockSurface(
        NULL,
        INFINITE,
        DXLOCKF_READWRITE,
        IID_IDXARGBReadWritePtr,
        (void**)&prw,
        &GenID
        );

    DXSAMPLE *pMask = new DXSAMPLE[m_ulMaskWidth*m_ulMaskHeight];

    DXPACKEDRECTDESC x;
    x.pSamples = pMask;
    x.bPremult = FALSE;
    x.rect.top = 0; x.rect.left = 0;
    x.rect.bottom = m_ulMaskHeight;
    x.rect.right = m_ulMaskWidth;
    x.lRowPadding = 0;
    prw->UnpackRect(&x);

    DXSAMPLE *dxs = new DXSAMPLE[m_ulMaskWidth];

    DWORD dwRow1Start = 0;
    DWORD dwRow2Start = m_ulMaskWidth*(m_ulMaskHeight-1);
    DWORD dwNumBytes = sizeof(DXSAMPLE)*m_ulMaskWidth;

    if (m_bFlipMaskV) {
      for (unsigned int h = 0; h < m_ulMaskHeight/2; ++h)
        {
          CopyMemory(&dxs[0], &pMask[dwRow1Start], dwNumBytes);
          CopyMemory(&pMask[dwRow1Start], &pMask[dwRow2Start], dwNumBytes);
          CopyMemory(&pMask[dwRow2Start], &dxs[0], dwNumBytes);
          dwRow1Start += m_ulMaskWidth;
          dwRow2Start -= m_ulMaskWidth;
        }
    }

    if (m_bFlipMaskH) {
      for (unsigned int h = 0; h < m_ulMaskHeight; ++h)
        {
          CopyMemory(dxs, &pMask[h * m_ulMaskWidth], dwNumBytes);
          for (unsigned int w = 0; w < m_ulMaskWidth / 2; ++w)
            {
	      pMask[h * m_ulMaskWidth + w] = pMask[(h+1)*m_ulMaskWidth - 1 - w];
	      pMask[(h+1)*m_ulMaskWidth - 1 - w] = dxs[w];
            }
        }
    }

    x.bPremult = TRUE;	// faster?
    prw->PackRect(&x);

    prw->Release();

    delete [] dxs;
    delete [] pMask;
}

HRESULT CDxtJpeg::ScaleByDXTransform()
{
    // this function uses m_xScale and m_yScale to determine aspect
    // ratio. m_offsetx and m_offsety causes scaling because we can't
    // clip.

    DbgLog((LOG_TRACE,2,TEXT("JPEG::Scale and Parameterize")));
    float pc1 = m_nInputWidth / (float)m_ReplicateX;     // Precalc (save away resultant)
    float pc2 = m_nInputHeight / (float)m_ReplicateY;    // Precalc (save away resultant)
    float xp0 = pc1+abs(m_xDisplacement)*2;
    float yp0 = pc2+abs(m_yDisplacement)*2;
    float xm0 = m_ulMaskWidth*m_xScale;
    float ym0 = m_ulMaskHeight*m_yScale;

    float xm1;
    float ym1;

    if ((xp0/yp0) >= (xm0/ym0))
      { xm1 = xp0; ym1 = (xp0*ym0)/xm0; }
    else
      { ym1 = yp0; xm1 = (yp0*xm0)/ym0; }

    float x_off = (xm1/2)-m_xDisplacement-(pc1/2);
    float y_off = (ym1/2)-m_yDisplacement-(pc2/2);

    float origin_x = (x_off*m_ulMaskWidth)/xm1;
    float origin_y = (y_off*m_ulMaskHeight)/ym1;

    float extent_x = (pc1*m_ulMaskWidth)/xm1;
    float extent_y = (pc2*m_ulMaskHeight)/ym1;


    CDXDBnds bounds;
    bounds.SetXYSize(m_nInputWidth, m_nInputHeight);

    HRESULT hr = m_cpSurfFact->CreateSurface(
      NULL,
      NULL,
      &DDPF_PMARGB32,
      &bounds,
      0,
      NULL,
      IID_IDXSurface,
      (void**)&m_pidxsMask);

    if(FAILED(hr)) {
        return hr;
    }

    CComPtr<IDXDCLock> pDCLockSrc, pDCLockDest;
    hr = m_pidxsRawMask->LockSurfaceDC(0, INFINITE, DXLOCKF_READ, &pDCLockSrc);
    if(SUCCEEDED(hr)) {
        hr = m_pidxsMask->LockSurfaceDC(0, INFINITE, DXLOCKF_READWRITE, &pDCLockDest);
    }

    if(SUCCEEDED(hr))
    {
        HDC hdcSrc = pDCLockSrc->GetDC();
        HDC hdcDest = pDCLockDest->GetDC();

        // if lock succeeded, we should have a DC
        ASSERT(hdcSrc && hdcDest);

        int x = SetStretchBltMode(hdcDest, COLORONCOLOR);
        ASSERT(x != 0);

        float x1 = 0, y1 = 0;

        for (long i1 = 0; i1 < m_ReplicateY; ++i1)
        {
            // adjust width to compensate for uneven multiples.
            int yWidth = (int)(y1 + pc2 + 0.5) - (int)y1;

            for (long i2 = 0; i2 < m_ReplicateX; ++i2)
            {
                int xWidth = (int)(x1 + pc1 + 0.5) - (int)x1;

                StretchBlt(hdcDest, x1, y1, xWidth, yWidth,
                           hdcSrc, origin_x, origin_y, extent_x, extent_y,
                           SRCCOPY);
                x1 += pc1;
            }
            y1 += pc2;
            x1 = 0;
        }
    }

    if(FAILED(hr))
    {
        m_pidxsMask->Release();
        m_pidxsMask = 0;
    }

    return hr;
}

HRESULT CDxtJpeg::LoadMaskResource()
{
  HRESULT hr = E_FAIL;

  if (m_pidxsRawMask)
    {
        m_pidxsRawMask->Release();
        m_pidxsRawMask = NULL;
    }

  if( ( m_szMaskName[0] == 0 ) && ( m_nMaskNum > 0 ) )

    { // Mask from QEDWIPES.DLL

      long lFakeMask = m_nMaskNum;
      MapMaskToResource(&lFakeMask);

      HINSTANCE m_hMR;
      

      if (NULL == (m_hMR = LoadLibraryEx(TEXT("qedwipes.dll"),0 ,LOAD_LIBRARY_AS_DATAFILE)))
        return hr;


      TCHAR tchResString[15];
      wsprintf(tchResString, TEXT("MASK%u"), lFakeMask);

      HRSRC hrcMask = FindResource (m_hMR, tchResString, TEXT("BINARY"));

      // We cannot use any shortcuts that read images from resource files 
      // because the images in the dll are in jpeg form and therefore are not considered
      // bitmaps.  The only way to get this image to the GDI + bitmap class is to put it in Global memory
      // then use an IStream.


      if (NULL != hrcMask)
      {
          HGLOBAL hgMask = LoadResource(m_hMR, hrcMask);
          BYTE *bMask = (BYTE *) LockResource (hgMask);

          long Size = SizeofResource(m_hMR, hrcMask);
          HGLOBAL hgMask2 = GlobalAlloc(GHND, Size );

          if (!hgMask2)
          {
              FreeLibrary (m_hMR);
              return E_OUTOFMEMORY;
          }

          BYTE *bS = (BYTE *)GlobalLock(hgMask2);
          if (!bS)
          {
              GlobalFree(hgMask2);
              FreeLibrary(m_hMR);
              return E_OUTOFMEMORY;
          }

          CopyMemory (bS, bMask, Size);
          
          CComPtr<IStream> pStream;

          hr = CreateStreamOnHGlobal(
              hgMask2,
              FALSE,        // I'll take care of that
              &pStream);
          if (FAILED (hr))
          {
              GlobalUnlock(hgMask2);
              GlobalFree(hgMask2);
              FreeLibrary(m_hMR);
              return E_OUTOFMEMORY;
          }

          hr = LoadJPEGImageFromStream (pStream, &m_pidxsRawMask);
          GlobalUnlock(hgMask2);
          GlobalFree(hgMask2);
      }
      
      FreeLibrary(m_hMR);

      if (FAILED (hr))
      {
          return hr;
      }
    } // Mask from QEDWIPES.DLL

    if (m_szMaskName[0] != 0)
    {
        USES_CONVERSION;
        TCHAR * tf = W2T( m_szMaskName );


        hr = LoadJPEGImageFromFile(tf,&m_pidxsRawMask);
        if (FAILED (hr))
        {
            return hr;
        }
        
    }

    if (SUCCEEDED(hr))
      {
        DXBNDS bounds;

        hr = m_pidxsRawMask->GetBounds(&bounds);

        CDXDBnds Bounds2(bounds);

        m_ulMaskWidth = Bounds2.Width();
        m_ulMaskHeight = Bounds2.Height();

        if (SUCCEEDED(hr) && (m_bFlipMaskV || m_bFlipMaskH))
          FlipSmpteMask();
      }

  return hr;
}

void CDxtJpeg::RescaleGrayscale()
{
  BYTE lowest = 0;
  BYTE highest = 0;

  DbgLog((LOG_TRACE,2,TEXT("JPEG::Rescale colours")));
  long Samples = m_nInputHeight*m_nInputWidth;
  for (long i = 0; i < Samples; ++i)
    {
      lowest = min(m_pMaskBuf[i].Blue, lowest);
      highest = max(m_pMaskBuf[i].Blue, highest);
    }

  float m = 255.0/(highest-lowest);	// for rescale to 0..255
  lowest = 0;
  highest = 0;

  for (i = 0; i < Samples; ++i)
  {
    m_pMaskBuf[i].Red = m_pMaskBuf[i].Green = m_pMaskBuf[i].Blue = (m_pMaskBuf[i].Green*m);
    lowest = min(m_pMaskBuf[i].Blue, lowest);
    highest = max(m_pMaskBuf[i].Blue, highest);
  }
}

HRESULT CDxtJpeg::LoadDefSettings()
{
    m_xDisplacement = 0;
    m_yDisplacement = 0;
    m_xScale = 1.0;
    m_yScale = 1.0;
    m_ReplicateX = 1;
    m_ReplicateY = 1;
    m_rgbBorder.rgbRed = 0;
    m_rgbBorder.rgbGreen = 0;
    m_rgbBorder.rgbBlue = 0;
    m_lBorderWidth = 0;
    m_lBorderSoftness = 0;

    m_dwFlush = MASK_FLUSH_CHANGEMASK;

    return NOERROR;
}

HRESULT CDxtJpeg::CreateRandomMask()
{
    CDXDBnds bounds;

    bounds.SetXYSize(m_nInputWidth, m_nInputHeight);

    if (m_pidxsRawMask)
      m_pidxsRawMask->Release();

    m_pidxsRawMask = NULL;

    HRESULT hr = m_cpSurfFact->CreateSurface(
      NULL,
      NULL,
      &MEDIASUBTYPE_RGB32,
      &bounds,
      0,
      NULL,
      IID_IDXSurface,
      (void**)&m_pidxsRawMask);

    if (FAILED(hr))
      return E_FAIL;

    CComPtr<IDXARGBReadWritePtr> prw = NULL;

    hr = m_pidxsRawMask->LockSurface(NULL,
        m_ulLockTimeOut,
        DXLOCKF_READWRITE,
        IID_IDXARGBReadWritePtr,
        (void**)&prw,
        NULL);

    if (FAILED(hr))
      return E_FAIL;

    unsigned long NumBlocksR = m_nInputWidth >> 4;
    unsigned long NumBlocksC = m_nInputHeight >> 4;
    unsigned long NumBlocks = NumBlocksR*NumBlocksC;

    UINT *BlockPattern = new UINT[NumBlocks];
    if( !BlockPattern )
    {
        return E_OUTOFMEMORY;
    }

    POINT *Point = new POINT[NumBlocks];
    if( !Point )
    {
        delete [] BlockPattern;
        return E_OUTOFMEMORY;
    }

    // "Randomness"
    for (unsigned int i = 0; i < NumBlocks; i++)
      {
        Point[i].x = (i % NumBlocksR)*16/*Block width*/;
        Point[i].y = (i/NumBlocksR)*16/*Block height*/;
        BlockPattern[i] = i;
      }

    unsigned SetLength = NumBlocks-1;
    while (SetLength > 0)
      {
        unsigned int pick = timeGetTime() % SetLength;
        unsigned int swap = BlockPattern[pick];
        BlockPattern[pick] = BlockPattern[SetLength];
        BlockPattern[SetLength] = swap;
        --SetLength;
      }

    DXPMSAMPLE *dxpm = new DXPMSAMPLE[16*16];

    DXPACKEDRECTDESC PackedRect;

    PackedRect.pSamples = dxpm;
    PackedRect.bPremult = FALSE;
    PackedRect.lRowPadding = 0;

    for (i = 0; i < NumBlocks; i++)
      {
        for (int s = 0; s < 16*16; ++s)
          {
            dxpm[s].Red = BYTE(i);
            dxpm[s].Green = BYTE(i);
            dxpm[s].Blue = BYTE(i);
            dxpm[s].Alpha = BYTE(0);
          }
        PackedRect.rect.top = Point[BlockPattern[i]].y;
        PackedRect.rect.left = Point[BlockPattern[i]].x;
        PackedRect.rect.bottom = PackedRect.rect.top+16;
        PackedRect.rect.right = PackedRect.rect.left+16;
        prw->PackRect(&PackedRect);
      }

	// init additional width and height members
    DXBNDS bounds2;
	
	hr = NOERROR;
    hr = m_pidxsRawMask->GetBounds(&bounds2);

	if(SUCCEEDED(hr))
	{
		CDXDBnds Bounds2(bounds2);

		// init the member vars, that are used in the DX Transform (for rescaling)
		m_ulMaskWidth = Bounds2.Width();
		m_ulMaskHeight = Bounds2.Height();
	}

	// clean up memory
    delete [] dxpm;
    delete [] BlockPattern;
    delete [] Point;

	// return success or failure
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\dxtjpeg.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxtjpeg.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtJpeg.h : Declaration of the CDxtJpeg

#ifndef __DXTJPEG_H_
#define __DXTJPEG_H_

#include "resource.h"       // main symbols
#include <dxatlpb.h>
#include <stdio.h>
//#define _INT32_DEFINED   // Keep jpeglib.h from redefining this
#include <gdiplus.h>
#include <qedit.h>
#include <qeditint.h>

using namespace Gdiplus;

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

/////////////////////////////////////////////////////////////////////////////
// CDxtJpeg
class ATL_NO_VTABLE CDxtJpeg : 
        public CDXBaseNTo1,
	public CComCoClass<CDxtJpeg, &CLSID_DxtJpeg>,
        public CComPropertySupport<CDxtJpeg>,
        public IPersistStorageImpl<CDxtJpeg>,
        public ISpecifyPropertyPagesImpl<CDxtJpeg>,
        public IPersistPropertyBagImpl<CDxtJpeg>,
	public IDispatchImpl<IDxtJpeg, &IID_IDxtJpeg, &LIBID_DexterLib>
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    DXSAMPLE * m_pInBufA;
    DXSAMPLE * m_pInBufB;
    DXSAMPLE * m_pOutBuf;
    DXSAMPLE * m_pMaskBuf;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;
    WCHAR m_szMaskName[_MAX_PATH];
    long m_nBorderMode;
    long m_nMaskNum;
    IStream *m_pisImageRes;
    BOOL m_bFlipMaskH;
    BOOL m_bFlipMaskV;
    long m_xDisplacement;
    long m_yDisplacement;
    double m_xScale;
    double m_yScale;
    long m_ReplicateX;
    long m_ReplicateY;

    IDXSurface *m_pidxsMask;
    IDXSurface *m_pidxsRawMask;

    unsigned long m_ulMaskWidth;
    unsigned long m_ulMaskHeight;

    RGBQUAD m_rgbBorder;

    long m_lBorderWidth;
    long m_lBorderSoftness;

    DDSURFACEDESC m_ddsd;

    DWORD m_dwFlush;
    
    ULONG_PTR   m_GdiplusToken;                 // GDI +


    // private helper method
    HRESULT LoadJPEGImage(Bitmap& bitJpeg,IDXSurface **ppSurface);
    HRESULT LoadJPEGImageFromFile (TCHAR * tFileName, IDXSurface **ppSurface);
    HRESULT LoadJPEGImageFromStream (IStream * pStream, IDXSurface **ppSurface);


public:
        DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
        DECLARE_REGISTER_DX_TRANSFORM(IDR_DXTJPEG, CATID_DXImageTransform)
        DECLARE_GET_CONTROLLING_UNKNOWN()
        DECLARE_POLY_AGGREGATABLE(CDxtJpeg)

	CDxtJpeg();
        ~CDxtJpeg();

// DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDxtJpeg)
        // Block CDXBaseNTo1 IObjectSafety implementation because we
        // aren't safe for scripting
        COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
	COM_INTERFACE_ENTRY(IDxtJpeg)
	COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXEffect)
#if(_ATL_VER < 0x0300)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
#else
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
#endif
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDxtJpeg)
    PROP_ENTRY("MaskNum", 1, CLSID_DxtJpegPP)
    PROP_ENTRY("MaskName", 2, CLSID_DxtJpegPP)
    PROP_ENTRY("ScaleX", 3, CLSID_DxtJpegPP)
    PROP_ENTRY("ScaleY", 4, CLSID_DxtJpegPP)
    PROP_ENTRY("OffsetX", 5, CLSID_DxtJpegPP)
    PROP_ENTRY("OffsetY", 6, CLSID_DxtJpegPP)
    PROP_ENTRY("ReplicateX", 7, CLSID_DxtJpegPP)
    PROP_ENTRY("ReplicateY", 8, CLSID_DxtJpegPP)
    PROP_ENTRY("BorderColor", 9, CLSID_DxtJpegPP)
    PROP_ENTRY("BorderWidth", 10, CLSID_DxtJpegPP)
    PROP_ENTRY("BorderSoftness", 11, CLSID_DxtJpegPP)
    PROP_PAGE(CLSID_DxtJpegPP)
END_PROPERTY_MAP()

    STDMETHOD(get_MaskNum)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_MaskNum)(/*[in]*/ long newVal);
    STDMETHOD(get_MaskName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_MaskName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ScaleX)(double *);
    STDMETHOD(put_ScaleX)(double);
    STDMETHOD(get_ScaleY)(double *);
    STDMETHOD(put_ScaleY)(double);
    STDMETHOD(get_OffsetX)(long *);
    STDMETHOD(put_OffsetX)(long);
    STDMETHOD(get_OffsetY)(long *);
    STDMETHOD(put_OffsetY)(long);
    STDMETHOD(get_ReplicateY)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_ReplicateY)(/*[in]*/ long newVal);
    STDMETHOD(get_ReplicateX)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_ReplicateX)(/*[in]*/ long newVal);
    STDMETHOD(get_BorderColor)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_BorderColor)(/*[in]*/ long newVal);
    STDMETHOD(get_BorderWidth)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_BorderWidth)(/*[in]*/ long newVal);
    STDMETHOD(get_BorderSoftness)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_BorderSoftness)(/*[in]*/ long newVal);
    STDMETHODIMP ApplyChanges() { return InitializeMask(); }
    STDMETHODIMP LoadDefSettings();

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );

    // our helper function
    //

    HRESULT DoEffect( DXSAMPLE * pOut, DXSAMPLE * pInA, DXSAMPLE * pInB, long Samples );
    HRESULT MakeSureBufAExists( long Samples );
    HRESULT MakeSureBufBExists( long Samples );
    HRESULT MakeSureOutBufExists( long Samples );
    void FreeStuff( );
    HRESULT InitializeMask();
    void MapMaskToResource(long *);
    void FlipSmpteMask();
    HRESULT ScaleByDXTransform();
    HRESULT LoadMaskResource();
    void RescaleGrayscale();
    HRESULT CreateRandomMask();

};

#define MASK_FLUSH_CHANGEMASK     0x001
#define MASK_FLUSH_CHANGEPARMS    0x002

#endif //__DXTJPEG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\loadjpg.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: loadjpg.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "dxtjpeg.h"
#include <gdiplus.h>
#include "../util/jpegfuncs.h"

using namespace Gdiplus;



HRESULT CDxtJpeg::LoadJPEGImage(Bitmap& bitJpeg,IDXSurface **ppSurface)
{
    
    HRESULT hr;
    Status stat;
    
    
    // Find out how big the image is.

    UINT  uiHeight = bitJpeg.GetHeight();
    UINT  uiWidth  = bitJpeg.GetWidth() ;



    UINT size = uiHeight * uiWidth * 4; // We'll use ARGB32

    BYTE * pBuffer = new BYTE[size];
    if (pBuffer == NULL)
    {
        return E_OUTOFMEMORY;
    }

    Rect rect(0, 0, uiWidth, uiHeight);

    BitmapData bitData;
    bitData.Width       = uiWidth;
    bitData.Height      = uiHeight;
    bitData.Stride      = uiWidth * 4;  //ARGB32
    bitData.PixelFormat = PixelFormat32bppARGB;
    bitData.Scan0       = (PVOID) pBuffer;

    stat = bitJpeg.LockBits(&rect, ImageLockModeRead | ImageLockModeUserInputBuf, PixelFormat32bppARGB,
                            &bitData);

    if (stat != Ok)
    {
        delete [] pBuffer;
        return ConvertStatustoHR(stat);
    }
   
    stat = bitJpeg.UnlockBits(&bitData);
    if (stat != Ok)
    {
        delete [] pBuffer;
        return ConvertStatustoHR(stat);
    }

    // Now pBuffer contains the uncompressed image.  Create a DX Surface and put that image in it.


    CDXDBnds bounds;
    bounds.SetXYSize( uiWidth, uiHeight);

    hr = m_cpSurfFact->CreateSurface(
            NULL,
            NULL,
            &MEDIASUBTYPE_ARGB32,
            &bounds,
            0,
            NULL,
            IID_IDXSurface,
            (void **) ppSurface);

    if (FAILED (hr))
    {
        delete [] pBuffer;
        return hr;
    }


    // Get a RW interface to the surface
    CComPtr<IDXARGBReadWritePtr> prw = NULL;

    hr = (*ppSurface)->LockSurface(
        NULL,
        m_ulLockTimeOut,
        DXLOCKF_READWRITE,
        IID_IDXARGBReadWritePtr,
        (void**)&prw,
        NULL);

    if (FAILED (hr))
    {
        delete [] pBuffer;
        return hr;
    }


    // Create a Sample Array
    DXSAMPLE * pSamples = new DXSAMPLE [size/4];
    
    if (pSamples == NULL)
    {
        delete [] pBuffer;
        return E_OUTOFMEMORY;
    }

    BYTE * pTemp = pBuffer;

    for (UINT i = 0; i < size / 4; i++)
    {
        pSamples[i].Red     = *pTemp++;
        pSamples[i].Blue    = *pTemp++;
        pSamples[i].Green   = *pTemp++;
        pSamples[i].Alpha   = *pTemp++;
    }


    // Pack the Sample Array into the DX Surface
    // No return value, supposedly it cannot fail.
    prw->PackAndMove(pSamples, size / 4);
    delete [] pSamples;         // Don't need it any more
    delete [] pBuffer;


    // and we're done.
    return S_OK;
}




HRESULT CDxtJpeg::LoadJPEGImageFromFile (TCHAR * tFileName, IDXSurface **ppSurface)
{
    if ((tFileName == NULL) || (ppSurface == NULL))
    {
        return E_INVALIDARG;
    }

    Status stat;

    USES_CONVERSION;

    LPWSTR wfilename = T2W(tFileName);
    
    // Create a GDI+ Bitmap object from the file.
    
    Bitmap bitJpeg(wfilename,TRUE);
    
    // Check if the Bitmap was created.
    stat = bitJpeg.GetLastStatus();

    if ( stat != Ok)
    {
       // Construction failed...  I'm out of here
       return ConvertStatustoHR(stat);
    }
    return (LoadJPEGImage(bitJpeg, ppSurface));
}





HRESULT CDxtJpeg::LoadJPEGImageFromStream(IStream * pStream, IDXSurface **ppSurface)
{
    if ((pStream == NULL) || (ppSurface == NULL))
    {
        return E_INVALIDARG;
    }

    Status stat;

    // Create a GDI+ Bitmap object

    Bitmap bitJpeg (pStream, TRUE);

    stat = bitJpeg.GetLastStatus();
    if ( stat != Ok)
    {
       // Construction failed...  I'm out of here
       return ConvertStatustoHR(stat);
    } 

    
    return (LoadJPEGImage(bitJpeg, ppSurface));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dxtjpegdll.rc
//
#define IDR_DXTJPEG                     1101
#define IDS_TITLEDxtJpegPP              1102
#define IDS_HELPFILEDxtJpegPP           1103
#define IDS_DOCSTRINGDxtJpegPP          1104
#define IDR_DXTJPEGPP                   1105
#define IDD_DXTJPEGPP                   1106
#define IDC_BROWSE                      1111
#define IDC_MASK_NAME                   1112
#define IDC_THRESHOLD                   1113
#define IDC_DO_BORDER                   1114
#define IDC_SMPTE_EDIT                  1115
#define IDC_XSCALE                      1117
#define IDC_YSCALE                      1118
#define IDC_XDISPLACEMENT               1119
#define IDC_YDISPLACEMENT               1120
#define IDC_REPLICATE_X                 1121
#define IDC_REPLICATE_Y                 1122
#define IDC_BORDERED                    1123
#define IDC_BORDERWIDTH                 1124
#define IDC_BORDER_DESC1                1125
#define IDC_BORDER_R                    1126
#define IDC_BORDER_G                    1127
#define IDC_BORDER_B                    1128
#define IDC_STATIC_BR                   1129
#define IDC_STATIC_BG                   1130
#define IDC_STATIC_BB                   1131
#define IDC_PICKFILE                    1132
#define IDC_FILEMASK                    1133
#define IDC_BORDERSOFTNESS              1134
#define IDC_BORDER_DESC2                1135
#define IDC_RESTOREDEFAULTS             1136
#define IDC_NUMOVERFILE                 1137


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1138
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1138
#define _APS_NEXT_SYMED_VALUE           1108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\dxtjpegpp.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxtjpegpp.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtJpegPP.cpp : Implementation of CDxtJpegPP
#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "DxtJpeg.h"
#include "DxtJpegPP.h"
#include <stdio.h>
#pragma warning (disable:4244 4800)

/////////////////////////////////////////////////////////////////////////////
// CDxtJpegPP

LRESULT CDxtJpegPP::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    USES_CONVERSION;
    CComQIPtr<IDxtJpeg, &IID_IDxtJpeg> pOwner( m_ppUnk[0] );

    // Populate scaling, displacement information
    SetPPMaskProperties(pOwner);
    SetPPScalingProperties(pOwner);
    SetPPReplicationProperties(pOwner);
    SetPPBorderProperties(pOwner);

    m_bWhyIsApplyCalledTwice = FALSE;

    return TRUE;
}

STDMETHODIMP CDxtJpegPP::Apply(void)
{
    ATLTRACE(_T("CDxtJpegPP::Apply\n"));
    for (UINT i = 0; i < m_nObjects; i++)
    {
      CComQIPtr<IDxtJpeg, &IID_IDxtJpeg> pOwner( m_ppUnk[0] );

      if (!m_bWhyIsApplyCalledTwice)
        {
            SetMaskPropertiesFromPP(pOwner);
            SetScalingPropertiesFromPP(pOwner);
            SetPReplicationPropertiesFromPP(pOwner);
            SetBorderPropertiesFromPP(pOwner);
            pOwner->ApplyChanges();
            m_bWhyIsApplyCalledTwice = TRUE;
        }
    }

    m_bDirty = FALSE;
    return S_OK;
}

LRESULT CDxtJpegPP::OnNumOverFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (m_bNumOverFile)
      SetDlgItemText(IDC_NUMOVERFILE, TEXT(">"));
    else
      SetDlgItemText(IDC_NUMOVERFILE, TEXT("<"));

    m_bNumOverFile = !m_bNumOverFile;

    SetDirty(TRUE);
    bHandled = TRUE;
    return 0;
}

LRESULT CDxtJpegPP::OnSelectFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    OPENFILENAME ofn;
    TCHAR tReturnName[_MAX_PATH];
    tReturnName[0] = 0;

    memset(&ofn, 0, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = NULL;
    ofn.lpstrFile = tReturnName;
    ofn.nMaxFile = _MAX_PATH;
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_LONGNAMES;
    if (!GetOpenFileName(&ofn))
      return FALSE;

    // Nice touch-autoswitch to FILE over NUM
    SetDlgItemText(IDC_NUMOVERFILE, TEXT(">"));
    m_bNumOverFile = FALSE;

    SetDlgItemText(IDC_FILEMASK, ofn.lpstrFile );

    SetDirty(TRUE);
    bHandled = TRUE;
    return 0;
}

LRESULT CDxtJpegPP::OnFactorySettings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CComQIPtr<IDxtJpeg, &IID_IDxtJpeg> pOwner( m_ppUnk[0] );

    pOwner->LoadDefSettings();

    SetPPMaskProperties(pOwner);
    SetPPScalingProperties(pOwner);
    SetPPReplicationProperties(pOwner);
    SetPPBorderProperties(pOwner);

    // Nice touch-autoswitch to NUM
    SetDlgItemText(IDC_NUMOVERFILE, TEXT("<"));
    m_bNumOverFile = TRUE;

    SetDirty(TRUE);
    bHandled = TRUE;
    return 0;
}

void CDxtJpegPP::SetPPMaskProperties(IDxtJpeg *punk)
{
    USES_CONVERSION;
    TCHAR convert[10];
    long lResult;

    punk->get_MaskNum(&lResult);
    wsprintf(convert, TEXT("%u"), lResult);
    SetDlgItemText(IDC_SMPTE_EDIT, convert);

    BSTR MaskName;
    punk->get_MaskName(&MaskName);
    TCHAR * tMaskName = W2T( MaskName );
    SetDlgItemText(IDC_FILEMASK, tMaskName);
    SysFreeString(MaskName);
}

void CDxtJpegPP::SetPPScalingProperties(IDxtJpeg *punk)
{
    DOUBLE dbNum;

    punk->get_ScaleX(&dbNum);
    SetDlgItemInt(IDC_XSCALE, UINT(dbNum*100.0), FALSE);

    punk->get_ScaleY(&dbNum);
    SetDlgItemInt(IDC_YSCALE, UINT(dbNum*100.0), FALSE);

    LONG lNum;

    punk->get_OffsetX(&lNum);
    SetDlgItemInt(IDC_XDISPLACEMENT, int(lNum), TRUE);

    punk->get_OffsetY(&lNum);
    SetDlgItemInt(IDC_YDISPLACEMENT, int(lNum), TRUE);
}

void CDxtJpegPP::SetPPReplicationProperties(IDxtJpeg *punk)
{
    long lResult;

    punk->get_ReplicateX(&lResult);
    SetDlgItemInt(IDC_REPLICATE_X, UINT(lResult), FALSE);

    punk->get_ReplicateY(&lResult);
    SetDlgItemInt(IDC_REPLICATE_Y, UINT(lResult), FALSE);
}

void CDxtJpegPP::SetPPBorderProperties(IDxtJpeg *punk)
{
    long l;

    punk->get_BorderWidth(&l);
    SetDlgItemInt(IDC_BORDERWIDTH, (int)l);

    punk->get_BorderSoftness(&l);
    SetDlgItemInt(IDC_BORDERSOFTNESS, (int)l);

    punk->get_BorderColor(&l);

    SetDlgItemInt(IDC_BORDER_R, (int)((l & 0xFF0000) >> 16));
    SetDlgItemInt(IDC_BORDER_G, (int)((l & 0xFF00) >> 8));
    SetDlgItemInt(IDC_BORDER_B, (int)(l & 0xFF));
}

void CDxtJpegPP::SetMaskPropertiesFromPP(IDxtJpeg *punk)
{
  if (m_bNumOverFile)
    punk->put_MaskNum(UINT(GetDlgItemInt(IDC_SMPTE_EDIT, NULL, FALSE)));

  if (!m_bNumOverFile)
    {
      BSTR bstr;
      if (GetDlgItemText(IDC_FILEMASK, bstr))
        {
          punk->put_MaskName(bstr);
          SysFreeString(bstr);
        }
    }
}

void CDxtJpegPP::SetScalingPropertiesFromPP(IDxtJpeg *punk)
{
  punk->put_ScaleX(DOUBLE(GetDlgItemInt(IDC_XSCALE, NULL, FALSE))/100.0);
  punk->put_ScaleY(DOUBLE(GetDlgItemInt(IDC_YSCALE, NULL, FALSE))/100.0);
  punk->put_OffsetX(LONG(GetDlgItemInt(IDC_XDISPLACEMENT, NULL, TRUE)));
  punk->put_OffsetY(LONG(GetDlgItemInt(IDC_YDISPLACEMENT, NULL, TRUE)));
}

void CDxtJpegPP::SetPReplicationPropertiesFromPP(IDxtJpeg *punk)
{
  punk->put_ReplicateX(GetDlgItemInt(IDC_REPLICATE_X, NULL, FALSE));
  punk->put_ReplicateY(GetDlgItemInt(IDC_REPLICATE_Y, NULL, FALSE));
}

void CDxtJpegPP::SetBorderPropertiesFromPP(IDxtJpeg *punk)
{
  punk->put_BorderWidth(LONG(GetDlgItemInt(IDC_BORDERWIDTH, NULL, FALSE)));
  punk->put_BorderSoftness(LONG(GetDlgItemInt(IDC_BORDERSOFTNESS, NULL, FALSE)));
  punk->put_BorderColor(LONG(
      ((UINT(GetDlgItemInt(IDC_BORDER_R, NULL, FALSE)) & 0xFF) << 16)+
      ((UINT(GetDlgItemInt(IDC_BORDER_G, NULL, FALSE)) & 0xFF) << 8)+
      ((UINT(GetDlgItemInt(IDC_BORDER_B, NULL, FALSE)) & 0xFF))
      ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxt\dxtwrap\property.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: property.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "dxt.h"
#include <dxtguid.c>	// MUST be included after dxtrans.h
#include "resource.h"

// constructor
//
CPropPage::CPropPage (TCHAR * pszName, LPUNKNOWN punk, HRESULT *phr) :
   CBasePropertyPage(pszName, punk, IDD_PROPERTIES, IDS_NAME)
   ,m_pOpt(NULL)
{
   DbgLog((LOG_TRACE,3,TEXT("CPropPage constructor")));
}

// create a new instance of this class
//
CUnknown *CPropPage::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CPropPage(NAME("DXT Property Page"),pUnk,phr);
}


HRESULT CPropPage::OnConnect(IUnknown *pUnknown)
{
    HRESULT hr = (pUnknown)->QueryInterface(IID_IAMDXTEffect,
                                            (void **)&m_pOpt);
    if (FAILED(hr))
        return E_NOINTERFACE;

    return NOERROR;
}


HRESULT CPropPage::OnDisconnect()
{
    if (m_pOpt)
        m_pOpt->Release();
    m_pOpt = NULL;
    return NOERROR;
}


HRESULT CPropPage::OnApplyChanges()
{
    DbgLog((LOG_TRACE,2,TEXT("Apply")));
    char ach[80];
    LONGLONG llStart, llStop;

    // !!! we're linking to msvcrt
    // !!! UNICODE compile?
    GetDlgItemTextA(m_hwnd, IDC_STARTTIME, ach, 80);
    double d = atof(ach);
    llStart = (LONGLONG)d;
    GetDlgItemTextA(m_hwnd, IDC_ENDTIME, ach, 80);
    d = atof(ach);
    llStop = (LONGLONG)d;
    llStart *= 10000; llStop *= 10000;
    HRESULT hr = m_pOpt->SetDuration(llStart, llStop);
    if (hr != S_OK) {
	MessageBox(NULL, TEXT("Error initializing transform"),
						TEXT("Error"), MB_OK);
    }
    return NOERROR;
}


// Handles the messages for our property window
//
INT_PTR CPropPage::OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
        case WM_INITDIALOG:

            DbgLog((LOG_TRACE,5,TEXT("Initializing the Dialog Box")));

	    LONGLONG llStart, llStop;
	    TCHAR ach[80];
	    m_pOpt->GetDuration(&llStart, &llStop);
	    llStart /= 10000; llStop /= 10000;
	    wsprintf(ach, TEXT("%d"), (int)llStart);
	    SetDlgItemText(hwnd, IDC_STARTTIME, ach);
	    wsprintf(ach, TEXT("%d"), (int)llStop);
	    SetDlgItemText(hwnd, IDC_ENDTIME, ach);
	    m_hwnd = hwnd;
            return TRUE;

	case WM_COMMAND:
            UINT uID = GET_WM_COMMAND_ID(wParam,lParam);

	    // we're dirty if anybody plays with these controls
	    if (uID == IDC_STARTTIME || uID == IDC_ENDTIME ||
				uID == IDC_CONSTANT || uID == IDC_VARIES ||
				uID == IDC_LEVEL) {
		m_bDirty = TRUE;
	    }
	    break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtkey\dxtkeypp.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxtkeypp.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtKeyPP.cpp : Implementation of CDxtKeyPP
#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "DxtKeyPP.h"
#pragma warning (disable:4244 4800)

/////////////////////////////////////////////////////////////////////////////
// CDxtKeyPP

LRESULT CDxtKeyPP::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    USES_CONVERSION;
    CComQIPtr<IDxtKey, &IID_IDxtKey> pOwner( m_ppUnk[0] );


    // keytype
//    SetKeyTypeProperty(pOwner);

    DWORD dw;
    pOwner->get_Hue((int *)&dw);
    SetDlgItemText(IDC_DXTKEYEDITRED, TEXT("0"));
    SetDlgItemText(IDC_DXTKEYEDITGREEN, TEXT("0"));
    SetDlgItemText(IDC_DXTKEYEDITBLUE, TEXT("0"));
    SetDlgItemText(IDC_DXTKEYEDITALPHA, TEXT("0"));

    //set all slider at start point

    return TRUE;
}

STDMETHODIMP CDxtKeyPP::Apply(void)
{
    ATLTRACE(_T("CDxtKeyPP::Apply\n"));
    for (UINT i = 0; i < m_nObjects; i++)
    {
      CComQIPtr<IDxtKey, &IID_IDxtKey> pOwner( m_ppUnk[0] );
    }

    m_bDirty = FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtkey\dxtkey.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxtkey.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtKey.cpp : Implementation of CDxtKey
#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "DxtKey.h"
#pragma warning (disable:4244)


void Key_RGB( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore, DXTKEY *pKey,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_Black( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_XRGB( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore, DXTKEY *pKey, float Percent,
               ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_Alpha( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXPMSAMPLE* pOverlay,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_PMAlpha( DXSAMPLE* pSrcBack,DXPMSAMPLE* pOverlay,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_Luma( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey, float Percent,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );
void Key_Hue( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey, float Percent,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut );

/////////////////////////////////////////////////////////////////////////////
// CDxtKey

CDxtKey::CDxtKey( )
{
    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;

    //init m_key
    DefaultKey();


}

CDxtKey::~CDxtKey( )
{
    FreeStuff( );
}

void CDxtKey::DefaultKey()
{
    m_Key.iKeyType =DXTKEY_ALPHA;    //keytype;     for all keys
    m_Key.iHue    =0;               //Hue  , only for _HUE keys
    m_Key.iLuminance    =0;               //Luminance  , only for _LUMINANCE keys
    m_Key.dwRGBA   =0;    //RGB color,  only for _RGB, _NONRED

    m_Key.iSimilarity =0;

    m_Key.bInvert=FALSE;        //I, every key except  Alpha Key
}

void CDxtKey::FreeStuff( )
{
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;
}

HRESULT CDxtKey::OnSetup( DWORD dwFlags )
{
    // delete any stored stuff we have, or memory allocated
    //
    FreeStuff( );

    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    m_nInputWidth = InBounds.Width( );
    m_nInputHeight = InBounds.Height( );

    CDXDBnds OutBounds(OutputSurface(), hr );
    m_nOutputWidth = OutBounds.Width( );
    m_nOutputHeight = OutBounds.Height( );

    if( m_nOutputWidth > m_nInputWidth )
    {
        m_nOutputWidth = m_nInputWidth;
    }
    if( m_nOutputHeight > m_nInputHeight )
    {
        m_nOutputHeight = m_nInputHeight;
    }

    return NOERROR;
}

HRESULT CDxtKey::FinalConstruct( )
{
    HRESULT hr;

    m_ulMaxImageBands = 1;
    m_ulMaxInputs = 2;
    m_ulNumInRequired = 2;
    m_dwMiscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_bInputIsClean = true;
    m_bOutputIsClean = true;
    m_nInputWidth = 0;
    m_nInputHeight = 0;
    m_nOutputWidth = 0;
    m_nOutputHeight = 0;

    hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_pUnkMarshaler.p );
    return hr;
}

HRESULT CDxtKey::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;
    DXSAMPLEFORMATENUM Format;
    DXNATIVETYPEINFO NativeType;

    //--- Get input sample access pointer for the requested region.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> pInA;
    hr = InputSurface( 0 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInA, NULL );
    if( FAILED( hr ) ) return hr;


    CComPtr<IDXARGBReadPtr> pInB;
    hr = InputSurface( 1 )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                         IID_IDXARGBReadPtr, (void**)&pInB, NULL );
    if( FAILED( hr ) ) return hr;


    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> pOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
    if( FAILED( hr ) ) return hr;

//    ASSERT(WI.DoBnds.Width() == WI.OutputBnds.Width());
//    Format = pInA->GetNativeType( &NativeType );
//    ASSERT(Format==DXPF_PMARGB32  || Format==DXPF_ARGB32 );
//    Format = pInB->GetNativeType( &NativeType );
//    ASSERT(Format==DXPF_PMARGB32  || Format==DXPF_ARGB32 );


    //--- Allocate a working buffer
    ULONG Width = WI.DoBnds.Width();
    ULONG Height = WI.DoBnds.Height();

    // allocate a scratch buffer fer us
    //
    DXPMSAMPLE *pOverlayBuffer = DXPMSAMPLE_Alloca( Width );
    DXPMSAMPLE *pScratchBuffer = DXPMSAMPLE_Alloca( Width );
    DXSAMPLE   *pChromaBuffer =  DXSAMPLE_Alloca( Width );

    // no dithering
    //
    if (DoDither())
    {
        return 0;
    }

    ULONG OutY;
    ULONG OutX;

    if( m_Key.iKeyType ==DXTKEY_ALPHA )
    {
        //m_Key.bInvert;       not supported in Alpha Key

        Format = pInB->GetNativeType( &NativeType );
        if( ( Format == DXPF_PMARGB32  ) )
            //alpha premultiplied
            Key_PMAlpha( (DXSAMPLE*)pScratchBuffer,pOverlayBuffer,
                         Width,Height,pInA,pInB,pOut);
        else
            Key_Alpha( (DXSAMPLE*)pScratchBuffer, pChromaBuffer, pOverlayBuffer,
              Width, Height,pInA, pInB,pOut );

    }
    else if(m_Key.iKeyType == DXTKEY_RGB)
    {

        if(m_Key.iSimilarity )
        {
            float Percent = 1.0;
            get_Progress( &Percent );

            Key_XRGB( (DXSAMPLE*)pScratchBuffer,pChromaBuffer, &m_Key, Percent,
                         Width,Height,pInA,pInB,pOut);
        }
        else
        {
            //no blending, no similarity, no threshold, no cutoff
            m_Key.dwRGBA |=0xff000000;  //ignore alpha channel

            if(m_Key.dwRGBA & 0x00FFFFFF)
            {
                Key_RGB( (DXSAMPLE*)pScratchBuffer,pChromaBuffer,&m_Key,
                         Width,Height,pInA,pInB,pOut);
            }
            else
                Key_Black((DXSAMPLE*)pScratchBuffer,pChromaBuffer,&m_Key,
                         Width,Height,pInA,pInB,pOut);
        }
    }
    else if(m_Key.iKeyType==DXTKEY_NONRED)
    {
        for( OutY = 0 ; OutY < Height ; ++OutY )
        {

            // copy background row into dest row
            pOut->MoveToRow( OutY );
            pInA->MoveToRow( OutY );
            pOut->CopyAndMoveBoth( (DXBASESAMPLE*) pScratchBuffer, pInA, Width, FALSE );
            pOut->MoveToRow( OutY );

            //
            // unpack the overlay and what the heck, the original values, too.
            //
            pInB->MoveToXY( 0, OutY );
            pInB->UnpackPremult( pOverlayBuffer, Width, FALSE );
            pInB->Unpack( pChromaBuffer, Width, FALSE );

            float Percent = 1.0;
            get_Progress( &Percent );

            //
            // convert the src's blue bits into an alpha value
            //
            for( OutX = 0; OutX < Width ; ++OutX )
            {
                long rb = pChromaBuffer[OutX].Blue - pChromaBuffer[OutX].Red;
                long gb = pChromaBuffer[OutX].Blue - pChromaBuffer[OutX].Green;

                if( rb > 30 || gb > 30 )
                {
                    if( rb > 70 || gb > 70 )
                    {
                        // very blue!
                        // completely transparent!
                        *( (DWORD *)(&(pOverlayBuffer[OutX])) )= 0;
                    }
                    else
                    {
                        double T = 1.0;

                        // do a quick search left or right to see if we find more blue
                        //
                        bool found = false;
                        if( ( OutX > 11 ) && ( OutX < ( Width - 11 ) ) )
                        {
                            for( ULONG j = OutX - 10 ; j < OutX + 10 ; j++ )
                            {
                                long rb = pChromaBuffer[j].Blue - pChromaBuffer[j].Red;
                                long gb = pChromaBuffer[j].Blue - pChromaBuffer[j].Green;
                                if( rb > 70 && gb > 70 )
                                {
                                    found = true;
                                }
                            }
                        }
                        if( found )
                        {
                            // vary the transparency of the colors based on how
                            // much blue is left

                            // first subtract off the blue itself, it's at least 70 above something
                            //
                            pOverlayBuffer[OutX].Blue -= 70;

                        // the rest of the blue's value determines how transparent everything
                        // else is. Blue is from 0 to 185. The MORE blue we have, the more transparent it should be.

                            T = ( 185.0 - pOverlayBuffer[OutX].Blue ) / 185.0;

                            T /= 3.0;

                        }

                        pOverlayBuffer[OutX].Red   =(DXPMSAMPLE)( (double)(pOverlayBuffer[OutX].Red)  *T* Percent );
                        pOverlayBuffer[OutX].Green =(DXPMSAMPLE)( (double)(pOverlayBuffer[OutX].Green)*T* Percent);
                        pOverlayBuffer[OutX].Blue  =(DXPMSAMPLE)( (double)(pOverlayBuffer[OutX].Blue) *T* Percent);
                        pOverlayBuffer[OutX].Alpha =(DXPMSAMPLE)( (double)(pOverlayBuffer[OutX].Alpha)*T* Percent);
                    }//if(rb>70)

                }// if( rb > 30 || gb > 30 )
            } // for i

            // blend the src (B) back into the destination
            pOut->OverArrayAndMove( pScratchBuffer, pOverlayBuffer, Width );

        } // End for
    }
    else if(m_Key.iKeyType==DXTKEY_LUMINANCE)
    {
        float Percent = 1.0;
        get_Progress( &Percent );

        Key_Luma( (DXSAMPLE*)pScratchBuffer,pChromaBuffer,&m_Key,Percent,
                   Width, Height,
                   pInA, pInB, pOut );
    }
    else if(m_Key.iKeyType==DXTKEY_HUE)
    {
        float Percent = 1.0;
        get_Progress( &Percent );

        Key_Hue( (DXSAMPLE*)pScratchBuffer, pChromaBuffer,&m_Key,Percent,
                 Width, Height, pInA, pInB,pOut);
    }
    else
    {
        //default to alpha blend
        Key_Alpha( (DXSAMPLE*)pScratchBuffer, pChromaBuffer, pOverlayBuffer,
              Width, Height,pInA, pInB,pOut );
    }

    return S_OK;
}

//
// IDXTKey
//
STDMETHODIMP CDxtKey::get_KeyType ( int *piKeyType)
{
    CheckPointer(piKeyType, E_POINTER);
    *piKeyType=m_Key.iKeyType;
    return NOERROR;
}

STDMETHODIMP CDxtKey::put_KeyType ( int iKeyType)
{
    m_Key.iKeyType=iKeyType;
    return NOERROR;
}

STDMETHODIMP CDxtKey::get_Hue(int *pHue)
{
    CheckPointer(pHue, E_POINTER);
    *pHue=m_Key.iHue;
    return NOERROR;
}

STDMETHODIMP CDxtKey::put_Hue(int iHue)
{
    m_Key.iHue=iHue;
    return NOERROR;
}

STDMETHODIMP CDxtKey::get_Luminance(int *pLuminance)
{
    CheckPointer(pLuminance, E_POINTER);
    *pLuminance=m_Key.iLuminance;
    return NOERROR;
}

STDMETHODIMP CDxtKey::put_Luminance(int iLuminance)
{
    m_Key.iLuminance=iLuminance;
    return NOERROR;
}

STDMETHODIMP CDxtKey::get_RGB(DWORD *pdwRGB)
{
    CheckPointer(pdwRGB, E_POINTER);
    *pdwRGB=m_Key.dwRGBA;
    return NOERROR;
}

STDMETHODIMP CDxtKey::put_RGB(DWORD dwRGB)
{
    m_Key.dwRGBA=dwRGB;
    return NOERROR;
}

STDMETHODIMP CDxtKey::get_Similarity(int *piSimilarity)
{
    CheckPointer(piSimilarity, E_POINTER);
    *piSimilarity=m_Key.iSimilarity;
    return NOERROR;
}
STDMETHODIMP CDxtKey::put_Similarity(int iSimilarity)
{
    m_Key.iSimilarity=iSimilarity;
    return NOERROR;
}


STDMETHODIMP CDxtKey::get_Invert(BOOL *pbInvert)
{
    CheckPointer(pbInvert, E_POINTER);
    *pbInvert=m_Key.bInvert;
    return NOERROR;
}
STDMETHODIMP CDxtKey::put_Invert(BOOL bInvert)
{
    m_Key.bInvert=bInvert;
    return NOERROR;
}

//
// put (DWORD *)in front of a DXSAMPLE to speed up the calc
//

//
// this is a RGB color key  which does not key for black color
// no blending, no similarity, no threshold, no cutoff

void Key_RGB( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;
    ULONG OutX;

    DWORD dwKey=pKey->dwRGBA &0x00FFFFFF;;

    if(pKey->bInvert==FALSE)
    {
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );


        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( ( *(DWORD *)(&pSrcFore[OutX]) & 0x00FFFFFF ) != dwKey )
                *( (DWORD *)(&pSrcBack[OutX]) )=*(DWORD *)(&pSrcFore[OutX]);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
    }
    else
    {
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );


        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
             if( ( *(DWORD *)(&pSrcFore[OutX]) & 0x00FFFFFF ) == dwKey )
                  *( (DWORD *)(&pSrcBack[OutX]) )=*(DWORD *)(&pSrcFore[OutX]);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
    }

}

void Key_Black( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;
    ULONG OutX;

    //black key
    if(pKey->bInvert==FALSE)
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack A
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        // unpack B
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( *(DWORD *)(&pSrcFore[OutX]) & 0x00FFFFFF  )
            *( (DWORD *)(&pSrcBack[OutX]) )=*(DWORD *)(&pSrcFore[OutX]);
        }

        // blend the src (B) back into the destination
        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
    else
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack A
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        // unpack B
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( *(DWORD *)(&pSrcFore[OutX]) & 0x00FFFFFF  )
            *( (DWORD *)(&pSrcFore[OutX]) )=*(DWORD *)(&pSrcBack[OutX]);
        }

        // blend the src (B) back into the destination
        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcFore,Width);
    }
}

void Key_XRGB( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore, DXTKEY *pKey, float Percent,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;
    ULONG OutX;

    DWORD dwRedMin = 255;
    DWORD dwGreenMin = 255;
    DWORD dwBlueMin = 255;
    DWORD dwTmp;
    DWORD dwRedMax = 0;
    DWORD dwGreenMax = 0;
    DWORD dwBlueMax = 0;

    BYTE *pB= (BYTE*)&(pKey->dwRGBA);


    if(pKey->iSimilarity)
    {
        dwRedMin   =*(pB+2)*(100-pKey->iSimilarity)/100;
        dwGreenMin =*(pB+1)*(100-pKey->iSimilarity)/100;
        dwBlueMin  = *pB   *(100-pKey->iSimilarity)/100;

        dwTmp=0xFF*pKey->iSimilarity/100;

        dwRedMax    =dwTmp+dwRedMin;
        dwGreenMax  =dwTmp+dwGreenMin;
        dwBlueMax   =dwTmp+dwBlueMin;

    }

 if(pKey->bInvert==FALSE)
 {
    if( pKey->iSimilarity && (Percent==1.0) )
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {

            if( (pSrcFore[OutX].Red   < dwRedMin  ) || (pSrcFore[OutX].Red > dwRedMax ) ||
                (pSrcFore[OutX].Green < dwGreenMin) || (pSrcFore[OutX].Green > dwGreenMax ) ||
                (pSrcFore[OutX].Blue  < dwBlueMin ) || (pSrcFore[OutX].Blue > dwBlueMax)  )
                    *(DWORD *)(&pSrcBack[OutX]) = *(DWORD *)(&pSrcFore[OutX]);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
    else   if(pKey->iSimilarity && (Percent==1.0))
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( (pSrcFore[OutX].Red   < dwRedMin  ) || (pSrcFore[OutX].Red > dwRedMax ) ||
                (pSrcFore[OutX].Green < dwGreenMin) || (pSrcFore[OutX].Green > dwGreenMax ) ||
                (pSrcFore[OutX].Blue  < dwBlueMin ) || (pSrcFore[OutX].Blue > dwBlueMax)  )
                    *(DWORD *)(&pSrcBack[OutX])=*(DWORD *)(&pSrcBack[OutX])/2 +
                                      *(DWORD *)(&pSrcFore[OutX])/2;
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
    else
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );


        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( (pSrcFore[OutX].Red   < dwRedMin  ) || (pSrcFore[OutX].Red > dwRedMax ) ||
                (pSrcFore[OutX].Green < dwGreenMin) || (pSrcFore[OutX].Green > dwGreenMax ) ||
                (pSrcFore[OutX].Blue  < dwBlueMin ) || (pSrcFore[OutX].Blue > dwBlueMax)  )
                    *(DWORD *)(&pSrcBack[OutX])= ( *(DWORD *)(&pSrcBack[OutX])/2 +
                                    *(DWORD *)(&pSrcFore[OutX])/2 )*Percent +
                                    *(DWORD *)(&pSrcFore[OutX])*(1-Percent);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
 }
 else
 {
    if( pKey->iSimilarity && (Percent==1.0) )
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {

            if( (pSrcFore[OutX].Red   < dwRedMin  ) || (pSrcFore[OutX].Red > dwRedMax ) ||
                (pSrcFore[OutX].Green < dwGreenMin) || (pSrcFore[OutX].Green > dwGreenMax ) ||
                (pSrcFore[OutX].Blue  < dwBlueMin ) || (pSrcFore[OutX].Blue > dwBlueMax)  )
                    *(DWORD *)(&pSrcFore [OutX]) = *(DWORD *)(&pSrcBack[OutX]);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcFore,Width);
    }
    else   if(pKey->iSimilarity && (Percent==1.0))
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {

            if( (pSrcFore[OutX].Red   < dwRedMin  ) || (pSrcFore[OutX].Red > dwRedMax ) ||
                (pSrcFore[OutX].Green < dwGreenMin) || (pSrcFore[OutX].Green > dwGreenMax ) ||
                (pSrcFore[OutX].Blue  < dwBlueMin ) || (pSrcFore[OutX].Blue > dwBlueMax)  )
                   *(DWORD *)(&pSrcFore[OutX])=*(DWORD *)(&pSrcFore[OutX])/2 +
                                     *(DWORD *)(&pSrcBack[OutX])/2;
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcFore,Width);
    }
    else
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {

        // unpack background
        pInA->MoveToRow( OutY );
        pInA->Unpack(pSrcBack, Width, FALSE );

        //unpack foreground
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        for( OutX = 0 ; OutX < Width ; ++OutX )
        {
            if( (pSrcFore[OutX].Red   >=dwRedMin  ) && (pSrcFore[OutX].Red <= dwRedMax ) &&
                (pSrcFore[OutX].Green >=dwGreenMin) && (pSrcFore[OutX].Green <= dwGreenMax ) &&
                (pSrcFore[OutX].Blue  >=dwBlueMin ) && (pSrcFore[OutX].Blue <= dwBlueMax)   )
                    *(DWORD *)(&pSrcFore[OutX])= ( *(DWORD *)(&pSrcFore[OutX])/2 +
                                    *(DWORD *)(&pSrcBack[OutX])/2)*Percent +
                                    *(DWORD *)(&pSrcBack[OutX])*(1-Percent);
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcFore,Width);
    }
 }
}

void Key_PMAlpha( DXSAMPLE* pSrcBack, DXPMSAMPLE* pSrcFore,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB,IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;

    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // copy background row into dest row
        pOut->MoveToRow( OutY );
        pInA->MoveToRow( OutY );
        pOut->CopyAndMoveBoth( (DXBASESAMPLE*) pSrcBack, pInA, Width, FALSE );

        // unpack the overlay and what the heck, the original values, too.
        //
        pInB->MoveToRow( OutY );
        pInB->UnpackPremult( pSrcFore, Width, FALSE );

        // blend the src (B) back into the destination
        pOut->MoveToRow( OutY );
        pOut->OverArrayAndMove( pSrcBack, pSrcFore, Width );
    }
}

void Key_Alpha( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXPMSAMPLE* pOverlay,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;

    // foreground image has to have alpha value in every pixel
    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // copy background row into dest row
        pOut->MoveToRow( OutY );
        pInA->MoveToRow( OutY );
        pOut->CopyAndMoveBoth( (DXBASESAMPLE*) pSrcBack, pInA, Width, FALSE );

        // unpack original value
        //
        pInB->MoveToRow( OutY );
        pInB->UnpackPremult( (DXPMSAMPLE*) pSrcFore, Width, FALSE );

        // blend the src (B) back into the destination
        pOut->MoveToRow( OutY );
        pOut->OverArrayAndMove( pSrcBack, (DXPMSAMPLE*) pSrcFore, Width );
    }
}

#define HMAX  360
#define LMAX  100
#define SMAX  100
#define RGBMAX  255
#define UNDEFINED 0 /* Hue is undefined if Saturation is 0 (grey-scale) */



void Key_Luma( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey,float Percent,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut )
{
    ULONG OutY;
    ULONG OutX;


    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack original value
        pInA->MoveToRow( OutY );
        pInA->Unpack( pSrcBack, Width, FALSE );

        // unpack original value
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );


        for( OutX = 0 ; OutX < Width ; ++OutX )
        {

            SHORT R, G, B;                 // input RGB values
            SHORT cMax,cMin;               // max and min RGB values

            //
            //  get R, G, and B out of DWORD.
            //
            R = pSrcFore[OutX].Red;
            G = pSrcFore[OutX].Green;
            B = pSrcFore[OutX].Blue;

            //
            //  Calculate lightness.
            //
            cMax = max(max(R, G), B);
            cMin = min(min(R, G), B);
            long iLuminance = (cMax + cMin)/2;  //fLuminance is now 0-255
            iLuminance = iLuminance * LMAX / RGBMAX; //fLuminance is now 0-100

            if( !pKey->bInvert && iLuminance != pKey->iLuminance ||
                pKey->bInvert && iLuminance ==  pKey->iLuminance )
            {
                *( (DWORD*)(&pSrcBack[OutX]) )=*(&pSrcFore[OutX]);
            }
            else if(Percent != -1)
            {
                pSrcBack[OutX].Red= pSrcFore[OutX].Red +
                    ((LONG)pSrcBack[OutX].Red - (LONG)pSrcFore[OutX].Red) * Percent ;

                pSrcBack[OutX].Green= pSrcFore[OutX].Green +
                    ((LONG)pSrcBack[OutX].Green - (LONG)pSrcFore[OutX].Green) * Percent ;

                pSrcBack[OutX].Blue= pSrcFore[OutX].Blue +
                    ((LONG)pSrcBack[OutX].Blue - (LONG)pSrcFore[OutX].Blue) * Percent ;
            }
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
}


void Key_Hue( DXSAMPLE* pSrcBack, DXSAMPLE* pSrcFore,DXTKEY *pKey, float Percent,
              ULONG Width, ULONG Height,
              IDXARGBReadPtr *pInA, IDXARGBReadPtr *pInB, IDXARGBReadWritePtr *pOut)
{

    ULONG OutY;
    ULONG OutX;

    for( OutY = 0 ; OutY < Height ; ++OutY )
    {
        // unpack original value
        pInA->MoveToRow( OutY );
        pInA->Unpack( pSrcBack, Width, FALSE );

        // unpack original value
        pInB->MoveToRow( OutY );
        pInB->Unpack( pSrcFore, Width, FALSE );

        //calc hue
        for( OutX = 0 ; OutX < Width ; ++OutX )
        {

            SHORT R, G, B;                 // input RGB values
            SHORT cMax,cMin;               // max and min RGB values
            SHORT cDif;
            SHORT iHue; //, iSaturation, iLuminance;

            //
            //  get R, G, and B out of DWORD.
            //
            R = pSrcFore[OutX].Red;
            G = pSrcFore[OutX].Green;
            B = pSrcFore[OutX].Blue;

            //
            //  Calculate lightness.
            //
            cMax = max(max(R, G), B);
            cMin = min(min(R, G), B);
//                 iLuminance = (cMax + cMin)/2;  //fLuminance is now 0-127
//  		   iLuminance /= ((RGBMAX / 2) / LMAX); //fLuminance is now 0-100

            cDif = cMax - cMin;
            if (!cDif)
            {
                //
                //  r = g = b --> Achromatic case.
                //
                iHue = UNDEFINED;                 // hue
//                  iSaturation = 0;
            }
            else
            {
                //
                //  Chromatic case.
                //

                //
                //  Luminance.
                //

                //
                //  Saturation.
                //

//                  if (iLuminance < 50)
//                  {
//                      //(0-1)     = (0-1  - 0- 1) / (0-1  + 0-1 );
//                      //          = (1    -  0  ) / ( 1 +  0 ); 1 max
//                      //			= (1 - 1)       / ( 1 + 1 ); 0 min
//                      //			=
//                      iSaturation = ((cMax - cMin) / (cMax + cMin)) / (RGBMAX / SMAX);
//                  }
//                  else
//                  {
//                      iSaturation = ((cMax - cMin) / (2.0 - cMax - cMin)) / (RGBMAX / SMAX);
//                  }

                //
                //  Hue.
                //

                if (R == cMax)
                {
                    //(0-60(?)) = (0-255 - 0-255) / (0-255 - 0-255)
                    //        =
                    iHue = ((double)(G - B) / (double)(cMax - cMin)) * 60.0;
                }
                else if (G == cMax) // pure green is 120
                {
                    iHue = 120 + ((double)(B - R) / (double)(cMax - cMin) * 60.0);
                }
                else  // (B == cMax)  pure blue is 240
                {
                    iHue = 240 + ((double)(R - G) / (double)(cMax - cMin)) * 60.0;
                }

                // bHue contained 0-6, where each was a vertices of HSL hexagon
                //  multiply by 60 degrees to find where bHue was in complete 360

                if (iHue < 0)
                {
                    //
                    //  This can occur when R == cMax and G is > B.
                    //
                    iHue += HMAX;
                }
                if (iHue >= HMAX)
                {
                    iHue -= HMAX;
                }
            }

            if( !pKey->bInvert && iHue != pKey->iHue ||
                pKey->bInvert && iHue ==  pKey->iHue )
            {
                *( (DWORD*)(&pSrcBack[OutX]) )=*(&pSrcFore[OutX]);
            }
            else if(Percent != -1)
            {
                pSrcBack[OutX].Red= pSrcFore[OutX].Red +
                    ((LONG)pSrcBack[OutX].Red - (LONG)pSrcFore[OutX].Red) * Percent ;

                pSrcBack[OutX].Green= pSrcFore[OutX].Green +
                    ((LONG)pSrcBack[OutX].Green - (LONG)pSrcFore[OutX].Green) * Percent ;

                pSrcBack[OutX].Blue= pSrcFore[OutX].Blue +
                    ((LONG)pSrcBack[OutX].Blue - (LONG)pSrcFore[OutX].Blue) * Percent ;
            }
        }

        pOut->MoveToRow( OutY );
        pOut->PackAndMove(pSrcBack,Width);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtkey\dxtkeypp.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxtkeypp.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtKeyPP.h : Declaration of the CDxtKeyPP

#ifndef __DXTKEYPP_H_
#define __DXTKEYPP_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_DxtKeyPP;

/////////////////////////////////////////////////////////////////////////////
// CDxtKeyPP
class ATL_NO_VTABLE CDxtKeyPP :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDxtKeyPP, &CLSID_DxtKeyPP>,
	public IPropertyPageImpl<CDxtKeyPP>,
	public CDialogImpl<CDxtKeyPP>
{
public:
    CDxtKeyPP() 
    {
    	m_dwTitleID = IDS_TITLEDxtKEYPP;
	m_dwHelpFileID = IDS_HELPFILEDxtKEYPP;
	m_dwDocStringID = IDS_DOCSTRINGDxtKEYPP;
    }

    enum {IDD = IDD_DXTKEYDLG};
	
DECLARE_REGISTRY_RESOURCEID(IDR_DXTKEYPP)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDxtKeyPP) 
#if(_ATL_VER < 0x0300)
	COM_INTERFACE_ENTRY_IMPL(IPropertyPage)
#else
	COM_INTERFACE_ENTRY(IPropertyPage)
#endif
END_COM_MAP()

BEGIN_MSG_MAP(CDxtKeyPP)
        //init
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	CHAIN_MSG_MAP(IPropertyPageImpl<CDxtKeyPP>)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 
    //IPropertyPage
    STDMETHOD(Apply)(void);

private:
    // Helper methods

};


#endif //__DXTKEYPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtjpegdll\stdafx.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stdafx.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

// get around problem of windowsx.h and atlwin.h not liking each other
#undef SubclassWindow

#include <atlbase.h>
#pragma intrinsic(memset, memcpy)

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

#include <DXTmpl.h>
#include <dtbase.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtkey\dxtkey.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dxtkey.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// DxtKey.h : Declaration of the CDxtKey

#ifndef __DXTKEY_H_
#define __DXTKEY_H_

#include "resource.h"       // main symbols
#include <dxatlpb.h>

#define _BASECOPY_STRING L"Copyright Microsoft Corp. 1998.  Unauthorized duplication of this string is illegal. "

//##############################################################################################3
//X: does not care the value
//A: foreground image
//B: background image
//O: output image
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//iKeyType()     |iHueOrLuminance()| dwRGBA       | iSimilarity()| iBlend()|iThreshold()|iCutOff()|bInvert(I) |iSoftWidth()     |iSoftColor()              |iGain()  | bProgress( P)|
//---------------|-----------------|--------------|--------------|---------|------------|---------|-----------|-----------------|--------------------------|---------|--------------|
//  _RGB         |X                |   0x00RGB    | S=0-100      | L=0-100 |X           |X        |TRUE/FALSE |0-0.5*imageWidth |<0, used background image |  X      | p=0.o to 1.0 |
//               |                 |              |              |         |            |         |           |                 |>=0 to 0xFFFFFFFF         |
//
//  bottom  = (A.R*(100-S)/100 << 16 ) | (  A.G*(100-S)/100 << 8 ) |(  A.B*(100-S)/100  )
//  top     = ((A.R+(0xff-A.R)*S/100) <<16 ) |( A.G+(0xff-A.G*S/100) <<8) | (A.B+(0xff-A.B)*S/100) )
// 
//if(I==FLASE)
//{
//   if( bottom<= A  &&  A<= Top )  O= ( B*(100-L*)/100 + A*L/100 )*P + A*(1-P);      
//   else O=A;
// }
// else
// {
//   if( bottom>= A  || A>= Top )  O= ( B*(100-L*)/100 + A*L/100 )*P + A*(1-P);      
//   else O=A;
// }
//    
//---------------|---------------- |--------------|--------------|---------|------------|---------|------------------------------------------------------------------
//_NONRED        |
//---------------|-----------------|--------------|--------------|---------|------------|-------- |-----------|-----------------|--------------------------|---------|---------------
//_LUMINANCE     |L=0- 255         |  X           |   X          |  X      |T=0-100     | C=0-100 |TRUE/FALSE |                 |                          | G       |   P            
//               |                 |              |              |         |
//  if(I==FALSE)
//          if( PixLuminance* G<= L*(100-T)/100 )  O=(B*(100-C)/100 + A*C/100)*P +A*(1-P)    
//          else O=A;
//  esle
//          if( PixLuminance* G >=L*(100-T)/100 )  O=(B*(100-C)/100 + A*C/100)*P +A*(1-P)     
//          else O=A;
//
//---------------|-----------------|--------------|--------------|---------|------------------------------------------------------------------------------------------------------
//  _HUE         |H=0-255          |  X           |  X           |  X      |T=1-100     | C=0-100 |TRUE/FALSE |                 |                          | G       |   P            
//
//  if(I==FALSE)
//          if( PixHue* G<= H*(100-T)/100 ) O=(B*(100-C)/100 + A*C/100)*P +A*(1-P)     
//          else O=A;
//  esle
//          if( PixHue* G >=H*(100-T)/100 ) O=(B*(100-C)/100 + A*C/100)*P +A*(1-P)     
//          else O=A;

//---------------|-----------------|--------------|----------------------------------------------------------------------------------------------------------------------
// DXTKEY_ALPHA  | X               | X            |   X          |  X      |X          | X         |TRUE/FALSE |                 |                          | X       |   X            
//
// if(I++TURE)
// {
//  pixel.Red   =A.Red  *(int)A.Alpha) & 0xff00 ) >>8);  //it should be divied by 255, used 256 as fast algorithem
//  pixel.Green =A.Green*(int)A.Alpha) & 0xff00 ) >>8);
//  pixel.Blue  =A.Blue *(int)A.Alpha) & 0xff00 ) >>8);
// }
//  else
// {
//  pixel.Red   =A.Red  *(0xff-(int)A.Alpha))& 0xff00 ) >>8);
//  pixel.Green =A.Green*(0xff-(int)A.Alpha)) & 0xff00 ) >>8);
//  pixel.Blue  =A.Blue *(oxff-(int)A.Alpha)) & 0xff00 )) >>8);
//  pixel.Alpha =A.Alpha*(0xff-(int)A.Alpha)) & 0xff00 ) >>8);
//  }
// O->OverArrayAndMove( B, pixle, Width );
//            
//---------------|-----------------|--------------|----------------------------------------------------------------------------------------------------------------------
// DXTKEY_ALPHA  | X               | X            |   X          |  X      |X          | X         |TRUE/FALSE |                 |                          | X       |   X            
//DXTKEY_PREMULT_ALPHA,  
//------------------------------------------------------------------------------------------------------------------------------------------------

typedef struct 
{
    int     iKeyType;       //keytype;          for all keys

    int     iHue;             //Hue
    int     iLuminance;          //Lumanice 
    DWORD   dwRGBA;         //RGB color,        only for _RGB, _NONRED

    int     iSimilarity;    //-1: not 

    BOOL  bInvert;        //I, except  Alpha Key
} DXTKEY;

/////////////////////////////////////////////////////////////////////////////
// CDxtKey
class ATL_NO_VTABLE CDxtKey : 
        public CDXBaseNTo1,
	public CComCoClass<CDxtKey, &CLSID_DxtKey>,
        public CComPropertySupport<CDxtKey>,
        public IPersistStorageImpl<CDxtKey>,
        public ISpecifyPropertyPagesImpl<CDxtKey>,
        public IPersistPropertyBagImpl<CDxtKey>,
	public IDispatchImpl<IDxtKey, &IID_IDxtKey, &LIBID_DexterLib>
{
    bool m_bInputIsClean;
    bool m_bOutputIsClean;
    long m_nInputWidth;
    long m_nInputHeight;
    long m_nOutputWidth;
    long m_nOutputHeight;

    //key
    DXTKEY m_Key;
public:
    DECLARE_POLY_AGGREGATABLE(CDxtKey)
    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
    DECLARE_REGISTER_DX_TRANSFORM(IDR_DXTKEY, CATID_DXImageTransform)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    
    CDxtKey();
    ~CDxtKey();

BEGIN_COM_MAP(CDxtKey)
    // Block CDXBaseNTo1 IObjectSafety implementation because we
    // aren't safe for scripting
    COM_INTERFACE_ENTRY_NOINTERFACE(IObjectSafety) 
    COM_INTERFACE_ENTRY(IDXEffect)
    COM_INTERFACE_ENTRY(IDxtKey)
    COM_INTERFACE_ENTRY(IDispatch)
#if(_ATL_VER < 0x0300)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
#else
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
#endif
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDxtKey)
    PROP_ENTRY("KeyType",         1, CLSID_DxtKeyPP)
    PROP_ENTRY("Hue", 2, CLSID_DxtKeyPP)
    PROP_ENTRY("Luminance", 3, CLSID_DxtKeyPP)
    PROP_ENTRY("RGB",            4, CLSID_DxtKeyPP)
    PROP_ENTRY("Similarity", 5, CLSID_DxtKeyPP)
    PROP_ENTRY("Invert", 6, CLSID_DxtKeyPP)
    PROP_PAGE(CLSID_DxtKeyPP)
END_PROPERTY_MAP()

    STDMETHOD(get_KeyType) ( int *);
    STDMETHOD(put_KeyType) ( int);
    STDMETHOD(get_Hue)(int *);
    STDMETHOD(put_Hue)(int );
    STDMETHOD(get_Luminance)(int *);
    STDMETHOD(put_Luminance)(int );
    STDMETHOD(get_RGB)(DWORD *);
    STDMETHOD(put_RGB)(DWORD );
    STDMETHOD(get_Similarity)(int *);
    STDMETHOD(put_Similarity)(int);
    STDMETHOD(get_Invert)(BOOL *);
    STDMETHOD(put_Invert)(BOOL);

    CComPtr<IUnknown> m_pUnkMarshaler;

    // required for ATL
    BOOL            m_bRequiresSave;

    // CDXBaseNTo1 overrides
    //
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue );
    HRESULT OnSetup( DWORD dwFlags );
    HRESULT FinalConstruct();

    // our helper function
    //
    void FreeStuff( );
    void DefaultKey(); //init m_Key


// IDxtKey
public:
};

#endif //__DxtKey_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtkey\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dxtkeydll.rc
//
#define IDS_DXTKEY                      1300
#define IDC_DXTKEY_RGB                  1301
#define IDC_DXTKEY_NONRED               1305
#define IDC_DXTKEY_LUMINANCE            1306
#define IDC_DXTKEY_ALPHA                1309
#define IDC_DXTKEY_PREMULT_ALPHA        1310
#define IDR_DXTKEY                      1320
#define IDR_DXTKEYPP                    1321
#define IDS_TITLEDxtKEYPP               1322
#define IDS_HELPFILEDxtKEYPP            1323
#define IDS_DOCSTRINGDxtKEYPP           1324
#define IDD_DXTKEYDLG                   1325
#define IDC_DXTKEYCOMBO                 1326
#define IDC_DXTKEYSLIDERSIMILAR         1327
#define IDC_DXTKEYSLIDERBLIND           1328
#define IDC_DXTKEYSLIDERTHRESHOLD       1329
#define IDC_DXTKEYSLIDERCUTOFF          1330
#define IDC_DXTKEYEDITRED               1331
#define IDC_DXTKEYEDITGREEN             1332
#define IDC_DXTKEYEDITBLUE              1333
#define IDC_DXTKEYEDITALPHA             1334

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         235
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\errlog\cerrlog.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: cerrlog.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#ifndef __CERRLOG_H__
#define __CERRLOG_H__

// for those projects who have not yet included this
//
#include <atlbase.h>

class CAMSetErrorLog : public IAMSetErrorLog
{
public:

    CComPtr< IAMErrorLog > m_pErrorLog;

public:

    CAMSetErrorLog( )
    {
    }

    // IAMSetErrorLog
    //
    STDMETHODIMP put_ErrorLog( IAMErrorLog * pLog )
    {
        m_pErrorLog = pLog;
        return 0;
    }

    STDMETHODIMP get_ErrorLog( IAMErrorLog ** ppLog )
    {
        CheckPointer( ppLog, E_POINTER );
        *ppLog = m_pErrorLog;
        if( *ppLog )
        {
            (*ppLog)->AddRef( );
        }
        return 0;
    }

    // public helper functions
    //
    STDMETHODIMP _GenerateError( long Priority, long ErrorStringId, HRESULT ErrorCode, VARIANT * pExtraInfo = NULL )
    {
        if( !m_pErrorLog )
        {
            return ErrorCode;
        }

    /*
        if( Priority > 1 )
        {
            return ErrorCode;
        }
    */

	// many errors are really just out of memory errors
	if (ErrorCode == E_OUTOFMEMORY)
	    ErrorStringId = DEX_IDS_OUTOFMEMORY;

        TCHAR tBuffer[256];
        tBuffer[0] = 0;
        LoadString( g_hInst, ErrorStringId, tBuffer, 256 );
        USES_CONVERSION;
        WCHAR * w = T2W( tBuffer );
        HRESULT hr = 0;

        CComBSTR bbb( w );
        hr = m_pErrorLog->LogError( Priority, bbb, ErrorStringId, ErrorCode, pExtraInfo );

        return hr;
    }

    STDMETHODIMP _GenerateError( long Priority, WCHAR * pErrorString, long ErrorStringId, HRESULT ErrorCode, VARIANT * pExtraInfo = NULL )
    {
        if( !m_pErrorLog )
        {
            return ErrorCode;
        }

    /*
        if( Priority > 1 )
        {
            return ErrorCode;
        }
    */

	HRESULT hr;

	// many errors are really just out of memory errors
	if (ErrorCode == E_OUTOFMEMORY) 
        {
            CComBSTR bbb( L"Out of memory" );
            hr = m_pErrorLog->LogError(Priority, bbb, DEX_IDS_OUTOFMEMORY, ErrorCode, pExtraInfo);
	} else 
        {
            CComBSTR bbb( pErrorString );
            hr = m_pErrorLog->LogError( Priority, bbb, ErrorStringId, ErrorCode, pExtraInfo );
	}
        return hr;
    }
};

#endif //__CERRLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\dxtkey\stdafx.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stdafx.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

// get around problem of windowsx.h and atlwin.h not liking each other
#undef SubclassWindow

#include <atlbase.h>
#pragma intrinsic(memset, memcpy)

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <DXTmpl.h>
#include <dtbase.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\frc\resource.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#define IDD_FRAMECONVERSION 600
#define IDC_EDIT_RATE       609
#define IDC_EDIT_FRMRATE    610
#define IDC_EDIT_SKEW       611
#define IDC_EDIT_START      612
#define IDC_EDIT_STOP       613
#define IDS_FRCPROP_TITLE   620
#ifndef IDC_STATIC
#define IDC_STATIC          -1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\frc\pthru.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: pthru.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

class CFrmRateConverter;

// {DBF8F620-53F0-11d2-9EE6-006008039E37}
DEFINE_GUID(CLSID_SkewPassThru, 
0xdbf8f620, 0x53f0, 0x11d2, 0x9e, 0xe6, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37);

class CSkewPassThru : public CPosPassThru
		    
{
    friend class CFrmRateConverter;
    friend class CFrmRateConverterOutputPin;

public:

    CSkewPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *, CFrmRateConverter *pFrm);

    //only support IMediaSeeking
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities ); 
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);	
    STDMETHODIMP GetTimeFormat(GUID *pFormat);		    
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);  
    STDMETHODIMP IsFormatSupported( const GUID * pFormat); 
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);	    
    
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll ) { if( pllPreroll) *pllPreroll =0; return S_OK; };
    
    //methods we do not support
    STDMETHODIMP SetRate( double dRate)	    { return E_NOTIMPL; };
    // STDMETHODIMP GetRate( double * pdRate); //use the base class
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
				   LONGLONG    Source, const GUID * pSourceFormat ){ return E_NOTIMPL ;};


private:
    
    // converts clip time to timeline time
    HRESULT FixTime(REFERENCE_TIME *prt, int nCurSeg);
    // converts timeline time to clip time
    int FixTimeBack(REFERENCE_TIME *prt, BOOL fRound);

    // allow CSkewPassThru access FrmRateConverter's m_rtSetStart, m_rtSetStop throught get_StartStop()
    CFrmRateConverter	*m_pFrm;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\frc\prop.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: prop.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;


#include <windows.h>
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "FRC.h"
#include "PThru.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////
//
// CFrcPropertyPage
//
//////////////////////////////////////////////////////////////////////////

//
// CreateInstance
//
CUnknown *CFrcPropertyPage::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)

  { // CreateInstance //

    CUnknown *punk = new CFrcPropertyPage(lpunk, phr);

    if (NULL == punk)
	    *phr = E_OUTOFMEMORY;

    return punk;

  } // CreateInstance //

CFrcPropertyPage::CFrcPropertyPage(LPUNKNOWN pUnk, HRESULT *phr) : CBasePropertyPage(NAME("Frame Rate Converter Property Page"), pUnk, IDD_FRAMECONVERSION, IDS_FRCPROP_TITLE), m_pifrc(NULL), m_bInitialized(FALSE)

  { // Constructor //
  } // Constructor //

void CFrcPropertyPage::SetDirty()

  { // SetDirty //

      m_bDirty = TRUE;

      if (m_pPageSite)
	m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

  } // SetDirty //

HRESULT CFrcPropertyPage::OnActivate (void)

  { // OnActivate //

    m_bInitialized = TRUE;

    return NOERROR;

  } // OnActivate //

HRESULT CFrcPropertyPage::OnDeactivate (void)

  { // OnDeactivate //

    m_bInitialized = FALSE;

    GetControlValues();

    return NOERROR;

  } // OnDeactivate //

INT_PTR CFrcPropertyPage::OnReceiveMessage (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

  { // OnReceiveMessage //

    ASSERT(m_pifrc != NULL);

    switch(uMsg)

      { // Switch

	case WM_COMMAND:

	  if (!m_bInitialized)
	    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

	  m_bDirty = TRUE;

	  if (m_pPageSite)
	    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

	  return TRUE;

        case WM_INITDIALOG:
          SetDlgItemInt(hwnd, IDC_EDIT_FRMRATE,(int)(m_dFrameRate * 100),FALSE);
          SetDlgItemInt(hwnd, IDC_EDIT_RATE,(int)(m_dRate * 100),FALSE);
          SetDlgItemInt(hwnd, IDC_EDIT_SKEW, (int)(m_rtSkew / 10000), TRUE);
          SetDlgItemInt(hwnd, IDC_EDIT_START, (int)(m_rtMediaStart / 10000),
									FALSE);
          SetDlgItemInt(hwnd, IDC_EDIT_STOP, (int)(m_rtMediaStop / 10000),
									FALSE);
          return TRUE;
          break;

	default:
	  return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
	  break;

      } // Switch

  } // OnReceiveMessage //

HRESULT CFrcPropertyPage::OnConnect (IUnknown *pUnknown)

  { // OnConnect //

    pUnknown->QueryInterface(IID_IDexterSequencer, (void **)&m_pifrc);

    ASSERT(m_pifrc != NULL);

    // Defaults from filter's current values (via IDexterSequencer)
    m_pifrc->get_OutputFrmRate(&m_dFrameRate);

    // !!! we only support one start/stop/skew in this prop page
    int c;
    m_pifrc->GetStartStopSkewCount(&c);

    REFERENCE_TIME *pStart = (REFERENCE_TIME *)QzTaskMemAlloc(c * 3 *
				sizeof(REFERENCE_TIME) + c * sizeof(double));
    if (pStart == NULL) {
	return E_OUTOFMEMORY;
    }
    REFERENCE_TIME *pStop = pStart + c;
    REFERENCE_TIME *pSkew = pStop + c;
    double *pRate = (double *)(pSkew + c);

    m_pifrc->GetStartStopSkew(pStart, pStop, pSkew, pRate);

    m_rtMediaStart = *pStart;
    m_rtMediaStop = *pStop;
    m_rtSkew = *pSkew;
    m_dRate = *pRate;

    m_bInitialized = FALSE;

    QzTaskMemFree(pStart);

    return NOERROR;

  } // OnConnect //

HRESULT CFrcPropertyPage::OnDisconnect()

  { // OnDisconnect //

    if (m_pifrc)

      { // Release

	m_pifrc->Release();
	m_pifrc = NULL;

      } // Release

    m_bInitialized = FALSE;

    return NOERROR;

  } // OnDisconnect //

HRESULT CFrcPropertyPage::OnApplyChanges()

  { // OnApplyChanges //

    ASSERT(m_pifrc != NULL);

    GetControlValues();

    // !!! we only support one start/stop/skew right now

    m_pifrc->put_OutputFrmRate(m_dFrameRate);
    m_pifrc->ClearStartStopSkew();
    m_pifrc->AddStartStopSkew(m_rtMediaStart, m_rtMediaStop, m_rtSkew, m_dRate);

    return NOERROR;

  } // OnApplyChanges //

void CFrcPropertyPage::GetControlValues (void)

  { // GetControlValues //

    int n;

    // Frame rate
    n = GetDlgItemInt(m_Dlg, IDC_EDIT_FRMRATE, NULL, FALSE);
    m_dFrameRate = (double)(n / 100.);

    // Playback rate
    n = GetDlgItemInt(m_Dlg, IDC_EDIT_RATE, NULL, FALSE);
    m_dRate = (double)(n / 100.);

    // Skew
    n = GetDlgItemInt(m_Dlg, IDC_EDIT_SKEW, NULL, TRUE);
    m_rtSkew = (REFERENCE_TIME)n * 10000;

    // Media times
    n = GetDlgItemInt(m_Dlg, IDC_EDIT_START, NULL, FALSE);
    m_rtMediaStart = (REFERENCE_TIME)n * 10000;
    n = GetDlgItemInt(m_Dlg, IDC_EDIT_STOP, NULL, FALSE);
    m_rtMediaStop = (REFERENCE_TIME)n * 10000;

  } // GetControlValues //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\frc\frc.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: frc.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

class CSkewPassThru;     // IMediaSeeking support
class CFRCWorker;
class CFrmRateConverter;

extern const AMOVIESETUP_FILTER sudFrmRateConv;

class CFRCWorker : public CAMThread
{

    CFrmRateConverter * m_pFRC;

public:
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

private:
    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    HRESULT DoRunLoop(void);

public:
    CFRCWorker();

    BOOL Create(CFrmRateConverter * pFRC);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();

    HRESULT Exit();
};


class CFrmRateConverter : public CTransInPlaceFilter,
		public IDexterSequencer ,public ISpecifyPropertyPages,
		public CPersistStream
{
    friend class CFrmRateConverterOutputPin;
    friend class CFrmRateConverterInputPin;
    //friend class CFrmRateInputAllocator;
    friend class CSkewPassThru;
    friend class CFRCWorker;

public:
    CFrmRateConverter(TCHAR *, LPUNKNOWN, REFCLSID clsid, HRESULT *);
    ~CFrmRateConverter();

    DECLARE_IUNKNOWN;

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr);
    
    // Reveals IDexterSequencer
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    CBasePin *GetPin(int n);

    // Overrriden from CTransformFilter base class
    
    // override this to customize the transform process
    
    HRESULT Transform(IMediaSample *pSample) { return NOERROR ;};
    HRESULT Receive(IMediaSample *pSample);
    HRESULT CheckInputType(const CMediaType *mtIn);
    // not allowed HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT EndOfStream();
    HRESULT NewSegment(
                        REFERENCE_TIME tStart,
                        REFERENCE_TIME tStop,
                        double dRate);

    HRESULT StartStreaming();
    HRESULT StopStreaming();
    STDMETHODIMP Stop();
    HRESULT BeginFlush();
    HRESULT EndFlush();

    HRESULT NextSegment(BOOL);
    HRESULT SeekNextSegment();

    // These implement the custom IDexterSequencer interface
    // FrmRate == FrmPerSecond
    STDMETHODIMP get_OutputFrmRate(double *dpFrmRate);
    STDMETHODIMP put_OutputFrmRate(double dFrmRate);
    STDMETHODIMP ClearStartStopSkew();
    STDMETHODIMP AddStartStopSkew(REFERENCE_TIME Start, REFERENCE_TIME Stop,
				  REFERENCE_TIME Skew, double dRate);
    STDMETHODIMP GetStartStopSkewCount(int *pCount);
    STDMETHODIMP GetStartStopSkew(REFERENCE_TIME *pStart, REFERENCE_TIME *pStop,
				  REFERENCE_TIME *pSkew, double *pdRate);
    STDMETHODIMP get_MediaType( AM_MEDIA_TYPE * pMediaType );
    STDMETHODIMP put_MediaType( const AM_MEDIA_TYPE * pMediaType );

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages (CAUUID *);

    // Constructor
    CFrmRateConverter(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

protected:

    CFrmRateConverterOutputPin *OutputPin()
    {
        return (CFrmRateConverterOutputPin *)m_pOutput;
    };
   
    double	m_dOutputFrmRate;	    // Output frm rate

    // StartStopSkew stuff

    typedef struct {
        REFERENCE_TIME rtMStart;
        REFERENCE_TIME rtMStop;
        REFERENCE_TIME rtSkew;
        REFERENCE_TIME rtTLStart;
        REFERENCE_TIME rtTLStop;
        double dRate;
    } FRCSKEW;

    FRCSKEW *m_pSkew;
    int m_cTimes;	// valid # of items in array
    int m_cMaxTimes;	// space allocated for this many

    int m_nCurSeg;	// current index of array being played
    int m_nSeekCurSeg;	// new value being set by the seek

    CMemAllocator *m_pUpAllocator;  // to get buffers to upsample into

    LONGLONG m_llOutputSampleCnt;

    REFERENCE_TIME m_rtLastSeek;	// last timeline time seek command
    REFERENCE_TIME m_rtNewLastSeek;	// what m_rtLastSeek is going to be

    LONGLONG m_llStartFrameOffset;	// after a seek, the first frame sent
					// (in timeline time)

    BOOL m_fSeeking;		// in the middle of seeking?
    HANDLE m_hEventSeek;	// wait before accepting data

    CMediaType m_mtAccept;	// accept only this type
    bool m_bMediaTypeSetByUser; // is m_mtAccept valid?

    CFRCWorker m_worker;	// worker thread for re-using sources
    HANDLE m_hEventThread;	// OK, time to wake up
    BOOL m_fThreadMustDie;
    BOOL m_fThreadCanSeek;
    BOOL m_fSpecialSeek;
    CCritSec m_csThread;

    BOOL m_fJustLate;	// we just got a late notification
    Quality m_qJustLate;// (and it was this one)

    BOOL m_fStopPushing;
    BOOL m_fFlushWithoutSeek;

    // hack to correct for broken parsers that don't send end time right
    BOOL m_fParserHack;	// do we do this hack at all?
    IMediaSample *m_pHackSample[2];	// we keep 2 samples around
    int m_nHackCur;			// which sample we use right now

    REFERENCE_TIME m_rtNewSeg;

}; // FrmRateConverter


//
// CFrmRateConverterOutputPin class
//
class CFrmRateConverterOutputPin : public CTransInPlaceOutputPin
{
    friend class CFrmRateConverter;
    friend class CFrmRateConverterInputPin;
    //friend class CFrmRateInputAllocator;

public:
    CFrmRateConverterOutputPin( TCHAR *pObjectName
                             , CFrmRateConverter *pFrmRateConverter
                             , HRESULT * phr
                             , LPCWSTR pName
                             );

    ~CFrmRateConverterOutputPin();

    STDMETHODIMP ReceiveAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **); //for IMediaSeeking
    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);

   
private:
    CFrmRateConverter     *m_pFrmRateConverter;
    CSkewPassThru	  *m_pSkewPassThru;

    
};

class CFrcPropertyPage : public CBasePropertyPage
{
    public:

      static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    private:

      INT_PTR OnReceiveMessage (HWND, UINT ,WPARAM ,LPARAM);

      HRESULT OnConnect (IUnknown *);
      HRESULT OnDisconnect (void);
      HRESULT OnActivate (void);
      HRESULT OnDeactivate (void);
      HRESULT OnApplyChanges (void);

      void SetDirty (void);

      CFrcPropertyPage (LPUNKNOWN, HRESULT *);

      void GetControlValues (void);

      IDexterSequencer *m_pifrc;

      // Temporary variables (until OK/Apply)

      double          m_dFrameRate;
      double          m_dRate;
      REFERENCE_TIME  m_rtSkew;
      REFERENCE_TIME  m_rtMediaStart;
      REFERENCE_TIME  m_rtMediaStop;
      BOOL            m_bInitialized;

};



//
// CFrmRateConverterInputPin class - override GetAllocator
//
class CFrmRateConverterInputPin : public CTransInPlaceInputPin 
{
    friend class CFrmRateConverter;
    friend class CFrmRateConverterOutputPin;
    //friend class CFrmRateInputAllocator;

public:
    CFrmRateConverterInputPin( TCHAR *pObjectName
                             , CFrmRateConverter *pFrmRateConverter
                             , HRESULT * phr
                             , LPCWSTR pName
                             );

    ~CFrmRateConverterInputPin();

    // we still need this class to peek at m_pAllocator
    //CFrmRateInputAllocator *m_pFakeAllocator;
    //STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\frc\pthru.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: pthru.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "FRC.h"
#include "PThru.h"
#include "..\util\conv.cxx"

const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

BOOL SafeSetEvent(HANDLE h);

CSkewPassThru::CSkewPassThru(const TCHAR *pName,
			   LPUNKNOWN pUnk,
			   HRESULT *phr,
			   IPin *pPin,
			   CFrmRateConverter *pFrm) :
    CPosPassThru(pName,pUnk, phr, pPin),
    m_pFrm( pFrm )
{
}

// Expose our IMediaSeeking interfaces
STDMETHODIMP
CSkewPassThru::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    *ppv = NULL;

    if (riid == IID_IMediaSeeking)
    {
	return GetInterface( static_cast<IMediaSeeking *>(this), ppv);
    }
    else {
	//we only support the IID_DIMediaSeeking
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// fix a clip time into timeline time, bounding it by the legal area
// Only works for the current segment
//
HRESULT CSkewPassThru::FixTime(REFERENCE_TIME *prt,  int nCurSeg)
{
    CheckPointer(prt, E_POINTER);

    REFERENCE_TIME rtStart, rtStop, rtSkew;
    rtSkew = m_pFrm->m_pSkew[nCurSeg].rtSkew;
    rtStart = m_pFrm->m_pSkew[nCurSeg].rtMStart;
    rtStop = m_pFrm->m_pSkew[nCurSeg].rtMStop;
    if (*prt < rtStart)
	*prt = rtStart;
    if (*prt > rtStop)
	*prt = rtStop;
    *prt = (REFERENCE_TIME)(rtStart + rtSkew + (*prt - rtStart) /
				 	m_pFrm->m_pSkew[nCurSeg].dRate);
    return S_OK;
}


// fix a timeline time back into clip time, bounding it by the legal area
// of a segment.
// If it's in between segments, use the beginning of the next segment
// Returns the segment it's in
// Optionally, round the time DOWN to a frame boundary before skewing. This
// makes sure seeking to a spot gives the same frame as playing up to that
// spot does (for the down sampling case)
//
int CSkewPassThru::FixTimeBack(REFERENCE_TIME *prt, BOOL fRound)
{
    CheckPointer(prt, E_POINTER);
    REFERENCE_TIME rtStart, rtStop, rtSkew;
    REFERENCE_TIME rtTLStart, rtTLStop;
    double dRate;

    if (m_pFrm->m_cTimes == 0) {
	ASSERT(FALSE);
	return 0;
    }

    if (fRound)
    {
        LONGLONG llOffset = Time2Frame( *prt, m_pFrm->m_dOutputFrmRate );
    	*prt = Frame2Time( llOffset, m_pFrm->m_dOutputFrmRate );
    }

    REFERENCE_TIME rtSave; // always inited below (where it's needed)
    for (int z = 0; z < m_pFrm->m_cTimes; z++) {
        rtSkew = m_pFrm->m_pSkew[z].rtSkew;
        rtStart = m_pFrm->m_pSkew[z].rtMStart;
        rtStop = m_pFrm->m_pSkew[z].rtMStop;
        dRate = m_pFrm->m_pSkew[z].dRate;
	rtTLStart = rtStart + rtSkew;
	rtTLStop = rtStart + rtSkew +
			(REFERENCE_TIME) ((rtStop - rtStart) / dRate);
	if (*prt < rtTLStart) {
	    *prt = rtStart;
	    break;
	} else if (*prt >= rtTLStop) {
	    // just in case there is no next segment, this is the final value
	    rtSave = rtStop;
	} else {
    	    *prt = (REFERENCE_TIME)(rtStart + (*prt - (rtStart + rtSkew)) *
								dRate);
	    break;
	}
    }
    if (z == m_pFrm->m_cTimes) {
	z--;
	*prt = rtSave;
    }
    return z;
}


// --- IMediaSeeking methods ----------

STDMETHODIMP
CSkewPassThru::GetCapabilities(DWORD * pCaps)
{
    return CPosPassThru::GetCapabilities(pCaps);
}


STDMETHODIMP
CSkewPassThru::CheckCapabilities(DWORD * pCaps)
{
    return CPosPassThru::CheckCapabilities(pCaps);
}


STDMETHODIMP
CSkewPassThru::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

STDMETHODIMP
CSkewPassThru::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

STDMETHODIMP
CSkewPassThru::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);

    if(*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return E_FAIL;
}

STDMETHODIMP
CSkewPassThru::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    return S_OK;
}

STDMETHODIMP
CSkewPassThru::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    if (*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return S_FALSE;
}

// The biggie!
//
STDMETHODIMP
CSkewPassThru::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
    // make sure our re-using sources thread isn't seeking at the moment.
    // Wait till it's done, so the app seek happens last, and that the thread
    // won't seek anymore from now on

    CAutoLock cAutolock(&m_pFrm->m_csThread);

    // make sure the state doesn't change while doing this
    CAutoLock c(&m_pFrm->m_csFilter);

    m_pFrm->m_fThreadCanSeek = FALSE;

    HRESULT hr;
    REFERENCE_TIME rtStart, rtStop = MAX_TIME;
    int nCurSeg = m_pFrm->m_nCurSeg;

    // we don't do segments
    if ((CurrentFlags & AM_SEEKING_Segment) ||
				(StopFlags & AM_SEEKING_Segment)) {
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("FRC: ERROR-Seek used EC_ENDOFSEGMENT!")));
	return E_INVALIDARG;
    }

    // figure out where we're seeking to, and add skew to make it in timeline
    // time

    // !!! We ignore stop times, because of the way we re-use sources and play
    // things in segments.  We will always send a stop time upstream equal to
    // the end of the current segment, and only pay attention to changes in the
    // start time.  This will work only because the switch will ignore things
    // we send after we were supposed to stop and stop us.

    DWORD dwFlags = (CurrentFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	rtStart = *pCurrent;
	// round seek request to nearest output frame
	nCurSeg = FixTimeBack(&rtStart, TRUE);
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	hr = CPosPassThru::GetCurrentPosition(&rtStart);
	if (hr != S_OK)
	    return hr;
	FixTime(&rtStart, m_pFrm->m_nCurSeg);
	rtStart += *pCurrent;
	// round seek request to nearest output frame
	nCurSeg = FixTimeBack(&rtStart, TRUE);
    } else if (dwFlags) {
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Invalid Current Seek flags")));
	return E_INVALIDARG;
    }

    // nothing to do
    if (!(CurrentFlags & AM_SEEKING_PositioningBitsMask)) {
	return S_OK;
    }

    DWORD CFlags = CurrentFlags & ~AM_SEEKING_PositioningBitsMask;
    DWORD SFlags = StopFlags & ~AM_SEEKING_PositioningBitsMask;
    CFlags |= AM_SEEKING_AbsolutePositioning;
    SFlags |= AM_SEEKING_AbsolutePositioning;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("FRC: Seek from %d to %dms"),
					(int)(rtStart / 10000),
					(int)(rtStop / 10000)));

    // note we're seeking during the flush that this will generate
    m_pFrm->m_fSeeking = TRUE;

    // we can't set the LastSeek variable until we've been flushed, and old
    // data has stopped arriving.  It must be set between the flush and the
    // next NewSegment call, so we'll set it in EndFlush to this value
    m_pFrm->m_rtNewLastSeek = rtStart;
    FixTime(&m_pFrm->m_rtNewLastSeek, nCurSeg);

    // the flush generated by the seek below needs to know this
    m_pFrm->m_nSeekCurSeg = nCurSeg;

    // I know we were asked to play until time n, but I'm going to tell it to
    // play all the way to the end.  If there's a gap in the file, and the stop
    // time is during the gap, we won't get enough samples to fill the whole
    // playing time.  If we play until the end, we'll get the first sample
    // after the gap, notice it's after the time we originally wanted to stop
    // at, and send the frame we get to fill the gap, which is better than
    // sending nothing (we have to send samples without gaps, or the switch
    // won't work).  The alternative is to copy every frame, and resend copies
    // of the last thing we got if we see an EOS too early (less efficient)
    // or to create black frames and send them to fill the gap (that would
    // only work for mediatypes we knew about, something I hesitate to do).
    hr = CPosPassThru::SetPositions(&rtStart, CFlags, NULL, 0);

    // We assume all Dexter sources are seekable
    if (hr != S_OK) {
        DbgLog((LOG_ERROR,TRACE_HIGHEST,TEXT("FRC SEEK FAILED")));
	//m_pFrm->FakeSeek(rtStart);
    }

    // if the push thread was stopped, we won't get flushed, and this won't
    // have been updated
    // !!! I ASSUME the push thread won't be started until this thread does it
    // when this function returns, or there is a race condition
    m_pFrm->m_rtLastSeek = m_pFrm->m_rtNewLastSeek;

    // !!! if we ever support Rate, we need to take the seek rate into account
    hr = CPosPassThru::SetRate(1.0);

    // all done
    m_pFrm->m_fSeeking = FALSE;

    // reset same stuff we reset when we start streaming
    m_pFrm->m_llOutputSampleCnt = 0;

    // in case we weren't flushed
    m_pFrm->m_nCurSeg = nCurSeg;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("FRC:Seeked into segment %d, rate = %d/100"), nCurSeg,
				(int)(m_pFrm->m_pSkew[nCurSeg].dRate * 100)));

    // (see comment about sharing a source filter at the top of audpack.cpp)
    // We were waiting for this seek, ever since we got a surprise flush.
    // Now that the switch knows about the seek, we can resume sending it
    // new data, and allow Receive to be entered (set the Seek event)
    // being careful to set all our variables up BEFORE releasing the hounds
    //
    if (m_pFrm->m_fFlushWithoutSeek) {
	m_pFrm->m_fFlushWithoutSeek = FALSE;
    	DbgLog((LOG_TRACE,1,TEXT("SURPRISE FLUSH followed by a SEEK - OK to resume")));

        // DO NOT FLUSH! The push thread has already started delivering the new
        // post-seek data... flushing will kill it and hang us!
	
    } else if (m_pFrm->m_State == State_Paused) {
	// Set this so that if a flush ever happens without a seek later,
	// we'll know that flush was AFTER the seek, not before
	m_pFrm->m_fFlushWithoutSeek = TRUE;
    }

    // only now that the above calculations were made, can we accept data again
    SafeSetEvent(m_pFrm->m_hEventSeek);

    return S_OK;
}

STDMETHODIMP
CSkewPassThru::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop)
{
    HRESULT hr=CPosPassThru::GetPositions(pCurrent, pStop);
    if(hr== S_OK)
    {
	FixTime(pCurrent, m_pFrm->m_nCurSeg);
	FixTime(pStop, m_pFrm->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CSkewPassThru::GetCurrentPosition(LONGLONG *pCurrent)
{
    HRESULT hr = CPosPassThru::GetCurrentPosition(pCurrent);
    if(hr== S_OK)
    {
	FixTime(pCurrent, m_pFrm->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CSkewPassThru::GetStopPosition(LONGLONG *pStop)
{
    HRESULT hr=CPosPassThru::GetStopPosition(pStop);
    if( hr == S_OK)
    {
	FixTime(pStop, m_pFrm->m_nCurSeg);
    }
    return hr;
}

STDMETHODIMP
CSkewPassThru::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
    CheckPointer(pEarliest, E_POINTER);
    CheckPointer(pLatest, E_POINTER);
    *pEarliest = m_pFrm->m_pSkew[m_pFrm->m_nCurSeg].rtMStart;
    *pLatest = m_pFrm->m_pSkew[m_pFrm->m_nCurSeg].rtMStop;
    FixTime(pEarliest, m_pFrm->m_nCurSeg);
    FixTime(pLatest, m_pFrm->m_nCurSeg);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\frc\frc.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: frc.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// !!! The MEDIA TIMES are not fixed up!  This could mess up live data!

/*

This video frame rate converter will perfectly correct time stamps to be at the
new frame rate (specified as a double, not in UNITS), with no error propagation.
It is an IN-PLACE transform that does not copy any data, just munges time stamps
and delivers some frames more than once.  Thus it allows itself to be in pass through mode with read-only buffers since it doesn't actually touch them.

It supports IDexterSequencer

It also delivers only the piece of a file you want, not the entire file.
It also skews time stamps linearly by a set amount.  For instance, if you are
doing an editing project and want the part of a movie from 15 to 25 seconds to
play starting at 30 seconds into your project, you set m_rtMediaStart to 15,
m_rtMediaStop to 25, and m_rtSkew to 15.  This filter will send a NewSegment
of 30 seconds, and then just the frames from 15 to 25 seconds of this movie,
time stamped starting at 0.

If you wish to play a 10 second video clip in only 5 seconds of timeline time,
this filter will pass a rate upstream, and do the rate change. (also does
slo motion)

#if 0
We also do fancy allocator stuff:  Normally the upstream filter calls GetBuffer
directly on the downstream filter, bypassing us.  That is bad, we need to make
the timestamps on GetBuffer what they will be when we call Receive, or the
downstream switch misbehaves, so we have a special fake allocator that sees
the GetBuffer request, and passes it downstream with corrected time stamps.
#endif

An output frame rate of 0 is a special thing... we will NOT do any frame rate
converting... for example, if we are doing smart recompression and need to
pass compressed data along without modifying it in any way, we'll do the
skewing, to fix the media times to timeline time, but we will never upsample
or downsample

*/

// NOTES ON SHARING A SOURCE FILTER:  The same source filter may be used in
// the video group, and the audio group, to avoid opening it twice. Seeking
// such a graph is complicated.  For the AVI parser, here's the behaviour...
// a seek on the video pin is obeyed, and seeks on the audio pin are ignored.
// (they better be identical anyway).  So what happens if the video switch is
// seeked first, is that that will cause the splitter to flush and send the
// new data to the audio branch, much to the surprise of the audio branch.
// Then later, the audio switch will see the seek, and the audio chain will
// ignore it.
// If the audio switch is seeked first, then we will see the seek, but nothing
// will happen, and then later when the video group is seeked, the audio chain
// will get flushed, and new data delivered, again, much to our surprise.
//
// So, if we get flushed during a seek, that's the normal case.  But now there
// are 2 other cases:
// 1. We get flushed out of nowhere. Wait for the seek we know is coming, and
//    then allow ourself to deliver data again (we need to wait for the switch
//    to be expecting the new data)
// 2. We get a seek, then a surprise flush.  We can start sending new data right
//    away without waiting for another seek.


//
//
// Summary
//
// This is a Frame Rate Converter Filter
//
//
// Files/
//
// FRC.cpp              Main filter and outputpin code
// FRC.h                Class definition for the filter and output pin
// PThru.cpp            CSkewPassThru class which supports IMediaSeeking
// PThru.h              Class definition for the CSkewClass
//
// Base classes used
//
// CTransInPlaceFilter  A transform filter with one input and output pin
//
//

#include <windows.h>
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "FRC.h"
#include "PThru.h"
#include "resource.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"

// for time stamp rounding errors (1ms)
#define FUDGE 10000

// Setup information
const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Video,       // Major type
    &MEDIASUBTYPE_NULL      // Minor type
};

const AMOVIESETUP_PIN sudpPins[] =
{
    { L"Input",             // Pins string name
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Are we allowed none
      FALSE,                // And allowed many
      &CLSID_NULL,          // Connects to filter
      NULL,                 // Connects to pin
      1,                    // Number of types
      &sudPinTypes          // Pin information
    },
    { L"Output",            // Pins string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Are we allowed none
      FALSE,                // And allowed many
      &CLSID_NULL,          // Connects to filter
      NULL,                 // Connects to pin
      1,                    // Number of types
      &sudPinTypes          // Pin information
    }
};

const AMOVIESETUP_FILTER sudFrmRateConv =
{
    &CLSID_FrmRateConverter,         // Filter CLSID
    L"Frame Rate Converter",       // String name
    MERIT_DO_NOT_USE,       // Filter merit
    2,                      // Number of pins
    sudpPins                // Pin information
};


const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

BOOL SafeResetEvent(HANDLE h);
BOOL SafeSetEvent(HANDLE h);
    
//
// Constructor
//
CFrmRateConverter::CFrmRateConverter(TCHAR *tszName,
		   LPUNKNOWN punk,
		   REFCLSID clsid,
		   HRESULT *phr) :
    CTransInPlaceFilter(tszName, punk, CLSID_FrmRateConverter, phr),
    CPersistStream(punk, phr),
    m_dOutputFrmRate(15.0),	// default output frame rate
    m_pSkew(NULL),
    m_cTimes(0),
    m_cMaxTimes(0),
    m_rtLastSeek(-1),		// nobody has seeked us yet
    m_fSeeking(FALSE),		// not seeking now
    m_bMediaTypeSetByUser(false),
    m_fSpecialSeek(FALSE),
    m_fJustLate(FALSE),
    m_fStopPushing(FALSE),
    m_fFlushWithoutSeek(FALSE),
    m_fParserHack(FALSE),
    m_fThreadMustDie(FALSE),
    m_pUpAllocator(NULL),
    //m_fCantSeek(FALSE),
    //m_rtFakeSeekOffset(0),
    m_nHackCur(0)
    , m_hEventSeek(0)
    , m_hEventThread(0)
{
    m_pHackSample[0] = NULL;
    m_pHackSample[1] = NULL;

    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE));
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateConverter::CFrmRateConverter")));

    // by default, play the movie normally
    AddStartStopSkew(0, MAX_TIME, 0, 1.0);
    m_nCurSeg = 0;

} // (Constructor)


CFrmRateConverter::~CFrmRateConverter()
{
    if (m_pSkew)
	QzTaskMemFree(m_pSkew);

    ASSERT(m_hEventThread == 0);
    ASSERT(m_hEventSeek == 0);
}


//
// CreateInstance
//
// Provide the way for COM to create a FrmRateConverter object
//
CUnknown *CFrmRateConverter::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CFrmRateConverter *pNewObject = new CFrmRateConverter(NAME("Frame Rate Converter"),
							punk,
							CLSID_FrmRateConverter,
							phr);
    if (pNewObject == NULL) {
	*phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// NonDelegatingQueryInterface
//
// Reveals IIPEffect and ISpecifyPropertyPages
//
STDMETHODIMP CFrmRateConverter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (IsEqualIID(IID_ISpecifyPropertyPages, riid)) {
      return GetInterface((ISpecifyPropertyPages *)this, ppv);
    } else if (riid == IID_IDexterSequencer) {
	return GetInterface((IDexterSequencer *) this, ppv);
    } else if (riid == IID_IPersistStream) {
	return GetInterface((IPersistStream *) this, ppv);
    } else {
	return CTransInPlaceFilter::NonDelegatingQueryInterface(riid, ppv);
    }
} // NonDelegatingQueryInterface




HRESULT CFrmRateConverter::NextSegment(BOOL fUseOtherThread)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC:Done Segment %d"), m_nCurSeg));

    if (m_nCurSeg < m_cTimes) {
        m_nCurSeg++;
    }

    if (m_nCurSeg == m_cTimes) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC:ALL done")));
	// deliver EOS only after all segs done
	CTransInPlaceFilter::EndOfStream();
	return S_OK;
    }

    // WE CANNOT SEEK ON the source's pushing thread, or you hang.
    // (That's just the rule).  So we have a separate thread that can seek
    // for us in that case.  Let's wake it up.
    if (fUseOtherThread) {
        m_fThreadCanSeek = TRUE;
        SetEvent(m_hEventThread);
    } else {
	m_fThreadCanSeek = TRUE;
	hr = SeekNextSegment();
    }

    return hr;
}


// called by our special thread to do the seek to the next segment
//
HRESULT CFrmRateConverter::SeekNextSegment()
{
    // our thread can't seek at the same time the app seeks us
    CAutoLock cAutolock(&m_csThread);

    // it is not safe for our thread to seek
    if (!m_fThreadCanSeek) {
	return S_OK;
    }
    m_fThreadCanSeek = FALSE;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC:Delayed Seek for NextSegment")));

    // in timeline time (which includes skew), this is where we are starting
    m_rtNewLastSeek = m_pSkew[m_nCurSeg].rtTLStart;
    m_nSeekCurSeg = m_nCurSeg;	// EndFlush looks at this

    // ??? will we get a new seg for sure?

    // note we're seeking during the flush that this will generate
    m_fSeeking = TRUE;
    m_fSpecialSeek = TRUE;

    IMediaSeeking *pMS;
    IPin *pPin = m_pInput->GetConnected();
    HRESULT hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pMS);

    // sources have to support seeking right now
    if (FAILED(hr)) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("FRC SEEK FAILED")));
	//FakeSeek(m_prtStart[m_nCurSeg]);
	//goto OK;
	return E_FAIL;
    }

    // Make sure we're talking MEDIA TIME
    hr = pMS->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);
    // this will FAIL if we're not stopped, and that's OK

    // we don't tell the source to change the rate.  We do it ourself.  We may
    // be sharing this source with somebody else, who will panic if the rate
    // is not 1.

    hr = pMS->SetRate(1.0);

    // I know we were asked to play until time n, but I'm going to tell it to
    // play all the way to the end.  If there's a gap in the file, and the stop
    // time is during the gap, we won't get enough samples to fill the whole
    // playing time.  If we play until the end, we'll get the first sample
    // after the gap, notice it's after the time we originally wanted to stop
    // at, and send the frame we get to fill the gap, which is better than
    // sending nothing (we have to send samples without gaps, or the switch
    // won't work).  The alternative is to copy every frame, and resend copies
    // of the last thing we got if we see an EOS too early (less efficient)
    // or to create black frames and send them to fill the gap (that would
    // only work for mediatypes we knew about, something I hesitate to do).
    hr = pMS->SetPositions(&m_pSkew[m_nCurSeg].rtMStart,
			AM_SEEKING_AbsolutePositioning, NULL, 0);
    if (hr != S_OK) {
        DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("FRC SEEK FAILED")));
	//FakeSeek(m_prtStart[m_nCurSeg]);
	pMS->Release();
	return hr;
    }

    pMS->Release();

    // if the push thread was stopped, we won't get flushed, and this won't
    // have been updated
    // !!! I ASSUME the push thread won't be started until this thread does it
    // when this function returns, or there is a race condition
    m_rtLastSeek = m_rtNewLastSeek;

    // all done
    m_fSpecialSeek = FALSE;
    m_fSeeking = FALSE;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Seg=%d  Seeking source to %d,%d ms"),
				m_nCurSeg,
				(int)(m_pSkew[m_nCurSeg].rtMStart / 10000),
				(int)(m_pSkew[m_nCurSeg].rtMStop / 10000)));

    // reset same stuff we reset when we start streaming
    m_llOutputSampleCnt = 0;

    // only now that the above calculations were made, can we accept data again
    SetEvent(m_hEventSeek);

    return S_OK;
}


// Fix the time stamps, deliver this frame 0, 1 or more times to convert the
// frame rate
// When run, all time stamps we send are 0 based.  The new segment will reflect
// what piece of the movie this is and the skew
//
HRESULT CFrmRateConverter::Receive(IMediaSample *pSample)
{
    // Stop pushing data to me!
    if (m_fStopPushing) {
        //return m_fCantSeek ? S_OK : E_FAIL;
	return E_FAIL;
    }

    HRESULT hr = S_OK;

    ASSERT(pSample);

    // make sure we're ready to accept data
    WaitForSingleObject(m_hEventSeek, INFINITE);

    if (m_nCurSeg == m_cTimes)
        //return m_fCantSeek ? S_OK : E_FAIL;
	return E_FAIL;

    //  EAT preroll before the switch sees it and maybe gets confused
    if (pSample->IsPreroll() == S_OK)
	return NOERROR;

    // make sure sample size is not zero
    if (!pSample->GetActualDataLength())
	return NOERROR;

    // Get sample start and stop time
    REFERENCE_TIME trStart, trStop;
    pSample->GetTime(&trStart, &trStop);

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC::Receive Start=%d Stop=%d ms"),
		(int)(trStart / 10000), (int)(trStop / 10000)));

    CFrmRateConverterInputPin *pIn = (CFrmRateConverterInputPin *)m_pInput;

    REFERENCE_TIME rtPinNewSeg = pIn->CurrentStartTime();

if (m_dOutputFrmRate) {

    // Calculate received sample's stop time in TL time... we are doing any
    // rate changing, since we don't ask the source to
    REFERENCE_TIME rtStop = (REFERENCE_TIME)(rtPinNewSeg + trStop);
    rtStop = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
				(rtStop - m_pSkew[m_nCurSeg].rtMStart) /
				m_pSkew[m_nCurSeg].dRate);
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Stop is %d"), (int)(rtStop / 10000)));

    // calculate how many times to deliver this frame based on the output FPS
    // and the output time. StopFrame should ROUND UP.
    LONGLONG StopFrame = RoundUpTime2Frame(rtStop , m_dOutputFrmRate);
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Duplicate this frame until %d"), (int)StopFrame));

    REFERENCE_TIME trOutStart, trOutStop;

    BOOL fRepeat = FALSE;

    // Deliver this 0, 1 or more times, until we've delivered all we're supposed
    // to
    while (m_llOutputSampleCnt + m_llStartFrameOffset < StopFrame)
    {
	// calc the output sample's start time
	trOutStart = Frame2Time( m_llOutputSampleCnt + m_llStartFrameOffset,
							m_dOutputFrmRate );

	// !!! If I got this math wrong, I'm toast

	// if this time stamp is too early, or too late, avoid sending it and
	// calling GetBuffer or it will conflict with valid time stamps in
	// a different segment.
	//
	int nAvoid = 0;
	if (trOutStart < m_pSkew[m_nCurSeg].rtTLStart) {
	    nAvoid = 1;
	}

	// if this time stamp is too late, avoid sending it (allow for rounding
	// error !!!)
	if (trOutStart + FUDGE >= m_pSkew[m_nCurSeg].rtTLStop) {
	    nAvoid = 2; // STOP PUSHING
	}

	trOutStart -= m_rtNewSeg;

        // calc the output sample's stop time
	trOutStop = Frame2Time( m_llOutputSampleCnt + m_llStartFrameOffset + 1, m_dOutputFrmRate );
	trOutStop -= m_rtNewSeg;

	// the sample we're going to actually send
	IMediaSample *pUseMe = pSample;
	BOOL fRelease_pUseMe = FALSE;

	// !!! We'll CRASH in every case except the downstream filter owning
	// the allocator, and being the BIG SWITCH !!!
	//
	//ASSERT(pInput->m_pAllocator == pInput->m_pFakeAllocator);

	// This is the first time through the loop.  We need to copy every
	// sample delivered to us.  EVEN IF WE'RE AVOIDING SENDING IT, so
	// that if the first thing we get (and don't avoid) is too late, we
	// can use this
	//
	// !!! If it wasn't too scary a change for millenium, I would avoid this
	// data copy if there is a resizer or COCO in front of me, by trying to
	// get 2 buffers in the allocator, and AddRef'ing instead of copying!
	//	
    	if (!fRepeat && m_fParserHack) {
	    DbgLog((LOG_TRACE,TRACE_LOW,TEXT("FRC:GetBuffer to make a copy (hack)")));
	    hr = m_pUpAllocator->GetBuffer(
				&m_pHackSample[m_nHackCur],
				&trOutStart, &trOutStop, 0);
	    if (FAILED(hr)) {
		break;
	    }
	    LPBYTE pSrc, pDst;
	    hr = pSample->GetPointer(&pSrc);
	    ASSERT(SUCCEEDED(hr));
	    int count = pSample->GetActualDataLength();
	    hr = m_pHackSample[m_nHackCur]->GetPointer(&pDst);
	    ASSERT(SUCCEEDED(hr));
	    CopyMemory(pDst, pSrc, count);
	    m_pHackSample[m_nHackCur]->SetActualDataLength(count);
	}

	if (!nAvoid) {

	    // which buffer do we deliver?
	    // We need to pass a special flag to the switch saying allow POOL
	    // buffers to be given, otherwise we'll hang because we can only
	    // get one buffer at a time sometimes, and we already have one !!!
	    //
	    if (trOutStop <= trStart + rtPinNewSeg + m_pSkew[m_nCurSeg].rtSkew -
			m_rtNewSeg && m_fParserHack &&
			m_pHackSample[1 - m_nHackCur]) {
	        // this sample starts later than the current time.  Good thing
	        // we have the last thing delivered to us still hanging around.
	        // We'll deliver that again. (This fixes slide shows with the
	        // broken ASF parser that doesn't set end times)
		pUseMe = m_pHackSample[1 - m_nHackCur];
	        DbgLog((LOG_TRACE,TRACE_LOW,TEXT("FRC:HACK-use old sample")));
	    } else if (m_fParserHack) {
	        // We had to copy the current sample.  Might as well send the
	        // COPY NOT the ORIGINAL, so we don't send a read only buffer
	        // and can buffer ahead
		pUseMe = m_pHackSample[m_nHackCur];
	    } else {
		// use what we just received
		pUseMe = pSample;
	    }

	    if (fRepeat) {
	        // this is not the first time through the loop.  We need ANOTHER
	        // sample to deliver (it's against the law to deliver the same
	        // sample twice with different time stamps. it needs to be a new
	        // sample. So we need to get a fresh buffer from our allocator
	        fRelease_pUseMe = TRUE;
		IMediaSample *pSrcSample = pUseMe;
	        DbgLog((LOG_TRACE,TRACE_LOW,TEXT("FRC:GetBuffer(upsample)")));
	        hr = m_pUpAllocator->GetBuffer(
				&pUseMe, &trOutStart, &trOutStop, 0);
		if (FAILED(hr)) {
		    break;
	        }
	        LPBYTE pSrc, pDst;
	        hr = pSrcSample->GetPointer(&pSrc);
	        ASSERT(SUCCEEDED(hr));
	        int count = pSrcSample->GetActualDataLength();
	        hr = pUseMe->GetPointer(&pDst);
	        ASSERT(SUCCEEDED(hr));
	        CopyMemory(pDst, pSrc, count);
	        pUseMe->SetActualDataLength(count);
	    }

	    //set sample time
	    pUseMe->SetTime( (REFERENCE_TIME*)&trOutStart,
						(REFERENCE_TIME*)&trOutStop);
	    pUseMe->SetMediaType( NULL );
	    pUseMe->SetSyncPoint(TRUE);
	    pUseMe->SetPreroll( FALSE );
	    pUseMe->SetDiscontinuity(FALSE);

	    // some broken decoders give us the wrong DataLen.  Fix it up
	    // or VidEdit won't be able to edit the output file we create, and
	    // wouldn't that be a disaster.

	    CFrmRateConverterInputPin *pIn = (CFrmRateConverterInputPin *)m_pInput;

	    LPBITMAPINFOHEADER lpbi = HEADER(pIn->m_mt.Format());
    	    if (IsEqualGUID(*pIn->m_mt.FormatType(), FORMAT_VideoInfo)) {
		if (lpbi->biCompression <= BI_BITFIELDS) {
		    pUseMe->SetActualDataLength(DIBSIZE(*lpbi));
		}
	    }

	    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("FRC: Deliver %I64d,%I64d Cur=%d"),
			trOutStart,
			trOutStop,
			(int)m_llOutputSampleCnt));

	    // deliver
	    hr = OutputPin()->Deliver(pUseMe);

	    if (fRelease_pUseMe) {
		pUseMe->Release();
	    }

	    // uh - oh!  We're behind
    	    if (m_fJustLate) {
    		REFERENCE_TIME rt = m_qJustLate.Late;
		m_fJustLate = FALSE;
		if (rt > 0) {
		    LONGLONG llSkip = Time2Frame(rt, m_dOutputFrmRate) - 1;
            	    DbgLog((LOG_TRACE,2,TEXT("FRC: SKIP %d frames"),
							(int)llSkip));
		    m_llOutputSampleCnt += llSkip;
		}
    	    }

	} else {
            DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CFrmRate::ALL done - AVOID DELIVER")));

            // avoid because too early ==> keep going
            // avoid because too late  ==> stop pushing
            if (nAvoid == 2) {
                EndOfStream();
                m_fStopPushing = TRUE;
                hr = E_FAIL;
            } else {
	        hr = S_OK;
            }
	}

        // an ordinary flush makes deliver return a SUCCESS code, in which case
        // this will GRIND DEXTER TO A HALT if we consider that a failure!
	if (FAILED(hr)) {
	    // we still get delivered frames after failing receive, making the
	    // wrong frame show up on the output, so we better ensure that
	    // we won't send anything more after this
	    m_fStopPushing = TRUE;
        }
        if (hr != S_OK) {
	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: Deliver failed")));
	    break;
	}

	// update frm cnt
	m_llOutputSampleCnt++;
	fRepeat = TRUE;
    }	// while

    // ping pong
    if (m_fParserHack) {
	m_nHackCur = 1 - m_nHackCur;
	if (m_pHackSample[m_nHackCur]) {
	    m_pHackSample[m_nHackCur]->Release();
	    m_pHackSample[m_nHackCur] = NULL;
	}
    }

    return hr;

  // there is no output frame rate.. do NOT frame rate convert
} else {

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC:SKEW ONLY")));

    // time stamps incl. their own NewSeg and skew
    trStart += rtPinNewSeg + m_pSkew[m_nCurSeg].rtSkew;
    trStop += rtPinNewSeg + m_pSkew[m_nCurSeg].rtSkew;

    // When delivering two segments in the mode when we don't change any
    // time stamps, we might end up sending the first frame of segment 2 with
    // a lower time stamp than the last frame of segment 1, thus going back
    // in time.  Since time stamps aren't fixed up nice.  Let's say the break
    // between segments is at 2000ms.  The last frame of segment 1 might be
    // as high as 1999, and the first frame of segment 2 could be as much as
    // 1/2 frame time back from 2000, say 1966.  Thus we make sure the first
    // time stamp ever delivered in a segment is never earlier than the time
    // the segment was supposed to start
    // Of course, if the entire frame is too early, just eat it
    //
    if (trStop <= m_pSkew[m_nCurSeg].rtTLStart) {
	return NOERROR;
    } else if (trStart < m_pSkew[m_nCurSeg].rtTLStart) {
	trStart = m_pSkew[m_nCurSeg].rtTLStart;
    }

    // time stamps relative to what the downstream guy thinks the NewSeg is
    trStart -= m_rtNewSeg;
    trStop -= m_rtNewSeg;

    pSample->SetTime(&trStart, &trStop);

    // the source is happily pushing an infinite # of frames at us in pass-thru
    // mode.  It's up to us to notice that we've got a time stamp later than
    // we need, and to stop the pushing

    REFERENCE_TIME rtTLStop = m_pSkew[m_nCurSeg].rtTLStop;
    if (m_rtNewSeg + trStart > rtTLStop + FUDGE) {
	DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: Received enough - Finished a segment")));
	EndOfStream();
	// We can't trust sources to stop pushing, and unfortunately, Dexter
	// will hang if it doesn't. (Seeking ourself to the next segment doesn't
	// let the flush go downstream or it confuses other filters, so we
	// have to make sure the push thread can't ever block).
	// So, from now on, fail any calls to GetBuffer or Receive
	m_fStopPushing = TRUE;
        //return m_fCantSeek ? S_OK : E_FAIL;
	return E_FAIL;
    }

    hr = OutputPin()->Deliver(pSample);
    if (m_fJustLate) {
	// if delivering ended up sending a quality message, reset it
	m_fJustLate = FALSE;
    }
    // an ordinary flush makes deliver return a SUCCESS code, in which case
    // this will GRIND DEXTER TO A HALT if we consider that a failure!
    if (FAILED(hr)) {
	DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: Deliver failed")));
	// we still get delivered frames after failing receive, making the
	// wrong frame show up on the output, so we better ensure that
	// we won't send anything more after this
	m_fStopPushing = TRUE;
    }
    return hr;
}

} // Receive



HRESULT CFrmRateConverter::StartStreaming()
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC::StartStreaming")));

    // hack to copy every sample we get so that if a parser is broken, and
    // the end time is set wrong, we still see that frame until the next frame
    // time, instead of seeing the next frame way early (slide shows will be
    // broken in ASF without this).  Bad: extra memory copy  Good: eliminates
    // using 1 R/O buffer, so Dexter can run ahead and buffer and smooth out
    // glitches due to slow effects.  Also fixes slide shows.  Hack is only
    // for the non-smart recompression case when we have a frame rate.  If we
    // don't, we're dealing with compressed data and shouldn't do this hack
    //
    IBaseFilter *pF = GetStartFilterOfChain(m_pInput);
    if (pF) {
	CLSID clsid;
        HRESULT hr = pF->GetClassID(&clsid);
	if (m_dOutputFrmRate && hr == S_OK && clsid == CLSID_WMAsfReader) {
	    m_fParserHack = TRUE;
    	    DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("FRC:COPY EVERYTHING to fix ASF bug and allow buffering ahead")));
	}
    }

    // if we were stopped when this was set, it will not be reset, since we
    // won't have gotten an EndFlush from the seek trying to start us again
    m_fStopPushing = FALSE;	// OK to deliver to me again

    if (m_cTimes == 0)
	return E_UNEXPECTED;

    // make the event BEFORE creating the thread.. it uses this!
    m_hEventThread = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hEventThread == NULL) {
	return E_OUTOFMEMORY;
    }

    m_hEventSeek = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (m_hEventSeek == NULL) {
	CloseHandle(m_hEventThread);
	m_hEventThread = NULL;
	return E_OUTOFMEMORY;
    }

    // We need a thread to seek on if we are re-using our source
    if (m_cTimes > 1) {
	m_fThreadMustDie = FALSE;
	m_fThreadCanSeek = FALSE;
        if (m_worker.Create(this)) {
            m_worker.Run();
	}
    }

#ifdef DEBUG
    // before we begin, make sure all timeline times are on a frame boundary
    // !!! Play.  Stop.  Change the frame rate.  Play. These numbers will drift.
    //
    if (m_dOutputFrmRate) {
        for (int z=0; z<m_cTimes; z++)
        {
	    // !!! actually align instead of asserting?
    	    LONGLONG llOffset = Time2Frame( m_pSkew[z].rtTLStart,
                                                m_dOutputFrmRate );
    	    REFERENCE_TIME rtTest = Frame2Time( llOffset, m_dOutputFrmRate );
	    ASSERT(rtTest == m_pSkew[z].rtTLStart);
	}
    }
#endif

    // stuff to reset
    m_llOutputSampleCnt		= 0;
    m_fFlushWithoutSeek = FALSE;

    IPin *pPin = m_pInput->GetConnected();
    if (pPin == NULL)
        return CTransInPlaceFilter:: StartStreaming();

    // if we weren't seeked, but we're just playing ordinarily, we never
    // seeked upstream to get the piece of movie we're interested in.  Do it now
    //
    if (m_rtLastSeek < 0) {
	ASSERT(m_nCurSeg == 0);
	m_nCurSeg--;
	NextSegment(FALSE);
    }

    // when we upsample, we need a buffer to upsample into.  Make an allocator
    //
    HRESULT hr = S_OK;
    m_pUpAllocator = new CMemAllocator(NAME("UpSample Allocator"), NULL, &hr);
    if (m_pUpAllocator == NULL) {
        return E_OUTOFMEMORY;
    }
    m_pUpAllocator->AddRef();
    ALLOCATOR_PROPERTIES a, b;
    ((CFrmRateConverterInputPin *)m_pInput)->m_pAllocator->GetProperties(&a);
    // Normally 1 is enough, but if we're copying every sample, we need 2
    // Don't waste memory! There could be hundreds of FRC's in the graph!
    a.cBuffers = m_fParserHack ? 3 : 1;
    m_pUpAllocator->SetProperties(&a, &b);
    hr = m_pUpAllocator->Commit();
    if (FAILED(hr))
        return hr;
	
    return CTransInPlaceFilter::StartStreaming();
}


HRESULT CFrmRateConverter::StopStreaming()
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC::StopStreaming")));

    // release our hack stuff
    if (m_pHackSample[0]) m_pHackSample[0]->Release();
    if (m_pHackSample[1]) m_pHackSample[1]->Release();
    m_pHackSample[0] = NULL;
    m_pHackSample[1] = NULL;
    m_nHackCur = 0;

    if (m_hEventSeek) {
        CloseHandle(m_hEventSeek);
        m_hEventSeek = 0;
    }
    if (m_hEventThread) {
        CloseHandle(m_hEventThread);
        m_hEventThread = 0;
    }

    if (m_pUpAllocator) {
        m_pUpAllocator->Release();
        m_pUpAllocator = NULL;
    }

    return CTransInPlaceFilter:: StopStreaming();
}


HRESULT CFrmRateConverter::Stop()
{
    // If we have a thread, kill it. This thread can take our filter critsec,
    // so we must do this OUTSIDE of that crit sec!
    if (m_hEventThread && m_cTimes > 1) {
	m_fThreadMustDie = TRUE;
	SetEvent(m_hEventThread);
	m_worker.Stop();
	m_worker.Exit();
	m_worker.Close();
    }

    CAutoLock lck1(&m_csFilter);
    if (m_State == State_Stopped) {
        return NOERROR;
    }

    // Succeed the Stop if we are not completely connected

    ASSERT(m_pInput == NULL || m_pOutput != NULL);
    if (m_pInput == NULL || m_pInput->IsConnected() == FALSE ||
        m_pOutput->IsConnected() == FALSE) {
                m_State = State_Stopped;
                m_bEOSDelivered = FALSE;
                return NOERROR;
    }

    ASSERT(m_pInput);
    ASSERT(m_pOutput);

    // decommit the input pin before locking or we can deadlock
    m_pInput->Inactive();
    m_pUpAllocator->Decommit(); // this will unblock receive, which might be
                                // stuck in GetBuffer

    // make all future GetBuffer and Receive calls fail, and make sure one isn't
    // executing now
    m_fStopPushing = TRUE;
    CAutoLock lck2(&m_csReceive);

    m_pOutput->Inactive();

    // allow a class derived from CTransformFilter
    // to know about starting and stopping streaming

    HRESULT hr = StopStreaming();
    if (SUCCEEDED(hr)) {
	// complete the state transition
	m_State = State_Stopped;
	m_bEOSDelivered = FALSE;
    }
    return hr;
}


// Irregardless of what new segment we get, we are correcting time stamps,
// so we send a new segment downstream of simply the piece of movie we're
// going to start sending plus the skew
//
// !!! Do we need to swallow new segments coming when we seek ourself? (and
//     fix the time stamps again?)
HRESULT CFrmRateConverter::NewSegment(
			REFERENCE_TIME tStart,
			REFERENCE_TIME tStop,
			double dRate)
{
    // ignore - we're all done, and m_nCurSeg is an invalid value to use
    if (m_nCurSeg == m_cTimes)
        return S_OK;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateConverter::NewSegment %d-%dms"),
			(int)(tStart / 10000), (int)(tStop / 10000)));

    // release our hack stuff, ready to start again
    if (m_pHackSample[0]) m_pHackSample[0]->Release();
    if (m_pHackSample[1]) m_pHackSample[1]->Release();
    m_pHackSample[0] = NULL;
    m_pHackSample[1] = NULL;
    m_nHackCur = 0;

    // convert to timeline time
    REFERENCE_TIME rtNewStart, rtNewStop;
    if (m_rtLastSeek < 0) {
	// Never been seeked, so this is the beginning of what we're sending
        rtNewStart = m_pSkew[m_nCurSeg].rtTLStart;
        rtNewStop = m_pSkew[m_nCurSeg].rtTLStart +
			(REFERENCE_TIME) ((tStop - tStart) / dRate);
    } else {
        // Skew the #'s, and send 'em on!
	rtNewStart = tStart;
        rtNewStop = tStop;
        if (rtNewStart < m_pSkew[m_nCurSeg].rtMStart)
	    rtNewStart = m_pSkew[m_nCurSeg].rtMStart;
        if (rtNewStart > m_pSkew[m_nCurSeg].rtMStop)
	    rtNewStart = m_pSkew[m_nCurSeg].rtMStop;
        rtNewStart = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
		        (rtNewStart - m_pSkew[m_nCurSeg].rtMStart) /
                        m_pSkew[m_nCurSeg].dRate);
        if (rtNewStop < m_pSkew[m_nCurSeg].rtMStart)
	    rtNewStop = m_pSkew[m_nCurSeg].rtMStart;
        if (rtNewStop > m_pSkew[m_nCurSeg].rtMStop)
	    rtNewStop = m_pSkew[m_nCurSeg].rtMStop;
        rtNewStop = (REFERENCE_TIME)(m_pSkew[m_nCurSeg].rtTLStart +
		 (rtNewStop - m_pSkew[m_nCurSeg].rtMStart) /
		 m_pSkew[m_nCurSeg].dRate);

	m_rtLastSeek = rtNewStart;	// pretend we were seeked here
    }
    m_rtNewSeg = rtNewStart;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("NewSeg:Skewing %dms to %dms"),
			(int)(tStart / 10000), (int)(rtNewStart / 10000)));

    if( m_dOutputFrmRate )
    {
        // What frame were we seeked into?  That's the first frame to send
        m_llStartFrameOffset = Time2Frame(m_rtNewSeg, m_dOutputFrmRate);
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Seek was to frame %d"),
						    (int)m_llStartFrameOffset));
    }
    else
    {
        m_llStartFrameOffset = 0;
    }

    return CTransInPlaceFilter::NewSegment( rtNewStart, rtNewStop, dRate );
}


HRESULT CFrmRateConverter::EndOfStream()
{
    if (m_fStopPushing) {
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("FRC: Ignoring bogus EOS")));
	return S_OK;
    }

    // ignore - we're all done, and m_nCurSeg is an invalid value to use
    if (m_nCurSeg == m_cTimes)
        return S_OK;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("*FRC::EndOfStream")));

    // If we're dealing with ASF, the WM SDK reader is broken in many ways.
    // It reports all stream lengths as the maximum length of any stream, it
    // doesn't actually give you each stream's length.  So we may run out of
    // data earlier than we expect, which would hang the switch.  Luckily,
    // because of ANOTHER WMSDK bug not setting the stop time of samples,
    // we're already holding a sample around we can send now.
    //
    // if we don't have a frame rate, we are dealing with compressed types
    // and can't/shouldn't do this
    while (m_dOutputFrmRate) {

	// !!! This is the same code as Receive

	HRESULT hr;
	int nAvoid = 0;
	REFERENCE_TIME trOutStart, trOutStop;

	// calc the output sample's start time
	trOutStart = Frame2Time( m_llOutputSampleCnt + m_llStartFrameOffset,
							m_dOutputFrmRate );

	// if this time stamp is too early or too late, avoid sending it
	// or it will conflict with valid time stamps in a different segment.
	//
	if (trOutStart < m_pSkew[m_nCurSeg].rtTLStart) {
	    nAvoid = 1;
	}
	// FUDGE = avoid rounding error
	if (trOutStart + FUDGE >= m_pSkew[m_nCurSeg].rtTLStop) {
	    nAvoid = 2; // ALL DONE!
	}

	trOutStart -= m_rtNewSeg;
	trOutStop = Frame2Time(m_llOutputSampleCnt + m_llStartFrameOffset + 1,
							m_dOutputFrmRate);
	trOutStop -= m_rtNewSeg;

	if (!nAvoid) {

	    // the sample we're going to actually send
	    IMediaSample *pUseMe;

	    // !!! We'll CRASH in every case except the downstream filter owning
	    // the allocator, and being the BIG SWITCH !!!

	    DbgLog((LOG_TRACE,TRACE_LOW,TEXT("FRC:Send shortchanged frame")));
	    hr = m_pUpAllocator->GetBuffer(
				&pUseMe, &trOutStart, &trOutStop, 0);
	    if (FAILED(hr)) {
	        break;
	    }
	    LPBYTE pSrc, pDst;
	    int count;
	    // if we have a frame sitting around to use, GREAT!  Else, make
	    // a black frame, I guess
	    hr = pUseMe->GetPointer(&pDst);
	    ASSERT(SUCCEEDED(hr));
    	    if (m_fParserHack && m_pHackSample[1 - m_nHackCur]) {
	        hr = m_pHackSample[1 - m_nHackCur]->GetPointer(&pSrc);
	        ASSERT(SUCCEEDED(hr));
	        count = m_pHackSample[1 - m_nHackCur]->GetActualDataLength();
	        CopyMemory(pDst, pSrc, count);
	    } else {
		// !!! will break when FRC starts accepting compressed types
		count = pUseMe->GetSize();
		ZeroMemory(pDst, count);
	    }
	    pUseMe->SetActualDataLength(count);

	    pUseMe->SetTime( (REFERENCE_TIME*)&trOutStart,
				(REFERENCE_TIME*)&trOutStop);
	    pUseMe->SetMediaType( NULL );
	    pUseMe->SetSyncPoint(TRUE);
	    pUseMe->SetPreroll( FALSE );
	    pUseMe->SetDiscontinuity(FALSE);

	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: Deliver %d,%d Cur=%d"),
			(int)(trOutStart / 10000),
			(int)(trOutStop / 10000),
			(int)m_llOutputSampleCnt));

	    hr = OutputPin()->Deliver(pUseMe);

	    pUseMe->Release();

	    // uh - oh!  We're behind
    	    if (m_fJustLate) {
    		REFERENCE_TIME rt = m_qJustLate.Late;
		m_fJustLate = FALSE;
		if (rt > 0) {
		    LONGLONG llSkip = Time2Frame(rt, m_dOutputFrmRate) - 1;
            	    DbgLog((LOG_TRACE,2,TEXT("FRC: SKIP %d frames"),
							(int)llSkip));
		    m_llOutputSampleCnt += llSkip;
		}
    	    }
	} else {
	    hr = (nAvoid == 2) ? E_FAIL : S_OK;
	}

	if (hr != S_OK) {
	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("FRC: Deliver failed")));
	    break;
	}

	// update frm cnt
	m_llOutputSampleCnt++;
    }

    // release our hack stuff
    if (m_pHackSample[0]) m_pHackSample[0]->Release();
    if (m_pHackSample[1]) m_pHackSample[1]->Release();
    m_pHackSample[0] = NULL;
    m_pHackSample[1] = NULL;
    m_nHackCur = 0;

    NextSegment(TRUE);
    // DON'T signal end of stream to the switch until ALL segments are done
    return S_OK;
}


HRESULT CFrmRateConverter::BeginFlush()
{
    // make sure Receive is not blocked
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC:BeginFlush")));
    HRESULT hr = S_OK;
    SafeSetEvent(m_hEventSeek);

    // don't flush the switch for our special seek that re-uses a source!
    if (!m_fSpecialSeek) {
        hr = CTransInPlaceFilter::BeginFlush();
    }

    CAutoLock foo(&m_csReceive);

    // flushing must reset this so that a real seek will kill a pending
    // segment seek, or else the segment seek will hang (won't flush the switch)
    // Must happen AFTER we know receive is done, and won't set this again
    m_fThreadCanSeek = FALSE;

    // if we get flushed without a seek having been made, that's a surprise.
    // It hopefully means the other chain of our shared source caused the seek
    if (m_fSeeking) {
	m_fFlushWithoutSeek = FALSE;
    } else {
	// wait for EndFlush to set m_fFlushWithoutSeek
    }

    return hr;
}


HRESULT CFrmRateConverter::EndFlush()
{

    // LIGOS sends bogus ones of these
    if (!m_pInput->IsFlushing())
        return S_OK;

    // wait until we're ready to accept data again.  block receive
    if (m_fSeeking) {
	m_rtLastSeek = m_rtNewLastSeek;	// time to update this before NewSeg
	m_nCurSeg = m_nSeekCurSeg; // NewSeg about to arrive needs this set
        SafeResetEvent(m_hEventSeek);
    } else {
	// This needs to be set before the NewSeg that's about to arrive after
	// the flush.  When sharing a source, we never have multiple segments
	m_nCurSeg = 0;	
	if (m_fFlushWithoutSeek) {
	    // If this is set, we've already seen a seek.  Now that the flush
	    // has arrived, we're done
    	    DbgLog((LOG_TRACE,2,TEXT("OK to proceed")));
	    m_fFlushWithoutSeek = FALSE;
	} else {
	    // We haven't seen a seek yet.  This is a surprise flush
    	    DbgLog((LOG_TRACE,2,TEXT("state=2. Wait for Seek")));
    	    SafeResetEvent(m_hEventSeek);
	    m_fFlushWithoutSeek = TRUE;
	}
    }

    m_fStopPushing = FALSE;	// OK to deliver to me again

    // If we got flushed without seeking, it probably means our shared source
    // got seeked by the other stream.  We'll get a seek later, and only then
    // can we resume delivering, or the switch won't be ready to receive the
    // new data yet.

    // don't flush the switch for our special seek that re-uses a source!
    if (!m_fSpecialSeek) {
        CTransInPlaceFilter::EndFlush();
    }
    return S_OK;
}


// Check the input type is OK - return an error otherwise

HRESULT CFrmRateConverter::CheckInputType(const CMediaType *pmt)
{
    if (!IsEqualGUID(*pmt->Type(), MEDIATYPE_Video))
    {
        return VFW_E_INVALIDMEDIATYPE;
    }


    // if user hasn't set a particular format, then accept it
    //
    if( !m_bMediaTypeSetByUser )
    {
        return NOERROR;
    }

    // !!! I can't seem to compare the whole format and ever succeed

    if( pmt->cbFormat < m_mtAccept.cbFormat )
    {
        return E_INVALIDARG;
    }


    if (!IsEqualGUID(*pmt->Subtype(), *m_mtAccept.Subtype()))
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    if (!IsEqualGUID(*pmt->FormatType(), *m_mtAccept.FormatType()))
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    // !!! I can't interpret anything but this right now
    if (!IsEqualGUID(*pmt->FormatType(), FORMAT_VideoInfo))
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pmt->Format();
    LPBITMAPINFOHEADER lpbi = HEADER(pvi);
    LPBITMAPINFOHEADER lpbiAccept=HEADER((VIDEOINFOHEADER*)m_mtAccept.Format());

    if( lpbi->biBitCount != lpbiAccept->biBitCount )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    if( lpbi->biHeight != lpbiAccept->biHeight ) {
        return VFW_E_INVALIDMEDIATYPE;
    }

    if( lpbi->biCompression != lpbiAccept->biCompression )
    {
	// the colour converter advertises 555 using BI_BITFIELDS!
	if (lpbi->biCompression == BI_BITFIELDS && lpbiAccept->biCompression ==
			BI_RGB && lpbi->biBitCount == 16) {
	    LPDWORD lp = (LPDWORD)(lpbi+1);
	    if (*lp==0x7c00 && *(lp+1)==0x03e0 && *(lp+2)==0x001f)
		return NOERROR;
	}
        return VFW_E_INVALIDMEDIATYPE;
    }

    return NOERROR;
}


CBasePin *CFrmRateConverter::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if not already done

    if (m_pInput == NULL) {

	m_pInput = new CFrmRateConverterInputPin(
					NAME("FrmRateConverter input pin")
					, this        // Owner filter
					, &hr         // Result code
					, L"Input"    // Pin name
					);

	// Constructor can't fail
	ASSERT(SUCCEEDED(hr));
    }

    // Create an output pin if not already done

    if (m_pInput!=NULL && m_pOutput == NULL) {

	m_pOutput = new CFrmRateConverterOutputPin( NAME("FrmRateConverter output pin")
					      , this       // Owner filter
					      , &hr        // Result code
					      , L"Output"  // Pin name
					      );

	// a failed return code should delete the object

	ASSERT(SUCCEEDED(hr));
	if (m_pOutput == NULL) {
	    delete m_pInput;
	    m_pInput = NULL;
	}
    }

    // Return the appropriate pin

    ASSERT (n>=0 && n<=1);
    if (n == 0) {
	return m_pInput;
    } else if (n==1) {
	return m_pOutput;
    } else {
	return NULL;
    }

} // GetPin



// IPersistStream

// tell our clsid
//
STDMETHODIMP CFrmRateConverter::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_FrmRateConverter;
    return S_OK;
}

typedef struct _FRCSave {
    int version;
    double dFrmRate;
    int cTimes;
} FRCSave;

// persist ourself
//
HRESULT CFrmRateConverter::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateConverter::WriteToStream")));

    CheckPointer(pStream, E_POINTER);

    int savesize = sizeof(FRCSave) + m_cTimes * sizeof(FRCSKEW);
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Persisted data is %d bytes"), savesize));

    FRCSave *px = (FRCSave *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    px->version = 1;
    px->dFrmRate = m_dOutputFrmRate;
    px->cTimes = m_cTimes;

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(FRCSave);
    if (m_cTimes) {
        CopyMemory(pb, m_pSkew, sizeof(FRCSKEW) * m_cTimes);
        pb += sizeof(FRCSKEW) * m_cTimes;
    }

    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** FRC: WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself
//
HRESULT CFrmRateConverter::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("FRC::ReadFromStream")));

    CheckPointer(pStream, E_POINTER);

    int savesize=sizeof(FRCSave);

    // we don't yet know how many saved connections there are
    // all we know we have for sure is the beginning of the struct
    FRCSave *px = (FRCSave *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    put_OutputFrmRate(px->dFrmRate);

    // how much saved data was there, really?  Get the rest
    savesize += px->cTimes * sizeof(FRCSKEW);
    px = (FRCSave *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
        return E_OUTOFMEMORY;
    }

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("Persisted data is %d bytes"), savesize));

    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(FRCSave) ;
    hr = pStream->Read(pb, (savesize-sizeof(FRCSave)), 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    ClearStartStopSkew();
    for (int z=0; z<px->cTimes; z++) {
        FRCSKEW *pSkew = (FRCSKEW *)pb;
	REFERENCE_TIME rtStart = pSkew->rtMStart;
	REFERENCE_TIME rtStop = pSkew->rtMStop;
	REFERENCE_TIME rtSkew = pSkew->rtSkew;
	double dRate = pSkew->dRate;
        AddStartStopSkew(rtStart, rtStop, rtSkew, dRate);
	pb += sizeof(FRCSKEW);
    }

    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}


// how big is our save data?
//
int CFrmRateConverter::SizeMax()
{
    return sizeof(FRCSave) + m_cTimes * 3 * sizeof(REFERENCE_TIME) +
			    m_cTimes * sizeof(double);
}



//
// IDexterSequencer implementation
//


//
// get_OutputFrmRate(double *PFS)
//
// Return the current FrmRateSpeed
STDMETHODIMP CFrmRateConverter::get_OutputFrmRate(double *dpFrmRate)
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(dpFrmRate,E_POINTER);
    *dpFrmRate = m_dOutputFrmRate;
    return NOERROR;
}


//
// put_OutputFrmRate
//
// A frame rate of 0 means do NOT do any frame rate conversion, just skewing
//
STDMETHODIMP CFrmRateConverter::put_OutputFrmRate(double dFrmRate)
{
    CAutoLock cAutolock(&m_csFilter);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRate::put_OutputFrmRate to %d/10 fps"),
						(int)(dFrmRate * 10)));
    m_dOutputFrmRate = dFrmRate;
    SetDirty(TRUE);
    return NOERROR;
}


STDMETHODIMP CFrmRateConverter::ClearStartStopSkew()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRate::ClearStartStopSkew")));
    CAutoLock cAutolock(&m_csFilter);

    //can not change duration if our filter is not currently stopped
    if(!IsStopped() )
      return VFW_E_WRONG_STATE;

    if (m_pSkew)
	QzTaskMemFree(m_pSkew);
    m_pSkew= NULL;

    m_cTimes = 0;
    m_cMaxTimes = 0;
    SetDirty(TRUE);

    return NOERROR;
}

// add this skew sorted by timeline time into our list
//
STDMETHODIMP CFrmRateConverter::AddStartStopSkew(REFERENCE_TIME Start, REFERENCE_TIME Stop, REFERENCE_TIME Skew, double dRate)
{
    CAutoLock cAutolock(&m_csFilter);

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRate::ADD Start %d  Stop %d  Skew %d ms  Rate %d/100"),
				(int)(Start / 10000), (int)(Stop / 10000),
				(int)(Skew / 10000), (int)(dRate * 100)));

    //can not change times if our filter is not currently stopped
    if(!IsStopped() )
	return VFW_E_WRONG_STATE;

    if (m_cTimes == m_cMaxTimes) {
	m_cMaxTimes += 10;
	if (m_pSkew)
	    m_pSkew = (FRCSKEW *)QzTaskMemRealloc(m_pSkew,
					m_cMaxTimes * sizeof(FRCSKEW));
	else
	    m_pSkew = (FRCSKEW *)QzTaskMemAlloc(
					m_cMaxTimes * sizeof(FRCSKEW));
	if (m_pSkew == NULL) {
	    m_cMaxTimes = 0;
	    return E_OUTOFMEMORY;
	}
    }

    // if the rate is 0, then just set the last skew's stop time to
    // the one we're passing in
    //
    if( dRate == 0.0 )
    {
        // go look for the time we want to extend
        //
#ifdef DEBUG
        bool fHosed = true;
#endif
        for( int z = 0 ; z < m_cTimes ; z++ ) {
            REFERENCE_TIME rtLastTLStop = m_pSkew[z].rtTLStop;

            if( AreTimesAndRateReallyClose( rtLastTLStop, Start + Skew,
                m_pSkew[z].rtMStop, Start, 0.0, 0.0, m_dOutputFrmRate ) )
            {
                m_pSkew[z].rtMStop += Stop - Start;
                m_pSkew[z].rtTLStop = m_pSkew[z].rtMStart + m_pSkew[z].rtSkew +
                    (REFERENCE_TIME)((m_pSkew[z].rtMStop - m_pSkew[z].rtMStart)
                                / m_pSkew[z].dRate);
                // the above math will have a rounding error, and rtTLStop won't
                // be frame aligned, so we better fix that
                LONGLONG ll = RoundTime2Frame(m_pSkew[z].rtTLStop, m_dOutputFrmRate);
                m_pSkew[z].rtTLStop = Frame2Time(ll, m_dOutputFrmRate);

#ifdef DEBUG
                fHosed = false;
#endif
                break;
            }
        }
#ifdef DEBUG
        if (fHosed) ASSERT(FALSE);  // we're dead
#endif
    }
    else
    {
        // merge it sorted by timeline time into the list
        //
        for (int z=0; z<m_cTimes; z++)
        {
	    if (Start + Skew < m_pSkew[z].rtTLStart)
            {
    	        for (int y = m_cTimes - 1; y >= z; y--)
                {
    		    m_pSkew[y + 1] = m_pSkew[y];
	        }
	        break;
	    }
        }

        m_pSkew[z].rtMStart = Start;
        m_pSkew[z].rtMStop = Stop;
        m_pSkew[z].rtSkew = Skew;
        m_pSkew[z].dRate = dRate;
        m_pSkew[z].rtTLStart = Start + Skew;
        m_pSkew[z].rtTLStop = Start + Skew +
                    (REFERENCE_TIME)((Stop - Start) / dRate);

        m_cTimes++;
    }

    SetDirty(TRUE);
    return S_OK;
}


STDMETHODIMP CFrmRateConverter::GetStartStopSkewCount(int *pCount)
{
    CheckPointer(pCount, E_POINTER);
    *pCount = m_cTimes;
    return NOERROR;
}


STDMETHODIMP CFrmRateConverter::GetStartStopSkew(REFERENCE_TIME *pStart, REFERENCE_TIME *pStop, REFERENCE_TIME *pSkew, double *pdRate)
{
    CAutoLock cAutolock(&m_csFilter);

    CheckPointer(pStart,E_POINTER);
    CheckPointer(pStop,E_POINTER);
    CheckPointer(pSkew,E_POINTER);
    CheckPointer(pdRate,E_POINTER);

    for (int i = 0; i < m_cTimes; i++) {
        pStart[i] = m_pSkew[i].rtMStart;
        pStop[i] = m_pSkew[i].rtMStop;
        pSkew[i] = m_pSkew[i].rtSkew;
        pdRate[i] = m_pSkew[i].dRate;
    }

    return NOERROR;
}


STDMETHODIMP CFrmRateConverter::get_MediaType( AM_MEDIA_TYPE *pmt )
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(pmt, E_POINTER);
    if (!m_bMediaTypeSetByUser)
	return E_UNEXPECTED;
    return CopyMediaType(pmt, &m_mtAccept);
}

STDMETHODIMP CFrmRateConverter::put_MediaType(const AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(pmt, E_POINTER);
    if (m_State != State_Stopped)
        return VFW_E_NOT_STOPPED;

    if (m_pInput && m_pInput->IsConnected())
        return VFW_E_ALREADY_CONNECTED;

    if (m_pOutput && m_pOutput->IsConnected())
        return VFW_E_ALREADY_CONNECTED;

    SaferFreeMediaType(m_mtAccept);
    HRESULT hr = CopyMediaType(&m_mtAccept, pmt);
    SetDirty(TRUE);
    m_bMediaTypeSetByUser = true;
    return hr;
}


// --- ISpecifyPropertyPages ---

STDMETHODIMP CFrmRateConverter::GetPages (CAUUID *pPages)

  { // GetPages //

    pPages->cElems = 1;
    pPages->pElems = (GUID *)CoTaskMemAlloc(sizeof(GUID));

    if (pPages->pElems == NULL)
	return E_OUTOFMEMORY;

    *(pPages->pElems) = CLSID_FRCProp;

    return NOERROR;

  } // GetPages

//////////////////////////////////////////////////////////////////////////
//
// CFrmRateConverterOutputPin
//
//////////////////////////////////////////////////////////////////////////
CFrmRateConverterOutputPin::CFrmRateConverterOutputPin(TCHAR       *pObjectName,
		   CFrmRateConverter *pBaseFilter,
		   HRESULT     *phr,
		   LPCWSTR      pPinName)
    : CTransInPlaceOutputPin(pObjectName, pBaseFilter, phr, pPinName),
      m_pFrmRateConverter(pBaseFilter),
      m_pSkewPassThru(NULL)
{
    ASSERT(pBaseFilter);
    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CFrmRateConverterOutputPin::CFrmRateConverterOutputPin()")));

}

CFrmRateConverterOutputPin::~CFrmRateConverterOutputPin()
{
    if( m_pSkewPassThru)
	delete m_pSkewPassThru;
    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CFrmRateConverterOutputPin::~CFrmRateConverterOutputPin()")));
}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP CFrmRateConverterOutputPin::NonDelegatingQueryInterface (REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;

    if (riid == IID_IMediaSeeking ) {
	//
	// Create a seeking implementation
	//
	ASSERT(m_pFrmRateConverter->m_pInput != NULL);

	if (m_pSkewPassThru == NULL)
	{
	    HRESULT hr = S_OK;
	    m_pSkewPassThru = new  CSkewPassThru (NAME("Skew Pass Through"),
					GetOwner(),
					&hr,
				     (IPin *)m_pFrmRateConverter->m_pInput,
				     m_pFrmRateConverter);

	    if (FAILED(hr)) {
		return hr;
	    }
	}
	 return m_pSkewPassThru->NonDelegatingQueryInterface(riid, ppv);
    }
    else {
	return CTransInPlaceOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}



/* Receive notifications from our own input pin as to which allocator we
   are actually going to use.  Only call if we are connected downstream.
   Propagate the choice to any connected downstream input pin.
*/
HRESULT
CFrmRateConverterOutputPin::ReceiveAllocator(IMemAllocator * pAllocator, BOOL bReadOnly)
{
    ASSERT( IsConnected() );

    // Overridden to allow read only pass through case, since we don't actually
    // touch any data, just the time stamps.

    // Propagate the allocator.
    // It's possible that the old and the new are the same thing.
    // AddRef before release ensures that we don't unload it.
    pAllocator->AddRef();
    if (m_pAllocator != NULL)
         m_pAllocator->Release();

    m_pAllocator = pAllocator;

    CFrmRateConverter *pTIPFilter = (CFrmRateConverter *)m_pTIPFilter;

    // Propagate the allocator downstream
    return m_pInputPin->NotifyAllocator(pAllocator, bReadOnly);

} // receiveAllocator



// OVERRIDDEN because A->TIP->B won't work if B has special allocator
// requirements.  A->TIP uses a normal A allocator.  Then when connected to B,
// it's given to B who rejects it.  I need to see what B wants and fix A's
// allocator to provide it.
//
HRESULT
CFrmRateConverterOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    // Note that *ppAlloc is almost certainly identical to m_Allocator

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateOut::DecideAllocator")));

    HRESULT hr = NOERROR;

    // If our input pin has an allocator and it's read/write then we use it.
    // Failing that we try to get one from downstream.
    *ppAlloc = NULL;

    bool fNeedToConfigureAllocator = false;

    CFrmRateConverter *pTIP = (CFrmRateConverter *)m_pTIPFilter;
    if (pTIP->InputPin()) {
        if (!pTIP->InputPin()->ReadOnly()) {
            *ppAlloc = pTIP->InputPin()->PeekAllocator();
        }
    }

    if (*ppAlloc!=NULL) {
        // don't need to configure allocator -- upstream filter has
        // already configured it
        (*ppAlloc)->AddRef();
    } else {
        hr = VFW_E_NO_ALLOCATOR;
        if ( IsConnected() ) {
            // Get an addreffed allocator from the downstream input pin.
            hr = m_pInputPin->GetAllocator( ppAlloc );
            fNeedToConfigureAllocator = true;
        }
    }


    if (*ppAlloc==NULL) {
        // Can't get one from upstream or downstream, so must use our own.

        hr = InitAllocator(ppAlloc);
        fNeedToConfigureAllocator = true;
    }

    if(FAILED(hr))
        return hr;

    ASSERT( *ppAlloc != NULL );

    if (fNeedToConfigureAllocator) {

        ALLOCATOR_PROPERTIES prop;
        ZeroMemory(&prop, sizeof(prop));

        // Try to get requirements from downstream
        pPin->GetAllocatorRequirements(&prop);

        // if he doesn't care about alignment, then set it to 1
        if (prop.cbAlign == 0) {
            prop.cbAlign = 1;
        }

        hr = DecideBufferSize(*ppAlloc, &prop);

        if (FAILED(hr)) {
            (*ppAlloc)->Release();
            *ppAlloc = NULL;
        }
    } else {
	// !!! OVERRIDE FOR THIS:

        ALLOCATOR_PROPERTIES b, a, c;
        pPin->GetAllocatorRequirements(&b);
        if (b.cbAlign == 0) {
            b.cbAlign = 1;
        }
	(*ppAlloc)->GetProperties(&a);
	if (b.cbAlign > a.cbAlign || b.cbPrefix > a.cbPrefix) {
    	    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("B needs a bigger allocator")));
	    a.cbPrefix = b.cbPrefix;
	    a.cbAlign = b.cbAlign;
	    hr = (*ppAlloc)->SetProperties(&a, &c);
	    if (FAILED(hr) || c.cbPrefix < a.cbPrefix || c.cbAlign < a.cbAlign){
		(*ppAlloc)->Release();
		*ppAlloc = NULL;
    		DbgLog((LOG_ERROR,1,TEXT("*ERROR: Can't fix A's allocator")));
		return hr;
	    }
    	    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("A's allocator successfully grown")));
	}
    }

    // Tell the downstream input pin
    // !!! OVERRIDE to fix this bug
    return pPin->NotifyAllocator(*ppAlloc, pTIP->InputPin()->ReadOnly());

} // DecideAllocator



//
// Notify
//
STDMETHODIMP CFrmRateConverterOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    // called in Receive.  Taking the filter lock will hang
    // CAutoLock lock_it(m_pLock);

    DbgLog((LOG_TRACE,1,TEXT("!!! FRC: Notify")));

    m_pFrmRateConverter->m_fJustLate = TRUE;
    m_pFrmRateConverter->m_qJustLate = q;

    // make the render keep trying to make up time, too
    return E_NOTIMPL;
}


CFrmRateConverterInputPin::CFrmRateConverterInputPin(TCHAR *pObjectName,
		   CFrmRateConverter *pBaseFilter,
		   HRESULT     *phr,
		   LPCWSTR      pPinName)
    : CTransInPlaceInputPin(pObjectName, pBaseFilter, phr, pPinName)
      // , m_pFakeAllocator(NULL)
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CFrmRateIn::CFrmRateIn")));
}

CFrmRateConverterInputPin::~CFrmRateConverterInputPin()
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CFrmRateIn::~CFrmRateIn")));
}

// I seem to need to override this but not change a thing or things don't work!
//
STDMETHODIMP CFrmRateConverterInputPin::NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly)
{
    HRESULT hr;
    CheckPointer(pAllocator,E_POINTER);
    ValidateReadPtr(pAllocator,sizeof(IMemAllocator));

    DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("CFrmRateIn:NotifyAllocator")));

    m_bReadOnly = bReadOnly;

    CAutoLock cObjectLock(m_pLock);

    // It's possible that the old and the new are the same thing.
    // AddRef before release ensures that we don't unload it.
    pAllocator->AddRef();

    if( m_pAllocator != NULL )
        m_pAllocator->Release();

    m_pAllocator = pAllocator;    // We have an allocator for the input pin

//#ifdef DEBUG
    // Propagate the decision downstream - do this always, even if it's
    // a read-only allocator.  The Receive function will take what it can.
    CFrmRateConverter *pTIPFilter = (CFrmRateConverter *)m_pTIPFilter;
    if (pTIPFilter->OutputPin()->IsConnected()) {
        hr = pTIPFilter->OutputPin()->ReceiveAllocator(pAllocator, bReadOnly);
        if (FAILED(hr)) {
            // The output connection would be messed up by this input connection
            // so refuse it!
            return hr;
        }
    }

    return NOERROR;

} // NotifyAllocator

CFRCWorker::CFRCWorker()
{
}

BOOL CFRCWorker::Create(CFrmRateConverter *pFRC)
{
    m_pFRC = pFRC;

    return CAMThread::Create();
}

HRESULT CFRCWorker::Run()
{
    return CallWorker(CMD_RUN);
}

HRESULT CFRCWorker::Stop()
{
    return CallWorker(CMD_STOP);
}

HRESULT CFRCWorker::Exit()
{
    return CallWorker(CMD_EXIT);
}



// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD CFRCWorker::ThreadProc()
{
    BOOL bExit = FALSE;

    QzInitialize(NULL);

    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }

    QzUninitialize();

    return NOERROR;
}

HRESULT CFRCWorker::DoRunLoop()
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("FRC:entering worker thread")));

    while (1) {
	Command com;
	if (CheckRequest(&com)) {
	    if (com == CMD_STOP)
		break;
	}

	// no more blocking if we're waiting to get stopped
	if (!m_pFRC->m_fThreadMustDie) {
            WaitForSingleObject(m_pFRC->m_hEventThread, INFINITE);
	}

	// might have gotten set while we were blocked
	if (!m_pFRC->m_fThreadMustDie && m_pFRC->m_fThreadCanSeek) {
	    // !!! This might fail (SetRate fails) we'll just hang!
	    m_pFRC->SeekNextSegment();
	}
    }

    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("FRC:getting ready to leave worker thread")));

    return hr;
}

// helper functions until we can fix m_hEventSeek being set 

BOOL SafeSetEvent(HANDLE h)
{
    if(h != 0) {
        return SetEvent(h);
    }
    DbgLog((LOG_ERROR, 1, TEXT("setting null handle")));
    return TRUE;
}
        
BOOL SafeResetEvent(HANDLE h)
{
    if(h != 0) {
        return ResetEvent(h);
    }
    DbgLog((LOG_ERROR, 1, TEXT("resetting null handle")));
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\gcache\grfcache.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: grfcache.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// GrfCache.h : Declaration of the CGrfCache

#ifndef __GRFCACHE_H_
#define __GRFCACHE_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CGrfCache
class ATL_NO_VTABLE CGrfCache : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CGrfCache, &CLSID_GrfCache>,
    public IDispatchImpl<IGrfCache, &IID_IGrfCache, &LIBID_DexterLib>
{
    CComQIPtr< IGraphBuilder, &IID_IGraphBuilder > m_pGraph;

public:

    CGrfCache();
    ~CGrfCache();

DECLARE_REGISTRY_RESOURCEID(IDR_GRFCACHE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CGrfCache)
    COM_INTERFACE_ENTRY(IGrfCache)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IGrfCache
public:
    STDMETHOD(DoConnectionsNow)();
    STDMETHOD(SetGraph)(const IGraphBuilder * pGraph);
    STDMETHOD(ConnectPins)(IGrfCache * ChainNext, LONGLONG PinID1, const IPin * pPin1, LONGLONG PinID2, const IPin * pPin2);
    STDMETHOD(AddFilter)(IGrfCache * ChainNext, LONGLONG ID, const IBaseFilter * pFilter, LPCWSTR pName);
};

#endif //__GRFCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\gcache\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gcacheman.rc
//
#define IDR_GRFCACHE                    1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           1002
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\gcache\grfcache.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: grfcache.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// GrfCache.cpp : Implementation of CGrfCache
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "GrfCache.h"

/////////////////////////////////////////////////////////////////////////////
// CGrfCache

CGrfCache::CGrfCache( )
{
}

CGrfCache::~CGrfCache( )
{
}

STDMETHODIMP CGrfCache::AddFilter( IGrfCache * pChainNext, LONGLONG, const IBaseFilter * pFilter, LPCWSTR pName )
{
    // THIS cache manager doesn't chain anyone. We're the last in the chain.
    //
    if( pChainNext )
    {
        return E_INVALIDARG;
    }

    if( !m_pGraph )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = 0;
    hr = m_pGraph->AddFilter( (IBaseFilter*) pFilter, pName );

    return hr;
}

STDMETHODIMP CGrfCache::ConnectPins( IGrfCache * pChainNext, LONGLONG, const IPin *pPin1, LONGLONG, const IPin *pPin2)
{
    // THIS cache manager doesn't chain anyone. We're the last in the chain.
    //
    if( pChainNext )
    {
        return E_INVALIDARG;
    }

    if( !m_pGraph )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = 0;

    if( !pPin2 )
    {
        hr = m_pGraph->Render( (IPin*) pPin1 );
    }
    else
    {
        hr = m_pGraph->Connect( (IPin*) pPin1, (IPin*) pPin2 );
    }

    return hr;
}

STDMETHODIMP CGrfCache::SetGraph(const IGraphBuilder  *pGraph)
{
    m_pGraph.Release( );
    m_pGraph = (IGraphBuilder*) pGraph;

    return S_OK;
}

STDMETHODIMP CGrfCache::DoConnectionsNow()
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\idl\dexhelp.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dexhelp.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

extern void DexterRemoveChain( IPin * pPin1, IPin * pPin2 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\mediadet\dll.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dll.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// mediadet.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include <initguid.h>
#include "dll.h"
#include "dll_i.c"

/*
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\gcache\stdafx.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stdafx.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__AE9472B5_B0C3_11D2_8D24_00A0C9441E20__INCLUDED_)
#define AFX_STDAFX_H__AE9472B5_B0C3_11D2_8D24_00A0C9441E20__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AE9472B5_B0C3_11D2_8D24_00A0C9441E20__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\mediadet\stdafx.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stdafx.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A1EEFB50_0D2D_11D3_920A_00C0DF10D434__INCLUDED_)
#define AFX_STDAFX_H__A1EEFB50_0D2D_11D3_920A_00C0DF10D434__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <atlbase.h>
#include <vfw.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A1EEFB50_0D2D_11D3_920A_00C0DF10D434__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\mediadet\mediadet.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: mediadet.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#ifndef __MEDIADET_H__
#define __MEDIADET_H__

extern const AMOVIESETUP_FILTER sudMediaDetFilter;
//extern const AMOVIESETUP_FILTER sudBitBucketFilter;

typedef struct _MDCacheFile
{
    double StreamLength;
    double StreamRate;
    GUID StreamType;
} MDCacheFile;

typedef struct _MDCache
{
    long Version;
    FILETIME FileTime;
    long Count;
    MDCacheFile CacheFile[1];
} MDCache;

class CMediaDetPin
    : public CBaseInputPin
{
    friend class CMediaDetFilter;
    CMediaDetFilter * m_pFilter;
    CCritSec m_Lock;
    LONG m_cPinRef;          // Pin's reference count

protected:

    GUID m_mtAccepted;

    CMediaDetPin( CMediaDetFilter * pFilter, HRESULT *phr, LPCWSTR Name );

    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    // CBaseInputPin necessary overrides
    HRESULT CheckMediaType( const CMediaType *pmtIn );

    // CBasePin overrides
    HRESULT GetMediaType( int Pos, CMediaType * pMediaType );
    HRESULT CompleteConnect( IPin * pReceivePin );
};

class CMediaDetFilter
    : public CBaseFilter
    , public IMediaDetFilter
{
    friend class CMediaDetPin;
    typedef CGenericList <CMediaDetPin> CInputList;
    CInputList m_PinList;
    CCritSec m_Lock;

    CMediaDetFilter( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr );
    ~CMediaDetFilter( );

protected:

    long m_nPins;

public:

    // needed to define IUnknown methods
    DECLARE_IUNKNOWN;
    
    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance( LPUNKNOWN pUnk, HRESULT *phr );

    // CBaseFilter overrides
    STDMETHODIMP NonDelegatingQueryInterface( REFIID, void ** );

    // IMediaDetFilter
    STDMETHODIMP put_AcceptedMediaType( long PinNo, GUID * pMajorType );
    STDMETHODIMP get_Length( long PinNo, double * pVal );
    STDMETHODIMP put_AcceptedMediaTypeB( long PinNo, BSTR MajorType );
    STDMETHODIMP get_PinCount( long * pVal );

    // CBaseFilter overrides
    CBasePin * GetPin( int n );
    CMediaDetPin * GetPin2( int n );
    int GetPinCount( );

    // random pin stuff
    void InitInputPinsList( );
    CMediaDetPin * CreateNextInputPin( );
    void DeleteInputPin( CMediaDetPin * pPin );
    int GetNumFreePins();
};

class CAutoReleaseMutex
{
    HANDLE m_hMutex;

public:

    CAutoReleaseMutex( HANDLE hMutex )
    {
        m_hMutex = hMutex;
    }
    ~CAutoReleaseMutex( )
    {
        if( m_hMutex )
        {
            ReleaseMutex( m_hMutex );
        }
    }
};

class CMediaDet
    : public CUnknown
    , public IMediaDet
    , public IServiceProvider
    , public IObjectWithSite
{
    WCHAR * m_szFilename;
    CComPtr< IBaseFilter > m_pFilter;
    CComPtr< IGraphBuilder > m_pGraph;
    CComPtr< IBaseFilter > m_pMediaDet;
    CComPtr< IBaseFilter > m_pBitBucketFilter;
    CComPtr< IBaseFilter > m_pBitRenderer;

    // storage stuff
    //
    MDCache * m_pCache;
    HRESULT _ReadCacheFile( );
    void _WriteCacheFile( );
    void _FreeCacheMemory( );
    void _GetStorageFilename( WCHAR * In, WCHAR * Out );


    long m_nStream;
    long m_cStreams;
    bool m_bBitBucket;
    bool m_bAllowCached;

    // stuff for the frame grabbing
    //
    HDRAWDIB m_hDD;
    HDC m_hDC;
    HBITMAP m_hDib;
    HGDIOBJ m_hOld;
    char * m_pDibBits;
    long m_nDibWidth;
    long m_nDibHeight;
    double m_dLastSeekTime;

    HRESULT _SeekGraphToTime( double SeekTime );
    void _ClearOutEverything( ); // clear out filters, streams, and filename
    void _ClearGraphAndStreams( ); // clear out filters, plus streamcount info
    void _ClearGraph( ); // clear out any filters we've loaded
    HRESULT _Load( );
    HRESULT _InjectBitBuffer( );
    IPin * _GetNthStreamPin( long Stream );
    HRESULT _GetCacheDirectoryName( WCHAR * pPath );
    bool _IsLoaded( );

    CMediaDet( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr );
    ~CMediaDet( );

public:

    // needed to define IUnknown methods
    DECLARE_IUNKNOWN;

    // CUnknown overrides
    STDMETHODIMP NonDelegatingQueryInterface( REFIID, void ** );

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance( LPUNKNOWN pUnk, HRESULT *phr );

    STDMETHODIMP get_Filter( IUnknown* *pVal);
    STDMETHODIMP put_Filter( IUnknown* newVal);
    STDMETHODIMP get_Filename( BSTR *pVal);
    STDMETHODIMP put_Filename( BSTR newVal);
    STDMETHODIMP get_OutputStreams( long *pVal);
    STDMETHODIMP get_CurrentStream( long *pVal);
    STDMETHODIMP put_CurrentStream( long newVal);
    STDMETHODIMP get_StreamType( GUID *pVal);
    STDMETHODIMP get_StreamTypeB( BSTR *pVal);
    STDMETHODIMP get_StreamLength( double *pVal);
    STDMETHODIMP GetBitmapBits(double StreamTime, long * pBufferSize, char * pBuffer, long Width, long Height);
    STDMETHODIMP WriteBitmapBits(double StreamTime, long Width, long Height, BSTR Filename );
    STDMETHODIMP get_StreamMediaType(AM_MEDIA_TYPE *pVal);
    STDMETHODIMP GetSampleGrabber( ISampleGrabber ** ppVal );
    STDMETHODIMP get_FrameRate(double *pVal);
    STDMETHODIMP EnterBitmapGrabMode( double SeekTime );

    static void CALLBACK StaticLoader( BOOL bLoading, const CLSID * rclsid );
    static HANDLE m_ghMutex;
    static WCHAR m_gszCacheDirectoryName[_MAX_PATH];

    // --- IObjectWithSite methods
    // This interface is here so we can keep track of the context we're
    // living in.
    STDMETHODIMP    SetSite(IUnknown *pUnkSite);
    STDMETHODIMP    GetSite(REFIID riid, void **ppvSite);

    IUnknown *        m_punkSite;

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\mediadet\mediadetf.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: mediadetf.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "mediadet.h"
#include "..\util\conv.cxx"

CMediaDetPin::CMediaDetPin( CMediaDetFilter * pFilter, HRESULT * pHr, LPCWSTR Name )
    : CBaseInputPin( TEXT("MediaDetPin"), pFilter, &m_Lock, pHr, Name )
    , m_pFilter( pFilter )
    , m_mtAccepted( GUID_NULL )
    , m_cPinRef( 0 )
{
}

//
// NonDelegatingAddRef
//
// We need override this method so that we can do proper reference counting
// on each input pin. The CBasePin implementation of NonDelegatingAddRef
// refcounts the filter, but this won't work for use since we need to know
// when we should delete individual pins.
//
STDMETHODIMP_(ULONG) CMediaDetPin::NonDelegatingAddRef()
{
#ifdef DEBUG
    // Update the debug only variable maintained by the base class
    m_cRef++;
    ASSERT(m_cRef > 0);
#endif

    // Now update our reference count
    m_cPinRef++;
    ASSERT(m_cPinRef > 0);

    // If our reference count == 2, then someone besides the filter has referenced
    // us.  Therefore we need to AddRef the filter.  The reference on the filter will
    // be released when our ref count gets back to 1.
//    if (2 == m_cPinRef)
//	m_pFilter->AddRef();

    return m_cPinRef;
} /* CAudMixerInputPin::NonDelegatingAddRef */


//
// NonDelegatingRelease
//
// CAudMixerInputPin overrides this class so that we can take the pin out of our
// input pins list and delete it when its reference count drops to 1 and there
// is at least two free pins.
//
// Note that CreateNextInputPin holds a reference count on the pin so that
// when the count drops to 1, we know that no one else has the pin.
//
STDMETHODIMP_(ULONG) CMediaDetPin::NonDelegatingRelease()
{
#ifdef DEBUG
    // Update the debug only variable in CBasePin
    m_cRef--;
    ASSERT(m_cRef >= 0);
#endif

    // Now update our reference count
    m_cPinRef--;
    ASSERT(m_cPinRef >= 0);

    // if the reference count on the object has gone to one, remove
    // the pin from our output pins list and physically delete it
    // provided there are atealst two free pins in the list(including
    // this one)

    // Also, when the ref count drops to 0, it really means that our
    // filter that is holding one ref count has released it so we
    // should delete the pin as well.

    // since DeleteINputPin will wipe out "this"'s stack, we need
    // to save this off as a local variable.
    //
    ULONG ul = m_cPinRef;

    if ( 0 == ul )
    {
	m_pFilter->DeleteInputPin(this);
    }
    return ul;
} /* CAudMixerInputPin::NonDelegatingRelease */

HRESULT CMediaDetPin::CheckMediaType( const CMediaType * pmtIn )
{
    CheckPointer( pmtIn, E_POINTER );

    GUID Incoming = *pmtIn->Type( );
    if( Incoming == MEDIATYPE_Video )
    {
        if( *pmtIn->FormatType( ) != FORMAT_VideoInfo )
        {
            return -1;
        }
    }

    if( m_mtAccepted == GUID_NULL )
    {
        if( Incoming == MEDIATYPE_Video )
        {
            return 0;
        }
        if( Incoming == MEDIATYPE_Audio )
        {
            return 0;
        }
        return -1;
    }

    if( Incoming == m_mtAccepted )
    {
        return 0;
    }

    return -1;
}

HRESULT CMediaDetPin::GetMediaType( int Pos, CMediaType * pmt )
{
    if( Pos < 0 )
        return E_INVALIDARG;
    if( Pos > 1 )
        return VFW_S_NO_MORE_ITEMS;

    // we only tell them what the major type is!
    pmt->InitMediaType( );
    pmt->SetType( &m_mtAccepted );

    return NOERROR;
}

HRESULT CMediaDetPin::CompleteConnect( IPin *pReceivePin )
{
    ASSERT( m_Connected == pReceivePin );
    HRESULT hr = CBaseInputPin::CompleteConnect( pReceivePin );

    // Since this pin has been connected up, create another input pin
    // if there are no unconnected pins.
    if( SUCCEEDED( hr ) )
    {
        int n = m_pFilter->GetNumFreePins( );

        if( n == 0 )
        {
            // No unconnected pins left so spawn a new one
            CMediaDetPin * pInputPin = m_pFilter->CreateNextInputPin( );
            if( pInputPin != NULL )
            {
                m_pFilter->IncrementPinVersion();
            }
        }
    }

    return hr;
} /* CAudMixerInputPin::CompleteConnect */

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CMediaDetFilter::CMediaDetFilter( TCHAR * pName, IUnknown * pUnk, HRESULT * pHr )
    : CBaseFilter( TEXT("MediaDetFilter"), pUnk, &m_Lock, CLSID_MediaDetFilter )
    , m_PinList( NAME("Input Pins list") )
{
    // Create a single input pin at this time and add it to the list
    InitInputPinsList();
    CreateNextInputPin( );
}

CMediaDetFilter::~CMediaDetFilter( )
{
    InitInputPinsList( );
}

STDMETHODIMP CMediaDetFilter::NonDelegatingQueryInterface( REFIID i, void ** p )
{
    if( i == IID_IMediaDetFilter )
    {
        return GetInterface( (IMediaDetFilter*) this, p );
    }
    return CBaseFilter::NonDelegatingQueryInterface( i, p );
}

STDMETHODIMP CMediaDetFilter::put_AcceptedMediaType( long PinNo, GUID * pMajorType )
{
    CheckPointer( pMajorType, E_POINTER );
    if( PinNo < 0 || PinNo >= m_nPins )
    {
        return E_INVALIDARG;
    }
    CMediaDetPin * pPin = GetPin2( PinNo );
    pPin->m_mtAccepted = *pMajorType;
    return 0;
}

STDMETHODIMP CMediaDetFilter::put_AcceptedMediaTypeB( long PinNo, BSTR MajorTypeCLSID )
{
    if( PinNo < 0 || PinNo >= m_nPins )
    {
        return E_INVALIDARG;
    }

    GUID Guid = GUID_NULL;
    HRESULT hr = CLSIDFromString( MajorTypeCLSID, &Guid ); // assume this is safe!
    if( FAILED( hr ) )
    {
        return hr;
    }
    CMediaDetPin * pPin = GetPin2( PinNo );
    pPin->m_mtAccepted = Guid;
    return 0;
}

STDMETHODIMP CMediaDetFilter::get_Length( long PinNo, double * pVal )
{
    if( PinNo < 0 || PinNo >= m_nPins )
    {
        return E_INVALIDARG;
    }

    // get the pin
    //
    CMediaDetPin * pPin = GetPin2( PinNo );
    CComPtr< IPin > pOtherPin;
    pPin->ConnectedTo( &pOtherPin );
    if( !pOtherPin )
    {
        *pVal = 0;
        return NOERROR;
    }
    CComQIPtr< IMediaSeeking, &IID_IMediaSeeking > pSeek( pOtherPin );
    if( !pSeek )
    {
        *pVal = 0;
        return NOERROR;
    }

    REFERENCE_TIME Duration = 0;
    HRESULT hr = pSeek->GetDuration( &Duration );
    if( FAILED( hr ) )
    {
        *pVal = 0;
        return hr;
    }

    *pVal = RTtoDouble( Duration );
    return 0;
}

//
// InitInputPinsList
//
void CMediaDetFilter::InitInputPinsList( )
{
    // Release all pins in the list and remove them from the list.
    //
    POSITION pos = m_PinList.GetHeadPosition( );
    while( pos )
    {
        CMediaDetPin * pInputPin = m_PinList.GetNext( pos );
        pInputPin->Release( );
    }
    m_nPins = 0;
    m_PinList.RemoveAll( );

} /* CMediaDetFilter::InitInputPinsList */

//
// CreateNextInputPin
//
CMediaDetPin * CMediaDetFilter::CreateNextInputPin( )
{
    DbgLog( ( LOG_TRACE, 1, TEXT("CMediaDetFilter: Create an input pin" ) ) );

    HRESULT hr = NOERROR;
    CMediaDetPin * pPin = new CMediaDetPin( this, &hr, L"InputPin" );

    if( FAILED( hr ) || pPin == NULL )
    {
        delete pPin;
        pPin = NULL;
    }
    else
    {
        pPin->AddRef( );
	m_nPins++;
	m_PinList.AddTail( pPin );
    }

    return pPin;
} /* CMediaDetFilter::CreateNextInputPin */

//
// DeleteInputPin
//
void CMediaDetFilter::DeleteInputPin( CMediaDetPin * pPin )
{
    // Iterate our input pin list looking for the specified pin.
    // If we find the pin, delete it and remove it from the list.
    POSITION pos = m_PinList.GetHeadPosition( );
    while( pos )
    {
        POSITION posold = pos;         // Remember this position
        CMediaDetPin * pInputPin = m_PinList.GetNext( pos );
        if( pInputPin == pPin )
        {
            m_PinList.Remove( posold );
            m_nPins--;
            IncrementPinVersion( );

            delete pPin;
            break;
        }
    }
} /* CMediaDetFilter::DeleteInputPin */

//
// GetNumFreePins
//
int CMediaDetFilter::GetNumFreePins( )
{
    // Iterate our pin list, counting pins that are not connected.
    int n = 0;
    POSITION pos = m_PinList.GetHeadPosition( );
    while( pos )
    {
        CMediaDetPin * pInputPin = m_PinList.GetNext( pos );
        if( !pInputPin->IsConnected( ) )
        {
            n++;
        }
    }
    return n;
} /* CMediaDetFilter::GetNumFreePins */

HRESULT CMediaDetFilter::get_PinCount( long * pVal )
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nPins - 1;
    return NOERROR;
} /* CAudMixer::GetPinCount */

int CMediaDetFilter::GetPinCount( )
{
    return m_nPins;
}

//
// GetPin
//
CBasePin * CMediaDetFilter::GetPin( int n )
{
    CMediaDetPin * pInputPin = NULL;
    // Validate the position being asked for
    if( n < m_nPins && n >= 0 )
    {
        // Iterate through the list, returning the pin at position n+1
        POSITION pos = m_PinList.GetHeadPosition( );
        n++;        // Convert zero starting index to 1

        while( n )
        {
            pInputPin = m_PinList.GetNext( pos );
            n--;
        }
    }
    return pInputPin;
}

CMediaDetPin * CMediaDetFilter::GetPin2( int n )
{
    CMediaDetPin * pInputPin = NULL;
    // Validate the position being asked for
    if( n < m_nPins && n >= 0 )
    {
        // Iterate through the list, returning the pin at position n+1
        POSITION pos = m_PinList.GetHeadPosition( );
        n++;        // Convert zero starting index to 1

        while( n )
        {
            pInputPin = m_PinList.GetNext( pos );
            n--;
        }
    }
    return pInputPin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\medloc\resource.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by medloc.rc
//
#define IDD_MEDLOC_DIALOG               903
#define IDC_ORIGINAL                    904
#define IDC_FOUND                       905
#define IDR_MEDIALOCATOR                901
#define IDS_CANNOT_FIND_FILE            902

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\medloc\medialoc.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: medialoc.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// MediaLocator.cpp : Implementation of CMediaLocator
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "..\util\dexmisc.h"
#include "MediaLoc.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define MAX_FILTER_STRING 1024

const long DEFAULT_DIRECTORIES = 8;
const TCHAR * gszRegistryLoc = TEXT("Software\\Microsoft\\ActiveMovie\\MediaLocator");

CMediaLocator::CMediaLocator( )
{
    m_bUseLocal = FALSE;

    HKEY hKey = NULL;

    // create the key just to make sure it's there
    //
    long Result = RegCreateKeyEx(
        HKEY_CURRENT_USER,  // key
        gszRegistryLoc,     // sub key
        0,                  // reserved
        NULL,               // lpClass
        0,                  // options
        KEY_EXECUTE | KEY_QUERY_VALUE,
        NULL, // default ACL
        &hKey,
        NULL ); // disp

    if( Result == ERROR_SUCCESS )
    {
        // go find out if we're supposed to look locally
        //
        DWORD Size = sizeof( long );
        DWORD Type = REG_DWORD;
        long UseLocal = 0;
        Result = RegQueryValueEx(
            hKey,
            TEXT("UseLocal"),
            0, // reserved
            &Type,
            (BYTE*) &UseLocal,
            &Size );
        if( Result == ERROR_SUCCESS )
        {
            m_bUseLocal = UseLocal;
        }

        RegCloseKey( hKey );

    }
}

/////////////////////////////////////////////////////////////////////////////
// FindMediaFile - try to find the media file using some cacheing mechanism
// Use the registry to hold the caching directories. A return value of S_FALSE
// means the file was replaced with another, a return code of E_FAIL means
// the file couldn't be found anywhere.
/////////////////////////////////////////////////////////////////////////////
//
HRESULT CMediaLocator::FindMediaFile
    ( BSTR Input, BSTR FilterString, BSTR * pOutput, long ValidateFlags )
{
    CheckPointer( pOutput, E_POINTER );

    HRESULT hr;

    // don't validate the incoming filename exists, since it very well may
    // not (that's the point of this class). We *should* be validating the
    // file name isn't a printer or something, but this is better left AFTER
    // finding the name, than before

    hr = ValidateFilenameIsntNULL( Input);
    if( FAILED( hr ) ) return hr;

    BOOL UseLocal = ( ( ValidateFlags & SFN_VALIDATEF_USELOCAL ) == SFN_VALIDATEF_USELOCAL );
    BOOL WantUI = ( ( ValidateFlags & SFN_VALIDATEF_POPUP ) == SFN_VALIDATEF_POPUP );
    BOOL WarnReplace = ( ( ValidateFlags & SFN_VALIDATEF_TELLME ) == SFN_VALIDATEF_TELLME );
    BOOL DontFind = ( ( ValidateFlags & SFN_VALIDATEF_NOFIND ) == SFN_VALIDATEF_NOFIND );
    UseLocal |= m_bUseLocal ;

    // reset this now
    //
    *pOutput = NULL;

    // !!! what if the incoming file is not on a disk, like
    // 1) On the web
    // 2) On external hardware!

    USES_CONVERSION;
    TCHAR * tInput = W2T( Input );
    BOOL FoundFileAsSpecified = FALSE;

    HANDLE hcf = CreateFile(
        tInput,
        GENERIC_READ, // the point is, we're about to see if we can read it. Don't use "0"
        FILE_SHARE_READ, // share mode
        NULL, // security
        OPEN_EXISTING, // creation disposition
        0, // flags
        NULL );

    if( INVALID_HANDLE_VALUE != hcf )
    {
        FoundFileAsSpecified = TRUE;
        CloseHandle( hcf );
    }

    // if we found the file where the user asked and they didn't specify use local
    // then return
    //
    if( FoundFileAsSpecified )
    {
        if( !UseLocal )
        {
            hr = ValidateFilename( Input, MAX_PATH, FALSE );
            ASSERT( !FAILED( hr ) );
            return hr;
        }
        else
        {
            // they specified use local and it is local
            //
	    // !!! this isn't good enough.
            if( tInput[0] != '\\' || tInput[1] != '\\' )
            {
                hr = ValidateFilename( Input, MAX_PATH, FALSE );
                ASSERT( !FAILED( hr ) );
                return hr;
            }
        }
    }

    // cut up the filename into little bits
    //
    TCHAR Drive[_MAX_DRIVE];
    TCHAR Dir[_MAX_DIR];
    TCHAR Fname[_MAX_FNAME];
    TCHAR Ext[_MAX_EXT];
    _tsplitpath( tInput, Drive, Dir, Fname, Ext );
    TCHAR tNewFileName[_MAX_PATH];

    // can't find nothing
    //
    if( wcslen( Input ) == 0 ) // safe
    {
        return E_INVALIDARG;
    }

    // where did we look last?
    //
    HKEY hKey = NULL;
    long Result = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        gszRegistryLoc ,
        0, // reserved options
        KEY_EXECUTE | KEY_SET_VALUE | KEY_QUERY_VALUE,
        &hKey );

    if( Result != ERROR_SUCCESS )
    {
        return MAKE_HRESULT( 1, 4, Result );
    }

    // find out how many cached directories to look in
    //
    long DirectoryCount = DEFAULT_DIRECTORIES;
    DWORD Size = sizeof( long );
    DWORD Type = REG_DWORD;
    Result = RegQueryValueEx(
        hKey,
        TEXT("Directories"),
        0, // reserved
        &Type,
        (BYTE*) &DirectoryCount,
        &Size );

    if( Result != ERROR_SUCCESS )
    {
        // if we don't have a count, default to something
        //
        DirectoryCount = DEFAULT_DIRECTORIES;
    }

    // bound this to something reasonable
    if( DirectoryCount > 32 )
    {
        DirectoryCount = 32;
    }
    if( DirectoryCount < 1 )
    {
        DirectoryCount = 1;
    }

    while( !DontFind )
    {
        // look in each directory
        //
        bool foundit = false;
        for( long i = 0 ; i < DirectoryCount ; i++ )
        {
            TCHAR ValueName[256];
            wsprintf( ValueName, TEXT("Directory%2.2ld"), i ); // safe, i can't be > 99
            TCHAR DirectoryName[256];
            Size = sizeof(DirectoryName);
            Type = REG_SZ;

            Result = RegQueryValueEx(
                hKey,
                ValueName,
                0, // reserved
                &Type,
                (BYTE*) DirectoryName,
                &Size );

            if( Result != ERROR_SUCCESS )
            {
                // didn't find it, must not exist, do the next one
                //
                continue;
            }

            // found a directory

            // build up a new filename
            //
            size_t Remaining = _MAX_PATH;
            TCHAR * tContinue = NULL;
            hr = StringCchCopyEx( tNewFileName, Remaining, DirectoryName, &tContinue, &Remaining, 0 );
            if( FAILED( hr ) )
            {
                continue;
            }
            hr = StringCchCopyEx( tContinue, Remaining, Fname, &tContinue, &Remaining, 0 );
            if( FAILED( hr ) )
            {
                continue;
            }
            hr = StringCchCopyEx( tContinue, Remaining, Ext, NULL, NULL, 0 );
            if( FAILED( hr ) )
            {
                continue;
            }

            // if UseLocal is set, and this directory is on the net, then
            // ignore it
            //
            if( UseLocal  )
            {
		// !!! ugly
                if( tNewFileName[0] == '\\' && tNewFileName[1] == '\\' )
                {
                    continue;
                }
            }

            HANDLE h = CreateFile(
                tNewFileName,
                GENERIC_READ, // access
                FILE_SHARE_READ, // share mode
                NULL, // security
                OPEN_EXISTING, // creation disposition
                0, // flags
                NULL );

            if( INVALID_HANDLE_VALUE == h )
            {
                // didn't find it, continue
                //
                continue;
            }

            // found the directory it was in, break;
            //
            CloseHandle( h );
            foundit = true;
            break;
        }

        // found it!
        //
        if( foundit )
        {
            // validate it first
            //
            hr = ValidateFilename( T2W( tNewFileName ), MAX_PATH, FALSE );
            ASSERT( !FAILED( hr ) );

            if( SUCCEEDED( hr ) )
            {
                AddOneToDirectoryCache( hKey, i );
                *pOutput = SysAllocString( T2W( tNewFileName ) );
                hr = *pOutput ? S_FALSE : E_OUTOFMEMORY;
                if( WarnReplace )
                {
                    ShowWarnReplace( Input, *pOutput );
                }
            }
            RegCloseKey( hKey );
            hKey = NULL;
            return hr;
        }

        // we didn't find it. :-(

        // if we got here, we found it where it was supposed to be, but
        // we tried to look for it locally instead. Return we found it.
        //
        if( FoundFileAsSpecified )
        {
            hr = ValidateFilename( Input, MAX_PATH, FALSE );
            ASSERT( !FAILED( hr ) );
            RegCloseKey( hKey );
            return hr;
        }

        if( !UseLocal )
        {
            break; // out of while loop
        }
        UseLocal = FALSE;

    } // while 1 ( UseLocal will break us out )

    // it's REALLY not around!

    // if we don't want UI, just signal we couldn't find it
    //
    if( !WantUI )
    {
        // we return S_FALSE to signify the file was replaced, and
        // a failure code to signify we couldn't find it period.
        //
        RegCloseKey( hKey );
        hKey = NULL;
        return E_FAIL;
    }

    // bring up a UI and try to go find it
    //
    OPENFILENAME ofn;
    ZeroMemory( &ofn, sizeof( ofn ) );

    // we need to find two double-nulls in a row if they really specified a
    // filter string
    TCHAR * tFilter = NULL;
    TCHAR ttFilter[MAX_FILTER_STRING];

    if( !FAILED( ValidateFilenameIsntNULL( FilterString ) ) )
    {
        size_t FilterLen = 0;
        HRESULT hrLen = StringCchLength( FilterString, MAX_FILTER_STRING, &FilterLen );
        if( FilterLen < 2 )
        {
            return E_INVALIDARG;
        }
        if( FAILED( hrLen ) )
        {
            return E_INVALIDARG;
        }

        // look for two nulls
        //
        for( int i = 0 ; i < MAX_FILTER_STRING - 1 ; i++ )
        {
            // found it
            //
            if( FilterString[i] == 0 && FilterString[i+1] == 0 )
            {
                break;
            }
        }
	if( i >= MAX_FILTER_STRING - 1 )
	{
	    return E_INVALIDARG;
	}

#ifndef UNICODE
        // copy it to a shorty string, with two nulls
        //
        WideCharToMultiByte( CP_ACP, 0, FilterString, i + 2, ttFilter, MAX_FILTER_STRING, NULL, NULL );
#else if
        // need to copy both the extra zero's as well, or the filter string will fail
        CopyMemory(ttFilter, FilterString, 2*(i+2) );
#endif

        // point to it
        //
        tFilter = ttFilter;
    }

    // we shouldn't make the return path any longer than max_path either, I think.
    // so this code is good.
    TCHAR tReturnName[_MAX_PATH];
    TCHAR * tEnd = NULL;
    size_t tRemaining = 0;
    hr = StringCchCopyEx( tReturnName, _MAX_PATH, Fname, &tEnd, &tRemaining, 0 );
    if( FAILED( hr ) )
    {
        return hr;
    }
    hr = StringCchCopyEx( tEnd, tRemaining, Ext, NULL, NULL, 0 );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // fashion a title so the user knows what file to find
    //
    HINSTANCE hinst = _Module.GetModuleInstance( );

    TCHAR tErrorMsg[256];
    int ReadIn = LoadString( hinst, IDS_CANNOT_FIND_FILE, tErrorMsg, 256 /* characters */ );
    TCHAR tTitle[_MAX_PATH + 256]; // it's okay if it's a bit too big
    if( ReadIn )
    {
        tRemaining = _MAX_PATH + 256;
        StringCchCopyEx( tTitle, tRemaining, tErrorMsg, &tEnd, &tRemaining, 0 );
        StringCchCopyEx( tEnd, tRemaining, tReturnName, NULL, NULL, 0 ); // doesn't matter if it truncates
        ofn.lpstrTitle = tTitle;
    }
    else
    {
        ReadIn = GetLastError( );
    }

    ofn.lStructSize = sizeof( ofn );
    ofn.hwndOwner = NULL;
    ofn.hInstance = _Module.GetModuleInstance( );
    ofn.lpstrFilter = tFilter;
    ofn.lpstrFile = tReturnName;
    ofn.nMaxFile = _MAX_PATH;
    ofn.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_LONGNAMES;
    long r = GetOpenFileName( &ofn );
    if( r == 0 )
    {
        // not a very good error code, is it?
        //
        RegCloseKey( hKey );
        hKey = NULL;
        return E_FAIL;
    }

    _tsplitpath( ofn.lpstrFile, Drive, Dir, Fname, Ext );
    // create a string that is the directory which was found
    TCHAR ReplacementPath[_MAX_DRIVE+_MAX_DIR];
    StringCchCopy( ReplacementPath, _MAX_DRIVE+_MAX_DIR, Drive ); // safe, Drive can't be over max_drive!
    StringCchCat( ReplacementPath, _MAX_DIR, Dir ); // safe

    long i = GetLeastUsedDirectory( hKey, DirectoryCount );
    ReplaceDirectoryPath( hKey, i, ReplacementPath );

    *pOutput = SysAllocString( T2W( ofn.lpstrFile ) );
    hr = *pOutput ? S_FALSE : E_OUTOFMEMORY;

    RegCloseKey( hKey );
    hKey = NULL;

    return hr;
}

// sets registry value, called from FindMediaFile
void CMediaLocator::AddOneToDirectoryCache( HKEY hKey, int WhichDirectory )
{
    DWORD Size = sizeof( long );
    DWORD Type = REG_DWORD;
    long UsageCount = 0;
    TCHAR ValueName[25];
    wsprintf( ValueName, TEXT("Dir%2.2ldUses"), WhichDirectory ); // safe

    long Result = RegQueryValueEx(
        hKey,
        ValueName,
        0, // reserved
        &Type,
        (BYTE*) &UsageCount,
        &Size );

    if( Result != ERROR_SUCCESS )
    {
        return;
    }

    UsageCount++;

    RegSetValueEx(
        hKey,
        ValueName,
        0, // reserverd
        REG_DWORD,
        (BYTE*) &UsageCount,
        sizeof( UsageCount ) );

}

int CMediaLocator::GetLeastUsedDirectory( HKEY hKey, int DirectoryCount )
{
    long Min = -1;
    long WhichDir = 0;

    long i;
    for( i = 0 ; i < DirectoryCount ; i++ )
    {
        TCHAR ValueName[25];
        wsprintf( ValueName, TEXT("Dir%2.2ldUses"), i ); // safe
        DWORD Size = sizeof( long );
        DWORD Type = REG_DWORD;
        long UsageCount = 0;

        long Result = RegQueryValueEx(
                hKey,
                ValueName,
                0, // reserved
                &Type,
                (BYTE*) &UsageCount,
                &Size );

        if( Result != ERROR_SUCCESS )
        {
            // since this key didn't exist yet, it's certainly not
            // used, so we can return "i".
            //
            return i;
        }

        if( i == 0 )
        {
            Min = UsageCount;
        }

        if( UsageCount < Min )
        {
            Min = UsageCount;
            WhichDir = i;
        }

    } // for

    return WhichDir;
}

// sets registry value
void CMediaLocator::ReplaceDirectoryPath( HKEY hKey, int WhichDirectory, TCHAR * Path )
{
    // don't stick it in the registry if it's too big
    //
    if( _tcslen( Path ) > _MAX_PATH )
    {
        return;
    }

    TCHAR ValueName[25];
    wsprintf( ValueName, TEXT("Directory%2.2ld"), WhichDirectory ); // safe
    DWORD Size = sizeof(TCHAR) * ( _tcslen(Path) + 1 ); // safe

    RegSetValueEx(
            hKey,
            ValueName,
            0, // reserved
            REG_SZ,
            (BYTE*) Path,
            Size );

    // doesn't matter if it bombs

    long UsageCount = 0;
    wsprintf( ValueName, TEXT("Dir%2.2ldUses"), WhichDirectory ); // safe

    RegSetValueEx(
        hKey,
        ValueName,
        0, // reserverd
        REG_DWORD,
        (BYTE*) &UsageCount,
        sizeof( UsageCount ) );

    // doesn't matter if it bombs
}

STDMETHODIMP CMediaLocator::AddFoundLocation( BSTR Dir )
{
    // where did we look last?
    //
    HKEY hKey = NULL;
    long Result = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        gszRegistryLoc ,
        0, // reserved options
        KEY_READ | KEY_WRITE, // access
        &hKey );

    if( Result != ERROR_SUCCESS )
    {
        return MAKE_HRESULT( 1, 4, Result );
    }

    // find out how many cached directories to look in
    //
    long DirectoryCount = DEFAULT_DIRECTORIES;
    DWORD Size = sizeof( long );
    DWORD Type = REG_DWORD;
    Result = RegQueryValueEx(
        hKey,
        TEXT("Directories"),
        0, // reserved
        &Type,
        (BYTE*) &DirectoryCount,
        &Size );

    if( Result != ERROR_SUCCESS )
    {
        // if we don't have a count, default to something
        //
        DirectoryCount = DEFAULT_DIRECTORIES;
    }

    // bound it
    if( ( DirectoryCount < 1 ) || ( DirectoryCount > 32 ) )
    {
        DirectoryCount = DEFAULT_DIRECTORIES;
    }

    USES_CONVERSION;
    TCHAR * tDir = W2T( Dir );
    long i = GetLeastUsedDirectory( hKey, DirectoryCount );
    if( ( i < 0 ) || ( i > 31 ) )
    {
        RegCloseKey( hKey );
        return NOERROR;
    }
    ReplaceDirectoryPath( hKey, i, tDir );

    RegCloseKey( hKey );

    return NOERROR;
}

void CMediaLocator::ShowWarnReplace( TCHAR * pOriginal, TCHAR * pReplaced )
{
    CAutoLock Lock( &m_Lock );

    HINSTANCE h = _Module.GetModuleInstance( );

    // these will (correctly) truncate the incoming strings if they're too long
    // so nothing needs done here, we can even ignore the return codes
    // from the below

    StringCchCopy( CMediaLocator::szShowWarnOriginal, _MAX_PATH, pOriginal );
    StringCchCopy( CMediaLocator::szShowWarnReplaced, _MAX_PATH, pReplaced );

    HWND hDlg = CreateDialog( h, MAKEINTRESOURCE( IDD_MEDLOC_DIALOG ), NULL, DlgProc );
    if( !hDlg )
    {
        return;
    }

    static int cx = 0;
    static int cy = 0;
    cx += 20;
    cy += 15;

    if( cx > 600 ) cx -= 600;
    if( cy > 400 ) cy -= 400;

    ShowWindow( hDlg, SW_SHOW );

    SetWindowPos( hDlg, NULL, cx, cy, 0, 0, SWP_NOSIZE | SWP_NOZORDER );

    USES_CONVERSION;
    TCHAR * tOriginal = W2T( CMediaLocator::szShowWarnOriginal );
    TCHAR * tReplaced = W2T( CMediaLocator::szShowWarnReplaced );

    SetDlgItemText( hDlg, IDC_ORIGINAL, tOriginal );
    SetDlgItemText( hDlg, IDC_FOUND, tReplaced );

    DWORD ThreadId = 0;
    HANDLE NewThread = CreateThread( NULL, 0, ThreadProc, (LPVOID) hDlg, 0, &ThreadId );
    if( !NewThread )
    {
        EndDialog( hDlg, TRUE );
    }
    else
    {
        SetThreadPriority( NewThread, THREAD_PRIORITY_BELOW_NORMAL );
    }

    // by the time this dialog call gets back, it will have used the values
    // stored in the static vars and they are free to be used again
}

TCHAR CMediaLocator::szShowWarnOriginal[_MAX_PATH];
TCHAR CMediaLocator::szShowWarnReplaced[_MAX_PATH];

INT_PTR CALLBACK CMediaLocator::DlgProc( HWND h, UINT i, WPARAM w, LPARAM l )
{
    switch( i )
    {
    case WM_INITDIALOG:
        {
        return TRUE;
        }
    }
    return FALSE;
}

DWORD WINAPI CMediaLocator::ThreadProc( LPVOID lpParam )
{
    Sleep( 3000 );
    EndDialog( (HWND) lpParam, TRUE );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\mediadet\setup.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: setup.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "mediadet.h"

#ifdef MSDEV
    #include "qedit_i.c"
    #include <atlconv.cpp>
    // why the h*** this isn't defined already escapes me.
    struct IUnknown * __stdcall ATL::AtlComPtrAssign(struct IUnknown** pp, struct IUnknown* lp)
    {
	    if (lp != NULL)
		    lp->AddRef();
	    if (*pp)
		    (*pp)->Release();
	    *pp = lp;
	    return lp;
    }
#endif

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_NULL,         // Major CLSID
    &MEDIASUBTYPE_NULL       // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",             // Pin's string name
      TRUE,                 // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypes }        // Pin information
};

const AMOVIESETUP_FILTER sudMediaDetFilter =
{
    &CLSID_MediaDetFilter,             // CLSID of filter
    L"MediaDetFilter",    // Filter's name
    MERIT_DO_NOT_USE,       // Filter merit
    1,                      // Number of pins we start out with
    psudPins                // Pin information
};

// Creator function for the class ID
//
CUnknown * WINAPI CMediaDetFilter::CreateInstance( LPUNKNOWN pUnk, HRESULT * phr )
{
    return new CMediaDetFilter( NAME( "MediaDetFilter" ), pUnk, phr );
}

// Creator function for the class ID
//
CUnknown * WINAPI CMediaDet::CreateInstance( LPUNKNOWN pUnk, HRESULT * phr )
{
    return new CMediaDet( NAME( "MediaDet" ), pUnk, phr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\mediadet\mediadet.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: mediadet.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include <qeditint.h>
#include <qedit.h>
#include "..\util\dexmisc.h"
#include "..\util\filfuncs.h"
#include "mediadet.h"
#include "..\util\conv.cxx"
#include "..\render\dexhelp.h"
#include <shfolder.h>
#include <strsafe.h>

// this ini file holds media type information about various streams in various
// files. It uses structured storage. All file accesses are serialized through
// a mutex.
//
#define OUR_VERSION 1
const WCHAR * gszMEDIADETCACHEFILE = L"DCBC2A71-70D8-4DAN-EHR8-E0D61DEA3FDF.ini";
#define GETCACHEDIRNAMELEN 32

// this routine prevents a named mutex tromp, and initializes the cache directory location
// so it doesn't have to be computed all the time
//
HANDLE CMediaDet::m_ghMutex = NULL;
WCHAR CMediaDet::m_gszCacheDirectoryName[_MAX_PATH];
void CALLBACK CMediaDet::StaticLoader( BOOL bLoading, const CLSID * rclsid )
{
    if( bLoading )
    {
        WCHAR WeirdMutexName[33];
        srand( timeGetTime( ) * timeGetTime( ) );
        for( int i = 0 ; i < 32 ; i++ )
        {
            WeirdMutexName[i] = 64 + rand( ) % 27;
        }
        WeirdMutexName[32] = 0;
        m_ghMutex = CreateMutex( NULL, FALSE, WeirdMutexName );
        m_gszCacheDirectoryName[0] = 0;
    }
    else
    {
        if( NULL != m_ghMutex )
        {
            CloseHandle( m_ghMutex );
            m_ghMutex = NULL;
        }
    }
}

//############################################################################
//
//############################################################################

CMediaDet::CMediaDet( TCHAR * pName, IUnknown * pUnk, HRESULT * pHr )
    : CUnknown( pName, pUnk )
    , m_nStream( 0 )
    , m_cStreams( 0 )
    , m_bBitBucket( false )
    , m_bAllowCached( true )
    , m_hDD( 0 )
    , m_hDC( 0 )
    , m_hDib( NULL )
    , m_hOld( 0 )
    , m_pDibBits( NULL )
    , m_nDibWidth( 0 )
    , m_nDibHeight( 0 )
    , m_pCache( NULL )
    , m_dLastSeekTime( -1.0 )
    , m_punkSite( NULL )
    , m_szFilename( NULL )
{
    if( !m_ghMutex )
    {
        *pHr = E_OUTOFMEMORY;
    }
}

//############################################################################
//
//############################################################################

CMediaDet::~CMediaDet( )
{
    // wipe out the graph 'n' stuff
    //
    _ClearOutEverything( );

    // close the cache memory
    //
    _FreeCacheMemory( );

    // if we have these objects open, close them now
    //
    if( m_hDD )
    {
        DrawDibClose( m_hDD );
    }
    if( m_hDib )
    {
        DeleteObject( SelectObject( m_hDC, m_hOld ) );
    }
    if( m_hDC )
    {
        DeleteDC( m_hDC );
    }
}

// it's "loaded" if either of these are set
//
bool CMediaDet::_IsLoaded( )
{
    if( m_pCache || m_pMediaDet )
    {
        return true;
    }
    return false;
}

//############################################################################
// free up the cache memory that's being used for this particular file
//############################################################################

void CMediaDet::_FreeCacheMemory( )
{
    if( m_pCache )
    {
        delete [] m_pCache;
        m_pCache = NULL;
    }
}

//############################################################################
// serialize read in the cache file information and put it into a buffer
//############################################################################

HRESULT CMediaDet::_ReadCacheFile( )
{
    if( !m_ghMutex )
    {
        return E_OUTOFMEMORY;
    }

    DWORD WaitVal = WaitForSingleObject( m_ghMutex, 30000 );
    if( WaitVal != WAIT_OBJECT_0 )
    {
        return STG_E_LOCKVIOLATION;
    }

    CAutoReleaseMutex AutoMutex( m_ghMutex );

    USES_CONVERSION;
    HRESULT hr = 0;

    // if no filename, we can't do anything.
    //
    if( !m_szFilename )
    {
        return NOERROR;
    }

    CComPtr< IStorage > m_pStorage;

    // create the pathname for the .ini file
    //
    WCHAR SystemDir[_MAX_PATH];
    hr = _GetCacheDirectoryName( SystemDir ); // safe as long as max_path is passed in
    if( FAILED( hr ) )
    {
        return hr;
    }

    WCHAR SystemPath[_MAX_PATH+1+_MAX_PATH+1];
    long SafeLen = _MAX_PATH+1+_MAX_PATH+1;
    StringCchCopy( SystemPath, SafeLen, SystemDir );
    SafeLen -= _MAX_PATH;
    StringCchCat( SystemPath, SafeLen, L"\\" );
    SafeLen -= 1;
    StringCchCat( SystemPath, SafeLen, gszMEDIADETCACHEFILE );

    // if somebody opens it for write on a different
    // thread or process, that won't affect us. At the very least,
    // we will not open the stream that's being written, and 
    // cause the OS to attempt to find the media type information
    // directly instead of through the cache file

    hr = StgOpenStorage(
        SystemPath,
        NULL,
        STGM_READ | STGM_SHARE_EXCLUSIVE,
        NULL,
        0,
        &m_pStorage );

    if( FAILED( hr ) )
    {
        return hr;
    }

    // free up the cache file that already exists
    //
    _FreeCacheMemory( );

    // create a unique name for the storage directory
    //
    WCHAR Filename[GETCACHEDIRNAMELEN]; // len includes null terminator
    _GetStorageFilename( m_szFilename, Filename ); // safe

    // open up the stream to read in the cached information
    //
    CComPtr< IStream > pStream;
    hr = m_pStorage->OpenStream(
        Filename,
        NULL,
        STGM_READ | STGM_SHARE_EXCLUSIVE,
        0,
        &pStream );

    // !!! could fail due to somebody trying to write to it. Okay?

    if( FAILED( hr ) )
    {
        return hr;
    }

    // first, read the size of the cache info
    //
    long size = 0;
    hr = pStream->Read( &size, sizeof( size ), NULL );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // do a smart check first, just in case
    //
    if( size < 1 )
    {
        return E_OUTOFMEMORY;
    }

    // here's another "smart" check - no more than 100 streams. Enough, ya think?
    //
    long supposedstreamcount = ( size - sizeof( long ) + sizeof( FILETIME ) + sizeof( long ) ) / sizeof( MDCacheFile );
    if( supposedstreamcount > 100 )
    {
        return VFW_E_INVALID_FILE_FORMAT;
    }

    // create the cache block
    //
    m_pCache = (MDCache*) new char[size];
    if( !m_pCache )
    {
        return E_OUTOFMEMORY;
    }

    hr = pStream->Read( m_pCache, size, NULL );

    // more smart checks
    //
    if( m_pCache->Version != OUR_VERSION )
    {
        return VFW_E_INVALID_FILE_FORMAT;
    }
    if( m_pCache->Count < 0 || m_pCache->Count > 100 )
    {
        return VFW_E_INVALID_FILE_FORMAT;
    }

    // at this point, there is no way to validate that
    // the data is really what it is supposed to be.
    // we have to trust this information is valid. We could only
    // do that by actually opening the file, which is costly

    pStream.Release( );

    m_pStorage.Release( );

    return hr;
}

//############################################################################
//
//############################################################################

void CMediaDet::_WriteCacheFile( )
{
    HRESULT hr = 0;

    if( !m_ghMutex )
    {
        return;
    }

    DWORD WaitVal = WaitForSingleObject( m_ghMutex, 30000 );
    if( WaitVal != WAIT_OBJECT_0 )
    {
        return;
    }

    CAutoReleaseMutex AutoMutex( m_ghMutex );
    USES_CONVERSION;

    CComPtr< IStorage > m_pStorage;

    WCHAR SystemDir[_MAX_PATH];
    hr = _GetCacheDirectoryName( SystemDir ); // safe as long as max_path is passed in
    if( FAILED( hr ) )
    {
        return;
    }

    WCHAR SystemPath[_MAX_PATH+1+_MAX_PATH+1];
    long SafeLen = _MAX_PATH+1+_MAX_PATH+1;
    StringCchCopy( SystemPath, SafeLen, SystemDir );
    SafeLen -= _MAX_PATH;
    StringCchCat( SystemPath, SafeLen, L"\\" );
    SafeLen -= 1;
    StringCchCat( SystemPath, SafeLen, gszMEDIADETCACHEFILE );

    // first figure out how big the cache file is. If it's getting wayyy too 
    // big, it's time to delete it!

    HANDLE hTemp = CreateFile( 
        W2T( SystemPath ),
        0, 
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL );
    if( hTemp != INVALID_HANDLE_VALUE )
    {
        LARGE_INTEGER fileSize;
        fileSize.QuadPart = 0;
        BOOL GotSize = GetFileSizeEx( hTemp, &fileSize );
        CloseHandle( hTemp );
        hTemp = NULL;
        if( GotSize )
        {
            if( fileSize.QuadPart > 250000 )
            {
                // time to delete the cache file, it's getting too darned big
                BOOL Deleted = DeleteFile( W2T( SystemPath ) );
                if( !Deleted )
                {
                    // couldn't delete it, so no more writing!
                    //
                    return;
                }
            }
        }
    }

    hr = StgCreateDocfile( 
        SystemPath,
        STGM_READWRITE | STGM_TRANSACTED, // FAILIFTHERE is IMPLIED
        0,
        &m_pStorage );

    if( hr == STG_E_FILEALREADYEXISTS )
    {
        hr = StgOpenStorage(
            SystemPath,
            NULL,
            STGM_READWRITE | STGM_TRANSACTED,
            NULL,
            0,
            &m_pStorage );
    }

    if( FAILED( hr ) )
    {
        return;
    }

    // tell the main storage to open up a storage for this file
    //
    WCHAR Filename[GETCACHEDIRNAMELEN]; // len includes null terminator
    _GetStorageFilename( m_szFilename, Filename ); // safe

    BOOL TriedRepeat = FALSE;

looprepeat:

    // write out this MDCache
    //
    CComPtr< IStream > pStream;
    hr = m_pStorage->CreateStream( 
        Filename,
        STGM_WRITE | STGM_SHARE_EXCLUSIVE,
        0, 0,
        &pStream );

    if( FAILED( hr ) )
    {
        if( hr == STG_E_FILEALREADYEXISTS )
        {
            if( TriedRepeat )
            {
                return;
            }

            // need to delete the storage first
            //
            hr = m_pStorage->DestroyElement( Filename );
            TriedRepeat = TRUE;
            goto looprepeat;
        }

        DbgLog( ( LOG_ERROR, 1, "Could not CreateStream" ) );

        return;
    }

    long size = sizeof( long ) + sizeof( FILETIME ) + sizeof( long ) + sizeof( MDCacheFile ) * m_cStreams;

    // write the size of what we're about to write
    //
    hr = pStream->Write( &size, sizeof( size ), NULL );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not Write to stream" ) );

        return;
    }
    
    // write the whole block in one chunk
    //
    hr = pStream->Write( m_pCache, size, NULL );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not Write to stream" ) );

        return;
    }

    hr = pStream->Commit( STGC_DEFAULT );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not Commit stream" ) );

        return;
    }

    pStream.Release( );

    m_pStorage->Commit( STGC_DEFAULT );
    m_pStorage.Release( );

    _ClearGraph( ); // don't clear stream count info, we can use that

    return;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::GetSampleGrabber( ISampleGrabber ** ppVal )
{
    CheckPointer( ppVal, E_POINTER );

    if( m_pBitBucketFilter )
    {
        HRESULT hr = m_pBitBucketFilter->QueryInterface( IID_ISampleGrabber, (void**) ppVal );
        return hr;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::NonDelegatingQueryInterface( REFIID i, void ** p )
{
    CheckPointer( p, E_POINTER );

    if( i == IID_IMediaDet )
    {
        return GetInterface( (IMediaDet*) this, p );
    }
    else if( i == IID_IObjectWithSite )
    {
        return GetInterface( (IObjectWithSite*) this, p );
    }
    else if( i == IID_IServiceProvider )
    {
        return GetInterface( (IServiceProvider*) this, p );
    }

    return CUnknown::NonDelegatingQueryInterface( i, p );
}

//############################################################################
// unload the filter, anything it's connected to, and stream info
// called from:
//      WriteCacheFile (because it found a cache file, it doesn't need graph)
//      ClearGraphAndStreams (duh)
//      get_StreamMediaType (it only does this if it's cached, this should have no effect!)
//      EnterBitmapGrabMode (it only does this if no graph, this should have no effect!)
//          if EnterBitmapGrabMode fails, it will also call this. Hm....
//############################################################################

void CMediaDet::_ClearGraph( )
{
    m_pGraph.Release( );
    m_pFilter.Release( );
    m_pMediaDet.Release( );
    m_pBitBucketFilter.Release( );
    m_pBitRenderer.Release( );
    m_bBitBucket = false;
}

//############################################################################
//
//############################################################################

void CMediaDet::_ClearGraphAndStreams( )
{
    _ClearGraph( );
    _FreeCacheMemory( ); // this causes _IsLoaded to return false now
    m_nStream = 0;
    m_cStreams = 0;
}

//############################################################################
//
//############################################################################

void CMediaDet::_ClearOutEverything( )
{
    _ClearGraphAndStreams( );
    if( m_szFilename )
    {
        delete [] m_szFilename;
        m_szFilename = NULL;
    }
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::get_Filter( IUnknown* *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_pFilter;
    if( *pVal )
    {
        (*pVal)->AddRef( );
        return NOERROR;
    }
    return S_FALSE;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::put_Filter( IUnknown* newVal)
{
    CheckPointer( newVal, E_POINTER );

    // make sure it's a filter
    //
    CComQIPtr< IBaseFilter, &IID_IBaseFilter > pBase( newVal );
    if( !pBase )
    {
        return E_NOINTERFACE;
    }

    // clear anything out
    //
    _ClearOutEverything( );

    // set our filter now
    //
    m_pFilter = pBase;

    // load up the info
    //
    HRESULT hr = _Load( );

    // if we failed, don't hold onto the pointer
    //
    if( FAILED( hr ) )
    {
        _ClearOutEverything( );
    }

    return hr;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::get_Filename( BSTR *pVal)
{
    CheckPointer( pVal, E_POINTER );

    // if no name's been set
    //
    if( !m_szFilename )
    {
        *pVal = NULL;
        return NOERROR;
    }

    *pVal = SysAllocString( m_szFilename ); // safe, this is bounded
    if( !(*pVal) ) return E_OUTOFMEMORY;
    return NOERROR;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::put_Filename( BSTR newVal)
{
    HRESULT hr;

    if( FAILED( hr = ValidateFilenameIsntNULL( newVal ) ) )
    {
        _ClearOutEverything( );
        return hr;
    }

    if( FAILED( hr = ValidateFilename( newVal, _MAX_PATH , FALSE) ) )
    {
        return hr;
    }

    USES_CONVERSION;
    TCHAR * tFilename = W2T( newVal ); // safe
    HANDLE h = CreateFile
    (
        tFilename,
        GENERIC_READ, // access
        FILE_SHARE_READ, // share mode
        NULL, // security
        OPEN_EXISTING, // creation disposition
        0, // flags
        NULL
    );
    if( h == INVALID_HANDLE_VALUE )
    {
        return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError( ) );
    }
    CloseHandle( h );

    // clear anything out first
    //
    _ClearOutEverything( );

    m_szFilename = new WCHAR[wcslen(newVal)+1]; // include room for terminator 0
    if( !m_szFilename )
    {
        return E_OUTOFMEMORY;
    }

    // copy over the filename
    //
    StringCchCopy( m_szFilename, wcslen(newVal)+1, newVal ); // safe, it's been allocated

    // try to get our info
    //
    hr = _Load( );

    // if it failed, free up the name
    //
    if( FAILED( hr ) )
    {
        delete [] m_szFilename;
        m_szFilename = NULL;
    }

    return hr;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::get_CurrentStream( long *pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = 0;

    if( !_IsLoaded( ) )
    {
        return NOERROR;
    }

    // either m_pCache or m_pMediaDet is valid, so m_nStream must be valid

    CheckPointer( pVal, E_POINTER );
    *pVal = m_nStream;

    return NOERROR;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::put_CurrentStream( long newVal)
{
    if( m_bBitBucket )
    {
        return E_INVALIDARG;
    }
    if( !_IsLoaded( ) )
    {
        return E_INVALIDARG;
    }

    // since m_pCache or m_pMediaDet is valid, we know m_nStreams is valid

    // force it to load m_cStreams
    //
    long Streams = 0;
    get_OutputStreams( &Streams );

    if( newVal >= Streams )
    {
        return E_INVALIDARG;
    }
    if( newVal < 0 )
    {
        return E_INVALIDARG;
    }
    m_nStream = newVal;
    return NOERROR;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::get_StreamTypeB( BSTR *pVal)
{
    // if we're in bit bucket mode, then we can't return
    // a stream type
    //
    if( m_bBitBucket )
    {
        return E_INVALIDARG;
    }

    // get the stream type and convert to a BSTR
    //
    GUID Type = GUID_NULL;
    HRESULT hr = get_StreamType( &Type );
    if( FAILED( hr ) )
    {
        return hr;
    }

    WCHAR * TempVal = NULL;
    hr = StringFromCLSID( Type, &TempVal );
    if( FAILED( hr ) )
    {
        return hr;

    }

    // if you call StringFromCLSID, VB will fault out. You need to allocate it
    //
    *pVal = SysAllocString( TempVal ); // safe because StringFromCLSID worked
    hr = *pVal ? NOERROR : E_OUTOFMEMORY;
    CoTaskMemFree( TempVal );

    return hr;
}

//############################################################################
//
//############################################################################

HRESULT CMediaDet::_Load( )
{
    USES_CONVERSION;

    HRESULT hr = 0;

    FILETIME WriteTime;
    ZeroMemory( &WriteTime, sizeof( WriteTime ) ); // safe

    if( m_szFilename && m_bAllowCached )
    {
        TCHAR * tFilename = W2T( m_szFilename ); // safe, by now.
    
        // attempt to open the file. if we can't open the file, we cannot cache the
        // values
        //
        HANDLE hFile = CreateFile(
            tFilename,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL );

        if( hFile != INVALID_HANDLE_VALUE )
        {
            // get the real write time
            //
            GetFileTime( hFile, NULL, NULL, &WriteTime );
            CloseHandle( hFile );
        }

        hr = _ReadCacheFile( );
        if( !FAILED( hr ) )
        {
            // if they don't match, we didn't get a hit
            //
            if( memcmp( &WriteTime, &m_pCache->FileTime, sizeof( WriteTime ) ) == 0 ) // safe
            {
                return NOERROR;
            }
        }
        else
        {
            hr = 0;
        }

        // ... drop through and do normal processing. We will cache the answer
        // if possible in the registry as we find it.
    }

    // if we don't have a filter *, then we need one now. Note! This allows us
    // to have a valid m_pFilter but not an m_pGraph!
    //
    if( !m_pFilter )
    {
        CComPtr< IUnknown > pUnk;
        hr = MakeSourceFilter( &pUnk, m_szFilename, NULL, NULL, NULL, NULL, 0, NULL ); // safe
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            DbgLog( ( LOG_ERROR, 1, "Could not MakeSourceFilter" ) );

            _ClearGraphAndStreams( );
            return hr;
        }

        pUnk->QueryInterface( IID_IBaseFilter, (void**) &m_pFilter );
    }

    // now we have a filter. But we don't know how many streams it has.
    // put both the source filter and the mediadet in the graph and tell it to
    // Render( ) the source. All the mediadet pins will then be hooked up.
    // Note! This allows us to have a valid m_pMediaDet without a valid m_pGraph!

    ASSERT( !m_pMediaDet );

    hr = CoCreateInstance(
        CLSID_MediaDetFilter,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IBaseFilter,
        (void**) &m_pMediaDet );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not create MediaDetFilter" ) );

        _ClearGraphAndStreams( );
        return hr;
    }

    hr = CoCreateInstance(
        CLSID_FilterGraph,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IGraphBuilder,
        (void**) &m_pGraph );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not create graph!" ) );

        _ClearGraphAndStreams( );
        return hr;
    }

    // give the graph a pointer back to us. Only tell the graph about us
    // if we've got a site to give. Otherwise, we may clear out a site
    // that already exists.
    //
    if( m_punkSite )
    {
        CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( m_pGraph );
        ASSERT( pOWS );
        if( pOWS )
        {
            pOWS->SetSite( (IServiceProvider *) this );
        }
    }

    hr = m_pGraph->AddFilter( m_pFilter, L"Source" );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not add source filter to graph" ) );

        _ClearGraphAndStreams( );
        return hr;
    }

    hr = m_pGraph->AddFilter( m_pMediaDet, L"MediaDet" );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not add MediaDet filter to graph" ) );

        _ClearGraphAndStreams( );
        return hr;
    }

    // render ALL output pins
    //
    BOOL FoundAtLeastSomething = FALSE;
    long SourcePinCount = GetPinCount( m_pFilter, PINDIR_OUTPUT );
    for( int pin = 0 ; pin < SourcePinCount ; pin++ )
    {
        IPin * pFilterOutPin = GetOutPin( m_pFilter, pin );
        HRESULT hr2 = m_pGraph->Render( pFilterOutPin );
        if( !FAILED( hr2 ) )
        {
            FoundAtLeastSomething = TRUE;
        }
    }
    if( !FoundAtLeastSomething )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not render anything on source" ) );

        _ClearGraphAndStreams( );
        return VFW_E_INVALIDMEDIATYPE;
    }

    // all the pins should be hooked up now.

    // find the number of pins
    //
    CComQIPtr< IMediaDetFilter, &IID_IMediaDetFilter > pDetect( m_pMediaDet );
    pDetect->get_PinCount( &m_cStreams );

    // if we just gave us a filter, don't bother
    // saving back to the registry
    //
    if( !m_szFilename || !m_bAllowCached )
    {
        // but do bother finding out how many streams we've got
        //
        return hr;
    }

    _FreeCacheMemory( );

    long size = sizeof( long ) + sizeof( FILETIME ) + sizeof( long ) + sizeof( MDCacheFile ) * m_cStreams;

    // don't assign this to m_pCache, since functions look at it.
    //
    MDCache * pCache = (MDCache*) new char[size];
    if( !pCache )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not allocate cache memory" ) );

        _ClearGraphAndStreams( );
        return E_OUTOFMEMORY;
    }
    ZeroMemory( pCache, size ); // safe

    pCache->FileTime = WriteTime;
    pCache->Count = m_cStreams;
    pCache->Version = OUR_VERSION;

    // for each pin, find it's media type, etc
    //
    for( int i = 0 ; i < m_cStreams ; i++ )
    {
        m_nStream = i;
        GUID Type = GUID_NULL;
        hr = get_StreamType( &Type );
        double Length = 0.0;
        hr = get_StreamLength( &Length );

        pCache->CacheFile[i].StreamLength = Length;
        pCache->CacheFile[i].StreamType = Type;
    }

    // NOW assign it!
    //
    m_pCache = pCache;

    // if it bombs, there's nothing we can do. We can still allow us to use
    // m_pCache for getting information, but it won't read in next time we
    // try to read it. Next time, it will need to generate the cache information
    // again!
    //
    _WriteCacheFile( );

    return hr;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::get_StreamType( GUID *pVal )
{
    CheckPointer( pVal, E_POINTER );

    if( m_bBitBucket )
    {
        return E_INVALIDARG;
    }
    if( !_IsLoaded( ) )
    {
        return E_INVALIDARG;
    }

    // if we have a cache, use that information now
    //
    if( m_pCache )
    {
        *pVal = m_pCache->CacheFile[m_nStream].StreamType;
        return NOERROR;
    }

    // because of the IsLoaded( ) check above, and the m_pCache check, m_pMediaDet MUST be valid
    //
    IPin * pPin = GetInPin( m_pMediaDet, m_nStream );
    ASSERT( pPin );

    HRESULT hr = 0;

    // ask for it's media type
    //
    AM_MEDIA_TYPE Type;
    hr = pPin->ConnectionMediaType( &Type );
    if( FAILED( hr ) )
    {
        return hr;
    }

    *pVal = Type.majortype;
    SaferFreeMediaType(Type);
    return NOERROR;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::get_StreamMediaType( AM_MEDIA_TYPE * pVal )
{
    CheckPointer( pVal, E_POINTER );

    HRESULT hr = 0;

    // can't do it in bit bucket mode
    //
    if( m_bBitBucket )
    {
        return E_INVALIDARG;
    }
    if( !_IsLoaded( ) )
    {
        return E_INVALIDARG;
    }

    // if we have a cache, use that information now
    //
    if( m_pCache )
    {
        // need to free up the cached stuff and force a load
        //
        _ClearGraph( );
        _FreeCacheMemory( ); // _IsLoaded( ) will now return false!
        m_bAllowCached = false;
        hr = _Load( );
        if( FAILED( hr ) )
        {
            return hr; // whoops!
        }
    }

    // because of the IsLoaded( ) check above, and the reload with m_bAllowCached set
    // to false, m_pMediaDet MUST be valid
    //
    ASSERT( m_pMediaDet );
    IPin * pPin = GetInPin( m_pMediaDet, m_nStream );
    ASSERT( pPin );

    // ask for it's media type
    //
    hr = pPin->ConnectionMediaType( pVal );
    if( FAILED( hr ) )
    {
        return hr;
    }

    return NOERROR;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::get_StreamLength( double *pVal )
{
    CheckPointer( pVal, E_POINTER );

    if( m_bBitBucket )
    {
        return E_INVALIDARG;
    }
    if( !_IsLoaded( ) )
    {
        return E_INVALIDARG;
    }

    // if we have a cache, use that information now
    //
    if( m_pCache )
    {
        *pVal = m_pCache->CacheFile[m_nStream].StreamLength;
        return NOERROR;
    }

    // because of the IsLoaded( ) check above, and the cache check, m_pMediaDet MUST be valid
    //
    HRESULT hr = 0;

    CComQIPtr< IMediaDetFilter, &IID_IMediaDetFilter > pDetector( m_pMediaDet );
    hr = pDetector->get_Length( m_nStream, pVal );
    return hr;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::get_OutputStreams( long *pVal)
{
    if( m_bBitBucket )
    {
        return E_INVALIDARG;
    }
    if( !_IsLoaded( ) )
    {
        return E_INVALIDARG;
    }

    // if we have a cache, use that information now
    //
    if( m_pCache )
    {
        *pVal = m_pCache->Count;
        return NOERROR;
    }

    // it wasn't cached, so it MUST have been loaded in _Load( )
    // m_cStreams will be valid
    //
    CheckPointer( pVal, E_POINTER );
    *pVal = m_cStreams;
    return NOERROR;
}

//############################################################################
//
//############################################################################

HRESULT CMediaDet::_InjectBitBuffer( )
{
    HRESULT hr = 0;

    m_bBitBucket = true;

    hr = CoCreateInstance(
        CLSID_SampleGrabber,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IBaseFilter,
        (void**) &m_pBitBucketFilter );

    if( FAILED( hr ) )
    {
        return hr;
    }

    // tell the sample grabber what to do
    //
    CComQIPtr< ISampleGrabber, &IID_ISampleGrabber > pGrabber( m_pBitBucketFilter );
    CMediaType SetType;
    SetType.SetType( &MEDIATYPE_Video );
    SetType.SetSubtype( &MEDIASUBTYPE_RGB24 );
    SetType.SetFormatType( &FORMAT_VideoInfo ); // this will prevent upsidedown dibs
    pGrabber->SetMediaType( &SetType );
    pGrabber->SetOneShot( FALSE );
    pGrabber->SetBufferSamples( TRUE );

    hr = CoCreateInstance(
        CLSID_NullRenderer,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IBaseFilter,
        (void**) &m_pBitRenderer );

    if( FAILED( hr ) )
    {
        return hr;
    }

    // disconnect the mediadet, the source, and who's between
    //
    IPin * pMediaDetPin = GetInPin( m_pMediaDet, m_nStream );
    if( !pMediaDetPin )
    {
        return E_FAIL;
    }

    // find the first pin which provides the requested output media type, this will
    // be the source or a splitter, supposedly
    //
    CComPtr< IPin > pLastPin;
    hr = FindFirstPinWithMediaType( &pLastPin, pMediaDetPin, MEDIATYPE_Video );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // remove the mediadetfilter, etc
    //
    RemoveChain( pLastPin, pMediaDetPin );
    hr = m_pGraph->RemoveFilter( m_pMediaDet );

    // add the bit bucket
    //
    hr = m_pGraph->AddFilter( m_pBitBucketFilter, L"BitBucket" );
    if( FAILED( hr ) )
    {
        return hr;
    }

    IPin * pBitInPin = GetInPin( m_pBitBucketFilter, 0 );
    if( !pBitInPin )
    {
        return E_FAIL;
    }

    hr = m_pGraph->Connect( pLastPin, pBitInPin );
    if( FAILED( hr ) )
    {
        return hr;
    }

    IPin * pBitOutPin = GetOutPin( m_pBitBucketFilter, 0 );
    if( !pBitOutPin )
    {
        return E_FAIL;
    }

    IPin * pRendererInPin = GetInPin( m_pBitRenderer, 0 );
    if( !pRendererInPin )
    {
        return E_FAIL;
    }

    m_pGraph->AddFilter( m_pBitRenderer, L"NullRenderer" );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = m_pGraph->Connect( pBitOutPin, pRendererInPin );
    if( FAILED( hr ) )
    {
        return hr;
    }

    CComQIPtr< IMediaFilter, &IID_IMediaFilter > pMF( m_pGraph );
    if( pMF )
    {
        pMF->SetSyncSource( NULL );
    }

    return S_OK;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::GetBitmapBits(
                                      double StreamTime,
                                      long * pBufferSize,
                                      char * pBuffer,
                                      long Width,
                                      long Height)
{
    HRESULT hr = 0;

    // has to have been loaded before
    //
    if( !pBuffer )
    {
        CheckPointer( pBufferSize, E_POINTER );
        *pBufferSize = sizeof( BITMAPINFOHEADER ) + WIDTHBYTES( Width * 24 ) * Height;
        return S_OK;
    }

    hr = EnterBitmapGrabMode( StreamTime );
    if( FAILED( hr ) )
    {
        return hr;
    }

    CComQIPtr< ISampleGrabber, &IID_ISampleGrabber > pGrabber( m_pBitBucketFilter );
    if( !pGrabber )
    {
        return E_NOINTERFACE;
    }
//    pGrabber->SetOneShot( TRUE );

    // we can't ask Ourselves for our media type, since we're in bitbucket
    // mode, so ask the sample grabber what's up
    //
    CMediaType ConnectType;
    hr = pGrabber->GetConnectedMediaType( &ConnectType );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        return E_OUTOFMEMORY;
    }
    if( *ConnectType.FormatType( ) != FORMAT_VideoInfo )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }
    VIDEOINFOHEADER * pVIH = (VIDEOINFOHEADER*) ConnectType.Format( );
    if( !pVIH )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }
    BITMAPINFOHEADER * pSourceBIH = &pVIH->bmiHeader;

    hr = _SeekGraphToTime( StreamTime );
    if( FAILED( hr ) )
    {
        return hr;
    }

    long BufferSize = 0;
    pGrabber->GetCurrentBuffer( &BufferSize, NULL );
    if( BufferSize <= 0 )
    {
        ASSERT( BufferSize > 0 );
        return E_UNEXPECTED;
    }
    char * pOrgBuffer = new char[BufferSize+sizeof(BITMAPINFOHEADER)];
    if( !pOrgBuffer )
    {
        return E_OUTOFMEMORY;
    }
    pGrabber->GetCurrentBuffer( &BufferSize, (long*) ( pOrgBuffer + sizeof(BITMAPINFOHEADER) ) );
    CopyMemory( pOrgBuffer, pSourceBIH, sizeof( BITMAPINFOHEADER ) ); // safe
    pSourceBIH = (BITMAPINFOHEADER*) pOrgBuffer;
    char * pSourceBits = ((char*)pSourceBIH) + sizeof( BITMAPINFOHEADER );

    // CopyMemory over the bitmapinfoheader
    //
    BITMAPINFO BitmapInfo;
    ZeroMemory( &BitmapInfo, sizeof( BitmapInfo ) );
    BitmapInfo.bmiHeader.biSize = sizeof( BITMAPINFOHEADER );
    BitmapInfo.bmiHeader.biSizeImage = DIBSIZE( BitmapInfo.bmiHeader );
    BitmapInfo.bmiHeader.biWidth = Width;
    BitmapInfo.bmiHeader.biHeight = Height;
    BitmapInfo.bmiHeader.biPlanes = 1;
    BitmapInfo.bmiHeader.biBitCount = 24;
    BITMAPINFOHEADER * pDestBIH = (BITMAPINFOHEADER*) pBuffer;
    *pDestBIH = BitmapInfo.bmiHeader;
    char * pDestBits = pBuffer + sizeof( BITMAPINFOHEADER );

    // if the sizes don't match, free stuff
    //
    if( Width != m_nDibWidth || Height != m_nDibHeight )
    {
        if( m_hDD )
        {
            DrawDibClose( m_hDD );
            m_hDD = NULL;
        }
        if( m_hDib )
        {
            DeleteObject( SelectObject( m_hDC, m_hOld ) );
            m_hDib = NULL;
            m_hOld = NULL;
        }
        if( m_hDC )
        {
            DeleteDC( m_hDC );
            m_hDC = NULL;
        }
    }

    m_nDibWidth = Width;
    m_nDibHeight = Height;

    // need to scale the image
    //
    if( !m_hDC )
    {
        // create a DC for the scaled image
        //
        HDC screenDC = GetDC( NULL );
        if( !screenDC )
        {
            return E_OUTOFMEMORY;
        }

        m_hDC = CreateCompatibleDC( screenDC );
        ReleaseDC( NULL, screenDC );

        m_hDib = CreateDIBSection(
            m_hDC,
            &BitmapInfo,
            DIB_RGB_COLORS,
            (void**) &m_pDibBits,
            NULL,
            0 );

        if( !m_hDib )
        {
            DeleteDC( m_hDC );
            delete [] pOrgBuffer;
            return E_OUTOFMEMORY;
        }

        ValidateReadWritePtr( m_pDibBits, Width * Height * 3 );

        // Select the dibsection into the hdc
        //
        m_hOld = SelectObject( m_hDC, m_hDib );
        if( !m_hOld )
        {
            DeleteDC( m_hDC );
            delete [] pOrgBuffer;
            return E_OUTOFMEMORY;
        }

        m_hDD = DrawDibOpen( );
        if( !m_hDD )
        {
            DeleteObject( SelectObject( m_hDC, m_hOld ) );
            DeleteDC( m_hDC );
            delete [] pOrgBuffer;
            return E_OUTOFMEMORY;
        }

    }

    ValidateReadWritePtr( pSourceBits, WIDTHBYTES( pSourceBIH->biWidth * pSourceBIH->biPlanes ) * pSourceBIH->biHeight );

    BOOL Worked = DrawDibDraw(
        m_hDD,
        m_hDC,
        0,
        0,
        Width, Height,
        pSourceBIH,
        pSourceBits,
        0, 0,
        pSourceBIH->biWidth, pSourceBIH->biHeight,
        0 );

    CopyMemory( pDestBits, m_pDibBits, WIDTHBYTES( Width * 24 ) * Height ); // safe

    delete [] pOrgBuffer;

    if( !Worked )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    return S_OK;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::WriteBitmapBits(
                                        double StreamTime,
                                        long Width,
                                        long Height,
                                        BSTR Filename )
{
    HRESULT hr = 0;

    if( FAILED( hr = ValidateFilename( Filename, _MAX_PATH, TRUE ) ) )
    {
        return hr;
    }

    USES_CONVERSION;
    TCHAR * t = W2T( Filename ); // safe

    BOOL Deleted = DeleteFile( t ); // safe
    if( !Deleted )
    {
        hr = GetLastError( );
        if( hr != ERROR_FILE_NOT_FOUND )
        {
            return STG_E_ACCESSDENIED;
        }
    }

    // round up to mod 4
    //
    long Mod = Width % 4;
    if( Mod != 0 )
    {
        Width += ( 4 - Mod );
    }

    // find the size of the buffer required
    //
    long BufferSize = 0;
    hr = GetBitmapBits( StreamTime, &BufferSize, NULL, Width, Height );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // allocate and get the buffer
    //
    char * pBuffer = new char[BufferSize];

    if( !pBuffer )
    {
        return E_OUTOFMEMORY;
    }

    hr = GetBitmapBits( StreamTime, 0, pBuffer, Width, Height );
    if( FAILED( hr ) )
    {
        delete [] pBuffer;
        return hr;
    }

    HANDLE hf = CreateFile(
        t,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        NULL,
        NULL );
    if( hf == INVALID_HANDLE_VALUE )
    {
        delete [] pBuffer;
        return STG_E_WRITEFAULT;
    }

    BITMAPFILEHEADER bfh;
    ZeroMemory( &bfh, sizeof( bfh ) );
    bfh.bfType = 'MB';
    bfh.bfSize = sizeof( bfh ) + BufferSize;
    bfh.bfOffBits = sizeof( BITMAPINFOHEADER ) + sizeof( BITMAPFILEHEADER );

    hr = 0;
    DWORD Written = 0;
    BOOL bWritten = WriteFile( hf, &bfh, sizeof( bfh ), &Written, NULL );
    if( !bWritten )
    {
        hr = STG_E_WRITEFAULT;
    }
    if( SUCCEEDED( hr ) )
    {
        Written = 0;
        bWritten = WriteFile( hf, pBuffer, BufferSize, &Written, NULL );
        if( !bWritten )
        {
            hr = STG_E_WRITEFAULT;
        }
    }

    CloseHandle( hf );

    delete [] pBuffer;

    return hr;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::get_FrameRate(double *pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = 0.0;

    CMediaType MediaType;
    HRESULT hr = get_StreamMediaType( &MediaType );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // no frame rate if not video
    //
    if( *MediaType.Type( ) != MEDIATYPE_Video )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    if( *MediaType.FormatType( ) != FORMAT_VideoInfo )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    VIDEOINFOHEADER * pVIH = (VIDEOINFOHEADER*) MediaType.Format( );
    REFERENCE_TIME rt = pVIH->AvgTimePerFrame;

    // !!! hey! Poor filters may tell us the frame rate isn't right.
    // if this is so, just set it to some default
    //
    if( rt )
    {
        hr = 0;
        *pVal = double( UNITS ) / double( rt );
    }
    else
    {
        *pVal = 0;
        hr = S_FALSE;
    }

    return hr;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CMediaDet::EnterBitmapGrabMode( double StreamTime )
{
    HRESULT hr = 0;

    if( !_IsLoaded( ) )
    {
        return E_INVALIDARG;
    }

    if( !m_pGraph ) // if no graph, then m_pCache must be valid, we must throw it away.
    {
        _ClearGraph( ); // should do nothing!
        _FreeCacheMemory( ); // _IsLoaded should not return false
        m_bAllowCached = false;
        hr = _Load( );
        if( FAILED( hr ) )
        {
            return hr; // whoops!
        }
    }

    // kinda a redundant check. hr passing the fail check above should mean it's
    // loaded, right?
    //
    if( !_IsLoaded( ) )
    {
        return E_INVALIDARG;
    }

    // if we haven't put the bit bucket in the graph, then do it now
    //
    if( m_bBitBucket )
    {
        return NOERROR;
    }

    // make sure we're aligned on a stream that produces video.
    //
    GUID StreamType = GUID_NULL;
    get_StreamType( &StreamType );
    if( StreamType != MEDIATYPE_Video )
    {
        BOOL Found = FALSE;
        for( int i = 0 ; i < m_cStreams ; i++ )
        {
            GUID Major = GUID_NULL;
            put_CurrentStream( i );
            get_StreamType( &Major );
            if( Major == MEDIATYPE_Video )
            {
                Found = TRUE;
                break;
            }
        }
        if( !Found )
        {
            return VFW_E_INVALIDMEDIATYPE;
        }
    }

    hr = _InjectBitBuffer( );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not inject BitBuffer" ) );

        // bombed, don't clear out stream count info
        //
        _ClearGraph( );
        return hr;
    }

    // get the full size image as it exists. this necessitates a memory copy to our buffer
    // get our helper interfaces now
    //
    CComQIPtr< IMediaControl, &IID_IMediaControl > pControl( m_pGraph );
    hr = pControl->Pause( );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not pause graph" ) );

        // bombed, don't clear out stream count info
        //
        _ClearGraph( );
        return hr;
    }

    // we need to wait until this is fully paused, or when we issue
    // a seek, we'll really hose out

    OAFilterState FilterState;
    long Counter = 0;
    while( Counter++ < 600 )
    {
        hr = pControl->GetState( 50, &FilterState );
        if( FAILED( hr ) )
        {
            DbgLog((LOG_ERROR,1, TEXT( "MediaDet: Seek Complete, got an error %lx" ), hr ));
            Counter = 0; // clear counter so we see the real error
            break;
        }
        if( hr != VFW_S_STATE_INTERMEDIATE && FilterState == State_Paused )
        {
            DbgLog((LOG_TRACE,1, TEXT( "MediaDet: Seek Complete, state = %ld" ), FilterState ));
            hr = 0;
            Counter = 0;
            break;
        }
    }

    if( Counter != 0 )
    {
        return VFW_E_TIME_EXPIRED;
    }

    hr = _SeekGraphToTime( StreamTime );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_ERROR, 1, "Could not seek graph" ) );

        _ClearGraph( );
        return hr;
    }

    return hr;
}

//############################################################################
// lookup filename must not exceed GETCACHEDIRNAMELEN - 1 characters in length.
// (hash)
//############################################################################

// !?! STOLEN FROM SHLWAPI!!!! Via index2a! (aren't I clever?!)
//
//  this is the same table used by both URLMON and WININET's cache
//
const static BYTE Translate[256] =
{
    1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
    87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
    49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
    12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
    176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
    178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
    102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
    166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
    121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
    193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
    6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
    84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
    249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
    230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
    44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
    163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
};

void HashData(LPBYTE pbData, DWORD cbData, LPBYTE pbHash, DWORD cbHash)
{
    DWORD i, j;
    //  seed the hash
    for (i = cbHash; i-- > 0;)
        pbHash[i] = (BYTE) i;

    //  do the hash
    for (j = cbData; j-- > 0;)
    {
        for (i = cbHash; i-- > 0;)
            pbHash[i] = Translate[pbHash[i] ^ pbData[j]];
    }
}

void CMediaDet::_GetStorageFilename( WCHAR * In, WCHAR * Out )
{
    // incoming file has already been validated, so this is safe
    long InLen = wcslen( In );
    int i;

    BYTE OutTemp[GETCACHEDIRNAMELEN/2];
    ZeroMemory( OutTemp, sizeof( OutTemp ) );

    HashData( (BYTE*) In, InLen * 2, OutTemp, sizeof(OutTemp) );

    // expand the smaller hash into a larger, ASCI hash
    // THIS IS NOT CRYPTO!!!
    //
    for( i = 0 ; i < GETCACHEDIRNAMELEN/2 ; i++ )
    {
        BYTE b = (BYTE) OutTemp[i];
        Out[i*2+0] = 65 + ( b / 16 );
        Out[i*2+1] = 65 + ( b % 16 );
    }
    Out[GETCACHEDIRNAMELEN-1] = 0;
}

//############################################################################
//
//############################################################################

HRESULT CMediaDet::_SeekGraphToTime( double StreamTime )
{
    if( !m_pGraph )
    {
        return E_FAIL;
    }

    if( StreamTime == m_dLastSeekTime )
    {
        return NOERROR;
    }

    HRESULT hr = 0;

    // get the full size image as it exists. this necessitates a memory copy to our buffer
    // get our helper interfaces now
    //
    CComQIPtr< IMediaControl, &IID_IMediaControl > pControl( m_pGraph );
    CComQIPtr< IMediaSeeking, &IID_IMediaSeeking > pSeeking( m_pGraph );

    // seek to the required time FIRST, then pause
    //
    REFERENCE_TIME Start = DoubleToRT( StreamTime );
    REFERENCE_TIME Stop = Start; // + UNITS;
    DbgLog((LOG_TRACE,1, TEXT( "MediaDet: Seeking to %ld ms" ), long( Start / 10000 ) ));
    hr = pSeeking->SetPositions( &Start, AM_SEEKING_AbsolutePositioning, &Stop, AM_SEEKING_AbsolutePositioning );
    if( FAILED( hr ) )
    {
        return hr;
    }

    OAFilterState FilterState;
    long Counter = 0;
    while( Counter++ < 600 )
    {
        hr = pControl->GetState( 50, &FilterState );
        if( FAILED( hr ) )
        {
            DbgLog((LOG_ERROR,1, TEXT( "MediaDet: Seek Complete, got an error %lx" ), hr ));
            Counter = 0; // clear counter so we see the real error
            break;
        }
        if( hr != VFW_S_STATE_INTERMEDIATE )
        {
            DbgLog((LOG_TRACE,1, TEXT( "MediaDet: Seek Complete, state = %ld" ), FilterState ));
            hr = 0;
            Counter = 0;
            break;
        }
    }

    if( Counter != 0 )
    {
        DbgLog((LOG_TRACE,1, TEXT( "MediaDet: ERROR! Could not seek to %ld ms" ), long( Start / 10000 ) ));
        return VFW_E_TIME_EXPIRED;
    }

    if( !FAILED( hr ) )
    {
        m_dLastSeekTime = StreamTime;
    }

    return hr;
}

 //############################################################################
//
//############################################################################
// IObjectWithSite::SetSite
// remember who our container is, for QueryService or other needs
STDMETHODIMP CMediaDet::SetSite(IUnknown *pUnkSite)
{
    // note: we cannot addref our site without creating a circle
    // luckily, it won't go away without releasing us first.
    m_punkSite = pUnkSite;

    if( m_punkSite && m_pGraph )
    {
        CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( m_pGraph );
        ASSERT( pOWS );
        if( pOWS )
        {
            pOWS->SetSite( (IServiceProvider *) this );
        }
    }

    return S_OK;
}

//############################################################################
//
//############################################################################
// IObjectWithSite::GetSite
// return an addrefed pointer to our containing object
STDMETHODIMP CMediaDet::GetSite(REFIID riid, void **ppvSite)
{
    if (m_punkSite)
        return m_punkSite->QueryInterface(riid, ppvSite);

    return E_NOINTERFACE;
}

//############################################################################
//
//############################################################################
// Forward QueryService calls up to the "real" host
STDMETHODIMP CMediaDet::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    IServiceProvider *pSP;

    if (!m_punkSite)
        return E_NOINTERFACE;

    HRESULT hr = m_punkSite->QueryInterface(IID_IServiceProvider, (void **) &pSP);

    if (SUCCEEDED(hr)) {
        hr = pSP->QueryService(guidService, riid, ppvObject);
        pSP->Release();
    }

    return hr;
}

//############################################################################
//
//############################################################################

// make sure this never returns more than MAX_PATH!
HRESULT CMediaDet::_GetCacheDirectoryName( WCHAR * pName )
{
    pName[0] = 0;

    // already found, just copy it
    //
    if( m_gszCacheDirectoryName[0] )
    {
        StringCchCopy( pName, _MAX_PATH, m_gszCacheDirectoryName ); // safe
        return NOERROR;
    }

    HRESULT hr = E_FAIL;
    USES_CONVERSION;
    typedef HRESULT (*SHGETFOLDERPATHW) (HWND hwndOwner,int nFolder,HANDLE hToken,DWORD dwFlags,LPWSTR pszPath);
    SHGETFOLDERPATHW pFuncW = NULL;
    TCHAR tBuffer[_MAX_PATH];
    tBuffer[0] = 0;

    // go find it by dynalinking
    //
    HMODULE h = LoadLibrary( TEXT("ShFolder.dll") ); // safe
    if( NULL != h )
    {
        pFuncW = (SHGETFOLDERPATHW) GetProcAddress( h, "SHGetFolderPathW" );
    }

loop:

    // if we couldn't get a function pointer, just call system directory
    //
    if( !pFuncW )
    {
        UINT i = GetSystemDirectory( tBuffer, _MAX_PATH - 1 );

        // if we got some characters, we did fine, otherwise, we're going to fail
        //
        if( i > 0 )
        {
            StringCchCopy( m_gszCacheDirectoryName, _MAX_PATH, T2W( tBuffer ) ); // safe
            hr = NOERROR;
        }
    }
    else
    {
        hr = pFuncW( NULL, CSIDL_LOCAL_APPDATA, NULL, 0, m_gszCacheDirectoryName ); // safe: docs say length is max-path
        // hr can be S_FALSE if the folder doesn't exist where it should!

        // didn't work? Try the roaming one!
        //
        if( hr != NOERROR )
        {
            hr = pFuncW( NULL, CSIDL_APPDATA, NULL, 0, m_gszCacheDirectoryName );
            // hr can be S_FALSE if the folder doesn't exist where it should!

            // sec: by merely deleting the folder, the user can force this
	    // folder to go to the windows system directory. Okay?
        }

        if( hr != NOERROR )
        {
            // hr could be S_FALSE, or some other non-zero return code.
            // force it into an error if it wasn't an error, so it will at least try the
            // system directory
            //
            if( !FAILED( hr ) )
            {
                hr = E_FAIL;
            }

            // go back and try system directory?
            //
            pFuncW = NULL;
            goto loop;
        }
    }

    // if we succeeded, copy the name for future use
    //
    if( hr == NOERROR )
    {
        StringCchCopy( pName, _MAX_PATH, m_gszCacheDirectoryName ); // safe
    }

    if( h )
    {
        FreeLibrary( h );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\medloc\medialoc.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: medialoc.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// MediaLocator.h : Declaration of the CMediaLocator

#ifndef __MEDIALOCATOR_H_
#define __MEDIALOCATOR_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMediaLocator
class ATL_NO_VTABLE CMediaLocator : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMediaLocator, &CLSID_MediaLocator>,
	public IDispatchImpl<IMediaLocator, &IID_IMediaLocator, &LIBID_DexterLib>
{
    CCritSec m_Lock;
    BOOL m_bUseLocal;
    static TCHAR szShowWarnOriginal[_MAX_PATH];
    static TCHAR szShowWarnReplaced[_MAX_PATH];
    static INT_PTR CALLBACK DlgProc( HWND h, UINT i, WPARAM w, LPARAM l );
    static DWORD WINAPI ThreadProc( LPVOID lpParam );

public:
	CMediaLocator();

DECLARE_REGISTRY_RESOURCEID(IDR_MEDIALOCATOR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMediaLocator)
	COM_INTERFACE_ENTRY(IMediaLocator)
	COM_INTERFACE_ENTRY(IUnknown)
END_COM_MAP()

    void AddOneToDirectoryCache( HKEY h, int WhichDirectory );
    int  GetLeastUsedDirectory( HKEY h, int DirectoryCount );
    void ReplaceDirectoryPath( HKEY h, int WhichDirectory, TCHAR * Path );
    void ShowWarnReplace( TCHAR * pOriginal, TCHAR * pReplaced );

// IMediaLocator
public:
    STDMETHODIMP FindMediaFile( BSTR Input, BSTR FilterString, BSTR * pOutput, long Flags );
    STDMETHODIMP AddFoundLocation( BSTR DirectoryName );
};

#endif //__MEDIALOCATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\medloc\stdafx.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stdafx.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CC1101E8_79DC_11D2_8CE6_00A0C9441E20__INCLUDED_)
#define AFX_STDAFX_H__CC1101E8_79DC_11D2_8CE6_00A0C9441E20__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <streams.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CC1101E8_79DC_11D2_8CE6_00A0C9441E20__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\msgrab\msgrab.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: msgrab.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>     // Active Movie (includes windows.h)
#include <atlbase.h>
#include <initguid.h>    // declares DEFINE_GUID to declare an EXTERN_C const.
#include <qeditint.h>
#include <qedit.h>
#include "msgrab.h"
#include "..\util\filfuncs.h"

// setup data - allows the self-registration to work.
const AMOVIESETUP_MEDIATYPE sudPinTypes =
{ &MEDIATYPE_NULL        // clsMajorType
, &MEDIASUBTYPE_NULL };  // clsMinorType

const AMOVIESETUP_PIN psudSampleGrabberPins[] =
{ { L"Input"            // strName
  , FALSE               // bRendered
  , FALSE               // bOutput
  , FALSE               // bZero
  , FALSE               // bMany
  , &CLSID_NULL         // clsConnectsToFilter
  , L""                 // strConnectsToPin
  , 1                   // nTypes
  , &sudPinTypes        // lpTypes
  }
, { L"Output"           // strName
  , FALSE               // bRendered
  , TRUE                // bOutput
  , FALSE               // bZero
  , FALSE               // bMany
  , &CLSID_NULL         // clsConnectsToFilter
  , L""                 // strConnectsToPin
  , 1                   // nTypes
  , &sudPinTypes        // lpTypes
  }
};
const AMOVIESETUP_PIN psudNullRendererPins[] =
{ { L"Input"            // strName
  , TRUE                // bRendered
  , FALSE               // bOutput
  , FALSE               // bZero
  , FALSE               // bMany
  , &CLSID_NULL         // clsConnectsToFilter
  , L""                 // strConnectsToPin
  , 1                   // nTypes
  , &sudPinTypes        // lpTypes
  }
};

const AMOVIESETUP_FILTER sudSampleGrabber =
{ &CLSID_SampleGrabber                  // clsID
, L"SampleGrabber"                 // strName
, MERIT_DO_NOT_USE                // dwMerit
, 2                               // nPins
, psudSampleGrabberPins };                     // lpPin
const AMOVIESETUP_FILTER sudNullRenderer =
{ &CLSID_NullRenderer                  // clsID
, L"Null Renderer"                 // strName
, MERIT_DO_NOT_USE                // dwMerit
, 1                               // nPins
, psudNullRendererPins };                     // lpPin

//
// CreateInstance
//
// Provide the way for COM to create a CSampleGrabber object
CUnknown * WINAPI CSampleGrabber::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CSampleGrabber *pNewObject = new CSampleGrabber(NAME("MSample Grabber"), punk, phr );
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return pNewObject;
} // CreateInstance

// Constructor - just calls the base class constructor
CSampleGrabber::CSampleGrabber(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr)
    : CTransInPlaceFilter (tszName, punk, CLSID_SampleGrabber, phr,FALSE)
    , m_rtMediaStop(MAX_TIME)
    , m_bOneShot( FALSE )
    , m_bBufferSamples( FALSE )
    , m_pBuffer( NULL )
    , m_nBufferSize( 0 )
    , m_nSizeInBuffer( 0 )
    , m_nCallbackMethod( 0 )
{
    ZeroMemory( &m_mt, sizeof( m_mt ) );

    m_pInput = new CSampleGrabberInput( NAME("Msgrab input pin")
                                         , this        // Owner filter
                                        , phr         // Result code
                                        , L"Input"    // Pin name
                                        );

}

CSampleGrabber::~CSampleGrabber()
{
    SaferFreeMediaType( m_mt );

    if( m_pBuffer )
    {
        delete [] m_pBuffer;
        m_pBuffer = NULL;
    }
    m_nBufferSize = 0;
}


HRESULT CSampleGrabber::Receive(IMediaSample *pSample)
{
    HRESULT hr = 0;

    /*  Check for other streams and pass them on */
    AM_SAMPLE2_PROPERTIES * const pProps = m_pInput->SampleProps();
    if (pProps->dwStreamId != AM_STREAM_MEDIA)
    {
        if( m_pOutput->IsConnected() )
            return m_pOutput->Deliver(pSample);
        else
            return NOERROR;
    }

    REFERENCE_TIME StartTime, StopTime;
    pSample->GetTime( &StartTime, &StopTime);

    // don't accept preroll either
    //
    if( pSample->IsPreroll( ) == S_OK )
    {
        return NOERROR;
    }

    StartTime += m_pInput->CurrentStartTime( );
    StopTime += m_pInput->CurrentStartTime( );

    DbgLog((LOG_TRACE,1, TEXT( "msgrab: Receive %ld to %ld, (delta=%ld)" ), long( StartTime/10000 ), long( StopTime/10000 ), long( ( StopTime - StartTime ) / 10000 ) ));

    long ActualSize = pSample->GetActualDataLength( );
    long BufferSize = pSample->GetSize( );
    BYTE * pSampleBuffer = NULL;
    pSample->GetPointer( &pSampleBuffer );

    // if user told us to buffer, then copy sample
    //
    if( m_bBufferSamples )
    {
        if( BufferSize > m_nBufferSize )
        {
            if( m_pBuffer )
                delete [] m_pBuffer;
            m_pBuffer = NULL;
            m_nBufferSize = 0;
        }

        // if no buffer, make one now.
        //
        if( !m_pBuffer )
        {
            m_nBufferSize = BufferSize;
            m_pBuffer = new char[ m_nBufferSize ];
            if( !m_pBuffer )
            {
                m_nBufferSize = 0;
            }
        }

        // if we still have a buffer, copy the bits
        //

        if( pSampleBuffer && m_pBuffer )
        {
            CopyMemory( m_pBuffer, pSampleBuffer, ActualSize );
            m_nSizeInBuffer = ActualSize;
        }
    }

    if( m_pCallback )
    {
        if( m_nCallbackMethod == 0 )
        {
            m_pCallback->SampleCB( double( StartTime ) / double( UNITS ), pSample );
        }
        else
        {
            m_pCallback->BufferCB( double( StartTime ) / double( UNITS ), pSampleBuffer, ActualSize );
        }
    }

    if( m_pOutput->IsConnected() )
    {
        hr = m_pOutput->Deliver(pSample);
    }

    // if we're a one-shot receiver, then return now and
    // tell the graph to stop
    //
    if( m_bOneShot )
    {
        DbgLog((LOG_ERROR,1, TEXT( "MSGRAB:Sending EC_COMPLETE @ %d" ), timeGetTime( ) ));
        EndOfStream();
        return S_FALSE;
    }

    return hr;
} // Receive

STDMETHODIMP CSampleGrabber::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv
    )
{
    if (riid == IID_ISampleGrabber) {
        return GetInterface((ISampleGrabber *) this, ppv);
    } else {
        return CTransInPlaceFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


HRESULT CSampleGrabber::SetMediaType( PIN_DIRECTION Dir, const CMediaType * mtIn )
{
    if( Dir == PINDIR_INPUT )
    {
        SaferFreeMediaType( m_mt );
        HRESULT hr = CopyMediaType( &m_mt, mtIn );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }

    return CTransInPlaceFilter::SetMediaType( Dir, mtIn );
}

HRESULT CSampleGrabber::CheckInputType(const CMediaType* mtIn)
{
    // one of the things we DON'T accept, no matter what,
    // is inverted dibs!!
    //
    if( *mtIn->FormatType( ) == FORMAT_VideoInfo )
    {
        VIDEOINFOHEADER * pVIH = (VIDEOINFOHEADER*) mtIn->Format( );
        if( pVIH )
        {
            if( pVIH->bmiHeader.biHeight < 0 )
            {
                return E_INVALIDARG;
            }
        }
    }
    if( *mtIn->FormatType( ) == FORMAT_VideoInfo2 )
    {
        // we don't want to deal with this. Thanks anyway.
        //
        return VFW_E_INVALIDMEDIATYPE;
    }

    if( *m_mtAccept.Type( ) == GUID_NULL )
    {
        return S_OK;
    }

    if( *(mtIn->Type( )) != *m_mtAccept.Type( ) )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    if( *m_mtAccept.Subtype( ) == GUID_NULL )
    {
        return S_OK;
    }

    if( *(mtIn->Subtype( )) != *m_mtAccept.Subtype( ) )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    if( *m_mtAccept.FormatType( ) == GUID_NULL )
    {
        return S_OK;
    }

    if( *(mtIn->FormatType( )) != *m_mtAccept.FormatType( ) )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    if( *m_mtAccept.FormatType( ) == FORMAT_WaveFormatEx )
    {
        WAVEFORMATEX * pIn = (WAVEFORMATEX*) mtIn->Format( );
        WAVEFORMATEX * pAccept = (WAVEFORMATEX*) m_mtAccept.pbFormat;

        // if they both have formats
        //
        if( pAccept && pIn )
        {
            // then if we only want to look at any uncompressed, accept it now
            //
            if( pAccept->wFormatTag == WAVE_FORMAT_PCM && pAccept->nChannels == 0 )
            {
                if( pIn->wFormatTag == WAVE_FORMAT_PCM )
                {
                    return NOERROR;
                }
            }

            // otherwise, they have to match exactly
            //
            if( memcmp( pIn, pAccept, sizeof( WAVEFORMATEX ) ) != 0 )
            {
                return VFW_E_INVALIDMEDIATYPE;
            }
        }
    }

    return NOERROR;
}

STDMETHODIMP CSampleGrabber::SetMediaType( const AM_MEDIA_TYPE * pType )
{
    if( !pType )
    {
        m_mtAccept = CMediaType( );
    }
    else
    {
        return CopyMediaType( &m_mtAccept, pType );
    }
    return NOERROR;
}

STDMETHODIMP CSampleGrabber::SetOneShot( BOOL OneShot )
{
    m_bOneShot = OneShot;
    return NOERROR;
}

STDMETHODIMP CSampleGrabber::SetBufferSamples( BOOL BufferThem )
{
    m_bBufferSamples = BufferThem;
    return NOERROR;
}

STDMETHODIMP CSampleGrabber::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    HRESULT hr = CTransInPlaceFilter::GetState( dwMSecs, State );

    // if we're a one shot, tell the graph we cannot pause
    //
    if( m_bOneShot )
    {
        if( *State == State_Paused )
        {
            hr = VFW_S_CANT_CUE;
        }
    }

    return hr;
}

//
// input pin
//

CSampleGrabberInput::CSampleGrabberInput(
    TCHAR              * pObjectName,
    CSampleGrabber    * pFilter,
    HRESULT            * phr,
    LPCWSTR              pPinName) :
    CTransInPlaceInputPin(pObjectName, pFilter, phr, pPinName)
{
    m_pMyFilter=pFilter;
}


// the base classes don't allow the output to be unconnected,
// but we'll allow this.
HRESULT
CSampleGrabberInput::CheckStreaming()
{
    ASSERT( ( m_pMyFilter->OutputPin() ) != NULL);
    if (! ( (m_pMyFilter->OutputPin())->IsConnected() ) ) {
        return S_OK;
    } else {
        //  Shouldn't be able to get any data if we're not connected!
        ASSERT(IsConnected());

        //  Don't process stuff in Stopped state
        if (IsStopped()) {
            return VFW_E_WRONG_STATE;
        }
        if (m_bRunTimeError) {
            return VFW_E_RUNTIME_ERROR;
        }
        return S_OK;
    }
}

HRESULT CSampleGrabberInput::GetMediaType( int iPosition, CMediaType *pMediaType )
{
    if (iPosition < 0) {
        return E_INVALIDARG;
    }
    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    *pMediaType = m_pMyFilter->m_mtAccept;
    return S_OK;
}

CUnknown * WINAPI CNullRenderer::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CNullRenderer *pNewObject = new CNullRenderer( punk, phr );
    if (pNewObject == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }

    return pNewObject;
} // CreateInstance

CNullRenderer::CNullRenderer( LPUNKNOWN punk, HRESULT *phr )
    : CBaseRenderer( CLSID_NullRenderer, NAME("Null Renderer"), punk, phr )
{
}

STDMETHODIMP CSampleGrabber::GetCurrentSample( IMediaSample ** ppSample )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSampleGrabber::GetCurrentBuffer( long * pBufferSize, long * pBuffer )
{
    CheckPointer( pBufferSize, E_POINTER );

    // if buffering is not set, then return an error
    //
    if( !m_bBufferSamples )
    {
        return E_INVALIDARG;
    }

    if( !m_pBuffer )
    {
        return VFW_E_WRONG_STATE;
    }

    // if they wanted to know the buffer size
    //
    if( pBuffer == NULL )
    {
        *pBufferSize = m_nBufferSize;
        return NOERROR;
    }

    // if supplied buffer is too small, don't memory copy into it. 
    // this is NEW behavior, even though it's always been docced this way.
    //
    if( *pBufferSize < m_nSizeInBuffer )
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory( pBuffer, m_pBuffer, m_nSizeInBuffer );
    *pBufferSize = m_nSizeInBuffer;

    return 0;
}

STDMETHODIMP CSampleGrabber::SetCallback( ISampleGrabberCB * pCallback, long WhichMethodToCallback )
{
    if( WhichMethodToCallback < 0 || WhichMethodToCallback > 1 )
    {
        return E_INVALIDARG;
    }

    m_pCallback.Release( );
    m_pCallback = pCallback;
    m_nCallbackMethod = WhichMethodToCallback;
    return NOERROR;
}

STDMETHODIMP CSampleGrabber::GetConnectedMediaType( AM_MEDIA_TYPE * pType )
{
    if( !m_pInput || !m_pInput->IsConnected( ) )
    {
        return VFW_E_NOT_CONNECTED;
    }

    return m_pInput->ConnectionMediaType( pType );
}

HRESULT CNullRenderer::EndOfStream( )
{
    return CBaseRenderer::EndOfStream( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\msgrab\msgrab.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: msgrab.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

//extern const CLSID CLSID_SampleGrabber;
//extern const CLSID CLSID_NullRenderer;

extern const AMOVIESETUP_FILTER sudSampleGrabber;
extern const AMOVIESETUP_FILTER sudNullRenderer;

class CSampleGrabber;
class CSampleGrabberInput;

class CNullRenderer
    : public CBaseRenderer
{
public:

    static CUnknown *WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    CNullRenderer( IUnknown * pUnk, HRESULT * pHr );

    HRESULT DoRenderSample( IMediaSample * pms ) { return NOERROR; }
    HRESULT CheckMediaType( const CMediaType * pmt ) { return NOERROR; }
    HRESULT EndOfStream( );

};

//
// CSampleGrabber
//
class CSampleGrabber
    : public CTransInPlaceFilter
    , public ISampleGrabber
{
    friend class CSampleGrabberInput;

    REFERENCE_TIME m_rtMediaStop;
    CMediaType m_mt;
    BOOL m_bOneShot;
    BOOL m_bBufferSamples;
    char * m_pBuffer;
    long m_nBufferSize;
    long m_nSizeInBuffer;
    CComPtr< ISampleGrabberCB > m_pCallback;
    long m_nCallbackMethod;

protected:

    CMediaType m_mtAccept;

public:

    static CUnknown *WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    //expose ISampleGrabber
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    DECLARE_IUNKNOWN;

    // Constructor - just calls the base class constructor
    CSampleGrabber(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
    ~CSampleGrabber() ;                                            // destructor

    // Overrides the PURE virtual Transform of CTransInPlaceFilter base class
    HRESULT Transform(IMediaSample *pSample) { return NOERROR ;};
    // overrides receive function to take care ouput pin is not connected when running
    HRESULT Receive(IMediaSample *pSample);
    // don't allow cueing if we're a one-shot
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    // We accept any input type.  We'd return S_FALSE for any we didn't like.
    HRESULT CheckInputType(const CMediaType* mtIn);
    HRESULT SetMediaType( PIN_DIRECTION Dir, const CMediaType * mtIn );

    // ISampleGrabber interface
    STDMETHODIMP SetOneShot( BOOL OneShot );
    STDMETHODIMP GetConnectedMediaType( AM_MEDIA_TYPE * pType );
    STDMETHODIMP SetMediaType( const AM_MEDIA_TYPE * pType );
    STDMETHODIMP SetBufferSamples( BOOL BufferThem );
    STDMETHODIMP GetCurrentBuffer( long * pBufferSize, long * pBuffer );
    STDMETHODIMP GetCurrentSample( IMediaSample ** ppSample );
    STDMETHODIMP SetCallback( ISampleGrabberCB * pCallback, long WhichMethodToCallback );

};

// 
// CSampleGrabberInput
//
class CSampleGrabberInput 
    : public CTransInPlaceInputPin
{
    friend class CSampleGrabber;

    CSampleGrabber *m_pMyFilter;

public:
    CSampleGrabberInput::CSampleGrabberInput(
        TCHAR              * pObjectName,
        CSampleGrabber    * pFilter,
        HRESULT            * phr,
        LPCWSTR              pPinName);

    //overwrite receive to make this filter able to act like render
    HRESULT  CheckStreaming();

    // override to provide media type for fast connects
    HRESULT GetMediaType( int iPosition, CMediaType *pMediaType );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\qedit\qedit.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: qedit.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <process.h>
#undef SubclassWindow

#include <initguid.h>
#define INITGUID
#include <ddrawex.h>
#include <ddraw.h>
#include <d3drm.h>
#include <vfw.h>

#include <qeditint.h>
#include <qedit.h>

// magicly done for me #define _ATL_STATIC_REGISTRY

#include <qeditint_i.c>
#include "..\xmltl\xml2dex.h"

// for DXTWrap
#include "..\dxt\dxtwrap\dxt.h"
// for FRC
#include "..\frc\frc.h"
// for RESIZER
#include "..\resize\stretch.h"
// for BLACK
#include "..\black\black.h"
// for AudMix
#include "..\audmix\audmix.h"
#include "..\audmix\prop.h"
// for SILENCE
#include "..\silence\silence.h"
// for STILLVID
#include "..\stillvid\stillvid.h"
#include "..\stillvid\stilprop.h"
// for SQCDEST
//#include "..\sqcdest\sqcdest.h"
// for BIG SWITCH
#include "..\switch\switch.h"
// for SMART RECOMPRESSOR
#include "..\sr\sr.h"
// for AUDIO REPACKAGER
#include "..\audpack\audpack.h"
// for TIMELINE DATABASE
#include "atlbase.h"
#include "..\tldb\tldb.h"
// for RENDER ENGINE
#include "..\..\pnp\devenum\cmgrbase.cpp"
#include "..\util\filfuncs.h"
#include "..\render\irendeng.h"
// for GCACHE
#include "..\gcache\grfcache.h"
// for MEDLOC
#include "..\medloc\medialoc.h"
// for DA source
//#include "..\dasource\dasource.h"
// for Output Queue
#include "..\queue\queue.h"
// for Property Setter
#include "..\xmltl\varyprop.h"
// for MediaDet
#include "..\mediadet\mediadet.h"
// for MSGrab
#include "..\msgrab\msgrab.h"
    #include <DXTmpl.h>
    #include <dtbase.h>
// for DXT Jpeg
#include "..\dxtjpegdll\dxtjpeg.h"
#include "..\dxtjpegdll\dxtjpegpp.h"
// for Compositor
#include "..\dxt\comp\comp.h"
// for keying DXT
#include "..\dxtkey\Dxtkey.h"

HANDLE g_devenum_mutex = 0;


// individual source filter's includes
// note: some of the filters are registered as COM objects and not DSHOW filters
CFactoryTemplate g_Templates[] =
{
    {L"DirectX Transform Wrapper", &CLSID_DXTWrap, CDXTWrap::CreateInstance},
        //, NULL, &sudDXTWrap },
    {L"DirectX Transform Wrapper Property Page", &CLSID_DXTProperties, CPropPage::CreateInstance},
        // NULL, NULL},
    {L"Frame Rate Converter", &CLSID_FrmRateConverter, CFrmRateConverter::CreateInstance},
        // NULL, &sudFrmRateConv },
    {L"Frame Rate Converter Property Page", &CLSID_FRCProp, CFrcPropertyPage::CreateInstance},
        // NULL, NULL},
    {L"Stretch", &CLSID_Resize, CStretch::CreateInstance},
        // NULL, &sudStretchFilter },
    {L"Stretch Property Page", &CLSID_ResizeProp, CResizePropertyPage::CreateInstance},
        // NULL, NULL},
    {L"Big Switch", &CLSID_BigSwitch, CBigSwitch::CreateInstance},
        // NULL, &sudBigSwitch },
    {L"Smart Recompressor", &CLSID_SRFilter, CSR::CreateInstance},
        // NULL, &sudSR },
    {L"Generate Black Video", &CLSID_GenBlkVid, CGenBlkVid::CreateInstance},
        // NULL, &sudBlkVid},
    {L"Black Generator Property Page", &CLSID_GenVidPropertiesPage, CGenVidProperties::CreateInstance},
        // NULL, NULL},
    {L"Audio Mixer", &CLSID_AudMixer, CAudMixer::CreateInstance},
        // NULL, &sudAudMixer},
    { L"Audio Mixer Property", &CLSID_AudMixPropertiesPage, CAudMixProperties::CreateInstance},
        // NULL,NULL },
    { L"Pin Property", &CLSID_AudMixPinPropertiesPage, CAudMixPinProperties::CreateInstance},
        // NULL, NULL},
    {L"Silence", &CLSID_Silence, CSilenceFilter::CreateInstance},
        // NULL, &sudSilence},
    {L"Silence Generator Property Page", &CLSID_SilenceProp, CFilterPropertyPage::CreateInstance},
        // NULL, NULL},
    {L"Generate Still Video", &CLSID_GenStilVid, CGenStilVid::CreateInstance},
        // NULL, &sudStillVid},
    {L"Still Video Property Page", &CLSID_GenStilPropertiesPage, CGenStilProperties::CreateInstance},
        // NULL, NULL},
    //{L"SqcDest", &CLSID_SqcDest, CSqcDest::CreateInstance},
        // NULL, &sudSqcDest},
    {L"MS Timeline", &CLSID_AMTimeline, CAMTimeline::CreateInstance},
    {L"Audio Repackager", &CLSID_AudRepack, CAudRepack::CreateInstance},
        // NULL, &sudAudRepack},
    {L"Audio Repackager Property Page", &CLSID_AUDProp, CAudPropertyPage::CreateInstance},
        // NULL, NULL},
    //{L"DASource", &CLSID_DASourcer, CDASource::CreateInstance},
        // NULL, NULL },
    //{L"DAScriptParser", &CLSID_DAScriptParser, CDAScriptParser::CreateInstance},
        // NULL, &sudDASourceax},
    {L"Dexter Queue", &CLSID_DexterQueue, CDexterQueue::CreateInstance},
        // NULL, &sudQueue},
    {L"Property Setter", &CLSID_PropertySetter, CPropertySetter::CreateInstance, NULL, NULL},
    {L"MediaDetFilter", &CLSID_MediaDetFilter, CMediaDetFilter::CreateInstance},
        // NULL, &sudMediaDetFilter},
    {L"MediaDet", &CLSID_MediaDet, CMediaDet::CreateInstance, CMediaDet::StaticLoader, NULL},
    {L"Sample Grabber", &CLSID_SampleGrabber, CSampleGrabber::CreateInstance, NULL, &sudSampleGrabber},
    {L"Null Renderer", &CLSID_NullRenderer, CNullRenderer::CreateInstance, NULL, &sudNullRenderer}
};


int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

#include "..\dxt\dxtenum\vidfx1.h"
#include "..\dxt\dxtenum\vidfx2.h"


#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif // _ATL_STATIC_REGISTRY

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
#include <dtbase.cpp>


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_VideoEffects1Category, CVidFX1ClassManager)
  OBJECT_ENTRY(CLSID_VideoEffects2Category, CVidFX2ClassManager)
  OBJECT_ENTRY(CLSID_RenderEngine, CRenderEngine)
  OBJECT_ENTRY(CLSID_SmartRenderEngine, CSmartRenderEngine)
  OBJECT_ENTRY(CLSID_MediaLocator, CMediaLocator)
  OBJECT_ENTRY(CLSID_GrfCache, CGrfCache)
  OBJECT_ENTRY(CLSID_Xml2Dex, CXml2Dex)
  OBJECT_ENTRY(CLSID_DxtJpeg, CDxtJpeg)
  OBJECT_ENTRY(CLSID_DxtJpegPP, CDxtJpegPP)
  OBJECT_ENTRY(CLSID_DxtKey, CDxtKey)
  OBJECT_ENTRY(CLSID_DxtCompositor, CDxtCompositor)
  OBJECT_ENTRY(CLSID_DxtAlphaSetter, CDxtAlphaSetter)
END_OBJECT_MAP()

extern "C" BOOL QEditDllEntry(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);

BOOL QEditDllEntry(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
{
    BOOL f = DllEntryPoint(hInstance, ulReason, pv);

    // if loading this dll, we want to call the 2nd dll entry point
    // only if the first one succeeded. if unloading, always call
    // both. if the second one fails, undo the first one.  HAVE NOT
    // verified that failing DllEntryPoint for ATTACH does not cause
    // the loader to call in again w/ DETACH. but that seems silly
    if(f || ulReason == DLL_PROCESS_DETACH)
    {
        if (ulReason == DLL_PROCESS_ATTACH)
        {
            _ASSERTE(g_devenum_mutex == 0);
            g_devenum_mutex = CreateMutex(
                NULL,                   // no security attributes
                FALSE,                  // not initially owned
                TEXT("eed3bd3a-a1ad-4e99-987b-d7cb3fcfa7f0")); // name
            if(!g_devenum_mutex) {
                return FALSE;
            }


            _Module.Init(ObjectMap, hInstance);
            DisableThreadLibraryCalls(hInstance);

        }
        else if (ulReason == DLL_PROCESS_DETACH)
        {
            // We hit this ASSERT in NT setup
            // ASSERT(_Module.GetLockCount()==0 );
            _Module.Term();

            _ASSERTE(g_devenum_mutex != 0);
            BOOL f2 = CloseHandle(g_devenum_mutex);
            _ASSERTE(f2);
        }
    }

    return f;
}

//
// stub entry points
//

STDAPI
QEDIT_DllRegisterServer( void )
{
  // register the still video source filetypes
  HKEY hkey;
  OLECHAR wch[CHARS_IN_GUID];
  StringFromGUID2(CLSID_GenStilVid, wch, CHARS_IN_GUID);

  USES_CONVERSION;
  TCHAR *ch = W2T(wch);
  DWORD cb = CHARS_IN_GUID * sizeof(TCHAR); // incl. null

  HKEY hkExt = NULL;
  LONG l = RegCreateKeyEx(
    HKEY_CLASSES_ROOT,              // key
    TEXT("Media Type\\Extensions"), // sub key
    0,                              // reserved
    NULL,                           // lpClass
    0,                              // options
    KEY_WRITE,                      // permissions
    NULL,                           // default ACL
    &hkExt,                         // returned key
    NULL );                         // disposition

  if(l == ERROR_SUCCESS)
  {
      static TCHAR *rgszext[] = {
          TEXT(".bmp"),
          TEXT(".dib"),
          TEXT(".jpg"),
          TEXT(".jpeg"),
          TEXT(".jpe"),
          TEXT(".jfif"),
          TEXT(".gif"),
          TEXT(".tga")
      };

      for(int i = 0; i < NUMELMS(rgszext); i++)
      {
          l = RegCreateKeyEx(
              hkExt,
              rgszext[i], 
              0,
              NULL,
              0,
              KEY_WRITE,
              NULL,
              &hkey,
              NULL );
          if (l == ERROR_SUCCESS) {
              l = RegSetValueEx(hkey, TEXT("Source Filter"), 0, REG_SZ, (BYTE *)ch, cb);
              RegCloseKey(hkey);
          }

          if(l != ERROR_SUCCESS) {
              break;
          }
      }

      RegCloseKey(hkExt);
  }

  if (l != ERROR_SUCCESS) {
      ASSERT(0);
      return HRESULT_FROM_WIN32(l);
  }


  HRESULT hr =  AMovieDllRegisterServer2( TRUE );
  if(SUCCEEDED(hr)) {
      hr = _Module.RegisterServer(FALSE);
  }


  //  Register our type library
  if (SUCCEEDED(hr)) {
        // get file name (where g_hInst is the
        // instance handle of the filter dll)
        //
        WCHAR achFileName[MAX_PATH];

        // WIN95 doesn't support GetModuleFileNameW
        //
        char achTemp[MAX_PATH];

        DbgLog((LOG_TRACE, 2, TEXT("- get module file name")));

        GetModuleFileNameA( g_hInst, achTemp, sizeof(achTemp) );

        MultiByteToWideChar( CP_ACP, 0L, achTemp, -1, achFileName, MAX_PATH );
        ITypeLib *pTLB;
        hr = LoadTypeLib(achFileName, &pTLB);
        if (SUCCEEDED(hr)) {
            hr = RegisterTypeLib(pTLB, achFileName, NULL);
            pTLB->Release();
        }
  }
  return hr;
}

STDAPI
QEDIT_DllUnregisterServer( void )
{
  HRESULT hr = AMovieDllRegisterServer2( FALSE );
  if(SUCCEEDED(hr)) {
      hr = _Module.UnregisterServer();
  }

  return hr;
}

//  BOOL WINAPI
//  DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
//  {
//      return QEditDllEntry(hInstance, ulReason, pv);
//  }

STDAPI
QEDIT_DllGetClassObject(
    REFCLSID rClsID,
    REFIID riid,
    void **ppv)
{
    HRESULT hr = DllGetClassObject(rClsID, riid, ppv);
    if(FAILED(hr)) {
	hr = _Module.GetClassObject(rClsID, riid, ppv);
    }

    // not neccc. the right error if the the first call failed.
    return hr;
}

STDAPI QEDIT_DllCanUnloadNow(void)
{
    HRESULT hr = DllCanUnloadNow();
    if (hr == S_OK) {
	hr = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\qedit\stdafx.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stdafx.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\queue\queue.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: queue.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#ifndef __QUEUE__
#define __QUEUE__

extern const AMOVIESETUP_FILTER sudQueue;

class CDexterQueue;
class CDexterQueueOutputPin;
class CMyOutputQueue;

// class for the filter's Input pin

class CDexterQueueInputPin : public CBaseInputPin
{
    friend class CDexterQueueOutputPin;
    CDexterQueue *m_pQ;                  // Main filter object

public:

    // Constructor and destructor
    CDexterQueueInputPin(TCHAR *pObjName,
                 CDexterQueue *pQ,
                 HRESULT *phr,
                 LPCWSTR pPinName);

    ~CDexterQueueInputPin();

    // Used to check the input pin connection
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();
    HRESULT Active();
    HRESULT Inactive();

    // Reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);

    // Pass through calls downstream
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    int m_cBuffers;	    // number of buffers in allocator
    int m_cbBuffer;	    // size of the allocator buffers

};


// Class for the Queue filter's Output pins.

class CDexterQueueOutputPin : public CBaseOutputPin
{
    friend class CDexterQueueInputPin;
    friend class CDexterQueue;

    CDexterQueue *m_pQ;                  // Main filter object pointer
    CMyOutputQueue *m_pOutputQueue;  // Streams data to the peer pin
    IUnknown *m_pPosition;	// pass seek upstream

public:

    // Constructor and destructor

    CDexterQueueOutputPin(TCHAR *pObjName,
                   CDexterQueue *pQ,
                   HRESULT *phr,
                   LPCWSTR pPinName);

    ~CDexterQueueOutputPin();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // Override to enumerate media types
    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition,
                         CMediaType *pMediaType);

    // Negotiation to use our input pins allocator
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Used to create output queue objects
    HRESULT Active();
    HRESULT Inactive();

    // Overriden to create and destroy output pins
    HRESULT CompleteConnect(IPin *pReceivePin);

    // Overriden to pass data to the output queues
    HRESULT Deliver(IMediaSample *pMediaSample);
    HRESULT DeliverEndOfStream();
    HRESULT DeliverBeginFlush();
    HRESULT DeliverEndFlush();
    HRESULT DeliverNewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);


    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);
};


// Class for the Queue filter

class CDexterQueue: public CCritSec, public CBaseFilter,
		    public IAMOutputBuffering
{
    // Let the pins access our internal state
    friend class CDexterQueueInputPin;
    friend class CDexterQueueOutputPin;
    friend class CMyOutputQueue;

    // Declare an input pin.
    CDexterQueueInputPin m_Input;

    // And an output pin
    CDexterQueueOutputPin m_Output;

    IMemAllocator *m_pAllocator;    // Allocator from our input pin

public:

    DECLARE_IUNKNOWN

    // Reveals IAMOutputBuffering
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    CDexterQueue(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CDexterQueue();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    // Send EndOfStream if no input connection
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Pause();

    // IAMOutputBuffering
    STDMETHODIMP GetOutputBuffering(int *);
    STDMETHODIMP SetOutputBuffering(int);

protected:

    HANDLE m_hEventStall;

    Quality m_qLate;	// last Notify message received
    BOOL m_fLate;	// valid?
    int m_nOutputBuffering;

    // receive lock for the FILTER, not the pin
    CCritSec m_csReceive;
};

// overridden to get number of samples the thread has queued
//
class CMyOutputQueue: public COutputQueue
{

    friend class CDexterQueueInputPin;

public:
    CMyOutputQueue(CDexterQueue *pQ,		// owner filter
		 IPin    *pInputPin,          //  Pin to send stuff to
                 HRESULT   *phr,                //  'Return code'
                 BOOL       bAuto = TRUE,       //  Ask pin if blocks
                 BOOL       bQueue = TRUE,      //  Send through queue (ignored if
                                                //  bAuto set)
                 LONG       lBatchSize = 1,     //  Batch
                 BOOL       bBatchExact = FALSE,//  Batch exactly to BatchSize
                 LONG       lListSize =         //  Likely number in the list
                                DEFAULTCACHE,
                 DWORD      dwPriority =        //  Priority of thread to create
                                THREAD_PRIORITY_NORMAL
                );
    ~CMyOutputQueue();

    CDexterQueue *m_pQ;
    int GetThreadQueueSize();
};


#endif // __QUEUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\queue\queue.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: queue.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "queue.h"

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Video,        // Major CLSID
    &MEDIASUBTYPE_NULL       // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",             // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypes },       // Pin information
    { L"Output",            // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes },       // Pin information
};

const AMOVIESETUP_FILTER sudQueue =
{
    &CLSID_DexterQueue,       // CLSID of filter
    L"Dexter Queue",          // Filter's name
    MERIT_DO_NOT_USE,       // Filter merit
    2,                      // Number of pins
    psudPins                // Pin information
};

// Using this pointer in constructor
#pragma warning(disable:4355)

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CDexterQueue::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CDexterQueue(NAME("Dexter Queue Filter"), pUnk, phr);
}

const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

// ================================================================
// CDexterQueue Constructor
// ================================================================

CDexterQueue::CDexterQueue(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_pAllocator(NULL),
    m_Input(NAME("Input Pin"), this, phr, L"Input"),
    m_Output(NAME("Output Pin"), this, phr, L"Output"),
    CBaseFilter(NAME("Dexter Queue filter"), pUnk, this, CLSID_DexterQueue),
    m_fLate(FALSE),
    m_nOutputBuffering(DEX_DEF_OUTPUTBUF)
{
    ASSERT(phr);
}


//
// Destructor
//
CDexterQueue::~CDexterQueue()
{
}



//
// GetPinCount
//
int CDexterQueue::GetPinCount()
{
    return (2);
}


//
// GetPin
//
CBasePin *CDexterQueue::GetPin(int n)
{
    if (n < 0 || n > 1)
        return NULL ;

    // Pin zero is the one and only input pin
    if (n == 0)
        return &m_Input;
    else
        return &m_Output;
}


STDMETHODIMP CDexterQueue::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);

    if( riid == IID_IAMOutputBuffering )
    {
        return GetInterface( (IAMOutputBuffering*) this, ppv );
    }
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


//
// Pause
//
// Overriden to handle no input connections
//
STDMETHODIMP CDexterQueue::Pause()
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = CBaseFilter::Pause();

    if (m_Input.IsConnected() == FALSE) {
        m_Input.EndOfStream();
    }
    return hr;
}


//
// Run
//
// Overriden to handle no input connections
//
STDMETHODIMP CDexterQueue::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);

    HRESULT hr = CBaseFilter::Run(tStart);

    // unblock pause stall, AFTER state change has gone through
    SetEvent(m_hEventStall);

    if (m_Input.IsConnected() == FALSE) {
        m_Input.EndOfStream();
    }
    return hr;
}


HRESULT CDexterQueue::GetOutputBuffering(int *pnBuffer)
{
    CheckPointer( pnBuffer, E_POINTER );
    *pnBuffer = m_nOutputBuffering;
    return NOERROR;

}


HRESULT CDexterQueue::SetOutputBuffering(int nBuffer)
{
    // minimum 2, or switch hangs
    if (nBuffer <=1)
	return E_INVALIDARG;
    m_nOutputBuffering = nBuffer;
    return NOERROR;
}


// ================================================================
// CDexterQueueInputPin constructor
// ================================================================

CDexterQueueInputPin::CDexterQueueInputPin(TCHAR *pName,
                           CDexterQueue *pQ,
                           HRESULT *phr,
                           LPCWSTR pPinName) :
    CBaseInputPin(pName, pQ, pQ, phr, pPinName),
    m_pQ(pQ),
    m_cBuffers(0),
    m_cbBuffer(0)
{
    ASSERT(pQ);
}


//
// CDexterQueueInputPin destructor
//
CDexterQueueInputPin::~CDexterQueueInputPin()
{
    //DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CDexterQueueInputPin destructor")));
    ASSERT(m_pQ->m_pAllocator == NULL);
}



HRESULT CDexterQueueInputPin::Active()
{
    return CBaseInputPin::Active();
}


HRESULT CDexterQueueInputPin::Inactive()
{
    // make sure this receive isn't blocking
    SetEvent(m_pQ->m_hEventStall);

    // now wait for receive to complete
    CAutoLock cs(&m_pQ->m_csReceive);

    return CBaseInputPin::Inactive();
}


//
// CheckMediaType
//
HRESULT CDexterQueueInputPin::CheckMediaType(const CMediaType *pmt)
{
    //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Input::CheckMT %d bit"), HEADER(pmt->Format())->biBitCount));

    CAutoLock lock_it(m_pLock);

    HRESULT hr = NOERROR;

#ifdef DEBUG
    // Display the type of the media for debugging perposes
    //!!!DisplayMediaType(TEXT("Input Pin Checking"), pmt);
#endif

    // The media types that we can support are entirely dependent on the
    // downstream connections. If we have downstream connections, we should
    // check with them - walk through the list calling each output pin

            if (m_pQ->m_Output.m_Connected != NULL) {
                // The pin is connected, check its peer
                hr = m_pQ->m_Output.m_Connected->QueryAccept(pmt);
                if (hr != NOERROR) {
    		    //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("NOT ACCEPTED!")));
                    return VFW_E_TYPE_NOT_ACCEPTED;
		}
            }

    // Either all the downstream pins have accepted or there are none.
    //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("ACCEPTED!")));
    return NOERROR;

} // CheckMediaType


//
// BreakConnect
//
HRESULT CDexterQueueInputPin::BreakConnect()
{
    //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Input::BreakConnect")));

    // Release any allocator that we are holding
    if (m_pQ->m_pAllocator)
    {
        m_pQ->m_pAllocator->Release();
        m_pQ->m_pAllocator = NULL;
    }
    return NOERROR;

} // BreakConnect


//
// NotifyAllocator
//
STDMETHODIMP
CDexterQueueInputPin::NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly)
{
    CAutoLock lock_it(m_pLock);
    if (pAllocator == NULL)
        return E_FAIL;

    // Free the old allocator if any
    if (m_pQ->m_pAllocator)
        m_pQ->m_pAllocator->Release();

    // Store away the new allocator
    pAllocator->AddRef();
    m_pQ->m_pAllocator = pAllocator;

    ALLOCATOR_PROPERTIES prop;
    HRESULT hr = m_pQ->m_pAllocator->GetProperties(&prop);
    if (SUCCEEDED(hr)) {
        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Allocator is using %d buffers, size %d"),
						prop.cBuffers, prop.cbBuffer));
	m_cBuffers = prop.cBuffers;
	m_cbBuffer = prop.cbBuffer;
    }

    // Notify the base class about the allocator
    return CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly);

} // NotifyAllocator


//
// EndOfStream
//
HRESULT CDexterQueueInputPin::EndOfStream()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Queue::EndOfStream")));

    // send the message downstream

    hr = m_pQ->m_Output.DeliverEndOfStream();
    if (FAILED(hr))
        return hr;

    return(NOERROR);

} // EndOfStream


//
// BeginFlush
//
HRESULT CDexterQueueInputPin::BeginFlush()
{
    CAutoLock lock_it(m_pLock);

    // FIRST, make sure future receives will fail
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Queue::BeginFlush flushing...")));
    HRESULT hr = CBaseInputPin::BeginFlush();

    // NEXT, make sure this receive isn't blocking
    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Queue::BeginFlush setting EVENT...")));
    SetEvent(m_pQ->m_hEventStall);

    // Walk through the output pins list, sending the message downstream
    hr = m_pQ->m_Output.DeliverBeginFlush();

    // wait for receive to complete? CAutoLock cs(&m_pQ->m_csReceive);

    return hr;
} // BeginFlush


//
// EndFlush
//
HRESULT CDexterQueueInputPin::EndFlush()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // send the message downstream

    hr = m_pQ->m_Output.DeliverEndFlush();
    if (FAILED(hr))
        return hr;

    return CBaseInputPin::EndFlush();

} // EndFlush

//
// NewSegment
//

HRESULT CDexterQueueInputPin::NewSegment(REFERENCE_TIME tStart,
                                 REFERENCE_TIME tStop,
                                 double dRate)
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // send the message downstream

    hr = m_pQ->m_Output.DeliverNewSegment(tStart, tStop, dRate);
    if (FAILED(hr))
        return hr;

    return CBaseInputPin::NewSegment(tStart, tStop, dRate);

} // NewSegment


//
// Receive
//
HRESULT CDexterQueueInputPin::Receive(IMediaSample *pSample)
{
    CAutoLock cs(&m_pQ->m_csReceive);

    // Check that all is well with the base class
    HRESULT hr = NOERROR;
    hr = CBaseInputPin::Receive(pSample);
    if (hr != NOERROR) {
        //DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Base class ERROR!")));
        return hr;
    }

    // if no Q, no receivey
    //
    if( !m_pQ->m_Output.m_pOutputQueue )
    {
        return S_FALSE;
    }

    //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Queue::Receive")));

    int size = m_pQ->m_Output.m_pOutputQueue->GetThreadQueueSize();
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Queue::Receive, %d already on q"), size));

    // Our queue will block in pause mode if the filter we delivered to
    // has blocked.  As long as the downstream guy is satisfied that it
    // has enough pre-roll, why should we waste time queuing up samples that
    // just might get thrown away if we seek before running?
    //
    // Doing this GREATLY IMPROVES performance of seeking; otherwise we read
    // and decode and process 20 frames every seek!

    // We'll actually even hang the big switch if we don't do this!  If during
    // a seek, this queue is allowed to fill up, that makes all of the buffers
    // in the switch's pool allocator (common to all input pins) busy.
    // Well, the switch's GetBuffer will then block waiting for a buffer, and
    // flushing won't be able to unblock the pin's receive thread (since it's
    // getting buffers from an allocator that doesn't belong to it).
    //

    while (m_pQ->m_State == State_Paused && size > 0) {
        DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Queue::Receive blocking...")));
	WaitForSingleObject(m_pQ->m_hEventStall, INFINITE);
        size = m_pQ->m_Output.m_pOutputQueue->GetThreadQueueSize();
	if (m_bFlushing)
	    break;
    }
    //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Queue::Receive good to go...")));

    hr = m_pQ->m_Output.Deliver(pSample);

    // We have received a quality message we need to pass upstream.  We need
    // to do this on the thread that the switch delivered to us, not on the
    // queue's thread that got the quality message, or the switch will hang.
    if (m_pQ->m_fLate)
	PassNotify(m_pQ->m_qLate);
    m_pQ->m_fLate = FALSE;

    // This will prevent us from receiving any more data!
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("ERROR: failing Receive")));
        return hr;
    }
    return NOERROR;

} // Receive


//
// Completed a connection to a pin
//
HRESULT CDexterQueueInputPin::CompleteConnect(IPin *pReceivePin)
{
    //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Input::CompleteConnect %d bit"), HEADER(m_mt.Format())->biBitCount));

    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
        return hr;
    }

    // Force any output pins to use our type

    // Check with downstream pin
    if (m_pQ->m_Output.m_Connected != NULL) {
        if (m_mt != m_pQ->m_Output.m_mt) {
    	    //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("IN Connected: RECONNECT OUT")));
            m_pQ->ReconnectPin(&m_pQ->m_Output, &m_mt);
	}
    }
    return S_OK;
}


// ================================================================
// CDexterQueueOutputPin constructor
// ================================================================

CDexterQueueOutputPin::CDexterQueueOutputPin(TCHAR *pName,
                             CDexterQueue *pQ,
                             HRESULT *phr,
                             LPCWSTR pPinName) :
    CBaseOutputPin(pName, pQ, pQ, phr, pPinName) ,
    m_pOutputQueue(NULL),
    m_pQ(pQ),
    m_pPosition(NULL)
{
    ASSERT(pQ);
}



//
// CDexterQueueOutputPin destructor
//
CDexterQueueOutputPin::~CDexterQueueOutputPin()
{
    ASSERT(m_pOutputQueue == NULL);
    if (m_pPosition) m_pPosition->Release();
}



STDMETHODIMP
CDexterQueueOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IMediaSeeking) {

        if (m_pPosition == NULL) {

            HRESULT hr = CreatePosPassThru(
                             GetOwner(),
                             FALSE,
                             (IPin *)&m_pQ->m_Input,
                             &m_pPosition);
            if (FAILED(hr)) {
                return hr;
            }
        }
        return m_pPosition->QueryInterface(riid, ppv);
    } else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


//
// DecideBufferSize
//
// This has to be present to override the PURE virtual class base function
//
HRESULT CDexterQueueOutputPin::DecideBufferSize(IMemAllocator *pMemAllocator,
                                        ALLOCATOR_PROPERTIES * ppropInputRequest)
{
    return NOERROR;

} // DecideBufferSize


//
// DecideAllocator
//
HRESULT CDexterQueueOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    ASSERT(m_pQ->m_pAllocator != NULL);
    *ppAlloc = NULL;

    HRESULT hr = NOERROR;
    hr = pPin->NotifyAllocator(m_pQ->m_pAllocator, m_pQ->m_Input.m_bReadOnly);
    if (FAILED(hr))
        return hr;

    // Return the allocator
    *ppAlloc = m_pQ->m_pAllocator;
    m_pQ->m_pAllocator->AddRef();
    return NOERROR;

} // DecideAllocator


//
// CheckMediaType
//
HRESULT CDexterQueueOutputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);
    //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("TTOut: CheckMT %d bit"), HEADER(pmt->Format())->biBitCount));

    HRESULT hr = NOERROR;

#ifdef DEBUG
    // Display the type of the media for debugging purposes
    //!!!DisplayMediaType(TEXT("Output Pin Checking"), pmt);
#endif

    // The input needs to have been connected first
    if (m_pQ->m_Input.m_Connected == NULL) {
        //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("FAIL: In not connected")));
        return VFW_E_NOT_CONNECTED;
    }

    // If it doesn't match our input type, the input better be willing to
    // reconnect, and the other output better be too
    if (*pmt != m_pQ->m_Input.m_mt) {
        //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Hmmm.. not same as input type")));
	CDexterQueueOutputPin *pOut = &m_pQ->m_Output;
	IPin *pCon = pOut->m_Connected;
	if (pOut != this && pCon) {
	    if (pCon->QueryAccept(pmt) != S_OK) {
        	//DbgLog((LOG_TRACE, TRACE_LOW,TEXT("FAIL:Other out can't accept")));
		return VFW_E_TYPE_NOT_ACCEPTED;
	    }
	}
	hr = m_pQ->m_Input.m_Connected->QueryAccept(pmt);
	if (hr != S_OK) {
            //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("FAIL: In can't reconnect")));
            return VFW_E_TYPE_NOT_ACCEPTED;
	}
    }

    return NOERROR;

} // CheckMediaType


//
// EnumMediaTypes
//
STDMETHODIMP CDexterQueueOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(ppEnum);

    // Make sure that we are connected
    if (m_pQ->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    return CBaseOutputPin::EnumMediaTypes (ppEnum);
} // EnumMediaTypes

//
// GetMediaType
//
HRESULT CDexterQueueOutputPin::GetMediaType(
    int iPosition,
    CMediaType *pMediaType
    )
{
    // Make sure that we have an input connected
    if (m_pQ->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    IEnumMediaTypes *pEnum;
    HRESULT hr;

    // the first thing we offer is the current type other pins are connected
    // with... because if one output pin is connected to a filter whose input
    // pin offers media types, the current connected type might not be in
    // the list we're about to enumerate!
    if (iPosition == 0) {
	*pMediaType = m_pQ->m_Input.m_mt;
	return S_OK;
    }

    // offer all the types the filter upstream of us can offer, because we
    // may be able to reconnect and end up using any of them.
    AM_MEDIA_TYPE *pmt;
    hr = m_pQ->m_Input.m_Connected->EnumMediaTypes(&pEnum);
    if (hr == NOERROR) {
        ULONG u;
	if (iPosition > 1)
            pEnum->Skip(iPosition - 1);
        hr = pEnum->Next(1, &pmt, &u);
        pEnum->Release();
	if (hr == S_OK) {
	    *pMediaType = *pmt;
	    DeleteMediaType(pmt);
	    return S_OK;
	} else {
	    return VFW_S_NO_MORE_ITEMS;
	}
    } else {
        return E_FAIL;
    }

} // GetMediaType

//
// SetMediaType
//
HRESULT CDexterQueueOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Display the format of the media for debugging purposes
    // !!! DisplayMediaType(TEXT("Output pin type agreed"), pmt);
#endif

    // Make sure that we have an input connected
    if (m_pQ->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    // Make sure that the base class likes it
    HRESULT hr = NOERROR;
    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    return NOERROR;

} // SetMediaType


//
// CompleteConnect
//
HRESULT CDexterQueueOutputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = NOERROR;

    //DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Output::CompleteConnect %d bit"), HEADER(m_mt.Format())->biBitCount));

    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
        return hr;

    // If the type is not the same as that stored for the input
    // pin then force the input pins peer to be reconnected

    if (m_mt != m_pQ->m_Input.m_mt)
    {
    	//DbgLog((LOG_TRACE, TRACE_LOW,TEXT("OUT Connected: RECONNECT IN")));
        hr = m_pQ->ReconnectPin(m_pQ->m_Input.m_Connected, &m_mt);
        if(FAILED(hr)) {
            return hr;
        }
    }

    return NOERROR;

} // CompleteConnect


//
// Active
//
// This is called when we transition from stop to paused. We create the
// output queue object to send data to our associated peer pin
//
HRESULT CDexterQueueOutputPin::Active()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the pin is connected
    if (m_Connected == NULL)
        return NOERROR;

    // Create the output queue if we have to
    if (m_pOutputQueue == NULL)
    {
        m_pQ->m_hEventStall = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_pQ->m_hEventStall == NULL)
	    return E_OUTOFMEMORY;

 	// ALWAYS use a separate thread... with as many buffers as we've been
	// told to use
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Making a Q %d big"),
					m_pQ->m_nOutputBuffering));
        m_pOutputQueue = new CMyOutputQueue(m_pQ, m_Connected, &hr, FALSE,
				TRUE, 1, FALSE, m_pQ->m_nOutputBuffering,
				THREAD_PRIORITY_NORMAL);
        if (m_pOutputQueue == NULL)
            return E_OUTOFMEMORY;

        // Make sure that the constructor did not return any error
        if (FAILED(hr))
        {
            delete m_pOutputQueue;
            m_pOutputQueue = NULL;
            return hr;
        }

	m_pOutputQueue->SetPopEvent(m_pQ->m_hEventStall);
    }

    // Pass the call on to the base class
    CBaseOutputPin::Active();
    return NOERROR;

} // Active


//
// Inactive
//
// This is called when we stop streaming
// We delete the output queue at this time
//
HRESULT CDexterQueueOutputPin::Inactive()
{
    CAutoLock lock_it(m_pLock);

    // make sure we sync with receive, or it may hammer on the output Q.
    //
    CAutoLock cs(&m_pQ->m_csReceive);

    // Delete the output queue associated with the pin.  This will close the
    // handle
    if (m_pOutputQueue)
    {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }

    // now close the handle after the queue has gone away
    if (m_pQ->m_hEventStall)
    {
	CloseHandle(m_pQ->m_hEventStall);
        m_pQ->m_hEventStall = NULL;
    }

    CBaseOutputPin::Inactive();
    return NOERROR;

} // Inactive


//
// Deliver
//
HRESULT CDexterQueueOutputPin::Deliver(IMediaSample *pMediaSample)
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    pMediaSample->AddRef();
    //DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Putting on capture Q")));
    return m_pOutputQueue->Receive(pMediaSample);
} // Deliver


//
// DeliverEndOfStream
//
HRESULT CDexterQueueOutputPin::DeliverEndOfStream()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    DbgLog((LOG_TRACE, TRACE_LOW,TEXT("Queue::DeliverEndOfStream")));

    m_pOutputQueue->EOS();
    return NOERROR;

} // DeliverEndOfStream


//
// DeliverBeginFlush
//
HRESULT CDexterQueueOutputPin::DeliverBeginFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->BeginFlush();
    return NOERROR;

} // DeliverBeginFlush


//
// DeliverEndFlush
//
HRESULT CDexterQueueOutputPin::DeliverEndFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->EndFlush();
    return NOERROR;

} // DeliverEndFlish

//
// DeliverNewSegment
//
HRESULT CDexterQueueOutputPin::DeliverNewSegment(REFERENCE_TIME tStart,
                                         REFERENCE_TIME tStop,
                                         double dRate)
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->NewSegment(tStart, tStop, dRate);
    return NOERROR;

} // DeliverNewSegment


//
// Notify - pass it upstream
//
STDMETHODIMP CDexterQueueOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    m_pQ->m_qLate = q;
    m_pQ->m_fLate = TRUE;
    return E_FAIL;	// renderer, keep trying yourself
}




CMyOutputQueue::CMyOutputQueue(CDexterQueue *pQ, IPin *pInputPin, HRESULT *phr,
                 		BOOL bAuto, BOOL bQueue, LONG lBatchSize,
                 		BOOL bBatchExact, LONG lListSize,
                 		DWORD dwPriority) :
    COutputQueue(pInputPin, phr, bAuto, bQueue, lBatchSize, bBatchExact,
			lListSize, dwPriority)
{
    m_pQ = pQ;
}


CMyOutputQueue::~CMyOutputQueue()
{
}


// how many samples are queued but not sent?
int CMyOutputQueue::GetThreadQueueSize()
{
    if (m_List)
        return m_List->GetCount();
    else
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\deadpool.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: deadpool.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h> 
#include "stdafx.h"
#include "deadpool.h"
#include "..\util\filfuncs.h"

const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

//############################################################################
// 
//############################################################################

CDeadGraph::CDeadGraph( )
{
    Clear( );
    m_hrGraphCreate = CoCreateInstance( CLSID_FilterGraphNoThread,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IGraphBuilder,
        (void**) &m_pGraph );
}

//############################################################################
// 
//############################################################################

CDeadGraph::~CDeadGraph( )
{
}

//############################################################################
// 
//############################################################################

// the chain must be disconnected at both ends and be linear
// puts a chain of filters into this dead graph.  If it's already in the dead graph, it merely sets
// its ID to the given ID
//
HRESULT CDeadGraph::PutChainToRest( long ID, IPin * pStartPin, IPin * pStopPin, IBaseFilter *pDanglyBit )
{
    CAutoLock Lock( &m_Lock );

    DbgLog((LOG_TRACE,TRACE_HIGHEST, "deadgraph: PutChainToRest, chain = %ld", ID ));

#ifdef DEBUG
    long ttt1 = timeGetTime( );
#endif

    if( FAILED( m_hrGraphCreate ) )
    {
        return m_hrGraphCreate;
    }

    // one of the pins has to exist, at least
    if( !pStartPin && !pStopPin )
    {
        return E_INVALIDARG;
    }

    // no passing 0 as the ID
    if( ID == 0 )
    {
        return E_INVALIDARG;
    }

    // not too many in our list. what's a good number?
    if( m_nCount == MAX_DEAD )
    {
        return E_OUTOFMEMORY;
    }

    CComPtr< IPin > pConnected;
    IPin * pChainPin = NULL;

    // make sure it's not connected
    if( pStartPin )
    {
        pChainPin = pStartPin;

        pStartPin->ConnectedTo( &pConnected );

        if( pConnected )
        {
            return E_INVALIDARG;
        }
    } // if pStartPin

    // make sure it's not connected
    if( pStopPin )
    {
        pChainPin = pStopPin;

        pStopPin->ConnectedTo( &pConnected );

        if( pConnected )
        {
            return E_INVALIDARG;
        }
    } // if pStopPin

    // if the filters are connected, then they have to be in a graph.
    IFilterGraph * pCurrentGraph = GetFilterGraphFromPin( pChainPin );
    ASSERT( pCurrentGraph );
    if( !pCurrentGraph )
    {
        return E_INVALIDARG;
    }

    // see if our graph supports IGraphConfig, if it doesn't, we cannot do this
    // function
    CComQIPtr< IGraphConfig, &IID_IGraphConfig > pConfig( pCurrentGraph );
    ASSERT( pConfig );
    if( !pConfig )
    {
        return E_UNEXPECTED; // DEX_IDS_INSTALL_PROBLEM;
    }

    // put it in our list
    m_pStartPin[m_nCount] = pStartPin;
    m_pStopPin[m_nCount] = pStopPin;
    m_pFilter[m_nCount] = NULL;
    m_ID[m_nCount] = ID;
    m_pDanglyBit[m_nCount] = pDanglyBit;
    m_nCount++;

    // if the graphs are the same, don't do anything!
    if( pCurrentGraph == m_pGraph )
    {
        return NOERROR;
    }

    // tell each filter in the current graph that it's DEAD.
    HRESULT hr = 0;
    CComPtr< IBaseFilter > pStartFilter = pStartPin ? GetFilterFromPin( pStartPin ) : 
        GetStartFilterOfChain( pChainPin );

    hr = _RetireAllDownstream(pConfig, pStartFilter);
    
#ifdef DEBUG
    ttt1 = timeGetTime( ) - ttt1;
    DbgLog((LOG_TIMING,TRACE_HIGHEST, "deadgraph: PutChainToRest took %ld ms", ttt1 ));
#endif

    return hr;
}


HRESULT CDeadGraph::_RetireAllDownstream(IGraphConfig *pConfig, IBaseFilter *pStartFilter)
{
    CheckPointer(pConfig, E_POINTER);
    CheckPointer(pStartFilter, E_POINTER);

    HRESULT hr = S_OK;

    CComPtr< IEnumPins > pEnum;
    hr = pStartFilter->EnumPins(&pEnum);

    // recursively retire everything downstream of us
    while (hr == S_OK) {
        CComPtr <IPin> pPinOut;
        ULONG Fetched = 0;
        pEnum->Next(1, &pPinOut, &Fetched);
        if (!pPinOut) {
            break;
        }
        PIN_INFO pi;
        pPinOut->QueryPinInfo(&pi);
        if (pi.pFilter) 
            pi.pFilter->Release();
	if (pi.dir != PINDIR_OUTPUT)
	    continue;
        CComPtr <IPin> pPinIn;
        pPinOut->ConnectedTo(&pPinIn);
	if (pPinIn) {
            IBaseFilter *pF = GetFilterFromPin(pPinIn);
            if (pF)
	        hr = _RetireAllDownstream(pConfig, pF);
	}
    }

    // then retire ourself
    if (hr == S_OK) {
        FILTER_INFO fi;
        ZeroMemory( &fi, sizeof( fi ) );
        pStartFilter->QueryFilterInfo( &fi );
        if( fi.pGraph ) fi.pGraph->Release( );
        hr = pConfig->RemoveFilterEx( pStartFilter, REMFILTERF_LEAVECONNECTED );
        ASSERT( !FAILED( hr ) );
        // !!! what do we do if it bombed? Danny?
        hr = m_pGraph->AddFilter( pStartFilter, fi.achName );
        ASSERT( !FAILED( hr ) );
        if (FAILED(hr)) {
            m_nCount--;
            return hr;
        }
    }
    return hr;
}


//############################################################################
// 
//############################################################################

HRESULT CDeadGraph::PutFilterToRestNoDis( long ID, IBaseFilter * pFilter )
{
    CAutoLock Lock( &m_Lock );

    DbgLog((LOG_TRACE,TRACE_HIGHEST, "deadgraph: PutFilterToRestNoDis, ID = %ld", ID ));

    HRESULT hr = 0;

#ifdef DEBUG
    long ttt1 = timeGetTime( );
#endif

    if( FAILED( m_hrGraphCreate ) )
    {
        return m_hrGraphCreate;
    }

    if( !pFilter )
    {
        return E_INVALIDARG;
    }

    // no passing 0 as the ID
    if( ID == 0 )
    {
        return E_INVALIDARG;
    }

    // not too many in our list. what's a good number?
    if( m_nCount == MAX_DEAD )
    {
        return E_OUTOFMEMORY;
    }

    // by this time, all filters connected to pFilter had
    // better had SetSyncSource( NULL ) called on them,
    // because any filter that has a sync source upon it
    // will inadvertently call UpstreamReorder on the filter 
    // graph and find out that some filters in the chain
    // aren't connected in the same graph, and will bomb.

    // put just the filter passed in into our list of
    // cached filters, but pull across every connected
    // filter into the dead graph as well
    hr = _SleepFilter( pFilter );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // put it in our list
    m_pFilter[m_nCount] = pFilter;
    m_pStartPin[m_nCount] = NULL;
    m_pStopPin[m_nCount] = NULL;
    m_ID[m_nCount] = ID;
    m_nCount++;


#ifdef DEBUG
    ttt1 = timeGetTime( ) - ttt1;
    DbgLog((LOG_TIMING,TRACE_HIGHEST, "deadgraph: PutFilterToRest took %ld ms", ttt1 ));
#endif

    return hr;
}

//############################################################################
// 
//############################################################################

HRESULT CDeadGraph::PutFilterToRest( long ID, IBaseFilter * pFilter )
{
    CAutoLock Lock( &m_Lock );

    DbgLog((LOG_TRACE,TRACE_HIGHEST, "deadgraph: PutFilterToRest, ID = %ld", ID ));

#ifdef DEBUG
    long ttt1 = timeGetTime( );
#endif

    if( FAILED( m_hrGraphCreate ) )
    {
        return m_hrGraphCreate;
    }

    if( !pFilter )
    {
        return E_INVALIDARG;
    }

    // no passing 0 as the ID
    if( ID == 0 )
    {
        return E_INVALIDARG;
    }

    // not too many in our list. what's a good number?
    if( m_nCount == MAX_DEAD )
    {
        return E_OUTOFMEMORY;
    }

    FILTER_INFO fi;
    ZeroMemory( &fi, sizeof( fi ) );
    pFilter->QueryFilterInfo( &fi );

    IFilterGraph * pCurrentGraph = fi.pGraph;
    if( !pCurrentGraph )
    {
        return E_INVALIDARG;
    }
    pCurrentGraph->Release( );

    // put it in our list
    m_pFilter[m_nCount] = pFilter;
    m_pStartPin[m_nCount] = NULL;
    m_pStopPin[m_nCount] = NULL;
    m_ID[m_nCount] = ID;
    m_nCount++;

    // if the graphs are the same, don't do anything!
    if( pCurrentGraph == m_pGraph )
    {
        return NOERROR;
    }

    HRESULT hr = 0;

    pFilter->AddRef( );

    hr = pCurrentGraph->RemoveFilter( pFilter );
    ASSERT( !FAILED( hr ) );
    // !!! what do we do if it bombed? Danny?
    hr = m_pGraph->AddFilter( pFilter, fi.achName );

    pFilter->Release( );

    ASSERT( !FAILED( hr ) );
    if (FAILED(hr)) 
    {
        m_nCount--;
        return hr;
    }

#ifdef DEBUG
    ttt1 = timeGetTime( ) - ttt1;
    DbgLog((LOG_TIMING,TRACE_HIGHEST, "deadgraph: PutFilterToRest took %ld ms", ttt1 ));
#endif

    return hr;
}

//############################################################################
// 
//############################################################################

HRESULT CDeadGraph::ReviveChainToGraph( IGraphBuilder * pGraph, long ID, IPin ** ppStartPin, IPin ** ppStopPin, IBaseFilter **ppDanglyBit )
{
    CAutoLock Lock( &m_Lock );

    if (ppDanglyBit)
	*ppDanglyBit = NULL;

    DbgLog((LOG_TRACE,TRACE_HIGHEST, "deadgraph: ReviveChainToGraph, ID = %ld", ID ));

#ifdef DEBUG
    long ttt1 = timeGetTime( );
#endif

    if( FAILED( m_hrGraphCreate ) )
    {
        return m_hrGraphCreate;
    }

    // no passing 0 as the ID
    if( ID == 0 )
    {
        return E_INVALIDARG;
    }

    CComQIPtr< IGraphConfig, &IID_IGraphConfig > pConfig( m_pGraph );
    ASSERT( pConfig );
    if( !pConfig )
    {
        return E_UNEXPECTED;    // DEX_IDS_INSTALL_PROBLEM;
    }

    // linear search, how long does this take?
    for( int i = 0 ; i < m_nCount ; i++ )
    {
        if( ID == m_ID[i] )
        {
            break;
        }
    }

    // didn't find it
    //
    if( i >= m_nCount )
    {
        DbgLog((LOG_TRACE,TRACE_HIGHEST, "deadgraph: not found" ));
        return E_FAIL;
    }

    IPin * pChainPin = m_pStopPin[i];
    if( !pChainPin )
    {
        pChainPin = m_pStartPin[i];
    }

    HRESULT hr = 0;
    CComPtr< IBaseFilter > pStartFilter = m_pStartPin[i] ? 
        GetFilterFromPin( m_pStartPin[i] ) :
        GetStartFilterOfChain( pChainPin );

    hr = _ReviveAllDownstream(pGraph, pConfig, pStartFilter);

    if( ppStartPin )
    {
        *ppStartPin = m_pStartPin[i];
        (*ppStartPin)->AddRef( );
    }
    if( ppStopPin )
    {
        *ppStopPin = m_pStopPin[i];
        (*ppStopPin)->AddRef( );
    }

    // figure out if we're reviving not just this chain, but a dangly bit too,
    // off another parser pin not connected with this chain
    if (ppDanglyBit && m_pStopPin[i] && !m_pStartPin[i]) {
	// walk upstream until we find a filter with >1 output pin
	IPin *pOut = m_pStopPin[i];
	while (1) {
	    IPin *pIn;
	    IBaseFilter *pF = GetFilterFromPin(pOut);
	    ASSERT(pF);
	    if (!pF) break;

	    // this filter has >1 output pin.  It's the splitter. We can now
	    // find out if there's an extra appendage off of it
	    IPin *pTest = GetOutPin(pF, 1);
	    if (pTest) {
		// find a connected pin that isn't pOut, and you've found it
		int z = 0;
		while (1) {
		    pTest = GetOutPin(pF, z);
		    if (!pTest) break;
		    pIn = NULL;
		    pTest->ConnectedTo(&pIn);
		    if (pIn) {
			pIn->Release();
			if (pOut != pTest) {
			    *ppDanglyBit = GetFilterFromPin(pIn);
			    break;
			}
		    }
		    z++;
		}
	    }
	    if (*ppDanglyBit) break;
	    pIn = GetInPin(pF, 0);
	    if (!pIn) break;	// all done, no extra appendage
	    pIn->ConnectedTo(&pOut);	// addrefs
	    ASSERT(pOut);
            if (!pOut) break;
	    pOut->Release();
	}
    }

    m_pStopPin[i] = 0;
    m_pStartPin[i] = 0;

#ifdef DEBUG
    ttt1 = timeGetTime( ) - ttt1;
    DbgLog((LOG_TIMING,TRACE_HIGHEST, "deadgraph: ReviveChain took %ld ms", ttt1 ));
#endif

    return NOERROR;
}


HRESULT CDeadGraph::_ReviveAllDownstream(IGraphBuilder *pGraph, IGraphConfig * pConfig, IBaseFilter *pStartFilter)
{
    CheckPointer(pGraph, E_POINTER);
    CheckPointer(pConfig, E_POINTER);
    CheckPointer(pStartFilter, E_POINTER);

    HRESULT hr = S_OK;

    CComPtr< IEnumPins > pEnum;
    hr = pStartFilter->EnumPins(&pEnum);

    // recursively revive everything downstream of us
    while (hr == S_OK) {
        CComPtr <IPin> pPinOut;
        ULONG Fetched = 0;
        pEnum->Next(1, &pPinOut, &Fetched);
        if (!pPinOut) {
            break;
        }
        PIN_INFO pi;
        pPinOut->QueryPinInfo(&pi);
        if (pi.pFilter) 
            pi.pFilter->Release();
	if (pi.dir != PINDIR_OUTPUT)
	    continue;
        CComPtr <IPin> pPinIn;
        pPinOut->ConnectedTo(&pPinIn);
	if (pPinIn) {
            IBaseFilter *pF = GetFilterFromPin(pPinIn);
            if (pF)
	        hr = _ReviveAllDownstream(pGraph, pConfig, pF);
	}
    }

    // then revive ourself
    if (hr == S_OK) {
        FILTER_INFO fi;
        ZeroMemory( &fi, sizeof( fi ) );
        pStartFilter->QueryFilterInfo( &fi );
        if( fi.pGraph ) fi.pGraph->Release( );
        hr = pConfig->RemoveFilterEx( pStartFilter, REMFILTERF_LEAVECONNECTED );
        ASSERT( !FAILED( hr ) );
        // what do we do if it bombed? Danny?
        hr = pGraph->AddFilter( pStartFilter, fi.achName );
        ASSERT( !FAILED( hr ) );
        if (FAILED(hr)) {

            //m_pStopPin[i] = 0;
            //m_pStartPin[i] = 0;

            // this could get scary if it bombs halfway through the chain... djm
            return hr;
        }
        // what do we do if it bombed? Danny?
        pStartFilter = GetNextDownstreamFilter( pStartFilter );
    }
    return S_OK;
}


//############################################################################
// 
//############################################################################

HRESULT CDeadGraph::ReviveFilterToGraph( IGraphBuilder * pGraph, long ID, IBaseFilter ** ppFilter )
{
    CAutoLock Lock( &m_Lock );

    DbgLog((LOG_TRACE,TRACE_HIGHEST, "deadgraph: ReviveFilterToGraph, ID = %ld", ID ));

    HRESULT hr = 0;

    CheckPointer( ppFilter, E_POINTER );

#ifdef DEBUG
    long ttt1 = timeGetTime( );
#endif

    if( FAILED( m_hrGraphCreate ) )
    {
        return m_hrGraphCreate;
    }

    // no passing 0 as the ID
    if( ID == 0 )
    {
        return E_INVALIDARG;
    }

    // !!! linear search, how long does this take?
    for( int i = 0 ; i < m_nCount ; i++ )
    {
        if( ID == m_ID[i] )
        {
            break;
        }
    }

    // didn't find it
    //
    if( i >= m_nCount )
    {
        DbgLog((LOG_TRACE,TRACE_HIGHEST, "deadgraph: not found" ) );
        return E_FAIL;
    }

    IBaseFilter * pFilter = m_pFilter[i];

    hr = _ReviveFilter( pFilter, pGraph );
    ASSERT( !FAILED( hr ) );

    *ppFilter = pFilter;
    (*ppFilter)->AddRef( );

    m_pFilter[i] = 0;
    m_pStopPin[i] = 0;
    m_pStartPin[i] = 0;

#ifdef DEBUG
    ttt1 = timeGetTime( ) - ttt1;
    DbgLog((LOG_TIMING,TRACE_HIGHEST, "deadgraph: ReviveFilter took %ld ms", ttt1 ));
#endif

    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CDeadGraph::Clear( )
{
    CAutoLock Lock( &m_Lock );

#ifdef DEBUG
    long ttt1 = timeGetTime( );
#endif

    WipeOutGraph( m_pGraph );
    for( int i = 0 ; i < MAX_DEAD ; i++ )
    {
        m_ID[i] = 0;
        m_pStartPin[i] = NULL;
        m_pStopPin[i] = NULL;
        m_pFilter[i] = NULL;
    }
    m_nCount = 0;

#ifdef DEBUG
    ttt1 = timeGetTime( ) - ttt1;
    DbgLog((LOG_TIMING,TRACE_HIGHEST, "deadgraph: Clear took %ld ms", ttt1 ));
#endif

    return 0;
}

//############################################################################
// 
//############################################################################

HRESULT CDeadGraph::GetGraph( IGraphBuilder ** ppGraph )
{
    CAutoLock Lock( &m_Lock );

    CheckPointer( ppGraph, E_POINTER );
    *ppGraph = m_pGraph;
    if( m_pGraph )
    {
        (*ppGraph)->AddRef( );
        return NOERROR;
    }
    else
    {
        return E_FAIL;
    }
}

//############################################################################
// 
//############################################################################

HRESULT CDeadGraph::QueryInterface(REFIID riid, void ** ppv)
{
    if( riid == IID_IDeadGraph || riid == IID_IUnknown ) 
    {
        *ppv = (void *) static_cast< IDeadGraph *> ( this );
        return NOERROR;
    }    
    return E_NOINTERFACE;
}

//############################################################################
// 
//############################################################################

HRESULT CDeadGraph::_SleepFilter( IBaseFilter * pFilter )
{
    HRESULT hr = 0;

    FILTER_INFO fi;
    ZeroMemory( &fi, sizeof( fi ) );
    pFilter->QueryFilterInfo( &fi );
    if( fi.pGraph ) fi.pGraph->Release( );

    // if the graphs are the same, then don't do anything
    if( fi.pGraph == m_pGraph ) return NOERROR;

#ifdef DEBUG
    USES_CONVERSION;
    TCHAR * t = W2T( fi.achName );
    DbgLog((LOG_TRACE,TRACE_HIGHEST, "deadgraph: SleepFilter %s", t ));
#endif

    pFilter->AddRef( );

    // remove it from here...
    CComQIPtr< IGraphConfig, &IID_IGraphConfig > pConfig( fi.pGraph );
    hr = pConfig->RemoveFilterEx( pFilter, REMFILTERF_LEAVECONNECTED );
    ASSERT( !FAILED( hr ) );

    // and put it here
    hr = m_pGraph->AddFilter( pFilter, fi.achName );
    ASSERT( !FAILED( hr ) );

    pFilter->Release( );

    // go through each of the pins on this filter and move connected filters
    // over too
    CComPtr< IEnumPins > pEnum;
    pFilter->EnumPins( &pEnum );

    if( !pEnum )
    {
        return NOERROR;
    }

    while( 1 )
    {
        CComPtr< IPin > pPin;
        ULONG Fetched = 0;
        pEnum->Next( 1, &pPin, &Fetched );
        if( !pPin )
        {
            break;
        }

        CComPtr< IPin > pConnected;
        pPin->ConnectedTo( &pConnected );

        if( pConnected )
        {
            PIN_INFO pi;
            pConnected->QueryPinInfo( &pi );
            if( pi.pFilter ) 
            {
                pi.pFilter->Release( );
                hr = _SleepFilter( pi.pFilter );
                ASSERT( !FAILED( hr ) );
            }
        }
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CDeadGraph::_ReviveFilter( IBaseFilter * pFilter, IGraphBuilder * pGraph )
{
    HRESULT hr = 0;

    FILTER_INFO fi;
    ZeroMemory( &fi, sizeof( fi ) );
    pFilter->QueryFilterInfo( &fi );
    if( fi.pGraph ) fi.pGraph->Release( );

    // if the graphs are the same, then don't do anything
    if( pGraph == fi.pGraph ) return NOERROR;

#ifdef DEBUG
    USES_CONVERSION;
    TCHAR * t = W2T( fi.achName );
    DbgLog((LOG_TRACE,TRACE_HIGHEST, "deadgraph: ReviveFilter %s", t ));
#endif

    pFilter->AddRef( );

    // remove it from here...
    CComQIPtr< IGraphConfig, &IID_IGraphConfig > pConfig( m_pGraph );
    hr = pConfig->RemoveFilterEx( pFilter, REMFILTERF_LEAVECONNECTED );
    ASSERT( !FAILED( hr ) );

    // and put it here
    hr = pGraph->AddFilter( pFilter, fi.achName );
    ASSERT( !FAILED( hr ) );

    pFilter->Release( );

    // go through each of the pins on this filter and move connected filters
    // over too
    CComPtr< IEnumPins > pEnum;
    pFilter->EnumPins( &pEnum );

    if( !pEnum )
    {
        return NOERROR;
    }

    while( 1 )
    {
        CComPtr< IPin > pPin;
        ULONG Fetched = 0;
        pEnum->Next( 1, &pPin, &Fetched );
        if( !pPin )
        {
            break;
        }

        CComPtr< IPin > pConnected;
        pPin->ConnectedTo( &pConnected );

        if( pConnected )
        {
            PIN_INFO pi;
            pConnected->QueryPinInfo( &pi );
            if( pi.pFilter ) 
            {
                pi.pFilter->Release( );
                hr = _ReviveFilter( pi.pFilter, pGraph );
                ASSERT( !FAILED( hr ) );
            }
        }
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\dexhelp.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dexhelp.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <atlbase.h>
#include <qeditint.h>
#include <qedit.h>
#include "dexhelp.h"
#include "..\util\filfuncs.h"
#include "..\util\dexmisc.h"
#include "..\..\..\filters\h\ftype.h"
#include <initguid.h>
#include <strsafe.h>

#define DEXHELP_TRACE_LEVEL 2

DEFINE_GUID( CLSID_CrappyOldASFReader, 0x6B6D0800, 0x9ADA, 0x11d0, 0xa5, 0x20, 0x00, 0xa0, 0xd1, 0x01, 0x29, 0xc0 );

// this function is only called by dexhelp
// itself (in BuildSourcePart) and the mediadet
//
HRESULT MakeSourceFilter(
                        IUnknown **ppVal,
                        const WCHAR* szMediaName,
                        const GUID *pSubObjectGuid,
                        AM_MEDIA_TYPE *pSourceMT,
                        CAMSetErrorLog *pErr,
                        WCHAR * pMedLocFilterString, // passed straight to the media locator
                        long MedLocFlags,
                        IMediaLocator * pMedLocOverride )
{
    USES_CONVERSION;
    HRESULT hr = 0;

    long t1 = timeGetTime( );

    CheckPointer(ppVal, E_POINTER);

    // don't need to check bstrMediaName beyond if it will fit into FilenameToTry
    // we're middle-ware and something would have checked the name above us

    // we may pass a NULL pointer in, so make a local copy to make testing easy
    //
    BOOL NoName = TRUE;
    WCHAR FilenameToTry[_MAX_PATH];
    FilenameToTry[0] = 0;
    if( !FAILED( ValidateFilenameIsntNULL( szMediaName) ) )
    {
        size_t MediaNameLen;
        hr = StringCchLength( (WCHAR*) szMediaName, _MAX_PATH, &MediaNameLen );
        if( FAILED( hr ) )
        {
            return hr;
        }

        NoName = FALSE;
        StringCchCopy( FilenameToTry, _MAX_PATH, szMediaName );
    }

    // we may pass a NULL pointer in, so make a local copy to make testing easy
    //
    GUID SubObjectGuid = GUID_NULL;
    if (pSubObjectGuid)
        SubObjectGuid = *pSubObjectGuid;

    *ppVal = NULL;
    CComPtr< IUnknown > pFilter;

    // if they didn't give us any source information, we must want to generate
    // 'blankness', either audio or video style
    //
    if ( NoName && SubObjectGuid == GUID_NULL)
    {
	if (pSourceMT == NULL)
        {
	    return E_INVALIDARG;	// !!! maybe they used sub object
        }
	if (pSourceMT->majortype == MEDIATYPE_Video)
        {
            hr = CoCreateInstance(
                        CLSID_GenBlkVid,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IBaseFilter,
                        (void**) &pFilter );
            if( FAILED( hr ) )
            {
		ASSERT(FALSE);
                if (pErr) pErr->_GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr);
		return hr;
            }
	}
        else if (pSourceMT->majortype == MEDIATYPE_Audio)
        {
            hr = CoCreateInstance(
                        CLSID_Silence,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IBaseFilter,
                        (void**) &pFilter );
            if( FAILED( hr ) )
            {
                ASSERT(FALSE);
                if (pErr) pErr->_GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr);
		return hr;
            }
	} else
        {
	    return VFW_E_INVALIDMEDIATYPE;
	}

        // BLACK and SILENCE filters need to see the media type
        CComQIPtr< IBaseFilter, &IID_IBaseFilter > pBaseFilter( pFilter );
        IPin * pOutPin = GetOutPin( pBaseFilter, 0 );
        if( !pOutPin )
        {
            ASSERT( FALSE );
	    hr = E_FAIL;
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
	    return hr;
        }
        CComQIPtr< IDexterSequencer, &IID_IDexterSequencer > pSeq(pOutPin);
        if( pSeq )
        {
	    // !!! we never return hr from this point!
	    hr = pSeq->put_MediaType( pSourceMT );
        }

    }
    else // not a blankness filter, we actually want something here
    {
        // we're about to find what type and subtype the source provides
        //
        GUID Type = GUID_NULL;
        GUID Subtype = GUID_NULL;
        CLSID SourceClsid = SubObjectGuid;

        // in case we need to use this variant for an error call, invent one
        //
        VARIANT v;
        VariantInit( &v );

        // if we have a name, then write it into the potential error string
        //
        if( !NoName )
        {
            v.vt = VT_BSTR;
            v.bstrVal = FilenameToTry;
        }

        // if the user hasn't told us what our source CLSID is, then
        // we have to find it now by looking in the registry
        //
        if( SourceClsid == GUID_NULL )
        {
	    // if we don't have any source media name, we can't guess
	    // a sub-object
	    //
	    if( NoName )
	    {
                if (pErr) pErr->_GenerateError( 1, L"Filename was required, but wasn't given",
				 DEX_IDS_MISSING_SOURCE_NAME, E_INVALIDARG );
	        return E_INVALIDARG;
	    }

            // split it up so we can look at the extension
            //
            WCHAR Drive[_MAX_DRIVE];
            WCHAR Path[_MAX_DIR];
            WCHAR Name[_MAX_FNAME];
            WCHAR Ext[_MAX_EXT];
            Ext[0] = 0;
            _wsplitpath( FilenameToTry, Drive, Path, Name, Ext );

            // !!! hack for purposely finding the DASource filter
            //
            if(!DexCompareW( Ext, L".htm" )) // safe
            {
                SourceClsid = CLSID_DAScriptParser;
                hr = NOERROR;
            }
            else
            {
                // ask DShow for the filter we need.
                // !!!C may want to ask user for the clsid?
                //
                BOOL Retried = FALSE;

                // if we're not to check, the fake out retried so we don't look
                //
                BOOL DoCheck = ( ( MedLocFlags & SFN_VALIDATEF_CHECK ) == SFN_VALIDATEF_CHECK );
                if( !DoCheck ) Retried = TRUE;

                while( 1 )
                {
                    // convert wide name to TCHAR
                    //
                    const TCHAR * pName = W2CT( FilenameToTry );

                    hr = GetMediaTypeFile( pName, &Type, &Subtype, &SourceClsid );

                    // !!! hack for ASF files! Yikes!
                    //
                    if( SourceClsid == CLSID_CrappyOldASFReader )
                    {
                        SourceClsid = CLSID_WMAsfReader;
                    }

                    // 0x80070003 = HRESULT_FROM_WIN32( E_PATH_NOT_FOUND )
                    bool FailedToFind = false;
                    if( hr == 0x80070003 || hr == 0x80070002 )
                    {
                        FailedToFind = true;
                    }

                    // if no error, or if we've already done this once, break out
                    //
                    if( !FAILED( hr ) || Retried || !FailedToFind )
                    {
                        break;
                    }

                    Retried = TRUE;

                    // if failed to load, use the media detector
                    //
                    CComPtr< IMediaLocator > pLocator;
                    if( pMedLocOverride )
                    {
                        pLocator = pMedLocOverride;
                    }
                    else
                    {
                        HRESULT hr2 = CoCreateInstance(
                            CLSID_MediaLocator,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IMediaLocator,
                            (void**) &pLocator );

                        if( FAILED( hr2 ) )
                        {
                            if (pErr) pErr->_GenerateError( 1, L"Filename doesn't exist or cannot be interpreted",
         		        DEX_IDS_BAD_SOURCE_NAME2, E_INVALIDARG, &v );
                            return hr;
                        }
                    }

                    BSTR FoundName;
                    BSTR bFileToTry = SysAllocString (FilenameToTry);
                    BSTR bFilterString = SysAllocString ( pMedLocFilterString);

                    HRESULT FoundHr;
                    if (bFileToTry && bFilterString)
                    {
                        FoundHr = pLocator->FindMediaFile(bFileToTry, bFilterString, &FoundName, MedLocFlags );
                        SysFreeString (bFileToTry);
                        SysFreeString (bFilterString);
                    }
                    else
                    {
                        FoundHr = E_OUTOFMEMORY;
                        hr = E_OUTOFMEMORY;
                    }

                    // should never happen
                    //
                    if( FoundHr == NOERROR )
                    {
                        break;
                    }

                    // found something
                    //
                    if( FoundHr == S_FALSE )
                    {
                        hr = StringCchCopy( FilenameToTry, _MAX_PATH, FoundName );
                        SysFreeString( FoundName );
                        if( FAILED( hr ) )
                        {
                            return hr;
                        }
                        continue;
                    }

                    break;

                } // while 1

            } // not .htm file

            // if GetMediaTypeFile bombed, then bail
            //
            if( FAILED( hr ) )
            {
                if (pErr) pErr->_GenerateError( 1, L"Filename doesn't exist, or DShow doesn't recognize the filetype",
			DEX_IDS_BAD_SOURCE_NAME, E_INVALIDARG, &v );
                return hr;
            }
        }

        // create the source filter
        //
        hr = CoCreateInstance( SourceClsid, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void**) &pFilter );
        if( FAILED( hr ) )
        {
            if (pErr) pErr->_GenerateError( 1, L"unexpected error - some DShow component not installed correctly",
					    DEX_IDS_INSTALL_PROBLEM, E_INVALIDARG );
            return hr;
        }

        // ask for the file source interface.
        //
        if( !NoName )
        {
            CComQIPtr< IFileSourceFilter, &IID_IFileSourceFilter > pSourceFilter( pFilter );
            if( !pSourceFilter )
            {
                if (pErr) pErr->_GenerateError( 1, L"Source filter does not accept filenames",
				DEX_IDS_NO_SOURCE_NAMES, E_NOINTERFACE, &v );
                return E_NOINTERFACE;
            }

            // load it. Give it the media type we found, so it can find the splitter faster?
            //
            AM_MEDIA_TYPE FilterType;
            ZeroMemory( &FilterType, sizeof( FilterType ) ); // safe
            FilterType.majortype = Type;
            FilterType.subtype = Subtype;

            hr = pSourceFilter->Load( FilenameToTry, &FilterType );
            if( FAILED( hr ) )
            {
                if (pErr) pErr->_GenerateError( 1, L"File contains invalid data",
				DEX_IDS_BAD_SOURCE_NAME2, E_INVALIDARG, &v );
                return hr;
            }
        }
    }

    long t2 = timeGetTime( ) - t1;
    DbgLog((LOG_TIMING,1, "DEXHELP::Creating source filter took %ld ms", t2 ));

    // stuff it in the return
    //
    *ppVal = (IUnknown *)pFilter;
    (*ppVal)->AddRef();

    return NOERROR;
}

// look at the resizer and it's connections and figure out of the input size
// is the same as the desired output size and if it is, then disconnect it.
// If the output pin is unconnected at the time we call this, then the resizer
// will be removed from the graph and thrown away. ppOutPin should then be
// non-NULL and will then be stuffed with the output pin of the upstream
// filter from the resizer. If the output pin is connected when we call this,
// then the upstream filter from the resizer will be reconnected to the down-
// stream filter. In either case, if it's possible to remove it, the resizer
// is thrown away.
//
HRESULT RemoveResizerIfPossible( IBaseFilter * pResizer, long DesiredWidth, long DesiredHeight, IPin ** ppOutPin )
{
    HRESULT hr = 0;

    CheckPointer( pResizer, E_POINTER );

    IPin * pIn = GetInPin( pResizer, 0 );
    IPin * pOut = GetOutPin( pResizer, 0 );
    if( !pIn || !pOut )
    {
        return VFW_E_NOT_FOUND;
    }

    CComPtr< IPin > pInConnected;
    pIn->ConnectedTo( &pInConnected );
    if( !pInConnected )
    {
        return VFW_E_NOT_CONNECTED;
    }
    CComPtr< IPin > pOutConnected;
    pOut->ConnectedTo( &pOutConnected );

    // find the input pin's media type
    AM_MEDIA_TYPE mt;
    ZeroMemory( &mt, sizeof(AM_MEDIA_TYPE) ); // safe
    hr = pIn->ConnectionMediaType( &mt );
    if( FAILED( hr ) )
    {
	return hr;
    }

    if( ( mt.formattype == FORMAT_VideoInfo )
	&&
	( DesiredWidth == HEADER(mt.pbFormat)->biWidth )
	&&
	( DesiredHeight == HEADER(mt.pbFormat)->biHeight ) )
    {
        hr = pIn->Disconnect( );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            return hr;
        }
        hr = pInConnected->Disconnect( );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            return hr;
        }

        // if we used to be connected, reconnect now
        //
        if( pOutConnected )
        {
            hr = pOut->Disconnect( );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                return hr;
            }
            hr = pOutConnected->Disconnect( );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                return hr;
            }
            hr = pInConnected->Connect( pOutConnected, &mt );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                return hr;
            }
        }

        FILTER_INFO FilterInfo;
        hr = pResizer->QueryFilterInfo(&FilterInfo);
        if( FAILED( hr ) )
        {
            return hr;
        }
        hr  = FilterInfo.pGraph->RemoveFilter(pResizer);
        if (FilterInfo.pGraph) FilterInfo.pGraph->Release();
        if( FAILED( hr ) )
        {
            return hr;
        }

        DbgLog((LOG_TRACE,DEXHELP_TRACE_LEVEL,TEXT("DEXHELP::Removed unnecessary resizer")));

        // if user wanted to know the output pin, addref and returnit
        //
        if( ppOutPin )
        {
            *ppOutPin = pInConnected;
            (*ppOutPin)->AddRef( );
        }
    }
    else
    {
        if( ppOutPin )
        {
            *ppOutPin = pOut;
            (*ppOutPin)->AddRef( );
        }
    }

    SaferFreeMediaType( mt );

    return hr;
}

// this is called by the render engine OR the big switch (if dynamic)

// if this is being called by the big switch, then it's because of
// dynamic sources. The big switch could be part of a graph which is
// being played all by itself ( no render engine ),
// or it could be from a graph which was built by the render engine,
// which desires caching ability.
//
// when we're calling BuildSourcePart, we're looking to PULL from the cache,
// not put things in. We're passed in a pointer to a CDeadGraph, and we have
// a unique ID, so use those to pull it out.
//
HRESULT BuildSourcePart(
                        IGraphBuilder *pGraph,              // the big graph we're building to
                        BOOL fSource,                       // if this is really a source filter or just black
                        double SourceFPS,                   //
	                AM_MEDIA_TYPE *pSourceMT,           // the media type for the source to produce
                        double GroupFPS,                    //
                        long StreamNumber,                  // the source stream number
                        int nStretchMode,                   // the source stretch mode, if video
	                int cSkew,                          // number of skew structs
                        STARTSTOPSKEW *pSkew,               // skew struct array
	                CAMSetErrorLog *pErr,               // the error log you can use
                        BSTR bstrSourceName,                // the source name, if applicable
                        const GUID * SourceGUID,            // the source GUID, if applicable
                        IPin *pSplitPin,                    // src is this unconnected splitter pin
                        IPin **ppOutput,                    // the pin to connect to the switch
                        long UniqueID,                      // the source's unique Identifier
                        IDeadGraph * pCache,                // the cache we can pull dead filters from
                        BOOL InSmartRecompressionGraph,     // if we're using smart recompression
                        WCHAR * pMedLocFilterString,        // passed straight to the media locator
                        long MedLocFlags,                   // stuff for the media detector
                        IMediaLocator * pMedLocOverride,    // stuff for the media detector
                        IPropertySetter * pSetter,          // properties for the source
                        IBaseFilter **ppDanglyBit)          // properties for the source
{
    DbgLog((LOG_TRACE,1,TEXT("BuildSourcePart")));

    DbgTimer t( "(rendeng) BuildSourcePart" );

    CheckPointer(ppOutput, E_POINTER);

    HRESULT hr = 0;

#ifdef DEBUG
    long tt1, tt2;
    tt1 = timeGetTime( );
#endif

    HRESULT Revived = E_FAIL;
    IPin *pOutPin = NULL;
    CComPtr< IBaseFilter > pSource;
    CComPtr< IBaseFilter > pFRC;	// frc or audpack, actually

    CDeadGraph gBuilderGraph;	// do most of our graph building in a private
				// graph (it's faster)

    // who shall we revive it to? a seperate graph or the real one?
    // a seperate one might be better.  Faster.  No millions of switch pins
    //
    CComPtr< IGraphBuilder > pBuilderGraph;
    gBuilderGraph.GetGraph( &pBuilderGraph ); // this will addreff it once
    if( !pBuilderGraph )
    {
        return E_UNEXPECTED;
    }

    // copy site from main graph to extra graph
    IObjectWithSite* pObjectWithSite = NULL;
    HRESULT hrKey = pGraph->QueryInterface(IID_IObjectWithSite, (void**)&pObjectWithSite);
    if( SUCCEEDED(hrKey) )
    {
        IUnknown *punkSite;
        hrKey = pObjectWithSite->GetSite(IID_IUnknown, (void **) &punkSite);
        pObjectWithSite->Release();

        if( SUCCEEDED(hrKey) )
        {
            hrKey = pBuilderGraph->QueryInterface(IID_IObjectWithSite, (void**)&pObjectWithSite);
            if( SUCCEEDED(hrKey) )
            {
                hrKey = pObjectWithSite->SetSite( (IUnknown *) punkSite );
                pObjectWithSite->Release( );
            }
            punkSite->Release();
        }
    }

#ifdef DEBUG
    tt1 = timeGetTime( ) - tt1;
    DbgLog( ( LOG_TRACE, DEXHELP_TRACE_LEVEL, TEXT("DEXHELP::took %ld to set up Key"), tt1 ) );
    tt1 = timeGetTime( );
#endif

    CComPtr< IPin > pStopPin;

    // we are just supposed to connect from this splitter pin
    if (pSplitPin) {
	pOutPin = pSplitPin;
	pBuilderGraph = pGraph; // we must do our building in the main graph
				// since the source is already in the main graph

	// Is the split pin connected yet?
  	CComPtr <IPin> pCon;
  	pOutPin->ConnectedTo(&pCon);
  	if (pCon) {
	    // treat the extra appendage like it's just been revived, and fix
	    // it up with the settings it really needs (might not be correct)
	    IBaseFilter *pF = GetStopFilterOfChain(pCon);
	    pStopPin = GetOutPin(pF, 0);	// this will AddRef
	    Revived = S_OK;
    	    DbgLog((LOG_TRACE,1,TEXT("Fixing up already connected extra appendage")));
	    goto FixAppendage;
	} else {
	    // set pSource, it will be NULL
	    ASSERT(pSource == NULL);
	    pSource = GetStartFilterOfChain(pOutPin);
    	    DbgLog((LOG_TRACE,1,TEXT("Going to make an extra appendage")));
	    goto Split;
	}
    }

  {

    // see if this chain already exists in the dead pool. We'll deal with whether it's
    // okay to use it in a second.
    //
    if( pCache && UniqueID )
    {
        Revived = pCache->ReviveChainToGraph( pBuilderGraph, UniqueID, NULL, &pStopPin, ppDanglyBit ); // will addref pStopPin, but not ppDanglyBit
    }

    // if we couldn't load it, jump to the section that loads it
    //
    if( Revived != S_OK )
    {
        DbgLog( ( LOG_TRACE, DEXHELP_TRACE_LEVEL, TEXT("DEXHELP::Could not revive chain %ld, wasn't there"), UniqueID ) );
        goto LoadIt;
    }

    DbgLog((LOG_TRACE,1,TEXT("Successfully revived a chain from the cache")));

FixAppendage:
    // we'll save at least the source filter, which is already loaded,
    // and reconnect from there.
    //
    pSource = GetStartFilterOfChain( pStopPin );
    pFRC = GetFilterFromPin( pStopPin );
    if( !pSource || !pFRC )
    {
        DbgLog( ( LOG_TRACE, DEXHELP_TRACE_LEVEL, TEXT("DEXHELP::Couldn't find Source or couldn't find FRC, bail!") ) );
        goto LoadIt;
    }

    // Don't waste 2 seconds trying to connect audio pins to a video resizer
    // and vice versa.  Don't try a poor mediatype
    // !!! won't work when Dexter supports other types
    if (pOutPin == NULL) {	// we already know the right pin?
        GUID guid;
        if (pSourceMT->majortype == MEDIATYPE_Video) {
            guid = MEDIATYPE_Audio;
        } else {
            guid = MEDIATYPE_Video;
        }
        pOutPin = GetOutPinNotOfType( pSource, 0, &guid);
    }


    // try and see if the chain we loaded works for us

    if( pSourceMT->majortype == MEDIATYPE_Video )
    {
        DbgLog( ( LOG_TRACE, DEXHELP_TRACE_LEVEL, TEXT("DEXHELP::Revived VIDEO chain %ld..."), UniqueID ) );

        // get the current info
        //
        VIDEOINFOHEADER * pVIH = (VIDEOINFOHEADER*) pSourceMT->pbFormat;
        long DesiredWidth = pVIH->bmiHeader.biWidth;
        long DesiredHeight = pVIH->bmiHeader.biHeight;
        unsigned long DesiredCropMethod = nStretchMode;
        long DesiredBitDepth = pVIH->bmiHeader.biBitCount;

        // how do we find the size of the current chain? We cannot look for
        // a resize filter, since it may not be present in the chain. So
        // we look for the FRC (which is always there) and ask for it's
        // connection media type on the upstream (connected) pin

        // ask the input pin of the FRC for it's media type.
        // This will return the RESIZED size
        //
        IPin * pFRCInPin = GetInPin( pFRC, 0 );
        AM_MEDIA_TYPE FrcType;
        ZeroMemory( &FrcType, sizeof( FrcType ) ); // safe
        hr = pFRCInPin->ConnectionMediaType( &FrcType );
        if( FAILED( hr ) )
        {
            return hr; // this may have failed due to lack of memory?
        }
        pVIH = (VIDEOINFOHEADER*) FrcType.pbFormat;
        long OldOutputHeight = pVIH->bmiHeader.biHeight;
        long OldOutputWidth = pVIH->bmiHeader.biWidth;
        long OldBitDepth = pVIH->bmiHeader.biBitCount;

        // see if the output height matches the height we're looking for,
        // if they don't, then we must bail
        //
        if( ( OldOutputHeight != DesiredHeight ) ||
            ( OldOutputWidth != DesiredWidth ) ||
	    // !!! BUGBUG 565/555 broken!
            ( OldBitDepth != DesiredBitDepth ) )
        {
            DbgLog( ( LOG_TRACE, DEXHELP_TRACE_LEVEL, TEXT("DEXHELP::Revived chain didn't have same output size (or bit depth)") ) );
            goto LoadIt;
        }

        // force the frame rate upon the FRC
        //
        CComQIPtr< IDexterSequencer, &IID_IDexterSequencer > pSeq( pFRC );
        hr = pSeq->put_OutputFrmRate( GroupFPS );
        ASSERT( !FAILED( hr ) ); // should never fail
        if( FAILED( hr ) )
        {
            // if it can't handle the rate, then we can't handle it's output
            return hr;
        }

        // tell the FRC about the start/stop times it's going to produce
        //
        hr = pSeq->ClearStartStopSkew();

        // !!! WE NEED A WAY TO VARY THE RATE ON SOURCE w/o MEDIA TIMES!

        for (int z=0; z<cSkew; z++)
        {
	    hr = pSeq->AddStartStopSkew( pSkew[z].rtStart, pSkew[z].rtStop,
					    pSkew[z].rtSkew, pSkew[z].dRate );
            ASSERT(hr == S_OK);
            if( FAILED( hr ) )
            {
                return hr;
            }
        }

        // inform the FRC that it's not to do rate conversions if smart recompressing
        if( InSmartRecompressionGraph )
        {
            pSeq->put_OutputFrmRate( 0.0 );
        }

        // force source frame rate on the source
        pSeq = pSource;
        if( pSeq )
        {
            hr = pSeq->put_OutputFrmRate( SourceFPS );
            if( FAILED( hr ) )
            {
                DbgLog( ( LOG_ERROR, 2, TEXT("DEXHELP::Source didn't like being told it's frame rate") ) );
                return hr;
            }
        }

        // the sizes match, which means that either they're the same, or a resizer
        // is in use. So if the user has specified a crop method, if a resizer is
        // present, we can set it. Get it?
        //
        IBaseFilter * pResizeFilter = FindFilterWithInterfaceUpstream( pFRC, &IID_IResize );
        if( pResizeFilter )
        {
            DbgLog( ( LOG_TRACE, DEXHELP_TRACE_LEVEL, TEXT("DEXHELP::setting new crop/size on revived resizer (even if same)") ) );
            CComQIPtr< IResize, &IID_IResize > pResize( pResizeFilter );
            hr = pResize->put_Size( DesiredHeight, DesiredWidth, DesiredCropMethod );
            if( FAILED( hr ) )
            {
                // oh boy, it didn't like that. Guess what?
                //
                DbgLog( ( LOG_ERROR, 1, TEXT("DEXHELP::resizer wouldn't take new size") ) );
                return hr;
            }
            CComPtr< IPin > pNewStopPin;
            hr = RemoveResizerIfPossible( pResizeFilter, DesiredWidth, DesiredHeight, &pNewStopPin );
            if( FAILED( hr ) )
            {
                return hr;
            }
        }
    }
    else if( pSourceMT->majortype == MEDIATYPE_Audio )
    {
        DbgLog( ( LOG_TRACE, DEXHELP_TRACE_LEVEL, TEXT("DEXHELP::Revived AUDIO chain %ld..."), UniqueID ) );

        // get the current info
        //
        WAVEFORMATEX * pFormat = (WAVEFORMATEX*) pSourceMT->pbFormat;
        long DesiredChannels = pFormat->nChannels;
        long DesiredBitDepth = pFormat->wBitsPerSample;
        long DesiredSampleRate = pFormat->nSamplesPerSec;

        // only two things could have changed - the format of the audio itself OR the
        // rate at which the audpacker sends stuff downstream. All we need to do is
        // disconnect the audpacker's input pin, set the format, and reconnect it.

        IPin * pPackerInPin = GetInPin( pFRC, 0 );
        AM_MEDIA_TYPE OldType;
        ZeroMemory( &OldType, sizeof( OldType ) ); // safe
        hr = pPackerInPin->ConnectionMediaType( &OldType );
        if( FAILED( hr ) )
        {
            return hr;
        }
        pFormat = (WAVEFORMATEX*) OldType.pbFormat;
        long OldChannels = pFormat->nChannels;
        long OldBitDepth = pFormat->wBitsPerSample;
        long OldSampleRate = pFormat->nSamplesPerSec;

        if( ( OldChannels != DesiredChannels ) ||
            ( OldSampleRate != DesiredSampleRate ) ||
            ( OldBitDepth != DesiredBitDepth ) )
        {
            DbgLog( ( LOG_TRACE, DEXHELP_TRACE_LEVEL, TEXT("DEXHELP::Revived chain didn't have same audio parameters") ) );
            goto LoadIt;
        }

        // force the frame rate upon the FRC
        //
        CComQIPtr< IDexterSequencer, &IID_IDexterSequencer > pSeq( pFRC );
        hr = pSeq->put_OutputFrmRate( GroupFPS );
        if( FAILED( hr ) )
        {
            // if it can't handle the rate, then we can't handle it's output
            return hr;
        }

        // tell the FRC about the start/stop times it's going to produce
        //
        hr = pSeq->ClearStartStopSkew();

        // !!! WE NEED A WAY TO VARY THE RATE ON SOURCE w/o MEDIA TIMES!

        for (int z=0; z<cSkew; z++)
        {
	    hr = pSeq->AddStartStopSkew( pSkew[z].rtStart, pSkew[z].rtStop,
					    pSkew[z].rtSkew, pSkew[z].dRate );
            ASSERT(hr == S_OK);
            if( FAILED( hr ) )
            {
                return hr;
            }
        }

        // force source frame rate on the source
        pSeq = pSource;
        if( pSeq )
        {
            hr = pSeq->put_OutputFrmRate( SourceFPS );
            if( FAILED( hr ) )
            {
                DbgLog( ( LOG_ERROR, 2, TEXT("DEXHELP::Source didn't like being told it's frame rate") ) );
            }
        }
    }
    else
    {
        // just ain't gonna happen, we don't deal with it right
        //
        goto LoadIt;
    }

    // if we got here, then the chain worked.

    hr = ReconnectToDifferentSourcePin( pBuilderGraph, pSource, StreamNumber, &pSourceMT->majortype );
    if( FAILED( hr ) )
    {
	VARIANT var;
	VariantInit(&var);
	var.vt = VT_I4;
	var.lVal = StreamNumber;
	if (pErr) pErr->_GenerateError( 2, DEX_IDS_STREAM_NUMBER, hr, &var);
	return hr;
    }

    if (pBuilderGraph != pGraph) {
        // the chain we just revived has a unique ID associated with it.
        // This call, instead of bringing it from some other graph to
        // the builder graph, will just force the unique ID to 1.
        //
        // I have no idea what to do if this bombs. It shouldn't.
        // if it does, we're in trouble.
        hr = gBuilderGraph.PutChainToRest( 1, NULL, pStopPin, NULL );
        ASSERT(SUCCEEDED(hr));
        if( !FAILED( hr ) )
        {
            hr = gBuilderGraph.ReviveChainToGraph( pGraph, 1, NULL, ppOutput, NULL ); // this will addref ppOutput
        }
    } else {
	*ppOutput = pStopPin;	// return this pin
	(*ppOutput)->AddRef();
    }
    gBuilderGraph.Clear( );

#ifdef DEBUG
    tt2 = timeGetTime( );
    DbgLog( ( LOG_TIMING, 1, TEXT("DEXHELP::Took %ld ms to use revived chain"), tt2 - tt1 ) );
#endif

    DbgLog((LOG_TRACE,1,TEXT("Successfully re-programmed revived chain. Done")));

    return hr;


LoadIt:

    DbgLog((LOG_TRACE,1,"Cannot use cached chain!"));

    // if the chain was revived, but we got here, then we cannot
    // use the source chain. But we can use the source filter and the
    // FRC/audpack, save them off. This is simpler than a bunch of extra logic
    // to see what we need to tear
    // down and what we don't.
    //
    if( Revived == S_OK )
    {
        // disconnect just this pin of the source filter (it might be shared
        // with somebody else)
        //
	if (pOutPin) {
  	    CComPtr <IPin> pCon;
  	    pOutPin->ConnectedTo(&pCon);
	    if (pCon) {
                hr = pOutPin->Disconnect();
                hr = pCon->Disconnect();
	    }
	}
        if( FAILED( hr ) )
        {
            return hr;
        }

        // throw away all the others
        //
        hr = RemoveUpstreamFromPin( pStopPin );
        if( FAILED( hr ) )
        {
            return hr;
        }

	// we revived a dangly bit too, that also must die
	if (ppDanglyBit && *ppDanglyBit) {
	    hr = RemoveDownstreamFromFilter(*ppDanglyBit);
	    *ppDanglyBit = NULL;
	}

        // we'll save the FRC by leaving the pointer alone,
        // it should be disconnected now

        DbgLog((LOG_TRACE,2,"DEXHELP::We can at least use SRC and FRC/AUDPACK"));
    }

    // if the revive chain didn't have a source in it, then load the
    // source NOW
    //
    if( !pSource )
    {
        CComPtr< IUnknown > pUnk;
        DbgLog((LOG_TRACE,1,TEXT("Making a SourceFilter")));
        hr = MakeSourceFilter( &pUnk, bstrSourceName, SourceGUID, pSourceMT, pErr, pMedLocFilterString, MedLocFlags, pMedLocOverride );
        if( FAILED( hr ) )
        {
            return hr;
        }

	// give the properties to the source. SOURCES ONLY SUPPORT STATIC PROPS
	if (pSetter) {
	    pSetter->SetProps(pUnk, -1);
	}

        pUnk->QueryInterface( IID_IBaseFilter, (void**) &pSource );

        // ************************
        // the point here is to add the filter to the graph
        // and be able to find it's ID later so we can associate it with
        // something we're looking up
        // ************************

        // put the object in the graph
        //
        WCHAR FilterName[256];
        GetFilterName( UniqueID, L"Source", FilterName, 256 );
        hr = pBuilderGraph->AddFilter( pSource, FilterName );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
	    return hr;
        }
    }

    // tell it about our error log - Still image source supports this
    //
    CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pLog( pSource );
    if( pLog )
    {
	pLog->put_ErrorLog( pErr->m_pErrorLog );
    }

    // Don't waste 2 seconds trying to connect audio pins to a video resizer
    // and vice versa.  Don't try a poor mediatype
    // !!! won't work when Dexter supports other types
    if (pOutPin == NULL) {	// we already know the right pin?
        GUID guid;
        if (pSourceMT->majortype == MEDIATYPE_Video) {
            guid = MEDIATYPE_Audio;
        } else {
            guid = MEDIATYPE_Video;
        }
        pOutPin = GetOutPinNotOfType( pSource, 0, &guid);
    }

  }

// we have an unconnected splitter output as our source jumps straight here
Split:

  ///////////
  // VIDEO //
  ///////////

  if (pSourceMT->majortype == MEDIATYPE_Video) {

    ASSERT( pOutPin );
    if( !pOutPin )
    {
	hr = E_FAIL;
	if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
	return hr;
    }

    // if the filter supports telling it the frame rate, then tell it, this
    // will help out still image sources, etc.
    //
    CComQIPtr< IDexterSequencer, &IID_IDexterSequencer > pGenVideo( pOutPin );
    if( pGenVideo)
    {
	// This is just in case... we don't care if they fail
	if (fSource) {
	    pGenVideo->put_OutputFrmRate(SourceFPS); // stillvid wants this
	} else {
	    pGenVideo->put_OutputFrmRate(GroupFPS);  // black wants this
	}
    }

    IPin *pResizeOutput = NULL;

    // resizer stuff
    if( fSource && !InSmartRecompressionGraph ) {
        // put a resize in the graph
        //
        CComPtr< IBaseFilter > pResizeBase;
        hr = CoCreateInstance(
	    CLSID_Resize,
	    NULL,
	    CLSCTX_INPROC_SERVER,
	    IID_IBaseFilter,
	    (void**) &pResizeBase );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
	    if (pErr) pErr-> _GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
	    return hr;
        }

        // !!! hr = _AddFilter( lll, pResizeBase, L"Resizer" );
        hr = pBuilderGraph->AddFilter( pResizeBase, L"Resizer" );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
	    return hr;
        }

        CComQIPtr< IResize, &IID_IResize > pResize( pResizeBase );
        if( !pResize )
        {
	    hr = E_NOINTERFACE;
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_INTERFACE_ERROR, hr );
	    return hr;
        }

        // ask the source how it wants to be sized, and tell the resizer that
        //
        hr = pResize->put_MediaType(pSourceMT);
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_BAD_MEDIATYPE, hr );
	    return hr;
        }
        long Height = HEADER(pSourceMT->pbFormat)->biHeight;
        long Width = HEADER(pSourceMT->pbFormat)->biWidth;
        hr = pResize->put_Size( Height, Width, nStretchMode );
        ASSERT( !FAILED( hr ) );

        // get the pins on the resizer
        //
        IPin * pResizeInput = GetInPin( pResizeBase, 0 );
        ASSERT( pResizeInput );
        if( !pResizeInput )
        {
	    if (pErr) pErr->_GenerateError(1,DEX_IDS_GRAPH_ERROR,E_UNEXPECTED);
	    return E_UNEXPECTED;
        }

        pResizeOutput = GetOutPin( pResizeBase, 0 );
        ASSERT( pResizeOutput );
        if( !pResizeOutput )
        {
	    if (pErr) pErr->_GenerateError(1,DEX_IDS_GRAPH_ERROR, E_UNEXPECTED);
	    return E_UNEXPECTED;
        }

        // hook up the resizer input
        //
#ifdef DEBUG
        DbgLog((LOG_TIMING,1,"PERF: Connect in main graph? = %d",
			pBuilderGraph == pGraph));
	DWORD dwT = timeGetTime();
#endif
        hr = pBuilderGraph->Connect( pOutPin, pResizeInput );
#ifdef DEBUG
	dwT = timeGetTime() - dwT;
        DbgLog((LOG_TIMING,1,"PERF: Connect: %dms", (int)dwT));
#endif

	// why didn't we find the right pin off the bat?
        int iPin = 0;
        while( FAILED( hr ) )
        {
	    ASSERT(FALSE);
            pOutPin = GetOutPin( pSource, ++iPin );

            // if no more pins, give up
            if( !pOutPin )
                break;

            hr = pBuilderGraph->Connect( pOutPin, pResizeInput );
        }


        if( FAILED( hr ) )
        {
	    if (bstrSourceName) {
	        VARIANT var;
	        VariantInit(&var);
	        var.vt = VT_BSTR;
	        var.bstrVal = bstrSourceName;
	        if (pErr) pErr->_GenerateError( 1, DEX_IDS_BAD_SOURCE_NAME2,
		    E_INVALIDARG, &var);
	        return E_INVALIDARG;
	    } else {
	        if (pErr) pErr->_GenerateError( 1, DEX_IDS_BAD_SOURCE_NAME2,
		        E_INVALIDARG);
	        return E_INVALIDARG;
	    }
        }

        // maybe we didn't need a resizer cuz the size was OK already
        hr = RemoveResizerIfPossible(pResizeBase, Width, Height,&pResizeOutput);
	if (FAILED(hr)) {
	    if (pErr) pErr->_GenerateError( 1, DEX_IDS_GRAPH_ERROR, hr);
	    return hr;
	}
	pResizeOutput->Release();  // it was just addrefed

    } else {
	// this is the output pin to connect to the FRC
	pResizeOutput = pOutPin;
    }

    // put a FRC in the graph
    //
    if( !pFRC )
    {
        hr = CoCreateInstance(
	    CLSID_FrmRateConverter,
	    NULL,
	    CLSCTX_INPROC_SERVER,
	    IID_IBaseFilter,
	    (void**) &pFRC );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
	    return hr;
        }

        hr = pBuilderGraph->AddFilter( pFRC, L"Frame Rate Converter" );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
	    return hr;
        }
    }

    // set the FRC now, before connecting
    //
    CComQIPtr< IDexterSequencer, &IID_IDexterSequencer > pFRCInt( pFRC );

    // tell the FRC about the start/stop times it's going to produce
    //
    hr = pFRCInt->ClearStartStopSkew();

    // !!! WE NEED A WAY TO VARY THE RATE ON SOURCE w/o MEDIA TIMES!

    for (int z=0; z<cSkew; z++) {
	hr = pFRCInt->AddStartStopSkew(pSkew[z].rtStart, pSkew[z].rtStop,
					pSkew[z].rtSkew, pSkew[z].dRate);
        ASSERT(hr == S_OK);
    }

    // tell the FRC what frame rate to give out
    //
    hr = pFRCInt->put_OutputFrmRate( GroupFPS );
    ASSERT( !FAILED( hr ) );
    if( InSmartRecompressionGraph )
    {
        pFRCInt->put_OutputFrmRate( 0.0 );
    }

    // tell the FRC what media type it should accept
    //
    hr = pFRCInt->put_MediaType( pSourceMT );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
	if (pErr) pErr->_GenerateError( 2, DEX_IDS_BAD_MEDIATYPE, hr );
	return hr;
    }

    IPin * pFRCInput = GetInPin( pFRC, 0 );
    ASSERT( pFRCInput );
    if( !pFRCInput )
    {
	if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, E_UNEXPECTED);
	return E_UNEXPECTED;
    }

    // connect the FRC input pin
    //
    hr = pBuilderGraph->Connect( pResizeOutput, pFRCInput );

    // Somehow we got the wrong output pin from the source filter
    if( FAILED(hr) && InSmartRecompressionGraph )
    {
	ASSERT(FALSE);
        int iPin = 0;
        while( FAILED( hr ) )
        {
            pResizeOutput = GetOutPin( pSource, ++iPin );

            // if no more pins, give up
            if( !pResizeOutput )
            {
                break;
            }

            hr = pBuilderGraph->Connect( pResizeOutput, pFRCInput );
        }
    }

    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
	if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
	return hr;
    }

    // if we need a stream > 0 then we have to disconnect things and
    // try a different one.
    // !!! Much faster to somehow get stream right the first time
    if( StreamNumber && fSource )
    {
	hr = ReconnectToDifferentSourcePin(pBuilderGraph, pSource,
			StreamNumber, &MEDIATYPE_Video);
	if( FAILED( hr ) )
	{
	    VARIANT var;
	    VariantInit(&var);
	    var.vt = VT_I4;
	    var.lVal = StreamNumber;
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_STREAM_NUMBER, hr, &var);
	    return hr;
	}
    } // if StreamNumber

    IPin * pFRCOutput = GetOutPin( pFRC, 0 );
    ASSERT( pFRCOutput );
    if( !pFRCOutput )
    {
	if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, E_UNEXPECTED );
	return E_UNEXPECTED;
    }

    *ppOutput = pFRCOutput;


  ///////////
  // AUDIO //
  ///////////

  } else if (pSourceMT->majortype == MEDIATYPE_Audio) {

    ASSERT( pOutPin );
    if( !pOutPin )
    {
	hr = E_FAIL;
	if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
	return hr;
    }

    CComQIPtr< IDexterSequencer, &IID_IDexterSequencer > pGenVideo( pOutPin );
    if( pGenVideo)
    {
	// This is just in case... we don't care if they fail
	if (fSource) {
	    pGenVideo->put_OutputFrmRate(SourceFPS); // ???????? wants this
	} else {
	    pGenVideo->put_OutputFrmRate(GroupFPS);  // silence wants this
	}
    }

    if (!pFRC) {
        // put an audio repacker in the graph
        //
        hr = CoCreateInstance(
	    CLSID_AudRepack,
	    NULL,
	    CLSCTX_INPROC_SERVER,
	    IID_IBaseFilter,
	    (void**) &pFRC );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
	    return hr;
        }

        // add the repacker to the graph
        //
        hr = pBuilderGraph->AddFilter( pFRC, L"Audio Repackager" );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
	    return hr;
        }
    }

    // set the AudPack properties now BEFORE connecting!
    //
    CComQIPtr< IDexterSequencer, &IID_IDexterSequencer > pRepackerInt( pFRC );
    hr = pRepackerInt->ClearStartStopSkew();

    // !!! WE NEED A WAY TO VARY THE RATE ON SOURCE w/o MEDIA TIMES!

    for (int z=0; z<cSkew; z++) {
	hr = pRepackerInt->AddStartStopSkew(pSkew[z].rtStart, pSkew[z].rtStop,
					pSkew[z].rtSkew, pSkew[z].dRate);
	ASSERT(hr == S_OK);
    }
    hr = pRepackerInt->put_OutputFrmRate( GroupFPS );
    ASSERT( !FAILED( hr ) );
    hr = pRepackerInt->put_MediaType( pSourceMT );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
	if (pErr) pErr->_GenerateError( 2, DEX_IDS_BAD_MEDIATYPE, hr );
	return hr;
    }

    IPin * pRepackerInput = GetInPin( pFRC, 0 );
    ASSERT( pRepackerInput );
    if( !pRepackerInput )
    {
	if (pErr) pErr->_GenerateError( 1, DEX_IDS_GRAPH_ERROR, E_UNEXPECTED);
	return E_UNEXPECTED;
    }

#ifdef DEBUG
    DbgLog((LOG_TIMING,1,"PERF: Connect in main graph? = %d",
			pBuilderGraph == pGraph));
    DWORD dwT = timeGetTime();
#endif
    hr = pBuilderGraph->Connect( pOutPin, pRepackerInput );
#ifdef DEBUG
    dwT = timeGetTime() - dwT;
    DbgLog((LOG_TIMING,1,"PERF: Connect: %dms", (int)dwT));
#endif

    if( FAILED( hr ) )
    {
	if (bstrSourceName) {
	    VARIANT var;
	    VariantInit(&var);
	    var.vt = VT_BSTR;
	    var.bstrVal = bstrSourceName;
	    if (pErr) pErr->_GenerateError( 1, DEX_IDS_BAD_SOURCE_NAME2,
		    hr, &var);
	    return hr;
	} else {
	    if (pErr) pErr->_GenerateError( 1, DEX_IDS_BAD_SOURCE_NAME2,
		    hr);
	    return hr;
	}
    }

    // if we need a stream > 0 then we have to disconnect things and
    // try a different one, we only hooked up stream 0
    // !!! find the right stream off the bat? Put in parser by hand?
    if( StreamNumber && fSource )
    {
	hr = ReconnectToDifferentSourcePin(pBuilderGraph, pSource,
		StreamNumber, &MEDIATYPE_Audio);
	if( FAILED( hr ) )
	{
	    VARIANT var;
	    VariantInit(&var);
	    var.vt = VT_I4;
	    var.lVal = StreamNumber;
	    if (pErr) pErr->_GenerateError( 2, DEX_IDS_STREAM_NUMBER, hr, &var);
	    return hr;
	}
    } // if StreamNumber

    IPin * pRepackerOutput = GetOutPin( pFRC, 0 );
    ASSERT( pRepackerOutput );
    if( !pRepackerOutput )
    {
	if (pErr) pErr->_GenerateError( 2, DEX_IDS_GRAPH_ERROR, E_UNEXPECTED );
	return E_UNEXPECTED;
    }

    *ppOutput = pRepackerOutput;
  }

    if (pBuilderGraph != pGraph) {
        // the chain we just built does NOT have a unique ID associated with it.
        // This call, instead of bringing it from some other graph to
        // the builder graph, will just force a unique ID to be associated with this
        // chain.
        //
        hr = gBuilderGraph.PutChainToRest( 1, NULL, *ppOutput, NULL );
        if( !FAILED( hr ) )
        {
            hr = gBuilderGraph.ReviveChainToGraph( pGraph, 1, NULL, ppOutput, NULL ); // this will addref ppOutput
        }
    } else {
	(*ppOutput)->AddRef();
    }
    gBuilderGraph.Clear( );

#ifdef DEBUG
    tt2 = timeGetTime( ) - tt1;
    DbgLog((LOG_TIMING,1, "DEXHELP::Hooking up source chain took %ld ms", tt2 ));
#endif

    DbgLog((LOG_TRACE,1,TEXT("BuildSourcePart successfully created new chain")));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\grid.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: grid.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

enum
{
    ROW_PIN_UNASSIGNED = -1,
    ROW_PIN_OUTPUT = -100
};

// a class, but more like a struct
//
class CTimingBox
{
    friend class CTimingCol;

public:

    long m_nRow;            // the row this box represents
    long m_nValue;          // the output pin of the switch
    long m_nVCRow;          // ???  
    CTimingBox * m_pNext;   // linked list stuff
    CTimingBox * m_pPrev;   // linked list stuff

    CTimingBox( )
    {
        m_nRow = 0;
        m_nValue = ROW_PIN_UNASSIGNED;
        m_nVCRow = ROW_PIN_UNASSIGNED;
        m_pNext = NULL;
        m_pPrev = NULL;
    }

    CTimingBox( CTimingBox * p )
    {
        m_nRow = p->m_nRow;
        m_nValue = p->m_nValue;
        m_nVCRow = p->m_nVCRow;
        m_pNext = NULL;
        m_pPrev = NULL;
    }

    CTimingBox( long Row, long Value, long VCRow = ROW_PIN_UNASSIGNED )
    {
        m_nRow = Row;
        m_nValue = Value;
        m_nVCRow = VCRow;
        m_pNext = NULL;
        m_pPrev = NULL;
    }

    CTimingBox * Next( )
    {
        return m_pNext;
    }

};

// a class, but more like a struct, used as an array
//
class CTimingRow
{
    friend class CTimingGrid;
    friend class CTimingCol;

protected:

    bool m_bIsSource;       // does this row represent a source
    bool m_bIsCompatible;   // if this row is a source, is it recompressible
    bool m_bBlank;          // is this row completely blank - for perf reasons
    long m_nEmbedDepth;     // the timeline's embed depth, used for searching the grid
    long m_nModDepth;       // the timeline's modifiied embed depth, used for searching
    long m_nTrack;          // the timeline's track #, used for searching the grid
    long m_nWhichRow;       // which row is this in the row array
    long m_nSwitchPin;      // which switch input pin does this row represent
    long m_nMergeRow;       // used when pruning grid

public:
    CTimingRow( )
    : m_bBlank( true )
    , m_bIsSource( false )
    , m_bIsCompatible( false )
    , m_nTrack( 0 )         // only used for audio functions. Not used for video
    , m_nEmbedDepth( 0 )    // the ACTUAL non-changing embed depth. This value is NEVER used.
    , m_nModDepth( 0 )      // the modified embed depth
    , m_nWhichRow( 0 )
    , m_nSwitchPin( 0 )
    , m_nMergeRow( 0 )
    {
    }
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CTimingCol
{
    CTimingBox * m_pHeadBox;    // a sparse-array (list) of allocated rows
    CTimingBox * m_pTailBox;    // a sparse-array (list) of allocated rows
    CTimingGrid * m_pGrid;

public:

    CTimingCol * m_pNext;       // linked list stuff
    CTimingCol * m_pPrev;       // linked list stuff

    REFERENCE_TIME m_rtStart;   // the start/stop times of this col
    REFERENCE_TIME m_rtStop;

    // this was kept WRONGLY and not used anyway
    //long         m_nBoxCount;   // how many boxes total (for perf reasons)

    // get row box, NULL if none at that row
    CTimingBox *    GetRowBox( long Row );

    // get row box, even if the box is empty
    CTimingBox *    GetRowBoxDammit( long Row );

    // get head box, NULL if none
    CTimingBox *    GetHeadBox( );

    // get tail box, NULL if none
    CTimingBox *    GetTailBox( );

    // get a row box that is at a row earlier than the given row
    CTimingBox *    GetEarlierRowBox( long RowToBeEarlierThan );

    // get a row box that is >= the given row
    CTimingBox *    GetGERowBox( long Row ); // GE = Greater or Equal To

    // add a box with the given row, or replace a box already at that row
    void            AddBox( CTimingBox * Box );

    // split col into two. If SplitTime > the col's stop time, then make a new col
    // and link it in. Return the pointer to the column with the start time = splittime
    bool            Split( REFERENCE_TIME SplitTime, CTimingCol ** ppColWithSplitTime );

    // remove any UNASSIGNED or duplicate OUTPUT row boxes
    bool            Prune( );

#ifdef DEBUG
    void print( );
#endif

    CTimingCol( CTimingGrid * pGrid );
    ~CTimingCol( );
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CTimingGrid
{
    friend class CTimingRow;
    friend class CTimingCol;

    CTimingCol * m_pHeadCol;    // double-linked list
    CTimingCol * m_pTailCol;
    long m_nRows;               // how many rows have been allocated
    CTimingRow * m_pRow;        // the current row we're working with
    long m_nCurrentRow;         // the current row we're working with
    long m_nMaxRowUsed;         // max row used by anybody
    CTimingCol * m_pTempCol;    // used solely for RowGetNextRange
    bool m_bStartNewRow;        // used solely for RowGetNextRange
    long m_nBlankLevel;
    REFERENCE_TIME m_rtBlankDuration;

    long _GetStartRow( long RowToStartAt );
    CTimingCol * _GetColAtTime( REFERENCE_TIME t );

protected:

    CTimingRow * m_pRowArray;   // single-linked list for each row

public:
    CTimingGrid( );
    ~CTimingGrid( );

    bool SetNumberOfRows( long Rows );
    bool PruneGrid();
    void RemoveAnyNonCompatSources( );
    void WorkWithNewRow( long SwitchPin, long RowNumber, long EmbedDepth, long OwnerTrackNumber );
    void WorkWithRow( long RowNumber );
    void DoneWithLayer( );
    void SetBlankLevel( long Layers, REFERENCE_TIME Duration );
    bool RowIAmTransitionNow( REFERENCE_TIME Start, REFERENCE_TIME Stop, long OutPinA, long OutPinB );
    bool RowIAmEffectNow( REFERENCE_TIME Start, REFERENCE_TIME Stop, long OutPin );
    bool PleaseGiveBackAPieceSoICanBeACutPoint( REFERENCE_TIME Start, REFERENCE_TIME Stop, REFERENCE_TIME CutPoint );
    bool RowIAmOutputNow( REFERENCE_TIME Start, REFERENCE_TIME Stop, long OutPin );
    bool RowGetNextRange( REFERENCE_TIME * pInOut, REFERENCE_TIME * pStop, long * pValue );
    void RowSetIsSource( IAMTimelineObj * pSource, BOOL IsCompatible );
    void DumpGrid( );
    CTimingCol * SliceGridAtTime( REFERENCE_TIME Time );
    long MaxMixerTracks( );
    bool XferToMixer( 
        IBaseFilter * pMixer, 
        long OutPin, 
        long MixerPin, 
        REFERENCE_TIME EffectStart, 
        REFERENCE_TIME EffectStop );
    bool DoMix( IBaseFilter * pMixer, long OutPin );
    bool YoureACompNow( long TrackOwner );
    bool IsRowTotallyBlank( );
    long GetRowSwitchPin( );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\deadpool.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: deadpool.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#ifndef __DEADPOOL_H__
#define __DEADPOOL_H__

#define MAX_DEAD 2048

class CDeadGraph : public IDeadGraph
{
    CCritSec m_Lock;

    long m_ID[MAX_DEAD];

    // we don't need to reference count these, since they're stored in a seperate graph
    IPin * m_pStartPin[MAX_DEAD];
    IPin * m_pStopPin[MAX_DEAD];
    IBaseFilter * m_pFilter[MAX_DEAD];
    IBaseFilter * m_pDanglyBit[MAX_DEAD];
    long m_nCount;
    HRESULT m_hrGraphCreate;
    CComPtr< IGraphBuilder > m_pGraph;

    HRESULT _SleepFilter( IBaseFilter * pFilter );
    HRESULT _ReviveFilter( IBaseFilter * pFilter, IGraphBuilder * pGraph );
    HRESULT _RetireAllDownstream( IGraphConfig *pConfig, IBaseFilter *pF);
    HRESULT _ReviveAllDownstream( IGraphBuilder *pGraph, IGraphConfig *pConfig, IBaseFilter *pF);

public:

    CDeadGraph( );
    ~CDeadGraph( );

    // fake out COM
    STDMETHODIMP_(ULONG) AddRef() { return 2; }
    STDMETHODIMP_(ULONG) Release() { return 1; }
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);

    // IDeadGraph
    STDMETHODIMP PutChainToRest( long Identifier, IPin * pStartPin, IPin * pStopPin, IBaseFilter *pDanglyBit );
    STDMETHODIMP PutFilterToRest( long Identifier, IBaseFilter * pFilter );
    STDMETHODIMP PutFilterToRestNoDis( long Identifier, IBaseFilter * pFilter );
    STDMETHODIMP ReviveChainToGraph( IGraphBuilder * pGraph, long Identifier, IPin ** ppStartPin, IPin ** ppStopPin, IBaseFilter **ppDanglyBit );
    STDMETHODIMP ReviveFilterToGraph( IGraphBuilder * pGraph, long Identifier, IBaseFilter ** ppFilter );
    STDMETHODIMP Clear( );
    STDMETHODIMP GetGraph( IGraphBuilder ** ppGraph );
};

#endif // #ifndef __DEADPOOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\grid.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: grid.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "grid.h"
#include "..\util\filfuncs.h"

#define GROW_SIZE 256
#define RENDER_TRACE_LEVEL 5
#define RENDER_DUMP_LEVEL 1
const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;


CTimingCol::CTimingCol( CTimingGrid * pGrid )
: m_rtStart( 0 )
, m_rtStop( 0 )
, m_pNext( NULL )
, m_pPrev( NULL )
, m_pHeadBox( NULL )
, m_pTailBox( NULL )
//, m_nBoxCount( 0 )
, m_pGrid( pGrid )
{
}

CTimingCol::~CTimingCol( )
{
    // delete all the boxes in the list
    //
    CTimingBox * pBox = m_pHeadBox;
    while( pBox )
    {
        CTimingBox * pTemp = pBox;
        pBox = pBox->m_pNext;
        delete pTemp;
    }
}

CTimingBox * CTimingCol::GetRowBox( long Row )
{
    // do a run of the array and see if we have the asked
    // for box at the row. If not, return NULL.
    // !!! to make this faster, we could start at the tail,
    // if we had a clue about the row #'s in our little list
    //
    for( CTimingBox * pBox = m_pHeadBox ; pBox ; pBox = pBox->m_pNext )
    {
        if( pBox->m_nRow == Row )
        {
            // treat unassigned boxes as if they weren't there
            //
            if( pBox->m_nValue == ROW_PIN_UNASSIGNED )
            {
                return NULL;
            }

            return pBox;
        }
        if( pBox->m_nRow > Row )
        {
            return NULL;
        }
    }
    return NULL;
}

CTimingBox * CTimingCol::GetRowBoxDammit( long Row )
{
    // do a run of the array and see if we have the asked
    // for box at the row. If not, return NULL.
    // !!! to make this faster, we could start at the tail,
    // if we had a clue about the row #'s in our little list
    //
    for( CTimingBox * pBox = m_pHeadBox ; pBox ; pBox = pBox->m_pNext )
    {
        if( pBox->m_nRow == Row )
        {
            return pBox;
        }
        if( pBox->m_nRow > Row )
        {
            return NULL;
        }
    }
    return NULL;
}

CTimingBox * CTimingCol::GetGERowBox( long Row )
{
    for( CTimingBox * pBox = m_pHeadBox ; pBox ; pBox = pBox->m_pNext )
    {
        if( pBox->m_nRow >= Row && pBox->m_nValue != ROW_PIN_UNASSIGNED )
        {
            return pBox;
        }
    }
    return NULL;
}

CTimingBox * CTimingCol::GetEarlierRowBox( long RowToBeEarlierThan )
{
    for( CTimingBox * pBox = m_pTailBox ; pBox ; pBox = pBox->m_pPrev )
    {
        if( pBox->m_nRow < RowToBeEarlierThan && pBox->m_nValue != ROW_PIN_UNASSIGNED )
        {
            return pBox;
        }
    }
    return NULL;
}

CTimingBox * CTimingCol::GetHeadBox( )
{
    // treat unassigned boxes as if they weren't there
    // !!! can this cause a bug?
    //
    CTimingBox * pBox = m_pHeadBox;
    while( pBox && pBox->m_nValue == ROW_PIN_UNASSIGNED )
        pBox = pBox->m_pNext;
    return pBox;
}

CTimingBox * CTimingCol::GetTailBox( )
{
    // treat unassigned boxes as if they weren't there
    // !!! can this cause a bug?
    //
    CTimingBox * pBox = m_pTailBox;
    while( pBox && pBox->m_nValue == ROW_PIN_UNASSIGNED )
        pBox = pBox->m_pPrev;
    return pBox;
}

// add a box with the given row, or replace a box that's already there
// this either adds the newly allocated box to the array, or if it's
// already the same row, sets the values and deletes the passed in new box
//
void CTimingCol::AddBox( CTimingBox * b )
{
    //m_nBoxCount++;

    // if we don't already have a head, then this is it
    //
    if( !m_pHeadBox )
    {
        m_pHeadBox = b;
        m_pTailBox = b;
        return;
    }

    // if the same last row, then change it
    //
    if( b->m_nRow == m_pTailBox->m_nRow )
    {
        m_pTailBox->m_nValue = b->m_nValue;
        m_pTailBox->m_nVCRow = b->m_nVCRow;
        //m_nBoxCount--;
        delete b; // don't need it
        return;
    }

    // if the new row is > the last row, just add it
    //
    if( b->m_nRow >= m_pTailBox->m_nRow )
    {
        m_pTailBox->m_pNext = b;
        b->m_pPrev = m_pTailBox;
        m_pTailBox = b;
        return;
    }

    // we need to find where to insert it
    //
    CTimingBox * pBox = m_pTailBox;
    while( pBox && ( b->m_nRow < pBox->m_nRow ) )
    {
        pBox = pBox->m_pPrev;
    }

    // this box we're trying to add is the smallest!
    // Well, our search didn't work very well, did it?
    //
    if( !pBox )
    {
        b->m_pNext = m_pHeadBox;
        m_pHeadBox->m_pPrev = b;
        m_pHeadBox = b;
        return;
    }

    // if the box has the same row, then change it's values
    //
    ASSERT( !( pBox->m_nRow == b->m_nRow ) );
    if( pBox->m_nRow == b->m_nRow )
    {
        pBox->m_nValue = b->m_nValue;
        pBox->m_nVCRow = b->m_nVCRow;
        //m_nBoxCount--;
        delete b; // don't need it
        return;
    }

    // the box needs inserted after pBox
    //
    b->m_pPrev = pBox;
    b->m_pNext = pBox->m_pNext;
    pBox->m_pNext->m_pPrev = b;
    pBox->m_pNext = b;
    return;
}

bool CTimingCol::Split( REFERENCE_TIME SplitTime, CTimingCol ** ppTail )
{
    DbgTimer Timer1( "(grid) CTimingCol::Split" );

    // make a new column
    //
    CTimingCol * pNewCol = new CTimingCol( m_pGrid );
    if( !pNewCol )
    {
        return false;
    }

    if( SplitTime > m_rtStop )
    {
        // faked out. Actually asked us to add a column after us.
        // this CANNOT happen for a col that is not the last one
        // in the list, since all the start/stop times are back to
        // back. Just add a blank one after us.
        //
        pNewCol->m_rtStart = m_rtStop;
        pNewCol->m_rtStop = SplitTime;
    }
    else
    {
        // split the column into two. Copy over all the boxes
        // to the new column
        //
        for( CTimingBox * pBox = m_pHeadBox ; pBox ; pBox = pBox->m_pNext )
        {
            // treat unassigned boxes as if they weren't there
            //
            if( pBox->m_nValue != ROW_PIN_UNASSIGNED )
            {
                CTimingBox * pNewBox = new CTimingBox( pBox );
                if( !pNewBox )
                {
                    delete pNewCol;
                    return false;
                }
                pNewCol->AddBox( pNewBox );
            }
        }

        pNewCol->m_rtStart = SplitTime;
        pNewCol->m_rtStop = m_rtStop;
        m_rtStop = SplitTime;
    }

    // link the new one in
    //
    pNewCol->m_pNext = m_pNext;
    pNewCol->m_pPrev = this;
    if( m_pNext )
    {
        m_pNext->m_pPrev = pNewCol;
    }
    m_pNext = pNewCol;
    *ppTail = pNewCol;

    return true;
}

bool CTimingCol::Prune( )
{
    // go from top to bottom and look for any box that
    // has a VC row. When we find one, follow the VC chain
    // to it's completion and see if there's one MORE
    // output ahead of it, if there is, we can trash
    // this chain.

    for( CTimingBox * pBox = m_pHeadBox ; pBox ; pBox = pBox->m_pNext )
    {

        // didn't go to a vc row, continue
        //
        if( pBox->m_nVCRow == ROW_PIN_UNASSIGNED )
        {
            continue;
        }

        CTimingBox *pTemp1 = pBox;
        long vcrow = pBox->m_nVCRow;

        while( vcrow != ROW_PIN_UNASSIGNED )
        {
            pTemp1 = GetRowBoxDammit(vcrow);

            ASSERT( pTemp1 );
            if( !pTemp1 )
            {
                ASSERT( pTemp1 );
                return false; // shouldn't ever happen
            }

            vcrow = pTemp1->m_nVCRow;

        }

        // there sometimes aren't virtual connected rows all the way through
        // a valid chain (like for audio mixing) so it this chain just stops,
        // it's probably a valid chain, so don't prune it!
        if( pTemp1->m_nValue != ROW_PIN_OUTPUT && pTemp1->m_nValue != ROW_PIN_UNASSIGNED ) {
            continue;
        }

        CTimingBox * pTempStop = pTemp1;
        CTimingBox * pTemp2 = pTemp1->m_pNext;
        bool FoundOut = false;
        while( pTemp2 )
        {
            if( pTemp2->m_nValue == ROW_PIN_OUTPUT )
            {
                FoundOut = true;
                break;
            }

            pTemp2 = pTemp2->m_pNext;
        }

        // if we found another output, we need to blank out
        // this chain
        //
        if( FoundOut )
        {
            pTemp1 = pBox;
            while( pTemp1 )
            {
                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, "in col at time %ld, pruning box at row %ld, VC = %ld", long( m_rtStart/10000), pTemp1->m_nRow, pTemp1->m_nVCRow ) );
                int n = pTemp1->m_nVCRow;
                pTemp1->m_nValue = ROW_PIN_UNASSIGNED;
                pTemp1->m_nVCRow = ROW_PIN_UNASSIGNED;
                if( pTemp1 == pTempStop )
                {
                    break;
                }
                pTemp1 = GetRowBoxDammit(n);
            }
        }

    } // for pBox

    // go through each of the boxes from bottom up and
    // leave out all the duplicate outputs, so we don't have
    // to parse them later
    //
    CTimingBox * pHead = NULL;
    CTimingBox * pTail = NULL;
    long FoundOut = 0;

    for( pBox = m_pTailBox ; pBox ; pBox = pBox->m_pPrev )
    {
        // ignore unassigned ones
        //
        if( pBox->m_nValue == ROW_PIN_UNASSIGNED )
        {
            continue;
        }

        // ignore dups
        //
        if( pBox->m_nValue == ROW_PIN_OUTPUT )
        {
            FoundOut++;
            if( FoundOut > 1 )
            {
//                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, "in col at time %ld, skipping dup out at row %ld", long( m_rtStart/10000), pBox->m_nRow ) );
                continue;
            }
        }

        // add it
        //
        CTimingBox * pNewBox = new CTimingBox( pBox );

        // error condition
        //
        if( !pNewBox )
        {
            while( pHead )
            {
                CTimingBox * t = pHead;
                pHead = pHead->m_pNext;
                delete t;
            }
            return false;
        }
        pNewBox->m_pNext = pHead;
        if( !pTail )
        {
            pTail = pNewBox;
            pHead = pNewBox;
        }
        else
        {
            pHead->m_pPrev = pNewBox;
            pHead = pNewBox;
        }
    }

    // if there wasn't any rows that go to the output,
    // we need to add one now. THIS SHOULD NEVER HAPPEN!
    // (but who knows, right?....)
    //
    if( !FoundOut )
    {
        // if there's an new chain that's already been
        // created, go delete it now
        //
        while( pHead )
        {
            CTimingBox * t = pHead;
            pHead = pHead->m_pNext;
            delete t;
        }

        // create one blank box at row 0, just to keep somebody happy
        //
        pHead = pTail = new CTimingBox( 0, ROW_PIN_OUTPUT );
        if( !pHead )
        {
            return false;
        }

        m_pGrid->m_pRowArray[0].m_bBlank = false;
    }

    // delete old list
    //
    while( m_pHeadBox )
    {
        CTimingBox * t = m_pHeadBox;
        m_pHeadBox = m_pHeadBox->m_pNext;
        delete t;
    }

    m_pHeadBox = pHead;
    m_pTailBox = pTail;

#ifdef DEBUG
    for( pBox = m_pHeadBox ; pBox ; pBox = pBox->m_pNext )
    {
        for( CTimingBox * pBox2 = m_pHeadBox ; pBox2 ; pBox2 = pBox2->m_pNext )
        {
            if( pBox2 == pBox ) continue;

            ASSERT( pBox->m_nValue != pBox2->m_nValue );
        }
    }
#endif

    return true;
}

#ifdef DEBUG
void CTimingCol::print( )
{
    for( CTimingBox * pBox = m_pHeadBox ; pBox ; pBox = pBox->m_pNext )
    {
        DbgLog( ( LOG_TIMING, 1, "box row %d val %d", pBox->m_nRow, pBox->m_nValue ) );
    }
}
#endif

// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

CTimingGrid::CTimingGrid( )
: m_pRowArray( NULL )
, m_pHeadCol( NULL )
, m_pTailCol( NULL )
, m_nRows( 0 )
, m_pRow( NULL )
, m_nCurrentRow( 0 )
, m_nMaxRowUsed( -1 )   // only used in for loops
, m_pTempCol( NULL )
, m_bStartNewRow( true )
, m_nBlankLevel( 0 )
, m_rtBlankDuration( 0 )
{
}

CTimingGrid::~CTimingGrid( )
{
    delete [] m_pRowArray;
    CTimingCol * pCol = m_pHeadCol;
    while( pCol )
    {
        CTimingCol * pTemp = pCol;
        pCol = pCol->m_pNext;
        delete pTemp;
    }
}

void CTimingGrid::DumpGrid( )
{

#ifdef DEBUG
    if (!DbgCheckModuleLevel(LOG_TRACE,RENDER_DUMP_LEVEL))
        return;

#define RENDER_BUFFER_DEBUG_SIZE 512

    DbgLog((LOG_TRACE,RENDER_DUMP_LEVEL,TEXT("              ===========<DUMPGRID>============")));
    TCHAR buf1[2560];
    TCHAR buf2[2560];
    _tcscpy( buf1, TEXT(" ROW   DD  TT  SP  MR  ") ); // safe
    for( CTimingCol * pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
    {
	// sec: limit what we print out, so we don't blow out buffer
        if( _tcslen( buf1 ) > RENDER_BUFFER_DEBUG_SIZE ) // safe
        {
            break;
        }
        wsprintf( buf2, TEXT("%05d "), (long) pCol->m_rtStart / 10000 ); // safe
        _tcscat( buf1, buf2 ); // safe
    }
    DbgLog((LOG_TRACE,RENDER_DUMP_LEVEL,TEXT("%s"), buf1));

    _tcscpy( buf1, TEXT(" ROW   DD  TT  SP  MR  ") );  // safe 
    for( pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
    {
        if( _tcslen( buf1 ) > RENDER_BUFFER_DEBUG_SIZE ) // safe
        {
            break;
        }
        wsprintf( buf2, TEXT("%05d "), (long) pCol->m_rtStop / 10000 ); // safe
        _tcscat( buf1, buf2 ); // safe
    }
    DbgLog((LOG_TRACE,RENDER_DUMP_LEVEL,TEXT("%s"), buf1));


    for( int row = 0 ; row <= m_nMaxRowUsed ; row++ )
    {
        buf1[0] = 0;
        char cc = ' ';
        if( m_pRowArray[row].m_bIsSource )
        {
            cc = '!';
        }
        wsprintf( buf1, TEXT("%04d %c%03d %03d %03d %03d "), row, cc, m_pRowArray[row].m_nModDepth, m_pRowArray[row].m_nTrack, m_pRowArray[row].m_nSwitchPin, m_pRowArray[row].m_nMergeRow ); // safe

        for( CTimingCol * pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
        {
            CTimingBox * pBox = pCol->GetRowBox( row );
            long VCRow = ROW_PIN_UNASSIGNED;
            long Value = ROW_PIN_UNASSIGNED - 1;
            if( pBox )
            {
                Value = pBox->m_nValue;
                VCRow = pBox->m_nVCRow;
            }

            if( Value == ROW_PIN_OUTPUT )
            {
                _tcscpy( buf2, TEXT("   OUT") ); // safe
            }
            else if( Value == -1 )
            {
                _tcscpy( buf2, TEXT("   ...") ); // safe
            }
            else if( Value == -2 )
            {
                _tcscpy( buf2, TEXT("    . ") ); // safe
            }
            else if( Value >= 0 )
            {
                wsprintf( buf2, TEXT("   %03d"), Value ); // safe
            }
            _tcscat( buf1, buf2 ); // safe

            if( _tcslen( buf1 ) > RENDER_BUFFER_DEBUG_SIZE ) // safe
            {
                break;
            }

        } // for pCol

        DbgLog((LOG_TRACE,RENDER_DUMP_LEVEL,TEXT("%s"), buf1));
    }
#endif
}


bool CTimingGrid::PruneGrid( )
{
    DbgLog((LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::PRUNE the grid")));

    // remove duplicate pins which want to go to the output and unassigned
    //
    for( CTimingCol * pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
    {
        bool b = pCol->Prune( );
        if( !b ) return false;
    } // for pCol

    // find the merge rows first
    //
    for( int r = m_nMaxRowUsed ; r >= 1 ; r-- )
    {
        m_pRowArray[r].m_nMergeRow = -1;

        for( int r2 = r - 1 ; r2 >= 0 ; r2-- )
        {
            if( m_pRowArray[r2].m_nSwitchPin == m_pRowArray[r].m_nSwitchPin &&
                   !m_pRowArray[r2].m_bBlank && !m_pRowArray[r].m_bBlank)
            {
                m_pRowArray[r].m_nMergeRow = r2;
            }
        }
    }

    // merge emulated rows back into original row
    //
    for( pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
    {
        for( CTimingBox * pBox = pCol->GetHeadBox( ) ; pBox ; pBox = pBox->Next( ) )
        {
            long r = pBox->m_nRow;
            long v = pBox->m_nValue;
            long vc = pBox->m_nVCRow;
            long MergeRow = m_pRowArray[r].m_nMergeRow;

            // if no merge row, then continue
            //
            if( MergeRow == -1 )
            {
                continue;
            }

            if( MergeRow == r )
            {
                continue;
            }

            if( v == ROW_PIN_UNASSIGNED )
            {
                // who cares
                //
                continue;
            }

            // zero out the old box
            //
            pBox->m_nValue = ROW_PIN_UNASSIGNED;
            pBox->m_nVCRow = ROW_PIN_UNASSIGNED;

            // add in the new box at the right merge row
            //
            CTimingBox * pNewBox = new CTimingBox( MergeRow, v, vc );
            if( !pNewBox )
            {
                return false;
            }

            pCol->AddBox( pNewBox );

        } // while pBox

    } // for pCol

    // if our stuff ended earlier than the set duration, then
    // make a last column with a box in it that goes to output, at row 0,
    // which should be "silence"
    //
    if( m_pTailCol )
    {
        if( m_pTailCol->m_rtStop < m_rtBlankDuration )
        {
            // this will add one extra column at the end, with the
            // start time of the too-short-duration, and the stop time
            // of m_rtBlankDuration
            //
            CTimingCol * pCol = SliceGridAtTime( m_rtBlankDuration );
            if( !pCol )
                return false;
            CTimingBox * pBox = new CTimingBox( 0, ROW_PIN_OUTPUT );
            if( !pBox )
                return false;
            pCol->AddBox( pBox );
            m_pRowArray[0].m_bBlank = false;
        }
    }

    return true;
}

// tell us how many rows we're going to use, so we can allocate an array
// !!! someday, just grow this as needed
//
bool CTimingGrid::SetNumberOfRows( long Rows )
{
    delete [] m_pRowArray;

    m_pRowArray = new CTimingRow[Rows];
    if( !m_pRowArray )
    {
        m_nRows = 0;
        return false;
    }

    m_nRows = Rows;
    m_nCurrentRow = 0;
    m_pRow = &m_pRowArray[0];

    for( int i = 0 ; i < Rows ; i++ )
    {
        m_pRowArray[i].m_nWhichRow = i;
    }

    return true;
}

// the OwnerTrackNumber is the track's priority as defined by it's owner composition
//
void CTimingGrid::WorkWithRow( long Row )
{
    ASSERT( Row < m_nRows );

    m_nCurrentRow = Row;
    m_pRow = &m_pRowArray[Row];
    m_pTempCol = NULL;
    m_bStartNewRow = true;

    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Setting to row %d"), Row ) );
}

void CTimingGrid::WorkWithNewRow( long SwitchPin, long Row, long EmbedDepth, long OwnerTrackNumber )
{
    ASSERT( Row < m_nRows );

    m_nCurrentRow = Row;
    m_pRow = &m_pRowArray[Row];
    m_pRow->m_nEmbedDepth = EmbedDepth;

    // these shouldn't be necessary here
    //
    m_pTempCol = NULL;
    m_bStartNewRow = true;

    m_pRow->m_nSwitchPin = SwitchPin;
    m_pRow->m_nTrack = OwnerTrackNumber;
    m_pRow->m_nModDepth = EmbedDepth;

    if( Row > m_nMaxRowUsed )
    {
        m_nMaxRowUsed = Row;
    }

    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Working with new row %d"), Row ) );
}

bool CTimingGrid::RowIAmOutputNow( REFERENCE_TIME Start, REFERENCE_TIME Stop, long OutPin )
{
    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::RowIAmOutputNow") ) );

    DbgTimer Timer1( "(grid) IAmOutputNow" );

    // this would screw up and create a confusing empty column
    if (Start == Stop)
        return true;

    // error check
    //
    if( !m_pRow )
    {
        return false;
    }

    // don't allow start times less than 0
    //
    if( Start < 0 )
    {
        Start = 0;
    }

    CTimingCol * pSlicedCol;
    pSlicedCol = SliceGridAtTime( Stop );
    if( !pSlicedCol ) return false;
    pSlicedCol = SliceGridAtTime( Start );
    if( !pSlicedCol ) return false;

    for( CTimingCol * pCol = pSlicedCol ; pCol ; pCol = pCol->m_pNext )
    {
        // too early
        //
        if( pCol->m_rtStart < Start )
        {
            continue;
        }

        // too late
        //
        if( pCol->m_rtStart >= Stop )
        {
            break;
        }

        // add a box saying we're the output
        //
        CTimingBox * pNewBox = new CTimingBox( m_nCurrentRow, ROW_PIN_OUTPUT );
        if( !pNewBox ) return false;
        pCol->AddBox( pNewBox );
        m_pRow->m_bBlank = false;

    } // for pCol

    return true;
}

bool CTimingGrid::RowIAmTransitionNow( REFERENCE_TIME Start, REFERENCE_TIME Stop, long OutPinA, long OutPinB )
{
    DbgTimer Timer1( "(grid) IAmTransitionNow" );

    // this would screw up and create a confusing empty column
    if (Start == Stop)
        return true;

    // error check
    //
    if( !m_pRow )
    {
        return false;
    }

    // don't allow start times less than 0
    //
    if( Start < 0 )
    {
        Start = 0;
    }

    CTimingCol * pSlicedCol;
    pSlicedCol = SliceGridAtTime( Stop );
    if( !pSlicedCol ) return false;
    pSlicedCol = SliceGridAtTime( Start );
    if( !pSlicedCol ) return false;

    // find the starting row for the B track
    //
    long TrackBStartRow = _GetStartRow( m_nCurrentRow );

    // find the starting row for the A track
    //
    long StartRow = _GetStartRow( TrackBStartRow - 1 );

    if( m_pRowArray[StartRow].m_nModDepth < m_pRow->m_nModDepth - 1 )
    {
        // too deep! This transition is supposed to happen on top of black!
        //
        StartRow = TrackBStartRow;
    }

    // anybody who thinks they are the output, or one less than the output now needs to be rerouted
    // to the new outputs. However, don't do this for rows which aren't sources.

    for( CTimingCol * pCol = pSlicedCol ; pCol ; pCol = pCol->m_pNext )
    {
        // too early
        //
        if( pCol->m_rtStart < Start )
        {
            continue;
        }

        // too late
        //
        if( pCol->m_rtStart >= Stop )
        {
            break;
        }

        // go see if any of the rows prior to us has a source on it
        //
        bool hassource = false;

        CTimingBox * pEarlierRow = pCol->GetEarlierRowBox( m_nCurrentRow );

        // do this column
        //
        for( CTimingBox * pBox = pEarlierRow ; pBox ; pBox = pBox->m_pPrev )
        {
            long row = pBox->m_nRow;

            if( m_pRowArray[row].m_nModDepth < m_pRow->m_nModDepth )
            {
                break;
            }

            if( m_pRowArray[row].m_bIsSource )
            {
                hassource = true;
                break;
            }

        } // for pBox

        // if we found a source, we can switch things around.  The row with
	// -100 is pin B, and the row closest above it <-100 is pin A. (It
	// might not be -101)
	// row
        //
        if( hassource )
        {
	    long lRow = 0;

            bool AssignedA = false;
            bool AssignedB = false;

            for( CTimingBox * pBox = pEarlierRow ; pBox ; pBox = pBox->m_pPrev )
            {
                long v = pBox->m_nValue;
                long r = pBox->m_nRow;

                // don't go looking past our master composition (parent)
                //
                if( r < StartRow )
                {
                    break;
                }

		// A transition MUST act on one thing from this embed depth
		// and one thing BEFORE it
                if( !AssignedA && ( lRow && v == ROW_PIN_OUTPUT && m_pRowArray[r].m_nModDepth < m_pRowArray[lRow].m_nModDepth ) )
                {
                    AssignedA = true;

                    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::sending row %d from %d to %d at time %d"), r, v, OutPinA, long( pCol->m_rtStart / 10000 ) ) );
                    pBox->m_nValue = OutPinA;
		    // Once going out OutPinA, it will come back to the
		    // switch via input pin #m_nCurrentRow
                    pBox->m_nVCRow = m_nCurrentRow;
		    break;
                }
                if( !AssignedB && ( v == ROW_PIN_OUTPUT ) )
                {
                    AssignedB = true;

                    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::sending row %d from %d to %d at time %d"), r, v, OutPinB, long( pCol->m_rtStart / 10000 ) ) );
                    pBox->m_nValue = OutPinB;
		    // Once going out OutPinB, it will come back to the
		    // switch via input pin #m_nCurrentRow
	    	    pBox->m_nVCRow = m_nCurrentRow;
		    lRow = r;	// the row going to input #2 of trans
		    ASSERT(lRow > 0);
                }

                if( AssignedA && AssignedB )
                {
                    break;
                }

            } // for pBox

            // if we didn't find a box, that means we probably ended up in no-man's land
            //
            ASSERT( AssignedB );

            if( !AssignedA )
            {
                // well SOMETHING needs to go to the effect! Find the earliest unassigned row
                //
                pBox = pCol->GetHeadBox( );
                ASSERT( pBox );

                // no box? Well make one at the last blank layer
                //
                long BlankRow;
                if( pBox == NULL )
                {
                    BlankRow = m_nBlankLevel - 1;
                }
                else
                {
                    BlankRow = pBox->m_nRow - 1;
                    if( BlankRow >= m_nBlankLevel )
                    {
                        BlankRow = m_nBlankLevel - 1;
                    }
                }

                // we need a box earlier than this box and direct it to us
                //
                ASSERT( BlankRow >= 0 );
                CTimingBox * pNewBox = new CTimingBox( BlankRow, OutPinA, m_nCurrentRow );
                if( !pNewBox ) return false;
                pCol->AddBox( pNewBox );
                m_pRowArray[ BlankRow ].m_bBlank = false;
            }

            CTimingBox * pNewBox = new CTimingBox( m_nCurrentRow, ROW_PIN_OUTPUT );
            if( !pNewBox ) return false;
            pCol->AddBox( pNewBox );
            m_pRow->m_bBlank = false;

        } // if we found a source

    } // for pCol

    return true;
}

// this function should scan from the 'start' row all the way to the current row. For layers,
// its the layer start row, for sources, it's the source's start row, but since effect times on
// sources are bounded, it doesn't make any difference
//
bool CTimingGrid::RowIAmEffectNow( REFERENCE_TIME Start, REFERENCE_TIME Stop, long OutPin )
{
    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::RowIAmEffectNow"), long(Start/10000), long(Stop/10000) ) );
    DbgTimer Timer1( "(grid) IAmEffectNow" );

    // this would screw up and create a confusing empty column
    if (Start == Stop)
        return true;

    // error check
    //
    if( !m_pRow )
    {
        return false;
    }

    // don't allow start times less than 0
    //
    if( Start < 0 )
    {
        Start = 0;
    }

    CTimingCol * pSlicedCol;
    pSlicedCol = SliceGridAtTime( Stop );
    if( !pSlicedCol ) return false;
    pSlicedCol = SliceGridAtTime( Start );
    if( !pSlicedCol ) return false;

    // since we are an effect with the same embed depth on the current row as all the rest
    // preceding us, we call GetStartRow , which means, "start at current row and go
    // backwards looking for a lesser embed depth than us"
    //
    long StartRow = _GetStartRow( m_nCurrentRow );

    // anybody who thinks they are the output, or one less than the output now needs to be rerouted
    // to the new outputs. However, don't do this for rows which aren't sources.

    for( CTimingCol * pCol = pSlicedCol ; pCol ; pCol = pCol->m_pNext )
    {
        // too early
        //
        if( pCol->m_rtStart < Start )
        {
            continue;
        }

        // too late
        //
        if( pCol->m_rtStart >= Stop )
        {
            break;
        }

        bool hassource = false;

        CTimingBox * pEarlierBox = pCol->GetEarlierRowBox( m_nCurrentRow );

        // do this column
        //
        for( CTimingBox * pBox = pEarlierBox ; pBox ; pBox = pBox->m_pPrev )
        {
            long row = pBox->m_nRow;

            if( row < StartRow )
            {
                break;
            }

            if( m_pRowArray[row].m_nModDepth < m_pRow->m_nModDepth )
            {
                break;
            }

            if( m_pRowArray[row].m_bIsSource )
            {
                hassource = true;
                break;
            }

        } // for pBox

        // if we found a source, we can switch things around
        //
        if( hassource )
        {
            bool Assigned = false;
            bool AlreadyAssigned = false;

            for( CTimingBox * pBox = pCol->GetTailBox( ) ; pBox ; pBox = pBox->m_pPrev )
            {
                long v = pBox->m_nValue;
                long r = pBox->m_nRow;

                // don't go looking past our master composition (parent)
                //
                if( r < StartRow ) // this should never happen?
                {
                    break;
                }

                if( r != m_nCurrentRow )
                {
                    if( v == ROW_PIN_OUTPUT )
                    {
                        DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::sending row %d from %d to %d at time %d"), r, v, OutPin, long( pCol->m_rtStart / 10000 ) ) );

                        pBox->m_nValue = OutPin;
			// Once going out OutPin, it will come back to the
			// switch via input pin #m_nCurrentRow
	    		pBox->m_nVCRow = m_nCurrentRow;

                        Assigned = true;

                        // no more rows can be affected, break
                        //
                        break;
                    }
                    else
                    {
                        // Is it already assigned to the outpin?
                        //
                        if( v == OutPin )
                        {
                            Assigned = true;
                            AlreadyAssigned = true;
                            break;
                        }
                    }
                }

            } // for pBox

            if( !Assigned )
            {
                // well SOMETHING needs to go to the effect! Find the earliest unassigned row
                //
                pBox = pCol->GetHeadBox( );
                ASSERT( pBox );

                // no box? Well make one at the last blank layer
                //
                long BlankRow;
                if( pBox == NULL )
                {
                    BlankRow = m_nBlankLevel - 1;
                }
                else
                {
                    BlankRow = pBox->m_nRow - 1;
                    if( BlankRow >= m_nBlankLevel )
                    {
                        BlankRow = m_nBlankLevel - 1;
                    }
                }

                // we need a box earlier than this box and direct it to us
                //
                ASSERT( BlankRow >= 0 );
                CTimingBox * pNewBox = new CTimingBox( BlankRow, OutPin, m_nCurrentRow );
                if( !pNewBox ) return false;
                pCol->AddBox( pNewBox );
                m_pRowArray[ BlankRow ].m_bBlank = false;
            }

            if( !AlreadyAssigned )
            {
                CTimingBox * pNewBox = new CTimingBox( m_nCurrentRow, ROW_PIN_OUTPUT );
                if( !pNewBox ) return false;
                pCol->AddBox( pNewBox );
                m_pRow->m_bBlank = false;
            }

        } // if we found a source

    } // for pCol

    return true;
}

// if the user passes in -1, -1, it will give the first start/stop, like 0-2. If the user passes in
// 0-2, we'll pass back 2-4. If the end is 4-6, and the user passes in 4-6, we'll pass back 6-6
//
bool CTimingGrid::RowGetNextRange( REFERENCE_TIME * pInOut, REFERENCE_TIME * pStop, long * pValue )
{
    // this happens once in a while. A -1 means the same thing
    // as starting a new row
    //
    if( *pInOut == -1 )
    {
        m_pTempCol = NULL;
        m_bStartNewRow = true;
    }

    if( !m_pRow )
    {
        return false;
    }
    if( m_bStartNewRow )
    {
        m_bStartNewRow = false;
        m_pTempCol = m_pHeadCol;
        ASSERT( *pInOut <= 0 );
    }
    if( !m_pTempCol )
    {
        *pInOut = *pStop;
        return true;
    }

    CTimingCol * pCol = m_pTempCol;

    // this is the box with the value we're looking for
    //
    CTimingBox * pBox = pCol->GetRowBox( m_nCurrentRow );
    long Value = ROW_PIN_UNASSIGNED;
    if( pBox )
    {
        Value = pBox->m_nValue;
    }

    CTimingCol * pCol2 = pCol;

    while( 1 )
    {
        CTimingCol * pColTemp = pCol2;
        pCol2 = pCol2->m_pNext;

        if( !pCol2 )
        {
            *pValue = Value;
            m_pTempCol = NULL;

            // if we found NOTHING, then return as if completely blank
            //
            if( Value == ROW_PIN_UNASSIGNED && pCol == m_pHeadCol )
            {
                *pInOut = *pStop;
                return true;
            }
            else
            {
                *pInOut = pCol->m_rtStart;
                *pStop = pColTemp->m_rtStop;
            }

            return true;
        }

        pBox = pCol2->GetRowBox( m_nCurrentRow );
        long Value2 = ROW_PIN_UNASSIGNED;
        if( pBox )
        {
            Value2 = pBox->m_nValue;
        }

        if( Value != Value2 )
        {
            *pInOut = pCol->m_rtStart;
            *pStop = pColTemp->m_rtStop;
            *pValue = Value;
            m_pTempCol = pColTemp->m_pNext;
            return true;
        }
    }

    return true;
}

bool CTimingGrid::PleaseGiveBackAPieceSoICanBeACutPoint(
    REFERENCE_TIME Start,
    REFERENCE_TIME Stop,
    REFERENCE_TIME CutPoint )
{
    // this would screw up and create a confusing empty column
    if (Start == Stop)
        return true;

    // error check
    //
    if( !m_pRow )
    {
        return false;
    }

    // don't allow start times less than 0
    //
    if( Start < 0 )
    {
        Start = 0;
    }

    CTimingCol * pSlicedCol;
    pSlicedCol = SliceGridAtTime( Stop );
    if( !pSlicedCol ) return false;
    pSlicedCol = SliceGridAtTime( CutPoint );
    if( !pSlicedCol ) return false;
    pSlicedCol = SliceGridAtTime( Start );
    if( !pSlicedCol ) return false;

    for( CTimingCol * pCol = pSlicedCol ; pCol ; pCol = pCol->m_pNext )
    {
        // too early
        //
        if( pCol->m_rtStart < Start )
        {
            continue;
        }

        // too late
        //
        if( pCol->m_rtStart >= Stop )
        {
            break;
        }

        bool FoundFirst = false;
        bool FoundSecond = false;

        // do this column
        //
        for( CTimingBox * pBox = pCol->GetTailBox( ) ; pBox ; pBox = pBox->m_pPrev )
        {
            long v = pBox->m_nValue;

            if( pCol->m_rtStart < CutPoint )
            {
                if( v == ROW_PIN_OUTPUT )
                {
                    if( !FoundFirst )
                    {
                        FoundFirst = true;
                        pBox->m_nValue = ROW_PIN_UNASSIGNED;
                    }
                    else if( !FoundSecond )
                    {
                        FoundSecond = true;
                    }
                    else
                    {
                        // found both of them, we're done
                        //
                        break;
                    }
                }
            }
            else
            {
                if( v == ROW_PIN_OUTPUT )
                {
                    if( !FoundFirst )
                    {
                        FoundFirst = true;
                    }
                    else if( !FoundSecond )
                    {
                        FoundSecond = true;
                        pBox->m_nValue = ROW_PIN_UNASSIGNED;
                    }
                    else
                    {
                        break;
                    }
                }
            }

        } // for pBox

    } // for pCol

    return true;

}

void CTimingGrid::RowSetIsSource( IAMTimelineObj * pSource, BOOL IsCompatible )
{
    DbgLog((LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::RowSetIsSource, row = %d, IsCompat = %d"), m_nCurrentRow, IsCompatible ));

    if( !m_pRow )
    {
        return;
    }

    m_pRow->m_bIsSource = true;
    m_pRow->m_bIsCompatible = ( IsCompatible == TRUE );
}

CTimingCol * CTimingGrid::_GetColAtTime( REFERENCE_TIME t )
{
    if( t > m_pTailCol->m_rtStop / 2 ) // look backwards
    {
        for( CTimingCol * pCol = m_pTailCol ; pCol ; pCol = pCol->m_pPrev )
        {
            if( t >= pCol->m_rtStart )
            {
                return pCol;
            }
        }
        return m_pHeadCol;
    }
    else
    {
        for( CTimingCol * pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
        {
            if( t < pCol->m_rtStop )
            {
                return pCol;
            }
        }
        return m_pTailCol;
    }
}

CTimingCol * CTimingGrid::SliceGridAtTime( REFERENCE_TIME t )
{
    if( !m_pHeadCol )
    {
        CTimingCol * pCol = new CTimingCol( this );
        if( !pCol )
        {
            return NULL;
        }
        pCol->m_rtStart = 0;
        pCol->m_rtStop = t;

        m_pHeadCol = pCol;
        m_pTailCol = pCol;

        return pCol;
    }

    // if we're over, slice the last one and return
    //
    if( t > m_pTailCol->m_rtStop )
    {
        CTimingCol * pTail = NULL;
        bool ret = m_pTailCol->Split( t, &pTail );
        if( !ret ) return NULL;
        m_pTailCol = pTail;
        return pTail;
    }

    // gets the col that spans t or if t is > the max time,
    // get the last column
    //
    CTimingCol * pCol = _GetColAtTime( t );

    // we test for Stop == t because we've been asked to slice
    // the grid at this time. I've arranged the code so that nothing
    // will use the returned Col as if it has the start time of t when
    // this happens
    //
    if( pCol->m_rtStart == t || pCol->m_rtStop == t )
    {
        return pCol;
    }

    // we need to split a column that already exists
    //
    CTimingCol * pColDesired = NULL;
    bool ret = pCol->Split( t, &pColDesired );
    if( !ret ) return NULL;
    if( pCol == m_pTailCol )
    {
        m_pTailCol = pColDesired;
    }
    return pColDesired;
}

void CTimingGrid::DoneWithLayer( )
{
    DbgTimer Timer1( "(grid) DoneWithLayer" );

    long CurrentEmbedDepth = m_pRow->m_nModDepth;
    for( long i = m_nCurrentRow - 1 ; i >= 0 ; i-- )
    {
        if( m_pRowArray[i].m_nModDepth < CurrentEmbedDepth )
        {
            break;
        }
        if( m_pRowArray[i].m_nModDepth > 0 )
        {
            m_pRowArray[i].m_nModDepth--;
        }
    }
    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::DoneWithLayer, going back to layer %d"), i + 1 ) );
    if( m_pRow->m_nModDepth > 0 )
    {
        m_pRow->m_nModDepth--;
    }
}

// get the starting row in the grid of the composition encompasing the current row
//
long CTimingGrid::_GetStartRow( long StartRow )
{
    // go find the first row (backwards) that doesn't have the same ModDepth as the first one
    //
    for( int i = StartRow ; i >= 0 ; i-- )
    {
        if( m_pRowArray[i].m_nModDepth != m_pRowArray[StartRow].m_nModDepth )
        {
            break;
        }
    }
    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::GetStartRow=%d"), i + 1 ) );
    return i + 1;
}

// return the maximum amount of tracks that need to be mixed for the current
// group of tracks that the last row in the grid is referencing. This will normally
// be a composition's entire group of tracks
//
long CTimingGrid::MaxMixerTracks( )
{
    DbgTimer Timer1( "(grid) MaxMixerTracks" );

    // since this is a mix on a composition, we want to start one row back to find beginning,
    // a composition has a last (current) row in the grid with a LESSER embed depth than those
    // that precede it, but we want to find the starting row in the grid for all tracks that
    // this composition used.
    //
    long StartRow = _GetStartRow( m_nCurrentRow - 1 );
    long MaxTracks = 0;

    for( CTimingCol * pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
    {
        // do this column
        //
        long Tracks = 0;
        for( CTimingBox * pBox = pCol->GetEarlierRowBox( m_nCurrentRow ) ; pBox ; pBox = pBox->m_pPrev )
        {
            if( pBox->m_nRow < StartRow )
            {
                break;
            }

            // get the output pin this row/column is assigned to
            //
            long v = pBox->m_nValue;

            // there is overlap (and the need to mix) only if the first output value is < -100
            //
            if( v == ROW_PIN_OUTPUT )
            {
                Tracks++;
            }

        } // for pBox

        if( Tracks > MaxTracks )
        {
            MaxTracks = Tracks;
        }

    } // for pCol

    return MaxTracks;
}

bool CTimingGrid::DoMix( IBaseFilter * pMixer, long OutPin )
{
    {
        DbgTimer Timer1( "(grid) DoMix start" );
    }

    DbgTimer Timer1( "(grid) DoMix" );

    // since this is a mix on a composition, we want to start one row back to find beginning,
    // a composition has a last (current) row in the grid with a LESSER embed depth than those
    // that precede it, but we want to find the starting row in the grid for all tracks that
    // this composition used.
    //
    long StartRow = _GetStartRow( m_nCurrentRow - 1 );

    // now go through each of the rows and connect up unassigned outputs to the mixer inputs

    // flag that we don't need a mixer yet.
    //
    bool NeedMix = false;
    for( CTimingCol * pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
    {
        // if this isn't true, look for a mixer need PER COLUMN. If it's
        // defined, then once a mixer is put in, it stays for the rest of the track
        //
        NeedMix = false;
        long TracksWithOutput = 0;

        CTimingBox * pStartRowBox = pCol->GetGERowBox( StartRow );
        CTimingBox * pBox;

        if( !NeedMix )
        {
            for( pBox = pStartRowBox ; pBox ; pBox = pBox->Next( ) )
            {
                // get the output pin this row/column is assigned to
                //
                long v = pBox->m_nValue;

                // we need to mix if two rows go to the output
                //
                if( v == ROW_PIN_OUTPUT )
                {
                    TracksWithOutput++;
                    if( TracksWithOutput > 1 )
                    {
                        NeedMix = true;
                        DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Need mix because %d rows go to OUT at time %d"), TracksWithOutput, pCol->m_rtStart ) );
                    }
                }

            } // for pBox
        }

        if( !NeedMix )
        {
            continue;
        }

        // we need to mix, so set the mixer's output pin to be active in this
        // segment
        //
        DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Sending the mixer's output pin...") ) );

        CTimingBox * pNewBox = new CTimingBox( m_nCurrentRow, ROW_PIN_OUTPUT );
        if( !pNewBox ) return false;
        pCol->AddBox( pNewBox );
        m_pRow->m_bBlank = false;

        for( pBox = pStartRowBox ; pBox ; pBox = pBox->Next( ) )
        {
            long r = pBox->m_nRow;
            long v = pBox->m_nValue;

            if( r >= m_nCurrentRow )
            {
                break;
            }

            // if it went to an output, now it goes to a mixer input pin,
            // which is determined by which track the layer was on
            //
            if( v == ROW_PIN_OUTPUT )
            {
                long mi = m_pRowArray[r].m_nTrack;
                pBox->m_nValue = OutPin + mi;
                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Pin %d redirected to mixer input %d"), r, mi ) );
                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("    .... from time %d to time %d"), long( pCol->m_rtStart / 10000 ), long( pCol->m_rtStop / 10000 ) ) );

                // need to inform the pin itself about the output range. Hacky, but it works, I guess
                //
                IPin * pPin = GetInPin( pMixer, mi );
                ASSERT( pPin );
                CComQIPtr< IAudMixerPin, &IID_IAudMixerPin > pMixerPin( pPin );
                ASSERT( pMixerPin );
                pMixerPin->ValidateRange( pCol->m_rtStart, pCol->m_rtStop );
                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Validated the range on mixer pin %d from time %d to %d"), mi, long( pCol->m_rtStart / 10000 ), long( pCol->m_rtStop / 10000 ) ) );
            }

        } // for pBox

    } // for pCol

    return true;
}

bool CTimingGrid::YoureACompNow( long TrackPriorityOfComp )
{
    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Calling YoureACompNow") ) );
    DbgTimer Timer1( "(grid) YoureACompNow" );

    // since this is a mix on a composition, we want to start one row back to find beginning,
    // a composition has a last (current) row in the grid with a LESSER embed depth than those
    // that precede it, but we want to find the starting row in the grid for all tracks that
    // this composition used.
    //
    long StartRow = _GetStartRow( m_nCurrentRow - 1 );

    // now go through each of the rows and connect up unassigned outputs to the mixer inputs
    //
    for( CTimingCol * pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
    {
        for( CTimingBox * pBox = pCol->GetGERowBox( StartRow ) ; pBox ; pBox = pBox->Next( ) )
        {
            long r = pBox->m_nRow;
            if( r >= m_nCurrentRow )
            {
                break;
            }

            // get the output pin this row/column is assigned to
            //
            long v = pBox->m_nValue;

            if( v == ROW_PIN_OUTPUT )
            {
                m_pRowArray[r].m_nTrack = TrackPriorityOfComp;
                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Row %d is an OUTPUT at time %d, now has new Track priority of %d"), r, pCol->m_rtStart, TrackPriorityOfComp ) );
            }

        } // for pBox

    } // for pCol;

    return true;
}

// if a waveform envelope is needed on a pin, it is sent to the mixer's pin immediately
// instead of being directed to the normal "output" pin. DoMix could be called later,
// but since it's already been sent to the Mixer Pin, DoMix is happy and ignores it. This
// combination makes both Wave Envelopes and mixing logic work together in peace and harmoney.
// this code is almost exactly like DoMix, except it will direct ONE pin to the mixer, not
// any of them that match.
//
bool CTimingGrid::XferToMixer(
                                 IBaseFilter * pMixer,
                                 long OutPin,
                                 long Track,
                                 REFERENCE_TIME EffectStart,
                                 REFERENCE_TIME EffectStop )
{
    DbgTimer Timer1( "(grid) XferToMixer" );

    // since this is a mix on a composition, we want to start one row back to find beginning,
    // a composition has a last (current) row in the grid with a LESSER embed depth than those
    // that precede it, but we want to find the starting row in the grid for all tracks that
    // this composition used.
    //
    long StartRow = _GetStartRow( m_nCurrentRow - 1 );

    bool SetRange = false;

    for( CTimingCol * pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
    {
        for( CTimingBox * pBox = pCol->GetGERowBox( StartRow ) ; pBox ; pBox = pBox->Next( ) )
        {
            long r = pBox->m_nRow;
            if( r >= m_nCurrentRow )
            {
                break;
            }

            // if this row isn't the same track, then we don't care about it
            //
            if( m_pRowArray[r].m_nTrack != Track )
            {
                continue;
            }

            long MixerInput = m_pRowArray[r].m_nTrack;

            // get the output pin this row/column is assigned to
            //
            long v = pBox->m_nValue;

            // if it wanted to go to an output of some priority, too bad, now it goes to the mixer
            //
            if( v == ROW_PIN_OUTPUT )
            {
                HRESULT hr;

                // need to inform the pin itself about the output range. Hacky, but it works, I guess
                //
                IPin * pPin = GetInPin( pMixer, MixerInput );
                ASSERT( pPin );
                CComQIPtr< IAudMixerPin, &IID_IAudMixerPin > pMixerPin( pPin );
                ASSERT( pMixerPin );

                if( !SetRange )
                {
                    if( EffectStart != -1 )
                    {
                        hr = pMixerPin->SetEnvelopeRange( EffectStart, EffectStop );
                    }
                    SetRange = true;
                }

                // tell the grid's track it goes to the mixer now
                //
                pBox->m_nValue = OutPin + MixerInput;

                CTimingBox * pNewBox = new CTimingBox( m_nCurrentRow, ROW_PIN_OUTPUT );
                if( !pNewBox ) return false;
                pCol->AddBox( pNewBox );
                m_pRow->m_bBlank = false;

                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Pin %d redirected to mixer input %d"), r, MixerInput ) );
                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("    .... from time %d to time %d"), long( pCol->m_rtStart / 10000 ), long( pCol->m_rtStop / 10000 ) ) );

                hr = pMixerPin->ValidateRange( pCol->m_rtStart, pCol->m_rtStop );
                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Validated the range on mixer pin %d from time %d to %d"), MixerInput, long( pCol->m_rtStart / 10000 ), long( pCol->m_rtStop / 10000 ) ) );
            }

        } // for pBox

    } // for pCol

    return true;
}

void CTimingGrid::RemoveAnyNonCompatSources( )
{
    DbgLog((LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::Remove any non-compat sources")));
    DbgTimer Timer1( "(grid) RemoveAnyNonCompat" );

    long col = 0;
    for( CTimingCol * pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
    {
        DbgLog((LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::looking at column %d, time = %d"), col++, pCol->m_rtStart ));
        bool FoundARowWithOutput = false;

        for( CTimingBox * pBox = pCol->GetHeadBox( ) ; pBox ; pBox = pBox->Next( ) )
        {
            long r = pBox->m_nRow;
            long v = pBox->m_nValue;

            // found the row with the output
            if( v == ROW_PIN_OUTPUT )
            {
                DbgLog((LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("  for this column, row %d has the output"), r ));

                FoundARowWithOutput = true;

                // if this row isn't a (compat) source, then this column isn't
                // active for a compressed switch
                if( !m_pRowArray[r].m_bIsSource || !m_pRowArray[r].m_bIsCompatible )
                {
                    if( !m_pRowArray[r].m_bIsCompatible )
                    {
                        DbgLog((LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("  this output row is not compatible")));
                    }
                    if( !m_pRowArray[r].m_bIsSource )
                    {
                        DbgLog((LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("  this output row is not a source")));
                    }

                    // wipe out this column. NOTHING goes to the output in this
                    // section
                    CTimingBox * pBox2 = pCol->GetHeadBox( );
                    while( pBox2 )
                    {
                        pBox2->m_nValue = ROW_PIN_UNASSIGNED;
                        pBox2 = pBox2->Next( );
                    }

                    break;
                }
                else
                {
                    DbgLog((LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("  this output row is a compatible source")));
                }

                // well we ARE a compat source and we go to the output. However, NOTHING
                // else in the grid for this column is allowed to go anywhere
                CTimingBox * pBox2 = pCol->GetHeadBox( );
                while( pBox2 )
                {
                    if( pBox2->m_nRow != pBox->m_nRow )
                    {
                        pBox2->m_nValue = ROW_PIN_UNASSIGNED;
                    }
                    pBox2 = pBox2->Next( );
                }

                break;

            } // if v = OUTPUT

        } // for pBox


        // if we didn't find SOME row with an output, then set the whole column to
        // nothing. This should never happen, but deal with it anyhow, for completeness.
        //
        if( !FoundARowWithOutput )
        {
            DbgLog((LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("  this column didn't have an output row anywhere")));

            for( CTimingBox * pBox = pCol->GetHeadBox( ) ; pBox ; pBox = pBox->Next( ) )
            {
                pBox->m_nValue = ROW_PIN_UNASSIGNED;
            }
        }

    } // for pCol

    // set flag for rows that are really blank
    //
    for( int r = 0; r <= m_nMaxRowUsed ; r++ )
    {
        bool Blank = true;

        for( CTimingCol * pCol = m_pHeadCol ; pCol ; pCol = pCol->m_pNext )
        {
            CTimingBox * pBox = pCol->GetRowBox( r );
            if( pBox )
            {
                if( pBox->m_nValue == ROW_PIN_OUTPUT )
                {
                    Blank = false;
                    break;
                }
            }
        }
        m_pRowArray[r].m_bBlank = Blank;
        if( Blank )
        {
            DbgLog((LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("RENDG::The row %d is completely blank now"), r ));
        }
    }
}

bool CTimingGrid::IsRowTotallyBlank( )
{
    if( !m_pRow )
    {
        return false;
    }
    return m_pRow->m_bBlank;
}

long CTimingGrid::GetRowSwitchPin( )
{
    return m_pRow->m_nSwitchPin;
}

void CTimingGrid::SetBlankLevel( long Layers, REFERENCE_TIME Duration )
{
    m_nBlankLevel = Layers;
    m_rtBlankDuration = Duration;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\dexhelp.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dexhelp.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "..\errlog\cerrlog.h"
#include "..\render\deadpool.h"

HRESULT MakeSourceFilter(
                        IUnknown **ppVal, 
                        const WCHAR* szMediaName,
                        const GUID *pSubObjectGuid, 
                        AM_MEDIA_TYPE *pmt, 
                        CAMSetErrorLog *pErr,
                        WCHAR * pMedLocFilterString,
                        long MedLocFlags,
                        IMediaLocator * pChain );

HRESULT BuildSourcePart(
                        IGraphBuilder *pGraph, 
	                BOOL fSource, 		// real source, or blk/silence?
                        double sfps, 		// source fps
                        AM_MEDIA_TYPE *pMT, 	// source MT
                        double fps,		// group fps
	                long StreamNumber, 	
                        int nStretchMode, 
                        int cSkew, 		// to program skewer with
                        STARTSTOPSKEW *pSkew,
	                CAMSetErrorLog *pErr, 
                        BSTR bstrName, 		// source name or
                        const GUID * SourceGuid,// source filter clsid
			IPin *pSplitterSource,	// src is this unc split pin
                        IPin **ppOutput,	// returns chain output
                        long UniqueID,		// source GenID
                        IDeadGraph * pCache,	// pull from this cache
                        BOOL InSmartRecompressGraph,
                        WCHAR * pMedLocFilterString,
                        long MedLocFlags,
                        IMediaLocator * pChain,
			IPropertySetter *pSetter,  	// props for the source
			IBaseFilter **ppDanglyBit);	// start of unused chain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\rencache.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: rencache.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "grid.h"
#include "deadpool.h"
#include "..\errlog\cerrlog.h"
#include "..\util\filfuncs.h"
#include "IRendEng.h"
#include "dexhelp.h"

const long THE_OUTPUT_PIN = -1;

// in this function, we're taking a GRAPH which has certain filters in it which
// were built by the render engine, and we're going to strip them out of the
// graph and put them in the dead place.

HRESULT CRenderEngine::_LoadCache( )
{
    DbgLog((LOG_TRACE,1, "RENcache::Loading up the cache, there are %d old groups", m_nLastGroupCount ));

    HRESULT hr = 0;

#ifdef DEBUG
    long t1 = timeGetTime( );
#endif

    // go through every switch and pull off all the sources and 
    // stick them in the dead pool. Also, disconnect other things connected
    //
    for( int i = 0 ; i < m_nLastGroupCount ; i++ )
    {
        IBigSwitcher * pSwitch = m_pSwitcherArray[i];
        CComQIPtr< IBaseFilter, &IID_IBaseFilter > pFilter( pSwitch );

        // how many input pins does this switch have? Ask it!
        //
        long InPins = 0;
        pSwitch->GetInputDepth( &InPins );

        // pull off each source string connected to an input pin
        //
        for( int in = 0 ; in < InPins ; in++ )
        {
            // get the input pin
            //
            CComPtr<IPin> pPin;
            pSwitch->GetInputPin(in, &pPin);
            ASSERT(pPin);

            CComPtr< IPin > pConnected = NULL;
            hr = pPin->ConnectedTo( &pConnected );

            if( !pConnected )
            {
                continue;
            }

            // disconnect all input pins
            //
            hr = pConnected->Disconnect( );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                return hr;
            }

            hr = pPin->Disconnect( );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                return hr;
            }

            // ask switch if the pin is a source
            //
            BOOL IsSource = FALSE;
            pSwitch->IsInputASource( in, &IsSource );

            if( !IsSource )
            {
                continue;
            }

            // pull it out and put it in the dead pool
            //
            // how do we get the source ID for this filter chain?
            // we need the source filter's ID to identify this chain later
            CComPtr< IBaseFilter > pSourceFilter = GetStartFilterOfChain( pConnected );

	    // This chain may have an appendage to be a shared source with
	    // group 1.  If so, disconnect the appendage from the switch, so
	    // we can put both chains into the cache.
	    //
	    IBaseFilter *pDanglyBit = NULL;
	    if (i == 0) {
            	CComPtr<IAMTimelineObj> pGroupObj;
		hr = m_pTimeline->GetGroup(&pGroupObj, 1);
		if (hr == S_OK) {	// maybe there isn't a group 1
        	    CComQIPtr<IAMTimelineGroup, &IID_IAMTimelineGroup>
							pGroup(pGroupObj);
        	    CComQIPtr<IBaseFilter, &IID_IBaseFilter>
						pSwitch(m_pSwitcherArray[1]);
		    AM_MEDIA_TYPE mt;
		    if (pGroup) {
		        hr = pGroup->GetMediaType(&mt);
		        ASSERT(hr == S_OK);
		    }
		    hr = DisconnectExtraAppendage(pSourceFilter, &mt.majortype,
							pSwitch, &pDanglyBit);
		}
	    }	

            // look up the source filter's unique ID based on the filter #
            //
            long SourceID = 0;
            SourceID = GetFilterGenID( pSourceFilter );
            if( SourceID != 0 )
            {
                hr = m_pDeadCache->PutChainToRest( SourceID, NULL, pConnected, pDanglyBit );
                DbgLog((LOG_TRACE,1, "RENcache::pin %ld's source (%ld) put to sleep", in, SourceID ));
                if( FAILED( hr ) )
                {
                    return hr;
		}
            }
            else
            {
                DbgLog((LOG_TRACE,1, "RENcache::pin %ld was a non-tagged source", in ));
            }

        } // for each input pin on the switch

        // for each output on the switch
        //
        long OutPins = 0;
        pSwitch->GetOutputDepth( &OutPins );

        // pull off everything on the output, except the 0th pin, and throw them away
        //
        for( int out = 1 ; out < OutPins ; out++ )
        {
            // get the output pin
            //
            CComPtr<IPin> pPin;
            pSwitch->GetOutputPin( out, &pPin );
            ASSERT(pPin);

            CComPtr< IPin > pConnected = NULL;
            hr = pPin->ConnectedTo( &pConnected );

            if( !pConnected )
            {
                continue;
            }

            hr = pConnected->Disconnect( );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                return hr;
            }
            hr = pPin->Disconnect( );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                return hr;
            }

            // put the filter that was connected into
            // the cache too
            
            // this is 0'ed out because it doesn't save us too much time
            //
            if( 0 )
            {
                PIN_INFO pi;
                pConnected->QueryPinInfo( &pi );
                if( pi.pFilter ) pi.pFilter->Release( );

                long ID = 0;
                ID = GetFilterGenID( pi.pFilter );

                if( ID != 0 )
                {
                    hr = m_pDeadCache->PutFilterToRest( ID, pi.pFilter );
                    DbgLog((LOG_TRACE,1, "RENcache::out pin %ld's effect %ld put to sleep", out, ID ));
                    if( FAILED( hr ) )
                    {
                        return hr;
                    }
                }
            }
        }
    } // for each group

    // need to zero out sync source for all filters in this
    // chain, since the waveout filter's internal SetSyncSource( NULL )
    // is called upon filter removal. It then looks at all the filters
    // in the graph and finds some filters are already in a different
    // graph and CRASHES. This avoids the problem

    CComQIPtr< IMediaFilter, &IID_IMediaFilter > pMedia( m_pGraph );
    hr = pMedia->SetSyncSource( NULL );
    ASSERT( !FAILED( hr ) );

    // put all the switches to sleep in the dead graph. This will pull in
    // their output pins and anything connected to the output pins too
    for( i = 0 ; i < m_nLastGroupCount ; i++ )
    {
        IBigSwitcher * pSwitch = m_pSwitcherArray[i];
        CComQIPtr< IBaseFilter, &IID_IBaseFilter > pFilter( pSwitch );
        if( !GetFilterGraphFromFilter( pFilter ) )
        {
            continue;
        }

        long SwitchID = 0;
        SwitchID = GetFilterGenID( pFilter );
        ASSERT( SwitchID );

        // put the big switch itself into the dead pool
        //
        hr = m_pDeadCache->PutFilterToRestNoDis( SwitchID, pFilter );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }

    // !!! restore default sync for the graph, somebody may
    // not like this, but they can bug us about it later
    //
    CComQIPtr< IFilterGraph, &IID_IFilterGraph > pFG( m_pGraph );
    hr = pFG->SetDefaultSyncSource( );

#ifdef DEBUG
    long t2 = timeGetTime( );
    DbgLog( ( LOG_TIMING, 1, TEXT("RENCACHE::Took %ld load up graph"), t2 - t1 ) );
#endif

    return NOERROR;
}

HRESULT CRenderEngine::_ClearCache( )
{
    DbgLog((LOG_TRACE,1, "RENcache::Cleared the cache" ));

    if( !m_pDeadCache )
    {
        return NOERROR;
    }

    return m_pDeadCache->Clear( );
}

HRESULT CRenderEngine::SetDynamicReconnectLevel( long Level )
{
    CAutoLock Lock( &m_CritSec );

    m_nDynaFlags = Level;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\irendeng.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: irendeng.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// IRendEng.h : Declaration of the CRenderEngine

#ifndef __RENDERENGINE_H_
#define __RENDERENGINE_H_

class CDeadGraph;
#include "resource.h"

// the maximum amount of switchers in our graph possible
//
const long MAX_SWITCHERS = 132;

// the default FPS we hook stuff up at
//
const double DEFAULT_FPS = 15.0;

// our output trace level
//
extern const int RENDER_TRACE_LEVEL;

// how severe the error is we're throwing
//
typedef enum
{
    ERROR_SEVERE = 1,
    ERROR_MEDIUM,
    ERROR_LIGHT
} ERROR_PRIORITY;

// used for the _Connect method, flags what type of connection we're making
//
typedef enum
{
    CONNECT_TYPE_NONE,
    CONNECT_TYPE_SOURCE,
    CONNECT_TYPE_RENDERER
} CONNECT_TYPE;

enum
{
    ID_OFFSET_EFFECT = 1,
    ID_OFFSET_TRANSITION,
};

typedef struct {
    long MyID;		// GENID of this source
    long MatchID;	// GENID of the matching source in the other group
    IPin *pPin;		// other splitter pin for matched source to use
    int  nSwitch0InPin; // first group chain goes to this input pin
} ShareAV;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRenderEngine : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CRenderEngine, &CLSID_RenderEngine>,
    public IDispatchImpl<IRenderEngine, &IID_IRenderEngine, &LIBID_DexterLib>,
    public IObjectWithSite,
    public IServiceProvider,
    public CAMSetErrorLog
{
private:

    // caching stuff
    // caching stuff
    // caching stuff

    // caching vars
    long m_nLastGroupCount;
    CDeadGraph * m_pDeadCache;
    long m_nDynaFlags;

    // caching methods
    HRESULT _LoadCache( );
    HRESULT _ClearCache( );

    // dynamic recompression stuff
    // dynamic recompression stuff
    // dynamic recompression stuff

    BOOL                m_bSmartCompress;
    BOOL                m_bUsedInSmartRecompression;

    // media location stuff
    //
    CComPtr< IMediaLocator > m_pMedLocChain;
    WCHAR                   m_MedLocFilterString[_MAX_PATH];
    long                    m_nMedLocFlags;

    // non caching stuff
    // non caching stuff
    // non caching stuff

    // stuff that lets us share a source for both audio/video
    ShareAV	*m_share;	// list of all sources that will match
    int		m_cshare;	// size of array used
    int		m_cshareMax;	// allocated size of array
    IBaseFilter **m_pdangly;	// list of extra dangly bits
    int		m_cdangly;	// size of array used
    int		m_cdanglyMax;	// allocated size of array

    CCritSec                m_CritSec;
    CComPtr< IAMTimeline >  m_pTimeline;
    IBigSwitcher *          m_pSwitcherArray[MAX_SWITCHERS];
    CComPtr< IPin >         m_pSwitchOuttie[MAX_SWITCHERS];
    CComPtr<IGraphBuilder>  m_pGraph;
    CComPtr< IGrfCache >    m_pSourceConnectCB;
    long                    m_nGroupsAdded;
    REFERENCE_TIME          m_rtRenderStart;
    REFERENCE_TIME          m_rtRenderStop;
    HRESULT                 m_hBrokenCode;

    HRESULT _CreateObject( CLSID Clsid, GUID Interface, void ** pObject, long ID = 0 );
    HRESULT _AddFilter( IBaseFilter * pFilter, LPCWSTR pName, long ID = 0 );
    HRESULT _RemoveFilter( IBaseFilter * pFilter );
    HRESULT _Connect( IPin * pPin1, IPin * pPin2 );
    HRESULT _Disconnect( IPin * pPin1, IPin * pPin2 );
    HRESULT _HookupSwitchers( );
    HRESULT _AddVideoGroupFromTimeline( long WhichGroup, AM_MEDIA_TYPE * mt );
    HRESULT _AddAudioGroupFromTimeline( long WhichGroup, AM_MEDIA_TYPE * mt );
    long    _HowManyMixerOutputs( long WhichGroup );
    HRESULT _RemoveFromDanglyList( IPin *pDanglyPin );
    //HRESULT _AddRandomGroupFromTimeline( long WhichGroup, AM_MEDIA_TYPE * mt );
    void    _CheckErrorCode( long ErrorCode ) { if( FAILED( ErrorCode ) ) m_hBrokenCode = ErrorCode; }
    HRESULT _SetPropsOnAudioMixer( IBaseFilter * pAudMixer, AM_MEDIA_TYPE * pMediaType, double fps, long WhichGroup );
    HRESULT _ScrapIt( BOOL fWipeGraph);
    HRESULT _FindMatchingSource(BSTR bstrName, REFERENCE_TIME SourceStartOrig,
		REFERENCE_TIME SourceStopOrig, REFERENCE_TIME MediaStartOrig,
		REFERENCE_TIME MediaStopOrig, int WhichGroup, int WhichTrack,
		int WhichSource, AM_MEDIA_TYPE *pGroupMediaType,
		double GroupFPS, long *ID);

    IUnknown *       m_punkSite;

public:
    CRenderEngine();
    ~CRenderEngine();
    HRESULT FinalConstruct();

DECLARE_REGISTRY_RESOURCEID(IDR_RENDERENGINE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRenderEngine)
    COM_INTERFACE_ENTRY(IRenderEngine)
    COM_INTERFACE_ENTRY(IAMSetErrorLog)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IServiceProvider)
END_COM_MAP()

// IRenderEngine
public:
    STDMETHODIMP SetTimelineObject( IAMTimeline * pTimeline );
    STDMETHODIMP GetTimelineObject( IAMTimeline ** ppTimeline );
    STDMETHODIMP GetFilterGraph( IGraphBuilder ** ppFG );
    STDMETHODIMP SetFilterGraph( IGraphBuilder * pFG );
    STDMETHODIMP SetInterestRange( REFERENCE_TIME Start, REFERENCE_TIME Stop );
    STDMETHODIMP SetInterestRange2( double Start, double Stop );
    STDMETHODIMP SetRenderRange( REFERENCE_TIME Start, REFERENCE_TIME Stop );
    STDMETHODIMP SetRenderRange2( double Start, double Stop );
    STDMETHODIMP GetGroupOutputPin( long Group, IPin ** ppRenderPin );
    STDMETHODIMP ScrapIt( );
    STDMETHODIMP RenderOutputPins( );
    STDMETHODIMP GetVendorString( BSTR * pVendorID );
    STDMETHODIMP ConnectFrontEnd( );
    STDMETHODIMP SetSourceConnectCallback( IGrfCache * pCallback );
    STDMETHODIMP SetDynamicReconnectLevel( long Level );
    STDMETHODIMP DoSmartRecompression( );
    STDMETHODIMP UseInSmartRecompressionGraph( );
    STDMETHODIMP SetSourceNameValidation( BSTR FilterString, IMediaLocator * pCallback, LONG Flags );
    STDMETHODIMP Commit( );
    STDMETHODIMP Decommit( );
    STDMETHODIMP GetCaps( long Index, long * pReturn );

    // --- IObjectWithSite methods
    // This interface is here so we can keep track of the context we're
    // living in.
    STDMETHODIMP    SetSite(IUnknown *pUnkSite);
    STDMETHODIMP    GetSite(REFIID riid, void **ppvSite);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObject);
};

class ATL_NO_VTABLE CSmartRenderEngine : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSmartRenderEngine, &CLSID_SmartRenderEngine>,
    public IDispatchImpl<IRenderEngine, &IID_IRenderEngine, &LIBID_DexterLib>,
    public ISmartRenderEngine,
    public IObjectWithSite,
    public IServiceProvider,
    public CAMSetErrorLog
{
private:

    // the "uncompressed" render engine
    CComPtr< IRenderEngine > m_pRenderer;

    // the "compressed" render engine
    CComPtr< IRenderEngine > m_pCompRenderer;

    CComPtr< IBaseFilter > * m_ppCompressor;
    long m_nGroups; // how many groups in the timeline

    CComPtr< IFindCompressorCB > m_pCompressorCB;

    BOOL IsGroupCompressed( long Group );

public:
    CSmartRenderEngine();
    ~CSmartRenderEngine();

DECLARE_REGISTRY_RESOURCEID(IDR_SMARTRENDERENGINE)

DECLARE_PROTECT_FINAL_CONSTRUCT()                                               

BEGIN_COM_MAP(CSmartRenderEngine)
    COM_INTERFACE_ENTRY(IRenderEngine)
    COM_INTERFACE_ENTRY(ISmartRenderEngine)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IServiceProvider)
    COM_INTERFACE_ENTRY(IAMSetErrorLog)
END_COM_MAP()

// IRenderEngine
public:
    STDMETHODIMP Commit( );
    STDMETHODIMP Decommit( );
    STDMETHODIMP SetInterestRange( REFERENCE_TIME Start, REFERENCE_TIME Stop );
    STDMETHODIMP SetInterestRange2( double Start, double Stop );
    STDMETHODIMP SetRenderRange( REFERENCE_TIME Start, REFERENCE_TIME Stop );
    STDMETHODIMP SetRenderRange2( double Start, double Stop );
    STDMETHODIMP SetTimelineObject( IAMTimeline * pTimeline );
    STDMETHODIMP GetTimelineObject( IAMTimeline ** ppTimeline );
    STDMETHODIMP Run( REFERENCE_TIME Start, REFERENCE_TIME Stop );
    STDMETHODIMP GetCaps( long Index, long * pReturn );
    STDMETHODIMP GetVendorString( BSTR * pVendorID );
    STDMETHODIMP GetFilterGraph( IGraphBuilder ** ppFG );
    STDMETHODIMP SetFilterGraph( IGraphBuilder * pFG );
    STDMETHODIMP ConnectFrontEnd( );
    STDMETHODIMP ScrapIt( );
    STDMETHODIMP RenderOutputPins( );
    STDMETHODIMP SetSourceConnectCallback( IGrfCache * pCallback );
    STDMETHODIMP GetGroupOutputPin( long Group, IPin ** ppRenderPin );
    STDMETHODIMP SetDynamicReconnectLevel( long Level );
    STDMETHODIMP DoSmartRecompression( );
    STDMETHODIMP UseInSmartRecompressionGraph( );
    STDMETHODIMP SetSourceNameValidation( BSTR FilterString, IMediaLocator * pCallback, LONG Flags );

    // ISmartRenderEngine
    STDMETHODIMP SetGroupCompressor( long Group, IBaseFilter * pCompressor ); 
    STDMETHODIMP GetGroupCompressor( long Group, IBaseFilter ** ppCompressor ); 
    STDMETHODIMP SetFindCompressorCB( IFindCompressorCB * pCallback );

    STDMETHODIMP _InitSubComponents( );

    // --- IObjectWithSite methods
    // This interface is here so we can keep track of the context we're
    // living in.
    STDMETHODIMP    SetSite(IUnknown *pUnkSite);
    STDMETHODIMP    GetSite(REFIID riid, void **ppvSite);

    IUnknown *       m_punkSite;

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObject);
};

#endif //__RENDERENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\resource.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by render.rc
//
#define IDR_RENDERENGINE                1500
#define IDR_SMARTRENDERENGINE           1501

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\resize\resource.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#define IDD_RESIZE			    700
#define IDS_RESIZE_TITLE		    711
#define IDC_RESIZE_HEIGHT		    720
#define IDC_RESIZE_WIDTH		    721
#define IDC_DEXTER_RESIZE_CROP		    722
#define IDC_DEXTER_RESIZE_PRESERVE_RATIO    723
#define IDC_DEXTER_RESIZE		    724
#ifndef IDC_STATIC
#define IDC_STATIC        -1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\srender.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: srender.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "grid.h"
#include "deadpool.h"
#include "..\errlog\cerrlog.h"
#include "..\util\filfuncs.h"
#include "..\util\conv.cxx"
#include "IRendEng.h"
#include "dexhelp.h"

#include <initguid.h>
DEFINE_GUID( CLSID_Dump, 0x36A5F770, 0xFE4C, 0x11CE, 0xA8, 0xED, 0x00, 0xaa, 0x00, 0x2F, 0xEA, 0xB5 );

// notes:
// Smart Recompression is still rather uninteligent. The way it works is this:
// there is a compressed RE and an uncompressed RE. The URE will send
// <everything>, just like a normal non-SR project, to the SR filter. (Thus, it will
// be just as slow as normal, not taking into account the recompression step)
// however, the SR filter will ignore the uncompressed data unless it needs it.
// The CRE will only connect up compressed sources that it can send directly
// to the SR. I imagine this means there will be gaps in the CRE's playback. 

//############################################################################
// 
//############################################################################

CSmartRenderEngine::CSmartRenderEngine( )
    : m_punkSite( NULL )
    , m_ppCompressor( NULL )

{
    m_nGroups = 0;

    // don't create the renderers here because we can't return an error code
}

//############################################################################
// 
//############################################################################

CSmartRenderEngine::~CSmartRenderEngine( )
{
    for( int g = 0 ; g < m_nGroups ; g++ )
    {
        if( m_ppCompressor[g] )
        {
            m_ppCompressor[g].Release( );
        }
    }
    delete [] m_ppCompressor;
}

STDMETHODIMP CSmartRenderEngine::Commit( )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmartRenderEngine::Decommit( )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmartRenderEngine::SetInterestRange( REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmartRenderEngine::GetCaps( long Index, long * pReturn )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmartRenderEngine::GetVendorString( BSTR * pVendorID )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmartRenderEngine::SetSourceConnectCallback( IGrfCache * pCallback )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmartRenderEngine::SetFindCompressorCB( IFindCompressorCB * pCallback )
{
    return E_NOTIMPL;
}

STDMETHODIMP CSmartRenderEngine::SetDynamicReconnectLevel( long Level )
{
    // WE decide, not the user
    return E_NOTIMPL;
}

STDMETHODIMP CSmartRenderEngine::DoSmartRecompression( )
{
    // duh...
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::_InitSubComponents( )
{
    if( m_pRenderer && m_pCompRenderer )
    {
        return NOERROR;
    }

    HRESULT hr = 0;

    if( !m_pRenderer )
    {
        hr = CoCreateInstance(
            CLSID_RenderEngine,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IRenderEngine,
            (void**) &m_pRenderer );
        if( FAILED( hr ) )
        {
            return hr;
        }

        // give the child rendeng a pointer back to us
        {
            CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( m_pRenderer );

            pOWS->SetSite( (IServiceProvider *) this );
        }

        m_pRenderer->UseInSmartRecompressionGraph( );
    }

    if( !m_pCompRenderer )
    {
        hr = CoCreateInstance(
            CLSID_RenderEngine,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IRenderEngine,
            (void**) &m_pCompRenderer );
        if( FAILED( hr ) )
        {
            return hr;
        }

        // give the child rendeng a pointer back to us
        {
            CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( m_pCompRenderer );
            ASSERT( pOWS );
            if( pOWS )
            {            
                pOWS->SetSite( (IServiceProvider *) this );
            }                
        }

        // this one is the compressed one
        //
        m_pCompRenderer->DoSmartRecompression( );
        m_pCompRenderer->UseInSmartRecompressionGraph( );
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::RenderOutputPins( )
{
    HRESULT hr = 0;

    long Groups = 0;
    CComPtr< IAMTimeline > pTimeline;
    m_pRenderer->GetTimelineObject( &pTimeline );
    if( !pTimeline )
    {
        return E_UNEXPECTED;
    }
    CComPtr< IGraphBuilder > pGraph;
    m_pRenderer->GetFilterGraph( &pGraph );
    if( !pGraph )
    {
        return E_UNEXPECTED;
    }
    pTimeline->GetGroupCount( &Groups );

    for( int g = 0 ; g < Groups ; g++ )
    {
        CComPtr< IAMTimelineObj > pGroupObj;
        hr = pTimeline->GetGroup( &pGroupObj, g );
        ASSERT( !FAILED( hr ) );
        CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( pGroupObj );
        AM_MEDIA_TYPE MediaType;
        hr = pGroup->GetMediaType( &MediaType );
        GUID MajorType = MediaType.majortype;
        SaferFreeMediaType( MediaType );

        // ask OURSELVES for the output pin, then render it
        //
        CComPtr< IPin > pOut;
        hr = GetGroupOutputPin( g, &pOut );
        if( hr == S_FALSE || !pOut )
        {
            // didn't have a pin for this one, but didn't fail
            //
            continue;
        }
        if( FAILED( hr ) )
        {
            return hr;
        }

        // see if output pin is already connected
        //
        CComPtr< IPin > pConnected;
        pOut->ConnectedTo( &pConnected );
        if( pConnected )
        {
            continue;
        }

        if( MajorType == MEDIATYPE_Video )
        {
            // create a video renderer, to provide a destination
            //
            CComPtr< IBaseFilter > pVidRenderer;
            hr = CoCreateInstance(
                CLSID_VideoRenderer,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IBaseFilter,
                (void**) &pVidRenderer );
            ASSERT( !FAILED( hr ) );

            // put it in the graph
            //
            hr = pGraph->AddFilter( pVidRenderer, L"Video Renderer" );
            ASSERT( !FAILED( hr ) );

            // find a pin
            //
            IPin * pVidRendererPin = GetInPin( pVidRenderer , 0 );
            ASSERT( pVidRendererPin );

            hr = pGraph->Connect( pOut, pVidRendererPin );
            ASSERT( !FAILED( hr ) );
        }
        else if( MajorType == MEDIATYPE_Audio )
        {
            // create a audio renderer so we can hear it
            CComPtr< IBaseFilter > pAudRenderer;
            hr = CoCreateInstance(
                CLSID_DSoundRender,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IBaseFilter,
                (void**) &pAudRenderer );
            ASSERT( !FAILED( hr ) );

            hr = pGraph->AddFilter( pAudRenderer, L"Audio Renderer" );
            ASSERT( !FAILED( hr ) );

            IPin * pAudRendererPin = GetInPin( pAudRenderer , 0 );
            ASSERT( pAudRendererPin );

            hr = pGraph->Connect( pOut, pAudRendererPin );
            ASSERT( !FAILED( hr ) );
        }
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::SetRenderRange( REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    HRESULT hr = _InitSubComponents( );
    if( FAILED( hr ) )
    {
        return E_MUST_INIT_RENDERER;
    }

    hr = m_pRenderer->SetRenderRange( Start, Stop );
    if( FAILED( hr ) )
    {
        return hr;
    }

    return m_pCompRenderer->SetRenderRange( Start, Stop );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::SetTimelineObject( IAMTimeline * pTimeline )
{
    CheckPointer( pTimeline, E_POINTER );

    HRESULT hr = _InitSubComponents( );
    if( FAILED( hr ) )
    {
        return E_MUST_INIT_RENDERER;
    }

    // clear out the other groups first
    //
    if( m_ppCompressor )
    {
        for( int g = 0 ; g < m_nGroups ; g++ )
        {
            m_ppCompressor[g].Release( );        
        }
        delete [] m_ppCompressor;
        m_ppCompressor = NULL;
        m_nGroups = 0;
    }

    pTimeline->GetGroupCount( &m_nGroups );
    m_ppCompressor = new CComPtr< IBaseFilter >[m_nGroups];
    if( !m_ppCompressor )
    {
        m_nGroups = 0;
        return E_OUTOFMEMORY;
    }

    m_pErrorLog.Release( );

    // grab the timeline's error log
    //
    CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pTimelineLog( pTimeline );
    if( pTimelineLog )
    {
        pTimelineLog->get_ErrorLog( &m_pErrorLog );
    }

    hr = m_pRenderer->SetTimelineObject( pTimeline );
    if( FAILED( hr ) )
    {
        return hr;
    }

    return m_pCompRenderer->SetTimelineObject( pTimeline );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::GetTimelineObject( IAMTimeline ** ppTimeline )
{
    HRESULT hr = _InitSubComponents( );
    if( FAILED( hr ) )
    {
        return E_MUST_INIT_RENDERER;
    }

    return m_pCompRenderer->GetTimelineObject( ppTimeline );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::GetFilterGraph( IGraphBuilder ** ppFG )
{
    HRESULT hr = _InitSubComponents( );
    if( FAILED( hr ) )
    {
        return E_MUST_INIT_RENDERER;
    }

    return m_pCompRenderer->GetFilterGraph( ppFG );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::SetFilterGraph( IGraphBuilder * pFG )
{
    HRESULT hr = _InitSubComponents( );
    if( FAILED( hr ) )
    {
        return E_MUST_INIT_RENDERER;
    }

    hr = m_pRenderer->SetFilterGraph( pFG );
    if( FAILED( hr ) )
    {
        return hr;
    }

    return m_pCompRenderer->SetFilterGraph( pFG );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::ScrapIt( )
{
    HRESULT hr = _InitSubComponents( );
    if( FAILED( hr ) )
    {
        return E_MUST_INIT_RENDERER;
    }

    hr = m_pRenderer->ScrapIt( );
    if( FAILED( hr ) )
    {
        return hr;
    }

    return m_pCompRenderer->ScrapIt( );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::GetGroupOutputPin( long Group, IPin ** ppRenderPin )
{
    CheckPointer( ppRenderPin, E_POINTER );

    HRESULT hr = _InitSubComponents( );
    if( FAILED( hr ) )
    {
        return E_MUST_INIT_RENDERER;
    }

    *ppRenderPin = NULL;

    // if this group isn't recompressed, evidenced by NOT having a compressor, 
    // then just return the uncompressed
    // renderer's pin
    //
    if( m_nGroups == 0 )
    {
        return E_UNEXPECTED;
    }
    if( ( Group < 0 ) || ( Group >= m_nGroups ) )
    {
        return E_INVALIDARG;
    }

    if( !m_ppCompressor[Group] || !IsGroupCompressed( Group ) )
    {
        return m_pRenderer->GetGroupOutputPin( Group, ppRenderPin );
    }

    // return the SR's output pin for this combo

    CComPtr< IPin > pPin;
    m_pRenderer->GetGroupOutputPin( Group, &pPin );
    if( !pPin )
    {
        return E_UNEXPECTED;
    }

    // The compressed renderer is connected to the SR filter.
    // If something went wrong with trying to do smart recompression, there will
    // be no SR filter, in which case, fall back to doing non-smart rendering
    // instead of aborting the project
    //
    CComPtr< IPin > pSRIn;
    pPin->ConnectedTo( &pSRIn );
    if( !pSRIn )
    {
        return m_pRenderer->GetGroupOutputPin( Group, ppRenderPin );
    }

    IBaseFilter * pSR = GetFilterFromPin( pSRIn );
    IPin * pSROut = GetOutPin( pSR, 0 );
    if( !pSROut )
    {
        return E_UNEXPECTED;
    }

    pSROut->AddRef( );
    *ppRenderPin = pSROut;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

BOOL CSmartRenderEngine::IsGroupCompressed( long Group )
{
    HRESULT hr = _InitSubComponents( );
    if( FAILED( hr ) )
    {
        return E_MUST_INIT_RENDERER;
    }

    CComPtr< IAMTimeline > pTimeline;
    m_pRenderer->GetTimelineObject( &pTimeline );
    if( !pTimeline )
    {
        return FALSE;
    }

    CComPtr< IAMTimelineObj > pGroupObj;
    pTimeline->GetGroup( &pGroupObj, Group );
    if( !pGroupObj )
    {
        return FALSE;
    }
    CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( pGroupObj );

    BOOL Val = FALSE;
    pGroup->IsSmartRecompressFormatSet( &Val );
    return Val;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::UseInSmartRecompressionGraph( )
{
    // duh
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::SetGroupCompressor( long Group, IBaseFilter * pCompressor )
{
    if( Group < 0 || Group >= m_nGroups )
    {
        return E_INVALIDARG;
    }

    m_ppCompressor[Group].Release( );
    m_ppCompressor[Group] = pCompressor;
    return NOERROR;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::GetGroupCompressor( long Group, IBaseFilter ** ppCompressor )
{
    if( Group < 0 || Group >= m_nGroups )
    {
        return E_INVALIDARG;
    }
    CheckPointer(ppCompressor, E_POINTER);

    *ppCompressor = m_ppCompressor[Group];
    if (*ppCompressor) {
        (*ppCompressor)->AddRef();
    }
    return NOERROR;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CSmartRenderEngine::ConnectFrontEnd( )
{
    HRESULT hr = _InitSubComponents( );
    if( FAILED( hr ) )
    {
        return E_MUST_INIT_RENDERER;
    }

    // we need to ask the render engine if it already 
    // has a graph first, or BOTH of them will create one
    // for us.
    CComPtr< IGraphBuilder > pTempGraph;
    hr = m_pRenderer->GetFilterGraph( &pTempGraph );

    hr = m_pRenderer->ConnectFrontEnd( );
    if( FAILED( hr ) )
    {
        return hr;
    }

    if( !pTempGraph )
    {
        m_pRenderer->GetFilterGraph( &pTempGraph );
        ASSERT( pTempGraph );
        if( pTempGraph )
        {
            m_pCompRenderer->SetFilterGraph( pTempGraph );
        }
    }

    hr = m_pCompRenderer->ConnectFrontEnd( );
    if( FAILED( hr ) )
    {
        return hr;
    }

    long Groups = 0;
    CComPtr< IAMTimeline > pTimeline;
    m_pRenderer->GetTimelineObject( &pTimeline );
    if( !pTimeline )
    {
        return E_UNEXPECTED;
    }
    CComPtr< IGraphBuilder > pGraph;
    m_pRenderer->GetFilterGraph( &pGraph );
    if( !pGraph )
    {
        return E_UNEXPECTED;
    }
    pTimeline->GetGroupCount( &Groups );

    for( int g = 0 ; g < Groups ; g++ )
    {
        BOOL Compressed = IsGroupCompressed( g );
        if( !Compressed )
        {
            continue;
        }

        CComPtr< IPin > pOutUncompressed;
        hr = m_pRenderer->GetGroupOutputPin( g, &pOutUncompressed );
        if( FAILED( hr ) )
        {
            return hr;
        }

        CComPtr< IPin > pOutCompressed;
        hr = m_pCompRenderer->GetGroupOutputPin( g, &pOutCompressed );
        if( FAILED( hr ) )
        {
            return hr;
        }

        CComPtr< IPin > pOutUncConnected;
        CComPtr< IPin > pOutCompConnected;
        pOutUncompressed->ConnectedTo( &pOutUncConnected );
        pOutCompressed->ConnectedTo( &pOutCompConnected );

        CComPtr< IBaseFilter > pSR;

        // see if we already have an SR filter. If not, create one.
        //
        if( pOutUncConnected )
        {
            PIN_INFO pi;
            pOutUncConnected->QueryPinInfo( &pi );
            pSR = pi.pFilter;
            pi.pFilter->Release( );
        }
        else
        {
            hr = CoCreateInstance( CLSID_SRFilter,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IBaseFilter,
                (void**) &pSR );
            if( FAILED( hr ) )
            {
                return hr;
            }

            hr = pGraph->AddFilter( pSR, L"SmartRecompressor" );
            if( FAILED( hr ) )
            {
                return hr;
            }
        }

        // get the pins from the SR
        //
        IPin * pSRInUncompressed = GetInPin( pSR, 0 ); 
        IPin * pSRInCompressed = GetInPin( pSR, 1 ); 
        IPin * pSROutToCompressor = GetOutPin( pSR, 1 );
        IPin * pSRInFromCompressor = GetInPin( pSR, 2 );

        // if we already have a SR filter, then instead of comparing everything, we'll
        // purposely disconnect everything and reconnect. It's easier this way
        //
        if( pOutUncConnected )
        {
            pOutUncompressed->Disconnect( );
            pSRInUncompressed->Disconnect( );
            pOutCompressed->Disconnect( );
            pSRInCompressed->Disconnect( );

            // disconnect and throw out everything between two compressor pins
            //
            RemoveChain( pSROutToCompressor, pSRInFromCompressor );
        }

        CComQIPtr< IAMSmartRecompressor, &IID_IAMSmartRecompressor > pSmartie( pSR );
        pSmartie->AcceptFirstCompressed( );
    
        hr = pGraph->Connect( pOutCompressed, pSRInCompressed );
        if( FAILED( hr ) )
        {
            return hr;
        }

        hr = pGraph->Connect( pOutUncompressed, pSRInUncompressed );
        if( FAILED( hr ) )
        {
            return hr;
        }

        CComPtr< IBaseFilter > pCompressor;

        // if we were told a compressor for this group, then use that one
        //
        if( m_ppCompressor[g] )
        {
            pCompressor = m_ppCompressor[g];
        }

        AM_MEDIA_TYPE UncompressedType;
        AM_MEDIA_TYPE CompressedType;
        hr = pSRInUncompressed->ConnectionMediaType( &UncompressedType );
        if( FAILED( hr ) )
        {
            return hr;
        }
        hr = pSRInCompressed->ConnectionMediaType( &CompressedType );
        if( FAILED( hr ) )
        {
            SaferFreeMediaType( UncompressedType );
            return hr;
        }

        VIDEOINFOHEADER * pVIH = (VIDEOINFOHEADER*) CompressedType.pbFormat;
        double FrameRate = 1.0 / RTtoDouble( pVIH->AvgTimePerFrame );
        hr = pSmartie->SetFrameRate( FrameRate );
        if( FAILED( hr ) )
        {
            return hr;
        }
        hr = pSmartie->SetPreviewMode( FALSE );

        // if we don't HAVE a compressor, then do we have a callback in
        // order to get one?
        //
        if( !pCompressor )
        {
            if( m_pCompressorCB )
            {
                // find the types on the connected SR input pins
                //
                hr = m_pCompressorCB->GetCompressor( 
                    &UncompressedType, 
                    &CompressedType, 
                    &pCompressor );

		// Now remember which one was used if the app asks
		SetGroupCompressor(g, pCompressor);

            }
        }

        if( !pCompressor )
        {
            hr = FindCompressor( &UncompressedType, &CompressedType, &pCompressor, (IServiceProvider *) this );
	    // Now remember which one was used if the app asks
	    SetGroupCompressor(g, pCompressor);
        }

        if( !pCompressor )
        {
            // no compressor, make this group output pin UNCOMPRESSED then.
            //
            _GenerateError( 2, DEX_IDS_CANT_FIND_COMPRESSOR, hr );
            RemoveChain(pOutUncompressed, pSRInUncompressed);
            RemoveChain(pOutCompressed, pSRInCompressed);
            pGraph->RemoveFilter( pSR );
            SaferFreeMediaType( UncompressedType );
            SaferFreeMediaType( CompressedType );
            continue;
        }

        hr = pGraph->AddFilter( pCompressor, L"Compressor" );
        if( FAILED( hr ) )
        {
            return hr;
        }
        IPin * pCompIn = GetInPin( pCompressor, 0 );
        IPin * pCompOut = GetOutPin( pCompressor, 0 );

        hr = pGraph->Connect( pSROutToCompressor, pCompIn );
        if( FAILED( hr ) )
        {
            // no compressor, make this group output pin UNCOMPRESSED then.
            //
            _GenerateError( 2, DEX_IDS_CANT_FIND_COMPRESSOR, hr );
            RemoveChain(pOutUncompressed, pSRInUncompressed);
            RemoveChain(pOutCompressed, pSRInCompressed);
            pGraph->RemoveFilter( pSR );
            SaferFreeMediaType( UncompressedType );
            SaferFreeMediaType( CompressedType );
            continue;
        }

        // now program the compressor to produce the right kind of output
        IAMStreamConfig *pSC = NULL;
        pCompOut->QueryInterface(IID_IAMStreamConfig, (void**)&pSC);
        if (pSC) {
            // !!! BUGBUGS !!!
            // ABORT if this fails?
            // Fix up ZERO data rate to some default for WMV?
            pSC->SetFormat(&CompressedType);
            pSC->Release();
        }

        SaferFreeMediaType( UncompressedType );
        SaferFreeMediaType( CompressedType );

        hr = pGraph->Connect( pCompOut, pSRInFromCompressor );
        if( FAILED( hr ) )
        {
            return _GenerateError( 2, DEX_IDS_CANT_FIND_COMPRESSOR, hr );
        }

        // we've got the two renderers connected. Now, when somebody asks us
        // for a group output pin, we'll return the SR filter's
    }
   
    return NOERROR;
}

//############################################################################
// 
//############################################################################
// IObjectWithSite::SetSite
// remember who our container is, for QueryService or other needs
STDMETHODIMP CSmartRenderEngine::SetSite(IUnknown *pUnkSite)
{
    // note: we cannot addref our site without creating a circle
    // luckily, it won't go away without releasing us first.
    m_punkSite = pUnkSite;

    return S_OK;
}

//############################################################################
// 
//############################################################################
// IObjectWithSite::GetSite
// return an addrefed pointer to our containing object
STDMETHODIMP CSmartRenderEngine::GetSite(REFIID riid, void **ppvSite)
{
    if (m_punkSite)
        return m_punkSite->QueryInterface(riid, ppvSite);

    return E_NOINTERFACE;
}

//############################################################################
// 
//############################################################################
// Forward QueryService calls up to the "real" host
STDMETHODIMP CSmartRenderEngine::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    IServiceProvider *pSP;

    if (!m_punkSite)
	return E_NOINTERFACE;

    HRESULT hr = m_punkSite->QueryInterface(IID_IServiceProvider, (void **) &pSP);

    if (SUCCEEDED(hr)) {
	hr = pSP->QueryService(guidService, riid, ppvObject);
	pSP->Release();
    }

    return hr;
}

//############################################################################
// since we're middleware, we don't need to check the filterstring here
//############################################################################

STDMETHODIMP CSmartRenderEngine::SetSourceNameValidation
    ( BSTR FilterString, IMediaLocator * pCallback, LONG Flags )
{
    HRESULT hr = _InitSubComponents( );
    if( FAILED( hr ) )
    {
        return E_MUST_INIT_RENDERER;
    }

    m_pRenderer->SetSourceNameValidation( FilterString, pCallback, Flags );
    m_pCompRenderer->SetSourceNameValidation( FilterString, pCallback, Flags );

    return NOERROR;
}

STDMETHODIMP CSmartRenderEngine::SetInterestRange2( double Start, double Stop )
{
    return SetInterestRange( DoubleToRT( Start ), DoubleToRT( Stop ) );
}

STDMETHODIMP CSmartRenderEngine::SetRenderRange2( double Start, double Stop )
{
    return SetRenderRange( DoubleToRT( Start ), DoubleToRT( Stop ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\resize\prop.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: prop.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;


#include <windows.h>
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "stretch.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////
//
// CResizePropertyPage
//
//////////////////////////////////////////////////////////////////////////

//
// CreateInstance
//
CUnknown *CResizePropertyPage::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)

  { // CreateInstance //

    CUnknown *punk = new CResizePropertyPage(lpunk, phr);

    if (NULL == punk)
	    *phr = E_OUTOFMEMORY;

    return punk;

  } // CreateInstance //

CResizePropertyPage::CResizePropertyPage(LPUNKNOWN pUnk, HRESULT *phr) :
  CBasePropertyPage(NAME("Video Resize Property Page"),
		   pUnk, IDD_RESIZE, IDS_RESIZE_TITLE), m_bInitialized(FALSE), m_pirs(NULL)

  { // Constructor //
  } // Constructor //

void CResizePropertyPage::SetDirty()

  { // SetDirty //

      m_bDirty = TRUE;

      if (m_pPageSite)
	m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

  } // SetDirty //

HRESULT CResizePropertyPage::OnActivate (void)

  { // OnActivate //

    if (m_dwResizeFlag == RESIZEF_STRETCH)
        CheckRadioButton(m_Dlg, IDC_DEXTER_RESIZE_CROP, IDC_DEXTER_RESIZE,
					IDC_DEXTER_RESIZE);
    else if (m_dwResizeFlag == RESIZEF_CROP)
        CheckRadioButton(m_Dlg, IDC_DEXTER_RESIZE_CROP, IDC_DEXTER_RESIZE,
					IDC_DEXTER_RESIZE_CROP);
    else
        CheckRadioButton(m_Dlg, IDC_DEXTER_RESIZE_CROP, IDC_DEXTER_RESIZE,
					IDC_DEXTER_RESIZE_PRESERVE_RATIO);

    m_bInitialized = TRUE;

    return NOERROR;

  } // OnActivate //

HRESULT CResizePropertyPage::OnDeactivate (void)

  { // OnDeactivate //

    m_bInitialized = FALSE;

    GetControlValues();

    return NOERROR;

  } // OnDeactivate //

INT_PTR CResizePropertyPage::OnReceiveMessage (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

  { // OnReceiveMessage //

    switch(uMsg)

      { // Switch

	case WM_COMMAND:

	  if (!m_bInitialized)
	    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

	  m_bDirty = TRUE;

	  if (m_pPageSite)
	    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

	  return TRUE;

	case WM_INITDIALOG:
	  SetDlgItemInt(hwnd, IDC_RESIZE_HEIGHT, m_ResizedHeight, FALSE);
	  SetDlgItemInt(hwnd, IDC_RESIZE_WIDTH, m_ResizedWidth, FALSE);
	  return TRUE;
	  break;

	default:
	  return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
	  break;

      } // Switch

  } // OnReceiveMessage //

HRESULT CResizePropertyPage::OnConnect (IUnknown *pUnknown)

  { // OnConnect //

    pUnknown->QueryInterface(IID_IResize, (void **)&m_pirs);

    ASSERT(m_pirs != NULL);

    m_pirs->get_Size(&m_ResizedHeight, &m_ResizedWidth, &m_dwResizeFlag);

    m_bInitialized = FALSE;

    return NOERROR;

  } // OnConnect //

HRESULT CResizePropertyPage::OnDisconnect()

  { // OnDisconnect //

    if (m_pirs)

      { // Release

	m_pirs->Release();
	m_pirs = NULL;

      } // Release

    m_bInitialized = FALSE;

    return NOERROR;

  } // OnDisconnect //

HRESULT CResizePropertyPage::OnApplyChanges()

  { // OnApplyChanges //

    ASSERT(m_pirs != NULL);

    GetControlValues();

    m_pirs->put_Size(m_ResizedHeight, m_ResizedWidth, m_dwResizeFlag);

    return (NOERROR);

  } // OnApplyChanges //

void CResizePropertyPage::GetControlValues (void)

  { // GetControlValues //

    // Sampling rate
    m_ResizedHeight = GetDlgItemInt(m_Dlg, IDC_RESIZE_HEIGHT, NULL, FALSE);

    m_ResizedWidth = GetDlgItemInt(m_Dlg, IDC_RESIZE_WIDTH, NULL, FALSE);

    //get flags
    m_dwResizeFlag=0;

   for (DWORD dw = IDC_DEXTER_RESIZE_CROP; dw <= IDC_DEXTER_RESIZE; dw++) {
       if (IsDlgButtonChecked(m_Dlg, (int)dw)) {
	    if (dw == IDC_DEXTER_RESIZE_CROP)
                m_dwResizeFlag = RESIZEF_CROP;
	    else if (dw == IDC_DEXTER_RESIZE)
                m_dwResizeFlag = RESIZEF_STRETCH;
	    else
                m_dwResizeFlag = RESIZEF_PRESERVEASPECTRATIO;
            break;
        }
    }

  } // GetControlValues //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\stdafx.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stdafx.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__08E7CDC6_7F58_11D2_8CF1_00A0C9441E20__INCLUDED_)
#define AFX_STDAFX_H__08E7CDC6_7F58_11D2_8CF1_00A0C9441E20__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _ATL_APARTMENT_THREADED
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <qeditint.h>
#include <qedit.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__08E7CDC6_7F58_11D2_8CF1_00A0C9441E20__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\resize\stretch.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stretch.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// A Transform filter that stretches a video image as it passes through

#include <windows.h>
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include <Stretch.h>
#include <resource.h>
#include "..\util\filfuncs.h"

const int DEFAULT_WIDTH   = 320;
const int DEFAULT_HEIGHT  = 240;

// Setup data

const AMOVIESETUP_MEDIATYPE sudStretchPinTypes =
{
    &MEDIATYPE_Video,           // Major
    &MEDIASUBTYPE_NULL          // Subtype
};

const AMOVIESETUP_PIN sudStretchPin[] =
{
    { L"Input",                 // Name of the pin
      FALSE,                    // Is pin rendered
      FALSE,                    // Is an Output pin
      FALSE,                    // Ok for no pins
      FALSE,                    // Can we have many
      &CLSID_NULL,              // Connects to filter
      NULL,                     // Name of pin connect
      1,                        // Number of pin types
      &sudStretchPinTypes },    // Details for pins

    { L"Output",                // Name of the pin
      FALSE,                    // Is pin rendered
      TRUE,                     // Is an Output pin
      FALSE,                    // Ok for no pins
      FALSE,                    // Can we have many
      &CLSID_NULL,              // Connects to filter
      NULL,                     // Name of pin connect
      1,                        // Number of pin types
      &sudStretchPinTypes }     // Details for pins
};

const AMOVIESETUP_FILTER sudStretchFilter =
{
    &CLSID_Resize,             // CLSID of filter
    L"Stretch Video",           // Filter name
    MERIT_DO_NOT_USE,               // Filter merit
    2,                          // Number of pins
    sudStretchPin               // Pin information
};

// Constructor

CStretch::CStretch(LPUNKNOWN pUnk, HRESULT *phr) :
    CTransformFilter(NAME("Stretch"),pUnk,CLSID_Resize),
    CPersistStream(pUnk, phr),
    m_lBufferRequest(1),
    m_dwResizeFlag(RESIZEF_STRETCH)
{
    CreatePreferredMediaType(&m_mt);
}

CStretch::~CStretch()
{
    SaferFreeMediaType(m_mt);
}



// This goes in the factory template table to create new filter instances

CUnknown *CStretch::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CStretch *pNewObject = new CStretch(punk, phr);
    if (pNewObject == NULL) {
	*phr = E_OUTOFMEMORY;
    }
    return pNewObject;
}


// overridden to make a special input pin
//
CBasePin * CStretch::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if necessary

    if (n == 0 && m_pInput == NULL) {
        DbgLog((LOG_TRACE,2,TEXT("Creating an input pin")));

        m_pInput = new CStretchInputPin(NAME("Resize input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          L"Input");         // Pin name

        // a failed return code should delete the object

        if (FAILED(hr) || m_pInput == NULL) {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Or alternatively create an output pin

    if (n == 1 && m_pOutput == NULL) {

        DbgLog((LOG_TRACE,2,TEXT("Creating an output pin")));

        m_pOutput = new CTransformOutputPin(NAME("Transform output pin"),
                                            this,            // Owner filter
                                            &hr,             // Result code
                                            L"Output");      // Pin name

        // a failed return code should delete the object

        if (FAILED(hr) || m_pOutput == NULL) {
            delete m_pOutput;
            m_pOutput = NULL;
        }
    }

    // Return the appropriate pin

    if (n == 0) {
        return m_pInput;
    }
    return m_pOutput;
}


//
//  resize function
//
//

#define BITMAP_WIDTH(width,bitCount) \
    (int)((int)(((((int)width) * ((int)bitCount)) + 31L) & (int)~31L) / 8L)


extern void StretchDIB(
    LPBITMAPINFOHEADER pbiDst,   //    --> to destination BIH
    LPVOID    lpvDst,            //    --> to destination bits
    int    DstX,            //    Destination origin - x coordinate
    int    DstY,            //    Destination origin - y coordinate
    int    DstXE,            //    x extent of the BLT
    int    DstYE,            //    y extent of the BLT
    LPBITMAPINFOHEADER pbiSrc,   //    --> to source BIH
    LPVOID    lpvSrc,            //    --> to source bits
    int    SrcX,            //    Source origin - x coordinate
    int    SrcY,            //    Source origin - y coordinate
    int    SrcXE,            //    x extent of the BLT
    int    SrcYE             //    y extent of the BLT
    );

void CStretch::ResizeRGB( BITMAPINFOHEADER *pbiIn,    //Src's BitMapInFoHeader
			  const unsigned char * dibBits,    //Src bits
			  BITMAPINFOHEADER *pbiOut,
			  unsigned char *pFrame,    //Dst bits
			  int iNewWidth,            //new W in pixel
			  int iNewHeight)           //new H in pixel
{
    // NICE!
    //
    StretchDIB(
	pbiOut,   	    //	--> BITMAPINFO of destination
	pFrame,             //  --> to destination bits
	0,                  //  Destination origin - x coordinate
	0,                  //  Destination origin - y coordinate
	iNewWidth,          //  x extent of the BLT
	iNewHeight,         //  y extent of the BLT
	pbiIn,   	    //	--> BITMAPINFO of destination
	(void*) dibBits,    //  --> to source bits
	0,                  //  Source origin - x coordinate
	0,                  //  Source origin - y coordinate
	pbiIn->biWidth,    //  x extent of the BLT
	pbiIn->biHeight    //  y extent of the BLT
	);

    return;
}

void CropRGB(	BITMAPINFOHEADER *pbiIn,	//Src's BitMapInfoHeader
		const unsigned char * dibBits,  //Src bits
		BITMAPINFOHEADER *pbiOut,	//Dst's BitmapinfoHeader
		unsigned char *pOutBuf )	//Dst bits
{
    // check video bits
    long nBits;

    if ( (nBits = pbiOut->biBitCount) != pbiIn->biBitCount)
    {
	ASSERT( nBits == pbiIn->biBitCount);
	return;
    }


    long lSrcX, lDstX;	    //start point at x axis;
    long lWidthOff=(pbiOut->biWidth  - pbiIn->biWidth)>>1;
    long lInWidthBytes=(((pbiIn->biWidth * nBits) + 31) & ~31) / 8;
    long lOutWidthBytes=(((pbiOut->biWidth * nBits) + 31) & ~31) / 8;

    long lCropWidth;
    if(lWidthOff >=0)
    {
	//Src width < Dst Width, take whole source
	lSrcX	    =0L;
	lDstX	    =(((lWidthOff * nBits) + 31) & ~31) / 8;
	lCropWidth  =lInWidthBytes;
    }
    else
    {
	//Src Width > Dst Width, take part of Src
	lSrcX	    =-(((lWidthOff * nBits) + 31) & ~31) / 8;
	lDstX	    =0;
	lCropWidth  =lOutWidthBytes;
    }



    long lSrcY,lDstY;	    //Src start point at y axis
    long lHeightOff=(pbiOut->biHeight - pbiIn->biHeight)>>1;
    long lCropHeight;
    if(lHeightOff >=0)
    {
	//SRC height <Dst Height, take whole Src height
	lSrcY   =0L;
	lDstY	=lHeightOff;
	lCropHeight  =pbiIn->biHeight;
    }
    else
    {
	lSrcY	    =-lHeightOff;
	lDstY	    =0;
	lCropHeight =pbiOut->biHeight;
    }


    //	biBitCount: 0, bit implied by JPEG format
    //	1: monoChrome, 4: 16 color, 8, 16, 24, 32
    //we only support 8,16,24,32 bits.

    for(long y=lSrcY; y<(lSrcY+lCropHeight); y++)
    {
	long lSrcOffSet=lSrcX + y	*lInWidthBytes;
	long lDstOffSet=lDstX +	lDstY	*lOutWidthBytes;

	CopyMemory(&pOutBuf[lDstOffSet],&dibBits[lSrcOffSet],lCropWidth);
	lDstY++;
    }
}




HRESULT CStretch::CheckBufferSizes(IMediaSample *pIn, IMediaSample *pOut)
{
    if ((pIn== NULL) || (pOut == NULL))
    {
        return E_POINTER;
    }

    if (pOut->GetSize() <  (LONG)HEADER(m_mt.pbFormat)->biSizeImage)
    {
        return VFW_E_BUFFER_OVERFLOW;
    }
    return S_OK;
}



///
//  Transform
//
HRESULT CStretch::Transform(IMediaSample *pIn, IMediaSample *pOut)
{
    HRESULT hr = CheckBufferSizes(pIn, pOut);
    if (FAILED(hr))
    {
        return hr;
    }
    pOut->SetPreroll(pIn->IsPreroll() == S_OK);

    //get in and out buffer
    BYTE *pInBuffer, *pOutBuffer;
    pIn->GetPointer(&pInBuffer);
    pOut->GetPointer(&pOutBuffer);

    //get input and output BitMapInfoHeader
    BITMAPINFOHEADER *pbiOut = HEADER(m_mtOut.Format());
    BITMAPINFOHEADER *pbiIn = HEADER(m_mtIn.Format());

    if(m_dwResizeFlag == RESIZEF_CROP)
    {
	ZeroMemory(pOutBuffer, DIBSIZE(*pbiOut));
	CropRGB( pbiIn,		//Src's BitMapInfoHeader
		 pInBuffer,	//Src bits
		 pbiOut,	//Dsr'a BitmapinfoHeader
		 pOutBuffer );	//Dst bits
    }
    else if (m_dwResizeFlag == RESIZEF_PRESERVEASPECTRATIO_NOLETTERBOX)
    {
	double dy=(double)(pbiOut->biHeight)/(double)(pbiIn->biHeight);
	double dx=(double)(pbiOut->biWidth)/(double)(pbiIn->biWidth);

	if(dy!=dx)
	{
	    //keep the Y/X ratio
	    // variables for Source X and Y extant, and X and Y Coordinates
	    long lSrcXE,lSrcYE,lSrcX,lSrcY;
	    ZeroMemory(pOutBuffer, DIBSIZE(*pbiOut));

	    if( dy < dx )
	    {
		// the y ratio is smaller, therefore we need to fit the srcX competely to the destX
		// this will cause the srcY to stretch beyond the destY
		// therefore we will have to worry about the srcYExtant and srcY starting coordinate
		lSrcXE = pbiIn->biWidth;
		lSrcYE = pbiOut->biHeight * pbiIn->biWidth/pbiOut->biWidth;  // this will be the height of the destination
		lSrcX = 0;
		lSrcY = (pbiIn->biHeight - lSrcYE) >> 1;    // (difference in width) / 2
	    }
	    else
	    {
		// dy > dx
		// now the x ratio is smaller, therefore we need to fit srcY completely into destY
		// but this will cause srcX to stretch beyond destX
		// therfore we will modify srcXExtant, and srcX starting coordinate
		lSrcXE = pbiOut->biWidth * pbiIn->biHeight/pbiOut->biHeight;
		lSrcYE = pbiIn->biHeight;
		lSrcX = (pbiIn->biWidth - lSrcXE) >> 1;
		lSrcY = 0;
	    }
	    StretchDIB(
		pbiOut,   	    // --> BITMAPINFO of destination
		pOutBuffer,         // --> to destination bits
		0,                  // Destination origin - x coordinate
		0,                  // Destination origin - y coordinate
		pbiOut->biWidth,    // x extent of the BLT
		pbiOut->biHeight,   // y extent of the BLT
		pbiIn,   	    // --> BITMAPINFO of destination
		(void*) pInBuffer,  // --> to source bits
		lSrcX,              // Source origin - x coordinate
		lSrcY,              // Source origin - y coordinate
		lSrcXE,		    // x extent of the BLT
		lSrcYE		    // y extent of the BLT
		);
	}
	else
	    goto goto_Resize;
    }
    else if (m_dwResizeFlag == RESIZEF_PRESERVEASPECTRATIO)
    {
	double dy=(double)(pbiOut->biHeight)/(double)(pbiIn->biHeight);
	double dx=(double)(pbiOut->biWidth)/(double)(pbiIn->biWidth);

	if(dy!=dx)
	{
	    //keep the Y/X ratio
	    long lDstXE,lDstYE,lDstX,lDstY;
	    ZeroMemory(pOutBuffer, DIBSIZE(*pbiOut));

	    if( dy < dx )
	    {
		//y full strech,
		lDstXE	=pbiIn->biWidth*pbiOut->biHeight/pbiIn->biHeight;
		lDstYE	=pbiOut->biHeight;
		lDstX	=(pbiOut->biWidth-lDstXE)>>1;
		lDstY	=0;
	    }
	    else
	    {
		//x full strech
		lDstYE	=pbiIn->biHeight*pbiOut->biWidth/pbiIn->biWidth;
		lDstXE	=pbiOut->biWidth;
		lDstY	=(pbiOut->biHeight-lDstYE)>>1;
		lDstX	=0;
	    }
	    StretchDIB(
		pbiOut,   	    //	--> BITMAPINFO of destination
		pOutBuffer,             //  --> to destination bits
		lDstX,                  //  Destination origin - x coordinate
		lDstY,                  //  Destination origin - y coordinate
		lDstXE,          //  x extent of the BLT
		lDstYE,         //  y extent of the BLT
		pbiIn,   	 //	--> BITMAPINFO of destination
		(void*) pInBuffer,    //  --> to source bits
		0,                  //  Source origin - x coordinate
		0,                  //  Source origin - y coordinate
		pbiIn->biWidth,    //  x extent of the BLT
		pbiIn->biHeight    //  y extent of the BLT
		);
	}
	else
	    goto goto_Resize;
    // STRETCH
    } else {
	ASSERT(m_dwResizeFlag == RESIZEF_STRETCH);
goto_Resize:
	ZeroMemory(pOutBuffer, DIBSIZE(*pbiOut));

	ResizeRGB(  pbiIn,                          //Src's BitMapInFoHeader
		    pInBuffer,                      //Src bits
		    pbiOut,			    //Dst's BitMapInFoHeader
		    pOutBuffer,                     //Dst bits
		    (int)pbiOut->biWidth,           //new W in pixel
		    (int)pbiOut->biHeight );        //new H in pixel
    }

    pOut->SetActualDataLength(DIBSIZE(*pbiOut));

    return NOERROR;
}

// CheckInputType accepts any media type matching the media
// type set via the API, given the dimensions are non-zero.
HRESULT CStretch::CheckInputType(const CMediaType *mtIn)
{
    //DbgLog((LOG_TRACE,3,TEXT("Stretch::CheckInputType")));

    if (FAILED(InternalPartialCheckMediaTypes(mtIn, &m_mt)))
      return E_FAIL;

    VIDEOINFOHEADER *pv = (VIDEOINFOHEADER *)mtIn->Format();
    LPBITMAPINFOHEADER lpbi = HEADER(pv);

    // Final check - key fields: biCompression, biBitCount, biHeight, biWidth
    if (!lpbi->biHeight || !lpbi->biWidth)
      return E_FAIL;

    // we don't know how to deal with topside-right.  !!! We could!
    if (lpbi->biHeight < 0)
	return E_FAIL;

    return S_OK;
}


// CheckTransform - guarantee the media types for the input and output
// match our expectations (m_mt). The input type is guarded by the
// CheckInputType() method, so we're just perform a couple quick checks.
HRESULT CStretch::CheckTransform(const CMediaType *mtIn, const CMediaType *mtOut)
{
    if (FAILED(InternalPartialCheckMediaTypes(mtIn, mtOut)))
        return E_FAIL;

    LPBITMAPINFOHEADER lpbi = HEADER(mtOut->Format());

    if (lpbi->biHeight != HEADER(m_mt.Format())->biHeight ||
				lpbi->biWidth != HEADER(m_mt.Format())->biWidth)
        return E_FAIL;

    return S_OK;
}


// Tell the output pin's allocator what size buffers we require

HRESULT CStretch::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(pAlloc);
    ASSERT(pProperties);

    if (m_pInput->IsConnected() == FALSE) {
	return E_UNEXPECTED;
    }

    pProperties->cBuffers = 1;
    pProperties->cbBuffer = HEADER(m_mt.Format())->biSizeImage;

    ASSERT(pProperties->cbBuffer);

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
	return hr;
    }

    // Check we got at least what we asked for

    if ((pProperties->cBuffers > Actual.cBuffers) ||
	(pProperties->cbBuffer > Actual.cbBuffer)) {
	    return E_FAIL;
    }
    return NOERROR;
}


// Disconnected one of our pins

HRESULT CStretch::BreakConnect(PIN_DIRECTION dir)
{
    if (dir == PINDIR_INPUT) {
	m_mtIn.SetType(&GUID_NULL);
	return NOERROR;
    }

    ASSERT(dir == PINDIR_OUTPUT);
    m_mtOut.SetType(&GUID_NULL);
    return NOERROR;
}


// Tells us what media type we will be transforming

HRESULT CStretch::SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt)
{
    if (direction == PINDIR_INPUT) {
	m_mtIn = *pmt;
	return NOERROR;
    }

    ASSERT(direction == PINDIR_OUTPUT);
    m_mtOut = *pmt;
    return NOERROR;
}


// I support one type namely the type of the input pin

HRESULT CStretch::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (m_pInput->IsConnected() == FALSE) {
	return E_UNEXPECTED;
    }

    ASSERT(iPosition >= 0);
    if (iPosition > 0) {
	return VFW_S_NO_MORE_ITEMS;
    }

    *pMediaType = m_mt;

// !!! alter bit rate, other fields?

    return NOERROR;
}

STDMETHODIMP CStretch::NonDelegatingQueryInterface (REFIID riid, void **ppv)

  { // NonDelegatingQueryInterface //

    if (IsEqualIID(IID_ISpecifyPropertyPages, riid)) {
        return GetInterface((ISpecifyPropertyPages *)this, ppv);
    } else if (riid == IID_IPersistStream) {
	return GetInterface((IPersistStream *) this, ppv);
    } else if (IsEqualIID(IID_IResize, riid)) {
      return GetInterface((IResize *)this, ppv);
    } else {
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }

  } // NonDelegatingQueryInterface //

// --- ISpecifyPropertyPages ---

STDMETHODIMP CStretch::GetPages (CAUUID *pPages)

  { // GetPages //

    pPages->cElems = 1;
    pPages->pElems = (GUID *)CoTaskMemAlloc(sizeof(GUID));

    if (pPages->pElems == NULL)
	return E_OUTOFMEMORY;

    *(pPages->pElems) = CLSID_ResizeProp;

    return NOERROR;

  } // GetPages




// IPersistStream

// tell our clsid
//
STDMETHODIMP CStretch::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_Resize;
    return S_OK;
}

typedef struct _ResizeSave {
    int version;
    long dwResizeFlag;
    AM_MEDIA_TYPE mt;
    long x;	// fmt hidden here
} ResizeSave;

// persist ourself
//
HRESULT CStretch::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CStretch::WriteToStream")));

    CheckPointer(pStream, E_POINTER);
    ResizeSave *px;

    int savesize = sizeof(ResizeSave) + m_mt.cbFormat;
    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));
    px = (ResizeSave *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    px->version = 1;
    px->dwResizeFlag= m_dwResizeFlag;

    px->mt = m_mt; // AM_MEDIA_TYPE
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk = NULL;		// !!!

    // the format goes after the array
    CopyMemory(&px->x, m_mt.pbFormat, m_mt.cbFormat);

    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself
//
HRESULT CStretch::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CStretch::ReadFromStream")));
    CheckPointer(pStream, E_POINTER);

    int savesize1 = sizeof(ResizeSave) - sizeof(long);
    ResizeSave *px = (ResizeSave *)QzTaskMemAlloc(savesize1);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if (px->version != 1) {
        DbgLog((LOG_ERROR,1,TEXT("*** ERROR! Bad version file")));
        QzTaskMemFree(px);
	return S_OK;
    }

    // how much saved data was there, really?  Get the rest
    int savesize = sizeof(ResizeSave) + px->mt.cbFormat;
    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));
    px = (ResizeSave *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    hr = pStream->Read(&(px->x), savesize - savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }


    AM_MEDIA_TYPE mt = px->mt;

    put_Size(HEADER(m_mt.Format())->biHeight,HEADER(m_mt.Format())->biWidth,
							px->dwResizeFlag);

    mt.pbFormat = (BYTE *)QzTaskMemAlloc(mt.cbFormat);
    // remember, the format is after the array
    CopyMemory(mt.pbFormat, &(px->x), mt.cbFormat);

    put_MediaType(&mt);
    SaferFreeMediaType(mt);
    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}


// how big is our save data?
//
int CStretch::SizeMax()
{
    return sizeof(ResizeSave) + m_mt.cbFormat;
}



//
// --- IResize ---
//

HRESULT CStretch::get_Size(int *Height, int *Width, long *pdwFlag)
{
    CAutoLock cAutolock(&m_csFilter);

    CheckPointer(Height,E_POINTER);
    CheckPointer(Width,E_POINTER);

    *Height = HEADER(m_mt.Format())->biHeight;
    *Width = HEADER(m_mt.Format())->biWidth;
    *pdwFlag= m_dwResizeFlag;

    return NOERROR;

}

HRESULT CStretch::get_InputSize( int * Height, int * Width )
{
    CAutoLock Lock( &m_csFilter );

    CheckPointer( Height, E_POINTER );
    CheckPointer( Width, E_POINTER );

    if( !m_mtIn.Format( ) )
    {
        return E_POINTER;
    }

    *Height = HEADER( m_mtIn.Format( ) )->biHeight;
    *Width = HEADER( m_mtIn.Format( ) )->biWidth;

    return NOERROR;
}

HRESULT CStretch::put_Size(int Height, int Width, long dwFlag)
{
    CAutoLock cAutolock(&m_csFilter);

    // only do the check if the sizes differ
    //
    if( HEADER(m_mt.Format())->biHeight != Height ||
        HEADER(m_mt.Format())->biWidth != Width )
    {
        if (m_pOutput && m_pOutput->IsConnected())
        {
            // must succeed
            m_pGraph->Reconnect( m_pOutput );
        }

        HEADER(m_mt.Format())->biHeight = Height;
        HEADER(m_mt.Format())->biWidth = Width;
        HEADER(m_mt.Format())->biSizeImage = DIBSIZE(*HEADER(m_mt.Format()));
    }

    m_dwResizeFlag  = dwFlag;

    return NOERROR;

}


HRESULT CStretch::get_MediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(&m_csFilter);
    CheckPointer(pmt, E_POINTER);
    return CopyMediaType(pmt, &m_mt);
}


HRESULT CStretch::put_MediaType(const AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(&m_csFilter);
    if (m_pInput && m_pInput->IsConnected())
	return VFW_E_ALREADY_CONNECTED;
    if (m_pOutput && m_pOutput->IsConnected())
	return VFW_E_ALREADY_CONNECTED;
    // anything but uncompressed VIDEOINFO is not allowed in this filter
    if (pmt->majortype != MEDIATYPE_Video ||
		pmt->formattype != FORMAT_VideoInfo ||
		pmt->lSampleSize == 0) {
	return VFW_E_INVALID_MEDIA_TYPE;
    }

    SaferFreeMediaType(m_mt);
    return CopyMediaType(&m_mt, pmt);

    // Reconnect if this is allowed to change when connected
}




HRESULT CStretch::InternalPartialCheckMediaTypes(const CMediaType *mt1, const CMediaType *mt2)

  { // InternalPartialCheckMediaTypes //

    if (!IsEqualGUID(*mt1->Type(), *mt2->Type()))
      return E_FAIL;

    if (!IsEqualGUID(*mt1->Subtype(), *mt2->Subtype()))
      return E_FAIL;

    if (*mt1->FormatType() != *mt2->FormatType())
      return E_FAIL;

    LPBITMAPINFOHEADER lpbi1 = HEADER(mt1->Format());
    LPBITMAPINFOHEADER lpbi2 = HEADER(mt2->Format());

    if (lpbi1->biBitCount != lpbi2->biBitCount)
      return E_FAIL;

    return S_OK;

  } // InternalPartialCheckMediaTypes //





// Create our filter's preferred media type (RGB32, DEFAULT HEIGHT x DEF WIDTH)
// Lifted the code from ..\switch (with slight modification)
void CStretch::CreatePreferredMediaType (CMediaType *pmt)

  { // CreatePreferredMediaType //

    //ZeroMemory(pmt, sizeof(AM_MEDIA_TYPE));

    pmt->majortype = MEDIATYPE_Video;
    pmt->subtype = MEDIASUBTYPE_RGB32;
    pmt->formattype = FORMAT_VideoInfo;
    pmt->bFixedSizeSamples = TRUE;
    pmt->bTemporalCompression = FALSE;
    pmt->pbFormat = (BYTE *)QzTaskMemAlloc( sizeof(VIDEOINFOHEADER) );
    pmt->cbFormat = sizeof( VIDEOINFOHEADER );

    ZeroMemory(pmt->pbFormat, pmt->cbFormat);

    VIDEOINFOHEADER * pVI = (VIDEOINFOHEADER*) pmt->pbFormat;
    LPBITMAPINFOHEADER lpbi = &pVI->bmiHeader;

    lpbi->biSize = sizeof(BITMAPINFOHEADER);
    lpbi->biCompression = BI_RGB;
    lpbi->biBitCount = 32;
    lpbi->biWidth = DEFAULT_WIDTH;
    lpbi->biHeight = DEFAULT_HEIGHT;
    lpbi->biPlanes = 1;
    lpbi->biSizeImage = DIBSIZE(*lpbi);

    pmt->lSampleSize = DIBSIZE(*lpbi);
  } // CreatePreferredMediaType //

CStretchInputPin::CStretchInputPin(
    TCHAR              * pObjectName,
    CStretch 	       * pFilter,
    HRESULT            * phr,
    LPCWSTR              pPinName) :

    CTransformInputPin(pObjectName, pFilter, phr, pPinName)
{
}

CStretchInputPin::~CStretchInputPin()
{
};


// speed up intelligent connect INFINITELY by providing a VIDEO type here.
// DO NOT offer a fully specified type, that would connect us with that type,
// not the upstream filter's prefered type.  Then when the render engine
// disconnects this filter, and connects the upstream guy to somebody else,
// assuming he'll get the same type, he won't!  And graph building will fail
//
HRESULT CStretchInputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    ASSERT(iPosition >= 0);
    if (iPosition > 0) {
	return VFW_S_NO_MORE_ITEMS;
    }

    pMediaType->SetType(&MEDIATYPE_Video);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\silence\resource.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#define IDD_PROPPAGE 			400
#define IDC_RATE 			402
#define IDC_START4 			403
#define IDC_DUR 			404
#define IDC_SILENCE_NCHANNELNUM         405
#define IDC_SILENCE_NBITS               406
#define IDS_TITLE4			407
#ifndef IDC_STATIC
#define IDC_STATIC 	-1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\resize\stretchc.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stretchc.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

/*
 * StretchC.C
 *
 * StretchBlt for DIBs
 *
 * C version of stretch.asm: StretchDIB optimised for AVI.
 *
 * NOTES
 *	- does not handle mirroring in x or y
 *	- does not handle pixel translation
 *	- will not work in place.
 *
 * AUTHOR
 *      C version by Geraint Davies
 */

#include <streams.h>

/* Outline:
 *
 * we select a y-stretching function depending on the ratio (eg 1:N or N:1).
 * it copies scanlines from source to destination, duplicating or omitting
 * scanlines as necessary to fit the destination. It copies each scanline
 * via the X_FUNC function we passed as an argument: this copies one scanline
 * duplicating or omitting pixels to fit the destination: we select an X_FUNC
 * depending on the bit-depth as well as the x-stretching ratio.
 *
 * both x and y stretching functions use the following basic model for deciding
 * when to insert/omit elements:
 *
 * 	delta = <larger extent> -1;
 *
 *      for (number of destination elements) {
 *
 *		copy one element
 *		advance pointer to larger region
 *		delta -= <smaller extent>
 *		if (delta < 0) {
 *			delta += <larger extent>;
 *			advance pointer to smaller region
 *		}
 *	}
 */


/* stretch proportions */
#define STRETCH_1_1	1
#define STRETCH_1_2	2
#define STRETCH_1_4	3
#define STRETCH_1_N	4
#define STRETCH_N_1	5
#define STRETCH_4_1	6
#define STRETCH_2_1	7



/*
 * an X_FUNC is a function that copies one scanline, stretching or shrinking it
 * to fit a destination scanline. Pick an X_FUNC depending on
 * bitdepth and stretch ratio (1:1, 1:2, 1:4, 1:N, N:1, 4:1, 2:1)
 *
 * the x_fract argument is the delta fraction: it is a representation
 * of the smaller extent (whichever that is) as a fraction of the larger,
 * and is used when stretching or shrinking to advance the pointer to the
 * smaller scanline every (fract) pixels of the larger.
 * Thus if we are expanding 1:8, x_fract will be 1/8, we will advance the
 * source pointer once every 8 pixels, and thus copy each source pixel to
 * 8 dest pixels. Note that if shrinking 8:1, x_fract will still be 1/8
 * and we will use it to control advancement of the dest pointer.
 * the fraction is multiplied by 65536.
 */
typedef void (*X_FUNC) (LPBYTE lpSrc,
			LPBYTE lpDst,
			int SrcXE,
			int DstXE,
			int x_fract);


void X_Stretch_1_1_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_2_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_4_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_N_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_N_1_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);

void X_Stretch_1_1_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_2_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_N_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_N_1_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);

void X_Stretch_1_1_24Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_N_24Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_N_1_24Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);

void X_Stretch_1_1_32Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_1_N_32Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);
void X_Stretch_N_1_32Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE, int DstXE, int x_fract);


/*
 * Y_Stretch_* functions copy DstYE scanlines (using
 * an X_FUNC to copy each scanline) omitting or duplicating scanlines to
 * fit the destination extent. Pick a Y_ depending on the ratio
 * (1:N, N:1...)
 */

void Y_Stretch_1_N(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract,
		   X_FUNC x_func, int nBits);

void Y_Stretch_N_1(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract,
		   X_FUNC x_func);

/*
 * special case y-stretch functions for 1:2 in both dimensions for 8 and 16 bits
 * takes no X_FUNC arg. Will do entire stretch.
 */
void Stretch_1_2_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract);


void Stretch_1_2_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract);

/* straight copy of one scanline of count bytes */
void X_CopyScanline(LPBYTE lpSrc, LPBYTE lpDst, int count);


/* -------------------------------------------------------------------- */

/*
 * StretchFactor
 *
 * calculate the stretch factor (proportion of source extent to destination
 * extent: 1:1, 1:2, 1:4, 1:N, N:1, 4:1,or 2:1) and also the
 * delta fraction (see above comment on X_FUNC). This is the ratio of
 * the smaller extent to the larger extent, represented as a fraction
 * multiplied by 65536.
 *
 * returns: the stretch factor  (stores the delta fraction in *pfract)
 */

int
StretchFactor(int SrcE, int DstE, int *pfract)
{


	if (SrcE == DstE) {
		if (pfract != NULL) {
			pfract = 0;	     	
		}

		return(STRETCH_1_1);

	}


	if (SrcE > DstE) {
		if (pfract != NULL) {
			*pfract = ( (DstE << 16) / SrcE) & 0xffff;
		}

		if (SrcE == (DstE * 2)) {
			return(STRETCH_2_1);
		} else if (SrcE == (DstE * 4)) {
			return(STRETCH_4_1);
		} else {
			return(STRETCH_N_1);
		}

	} else {

		/* calculate delta fraction based on smallest / largest */
		if (pfract != NULL) {
			*pfract = ( (SrcE << 16) / DstE) & 0xffff;
		}
	
		if (DstE == (SrcE * 2)) {
			return(STRETCH_1_2);
		} else if (DstE == (SrcE * 4)) {
			return(STRETCH_1_4);
		} else {
			return(STRETCH_1_N);
		}
	}
}


/* -------------------------------------------------------------------- */

/*
 * StretchDIB
 *
 */

void FAR PASCAL
StretchDIB(
	LPBITMAPINFOHEADER biDst,   //	--> BITMAPINFO of destination
	LPVOID	lpvDst,		    //	--> to destination bits
	int	DstX,		    //	Destination origin - x coordinate
	int	DstY,		    //	Destination origin - y coordinate
	int	DstXE,		    //	x extent of the BLT
	int	DstYE,		    //	y extent of the BLT
	LPBITMAPINFOHEADER biSrc,   //	--> BITMAPINFO of source
	LPVOID	lpvSrc,		    //	--> to source bits
	int	SrcX,		    //	Source origin - x coordinate
	int	SrcY,		    //	Source origin - y coordinate
	int	SrcXE,		    //	x extent of the BLT
	int	SrcYE	 	    //	y extent of the BLT
	)
{

	int nBits;
	int SrcWidth, DstWidth;
	LPBYTE lpDst = (LPBYTE)lpvDst, lpSrc = (LPBYTE)lpvSrc;
	int x_fract;
	int x_factor;
	int y_factor;
	X_FUNC xfunc;
	

	/*
	 * check that bit depths are same and 8, 16 or 24
	 */

	if ((nBits = biDst->biBitCount) != biSrc->biBitCount) {
		return;
	}

	if ( (nBits != 8 ) && (nBits != 16) && (nBits != 24) &&
							(nBits != 32)) {
		return;
	}

	/*
	 * check that extents are not bad
	 */
	if ( (SrcXE <= 0) || (SrcYE <= 0) || (DstXE <= 0) || (DstYE <= 0)) {
		return;
	}

	/*
	 * calculate width of one scan line in bytes, rounded up to
	 * DWORD boundary.
	 */
	SrcWidth = (((biSrc->biWidth * nBits) + 31) & ~31) / 8;
	DstWidth = (((biDst->biWidth * nBits) + 31) & ~31) / 8;

	/*
	 * set initial source and dest pointers
	 */
	lpSrc += (SrcY * SrcWidth) + ((SrcX * nBits) / 8);
	lpDst += (DstY * DstWidth) + ((DstX * nBits) / 8);


	/*
	 * calculate stretch proportions (1:1, 1:2, 1:N, N:1 etc) and
	 * also the fractional stretch factor. (we are not interested in
	 * the y stretch fraction - this is only used in x stretching.
	 */

	y_factor = StretchFactor(SrcYE, DstYE, NULL);
	x_factor = StretchFactor(SrcXE, DstXE, &x_fract);

	/*
	 * we have special case routines for 1:2 in both dimensions
	 * for 8 and 16 bits
	 */
	if ((y_factor == x_factor) && (y_factor == STRETCH_1_2)) {

		if (nBits == 8) {
			//StartCounting();
			Stretch_1_2_8Bits(lpSrc, lpDst, SrcXE, SrcYE,
					  DstXE, DstYE, SrcWidth, DstWidth,
					  x_fract);
			//EndCounting("8 bit");
			return;

		} else if (nBits == 16) {
			//StartCounting();
			Stretch_1_2_16Bits(lpSrc, lpDst, SrcXE, SrcYE,
					  DstXE, DstYE, SrcWidth, DstWidth,
					  x_fract);
			//EndCounting("16 bit");
			return;
		}
	}


	/* pick an X stretch function */
	switch(nBits) {

	case 8:
		switch(x_factor) {
		case STRETCH_1_1:
			xfunc = X_Stretch_1_1_8Bits;
			break;

		case STRETCH_1_2:
			xfunc = X_Stretch_1_2_8Bits;
			break;

		case STRETCH_1_4:
			xfunc = X_Stretch_1_4_8Bits;
			break;

		case STRETCH_1_N:
			xfunc = X_Stretch_1_N_8Bits;
			break;

		case STRETCH_N_1:
		case STRETCH_4_1:
		case STRETCH_2_1:
			xfunc = X_Stretch_N_1_8Bits;
			break;

		}
		break;

	case 16:
		switch(x_factor) {
		case STRETCH_1_1:
			xfunc = X_Stretch_1_1_16Bits;
			break;

		case STRETCH_1_2:
			xfunc = X_Stretch_1_2_16Bits;
			break;

		case STRETCH_1_4:
		case STRETCH_1_N:
			xfunc = X_Stretch_1_N_16Bits;
			break;

		case STRETCH_N_1:
		case STRETCH_4_1:
		case STRETCH_2_1:
			xfunc = X_Stretch_N_1_16Bits;
			break;

		}
		break;

	case 24:
		switch(x_factor) {
		case STRETCH_1_1:
			xfunc = X_Stretch_1_1_24Bits;
			break;

		case STRETCH_1_2:
		case STRETCH_1_4:
		case STRETCH_1_N:
			xfunc = X_Stretch_1_N_24Bits;
			break;

		case STRETCH_N_1:
		case STRETCH_4_1:
		case STRETCH_2_1:
			xfunc = X_Stretch_N_1_24Bits;
			break;

		}
		break;

	case 32:
		switch(x_factor) {
		case STRETCH_1_1:
			xfunc = X_Stretch_1_1_32Bits;
			break;

		case STRETCH_1_2:
		case STRETCH_1_4:
		case STRETCH_1_N:
			xfunc = X_Stretch_1_N_32Bits;
			break;

		case STRETCH_N_1:
		case STRETCH_4_1:
		case STRETCH_2_1:
			xfunc = X_Stretch_N_1_32Bits;
			break;

		}
		break;

	}


	/*
	 * now call appropriate stretching function depending
	 * on the y stretch factor
	 */
	switch (y_factor) {
	case STRETCH_1_1:
	case STRETCH_1_2:
	case STRETCH_1_4:
	case STRETCH_1_N:
		Y_Stretch_1_N(lpSrc, lpDst, SrcXE, SrcYE,
			      DstXE, DstYE, SrcWidth, DstWidth, x_fract, xfunc, nBits);
		break;

	case STRETCH_N_1:
	case STRETCH_4_1:
	case STRETCH_2_1:
		Y_Stretch_N_1(lpSrc, lpDst, SrcXE, SrcYE,
			      DstXE, DstYE, SrcWidth, DstWidth, x_fract, xfunc);
		break;

	}
	return;
}


/* ---- y stretching -------------------------------------------- */

/*
 * call an X_FUNC to copy scanlines from lpSrc to lpDst. Duplicate or
 * omit scanlines to stretch SrcYE to DstYE.
 */


/*
 * Y_Stretch_1_N
 *
 * write DstYE scanlines based on SrcYE scanlines, DstYE > SrcYE
 *
 */

void
Y_Stretch_1_N(LPBYTE lpSrc,
              LPBYTE lpDst,
              int SrcXE,
              int SrcYE,
              int DstXE,
              int DstYE,
	      int SrcWidth,
	      int DstWidth,
              int x_fract,
              X_FUNC x_func,
              int nBits)
{

	int ydelta;
	int i;
	LPBYTE lpPrev = NULL;

	ydelta = DstYE -1;

	for (i = 0; i < DstYE; i++) {

		/* have we already stretched this scanline ? */
		if (lpPrev == NULL) {
			/* no - copy one scanline */
			(*x_func)(lpSrc, lpDst, SrcXE, DstXE, x_fract);
			lpPrev = lpDst;
		} else {	
			/* yes - this is a duplicate scanline. do
			 * a straight copy of one that has already
			 * been stretched/shrunk
			 */
			X_CopyScanline(lpPrev, lpDst, DstXE * nBits / 8);
		}

		/* advance dest pointer */
		lpDst += DstWidth;

		/* should we advance source pointer this time ? */
		if ( (ydelta -= SrcYE) < 0) {
			ydelta += DstYE;
			lpSrc += SrcWidth;
			lpPrev = NULL;
		}
	}
}


/*
 * Y_Stretch_N_1
 *
 * write DstYE scanlines based on SrcYE scanlines, DstYE < SrcYE
 *
 */
void
Y_Stretch_N_1(LPBYTE lpSrc,
              LPBYTE lpDst,
              int SrcXE,
              int SrcYE,
              int DstXE,
              int DstYE,
	      int SrcWidth,
	      int DstWidth,
              int x_fract,
              X_FUNC x_func)
{

	int ydelta;
	int i;

	ydelta = SrcYE -1;

	for (i = 0; i < DstYE; i++) {

		/* copy one scanline */
		(*x_func)(lpSrc, lpDst, SrcXE, DstXE, x_fract);

		/* advance dest pointer */
		lpDst += DstWidth;

		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc += SrcWidth;
			ydelta -= DstYE;
		} while (ydelta >= 0);

		ydelta += SrcYE;
	}
}

/* ---8-bit X stretching -------------------------------------------------- */

/*
 * X_Stretch_1_N_8Bits
 *
 * copy one scan line, stretching 1:N (DstXE > SrcXE). For 8-bit depth.
 */
void
X_Stretch_1_N_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = DstXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one byte and advance dest */
		*lpDst++ = *lpSrc;

		/* should we advance source pointer this time ? */
		if ( (xdelta -= SrcXE) < 0) {
			xdelta += DstXE;
			lpSrc++;
		}
	}
}


/*
 * X_Stretch_N_1_8Bits
 *
 * copy one scan line, shrinking N:1 (DstXE < SrcXE). For 8-bit depth.
 */
void
X_Stretch_N_1_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = SrcXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one byte and advance dest */
		*lpDst++ = *lpSrc;

		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc++;
			xdelta -= DstXE;
		} while (xdelta >= 0);

		xdelta += SrcXE;
	}
}

/*
 * copy one scanline of count bytes from lpSrc to lpDst. used by 1:1
 * scanline functions for all bit depths
 */
void
X_CopyScanline(LPBYTE lpSrc, LPBYTE lpDst, int count)
{
	int i;

	/*
	 * if the alignment of lpSrc and lpDst is the same, then
	 * we can get them aligned and do a faster copy
	 */
        if (((DWORD_PTR) lpSrc & 0x3) == ( (DWORD_PTR) lpDst & 0x3)) {
		
		/* align on WORD boundary */
		if ( (DWORD_PTR) lpSrc & 0x1) {
			*lpDst++ = *lpSrc++;
			count--;
		}

		/* align on DWORD boundary */
		if ((DWORD_PTR) lpSrc & 0x2) {
			* ((LPWORD) lpDst) = *((LPWORD) lpSrc);
			lpDst += sizeof(WORD);
			lpSrc += sizeof(WORD);
			count -= sizeof(WORD);
		}

		/* copy whole DWORDS */
		for ( i = (count / 4); i > 0; i--) {
			*((LPDWORD) lpDst) =  *((LPDWORD) lpSrc);
			lpSrc += sizeof(DWORD);
			lpDst += sizeof(DWORD);
		}
	} else {
		/* the lpSrc and lpDst pointers are different
		 * alignment, so leave them unaligned and
		 * copy all the whole DWORDs
		 */
                for (i = (count / 4); i> 0; i--) {
			*( (DWORD UNALIGNED FAR *) lpDst) =
				*((DWORD UNALIGNED FAR *) lpSrc);
			lpSrc += sizeof(DWORD);
			lpDst += sizeof(DWORD);
		}
	}

	/* in either case, copy last (up to 3) bytes. */
	for ( i = count % 4; i > 0; i--) {
		*lpDst++ = *lpSrc++;
	}
}
		
/*
 * X_Stretch_1_1_8Bits
 *
 * copy a scanline with no change (1:1)
 */
void
X_Stretch_1_1_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	X_CopyScanline(lpSrc, lpDst, DstXE);
}


/*
 * X_Stretch_1_2_8Bits
 *
 * copy a scanline, doubling all the pixels (1:2)
 */
void
X_Stretch_1_2_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
   	WORD wPix;
	int i;

	for (i = 0; i < SrcXE; i++) {
		
		/* get a pixel and double it */
		wPix = *lpSrc++;
		wPix |= (wPix << 8);
		* ((WORD UNALIGNED *) lpDst) = wPix;
		lpDst += sizeof(WORD);
	}
}


/*
 * X_Stretch_1_4_8Bits
 *
 * copy a scanline, quadrupling all the pixels (1:4)
 */
void
X_Stretch_1_4_8Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	DWORD dwPix;
	int i;

	for (i = 0; i < SrcXE; i++) {

		/* get a pixel and make four copies of it */
		dwPix = *lpSrc++;
		dwPix |= (dwPix <<8);
		dwPix |= (dwPix << 16);
		* ((DWORD UNALIGNED *) lpDst) = dwPix;
		lpDst += sizeof(DWORD);
	}
}


/*  -- 16-bit X functions -----------------------------------------------*/

/*
 * copy one scan-line of 16 bits with no change (1:1)
 */
void
X_Stretch_1_1_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	X_CopyScanline(lpSrc, lpDst, DstXE * sizeof(WORD));

}


/*
 * copy one scanline of 16 bpp duplicating each pixel
 */
void
X_Stretch_1_2_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

   	DWORD dwPix;
	int i;

	for (i = 0; i < SrcXE; i++) {
		
		/* get a pixel and double it */
		dwPix = * ((WORD *)lpSrc);
		dwPix |= (dwPix << 16);
		* ((DWORD UNALIGNED *) lpDst) = dwPix;

		lpDst += sizeof(DWORD);
		lpSrc += sizeof(WORD);
	}

}

/*
 * copy one scanline of 16 bits, stretching 1:n (dest > source)
 */
void
X_Stretch_1_N_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = DstXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one pixel and advance dest */
		*((WORD *) lpDst) = *((WORD *) lpSrc);

		lpDst += sizeof(WORD);

		/* should we advance source pointer this time ? */
		if ( (xdelta -= SrcXE) < 0) {
			xdelta += DstXE;
			lpSrc += sizeof(WORD);
		}
	}
}

/*
 * copy one scanline of 16bits, shrinking n:1 (dest < source)
 */
void
X_Stretch_N_1_16Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	int xdelta;
	int i;

	xdelta = SrcXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy one pixel and advance dest */
		*((WORD *) lpDst) = *((WORD *)lpSrc);

		lpDst += sizeof(WORD);

		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc += sizeof(WORD);
			xdelta -= DstXE;
		} while (xdelta >= 0);

		xdelta += SrcXE;
	}

}


/* 24-bits ---------------------------------------------------------*/

/*
 * copy one 24-bpp scanline as is (1:1)
 */
void
X_Stretch_1_1_24Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	X_CopyScanline(lpSrc, lpDst, DstXE * 3);
}

/*
 * copy one 24-bpp scanline stretching 1:n (dest > source)
 */
void
X_Stretch_1_N_24Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{

	int xdelta;
	int i;

	xdelta = DstXE -1;

	for (i = 0; i < DstXE; i++) {
		/* copy first word of pixel and advance dest */
		*((WORD UNALIGNED *) lpDst) = *((WORD UNALIGNED *) lpSrc);

		lpDst += sizeof(WORD);

		/* copy third byte and advance dest */
		*lpDst++ = lpSrc[sizeof(WORD)];

		/* should we advance source pointer this time ? */
		if ( (xdelta -= SrcXE) < 0) {
			xdelta += DstXE;
			lpSrc += 3;
		}
	}
}

/*
 * copy one scanline of 24 bits, shrinking n:1 (dest < source)
 */
void
X_Stretch_N_1_24Bits(LPBYTE lpSrc,
		    LPBYTE lpDst,
		    int SrcXE,
		    int DstXE,
		    int x_fract)
{
	int xdelta;
	int i;

	xdelta = SrcXE -1;

	for (i = 0; i < DstXE; i++) {

		/* copy first word of pixel and advance dest */
		*((WORD UNALIGNED *) lpDst) = *((WORD UNALIGNED *) lpSrc);

		lpDst += sizeof(WORD);

		/* copy third byte and advance dest */
		*lpDst++ = lpSrc[sizeof(WORD)];


		/* how many times do we advance source pointer this time ? */
		do {
			lpSrc += 3;
			xdelta -= DstXE;
		} while (xdelta >= 0);

		xdelta += SrcXE;
	}
}		


/* 32-bits ---------------------------------------------------------*/

/*
 * copy one 32-bpp scanline as is (1:1)
 */
void
X_Stretch_1_1_32Bits(LPBYTE lpSrc,
            LPBYTE lpDst,
            int SrcXE,
            int DstXE,
            int x_fract)
{
    X_CopyScanline((BYTE*) lpSrc, (BYTE*) lpDst, DstXE * sizeof( RGBQUAD ) );
}

/*
 * copy one 32-bpp scanline stretching 1:n (dest > source)
 */
void
X_Stretch_1_N_32Bits(LPBYTE lpSrc0,
            LPBYTE lpDst0,
            int SrcXE,
            int DstXE,
            int x_fract)
{

    int xdelta;
    int i;

    RGBQUAD *lpSrc=(RGBQUAD *)lpSrc0;
    RGBQUAD *lpDst=(RGBQUAD *)lpDst0;
    

    xdelta = DstXE -1;

    for (i = 0; i < DstXE; i++) 
    {
        /* copy first word of pixel and advance dest */
        *lpDst = *lpSrc;
        lpDst++;

        /* should we advance source pointer this time ? */
        if ( (xdelta -= SrcXE) < 0) 
        {
            xdelta += DstXE;
            lpSrc++;
        }
    }
}

/*
 * copy one scanline of 32 bits, shrinking n:1 (dest < source)
 */
void
X_Stretch_N_1_32Bits(LPBYTE lpSrc0,
            LPBYTE lpDst0,
            int SrcXE,
            int DstXE,
            int x_fract)
{
    int xdelta;
    int i;

    RGBQUAD *lpSrc=(RGBQUAD *)lpSrc0;
    RGBQUAD *lpDst=(RGBQUAD *)lpDst0;
    
    xdelta = SrcXE -1;

    for (i = 0; i < DstXE; i++) 
    {
        *lpDst = *lpSrc;
        lpDst++;

        /* how many times do we advance source pointer this time ? */
        do 
        {
                lpSrc++;
                xdelta -= DstXE;
        } while (xdelta >= 0);

        xdelta += SrcXE;
    }
}        




/* -- special-case 1:2 -------------------------------------------*/

/*
 * stretch 1:2 in both directions, for 8 bits.
 *
 * An experiment was done on x86 to only write every other line during
 * the stretch and when the whole frame was done to use memcpy to fill
 * in the gaps.  This is slower than doing the stretch in a single pass.
 */
void
Stretch_1_2_8Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract)
{

	int SrcInc, DstInc;
	int i, j;
	WORD wPix;
	DWORD dwPix4;

	/* amount to advance source by at the end of each scan */
	SrcInc = SrcWidth - SrcXE;


	/* amount to advance dest by at the end of each scan - note
	 * that we write two scans at once, so advance past the next
	 * scan line
	 */
	DstInc = (DstWidth * 2) - DstXE;

	/*
	 * we would like to copy the pixels DWORD at a time. this means
	 * being aligned. if we are currently aligned on a WORD boundary,
	 * then copy one pixel to get aligned. If we are on a byte
	 * boundary, we can never get aligned, so use the slower loop.
	 */
	if ( ((DWORD_PTR)lpDst) & 1) {

		/*
		 * dest is byte aligned - so we can never align it
		 * by writing WORDs - use slow loop.
		 */
		for (i = 0; i < SrcYE; i++) {
	
			for (j = 0; j < SrcXE; j++) {
	
				/* get a pixel and double it */
	
				wPix = *lpSrc++;
				wPix |= (wPix<<8);
	
	
				/* write doubled pixel to this scanline */
	
				*( (WORD UNALIGNED *) lpDst) = wPix;
	
				/* write double pixel to next scanline */
				*( (WORD UNALIGNED *) (lpDst + DstWidth)) = wPix;
	
				lpDst += sizeof(WORD);
			}
			lpSrc += SrcInc;
			lpDst += DstInc;
		}
		return;
	}

	/*
	 * this will be the aligned version. align each scan line
	 */
	for ( i = 0; i < SrcYE; i++) {

		/* count of pixels remaining */
		j = SrcXE;

		/* align this scan line */
		if (((DWORD_PTR)lpDst) & 2) {

			/* word aligned - copy one doubled pixel and we are ok */
			wPix = *lpSrc++;
			wPix |= (wPix << 8);
	
			*( (WORD *) lpDst) = wPix;
  			*( (WORD *) (lpDst + DstWidth)) = wPix;
			lpDst += sizeof(WORD);

			j -= 1;
		}


		/* now dest is aligned - so loop eating two pixels at a time
		 * until there is at most one left
		 */
               	for ( ; j > 1; j -= 2) {

			/* read two pixels and double them */
			wPix = * ((WORD UNALIGNED *) lpSrc);
			lpSrc += sizeof(WORD);

			dwPix4 = (wPix & 0xff) | ((wPix & 0xff) << 8);
			dwPix4 |= ((wPix & 0xff00) << 8) | ((wPix & 0xff00) << 16);
			*((DWORD *) lpDst) = dwPix4;
  			*((DWORD *) (lpDst + DstWidth)) = dwPix4;

			lpDst += sizeof(DWORD);
		}

		/* odd byte remaining ? */
		if (j > 0) {
			/* word aligned - copy one doubled pixel and we are ok */
			wPix = *lpSrc++;
			wPix |= (wPix << 8);
	
			*( (WORD *) lpDst) = wPix;
			*( (WORD *) (lpDst + DstWidth)) = wPix;
			lpDst += sizeof(WORD);

			j -= 1;
		}
		lpSrc += SrcInc;
		lpDst += DstInc;
	}
}



/* ----------------------------------------------------------------*/

/*
 * stretch 1:2 in both directions, for 16-bits
 */

void
Stretch_1_2_16Bits(LPBYTE lpSrc, LPBYTE lpDst, int SrcXE,int SrcYE, int DstXE,
		   int DstYE, int SrcWidth, int DstWidth, int x_fract)

{
	int SrcInc, DstInc;
	int i, j;
	DWORD dwPix;

	/* amount to advance source by at the end of each scan */
	SrcInc = SrcWidth - (SrcXE * sizeof(WORD));


	/* amount to advance dest by at the end of each scan - note
	 * that we write two scans at once, so advance past the next
	 * scan line
	 */
	DstInc = (DstWidth * 2) - (DstXE * sizeof(WORD));

	for (i = 0; i < SrcYE; i++) {

		for (j = 0; j < SrcXE; j++) {

			/* get a pixel and double it */

			dwPix = *((WORD *)lpSrc);
			dwPix |= (dwPix<<16);

			lpSrc += sizeof(WORD);

			/* write doubled pixel to this scanline */

			*( (DWORD UNALIGNED *) lpDst) = dwPix;

			/* write double pixel to next scanline */
			*( (DWORD UNALIGNED *) (lpDst + DstWidth)) = dwPix;

			lpDst += sizeof(DWORD);
		}
	        lpSrc += SrcInc;
		lpDst += DstInc;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\silence\silence.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: silence.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// !!! allow setting entire media type, not just sample rate for other uses

// !!! use 2 ro buffers, call GetBuffer twice!

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "silence.h"
#include "resource.h"
#include "..\util\filfuncs.h"

const int DEFAULT_DELAY = 0000;  /* in ms */
const int DEFAULT_AUDIORATE = 44100;  /* samples/sec */

// //////////////////////////////////////////////////////////////////////////////////
// /////// CSilenceFilter ///////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////

CUnknown * WINAPI CSilenceFilter::CreateInstance (LPUNKNOWN lpunk, HRESULT *phr)

  { // CreateInstance //

    CUnknown *punk = new CSilenceFilter(lpunk, phr);

    if (NULL == punk)
        *phr = E_OUTOFMEMORY;

    return punk;

  } // CreateInstance //

CSilenceFilter::CSilenceFilter (LPUNKNOWN lpunk, HRESULT *phr) :
  CSource(NAME("Silence"), lpunk, CLSID_Silence)
  ,CPersistStream(lpunk, phr)


  { // Constructor //

    CAutoLock lock(&m_cStateLock);

    m_paStreams = (CSourceStream **) new CSilenceStream*[1];

    if (NULL == m_paStreams)
      {
        *phr = E_OUTOFMEMORY;
        return;
      }

    m_paStreams[0] = new CSilenceStream(phr, this, L"Audio out");

    if (NULL == m_paStreams[0])
      {
        *phr = E_OUTOFMEMORY;
        return;
      }

  } // Constructor //

CSilenceFilter::~CSilenceFilter(void)

  { // Destructor //
  } // Destructor //

STDMETHODIMP CSilenceFilter::NonDelegatingQueryInterface (REFIID riid, void **ppv)

  { // NonDelegatingQueryInterface //

    if (riid == IID_IPersistStream)
	return GetInterface((IPersistStream *) this, ppv);

    return CSource::NonDelegatingQueryInterface(riid, ppv);

  } // NonDelegatingQueryInterface //



// ---------- IPersistStream

// tell our clsid
//
STDMETHODIMP CSilenceFilter::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_Silence;
    return S_OK;
}

typedef struct _SILENCESave {
    REFERENCE_TIME	rtStartTime;
    REFERENCE_TIME	rtDuration;
    AM_MEDIA_TYPE mt; // format is hidden after the array
} SILENCESav;

// !!! we only support 1 stat/stop/skew right now

// persist ourself
//
HRESULT CSilenceFilter::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CSilenceFilter::WriteToStream")));

    CheckPointer(pStream, E_POINTER);
    SILENCESav *px;

    CSilenceStream *pOutpin=( CSilenceStream *)m_paStreams[0];

    CMediaType MyMt;
    pOutpin->get_MediaType( &MyMt );

    int savesize = sizeof(SILENCESav) + MyMt.cbFormat;

    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));

    px = (SILENCESav *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	SaferFreeMediaType(MyMt);
	return E_OUTOFMEMORY;
    }

    //save data
    REFERENCE_TIME rtStop, rt;
    double d;
    pOutpin->GetStartStopSkew(&(px->rtStartTime), &rtStop, &rt, &d);
    px->rtDuration = rtStop - px->rtStartTime;

    px->mt	    = MyMt;
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk	    = NULL;		// !!!

    // the format goes after the array
    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(SILENCESav);
    CopyMemory(pb, MyMt.pbFormat, MyMt.cbFormat);

    HRESULT hr = pStream->Write(px, savesize, 0);
    SaferFreeMediaType(MyMt);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;

}


// load ourself
//
HRESULT CSilenceFilter::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CenBlkVid::ReadFromStream")));

    CheckPointer(pStream, E_POINTER);

    int savesize=sizeof(SILENCESav);

    // we don't yet know how many saved connections there are
    // all we know we have for sure is the beginning of the struct
    SILENCESav *px = (SILENCESav *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if(px->mt.cbFormat)
    {
	// how much saved data was there, really?  Get the rest
	savesize +=  px->mt.cbFormat;
	px = (SILENCESav *)QzTaskMemRealloc(px, savesize);
	if (px == NULL) {
	    DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	    return E_OUTOFMEMORY;
	}

    }
    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));


    BYTE *pb;
    pb=(BYTE *)(px)+sizeof(SILENCESav) ;
    hr = pStream->Read(pb, (savesize-sizeof(SILENCESav)), 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    CSilenceStream *pOutpin=( CSilenceStream *)m_paStreams[0];
    pOutpin->ClearStartStopSkew();
    pOutpin->AddStartStopSkew(px->rtStartTime, px->rtStartTime +
					px->rtDuration, 0, 1);

    AM_MEDIA_TYPE MyMt = px->mt;
    MyMt.pbFormat = (BYTE *)QzTaskMemAlloc(MyMt.cbFormat);
    if (MyMt.pbFormat == NULL) {
        QzTaskMemFree(px);
        return E_OUTOFMEMORY;
    }

    // remember, the format is after the array
    CopyMemory(MyMt.pbFormat, pb, MyMt.cbFormat);

    pOutpin->put_MediaType (&MyMt);
    SaferFreeMediaType(MyMt);
    QzTaskMemFree(px);

    SetDirty(FALSE);
    return S_OK;
}

// how big is our save data?
int CSilenceFilter::SizeMax()
{
    return sizeof(SILENCESav);
}


// //////////////////////////////////////////////////////////////////////////////////
// /////// CSilenceStream ///////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////

CSilenceStream::CSilenceStream (HRESULT *phr, CSilenceFilter *pParent, LPCWSTR pName) :
    CSourceStream(NAME("Src Stream"),phr, pParent, pName)
    , m_iBufferCnt(0)    //How many source buffer we get
    , m_ppbDstBuf(NULL)	 //will be used to zero the Dst buffers
    , m_bZeroBufCnt(0)	// How many source buffer already set to zero.
    , m_rtNewSeg(0)	// last NewSeg given

  { // Constructor //

    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE));

    //set default
    m_mtAccept.majortype = MEDIATYPE_Audio;
    m_mtAccept.subtype = MEDIASUBTYPE_PCM;
    m_mtAccept.formattype = FORMAT_WaveFormatEx;

    WAVEFORMATEX * pwf = (WAVEFORMATEX*)
			 m_mtAccept.AllocFormatBuffer( sizeof(WAVEFORMATEX) );
    if( !pwf )
    {
        *phr = E_OUTOFMEMORY;
        return;
    }
    ZeroMemory(pwf, sizeof(WAVEFORMATEX));
    pwf->wFormatTag       = WAVE_FORMAT_PCM;
    pwf->nSamplesPerSec   = 44100;
    pwf->wBitsPerSample   = 16;
    pwf->nChannels        = 2;
    pwf->nBlockAlign      = pwf->wBitsPerSample * pwf->nChannels / 8;
    pwf->nAvgBytesPerSec  = (int)((DWORD) pwf->nBlockAlign * pwf->nSamplesPerSec);
    pwf->cbSize           = 0;

    pParent->m_stream = this;

    // Defaults; use IDexterSequencer to set 'real' values
    m_rtStartTime       = DEFAULT_DELAY*10000;
    // MUST BE INFINITE stop time, Dexter doesn't set a stop time!
    // not too big so math on it will overflow, though
    m_rtDuration        = (MAX_TIME / 1000) - m_rtStartTime;
    m_rtStamp = m_rtStartTime;

    // !!! Fix DecideBufferSize if this changes
    m_rtDelta           = 2500000;  // 1/4 second

  } // Constructor //

CSilenceStream::~CSilenceStream(void)

  { // Destructor //
    /* BUFFER POINTER */
    if (m_ppbDstBuf)
        delete [] m_ppbDstBuf;

    SaferFreeMediaType( m_mtAccept );
  } // Destructor //


STDMETHODIMP CSilenceStream::NonDelegatingQueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(IID_IDexterSequencer, riid))
      return GetInterface((IDexterSequencer *)this, ppv);
    else if (IsEqualIID(IID_ISpecifyPropertyPages, riid))
	return GetInterface((ISpecifyPropertyPages *)this, ppv);
    else if (IsEqualIID(IID_IMediaSeeking, riid))
      return GetInterface((IMediaSeeking *)this, ppv);
    else
      return CSourceStream::NonDelegatingQueryInterface(riid, ppv);

}


HRESULT CSilenceStream::GetMediaType (CMediaType *pmt)

  { // GetMediaType //

    return CopyMediaType(pmt, &m_mtAccept);

  } // GetMediaType //

HRESULT CSilenceStream::DecideAllocator (IMemInputPin *pPin, IMemAllocator **ppAlloc)

  { // DecideAllocator //

      HRESULT hr = NOERROR;

      *ppAlloc = NULL;

      ALLOCATOR_PROPERTIES prop;
      ZeroMemory(&prop, sizeof(prop));

      prop.cbAlign = 1;

      // Downstream allocation?
      hr = pPin->GetAllocator(ppAlloc);

      if (SUCCEEDED(hr))

        { // Downstream allocation

          hr = DecideBufferSize(*ppAlloc, &prop);

          if (SUCCEEDED(hr))

            { // DecideBufferSize success

              // Read-only buffers?!
              hr = pPin->NotifyAllocator(*ppAlloc, TRUE);

              if (SUCCEEDED(hr))
                return NOERROR;

            } // DecideBufferSize success

        } // Downstream allocation

      /* If the GetAllocator failed we may not have an interface */

      if (*ppAlloc)
        {
          (*ppAlloc)->Release();
          *ppAlloc = NULL;
        }

      // Output pin allocation?

      hr = InitAllocator(ppAlloc);

      if (SUCCEEDED(hr))

        { // Output pin's allocation

          // Note - the properties passed here are in the same
          // structure as above and may have been modified by
          // the previous call to DecideBufferSize

          hr = DecideBufferSize(*ppAlloc, &prop);

          if (SUCCEEDED(hr))

            { // DecideBufferSize success

              // Read-only buffers?!
              hr = pPin->NotifyAllocator(*ppAlloc, TRUE);

              if (SUCCEEDED(hr))
                return NOERROR;

            } // DecideBufferSize success

        } // Output pin's allocation

      // Release interface pointers if needed
      if (*ppAlloc)
        {
          (*ppAlloc)->Release();
          *ppAlloc = NULL;
        }

     return hr;

  } // DecideAllocator //

HRESULT CSilenceStream::DecideBufferSize (IMemAllocator *pAlloc, ALLOCATOR_PROPERTIES *pProperties)

  { // DecideBufferSize //

    ASSERT(pAlloc);
    ASSERT(pProperties);

    WAVEFORMATEX *pwf = (WAVEFORMATEX *)(m_mtAccept.pbFormat);
    ASSERT(pwf);

    CAutoLock lock(m_pFilter->pStateLock());

    // MAXBUFFERCNT read-only buffers !
    if (pProperties->cBuffers < MAXBUFFERCNT )
      pProperties->cBuffers = MAXBUFFERCNT;

    if (pProperties->cbBuffer < (int)pwf->nSamplesPerSec)
      pProperties->cbBuffer = pwf->nSamplesPerSec;

    if (pProperties->cbAlign == 0)
      pProperties->cbAlign = 1;

    ALLOCATOR_PROPERTIES Actual;

    pAlloc->SetProperties(pProperties,&Actual);

    if (Actual.cbBuffer < pProperties->cbBuffer)
      return E_FAIL;

    //because I am not insisting my own buffer, I may get more than MAXBUFFERCNT buffers.
    m_iBufferCnt =Actual.cBuffers; //how many buffer need to be set to 0

    return NOERROR;

  } // DecideBufferSize //

HRESULT CSilenceStream::FillBuffer (IMediaSample *pms)

  { // FillBuffer //

    CAutoLock foo(&m_csFilling);

    ASSERT( m_ppbDstBuf != NULL );
    ASSERT( m_iBufferCnt );


    // The base class will automatically deliver end-of-stream when
    // the FillBuffer() returns S_FALSE so exploit this point when
    // the time comes.

    if (m_rtStamp >= m_rtStartTime + m_rtDuration) {
        DbgLog((LOG_TRACE,3,TEXT("Silence: all done")));
        return S_FALSE;
    }

    if( m_bZeroBufCnt < m_iBufferCnt  )	
    {
	//
	// there is no guarantee that the buffer is initialized yet
	//

	BYTE *pData;

	//pms: output media sample pointer
	pms->GetPointer(&pData);	    //get pointer to output buffer

	int	i	= 0;
	BOOL	bInit	= FALSE;
	while ( i <  m_bZeroBufCnt )
	{
	    if( m_ppbDstBuf[ i++ ] == pData)
	    {
		bInit	= TRUE;
		break;
	    }
	}

	if( bInit   == FALSE )
	{
	    long lDataLen = pms->GetSize(); //get output buffer size
    	    ZeroMemory( pData, lDataLen );  //clear memory
	    m_ppbDstBuf[ i ]	= pData;    //save this data pointer	
	    m_bZeroBufCnt++;
	}
    }


    REFERENCE_TIME rtSampleStop = m_rtStamp+m_rtDelta;

    pms->SetTime(&m_rtStamp, &rtSampleStop);

    DbgLog((LOG_TRACE,3,TEXT("Silence: Filled buffer %d"),
					(int)(m_rtStamp / 10000)));
    m_rtStamp += m_rtDelta;

    return NOERROR;

  } // FillBuffer //

HRESULT CSilenceStream::Active (void)

  { // Active //

    m_rtStamp = m_rtStartTime;

    //how many buffer is already set to 0.
    m_bZeroBufCnt	    =0;

    // will be used to zero the Dst buffers
    delete [] m_ppbDstBuf;
    m_ppbDstBuf		= new BYTE *[ m_iBufferCnt ];   //NULL;
    if( !m_ppbDstBuf )
    {
        return E_OUTOFMEMORY;
    }

    // don't reset m_rtNewSeg!  A seek might happen while stopped!

    for (int i=0; i<m_iBufferCnt; i++)
	m_ppbDstBuf[i]=NULL;

    return CSourceStream::Active();

  } // Active //



// --- IDexterSequencer implementation ---

HRESULT CSilenceStream::get_MediaType  (AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(m_pFilter->pStateLock());

    CheckPointer(pmt,E_POINTER);

    return CopyMediaType(pmt, &m_mtAccept);
}


HRESULT CSilenceStream::put_MediaType (const AM_MEDIA_TYPE *pmt)
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pmt, E_POINTER);

    if (IsConnected())
	return VFW_E_ALREADY_CONNECTED;


    WAVEFORMATEX * pwf = (WAVEFORMATEX*) (pmt->pbFormat);

    if( (pmt->majortype != MEDIATYPE_Audio ) ||
	(pwf->wFormatTag != WAVE_FORMAT_PCM) )
	return E_FAIL;  //only accept uncompressed audio

    //accept any Samples/second
    //pwf->nSamplesPerSec;
    if( pwf->nChannels>0 )
    {	
	//at least one channel exits
        WORD wn=pwf->wBitsPerSample;
        if(wn ==16  || wn ==8  )
	{
	    SaferFreeMediaType(m_mtAccept);
	    return CopyMediaType(&m_mtAccept, pmt);
	}
    }
    return E_FAIL;

}



// !!! We only support 1 start/stop right now.  No skew!

HRESULT CSilenceStream::ClearStartStopSkew()
{
    return NOERROR;
}


HRESULT CSilenceStream::GetStartStopSkewCount(int *pCount)
{
    CheckPointer(pCount, E_POINTER);
    *pCount = 1;
    return NOERROR;
}


HRESULT CSilenceStream::GetStartStopSkew(REFERENCE_TIME *StartTime, REFERENCE_TIME *StopTime, REFERENCE_TIME *Skew, double *pdRate)
{
    CheckPointer(StartTime, E_POINTER);
    CheckPointer(StopTime, E_POINTER);
    CheckPointer(Skew, E_POINTER);
    CheckPointer(pdRate, E_POINTER);

    *StartTime = m_rtStartTime;
    *StopTime = m_rtStartTime + m_rtDuration;

    *pdRate = 1.0;

    return NOERROR;

}


HRESULT CSilenceStream::AddStartStopSkew(REFERENCE_TIME StartTime, REFERENCE_TIME StopTime, REFERENCE_TIME Skew, double dRate)
{

    if (dRate != 1.0)
	return E_INVALIDARG;

    m_rtStartTime = StartTime;
    m_rtDuration = StopTime - StartTime;

    return NOERROR;
}




// --- ISpecifyPropertyPages ---

STDMETHODIMP CSilenceStream::GetPages (CAUUID *pPages)

  { // GetPages //

    pPages->cElems = 1;
    pPages->pElems = (GUID *)CoTaskMemAlloc(sizeof(GUID));

    if (pPages->pElems == NULL)
        return E_OUTOFMEMORY;

    *(pPages->pElems) = CLSID_SilenceProp;

    return NOERROR;

  } // GetPages

// //////////////////////////////////////////////////////////////////////////////////
// /////// CFilterPropertyPage //////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////

//
// CreateInstance
//
CUnknown *CFilterPropertyPage::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)

  { // CreateInstance //

    CUnknown *punk = new CFilterPropertyPage(lpunk, phr);

    if (NULL == punk)
	    *phr = E_OUTOFMEMORY;

    return punk;

  } // CreateInstance //

CFilterPropertyPage::CFilterPropertyPage(LPUNKNOWN pUnk, HRESULT *phr) : CBasePropertyPage(NAME("Silence Generator Property Page"), pUnk, IDD_PROPPAGE, IDS_TITLE4), m_pis(NULL), m_bInitialized(FALSE)

  { // Constructor //
  } // Constructor //

void CFilterPropertyPage::SetDirty()

  { // SetDirty //

      m_bDirty = TRUE;

      if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

  } // SetDirty //

HRESULT CFilterPropertyPage::OnActivate (void)

  { // OnActivate //

    m_bInitialized = TRUE;

    return NOERROR;

  } // OnActivate //

HRESULT CFilterPropertyPage::OnDeactivate (void)

  { // OnDeactivate //

    m_bInitialized = FALSE;

    GetControlValues();

    return NOERROR;

  } // OnDeactivate //

INT_PTR CFilterPropertyPage::OnReceiveMessage (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

  { // OnReceiveMessage //

    ASSERT(m_pis != NULL);

    switch(uMsg)

      { // Switch

        case WM_COMMAND:

          if (!m_bInitialized)
            return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

          m_bDirty = TRUE;

          if (m_pPageSite)
            m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

          return TRUE;

        case WM_INITDIALOG:

          SetDlgItemInt(hwnd, IDC_RATE, m_nSamplesPerSec, FALSE);
          SetDlgItemInt(hwnd, IDC_SILENCE_NCHANNELNUM, m_nChannelNum, FALSE);
	  SetDlgItemInt(hwnd, IDC_SILENCE_NBITS, m_nBits, FALSE);
          SetDlgItemInt(hwnd, IDC_START4, (int)(m_rtStartTime / 10000), FALSE);
          SetDlgItemInt(hwnd, IDC_DUR, (int)(m_rtDuration / 10000), FALSE);

          return TRUE;

          break;

        default:
          return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
          break;

      } // Switch

  } // OnReceiveMessage //

HRESULT CFilterPropertyPage::OnConnect (IUnknown *pUnknown)

  { // OnConnect //

    pUnknown->QueryInterface(IID_IDexterSequencer, (void **)&m_pis);

    ASSERT(m_pis != NULL);


    // Defaults from filter's current values (via IDexterSequencer)
    REFERENCE_TIME rtStop, rt;
    double d;
    m_pis->GetStartStopSkew(&m_rtStartTime, &rtStop, &rt, &d);
    m_rtDuration = rtStop - m_rtStartTime;

    CMediaType mt;
    mt.AllocFormatBuffer( sizeof( WAVEFORMATEX ) );

    m_pis->get_MediaType( &mt );
    WAVEFORMATEX * pwf = (WAVEFORMATEX*) mt.Format( );

    m_nSamplesPerSec	=pwf->nSamplesPerSec;
    m_nChannelNum	=pwf->nChannels;
    m_nBits		=(int)pwf->wBitsPerSample;

    SaferFreeMediaType(mt);

    return NOERROR;

  } // OnConnect //

HRESULT CFilterPropertyPage::OnDisconnect()

  { // OnDisconnect //

    if (m_pis)

      { // Release

        m_pis->Release();
        m_pis = NULL;

      } // Release

    m_bInitialized = FALSE;

    return NOERROR;

  } // OnDisconnect //

HRESULT CFilterPropertyPage::OnApplyChanges()

  { // OnApplyChanges //

    ASSERT(m_pis != NULL);

    HRESULT hr =GetControlValues();
    if(hr!=NOERROR)
	return E_FAIL; //data is not valid

    //build new mediatype
    CMediaType mt;
    mt.AllocFormatBuffer( sizeof( WAVEFORMATEX ) );

    //old format
    hr=m_pis->get_MediaType( &mt );
    if(hr!=NOERROR)
    {
	SaferFreeMediaType(mt);
	return E_FAIL;
    }

    WAVEFORMATEX * vih	= (WAVEFORMATEX*) mt.Format( );
    vih->nSamplesPerSec = m_nSamplesPerSec;
    vih->nChannels	= (WORD)m_nChannelNum;
    vih->wBitsPerSample = (WORD)m_nBits;
    vih->nBlockAlign    = vih->wBitsPerSample * vih->nChannels / 8;
    vih->nAvgBytesPerSec= vih->nBlockAlign * vih->nSamplesPerSec;
	
    m_pis->put_MediaType( &mt );
    m_pis->AddStartStopSkew(m_rtStartTime, m_rtStartTime + m_rtDuration, 0, 1);

    SaferFreeMediaType(mt);
    return (NOERROR);

  } // OnApplyChanges //

HRESULT CFilterPropertyPage::GetControlValues (void)

  { // GetControlValues //

    // Sampling rate
    //accept any Samples/second
    m_nSamplesPerSec = GetDlgItemInt(m_Dlg, IDC_RATE, NULL, FALSE);


    int n=0;
    n= GetDlgItemInt(m_Dlg, IDC_SILENCE_NCHANNELNUM, NULL, FALSE);
    if( n>0 )
    {	
	//at least one channel exits
        m_nChannelNum =n;
        n=GetDlgItemInt(m_Dlg, IDC_SILENCE_NBITS, NULL, FALSE);
        if(n ==16 || n==8 )
	{	
	    m_nBits	  =n ;
	    m_rtStartTime = GetDlgItemInt(m_Dlg, IDC_START4, NULL, FALSE) * (LONGLONG)10000;
	    m_rtDuration = GetDlgItemInt(m_Dlg, IDC_DUR, NULL, FALSE) * (LONGLONG)10000;
	    return NOERROR;
	}
    }

    return S_FALSE;

  } // GetControlValues //




// --- IMediaSeeking methods ----------


STDMETHODIMP
CSilenceStream::GetCapabilities(DWORD * pCaps)
{
    CheckPointer(pCaps,E_POINTER);
    // we always know the current position
    *pCaps =     AM_SEEKING_CanSeekAbsolute
		   | AM_SEEKING_CanSeekForwards
		   | AM_SEEKING_CanSeekBackwards
		   | AM_SEEKING_CanGetCurrentPos
		   | AM_SEEKING_CanGetStopPos
		   | AM_SEEKING_CanGetDuration;
		   //| AM_SEEKING_CanDoSegments
		   //| AM_SEEKING_Source;
    return S_OK;
}


STDMETHODIMP
CSilenceStream::CheckCapabilities(DWORD * pCaps)
{
    CheckPointer(pCaps,E_POINTER);

    DWORD dwMask = 0;
    GetCapabilities(&dwMask);
    *pCaps &= dwMask;

    return S_OK;
}


STDMETHODIMP
CSilenceStream::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

STDMETHODIMP
CSilenceStream::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

STDMETHODIMP
CSilenceStream::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);

    if(*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return E_FAIL;
}

STDMETHODIMP
CSilenceStream::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    return S_OK;
}

STDMETHODIMP
CSilenceStream::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    if (*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return S_FALSE;
}

// The biggie!
//
STDMETHODIMP
CSilenceStream::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
    // make sure we're not filling a buffer right now
    m_csFilling.Lock();

    HRESULT hr;
    REFERENCE_TIME rtStart, rtStop;

    // we don't do segments
    if ((CurrentFlags & AM_SEEKING_Segment) ||
				(StopFlags & AM_SEEKING_Segment)) {
    	DbgLog((LOG_TRACE,1,TEXT("FRC: ERROR-Seek used EC_ENDOFSEGMENT!")));
        m_csFilling.Unlock();
	return E_INVALIDARG;
    }

    // default to current values unless this seek changes them
    GetCurrentPosition(&rtStart);
    GetStopPosition(&rtStop);

    // figure out where we're seeking to
    DWORD dwFlags = (CurrentFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	rtStart = *pCurrent;
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	hr = GetCurrentPosition(&rtStart);
	rtStart += *pCurrent;
    } else if (dwFlags) {
    	DbgLog((LOG_TRACE,1,TEXT("Switch::Invalid Current Seek flags")));
        m_csFilling.Unlock();
	return E_INVALIDARG;
    }

    dwFlags = (StopFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pStop, E_POINTER);
	rtStop = *pStop;
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pStop, E_POINTER);
	hr = GetStopPosition(&rtStop);
	rtStop += *pStop;
    } else if (dwFlags == AM_SEEKING_IncrementalPositioning) {
	CheckPointer(pStop, E_POINTER);
	hr = GetCurrentPosition(&rtStop);
	rtStop += *pStop;
    }

    // !!! silence should be made not to need an audio repackager

    // flush first, so that our thread won't be blocked delivering
    DeliverBeginFlush();

    // Unlock/Stop so that our thread can wake up and stop without hanging
    m_csFilling.Unlock();
    Stop();

    // now fix the new values
    m_rtStartTime = rtStart;
    m_rtDuration = rtStop - rtStart;

    // now finish flushing
    DeliverEndFlush();

    DeliverNewSegment(rtStart, rtStop, 1.0);
    m_rtNewSeg = rtStart;

    // now start time stamps at 0-based
    m_rtStartTime = 0;
    m_rtStamp = m_rtStartTime;

    // reset same stuff we reset when we start streaming
    m_bZeroBufCnt = 0;

    // now start the thread up again
    Pause();

    DbgLog((LOG_TRACE,3,TEXT("Completed SILENCE seek")));

    return S_OK;
}

STDMETHODIMP
CSilenceStream::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop)
{
    CheckPointer(pCurrent, E_POINTER);
    CheckPointer(pStop, E_POINTER);
    GetCurrentPosition(pCurrent);
    GetStopPosition(pStop);
    return S_OK;
}

STDMETHODIMP
CSilenceStream::GetCurrentPosition(LONGLONG *pCurrent)
{
    CheckPointer(pCurrent, E_POINTER);
    *pCurrent = m_rtStamp + m_rtNewSeg;
    return S_OK;
}

STDMETHODIMP
CSilenceStream::GetStopPosition(LONGLONG *pStop)
{
    CheckPointer(pStop, E_POINTER);
    *pStop = m_rtStartTime + m_rtDuration + m_rtNewSeg;
    return S_OK;
}

STDMETHODIMP
CSilenceStream::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
    CheckPointer(pEarliest, E_POINTER);
    CheckPointer(pLatest, E_POINTER);
    *pEarliest = 0;
    *pLatest = MAX_TIME;
    return S_OK;
}

STDMETHODIMP
CSilenceStream::GetDuration( LONGLONG *pDuration )
{
    CheckPointer(pDuration, E_POINTER);
    *pDuration = m_rtDuration;
    return S_OK;
}

STDMETHODIMP
CSilenceStream::GetRate( double *pdRate )
{
    CheckPointer(pdRate, E_POINTER);
    *pdRate = 1.0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\resize\stretch.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stretch.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// Stretch Filter Object

extern const AMOVIESETUP_FILTER sudStretchFilter;

class CStretch;
class CStretchInputPin;
class CResizePropertyPage;

class CStretch : public CTransformFilter, public ISpecifyPropertyPages,
					public IResize, public CPersistStream
{

public:

    DECLARE_IUNKNOWN;

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    HRESULT Transform(IMediaSample *pIn, IMediaSample *pOut);
    HRESULT CheckInputType(const CMediaType *mtIn);
    HRESULT CheckTransform(const CMediaType *mtIn, const CMediaType *mtOut);
    HRESULT DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);
    HRESULT BreakConnect(PIN_DIRECTION dir);
    HRESULT CheckBufferSizes(IMediaSample *pIn, IMediaSample *pOut);


    CBasePin *GetPin(int);

    // Reveal our property interface
    STDMETHODIMP NonDelegatingQueryInterface (REFIID, void **);

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages (CAUUID *);

    // IResize
    STDMETHODIMP get_Size(int *piHeight, int *piWidth, long *dwFlag);
    STDMETHODIMP get_InputSize(int *piHeight, int *piWidth);
    STDMETHODIMP put_Size(int iHeight, int iWidth, long dwFlag);
    STDMETHODIMP get_MediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP put_MediaType(const AM_MEDIA_TYPE *pmt);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

protected:

    CStretch(LPUNKNOWN punk, HRESULT *phr);
    ~CStretch();

    CCritSec m_StretchLock;             // Internal play critical section
    CMediaType m_mtIn;                  // Source filter media type
    CMediaType m_mtOut;                 // Output connection media type
    const long m_lBufferRequest;        // Number of buffers to request

    //stretch function
    void ResizeRGB(BITMAPINFOHEADER *pbiSrc,	    //Src's BitMapInFoHeader
		  const unsigned char * dibBits,    //Src bits
    		  BITMAPINFOHEADER *pbiDst,	    //Dst's BitMapInFoHeader
		  unsigned char *pFrame,    //Dst bits
		  int iNewWidth,	    //new W in pixel
		  int iNewHeight);	    //new H in pixel

    CMediaType m_mt;

    long m_dwResizeFlag;	    //crop, preserve ratio
    // Helper methods
    HRESULT InternalPartialCheckMediaTypes (const CMediaType *mt1, const CMediaType *mt2);
    void CreatePreferredMediaType (CMediaType *mt);

    friend class CResizePropertyPage;
    friend class CStretchInputPin;

};

class CResizePropertyPage : public CBasePropertyPage
{

    public:

      static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    private:

      INT_PTR OnReceiveMessage (HWND, UINT ,WPARAM ,LPARAM);

      HRESULT OnConnect (IUnknown *);
      HRESULT OnDisconnect (void);
      HRESULT OnActivate (void);
      HRESULT OnDeactivate (void);
      HRESULT OnApplyChanges (void);

      void SetDirty (void);

      CResizePropertyPage (LPUNKNOWN, HRESULT *);

      void GetControlValues (void);

      BOOL m_bInitialized;

      IResize *m_pirs;

      // Temporary holding until OK/Apply
      int m_ResizedHeight;
      int m_ResizedWidth;
      long m_dwResizeFlag;


};

class CStretchInputPin : public CTransformInputPin
{
    public:

        CStretchInputPin(
            TCHAR              * pObjectName,
            CStretch	       * pFilter,
            HRESULT            * phr,
            LPCWSTR              pPinName);

        ~CStretchInputPin();

	// speed up intelligent connect INFINITELY by providing a type here!
	HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    private:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\render\rendeng.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: rendeng.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

/*

 Notes Section

 CACHEING

 The RE that is being used for smart compression cannot use the cache, since
 the caching code needs to know about FRC's and the like. It ALSO uses
 dynamic sources, always, for simplicity.
 
 m_bSmartCompressed === IsCompressed. They are one and the same flag

CONNECTING VIDEO PART overall skeleton
--------------------------------------
Get Video Source Count
Create the video Big Switch
Get the Timeline Group
Get the group compression info
Get the group's dynamicness info
Get track count
make a new grid
Get switch information, program it
calculate the number of switch input/output pins
set up the switch
set up the black layers
for each layer
    skip muted layers
    get embedded depth
    for each source
        skip muted source
        get source info
        ignore sources out of render range
        set up skew structure
        find the right switch input pin with the skew structure on it
        if used in SR & is dynamic source, find recompressability
        tell grid about source
        either connect source now or flag it as dynamic for layer
        if source has effects
            create dxt wrapper
            hook it up to the graph
            for each effect
                get effect info
                if !compressed, Q the parameter data with the DXT wrap
                tell grid about effect
            loop
        end if
        free up source reuse struct
    loop
    if track has effects
        create dxt wrapper
        hook it up to the graph
        for each effect
            get effect info
            if !compressed, Q the paramter data with the DXT wrap
            tell grid about effect
        loop
    end if
    if track has transitions
        if !compressed
            create DXT
            add DXT to graph
        end if
        add DXT to graph
        for each transition
            skip muted transitions
            get transition info
            if !compressed, Q the parameter data with the DXT
            tell the grid about trans
        loop
    end if
loop
prune the grid
if compressed, remove everything but sources
for each switch input pin
    if compressed
        if row is blank, ignore it
        if black row, ignore it
        find out how many ranges row has
        create skew array
        for each range in row, set switch's x-y
        merge skews
    else
        for each range in row, set switch's x-y
    end if
    set up black sources
loop

*/
//############################################################################

#include <streams.h>
#include "stdafx.h"
#include "grid.h"
#include "deadpool.h"
#include "..\errlog\cerrlog.h"
#include "..\util\filfuncs.h"
#include "..\util\conv.cxx"
#include "..\util\dexmisc.h"
#include "IRendEng.h"
#include "dexhelp.h"
#include <initguid.h>

const int RENDER_TRACE_LEVEL = 2;
const long THE_OUTPUT_PIN = -1;
const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;
const WCHAR * gwszSpecialCompSwitchName = L"DEXCOMPSWITCH";
const int HACKY_PADDING = 10000000;
const BOOL SHARE_SOURCES = TRUE;

typedef struct {
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtStop;
    REFERENCE_TIME rtMediaStop;
} MINI_SKEW;

#include <strsafe.h>

//############################################################################
// 
//############################################################################

void ValidateTimes( 
                   REFERENCE_TIME & TLStart,
                   REFERENCE_TIME & TLStop,
                   REFERENCE_TIME & MStart,
                   REFERENCE_TIME & MStop,
                   double FPS,
                   REFERENCE_TIME ProjectLength )
{
    bool ExactlyOne = ( ( MStop - MStart ) == ( TLStop - TLStart ) );

    // calculate the slope first so we can remember the rate
    // the user wanted to play
    //
    ASSERT( TLStop != TLStart );
    double slope = double(MStop-MStart)/double(TLStop-TLStart);

    // round the timeline times to the nearest frames. This means we'll
    // have to fix up the media times to have the EXACT SAME original rate
    //
    TLStart = Frame2Time( Time2Frame( TLStart, FPS ), FPS );
    TLStop  = Frame2Time( Time2Frame( TLStop,  FPS ), FPS );

    // make sure the timeline start and stop times are within bounds
    //
    if( TLStart < 0 )
    {
        MStart -= (REFERENCE_TIME)(TLStart * slope);
        TLStart = 0;
    }
    if( TLStop > ProjectLength )
    {
        TLStop = ProjectLength;
    }

    REFERENCE_TIME FixedMediaLen;    // len of fixed up media times
    if( ExactlyOne )
    {
        FixedMediaLen = TLStop - TLStart;
    }
    else
    {
        FixedMediaLen = REFERENCE_TIME( slope * ( TLStop - TLStart ) );
    }

    // We have to be careful when growing the media times to be in the right
    // ratio to the timeline times, because we don't want to make the start
    // get < 0, or the stop be > the movie length (which we don't know).
    // So we'll grow by moving the start back, until it hits 0, in which case
    // we'll grow the stop too, but hopefully this cannot cause a problem
    // because we're fudging by at most one output frame length, so the
    // switch should get all the frames it needs.

    if( FixedMediaLen > MStop - MStart ) // new len is longer! oh oh!
    {
        // we adjust just the start time, since we can
        //
        if( MStop >= FixedMediaLen )
        {
            MStart = MStop - FixedMediaLen;
        }
        else // start time would have gone < 0, adjust both ends
        {
            MStart = 0;
            MStop = FixedMediaLen;
        }
    }
    else // new len is shorter or same. Shrink the end down slightly
    {
        MStop = MStart + FixedMediaLen;
    }
}

CRenderEngine::CRenderEngine( )
: m_pGraph( NULL )
, m_nGroupsAdded( 0 )
, m_rtRenderStart( -1 )
, m_rtRenderStop( -1 )
, m_hBrokenCode( 0 )
, m_nDynaFlags( CONNECTF_DYNAMIC_SOURCES )
, m_nLastGroupCount( 0 )
, m_bSmartCompress( FALSE )
, m_bUsedInSmartRecompression( FALSE )
, m_punkSite( NULL )
, m_nMedLocFlags( 0 )
, m_pDeadCache( 0 )
{
    for( int i = 0 ; i < MAX_SWITCHERS ; i++ )
    {
        m_pSwitcherArray[i] = NULL;
    }
    
    m_MedLocFilterString[0] = 0;
    m_MedLocFilterString[1] = 0;
}

HRESULT CRenderEngine::FinalConstruct()
{
    m_pDeadCache = new CDeadGraph;
    // need to dekey this guy too
    if( m_pDeadCache )
    {
        CComPtr< IGraphBuilder > pGraph;
        m_pDeadCache->GetGraph( &pGraph );
        if( pGraph )
        {
            CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( pGraph );
            if( pOWS )
            {
                pOWS->SetSite( (IServiceProvider *) this );
            }
        }
    }
    return m_pDeadCache ? S_OK : E_OUTOFMEMORY;
}

//############################################################################
// 
//############################################################################

CRenderEngine::~CRenderEngine( )
{
    // disconnect EVERYTHING
    //
    _ScrapIt( FALSE );
    
    delete m_pDeadCache;
}

//############################################################################
// Remove everything from the graph, every last thing.
//############################################################################

HRESULT CRenderEngine::ScrapIt( )
{
    CAutoLock Lock( &m_CritSec );
    return _ScrapIt( TRUE );
}

HRESULT CRenderEngine::_ScrapIt( BOOL bWipeGraph ) // internal method
{
    if( bWipeGraph )
    {
        // stopping the graph below won't necessarily keep the graph stopped if
        // a video window is around to ask for a repaint.  make sure we won't
        // start up again, or we'll assert and hang tearing the graph down
        //HideVideoWindows( m_pGraph);

        // stop it first
        //
        if( m_pGraph )
        {
            CComQIPtr< IMediaControl, &IID_IMediaControl > pControl( m_pGraph );
            pControl->Stop( );
        }
        
        // remove everything from the graph
        //
        WipeOutGraph( m_pGraph );
    }
    
    // release all our switcher array pins
    //
    for( int i = 0 ; i < MAX_SWITCHERS ; i++ )
    {
        if( m_pSwitcherArray[i] )
        {
            m_pSwitcherArray[i]->Release( );
            m_pSwitcherArray[i] = 0;
        }
    }
    m_nGroupsAdded = 0;
    m_nLastGroupCount = 0;
    if(m_pDeadCache) {
        m_pDeadCache->Clear( );
    }
    
    // clear the broken code since we're torn down everything
    //
    m_hBrokenCode = 0;
    
    return NOERROR;
}

//############################################################################
// gets the maker of this render engine
//############################################################################

STDMETHODIMP CRenderEngine::GetVendorString( BSTR * pVendorID )
{
    CheckPointer( pVendorID, E_POINTER );
    *pVendorID = SysAllocString( L"Microsoft Corporation" ); // safe
    HRESULT hr = *pVendorID ? NOERROR : E_OUTOFMEMORY;
    return hr;
}

//############################################################################
// disconnect two pins from anything
//############################################################################

HRESULT CRenderEngine::_Disconnect( IPin * pPin1, IPin * pPin2 )
{
    HRESULT hr = 0;
    
    if( pPin1 )
    {
        hr = pPin1->Disconnect( );
        ASSERT( !FAILED( hr ) );
    }
    if( pPin2 )
    {
        hr = pPin2->Disconnect( );
        ASSERT( !FAILED( hr ) );
    }
    return NOERROR;
}

//############################################################################
// add a filter into the graph. Defer to the cache manager for how to do this.
//############################################################################

HRESULT CRenderEngine::_AddFilter( IBaseFilter * pFilter, LPCWSTR pName, long ID )
{
    HRESULT hr = 0;

    // if filter is already in the graph, don't do a thing. This REALLY HAPPENS,
    // taking it out of the cache automatically adds it to our graph
    //
    FILTER_INFO fi;
    hr = pFilter->QueryFilterInfo( &fi );
    if( FAILED( hr ) )
    {
        return hr;
    }
    if( fi.pGraph ) fi.pGraph->Release( );
    if( fi.pGraph == m_pGraph )
    {
        return NOERROR;
    }

    WCHAR FilterName[MAX_FILTER_NAME];
    if( wcscmp( pName, gwszSpecialCompSwitchName ) == 0 ) // safe, gwsz is bounded
    {
        StringCchCopy( FilterName, MAX_FILTER_NAME, gwszSpecialCompSwitchName ); // safe, bounded
    }
    else
    {
        GetFilterName( ID, (WCHAR*) pName, FilterName, MAX_FILTER_NAME );
    }

    hr = m_pGraph->AddFilter( pFilter, FilterName );
    ASSERT( SUCCEEDED(hr) );

    return hr;
}

//############################################################################
// 
//############################################################################

HRESULT CRenderEngine::_RemoveFilter( IBaseFilter * pFilter )
{
    HRESULT hr = 0;

    hr = m_pGraph->RemoveFilter( pFilter );
    return hr;
}

//############################################################################
// connect up two pins with respecive ID's.
//############################################################################

HRESULT CRenderEngine::_Connect( IPin * pPin1, IPin * pPin2 )
{
    DbgTimer t( "(rendeng) _Connect" );
    
    return m_pGraph->Connect( pPin1, pPin2 );
}

//############################################################################
// ask the render engine which timeline it's using
//############################################################################

STDMETHODIMP CRenderEngine::GetTimelineObject( IAMTimeline ** ppTimeline )
{
    CAutoLock Lock( &m_CritSec );
    
    // they should pass in a valid one
    //
    CheckPointer( ppTimeline, E_POINTER );
    
    *ppTimeline = m_pTimeline;
    if( *ppTimeline )
    {
        (*ppTimeline)->AddRef( );
    }
    
    return NOERROR;
}

//############################################################################
// tell the render engine what timeline we're going to be working with.
// This function also copies over any error log the timeline is using.
//############################################################################

STDMETHODIMP CRenderEngine::SetTimelineObject( IAMTimeline * pTimeline )
{
    CAutoLock Lock( &m_CritSec );
    
    // they should pass in a valid one
    //
    CheckPointer( pTimeline, E_POINTER );
    
    // if they already match, then the user's probably just being silly
    //
    if( pTimeline == m_pTimeline )
    {
        return NOERROR;
    }
    
    // if we already have a timeline, then forget about it and set the new one.
    //
    if( m_pTimeline )
    {
        ScrapIt( );
        m_pTimeline.Release( );
        m_pGraph.Release( );
    }
    
    m_pTimeline = pTimeline;
    
    m_pErrorLog.Release( );
    
    // grab the timeline's error log
    //
    CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pTimelineLog( pTimeline );
    if( pTimelineLog )
    {
        pTimelineLog->get_ErrorLog( &m_pErrorLog );
    }
    
    return NOERROR;
}

//############################################################################
// get the graph we're working with
//############################################################################

STDMETHODIMP CRenderEngine::GetFilterGraph( IGraphBuilder ** ppFG )
{
    CAutoLock Lock( &m_CritSec );
    
    CheckPointer( ppFG, E_POINTER );
    
    *ppFG = m_pGraph;
    if( m_pGraph )
    {
        (*ppFG)->AddRef( );
    }
    
    return NOERROR;
}

//############################################################################
// (pre)set the graph the render engine will use.
//############################################################################

STDMETHODIMP CRenderEngine::SetFilterGraph( IGraphBuilder * pFG )
{
    CAutoLock Lock( &m_CritSec );
    
    // no setting the graph after we already created one.
    //
    if( m_pGraph )
    {
        return E_INVALIDARG;
    }
    
    m_pGraph = pFG;
    
    return NOERROR;
}

//############################################################################
// set the callback that we want to use for connecting up sources.
//############################################################################

STDMETHODIMP CRenderEngine::SetSourceConnectCallback( IGrfCache * pCallback )
{
    CAutoLock Lock( &m_CritSec );
    
    m_pSourceConnectCB = pCallback;
    return NOERROR;
}

//############################################################################
// find the output pin for a group, each group has one and only one.
//############################################################################

STDMETHODIMP CRenderEngine::GetGroupOutputPin( long Group, IPin ** ppRenderPin )
{
    CAutoLock Lock( &m_CritSec );
    
    // if it's broken, don't do anything.
    //
    if( m_hBrokenCode )
    {
        return E_RENDER_ENGINE_IS_BROKEN;
    }
    
    CheckPointer( ppRenderPin, E_POINTER );
    
    *ppRenderPin = NULL;
    
    // don't let the group number be out of bounds
    //
    if( Group < 0 || Group >= MAX_SWITCHERS )
    {
        return E_INVALIDARG;
    }
    
    // error if we don't have a graph
    //
    if( !m_pGraph )
    {
        return E_INVALIDARG;
    }
    
    // this switcher might not exist for this group,
    // if it was skipped
    //
    if( !m_pSwitcherArray[Group] )
    {
        return S_FALSE;
    }
    
    // this should always work
    //
    CComQIPtr< IBaseFilter, &IID_IBaseFilter > pSwitcherBase( m_pSwitcherArray[Group] );
    
    m_pSwitcherArray[Group]->GetOutputPin( 0, ppRenderPin );
    ASSERT( *ppRenderPin );
    
    return NOERROR;
}

//############################################################################
// hook up the switchers and then render the output pins in one fell swoop
//############################################################################

HRESULT CRenderEngine::ConnectFrontEnd( )
{
    CAutoLock Lock( &m_CritSec );
    
    // if it's broken, don't do anything.
    //
    if( m_hBrokenCode )
    {
        return E_RENDER_ENGINE_IS_BROKEN;
    }

    DbgLog((LOG_TRACE,1,TEXT("RENDENG::ConnectFrontEnd" )));

    // init memory used to source/parser sharing
    m_cshare = 0; // init using same source for both A&V
    m_cshareMax = 25;
    m_share = (ShareAV *)CoTaskMemAlloc(m_cshareMax * sizeof(ShareAV));
    if (m_share == NULL)
	return E_OUTOFMEMORY;

    // init memory used to keep track of unused dangly bits from source sharing
    m_cdangly = 0;
    m_cdanglyMax = 25;
    m_pdangly = (IBaseFilter **)CoTaskMemAlloc(m_cdanglyMax * sizeof(IBaseFilter *));
    if (m_pdangly == NULL) {
	CoTaskMemFree(m_share);
	return E_OUTOFMEMORY;
    }

    // stopping the graph below won't necessarily keep the graph stopped if
    // a video window is around to ask for a repaint.  make sure we won't start
    // up again, or we'll assert and hang tearing the graph down
    //HideVideoWindows( m_pGraph);
    // !!! UH OH!

    // right now, reconnecting up the graph won't work unless we're stopped
    //
    if( m_pGraph )
    {
        CComQIPtr< IMediaControl, &IID_IMediaControl > pControl( m_pGraph );
        pControl->Stop( );
    }

    HRESULT hrRet = _HookupSwitchers( );
    _CheckErrorCode( hrRet );

    // free the shared memory
    if (m_share)        // re-alloc fail could make this NULL
        CoTaskMemFree(m_share);

    // kill all the leftover dangly bits
    for (int z=0; z < m_cdangly; z++) {
	if (m_pdangly[z]) {
	    IPin *pIn = GetInPin(m_pdangly[z], 0);
	    ASSERT(pIn);
	    IPin *pOut = NULL;
	    pIn->ConnectedTo(&pOut);
	    ASSERT(pOut);
	    pIn->Disconnect();
	    pOut->Disconnect();
	    RemoveDownstreamFromFilter(m_pdangly[z]);
	}
    }
    if (m_pdangly)      // re-alloc fail could make this NULL
        CoTaskMemFree(m_pdangly);

    return hrRet;
}

//############################################################################
//
//############################################################################

#define TESTROWS 500

HRESULT CRenderEngine::_HookupSwitchers( )
{
    HRESULT hr = 0;

    // if our timeline hasn't been set, we've got an error
    //
    if( !m_pTimeline )
    {
        return E_INVALIDARG;
    }
    
    // if we don't already have a graph, create one now
    //
    if( !m_pGraph )
    {
        hr = _CreateObject(
            CLSID_FilterGraph,
            IID_IFilterGraph,
            (void**) &m_pGraph );
        
        if( FAILED( hr ) )
        {
            return hr;
        }
        
        // give the graph a pointer back to us
        // !!! only if( m_punkSite ) ?
        {
            CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( m_pGraph );
            
            pOWS->SetSite( (IServiceProvider *) this );
        }
    }

#ifdef DEBUG
    CComQIPtr< IGraphConfig, &IID_IGraphConfig > pConfig( m_pGraph );
    if( !pConfig )
    {
        DbgLog((LOG_ERROR,1, TEXT( "RENDENG::******** Old version of Quartz.dll detected." )));
        static bool warned = false;
        if( !warned )
        {
            warned = true;
            MessageBox( NULL, TEXT("You have an old version of Quartz installed. This version of Dexter won't work with it."),
                TEXT("Whoops!"), MB_OK | MB_TASKMODAL );
            return DEX_IDS_INSTALL_PROBLEM;
        }
    }
#endif
    
    // we've always assumed that the user has wiped out the graph
    // when they call ConnectFrontEnd, which calls us. Make sure this
    // is so from now on. 
    
    // ask the timeline how many groups it has
    //
    long GroupCount = 0;
    hr = m_pTimeline->GetGroupCount( &GroupCount );
    if( FAILED( hr ) )
    {
        return hr;
    }
    if( GroupCount < 0 )
    {
        return E_INVALIDARG;
    }

    bool BlowCache = false;

    // look at the list of groups and see if we need to blow our cache
    //
    if( GroupCount != m_nLastGroupCount )
    {
        BlowCache = true;
    }
    else
    {
        // okay, the group count matches, so look at the group
        // id's and see if they're the same
        //
        for( int g = 0 ; g < GroupCount ; g++ )
        {
            CComPtr< IAMTimelineObj > pGroupObj;
            hr = m_pTimeline->GetGroup( &pGroupObj, g );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                return _GenerateError( 2, DEX_IDS_TIMELINE_PARSE, hr );
            }
            long NewSwitchID = 0;
            pGroupObj->GetGenID( &NewSwitchID );

            // if we no longer have a switch, we blow the cache
            //
            if( !m_pSwitcherArray[g] )
            {
                BlowCache = true;
                break;
            }

            // get the switch filter and ask for it's ID
            //
            CComQIPtr< IBaseFilter, &IID_IBaseFilter > pSwitch( m_pSwitcherArray[g] );
            
            long OldSwitchID = GetFilterGenID( pSwitch );

            if( OldSwitchID != NewSwitchID )
            {
                BlowCache = true;
                break;
            }
        }

    }
    if( BlowCache )
    {
        _ClearCache( );
    }

    if( !m_bSmartCompress )
    {
        if( !BlowCache )
        {
            // if we're not the compressed RE, whether in recompression mode or not,
            // attempt to use the cache
            //
            _LoadCache( ); // if BlowCache, then this is a NO-OP

        }

        // remove everything from the graph
        //
        WipeOutGraph( m_pGraph );
    }
    
    // release all our switcher array pins before we go a' settin' them
    //
    //
    for( int i = 0 ; i < MAX_SWITCHERS ; i++ )
    {
        if( m_pSwitcherArray[i] )
        {
            m_pSwitcherArray[i]->Release( );
            m_pSwitcherArray[i] = 0;
        }
    }
    m_nGroupsAdded = 0;
    
    // clear the broken code since we're torn down everything
    //
    m_hBrokenCode = 0;
    
    // for each group we've got, parse it and connect up the necessary filters.
    //
    for( int CurrentGroup = 0 ; CurrentGroup < GroupCount ; CurrentGroup++ )
    {
        DbgTimer t( "(rendeng) Time to connect up group" );

        CComPtr< IAMTimelineObj > pGroupObj;
        hr = m_pTimeline->GetGroup( &pGroupObj, CurrentGroup );
        if( FAILED( hr ) )
        {
            return hr;
        }
        CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( pGroupObj );
        
        // ask the group if it's compressed. If we're in compressed mode
        // and the group isn't, don't process it. 
        //
        BOOL Compressed = FALSE;
        pGroup->IsSmartRecompressFormatSet( &Compressed );
        if( m_bSmartCompress && !Compressed )
        {
            continue;
        }
        
        AM_MEDIA_TYPE MediaType;
        hr = pGroup->GetMediaType( &MediaType );
        if( FAILED( hr ) )
        {
            return hr;
        }
        
        if( MediaType.pbFormat == NULL )
        {
#if DEBUG
            MessageBox( NULL, TEXT("REND--Need to set the format of the media type in the timeline group"), TEXT("REND--error"), MB_TASKMODAL | MB_OK );
#endif
            return VFW_E_INVALIDMEDIATYPE;
        }
        
        if( MediaType.majortype == MEDIATYPE_Video )
        {
            hr = _AddVideoGroupFromTimeline( CurrentGroup, &MediaType );
        }
        else if( MediaType.majortype == MEDIATYPE_Audio )
        {
            hr = _AddAudioGroupFromTimeline( CurrentGroup, &MediaType );
        }
        else
        {
	    ASSERT(FALSE);
            //hr = _AddRandomGroupFromTimeline( CurrentGroup, &MediaType );
        }
        SaferFreeMediaType( MediaType );
        
        if( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    m_nLastGroupCount = m_nGroupsAdded;
    
    // we can clear the cache no matter who we are, it won't do anything
    // the second time we call it
    //
    _ClearCache( );

    if( BlowCache )
    {
        return S_WARN_OUTPUTRESET;
    }
    
    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CRenderEngine::_AddVideoGroupFromTimeline( long WhichGroup, AM_MEDIA_TYPE * pGroupMediaType )

{
    HRESULT hr = 0;
    
    // we've already checked for m_pTimeline being valid
    
    long Dummy = 0;
    long VideoSourceCount = 0;
    m_pTimeline->GetCountOfType( WhichGroup, &VideoSourceCount, &Dummy, TIMELINE_MAJOR_TYPE_SOURCE );
    
    // somebody said that if we have a group with no video sources in it, but the group
    // exists, then the blank group should just produce "blankness", or black
    
    if( VideoSourceCount < 1 )
    {
        //        return NOERROR;
    }

    // get group first, so we can get group ID and cache the switch
    //
    CComPtr< IAMTimelineObj > pGroupObj;
    hr = m_pTimeline->GetGroup( &pGroupObj, WhichGroup );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        return _GenerateError( 2, DEX_IDS_TIMELINE_PARSE, hr );
    }
    long SwitchID = 0;
    pGroupObj->GetGenID( &SwitchID );
    
    // check to see if graph already holds our Compressed Video Switcher. If we find one,
    // use it. If it's not in the cache, we might not find it.
    //
    m_pSwitcherArray[WhichGroup] = NULL;

    if( m_bSmartCompress )
    {
        CComPtr< IBaseFilter > pFoundFilter;
        m_pGraph->FindFilterByName( gwszSpecialCompSwitchName, &pFoundFilter );

        if( pFoundFilter )
        {
            pFoundFilter->QueryInterface( IID_IBigSwitcher, (void**) &m_pSwitcherArray[WhichGroup] );
        }
    }

    if( !m_pSwitcherArray[WhichGroup] )
    {
        // create a switch for each group we add.
        //
        hr = _CreateObject(
            CLSID_BigSwitch,
            IID_IBigSwitcher,
            (void**) &m_pSwitcherArray[WhichGroup],
            SwitchID );
    }
    
    if( FAILED( hr ) )
    {
        return _GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
    }
    
    m_pSwitcherArray[WhichGroup]->Reset( );
    // the switch may need to know what group it is
    m_pSwitcherArray[WhichGroup]->SetGroupNumber( WhichGroup );

    CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pGroupComp( pGroupObj );
    if( !pGroupComp )
    {
        hr = E_NOINTERFACE;
        return _GenerateError( 2, DEX_IDS_TIMELINE_PARSE, hr );
    }
    CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( pGroupObj );
    if( !pGroup )
    {
        hr = E_NOINTERFACE;
        return _GenerateError( 2, DEX_IDS_TIMELINE_PARSE, hr );
    }
    
    // find out if this group expects us to recompress
    //
    CMediaType CompressedGroupType;
    SCompFmt0 * pFormat = NULL;
    pGroup->GetSmartRecompressFormat( (long**) &pFormat );
    if( pFormat )
    {
        CompressedGroupType = pFormat->MediaType;
    }
    
    BOOL IsCompressed = FALSE;
    // how can we delete pFormat cleanly?
    
    // By now we know that if we're in a Smart Rec group, we are the
    // compressed switch
    //
    if( m_bSmartCompress )
    {
        if( !pFormat )
        {
            return E_UNEXPECTED;
        }
        
        IsCompressed = TRUE;
        pGroupMediaType = &CompressedGroupType;
        m_pSwitcherArray[WhichGroup]->SetCompressed( );
    }
    
    if (pFormat) SaferFreeMediaType( pFormat->MediaType );
    if (pFormat) delete pFormat;
    
    // ask the group if somebody has changed the smart compress format.
    // if they have, then we should re-tell the sources if they're compatible
    // or at least clear the flags
    
    BOOL ResetCompatibleFlags = FALSE;
    pGroup->IsRecompressFormatDirty( &ResetCompatibleFlags );
    pGroup->ClearRecompressFormatDirty( );
    
    // If in compressed mode, put switch in dynamic mode
    // !!! Smart recompression MUST USE DYNAMIC SOURCES or things
    // will break trying to re-use a source that might not exist
    // (the first instance may not have been a match with the
    // smart recompression format if there was a rate change)
    // If using smart recompression, the UNcompressed switch must NOT be
    // dynamic (so we can look at the sources as we load them to see if they're
    // compatible - we won't load them if we're dynamic)
    long DynaFlags = m_nDynaFlags;
    if( IsCompressed )
    {
        DynaFlags |= CONNECTF_DYNAMIC_SOURCES;
    } else if (m_bUsedInSmartRecompression) {
        DynaFlags &= ~CONNECTF_DYNAMIC_SOURCES;
    }
    
    // tell the switch if we're doing dynamic reconnections or not
    hr = m_pSwitcherArray[WhichGroup]->SetDynamicReconnectLevel(DynaFlags);
    ASSERT(SUCCEEDED(hr));
    
    // tell the switch about our error log
    //
    CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pSwitchLog( m_pSwitcherArray[WhichGroup] );
    if( pSwitchLog )
    {
        pSwitchLog->put_ErrorLog( m_pErrorLog );
    }
    
    // are we allowed to have transitions on the timeline right now?
    //
    BOOL EnableTransitions = FALSE;
    BOOL EnableFx = FALSE;
    m_pTimeline->EffectsEnabled( &EnableFx );
    m_pTimeline->TransitionsEnabled( &EnableTransitions );
    
    // ask timeline how many actual tracks it has
    //
    long VideoTrackCount = 0;
    long VideoLayers = 0;
    m_pTimeline->GetCountOfType( WhichGroup, &VideoTrackCount, &VideoLayers, TIMELINE_MAJOR_TYPE_TRACK );
        
    CTimingGrid VidGrid;
    
    // ask for this group's frate rate, so we can tell the switch about it
    //
    double GroupFPS = DEFAULT_FPS;
    pGroup->GetOutputFPS(&GroupFPS);
    if( GroupFPS <= 0.0 )
    {
        GroupFPS = DEFAULT_FPS;
    }
    
    // ask it if it's in preview mode, so we can tell the switch about it
    //
    BOOL fPreview = FALSE;
    hr = pGroup->GetPreviewMode(&fPreview);
    
    // no previewing mode when smart recompressing
    if( IsCompressed )
    {
        fPreview = FALSE;
    }
    
    // ask how much buffering this group wants
    //
    int nOutputBuffering;
    hr = pGroup->GetOutputBuffering(&nOutputBuffering);
    ASSERT(SUCCEEDED(hr));
    
    WCHAR GroupName[256];
    BSTR bstrGroupName;
    hr = pGroup->GetGroupName( &bstrGroupName );
    if( FAILED( hr ) )
    {
        return E_OUTOFMEMORY;
    }
    hr = StringCchCopy( GroupName, 256, bstrGroupName );
    if( FAILED( hr ) )
    {
        return hr;
    }
    SysFreeString( bstrGroupName );
    
    // for compressed version, add a C
    if( IsCompressed )
    {
        StringCchCopy( GroupName, 256, gwszSpecialCompSwitchName );
        SwitchID = 0;
    }
    
    // add the switch to the graph
    //
    IBigSwitcher *&_pVidSwitcherBase = m_pSwitcherArray[WhichGroup];
    CComQIPtr< IBaseFilter, &IID_IBaseFilter > pVidSwitcherBase( _pVidSwitcherBase );
    hr = _AddFilter( pVidSwitcherBase, GroupName, SwitchID );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
    }

    // find out if the switch output pin is connected. If it is,
    // disconnect it, but remember what it was connected to so we can
    // connect it up later. We can't leave it connected and try to 
    // connect input pins.
    // Cannot leave output connected because Switch's SetMediaType will bomb
    // if any input or output is connected.
    //
    CComPtr< IPin > pSwitchRenderPin;
    _pVidSwitcherBase->GetOutputPin( 0, &pSwitchRenderPin );
    if( pSwitchRenderPin )
    {
        pSwitchRenderPin->ConnectedTo( &m_pSwitchOuttie[WhichGroup] );
        if( m_pSwitchOuttie[WhichGroup] )
        {
            m_pSwitchOuttie[WhichGroup]->Disconnect( );
            pSwitchRenderPin->Disconnect( );
        }
    }

    long vidoutpins = VideoSourceCount;    // fx on clips
    vidoutpins += 2 * VideoLayers;    // trans on track, comp & group
    vidoutpins += VideoLayers;     // fx on track, comp & group
    vidoutpins += 1;               // rendering pin
    
    long vidinpins = VideoSourceCount;    // clip fx outputs
    vidinpins += VideoLayers;    // track, comp & group fx outputs
    vidinpins += VideoLayers;    // track, comp & group trans outputs
    vidinpins += VideoSourceCount;    // the actual sources
    vidinpins += VideoLayers;    // a black source for each layer
    if (vidinpins == 0) vidinpins = 1; // don't error out
    
    long vidswitcheroutpin = 0;
    long vidswitcherinpin = 0;
    long gridinpin = 0;
    vidswitcheroutpin++;
    
    hr = m_pSwitcherArray[WhichGroup]->SetInputDepth( vidinpins );
    if( FAILED( hr ) )
    {
        return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
    }
    hr = m_pSwitcherArray[WhichGroup]->SetOutputDepth( vidoutpins );
    if( FAILED( hr ) )
    {
        return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
    }
    
    // set the media type it accepts
    //
    hr = m_pSwitcherArray[WhichGroup]->SetMediaType( pGroupMediaType );
    if( FAILED( hr ) )
    {
        VARIANT var;
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = WhichGroup;
        return _GenerateError( 2, DEX_IDS_BAD_MEDIATYPE, hr, &var );
    }
    
    // set the frame rate
    //
    hr = m_pSwitcherArray[WhichGroup]->SetFrameRate( GroupFPS );
    ASSERT(SUCCEEDED(hr));
    
    // set preview mode
    //
    hr = m_pSwitcherArray[WhichGroup]->SetPreviewMode( fPreview );
    ASSERT(SUCCEEDED(hr));
    
    CComQIPtr< IAMOutputBuffering, &IID_IAMOutputBuffering > pBuffer ( 
        m_pSwitcherArray[WhichGroup] );
    hr = pBuffer->SetOutputBuffering( nOutputBuffering );
    ASSERT(SUCCEEDED(hr));
    if( FAILED( hr ) )
    {
        return hr;
    }
    
    // set the duration
    //
    REFERENCE_TIME TotalDuration = 0;
    m_pTimeline->GetDuration( &TotalDuration );
    if( m_rtRenderStart != -1 )
    {
        if( TotalDuration > ( m_rtRenderStop - m_rtRenderStart ) )
        {
            TotalDuration = m_rtRenderStop - m_rtRenderStart;
        }
    }
    pGroupObj->FixTimes( NULL, &TotalDuration );

    if (TotalDuration == 0)
        return S_FALSE; // don't abort, other groups might still work

    hr = m_pSwitcherArray[WhichGroup]->SetProjectLength( TotalDuration );
    ASSERT(SUCCEEDED(hr));
    
    bool worked = VidGrid.SetNumberOfRows( vidinpins + 1 );
    if( !worked )
    {
        hr = E_OUTOFMEMORY;
        return _GenerateError( 2, DEX_IDS_GRID_ERROR, hr );
    }
    
    // there is a virtual black track per layer that comes first... everything
    // transparent on the real tracks makes you see this black track.  Each
    // track or composite might have a transition from black to the content of
    // its track, so we may need a black source for each of them.
    
    // We don't of course know yet if we need the black source, so we won't
    // put it in the graph yet. But we'll add a whole lot of black to the grid,
    // to pretend like it's there.
    
    // this operation is inexpensive, go ahead and do it for compressed version
    // as well
    VidGrid.SetBlankLevel( VideoLayers, TotalDuration );
    for (int xx=0; xx<VideoLayers; xx++) 
    {
        // tell the grid about it
        //
        VidGrid.WorkWithNewRow( vidswitcherinpin, gridinpin, 0, 0 );
        vidswitcherinpin++;
        gridinpin++;
        
    } // for all video layers
    
    // we are going to be clever, and if the same source is used
    // more than once in a project, we'll use the same source filter
    // instead of opening the source several times.
	
    // for each source in the project, we'll fill in this structure, which
    // contains everything necessary to determine if it's really exactly the
    // same, plus an array of all the times it's used in other places, so we
    // can re-use it only if none of the times it is used overlap (we can't
    // very well have one source filter giving 2 spots in the same movie at
    // the same time, can we?)

    typedef struct {
	long ID;
   	BSTR bstrName;
   	GUID guid;
	int  nStretchMode;
   	double dfps;
   	long nStreamNum;
	int nPin;
	int cTimes;	// how big the following array is
        int cTimesMax;	// how much space is allocated
        MINI_SKEW * pMiniSkew;
        double dTimelineRate;
    } DEX_REUSE;

    // make a place to hold an array of names and guids (of the sources
    // in this project) and which pin they are on
    long cListMax = 20, cList = 0;
    DEX_REUSE *pREUSE = (DEX_REUSE *)QzTaskMemAlloc(cListMax *
						sizeof(DEX_REUSE));
    if (pREUSE == NULL) {
        return _GenerateError( 1, DEX_IDS_GRAPH_ERROR, E_OUTOFMEMORY);
    }

    // which physical track are we on in our enumeration? (0-based) not counting
    // comps and the group
    int WhichTrack = -1;

    long LastEmbedDepth = 0;
    long LastUsedNewGridRow = 0;

    // add source filters for each source on the timeline
    //
    for( int CurrentLayer = 0 ; CurrentLayer < VideoLayers ; CurrentLayer++ )
    {
        DbgTimer CurrentLayerTimer( "(rendeng) Current Layer" );

        // get the layer itself
        //
        CComPtr< IAMTimelineObj > pLayer;
	// NB: This function enumerates things inside out... tracks, then
	// the comp they're in, etc. until finally returning the group
	// It's NOT only giving real tracks!
        hr = pGroupComp->GetRecursiveLayerOfType( &pLayer, CurrentLayer, TIMELINE_MAJOR_TYPE_TRACK );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            hr = _GenerateError( 2, DEX_IDS_TIMELINE_PARSE, hr );
            goto die;
        }
        
        DbgTimer CurrentLayerTimer1( "(rendeng) Current Layer 1" );

	// I'm figuring out which physical track we're on
	TIMELINE_MAJOR_TYPE tx;
	pLayer->GetTimelineType(&tx);
	if (tx == TIMELINE_MAJOR_TYPE_TRACK)
	    WhichTrack++;

        // ask if the layer is muted
        //
        BOOL LayerMuted = FALSE;
        pLayer->GetMuted( &LayerMuted );
        if( LayerMuted )
        {
            // don't look at this layer
            //
            continue; // skip this layer, don't worry about grid
        }
        
        long LayerEmbedDepth = 0;
        pLayer->GetEmbedDepth( &LayerEmbedDepth );
        LayerEmbedDepth++;	// for our purposes, original black tracks are
        // 0 and actual layers are 1-based
        
        CComQIPtr< IAMTimelineTrack, &IID_IAMTimelineTrack > pTrack( pLayer );
        
        // get the TrackID for this layer
        //
        long TrackID = 0;
        pLayer->GetGenID( &TrackID );
        
        bool bUsedNewGridRow = false;

        // get all the sources for this layer
        //
        if( pTrack )
        {
            CComPtr< IAMTimelineObj > pSourceLast;
            CComPtr< IAMTimelineObj > pSourceObj;

	    // which source are we on?
	    int WhichSource = -1;

            while( 1 )
            {
                DbgTimer CurrentSourceTimer( "(rendeng) Video Source" );

                pSourceLast = pSourceObj;
                pSourceObj.Release();

                // get the next source on this layer, given a time.
                //
                hr = pTrack->GetNextSrcEx( pSourceLast, &pSourceObj );

                DbgLog( ( LOG_TRACE, 1, "Next Source" ) );

                ASSERT( !FAILED( hr ) );
                if( hr != NOERROR )
                {
                    // all done with sources
                    //
                    break;
                }
                
                CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSource( pSourceObj );
                ASSERT( pSource );
                if( !pSource )
                {
                    // this one bombed, look at the next
                    //
                    continue; // sources
                }
                
		// keeping track of which source this is
		WhichSource++;

                // ask if the source is muted
                //
                BOOL SourceMuted = FALSE;
                pSourceObj->GetMuted( &SourceMuted );
                if( SourceMuted )
                {
                    // don't look at this source
                    //
                    continue; // sources
                }
                
                // get the source's SourceID
                //
                long SourceID = 0;
                pSourceObj->GetGenID( &SourceID );
                
                // ask the source which stream number it wants to provide, since it
                // may be one of many
                //
                long StreamNumber = 0;
                hr = pSource->GetStreamNumber( &StreamNumber );
                    
                int nStretchMode;
                hr = pSource->GetStretchMode( &nStretchMode );
                
                CComBSTR bstrName;
                hr = pSource->GetMediaName( &bstrName );
                if( FAILED( hr ) )
                {
                    // couldn't allocate the memory, guess we die
                    goto die;
                }
                GUID guid;
                hr = pSourceObj->GetSubObjectGUID(&guid);
                double sfps;
                hr = pSource->GetDefaultFPS( &sfps );
                ASSERT(hr == S_OK); // can't fail, really

                // this is the order things MUST be done
                // 1. Get Start/Stop times
                // 2. Get MediaTimes
                // 3. Make sure MediaStop <> MediaStart
                // 4. Offset for RenderRange MUST be done before fixing up the
                // times because of rounding issues with the slope calculation 
                // in ValidateTimes.
                // 5. Fix Source Times
                // 6. Fix Media Times

                // ask this source for it's start/stop times
                //
                REFERENCE_TIME SourceStart = 0;
                REFERENCE_TIME SourceStop = 0;
                hr = pSourceObj->GetStartStop( &SourceStart, &SourceStop );
		// I want to remember what these were, originally
		REFERENCE_TIME SourceStartOrig = SourceStart;
		REFERENCE_TIME SourceStopOrig = SourceStop;
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) || SourceStart == SourceStop)
                {
                    // this one bombed, or exists for zero time
                    //
                    continue; // sources
                }
                // ask this source for it's media start/stops
                //
                REFERENCE_TIME MediaStart = 0;
                REFERENCE_TIME MediaStop = 0;
                hr = pSource->GetMediaTimes( &MediaStart, &MediaStop );
		// I want to remember what these were, originally
		REFERENCE_TIME MediaStartOrig = MediaStart;
		REFERENCE_TIME MediaStopOrig = MediaStop;
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    // this one bombed, look at the next
                    //
                    continue; // sources
                }
                
                DbgTimer CurrentSourceTimer2( "(rendeng) Video Source 2" );

                // !!! Not sure the right way to handle sources with no media times
                // So the FRC doesn't get confused, we'll make MTime = TLTime
                if (MediaStart == MediaStop) {
                    MediaStop = MediaStart + (SourceStop - SourceStart);
                }
                
                // skew the times for the particular render range
                //
                if( m_rtRenderStart != -1 )
                {
                    SourceStart -= m_rtRenderStart;
                    SourceStop -= m_rtRenderStart;

                    if( ( SourceStop <= 0 ) || ( SourceStart >= ( m_rtRenderStop - m_rtRenderStart ) ) )
                    {
                        continue; // out of range
                    }
                }
                
                // make sure no times go < 0
                //                
                ValidateTimes( SourceStart, SourceStop, MediaStart, MediaStop, GroupFPS, TotalDuration );
                
                if(SourceStart == SourceStop)
                {
                    // source combining, among other things, will mess up if
                    // we try and play something for 0 length.  ignore this.
                    //
                    continue; // sources
                }

                STARTSTOPSKEW skew;
                skew.rtStart = MediaStart;
                skew.rtStop = MediaStop;
                skew.rtSkew = SourceStart - MediaStart;
                // !!! rate calculation appears in several places
                if (MediaStop == MediaStart || SourceStop == SourceStart)
                    skew.dRate = 1;
                else
                    skew.dRate = (double) ( MediaStop - MediaStart ) /
                    ( SourceStop - SourceStart );

    		DbgLog((LOG_TRACE,1,TEXT("RENDENG::Working with source")));
    		DbgLog((LOG_TRACE,1,TEXT("%ls"), (WCHAR *)bstrName));

		// get the props for the source
		CComPtr< IPropertySetter > pSetter;
		hr = pSourceObj->GetPropertySetter(&pSetter);

		// in the spirit of using only 1 source filter for
		// both the video and the audio of a file, if both
		// are needed, let's see if we have another group
		// with the same piece of this file but with another
		// media type - SHARING ONLY HAPPENS BETWEEN GROUP 0 AND 1
		long MatchID = 0;
		IPin *pSplit, *pSharePin = NULL;
		BOOL fShareSource = FALSE;
                int nSwitch0InPin;
                // in smart recomp, we don't know what video pieces are needed,
                // they may not match the audio pieces needed, so source sharing
                // will NEVER WORK.  Don't try it
		if (WhichGroup == 0 && !m_bUsedInSmartRecompression) {
		    // If the match is muted, we'll never try and use it,
                    // but that should be OK
                    // !!! Don't share if we're dealing with compressed data
                    // OK for now, since only video can be compressed now
		    hr = _FindMatchingSource(bstrName, SourceStartOrig,
			    SourceStopOrig, MediaStartOrig, MediaStopOrig,
			    WhichGroup, WhichTrack, WhichSource,
			    pGroupMediaType, GroupFPS, &MatchID);
    		    DbgLog((LOG_TRACE,1,TEXT("GenID %d matches with ID %d"),
						SourceID, MatchID));
		    
		} else if (WhichGroup == 1 && !m_bUsedInSmartRecompression) {
		    for (int zyz = 0; zyz < m_cshare; zyz++) {
			if (SourceID == m_share[zyz].MatchID) {
			    fShareSource = SHARE_SOURCES;
                            // this is the split pin we need to build off of
			    pSharePin = m_share[zyz].pPin;
                            // this is the switch pin used by group 0
			    nSwitch0InPin = m_share[zyz].nSwitch0InPin;
                            // OK, we have a split pin, but not necessarily the
                            // right one, if we're using a special stream #
                            // We need the right one or BuildSourcePart's
                            // caching won't work
                            if (StreamNumber > 0 && pSharePin) {
                                // not addreffed or released
                                pSharePin = FindOtherSplitterPin(pSharePin, MEDIATYPE_Video,
                                                StreamNumber);
                            }
			    // it's a dangly bit we are using
			    _RemoveFromDanglyList(pSharePin);
    		    	    DbgLog((LOG_TRACE,1,TEXT("GenID %d matches with ID %d"),
					SourceID, m_share[zyz].MatchID));
    			    DbgLog((LOG_TRACE,1,TEXT("Time to SHARE source!")));
			    break;
			}
		    }
		}

	    // If this source has been used before, and all the important
	    // parameters are the same, and the times don't overlap, then
	    // just re-use it using the same source filter we already made
	    // for it.

	    BOOL fCanReuse = FALSE;
            int nGrow;
            long SwitchInPinToUse = vidswitcherinpin;
	    int xxx;

	    // if a source has properties, do NOT share it with anybody, that
	    // other guy will unwittingly get my properties!
	    if (pSetter) {
		MatchID = 0;
		fShareSource = FALSE;
	    }

	    // go through all the sources in the project looking for a match
	    for (xxx = 0; xxx < cList; xxx++) {

	        // if a source has properties, do NOT re-use it, that
	        // other guy will unwittingly get my properties!
		if (pSetter) {
		    break;
		}

		// !!! Full path/no path will look different but won't be!
		if (!DexCompareW(pREUSE[xxx].bstrName, bstrName) && // since bstrName is good, and reuse bstrName is good, safe
			pREUSE[xxx].guid == guid &&
			pREUSE[xxx].nStretchMode == nStretchMode &&
			pREUSE[xxx].dfps == sfps &&
			pREUSE[xxx].nStreamNum == StreamNumber) {

		    // we found this source already in use.  But do the 
		    // different times it's needed overlap?
	    	    fCanReuse = TRUE;

                    nGrow = -1;

		    for (int yyy = 0; yyy < pREUSE[xxx].cTimes; yyy++) {
			// Here's the deal.  Re-using a file needs to seek
			// the file to the new spot, which must take < 1/30s
			// or it will interrupt playback.  If there are few
			// keyframes (ASF) this will take hours.  We cannot
			// re-use sources if they are consecutive.  Open it
			// twice, it'll play better avoiding the seek, and ping
			// pong between the 2 sources every other source.

                        double Rate1 = double( MediaStop - MediaStart ) / double( SourceStop - SourceStart );
                        double Rate2 = pREUSE[xxx].dTimelineRate;
                        REFERENCE_TIME OldMediaStop = pREUSE[xxx].pMiniSkew[yyy].rtMediaStop;
                        if( !IsCompressed && AreTimesAndRateReallyClose( 
                            pREUSE[xxx].pMiniSkew[yyy].rtStop, SourceStart, 
                            OldMediaStop, MediaStart, 
                            Rate1, Rate2, GroupFPS ) )
                        {
                            nGrow = yyy;
                            skew.dRate = 0.0;
    			    DbgLog((LOG_TRACE,1,TEXT("COMBINING with a previous source")));
                            break;
                        }

                        // if the start is really close to the reuse stop,
                        // and the rates are the same, we can combine them
                        //
			if (SourceStart < pREUSE[xxx].pMiniSkew[yyy].rtStop + HACKY_PADDING &&
				SourceStop > pREUSE[xxx].pMiniSkew[yyy].rtStart) {
        			fCanReuse = FALSE;
        			break;
			}
		    }
		    if (fCanReuse)
			break;
		}
	    }

            // Actually, we CAN'T re-use, if we're re-using a guy that is
            // sharing a parser... that would be both REUSE and SHARE, which,
            // as explained elsewhere, is illegal.
            if (WhichGroup == 1) {
                for (int zz = 0; zz < m_cshare; zz++) {
                    if (m_share[zz].MatchID == pREUSE[xxx].ID) {
                        fCanReuse = FALSE;
                    }
                }
            }

	    // We are re-using a previous source!  Add the times it is being
	    // used for this segment to the list of times it is used
	    if (fCanReuse) {

		// this is the pin the old source is coming in on
		SwitchInPinToUse = pREUSE[xxx].nPin;
            	DbgLog((LOG_TRACE,1,TEXT("Row %d can REUSE source from pin %ld")
						, gridinpin, SwitchInPinToUse));

                if( nGrow == -1 )
                {
		    // need to grow the array first?
	            if (pREUSE[xxx].cTimes == pREUSE[xxx].cTimesMax) {
		        pREUSE[xxx].cTimesMax += 10;
	                pREUSE[xxx].pMiniSkew = (MINI_SKEW*)QzTaskMemRealloc(
			    	    pREUSE[xxx].pMiniSkew,
				    pREUSE[xxx].cTimesMax * sizeof(MINI_SKEW));
	                if (pREUSE[xxx].pMiniSkew == NULL)
		            goto die;
	            }
		    pREUSE[xxx].pMiniSkew[pREUSE[xxx].cTimes].rtStart = SourceStart;
		    pREUSE[xxx].pMiniSkew[pREUSE[xxx].cTimes].rtStop = SourceStop;
		    pREUSE[xxx].pMiniSkew[pREUSE[xxx].cTimes].rtMediaStop = MediaStop;
		    pREUSE[xxx].cTimes++;
                }
                else
                {
                    // We MUST grow by a whole number of frame intervals.
                    // All these numbers be rounded to frame lengths, or things
                    // can screw up.  The timeline and media lengths are
                    // already an even # of frame lengths, so adding that much
                    // should be safe.
		    pREUSE[xxx].pMiniSkew[nGrow].rtStop += SourceStop -
                                                                SourceStart;
                    pREUSE[xxx].pMiniSkew[nGrow].rtMediaStop += MediaStop -
                                                                MediaStart;
                }

		// you CANNOT both share a source and re-use. It will never
		// work.  Don't even try. (When one branch finishes a segment
		// and seeks upstream, it will kill the other branch)
                // (source combining is OK... that's not really re-using)
		// RE-USING can improve perf n-1, sharing only 2-1, so I pick
		// RE-USING to win out.

		// if we were about to re-use an old parser, DON'T!
    		DbgLog((LOG_TRACE,1,TEXT("Re-using, can't share!")));

		// take the guy we're re-using from out of the race for possible
		// source re-usal
                if (WhichGroup == 0) {
                    for (int zz = 0; zz < m_cshare; zz++) {
                        if (m_share[zz].MyID == pREUSE[xxx].ID) {
                            m_share[zz].MatchID = 0;
                        }
                    }
                }
		fShareSource = FALSE;
		MatchID = 0;

	    // We are NOT re-using this source.  Put this new source on the
	    // list of unique sources to possibly be re-used later
	    //
	    } else {
	        pREUSE[cList].ID = SourceID;	// for sharing a source filter
	        pREUSE[cList].bstrName = SysAllocString(bstrName); // safe
	        if (pREUSE[cList].bstrName == NULL)
		    goto die;
	        pREUSE[cList].guid = guid;
	        pREUSE[cList].nPin = SwitchInPinToUse;
	        pREUSE[cList].nStretchMode = nStretchMode;
	        pREUSE[cList].dfps = sfps;
	        pREUSE[cList].nStreamNum = StreamNumber;
	        pREUSE[cList].cTimesMax = 10;
	        pREUSE[cList].cTimes = 0;
                // we only need to set this once, since all others must match it
                pREUSE[cList].dTimelineRate = double( MediaStop - MediaStart ) / double( SourceStop - SourceStart );
	        pREUSE[cList].pMiniSkew = (MINI_SKEW*)QzTaskMemAlloc(
			    pREUSE[cList].cTimesMax * sizeof(MINI_SKEW));
	        if (pREUSE[cList].pMiniSkew == NULL) {
                    SysFreeString(pREUSE[cList].bstrName);
                    pREUSE[cList].bstrName = NULL;
		    goto die;
                }
	        pREUSE[cList].cTimes = 1;
	        pREUSE[cList].pMiniSkew->rtStart = SourceStart;
	        pREUSE[cList].pMiniSkew->rtStop = SourceStop;
	        pREUSE[cList].pMiniSkew->rtMediaStop = MediaStop;

		// grow the list if necessary
	        cList++;
	        if (cList == cListMax) {
		    cListMax += 20;
                    DEX_REUSE *pxxx = (DEX_REUSE *)QzTaskMemRealloc(pREUSE,
                                        cListMax * sizeof(DEX_REUSE));
		    if (pxxx == NULL) {
		        goto die;
                    }
                    pREUSE = pxxx;
	        }
	    }

            // !!! We could save some time, by the following
            // if (fCanReuse)
            //     This Source's Recompressability = That Of The Source Reused
            // but I don't have access to the other source object

            DbgTimer CurrentSourceTimer3( "(rendeng) Video Source 3" );

            CComQIPtr< IAMTimelineSrcPriv, &IID_IAMTimelineSrcPriv > pSrcPriv( pSource );

            // if we're to reset the compat flags, then do so now. Since the group's
            // recompress type changed, we'll have to re-ask the sources
            //
            if( ResetCompatibleFlags )
            {
                pSrcPriv->ClearAnyKnowledgeOfRecompressability( );
            }

            // is this source compatibilly compressed? We'll ask the mediadet, since
            // it can do this function. It seems like scary code, but really, there's no
            // other way to do it. We look to see this information if it IS compressed,
            // or if it's not compressed, but it's not about to load the source anyhow.
            // Note that if the source has already figured this information out, then
            // GetIsRecompressable will return right away and we won't need to use a
            // mediadet. This information really only needs to be found out ONCE for
            // a source, if the app is smart about it.
            //
            // turn off Compat if the rate isn't right
            //
            BOOL NormalRate = FALSE;
            pSource->IsNormalRate( &NormalRate );

            // if we're the compressed RE, we need to know by this point if the source is
            // recompressable, so we need to go through this.

                BOOL Compat = FALSE;
                if( IsCompressed )
	        {
                    if( pSrcPriv )
                    {
                        hr = pSrcPriv->GetIsRecompressable( &Compat );
                        
                        if( hr == S_FALSE )
                        {
                            if( !NormalRate )
                            {
                                Compat = FALSE;
                            }
                            else
                            {
                                // the source didn't know. We have to find out, then
                                // tell it for future reference
                                CComPtr< IMediaDet > pDet;
                                hr = _CreateObject( CLSID_MediaDet,
                                    IID_IMediaDet,
                                    (void**) &pDet );
                                if( FAILED( hr ) )
                                {
                                    goto die;
                                }
                                
                                // set service provider for keyed filters
                                {
                                    CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( pDet );
                                    ASSERT( pOWS );
                                    if( pOWS )
                                    {                                    
                                        pOWS->SetSite((IUnknown *) (IServiceProvider *) m_punkSite );
                                    }                                        
                                }
                                hr = pDet->put_Filename( bstrName );
                                if( FAILED( hr ) )
                                {
                                    goto die;
                                }
                                
                                // I need to find a video stream first
                                //
                                long Streams = 0;
                                hr = pDet->get_OutputStreams( &Streams );
                                if( FAILED( hr ) )
                                {
                                    goto die;
                                }

                                // go look for a video type
                                //
                                CMediaType Type;
                                long FoundVideo = 0;
                                BOOL FoundStream = FALSE;
                                for( long i = 0 ; i < Streams ; i++ )
                                {
                                    hr = pDet->put_CurrentStream( i );
                                    if( FAILED( hr ) )
                                    {
                                        goto die;
                                    }

                                    SaferFreeMediaType( Type );
                                    hr = pDet->get_StreamMediaType( &Type );
                                    if( *Type.Type( ) == MEDIATYPE_Video )
                                    {
                                        if( FoundVideo == StreamNumber )
                                        {
                                            FoundStream = TRUE;
                                            break;
                                        }

                                        FoundVideo++;
                                    }
                                }

                                // didn't find the right stream number, this should NEVER happen
                                //
                                if( !FoundStream )
                                {
                                    ASSERT( 0 );
                                    hr = VFW_E_INVALIDMEDIATYPE;
                                    goto die;
                                }

                                // compare the source's type to the group's to determine
                                // if they're compatible
                                
                                Compat = AreMediaTypesCompatible( &Type, pGroupMediaType );
                                
                                SaferFreeMediaType( Type );
                                
                                pSrcPriv->SetIsRecompressable( Compat );
                            }
                        }
                    }
                }
                    
                DbgTimer CurrentSourceTimer4( "(rendeng) Video Source 4" );

                bUsedNewGridRow = true;

                // tell the grid about it.
                //
                VidGrid.WorkWithNewRow( SwitchInPinToUse, gridinpin, LayerEmbedDepth, 0 );

                VidGrid.RowSetIsSource( pSourceObj, Compat );
                DbgTimer CurrentSourceTimer402( "(rendeng) Video Source 402" );
                worked = VidGrid.RowIAmOutputNow( SourceStart, SourceStop, THE_OUTPUT_PIN );
                if( !worked )
                {
                    hr = E_OUTOFMEMORY;
                    goto die;
                }

                DbgTimer CurrentSourceTimer41( "(rendeng) Video Source 41" );
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                // don't do any switch connections unless we're not compressed.
                // we'll do that later
                //
		if( !IsCompressed || ( IsCompressed && Compat ) )
                {

	            // NO dynamic reconnections, make the source now
                    // !!!Smart recompression MUST USE DYNAMIC SOURCES or things
		    // will break trying to re-use a source that might not exist
		    // (the first instance may not have been a match with the
		    // smart recompression format if there was a rate change)
                    //
                    if( !( DynaFlags & CONNECTF_DYNAMIC_SOURCES ) ) 
                    {

                        // We are not re-using a previous source, make the source now
                        if( !fCanReuse ) 
                        {
                            CComPtr< IPin > pOutput;
        		    DbgLog((LOG_TRACE,1,TEXT("Call BuildSourcePart")));
                            
			    IBaseFilter *pDangly = NULL;
                            hr = BuildSourcePart(
                                m_pGraph, 
                                TRUE, 
                                sfps, 
                                pGroupMediaType,
                                GroupFPS, 
                                StreamNumber, 
                                nStretchMode, 
                                1, 
                                &skew,
                                this, 
                                bstrName, 
                                &guid,
				pSharePin,  // connect from this splitter pin
                                &pOutput, 
                                SourceID, 
                                m_pDeadCache,
                                IsCompressed,
                                m_MedLocFilterString,
                                m_nMedLocFlags,
                                m_pMedLocChain,
				pSetter, &pDangly);

			    // We built more than we bargained for. We have
			    // an appendage that we need to kill later if it
			    // isn't used
			    if (pDangly) {
			        m_pdangly[m_cdangly] = pDangly;
			        m_cdangly++;
			        if (m_cdangly == m_cdanglyMax) {
				    m_cdanglyMax += 25;
				    m_pdangly = (IBaseFilter **)CoTaskMemRealloc
					(m_pdangly,
					m_cdanglyMax * sizeof(IBaseFilter *));
				    if (m_pdangly == NULL) {
                                        // !!! leaves things dangling (no leak)
                                        hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,
							    E_OUTOFMEMORY);
                                        m_cdangly = 0;
                                        goto die;
				    }
			        }
			    }
                            
                            if (FAILED(hr)) {
                                // error was already logged
                                goto die;
                            }
                            
                            if( m_bUsedInSmartRecompression && !IsCompressed )
                            {
                                // pause a second and find out if this source has
                                // a compatible media type. In case we'll use it
                                // for a smart recompression later
                                
                                // we need the source filter... look upstream of the pOutput pin
                                // for the source filter
                                //
                                IBaseFilter * pStartFilter = GetStartFilterOfChain( pOutput );
                                
                                hr = pSrcPriv->GetIsRecompressable( &Compat );
                                if( hr == S_FALSE )
                                {
                                    if( !NormalRate )
                                    {
                                        Compat = FALSE;
                                    }
                                    else
                                    {
                                        // set the major type for the format we're looking for
                                        //
                                        AM_MEDIA_TYPE FindMediaType;
                                        ZeroMemory( &FindMediaType, sizeof( FindMediaType ) ); // safe
                                        FindMediaType.majortype = MEDIATYPE_Video;
                                        
					// !!! Did I break this function?
                                        hr = FindMediaTypeInChain( pStartFilter, &FindMediaType, StreamNumber );
                                        
                                        // compare the two media types
                                        // !!! redefined it
                                        BOOL Compat = AreMediaTypesCompatible( &FindMediaType, &CompressedGroupType );
                                        
                                        SaferFreeMediaType( FindMediaType );
                                        
                                        pSrcPriv->SetIsRecompressable( Compat );
                                    }
                                }
                            }
                            
                            CComPtr< IPin > pSwitchIn;
                            _pVidSwitcherBase->GetInputPin(SwitchInPinToUse, &pSwitchIn);
                            if( !pSwitchIn )
                            {
                                ASSERT(FALSE);
                                hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,E_OUTOFMEMORY);
                                goto die;
                            }
                            hr = _Connect( pOutput, pSwitchIn );
                            
                            ASSERT( !FAILED( hr ) );
                            if( FAILED( hr ) )
                            {
                                hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                                goto die;
                            }
                            
			    // If we are going to use this source for both audio
			    // and video, get an unused split pin of the right
			    // type as a good place to start the other chain
			    if (MatchID) {
				GUID guid = MEDIATYPE_Audio;
				pSplit = FindOtherSplitterPin(pOutput, guid,0);
				if (!pSplit) {
				    MatchID = 0;
				}
			    }

                            // we ARE re-using a previous source. Add the new range
                        } 
                        else 
                        {
                            DbgTimer ReuseSourceTimer( "(rendeng) Reuse Video Source" );
    			    DbgLog((LOG_TRACE,1,TEXT("Adding another skew..")));

                            CComPtr< IPin > pPin;
                            m_pSwitcherArray[WhichGroup]->GetInputPin(SwitchInPinToUse, &pPin);
                            ASSERT( pPin);
                            if( !pPin )
                            {
                                hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,E_OUTOFMEMORY);
                                goto die;
                            }
                            IPin * pCon;

                            hr = pPin->ConnectedTo(&pCon);
                            
                            ASSERT(hr == S_OK);

                            IBaseFilter *pFil = GetFilterFromPin(pCon);
                            pCon->Release( );
                            ASSERT( pFil);
                            if( !pFil )
                            {
                                hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,E_OUTOFMEMORY);
                                goto die;
                            }

                            CComQIPtr<IDexterSequencer, &IID_IDexterSequencer>
                                pDex( pFil );
                            ASSERT(pDex);
                            if( !pDex )
                            {
                                hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,E_OUTOFMEMORY);
                                goto die;
                            }

                            hr = pDex->AddStartStopSkew(skew.rtStart, skew.rtStop,
                                skew.rtSkew, skew.dRate);
                            ASSERT(SUCCEEDED(hr));
                            if(FAILED(hr))
                            {
                                hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,hr);
                                goto die;
                            }

			    // If we are going to use this source for both audio
			    // and video, get an unused split pin of the right
			    // type as a good place to start the other chain
			    if (MatchID) {
				ASSERT(FALSE);	// can't both re-use and share
				GUID guid = MEDIATYPE_Audio;
				pSplit = FindOtherSplitterPin(pCon, guid,0);
				if (!pSplit) {
				    MatchID = 0;
				}
			    }

                        }

			// remember which source we are going to use on the
			// other splitter pin
			if (MatchID) {
			    m_share[m_cshare].MatchID = MatchID;
			    m_share[m_cshare].MyID = SourceID;
			    m_share[m_cshare].pPin = pSplit;
                            // remember which group 0 switch in pin was used
			    m_share[m_cshare].nSwitch0InPin = SwitchInPinToUse;
			    m_cshare++;
			    if (m_cshare == m_cshareMax) {
				m_cshareMax += 25;
				m_share = (ShareAV *)CoTaskMemRealloc(m_share,
						m_cshareMax * sizeof(ShareAV));
				if (m_share == NULL) {
                                    hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,
							E_OUTOFMEMORY);
                                    goto die;
				}
			    }
			}
                    }
                    else 
                    {
                        // DYNAMIC reconnections - make the source later
                        
                        // schedule this source to be dynamically loaded by the switcher
                        // at a later time. This will merge skews of like sources
    			DbgLog((LOG_TRACE,1,TEXT("Calling AddSourceToConnect")));
                        AM_MEDIA_TYPE mt;
                        ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE)); // safe
                        if (!fShareSource || WhichGroup != 1) {
                            // Normal case - we are not the shared appendage
                            hr = m_pSwitcherArray[WhichGroup]->AddSourceToConnect(
                                bstrName,
                                &guid, nStretchMode,
                                StreamNumber, sfps,
                                1, &skew,
                                SwitchInPinToUse, FALSE, 0, mt, 0.0,
			        pSetter);
                        } else {
                            // We are a shared appendage.  Tell the group 0 
                            // switch about this source, which will build and
                            // destroy both chains to both switches at the same
                            // time.
                            ASSERT(WhichGroup == 1);
                            DbgLog((LOG_TRACE,1,TEXT("SHARING: Giving switch 0 info about switch 1")));
                            hr = m_pSwitcherArray[0]->AddSourceToConnect(
                                bstrName,
                                &guid, nStretchMode,
                                StreamNumber, sfps,
                                1, &skew,
                                nSwitch0InPin,      // group 0's switch inpin
                                TRUE, SwitchInPinToUse, // our switch's inpin
                                *pGroupMediaType, GroupFPS,
			        pSetter);
                        }
                        if (FAILED(hr)) 
                        {
                            hr = _GenerateError( 1, DEX_IDS_INSTALL_PROBLEM, hr );
                            goto die;
                        }

			// remember which source we are going to use on the
			// other splitter pin
			if (MatchID) {
			    m_share[m_cshare].MatchID = MatchID;
			    m_share[m_cshare].MyID = SourceID;
			    m_share[m_cshare].pPin = NULL; // don't have this
                            // remember which group 0 switch in pin was used
			    m_share[m_cshare].nSwitch0InPin = SwitchInPinToUse;
			    m_cshare++;
			    if (m_cshare == m_cshareMax) {
				m_cshareMax += 25;
				m_share = (ShareAV *)CoTaskMemRealloc(m_share,
						m_cshareMax * sizeof(ShareAV));
				if (m_share == NULL) {
                                    hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,
							E_OUTOFMEMORY);
                                    goto die;
				}
			    }
			}

                    }
            
                    // tell the switcher that we're a source pin
                    //
                    hr = m_pSwitcherArray[WhichGroup]->InputIsASource(
                        SwitchInPinToUse, TRUE );
            
                } // if !IsCompressed
            
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

                DbgTimer CurrentSourceTimer5( "(rendeng) Video Source 5" );

                gridinpin++;
                if( !fCanReuse )
                {
                    vidswitcherinpin++;
                }
            
                // check and see if we have source effects
                //
                CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pSourceEffectable( pSource );
                long SourceEffectCount = 0;
                long SourceEffectInPin = 0;
                long SourceEffectOutPin = 0;
                CComPtr< IAMMixEffect > pSourceMixEffect;
                if( pSourceEffectable )
                {
                    pSourceEffectable->EffectGetCount( &SourceEffectCount );
                }
            
                // if we don't want effects, set the effect count to 0
                //
                if( !EnableFx )
                {
                    SourceEffectCount = 0;
                }
            
                if( SourceEffectCount )
                {
                    DbgTimer SourceEffectTimer( "Source Effects" );

                    if( !IsCompressed )
                    {
                        // create the DXT wrapper
                        //
                        CComPtr< IBaseFilter > pDXTBase;
                        hr = _CreateObject(
                            CLSID_DXTWrap,
                            IID_IBaseFilter,
                            (void**) &pDXTBase,
                            SourceID + ID_OFFSET_EFFECT );
                        ASSERT( !FAILED( hr ) );
                        if( FAILED( hr ) )
                        {
                            hr = _GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
                            goto die;
                        }
                    
                        // tell it about our error log
                        //
                        CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pErrLog( pDXTBase );
                        if( pErrLog )
                        {
                            pErrLog->put_ErrorLog( m_pErrorLog );
                        }
                    
                        // get the effect interface
                        //
                        hr = pDXTBase->QueryInterface( IID_IAMMixEffect, (void**) &pSourceMixEffect );
                        ASSERT( !FAILED( hr ) );
                        if( FAILED( hr ) )
                        {
                            hr = _GenerateError( 2, DEX_IDS_INTERFACE_ERROR, hr );      
                            goto die;
                        }
                    
                        // reset the DXT so we can reprogram it.
                        // !!! take this out someday, make QParamdata more efficient
                        //
                        pSourceMixEffect->Reset( );
                
                        // set up some stuff now
                        //
                        hr = pSourceMixEffect->SetNumInputs( 1 );
                        ASSERT( !FAILED( hr ) );
                        hr = pSourceMixEffect->SetMediaType( pGroupMediaType );
                        ASSERT( !FAILED( hr ) );
                    
                        // set the defaults
                        //
                        GUID DefaultEffect = GUID_NULL;
                        m_pTimeline->GetDefaultEffect( &DefaultEffect );
                        hr = pSourceMixEffect->SetDefaultEffect( &DefaultEffect );
                    
                        // add it to the graph
                        //
                        hr = _AddFilter( pDXTBase, L"DXT Wrapper", SourceID + 1 );
                        ASSERT( !FAILED( hr ) );
                        if( FAILED( hr ) )
                        {
                            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );      
                            goto die;
                        }
                    
                        // find pins...
                        //
                        IPin * pFilterInPin = NULL;
                        pFilterInPin = GetInPin( pDXTBase, 0 );
                        ASSERT( pFilterInPin );
                        if( !pFilterInPin )
                        {
                            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, E_OUTOFMEMORY);
                            goto die;
                        }
                        // !!! error check
                        IPin * pFilterOutPin = NULL;
                        pFilterOutPin = GetOutPin( pDXTBase, 0 );
                        ASSERT( pFilterOutPin );
                        if( !pFilterOutPin )
                        {
                            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, E_OUTOFMEMORY);
                            goto die;
                        }
                        CComPtr< IPin > pSwitcherOutPin;
                        _pVidSwitcherBase->GetOutputPin(vidswitcheroutpin, &pSwitcherOutPin);
                        ASSERT( pSwitcherOutPin );
                        if( !pSwitcherOutPin )
                        {
                            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, E_OUTOFMEMORY);
                            goto die;
                        }
                        CComPtr< IPin > pSwitcherInPin;
                        _pVidSwitcherBase->GetInputPin(vidswitcherinpin, &pSwitcherInPin);
                        ASSERT( pSwitcherInPin );
                        if( !pSwitcherInPin )
                        {
                            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, E_OUTOFMEMORY);
                            goto die;
                        }
                    
                        // connect them
                        //
                        hr = _Connect( pSwitcherOutPin, pFilterInPin );
                        ASSERT( !FAILED( hr ) );
                        if( FAILED( hr ) )
                        {
                            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                            goto die;
                        }
                        hr = _Connect( pFilterOutPin, pSwitcherInPin );
                        ASSERT( !FAILED( hr ) );
                        if( FAILED( hr ) )
                        {
                            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                            goto die;
                        }
                    } // if !IsCompressed
                
                    // use one DXT for all the effects we wish to apply
                    //
                    SourceEffectInPin = vidswitcherinpin;
                    SourceEffectOutPin = vidswitcheroutpin;
                
                    // new row on the grid. NOTE: Clip effects technically should be one layer
                    // deeper than the clip itself, but since clip effect ranges are bounded by the length
                    // of the clip, they will never affect anything outside that clip, and we don't need to
                    // do it right.
                    //
                    VidGrid.WorkWithNewRow( SourceEffectInPin, gridinpin, LayerEmbedDepth, 0 );

                    // go through each effect and apply it to the DXT wrapper
                    //
                    for( int SourceEffectN = 0 ; SourceEffectN < SourceEffectCount ; SourceEffectN++ )
                    {
                        CComPtr< IAMTimelineObj > pEffect;
                        hr = pSourceEffectable->GetEffect( &pEffect, SourceEffectN );
                    
                        // if for some reason, it didn't work, ignore it (I guess)
                        //
                        if( !pEffect )
                        {
                            // !!! should we notify app that something didn't work?
                            continue; // effects
                        }
                    
                        // ask if the effect is muted
                        //
                        BOOL effectMuted = FALSE;
                        pEffect->GetMuted( &effectMuted );
                        if( effectMuted )
                        {
                            // don't look at this effect
                            //
                            // !!! should we notify app that something didn't work?
                            continue; // effects
                        }
                    
                        // find the effect's lifetime
                        //
                        REFERENCE_TIME EffectStart = 0;
                        REFERENCE_TIME EffectStop = 0;
                        hr = pEffect->GetStartStop( &EffectStart, &EffectStop );
                        ASSERT( !FAILED( hr ) ); // should always work
                    
                        // add in the effect's parent's time
                        //
                        EffectStart += SourceStart;
                        EffectStop += SourceStart;
                    
                        // do some minimal error checking
                        //
                        if( m_rtRenderStart != -1 )
                        {
                            if( ( EffectStop <= m_rtRenderStart ) || ( EffectStart >= m_rtRenderStop ) )
                            {
                                // !!! should we notify app that something didn't work?
                                continue; // effects
                            }
                            else
                            {
                                EffectStart -= m_rtRenderStart;
                                EffectStop -= m_rtRenderStart;
                            }
                        }
                    
                        // fix up the times to align on a frame boundary
                        //
                        hr = pEffect->FixTimes( &EffectStart, &EffectStop );
                    
                        // too short, we're ignoring it
                        if (EffectStart >= EffectStop)
                            continue;
                
                        if( !IsCompressed )
                        {
                            // find the effect's subobject or GUID, whichever comes first
                            //
                            BOOL Loaded = FALSE;
                            pEffect->GetSubObjectLoaded( &Loaded );
                            GUID EffectGuid = GUID_NULL;
                            CComPtr< IUnknown > EffectPtr;
                            if( Loaded )
                            {
                                hr = pEffect->GetSubObject( &EffectPtr );
                            }
                            else
                            {
                                hr = pEffect->GetSubObjectGUID( &EffectGuid );
                            }
                            ASSERT( !FAILED( hr ) );
                            if( FAILED( hr ) )
                            {
                                // !!! should we notify app that something didn't work?
                                continue; // effects
                            }
                        
                            CComPtr< IPropertySetter > pSetter;
                            hr = pEffect->GetPropertySetter( &pSetter );
                            // can't fail
                            ASSERT( !FAILED( hr ) );
                        
                            // ask for the wrap interface
                            //
                            DEXTER_PARAM_DATA ParamData;
                            ZeroMemory( &ParamData, sizeof( ParamData ) ); // safe
                            ParamData.rtStart = EffectStart;
                            ParamData.rtStop = EffectStop;
                            ParamData.pSetter = pSetter;
                            hr = pSourceMixEffect->QParamData(
                                EffectStart,
                                EffectStop,
                                EffectGuid,
                                EffectPtr,
                                &ParamData );
                            if( FAILED( hr ) )
                            {
                                // QParamData logs its own errors
                                continue; // effects
                            }
                            // QParamData logs its own errors
                        } // if !IsCompressed
                    
                        // tell the grid who is grabbing what
                        //
                        worked = VidGrid.RowIAmEffectNow( EffectStart, EffectStop, SourceEffectOutPin );
                        if( !worked )
                        {
                            hr = E_OUTOFMEMORY;
                            goto die;
                        }

        		VidGrid.DumpGrid( );
                    
                    } // for all the effects
                
                    // bump these to make room for the effect
                    //
                    vidswitcheroutpin++;
                    vidswitcherinpin++;
                    gridinpin++;
                
                } // if any effects on Source
            
            } // while sources

            if( !bUsedNewGridRow )
            {
                // nothing was on this Video TRACK, so ignore everything on it. This
                // only happens for a video TRACK, not a composition or a group
                //
                continue;
            }

        } // if pTrack
        
        CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pTrackEffectable( pLayer );
        long TrackEffectCount = 0;
        if( pTrackEffectable )
        {
            pTrackEffectable->EffectGetCount( &TrackEffectCount );
        }
        
        if( !EnableFx )
        {
            TrackEffectCount = 0;
        }
        
        REFERENCE_TIME TrackStart = 0;
        REFERENCE_TIME TrackStop = 0;
        pLayer->GetStartStop( &TrackStart, &TrackStop );
        
        if( TrackEffectCount )
        {
            DbgTimer TrackEffectTimer( "Track Effects" );

            CComPtr< IAMMixEffect > pTrackMixEffect;
            if (!IsCompressed) {
                // if we are rendering only a portion of the timeline, and the count
                // shows that an effect is present, we'll put a DXT wrapper in the 
                // graph even if, during the amount of time that we're active,
                // an effect doesn't happen. This way, we'll be faster for scrubbing.
                
                // create the DXT wrapper
                //
                CComPtr< IBaseFilter > pDXTBase;
                hr = _CreateObject(
                    CLSID_DXTWrap,
                    IID_IBaseFilter,
                    (void**) &pDXTBase,
                    TrackID + ID_OFFSET_EFFECT );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
                    goto die;
                }
                
                // tell it about our error log
                //
                CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pErrLog( pDXTBase );
                if( pErrLog )
                {
                    pErrLog->put_ErrorLog( m_pErrorLog );
                }
                
                // add it to the graph
                //
                hr = _AddFilter( pDXTBase, L"DXT Wrapper", TrackID + ID_OFFSET_EFFECT );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                
                // get the effect interface
                //
                hr = pDXTBase->QueryInterface( IID_IAMMixEffect, (void**) &pTrackMixEffect );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_INTERFACE_ERROR, hr );
                    goto die;
                }
                
                // reset the DXT so we can reprogram it.
                // !!! take this out someday, make QParamdata more efficient
                //
                pTrackMixEffect->Reset( );
                
                // set up some stuff now
                //
                hr = pTrackMixEffect->SetNumInputs( 1 );
                hr = pTrackMixEffect->SetMediaType( pGroupMediaType );
                ASSERT( !FAILED( hr ) );
                
                // set the defaults
                //
                GUID DefaultEffect = GUID_NULL;
                m_pTimeline->GetDefaultEffect( &DefaultEffect );
                hr = pTrackMixEffect->SetDefaultEffect( &DefaultEffect );
                ASSERT(SUCCEEDED(hr));
                
                // find pins...
                //
                IPin * pFilterInPin = NULL;
                pFilterInPin = GetInPin( pDXTBase, 0 );
                ASSERT( pFilterInPin );
                if( !pFilterInPin )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                IPin * pFilterOutPin = NULL;
                pFilterOutPin = GetOutPin( pDXTBase, 0 );
                ASSERT( pFilterOutPin );
                if( !pFilterOutPin )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                CComPtr< IPin > pSwitcherOutPin;
                _pVidSwitcherBase->GetOutputPin(vidswitcheroutpin, &pSwitcherOutPin );
                ASSERT( pSwitcherOutPin );
                if( !pSwitcherOutPin )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                CComPtr< IPin > pSwitcherInPin;
                _pVidSwitcherBase->GetInputPin(vidswitcherinpin, &pSwitcherInPin );
                ASSERT( pSwitcherInPin );
                if( !pSwitcherInPin )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                
                // connect it up
                //
                hr = _Connect( pSwitcherOutPin, pFilterInPin );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                hr = _Connect( pFilterOutPin, pSwitcherInPin );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                
          } // if (!IsCompressed)
          
          // new row on the grid
          //
          bUsedNewGridRow = true;
          VidGrid.WorkWithNewRow( vidswitcherinpin, gridinpin, LayerEmbedDepth, 0 );
          
          // go through every effect and program up the DXT for it
          //
          for( int TrackEffectN = 0 ; TrackEffectN < TrackEffectCount ; TrackEffectN++ )
          {
              CComPtr< IAMTimelineObj > pEffect;
              pTrackEffectable->GetEffect( &pEffect, TrackEffectN );
              if( !pEffect )
              {
                  // effect didn't show up, ignore it
                  //
                  continue; // effects
              }
              
              // ask if the effect is muted
              //
              BOOL effectMuted = FALSE;
              pEffect->GetMuted( &effectMuted );
              if( effectMuted )
              {
                  // don't look at this effect
                  //
                  continue; // effects
              }
              
              // find the effect's lifetime, this should always work
              //
              REFERENCE_TIME EffectStart = 0;
              REFERENCE_TIME EffectStop = 0;
              hr = pEffect->GetStartStop( &EffectStart, &EffectStop );
              ASSERT( !FAILED( hr ) );
              
              EffectStart += TrackStart;
              EffectStop += TrackStart;
              
              // minimal error checking on times
              //
              if( m_rtRenderStart != -1 )
              {
                  if( ( EffectStop <= m_rtRenderStart ) || ( EffectStart >= m_rtRenderStop ) )
                  {
                      continue; // effects
                  }
                  else
                  {
                      EffectStart -= m_rtRenderStart;
                      EffectStop -= m_rtRenderStart;
                  }
              }
                  
              // align times to frame boundary
              //
              hr = pEffect->FixTimes( &EffectStart, &EffectStop );
              
              // too short, we're ignoring it
              if (EffectStart >= EffectStop)
                  continue;
                
              if (!IsCompressed) {
                  // find the effect's GUID.
                  //
                  GUID EffectGuid = GUID_NULL;
                  hr = pEffect->GetSubObjectGUID( &EffectGuid );
                  ASSERT( !FAILED( hr ) );
                  if( FAILED( hr ) )
                  {
                      // effect failed to give us something valuable, we should ignore it.
                      //
                      continue; // effects
                  }
                  
                  CComPtr< IPropertySetter > pSetter;
                  hr = pEffect->GetPropertySetter( &pSetter );
                  // can't fail
                  ASSERT( !FAILED( hr ) );
                  
                  // ask for the wrap interface
                  //
                  DEXTER_PARAM_DATA ParamData;
                  ZeroMemory( &ParamData, sizeof( ParamData ) ); // safe
                  ParamData.rtStart = EffectStart;
                  ParamData.rtStop = EffectStop;
                  ParamData.pSetter = pSetter;
                  hr = pTrackMixEffect->QParamData(
                      EffectStart,
                      EffectStop,
                      EffectGuid,
                      NULL, // effect com object
                      &ParamData );
                  if( FAILED( hr ) )
                  {
                      // QParamData logs its own errors
                      continue; // effects
                  }
                  // QParamData logs its own errors
                  
              }	// if (!IsCompressed)
              
              // tell the grid who is grabbing what
              
              worked = VidGrid.RowIAmEffectNow( EffectStart, EffectStop, vidswitcheroutpin );
                if( !worked )
                {
                    hr = E_OUTOFMEMORY;
                    goto die;
                }
                  
              VidGrid.DumpGrid( );

          } // for all the effects
          
          // bump these to make room for the effect
          //
          vidswitcheroutpin++;
          vidswitcherinpin++;
          gridinpin++;
          
        } // if any effects on track
        
        // ask this TRACK if it has a transition, or two
        //
        CComQIPtr< IAMTimelineTransable, &IID_IAMTimelineTransable > pTrackTransable( pLayer );
        ASSERT( pTrackTransable );
        long TransitionCount = 0;
        hr = pTrackTransable->TransGetCount( &TransitionCount );
        if( TransitionCount )
        {
            DbgTimer TransitionTimer( "Trans Timer" );

            CComPtr< IAMMixEffect > pMixEffect;
            if( !IsCompressed )
            {
                // create the DXT wrapper
                //
                CComPtr< IBaseFilter > pDXTBase;
                hr = _CreateObject(
                    CLSID_DXTWrap,
                    IID_IBaseFilter,
                    (void**) &pDXTBase,
                    TrackID + ID_OFFSET_TRANSITION );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
                    goto die;
                }

                // tell it about our error log
                //
                CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pErrLog( pDXTBase);
                if( pErrLog )
                {
                    pErrLog->put_ErrorLog( m_pErrorLog );
                }
                
                // add it to the graph
                //
                hr = _AddFilter( pDXTBase, L"DXT Wrapper", TrackID + ID_OFFSET_TRANSITION );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                
                // get the effect interface
                //
                hr = pDXTBase->QueryInterface( IID_IAMMixEffect, (void**) &pMixEffect );
                ASSERT( !FAILED( hr ) );
                
                // reset the DXT so we can reprogram it.
                // !!! take this out someday, make QParamdata more efficient
                //
                pMixEffect->Reset( );
                
                // set up some stuff now
                //
                hr = pMixEffect->SetNumInputs( 2 );
                hr = pMixEffect->SetMediaType( pGroupMediaType );
                ASSERT( !FAILED( hr ) );
                
                // set the default effect
                //
                GUID DefaultEffect = GUID_NULL;
                m_pTimeline->GetDefaultTransition( &DefaultEffect );
                hr = pMixEffect->SetDefaultEffect( &DefaultEffect );
                
                // find it's pins...
                //
                IPin * pFilterInPin1 = NULL;
                IPin * pFilterInPin2 = NULL;
                IPin * pFilterOutPin = NULL;
                pFilterInPin1 = GetInPin( pDXTBase, 0 );
                ASSERT( pFilterInPin1 );
                if( !pFilterInPin1 )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                pFilterInPin2 = GetInPin( pDXTBase, 1 );
                ASSERT( pFilterInPin2 );
                if( !pFilterInPin2 )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                pFilterOutPin = GetOutPin( pDXTBase, 0 );
                ASSERT( pFilterOutPin );
                if( !pFilterOutPin )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                CComPtr< IPin > pSwitcherOutPin1;
                _pVidSwitcherBase->GetOutputPin( vidswitcheroutpin, &pSwitcherOutPin1 );
                ASSERT( pSwitcherOutPin1 );
                if( !pSwitcherOutPin1 )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                CComPtr< IPin > pSwitcherOutPin2;
                _pVidSwitcherBase->GetOutputPin(vidswitcheroutpin + 1, &pSwitcherOutPin2 );
                ASSERT( pSwitcherOutPin2 );
                if( !pSwitcherOutPin2 )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                CComPtr< IPin > pSwitcherInPin;
                _pVidSwitcherBase->GetInputPin( vidswitcherinpin, &pSwitcherInPin );
                ASSERT( pSwitcherInPin );
                if( !pSwitcherInPin )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }

                // connect them all up
                //
                hr = _Connect( pSwitcherOutPin1, pFilterInPin1 );
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                ASSERT( !FAILED( hr ) );

                hr = _Connect( pSwitcherOutPin2, pFilterInPin2 );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }

                hr = _Connect( pFilterOutPin, pSwitcherInPin );
                ASSERT( !FAILED( hr ) ); 
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }

            } // if !IsCompressed
            
            bUsedNewGridRow = true;
            VidGrid.WorkWithNewRow( vidswitcherinpin, gridinpin, LayerEmbedDepth, 0 );
            
            // for each transition on the track, add it to the DXT wrapper
            //
            REFERENCE_TIME TransInOut = 0;
            for( long CurTrans = 0 ; CurTrans < TransitionCount ; CurTrans++ )
            {
                // yup, it's got one alright
                //
                CComPtr< IAMTimelineObj > pTransObj;
                hr = pTrackTransable->GetNextTrans( &pTransObj, &TransInOut );
                if( !pTransObj )
                {
                    // for some reason, it didn't show up, ignore it
                    //
                    continue; // transitions
                }
                
                // ask if the Trans is muted 
                //
                BOOL TransMuted = FALSE;
                pTransObj->GetMuted( &TransMuted );
                if( TransMuted )
                {
                    // don't look at this
                    //
                    continue; // transitions
                }
                
                CComQIPtr< IAMTimelineTrans, &__uuidof(IAMTimelineTrans) > pTrans( pTransObj );
                
                // ask the trans which direction to go
                //
                BOOL fSwapInputs;
                pTrans->GetSwapInputs(&fSwapInputs);
                
                // and get it's start/stop times
                //
                REFERENCE_TIME TransStart = 0;
                REFERENCE_TIME TransStop = 0;
                GUID TransGuid = GUID_NULL;
                pTransObj->GetStartStop( &TransStart, &TransStop );
                
                // need to add parent's times to transition's
                //
                TransStart += TrackStart;
                TransStop += TrackStart;
                
                // do some minimal error checking
                //
                if( m_rtRenderStart != -1 )
                {
                    if( ( TransStop <= m_rtRenderStart ) || ( TransStart >= m_rtRenderStop ) )
                    {
                        continue; // transitions
                    }
                    else
                    {
                        TransStart -= m_rtRenderStart;
                        TransStop -= m_rtRenderStart;
                    }
                }
                    
                // align the times to a frame boundary
                //
                hr = pTransObj->FixTimes( &TransStart, &TransStop );

                // too short, we're ignoring it
                if (TransStart >= TransStop)
                    continue;
                
                // get the cut point, in case we just do cuts only
                //
                REFERENCE_TIME CutTime = 0;
                hr = pTrans->GetCutPoint( &CutTime );
                ASSERT( !FAILED( hr ) );
                
                // this is an offset, so we need to bump it to get to TL time
                //
                CutTime += TrackStart;
                hr = pTransObj->FixTimes( &CutTime, NULL );
                
                // ask if we're only doing a cut
                //
                BOOL CutsOnly = FALSE;
                hr = pTrans->GetCutsOnly( &CutsOnly );
                
                // if we haven't enabled this transition for real, then we need
                // to tell the grid we need some space in order to live
                //
                if( !EnableTransitions || CutsOnly )
                {
                    worked = VidGrid.PleaseGiveBackAPieceSoICanBeACutPoint( TransStart, TransStop, TransStart + CutTime );
                    if( !worked )
                    {
                        hr = E_OUTOFMEMORY;
                        goto die;
                    }
                
                    // that's all, do the next one
                    //
                    continue; // transitions
                }
                
                if( !IsCompressed )
                {
                    // ask the transition for the effect it wants to provide
                    //
                    hr = pTransObj->GetSubObjectGUID( &TransGuid );
                    if( FAILED( hr ) )
                    {
                        continue; // transitions
                    }
                    
                    CComPtr< IPropertySetter > pSetter;
                    hr = pTransObj->GetPropertySetter( &pSetter );
                    // can't fail
                    ASSERT( !FAILED( hr ) );
                    
                    // ask for the wrap interface
                    //
                    DEXTER_PARAM_DATA ParamData;
                    ZeroMemory( &ParamData, sizeof( ParamData ) ); // safe
                    ParamData.rtStart = TransStart;
                    ParamData.rtStop = TransStop;
                    ParamData.pSetter = pSetter;
                    ParamData.fSwapInputs = fSwapInputs;
                    hr = pMixEffect->QParamData(
                        TransStart,
                        TransStop,
                        TransGuid,
                        NULL,
                        &ParamData );
                    if( FAILED( hr ) )
                    {
                        // QParamData logs its own errors
                        continue; // transitions
                    }
                    // QParamData logs its own errors
                } // if !IsCompressed
                
                {
                    DbgTimer d( "RowIAmTransitionNow" );

                    // tell the grid about it
                    //
                    worked = VidGrid.RowIAmTransitionNow( TransStart, TransStop, vidswitcheroutpin, vidswitcheroutpin + 1 );
                    if( !worked )
                    {
                        hr = E_OUTOFMEMORY;
                        goto die;
                    }

                    VidGrid.DumpGrid( );
                }
                
            } // for CurTrans
            
            vidswitcheroutpin += 2;
            vidswitcherinpin++;
            gridinpin++;
            
        } // if TransitionCount

        // we must only call DoneWithLayer if we've called WorkWithNewRow above
        // (bUsedNewGridRow) or if we're a composition and some deeper depth
        // called DoneWithLayer.
        // We won't get this far for an emtpy track, so if bUsedNewGridRow is
        // not set, we know we're a comp.
        //
        if ((LastEmbedDepth > LayerEmbedDepth &&
                LastUsedNewGridRow > LayerEmbedDepth) || bUsedNewGridRow) {
            VidGrid.DoneWithLayer( );
            VidGrid.DumpGrid( );
            LastUsedNewGridRow = LayerEmbedDepth; // last layer to call Done
        }

        // remember these previous settings
        LastEmbedDepth = LayerEmbedDepth;

    } // while VideoLayers
    
die:

    DbgTimer ExtraTimer( "(rendeng) Extra Stuff" );
    
    // free the re-using source stuff now that we're either done or we
    // hit an error
    for (int yyy = 0; yyy < cList; yyy++) {
	SysFreeString(pREUSE[yyy].bstrName);
        if (pREUSE[yyy].pMiniSkew)      // failed re-alloc would make this NULL
	    QzTaskMemFree(pREUSE[yyy].pMiniSkew);
    }
    if (pREUSE)
        QzTaskMemFree(pREUSE);
    if (FAILED(hr))
	return hr;


    worked = VidGrid.PruneGrid( );
    if( !worked )
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }
    VidGrid.DumpGrid( );
    
    if( IsCompressed )
    {
        VidGrid.RemoveAnyNonCompatSources( );
    }

#ifdef DEBUG
    long zzz1 = timeGetTime( );
#endif

    // make the switch connections now
    //
    for( int vip = 0 ; vip < vidinpins ; vip++ )
    {
        VidGrid.WorkWithRow( vip );
        long SwitchPin = VidGrid.GetRowSwitchPin( );
        REFERENCE_TIME InOut = -1;
        REFERENCE_TIME Stop = -1;
        int nUsed = 0;	// how many different ranges there are for each BLACK
        STARTSTOPSKEW * pSkew = NULL;
        int nSkew = 0;
        
        if( VidGrid.IsRowTotallyBlank( ) )
        {
            continue;
        }

        if( IsCompressed )
        {
            // if we're compressed, then we need to do some source stuff now.

            // ignore black layers, we don't deal with these in the compressed case
            //
            if( vip < VideoLayers )
            {
                continue;
            }
            
            // find out how many different ranges this layer is going to have. We
            // need to tell the switcher to set up the skews for all the dynamic
            // source information.
            //
            long Count = 0;
            while( 1 )
            {
                long Value = 0;
                VidGrid.RowGetNextRange( &InOut, &Stop, &Value );
                if( InOut == Stop )
                {
                    break;
                }
                if( Value != ROW_PIN_OUTPUT )
                {
                    continue;
                }
                
                Count++;
            }
            
            // create a skew array
            //
            STARTSTOPSKEW * pSkews = new STARTSTOPSKEW[Count];
            if( !pSkews )
            {
                hr = E_OUTOFMEMORY;
                return hr;
            }
            
            InOut = -1;
            Stop = -1;
            Count = 0;
            
            // go through each range and set up the switch's X-Y values for this layer
            //
            while( 1 )
            {
                long Value = 0;
                
                VidGrid.RowGetNextRange( &InOut, &Stop, &Value );
                
                // ah, we're done with all the columns, we can go to the next row (pin)
                //
                if( InOut == Stop || InOut >= TotalDuration )
                {
                    break;
                }
                
                if( Value != ROW_PIN_OUTPUT )
                {
                    hr = m_pSwitcherArray[WhichGroup]->SetX2Y( InOut, SwitchPin, -1 );
                    ASSERT( !FAILED( hr ) );
                    if( FAILED( hr ) )
                    {
                        // must be out of memory
                        return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    }
                    continue;
                }
                
                Value = 0;
                
                // tell the switch to go from x to y at time
                //
                hr= m_pSwitcherArray[WhichGroup]->SetX2Y(InOut, SwitchPin, Value);
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    // must be out of memory
                    return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                }
                
                pSkews[Count].rtStart = InOut;
                pSkews[Count].rtStop = Stop;
                pSkews[Count].rtSkew = 0;
                pSkews[Count].dRate = 1.0;
                Count++;
                
            } // while( 1 ) (columns for row)

            // merge what we can and set up the skews right
            //
            hr = m_pSwitcherArray[WhichGroup]->ReValidateSourceRanges( SwitchPin, Count, pSkews );
            if( FAILED( hr ) )
            {
                return hr;
            }
            
            delete [] pSkews;
        }
        else
        {
            // the row is not compressed. go through each range on the row
            // and find out where it goes to and set up the switch's X-Y array
            //
            while( 1 )
            {
                long Value = 0;
                
                VidGrid.RowGetNextRange( &InOut, &Stop, &Value );
                
                // ah, we're done with all the columns, we can go to the next row (pin)
                //
                if( InOut == Stop || InOut >= TotalDuration )
                {
                    break;
                }
                
                // if this pin wants to go somewhere on the output
                //
                if( Value >= 0 || Value == ROW_PIN_OUTPUT )
                {
                    // if it wants to go to the output pin...
                    //
                    if (Value == ROW_PIN_OUTPUT)
                    {
                        Value = 0;
                    }
                    
                    // do some fancy processing for setting up the black sources, if not compressed
                    //
                    if( vip < VideoLayers )
                    {
                        if( nUsed == 0 ) 
                        {
                            nSkew = 10;	// start with space for 10
                            pSkew = (STARTSTOPSKEW *)CoTaskMemAlloc(nSkew *
                                sizeof(STARTSTOPSKEW));
                            if (pSkew == NULL)
                                return _GenerateError( 1, DEX_IDS_GRAPH_ERROR,	
                                E_OUTOFMEMORY);
                        } else if (nUsed == nSkew) {
                            nSkew += 10;
                            pSkew = (STARTSTOPSKEW *)CoTaskMemRealloc(pSkew, nSkew *
                                sizeof(STARTSTOPSKEW));
                            if (pSkew == NULL)
                                return _GenerateError( 1, DEX_IDS_GRAPH_ERROR,	
                                E_OUTOFMEMORY);
                        }
                        pSkew[nUsed].rtStart = InOut;
                        pSkew[nUsed].rtStop = Stop;
                        pSkew[nUsed].rtSkew = 0;
                        pSkew[nUsed].dRate = 1.0;
                        nUsed++;
                        
                    } // if a black layer
                    
                    // tell the switch to go from x to y at time
                    //
                    hr= m_pSwitcherArray[WhichGroup]->SetX2Y(InOut, SwitchPin, Value);
                    ASSERT( !FAILED( hr ) );
                    if( FAILED( hr ) )
                    {
                        // must be out of memory
                        return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    }
                    
                } // the pin wanted to go somewhere on the output
                
                // either it's unassigned or another track has higher priority and
                // no transition exists at this time, so it should be invisible
                //
                else if( Value == ROW_PIN_UNASSIGNED || Value < ROW_PIN_OUTPUT )
                {
                    // make sure not to program anything if this is a black source
                    // that is about to be removed, or programmed later, or the
                    // switch won't work
                    if (SwitchPin >= VideoLayers || nUsed)
                    {
                        hr = m_pSwitcherArray[WhichGroup]->SetX2Y( InOut, SwitchPin,
                            ROW_PIN_UNASSIGNED );
                        ASSERT( !FAILED( hr ) );
                        if( FAILED( hr ) )
                        {
                            // must be out of memory
                            return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                        }
                    }
                }
                
                // this should never happen
                //
                else
                {
                    ASSERT( 0 );
                }
                
            } // while( 1 ) (columns for row)
        } // if !Compressed
        
        // if compressed, the above logic forces nUsed to be 0, so the below
        // code doesn't execute
        
        // Process the black sources now, since we forgot before
        
        // No dynamic sources, make the black source now
        //
        if( !( DynaFlags & CONNECTF_DYNAMIC_SOURCES ) ) {
            
            if (nUsed) {
                IPin * pOutPin = NULL;
                hr = BuildSourcePart(
                    m_pGraph, 
                    FALSE, 
                    0, 
                    pGroupMediaType, 
                    GroupFPS, 
                    0, 
                    0, 
                    nUsed, 
                    pSkew, 
                    this, 
                    NULL, 
                    NULL,
		    NULL,
                    &pOutPin, 
                    0, 
                    m_pDeadCache,
                    IsCompressed,
                    m_MedLocFilterString,
                    m_nMedLocFlags,
                    m_pMedLocChain, NULL, NULL );
                
                CoTaskMemFree(pSkew);
                
                if (FAILED(hr)) {
                    // error was already logged
                    return hr;
                }
                
                pOutPin->Release(); // not the last ref
                
                CComPtr< IPin > pSwitchIn;
                _pVidSwitcherBase->GetInputPin( SwitchPin, &pSwitchIn);
                if( !pSwitchIn )
                {
                    ASSERT(FALSE);
                    return _GenerateError(1,DEX_IDS_GRAPH_ERROR,E_OUTOFMEMORY);
                }
                
                hr = _Connect( pOutPin, pSwitchIn );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                }
                
                // tell the switcher that we're a source pin
                //
                hr = m_pSwitcherArray[WhichGroup]->InputIsASource(SwitchPin,TRUE);
                
            }
            
            // DYNAMIC sources, make the source later
            //
        } else {
            if (nUsed) {
                // this will merge skews
                AM_MEDIA_TYPE mt;
                ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE)); // safe
                hr = m_pSwitcherArray[WhichGroup]->AddSourceToConnect(
                    NULL, &GUID_NULL,
                    0, 0, 0,
                    nUsed, pSkew, SwitchPin, FALSE, 0, mt, 0.0, NULL);
                CoTaskMemFree(pSkew);
                if (FAILED(hr))	// out of memory?
                    return _GenerateError( 1, DEX_IDS_INSTALL_PROBLEM, hr );
                
                // tell the switcher that we're a source pin
                //
                hr = m_pSwitcherArray[WhichGroup]->InputIsASource(SwitchPin,TRUE);
                
            }
        }
    } // for vip (video input pin)
    
    // finally, at long last, see if the switch used to have something connected
    // to it. If it did, restore the connection
    // !!! this might fail if we're using 3rd party  filters which don't
    // accept input pin reconnections if the output pin is already connected.\
    // if this happens, we might have to write some clever connect function that
    // deals with this scenario.
    //
    if( m_pSwitchOuttie[WhichGroup] )
    {
        CComPtr< IPin > pSwitchRenderPin;
        _pVidSwitcherBase->GetOutputPin( 0, &pSwitchRenderPin );
        hr = _Connect( pSwitchRenderPin, m_pSwitchOuttie[WhichGroup] );
        ASSERT( !FAILED( hr ) );
        m_pSwitchOuttie[WhichGroup].Release( );
    }

#ifdef DEBUG
    zzz1 = timeGetTime( ) - zzz1;
    DbgLog( ( LOG_TIMING, 1, "RENDENG::Took %ld to process switch X-Y hookups", zzz1 ) );
#endif

    m_nGroupsAdded++;
    
    return hr;
}


// little helper function in DXT.cpp
//
extern HRESULT VariantFromGuid(VARIANT *pVar, BSTR *pbstr, GUID *pGuid);

//############################################################################
// 
//############################################################################

HRESULT CRenderEngine::_AddAudioGroupFromTimeline( long WhichGroup, AM_MEDIA_TYPE * pGroupMediaType )
{
    HRESULT hr = 0;
    
    // ask for how many sources we have total
    //
    long Dummy = 0;
    long AudioSourceCount = 0;
    m_pTimeline->GetCountOfType( WhichGroup, &AudioSourceCount, &Dummy, TIMELINE_MAJOR_TYPE_SOURCE );
    
    // if this group has nothing in it, we'll product audio silence
    //
    if( AudioSourceCount < 1 )
    {
        //        return NOERROR;
    }
    
    // are we allowed to have effects on the timeline right now?
    //
    BOOL EnableFx = FALSE;
    m_pTimeline->EffectsEnabled( &EnableFx );
    
    // ask for how many effects we have total
    //
    Dummy = 0;
    long EffectCount = 0;
    m_pTimeline->GetCountOfType( WhichGroup, &EffectCount, &Dummy, TIMELINE_MAJOR_TYPE_EFFECT );
    if( !EnableFx )
    {
        EffectCount = 0;
    }
    
    CComPtr< IAMTimelineObj > pGroupObj;
    hr = m_pTimeline->GetGroup( &pGroupObj, WhichGroup );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        return _GenerateError( 2, DEX_IDS_TIMELINE_PARSE, hr );
    }

    long SwitchID = 0;
    pGroupObj->GetGenID( &SwitchID );
    
    hr = _CreateObject(
        CLSID_BigSwitch,
        IID_IBigSwitcher,
        (void**) &m_pSwitcherArray[WhichGroup],
        SwitchID );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        return _GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
    }
    
    m_pSwitcherArray[WhichGroup]->Reset( );
    // the switch may need to know what group it is
    m_pSwitcherArray[WhichGroup]->SetGroupNumber( WhichGroup );

    // tell the switch if we're doing dynamic reconnections or not
    hr = m_pSwitcherArray[WhichGroup]->SetDynamicReconnectLevel(m_nDynaFlags);
    ASSERT(SUCCEEDED(hr));
    
    // tell the switch about our error log
    //
    CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pSwitchLog( m_pSwitcherArray[WhichGroup] );
    if( pSwitchLog )
    {
        pSwitchLog->put_ErrorLog( m_pErrorLog );
    }
    
    // ask timeline how many actual tracks it has
    //
    long AudioTrackCount = 0;   // tracks only
    long AudioLayers = 0;       // tracks including compositions
    m_pTimeline->GetCountOfType( WhichGroup, &AudioTrackCount, &AudioLayers, TIMELINE_MAJOR_TYPE_TRACK );
    
    CTimingGrid AudGrid;
    
    CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pGroupComp( pGroupObj );
    if( !pGroupComp )
    {
        hr = E_NOINTERFACE;
        return _GenerateError( 2, DEX_IDS_INTERFACE_ERROR, hr );
    }
    CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( pGroupObj );
    if( !pGroup )
    {
        hr = E_NOINTERFACE;
        return _GenerateError( 2, DEX_IDS_INTERFACE_ERROR, hr );
    }
    
    // ask for this group's frame rate, so we can tell switch about it
    //
    double GroupFPS = DEFAULT_FPS;
    hr = pGroup->GetOutputFPS(&GroupFPS);
    ASSERT(hr == S_OK);
    
    // aks it for it's preview mode, so we can tell switch about it
    //
    BOOL fPreview;
    hr = pGroup->GetPreviewMode(&fPreview);
    
    WCHAR GroupName[256];
    BSTR bstrGroupName;
    hr = pGroup->GetGroupName( &bstrGroupName );
    if( FAILED( hr ) )
    {
        return E_OUTOFMEMORY;
    }
    hr = StringCchCopy( GroupName, 256, bstrGroupName );
    if( FAILED( hr ) )
    {
        return hr;
    }
    SysFreeString( bstrGroupName );
    
    // add the switch to the graph
    //
    IBigSwitcher *&_pAudSwitcherBase = m_pSwitcherArray[WhichGroup];
    CComQIPtr< IBaseFilter, &IID_IBaseFilter > pAudSwitcherBase( _pAudSwitcherBase );
    hr = _AddFilter( pAudSwitcherBase, GroupName, SwitchID );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
    }
    
    // find out if the switch output pin is connected. If it is,
    // disconnect it, but remember what it was connected to
    //
    CComPtr< IPin > pSwitchRenderPin;
    _pAudSwitcherBase->GetOutputPin( 0, &pSwitchRenderPin );
    if( pSwitchRenderPin )
    {
        pSwitchRenderPin->ConnectedTo( &m_pSwitchOuttie[WhichGroup] );
        if( m_pSwitchOuttie[WhichGroup] )
        {
            m_pSwitchOuttie[WhichGroup]->Disconnect( );
            pSwitchRenderPin->Disconnect( );
        }
    }

    long audoutpins = 0;
    audoutpins += 1;            // rendering pin
    audoutpins += EffectCount;  // one output pin per effect
    audoutpins += AudioLayers;  // one output pin per layer, this includes tracks and comps
    audoutpins += _HowManyMixerOutputs( WhichGroup );   
    long audinpins = audoutpins + AudioSourceCount;
    long audswitcheroutpin = 0;
    long audswitcherinpin = 0;
    long gridinpin = 0;
    audswitcheroutpin++;
    
    audinpins += AudioTrackCount;                      // account for black sources
    
    // set the switch's pin depths, in and out
    //
    hr = m_pSwitcherArray[WhichGroup]->SetInputDepth( audinpins );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        // must be out of memory
        return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
    }
    hr = m_pSwitcherArray[WhichGroup]->SetOutputDepth( audoutpins );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        // must be out of memory
        return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
    }
    
    // set the media type it accepts
    //
    hr = m_pSwitcherArray[WhichGroup]->SetMediaType( pGroupMediaType );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        VARIANT var;
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = WhichGroup;
        return _GenerateError( 2, DEX_IDS_BAD_MEDIATYPE, hr, &var );
    }
    
    // set the frame rate
    //
    m_pSwitcherArray[WhichGroup]->SetFrameRate( GroupFPS );
    ASSERT( !FAILED( hr ) );
    
    // set the preview mode
    //
    hr = m_pSwitcherArray[WhichGroup]->SetPreviewMode( fPreview );
    ASSERT( !FAILED( hr ) );
    
    // set the duration
    //
    REFERENCE_TIME TotalDuration = 0;
    m_pTimeline->GetDuration( &TotalDuration );
    
    if( m_rtRenderStart != -1 )
    {
        if( TotalDuration > ( m_rtRenderStop - m_rtRenderStart ) )
        {
            TotalDuration = m_rtRenderStop - m_rtRenderStart;
        }
    }
    pGroupObj->FixTimes( NULL, &TotalDuration );

    if (TotalDuration == 0)
        return S_FALSE; // don't abort, other groups might still work

    hr = m_pSwitcherArray[WhichGroup]->SetProjectLength( TotalDuration );
    ASSERT( !FAILED( hr ) );
    
    bool worked = AudGrid.SetNumberOfRows( audinpins + 1 );
    if( !worked )
    {
        hr = E_OUTOFMEMORY;
        return _GenerateError( 2, DEX_IDS_GRID_ERROR, hr );
    }
    
    // there is a virtual silence track as the first track... any real
    // tracks with transparent holes in them will make you hear this
    // silence.
    
    // tell the grid about the silent row... it's a special row that is
    // never supposed to be mixed with anything 
    // so use -1.
    //
    AudGrid.WorkWithNewRow( audswitcherinpin, gridinpin, -1, 0 );
    worked = AudGrid.RowIAmOutputNow( 0, TotalDuration, THE_OUTPUT_PIN );
    if( !worked )
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }
    
    audswitcherinpin++;
    gridinpin++;
    
    // we are going to be clever, and if the same source is used
    // more than once in a project, we'll use the same source filter
    // instead of opening the source several times.
	
    // for each source in the project, we'll fill in this structure, which
    // contains everything necessary to determine if it's really exactly the
    // same, plus an array of all the times it's used in other places, so we
    // can re-use it only if none of the times it is used overlap (we can't
    // very well have one source filter giving 2 spots in the same movie at
    // the same time, can we?)

    typedef struct {
	long ID;
   	BSTR bstrName;
   	GUID guid;
   	long nStreamNum;
	int nPin;
	int cTimes;	// how big the following array is
        int cTimesMax;	// how much space is allocated
        MINI_SKEW * pMiniSkew;
        double dTimelineRate;
    } DEX_REUSE;

    // make a place to hold an array of names and guids (of the sources
    // in this project) and which pin they are on
    long cListMax = 20, cList = 0;
    DEX_REUSE *pREUSE = (DEX_REUSE *)QzTaskMemAlloc(cListMax *
						sizeof(DEX_REUSE));
    if (pREUSE == NULL) {
        return _GenerateError( 1, DEX_IDS_GRAPH_ERROR, E_OUTOFMEMORY);
    }

    // which physical track are we on in our enumeration? (0-based) not counting
    // comps and the group
    int WhichTrack = -1;

    long LastEmbedDepth = 0;
    long LastUsedNewGridRow = 0;

    // add source filters for each source on the timeline
    //
    for(  int CurrentLayer = 0 ; CurrentLayer < AudioLayers ; CurrentLayer++ )
    {
        DbgTimer CurrentLayerTimer( "(rendeng) Audio Layer" );

        // get the layer itself
        //
        CComPtr< IAMTimelineObj > pLayer;
	// NB: This function enumerates things inside out... tracks, then
	// the comp they're in, etc. until finally returning the group
	// It's NOT only giving real tracks!
        hr = pGroupComp->GetRecursiveLayerOfType( &pLayer, CurrentLayer, TIMELINE_MAJOR_TYPE_TRACK );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            continue; // audio layers
        }
        
        DbgTimer CurrentLayerTimer2( "(rendeng) Audio Layer 2" );

	// I'm figuring out which physical track we're on
	TIMELINE_MAJOR_TYPE tx;
	pLayer->GetTimelineType(&tx);
	if (tx == TIMELINE_MAJOR_TYPE_TRACK)
	    WhichTrack++;

        // ask if the layer is muted
        //
        BOOL LayerMuted = FALSE;
        pLayer->GetMuted( &LayerMuted );
        if( LayerMuted )
        {
            // don't look at this layer
            //
            continue; // audio layers
        }
        
        long TrackPriority = 0;
        CComQIPtr< IAMTimelineVirtualTrack, &IID_IAMTimelineVirtualTrack > pVTrack( pLayer );
        if( pVTrack )
        {
            pVTrack->TrackGetPriority( &TrackPriority );
        }
        
        DbgTimer CurrentLayerTimer3( "(rendeng) Audio Layer 3" );
        
        long LayerEmbedDepth = 0;
        pLayer->GetEmbedDepth( &LayerEmbedDepth );
        
        CComQIPtr< IAMTimelineTrack, &IID_IAMTimelineTrack > pTrack( pLayer );
        
        bool bUsedNewGridRow = false;

        // get all the sources for this layer
        //
	if ( pTrack )
        {
            CComPtr< IAMTimelineObj > pSourceLast;
            CComPtr< IAMTimelineObj > pSourceObj;

	    // which source are we on?
	    int WhichSource = -1;

            while( 1 )
            {
                DbgTimer CurrentSourceTimer( "(rendeng) Audio Source" );

                pSourceLast = pSourceObj;
                pSourceObj.Release();

                // get the next source on this layer, given a time.
                //
                hr = pTrack->GetNextSrcEx( pSourceLast, &pSourceObj );

                // ran out of sources, so we're done
                //
                if( hr != NOERROR )
                {
                    break;
                }
                
                CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSource( pSourceObj );
                ASSERT( pSource );
                if( !pSource )
                {
                    // this one bombed, look at the next
                    //
                    continue; // sources
                }
                
		// keeping track of which source this is
		WhichSource++;

                // ask if the source is muted
                //
                BOOL SourceMuted = FALSE;
                pSourceObj->GetMuted( &SourceMuted );
                if( SourceMuted )
                {
                    // don't look at this source
                    //
                    continue; // sources
                }
                
                // ask this source for it's start/stop times
                //
                REFERENCE_TIME SourceStart = 0;
                REFERENCE_TIME SourceStop = 0;
                hr = pSourceObj->GetStartStop( &SourceStart, &SourceStop );
		REFERENCE_TIME SourceStartOrig = SourceStart;
		REFERENCE_TIME SourceStopOrig = SourceStop;
                ASSERT( !FAILED( hr ) );
                if (FAILED(hr) || SourceStart == SourceStop) {
                    // this source exists for zero time!
                    continue;
                }
                
                long SourceID = 0;
                pSourceObj->GetGenID( &SourceID );
                
                // ask this source for it's media start/stops
                //
                REFERENCE_TIME MediaStart = 0;
                REFERENCE_TIME MediaStop = 0;
                hr = pSource->GetMediaTimes( &MediaStart, &MediaStop );
		REFERENCE_TIME MediaStartOrig = MediaStart;
		REFERENCE_TIME MediaStopOrig = MediaStop;
                ASSERT( !FAILED( hr ) );
                
                // !!! Not sure the right way to handle sources with no media times
                // So the AUDPACK doesn't mess up, we'll make MTime = TLTime
                if (MediaStart == MediaStop) {
                    MediaStop = MediaStart + (SourceStop - SourceStart);
                }
                
                // if this is out of our render range, then skip it
                //
                if( m_rtRenderStart != -1 )
                {
                    SourceStart -= m_rtRenderStart;
                    SourceStop -= m_rtRenderStart;

                    if( ( SourceStop <= 0 ) || SourceStart >= ( m_rtRenderStop - m_rtRenderStart ) )
                    {
                        continue; // while sources
                    }
                }
                
                ValidateTimes( SourceStart, SourceStop, MediaStart, MediaStop, GroupFPS, TotalDuration );
                
                if(SourceStart == SourceStop)
                {
                    // source combining, among other things, will mess up if
                    // we try and play something for 0 length.  ignore this.
                    //
                    continue; // sources
                }

                // ask the source which stream number it wants to provide, since it
                // may be one of many
                //
                long StreamNumber = 0;
                hr = pSource->GetStreamNumber( &StreamNumber );
                
                CComBSTR bstrName;
                hr = pSource->GetMediaName( &bstrName );
                if( FAILED( hr ) )
                {
                    goto die;
                }
                GUID guid;
                hr = pSourceObj->GetSubObjectGUID(&guid);
                double sfps;
                hr = pSource->GetDefaultFPS( &sfps );
                ASSERT(hr == S_OK); // can't fail, really
                
                STARTSTOPSKEW skew;
                skew.rtStart = MediaStart;
                skew.rtStop = MediaStop;
                skew.rtSkew = SourceStart - MediaStart;
                
	    // !!! rate calculation appears in several places
            if (MediaStop == MediaStart || SourceStop == SourceStart)
	        skew.dRate = 1;
            else
	        skew.dRate = (double) ( MediaStop - MediaStart ) /
					( SourceStop - SourceStart );

    	    DbgLog((LOG_TRACE,1,TEXT("RENDENG::Working with source")));
    	    DbgLog((LOG_TRACE,1,TEXT("%ls"), (WCHAR *)bstrName));

	    // get the props for the source
            CComPtr< IPropertySetter > pSetter;
            hr = pSourceObj->GetPropertySetter(&pSetter);

	    // in the spirit of using only 1 source filter for
	    // both the video and the audio of a file, if both
	    // are needed, let's see if we have another group
	    // with the same piece of this file but with another
	    // media type
	    long MatchID = 0;
	    IPin *pSplit, *pSharePin = NULL;
	    BOOL fShareSource = FALSE;
            int nSwitch0InPin;
            // in smart recomp, we don't know what video pieces are needed,
            // they may not match the audio pieces needed, so source sharing
            // will NEVER WORK.  Don't try it
	    if (WhichGroup == 0 && !m_bUsedInSmartRecompression) {
		// I don't make sure the matching source isn't muted, etc.
		hr = _FindMatchingSource(bstrName, SourceStartOrig,
			    SourceStopOrig, MediaStartOrig, MediaStopOrig,
			    WhichGroup, WhichTrack, WhichSource,
			    pGroupMediaType, GroupFPS, &MatchID);
    		DbgLog((LOG_TRACE,1,TEXT("GenID %d matches with ID %d"),
						SourceID, MatchID));
	    } else if (WhichGroup == 1 && !m_bUsedInSmartRecompression) {
		for (int zyz = 0; zyz < m_cshare; zyz++) {
		    if (SourceID == m_share[zyz].MatchID) {
			fShareSource = SHARE_SOURCES;
                        // the split pin we're to build from
			pSharePin = m_share[zyz].pPin;
                        // group 0's switch inpin used for the shared source
			nSwitch0InPin = m_share[zyz].nSwitch0InPin;
                        // OK, we have a split pin, but not necessarily the
                        // right one, if we're using a special stream #
                        // We need the right one or BuildSourcePart's
                        // caching won't work
                        if (StreamNumber > 0 && pSharePin) {
                            // not addreffed or released
                            pSharePin = FindOtherSplitterPin(pSharePin, MEDIATYPE_Audio,
                                StreamNumber);
                        }
			// it's a dangly bit we are using
			_RemoveFromDanglyList(pSharePin);
    		    	DbgLog((LOG_TRACE,1,TEXT("GenID %d matches with ID %d"),
					SourceID, m_share[zyz].MatchID));
    			DbgLog((LOG_TRACE,1,TEXT("Time to SHARE source!")));
			break;
		    }
		}
	    }

	    // if a source has properties, do NOT share it with anybody, that
	    // other guy will unwittingly get my properties!
	    if (pSetter) {
		MatchID = 0;
		fShareSource = FALSE;
	    }

	    // If this source has been used before, and all the important
	    // parameters are the same, and the times don't overlap, then
	    // just re-use it using the same source filter we already made
	    // for it.

	    BOOL fCanReuse = FALSE;
            int nGrow;
            long SwitchInPinToUse = audswitcherinpin;
	    int xxx;

	    // go through all the sources in the project looking for a match
	    for (xxx = 0; xxx < cList; xxx++) {

	        // if a source has properties, do NOT re-use it, that
	        // other guy will unwittingly get my properties!
		if (pSetter) {
		    break;
		}

		// !!! Full path/no path will look different but won't be!
		if (!DexCompareW(pREUSE[xxx].bstrName, bstrName) && // since bstrName is good, and reuse bstrName is good, safe
			pREUSE[xxx].guid == guid &&
			pREUSE[xxx].nStreamNum == StreamNumber) {

		    // we found this source already in use.  But do the 
		    // different times it's needed overlap?
	    	    fCanReuse = TRUE;
                    nGrow = -1;

		    for (int yyy = 0; yyy < pREUSE[xxx].cTimes; yyy++) {
			// Here's the deal.  Re-using a file needs to seek
			// the file to the new spot, which must take < 1/30s
			// or it will interrupt playback.  If there are few
			// keyframes (ASF) this will take hours.  We cannot
			// re-use sources if they are consecutive.  Open it
			// twice, it'll play better avoiding the seek, and ping
			// pong between the 2 sources every other source.

                        double Rate1 = double( MediaStop - MediaStart ) / double( SourceStop - SourceStart );
                        double Rate2 = pREUSE[xxx].dTimelineRate;
                        REFERENCE_TIME OldMediaStop = pREUSE[xxx].pMiniSkew[yyy].rtMediaStop;
                        if( AreTimesAndRateReallyClose( 
                            pREUSE[xxx].pMiniSkew[yyy].rtStop, SourceStart, 
                            OldMediaStop, MediaStart, 
                            Rate1, Rate2, GroupFPS ) )
                        {
                            nGrow = yyy;
                            skew.dRate = 0.0;
    			    DbgLog((LOG_TRACE,1,TEXT("COMBINING with a previous source")));
                            break;
                        }

                        // if the start is really close to the reuse stop,
                        // and the rates are the same, we can combine them
                        //
			if (SourceStart < pREUSE[xxx].pMiniSkew[yyy].rtStop + HACKY_PADDING &&
				SourceStop > pREUSE[xxx].pMiniSkew[yyy].rtStart) {
        			fCanReuse = FALSE;
        			break;
			}
		    }
		    if (fCanReuse)
			break;
		}
	    }

            // Actually, we CAN'T re-use, if we're re-using a guy that is
            // sharing a parser... that would be both REUSE and SHARE, which,
            // as explained elsewhere, is illegal.
            if (WhichGroup == 1) {
                for (int zz = 0; zz < m_cshare; zz++) {
                    if (m_share[zz].MatchID == pREUSE[xxx].ID) {
                        fCanReuse = FALSE;
                    }
                }
            }

	    // We are re-using a previous source!  Add the times it is being
	    // used for this segment to the list of times it is used
	    if (fCanReuse) {

		// this is the pin the old source is coming in on
		SwitchInPinToUse = pREUSE[xxx].nPin;
            	DbgLog((LOG_TRACE,1,TEXT("Row %d REUSE source from pin %ld")
						, gridinpin, SwitchInPinToUse));

                if( nGrow == -1 )
                {
		    // need to grow the array first?
	            if (pREUSE[xxx].cTimes == pREUSE[xxx].cTimesMax) {
		        pREUSE[xxx].cTimesMax += 10;
	                pREUSE[xxx].pMiniSkew = (MINI_SKEW*)QzTaskMemRealloc(
			    	    pREUSE[xxx].pMiniSkew,
				    pREUSE[xxx].cTimesMax * sizeof(MINI_SKEW));
	                if (pREUSE[xxx].pMiniSkew == NULL)
		            goto die;
	            }
		    pREUSE[xxx].pMiniSkew[pREUSE[xxx].cTimes].rtStart = SourceStart;
		    pREUSE[xxx].pMiniSkew[pREUSE[xxx].cTimes].rtStop = SourceStop;
		    pREUSE[xxx].pMiniSkew[pREUSE[xxx].cTimes].rtMediaStop = MediaStop;
		    pREUSE[xxx].cTimes++;
                }
                else
                {
                    // We MUST grow by a whole number of frame intervals.
                    // All these numbers be rounded to frame lengths, or things
                    // can screw up.  The timeline and media lengths are
                    // already an even # of frame lengths, so adding that much
                    // should be safe.
		    pREUSE[xxx].pMiniSkew[nGrow].rtStop += SourceStop -
                                                                SourceStart;
                    pREUSE[xxx].pMiniSkew[nGrow].rtMediaStop += MediaStop -
                                                                MediaStart;
                }

		// if we were about to re-use an old parser, DON'T!
    		DbgLog((LOG_TRACE,1,TEXT("Re-using, can't share!")));

		// you CANNOT both share a source and re-use. It will never
		// work.  Don't even try. (When one branch finishes a segment
		// and seeks upstream, it will kill the other branch)
                // (source combining is OK... that's not really re-using)
		// RE-USING can improve perf n-1, sharing only 2-1, so I pick
		// RE-USING to win out.

		// take the guy we're re-using from out of the race for possible
		// source re-usal
                if (WhichGroup == 0) {
                    for (int zz = 0; zz < m_cshare; zz++) {
                        if (m_share[zz].MyID == pREUSE[xxx].ID) {
                            m_share[zz].MatchID = 0;
                        }
                    }
                }
		fShareSource = FALSE;
		MatchID = 0;

	    // We are NOT re-using this source.  Put this new source on the
	    // list of unique sources to possibly be re-used later
	    //
	    } else {
	        pREUSE[cList].ID = SourceID;	// for sharing a source filter
	        pREUSE[cList].bstrName = SysAllocString(bstrName); // safe
	        if (pREUSE[cList].bstrName == NULL)
		    goto die;
	        pREUSE[cList].guid = guid;
	        pREUSE[cList].nPin = SwitchInPinToUse;
	        pREUSE[cList].nStreamNum = StreamNumber;
	        pREUSE[cList].cTimesMax = 10;
	        pREUSE[cList].cTimes = 0;
                // we only need to set this once, since all others must match it
                pREUSE[cList].dTimelineRate = double( MediaStop - MediaStart ) / double( SourceStop - SourceStart );
	        pREUSE[cList].pMiniSkew = (MINI_SKEW*)QzTaskMemAlloc(
			    pREUSE[cList].cTimesMax * sizeof(MINI_SKEW));
	        if (pREUSE[cList].pMiniSkew == NULL) {
                    SysFreeString(pREUSE[cList].bstrName);
                    pREUSE[cList].bstrName = NULL;
		    goto die;
                }
	        pREUSE[cList].cTimes = 1;
	        pREUSE[cList].pMiniSkew->rtStart = SourceStart;
	        pREUSE[cList].pMiniSkew->rtStop = SourceStop;
	        pREUSE[cList].pMiniSkew->rtMediaStop = MediaStop;

		// grow the list if necessary
	        cList++;
	        if (cList == cListMax) {
		    cListMax += 20;
		    DEX_REUSE *pxxx = (DEX_REUSE *)QzTaskMemRealloc(pREUSE,
                                        cListMax * sizeof(DEX_REUSE));
		    if (pxxx == NULL)
		        goto die;
                    pREUSE = pxxx;
	        }
	    }

            // tell the grid about it
            //
            bUsedNewGridRow = true;
            AudGrid.WorkWithNewRow( SwitchInPinToUse, gridinpin, LayerEmbedDepth, TrackPriority );
            AudGrid.RowSetIsSource( pSourceObj, FALSE );
            worked = AudGrid.RowIAmOutputNow( SourceStart, SourceStop, THE_OUTPUT_PIN );
            if( !worked )
            {
                hr = E_OUTOFMEMORY;
                goto die;
            }

	    // no dynamic sources - load it now if it's not being re-used
	    //
	    if( !( m_nDynaFlags & CONNECTF_DYNAMIC_SOURCES ) )
	    {

		// We are not re-using a previous source, make the source now
		if( !fCanReuse ) 
                {
	            CComPtr< IPin > pOutput;
        	    DbgLog((LOG_TRACE,1,TEXT("Call BuildSourcePart")));

		    IBaseFilter *pDangly = NULL;
                    hr = BuildSourcePart(
                        m_pGraph, 
                        TRUE, 
                        sfps, 
                        pGroupMediaType,
		        GroupFPS, 
                        StreamNumber, 
                        0, 
                        1, 
                        &skew,
		        this, 
                        bstrName, 
                        &guid,
			pSharePin,	// splitter pin is our source?
			&pOutput,
			SourceID,
			m_pDeadCache,
			FALSE,
			m_MedLocFilterString,
			m_nMedLocFlags,
			m_pMedLocChain,
		        pSetter, &pDangly);

                    if (FAILED(hr)) {
                        // error was already logged
                        goto die;
                    }

		    // We built more than we bargained for. We have
		    // an appendage that we need to kill later if it
		    // isn't used
		    if (pDangly) {
			m_pdangly[m_cdangly] = pDangly;
			m_cdangly++;
			if (m_cdangly == m_cdanglyMax) {
			    m_cdanglyMax += 25;
			    m_pdangly = (IBaseFilter **)CoTaskMemRealloc
				(m_pdangly,
				m_cdanglyMax * sizeof(IBaseFilter *));
			    if (m_pdangly == NULL) {
                                // !!! leaves things dangling (no leak)
				hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,
						    E_OUTOFMEMORY);
                                m_cdangly = 0;
				goto die;
			    }
			}
		    }

                        CComPtr< IPin > pSwitchIn;
                        _pAudSwitcherBase->GetInputPin( SwitchInPinToUse, &pSwitchIn);
                        ASSERT( pSwitchIn );
                        if( !pSwitchIn )
                        {
                            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                            goto die;
                        }
                        
                        hr = _Connect( pOutput, pSwitchIn );
                        ASSERT( !FAILED( hr ) );
                        if( FAILED( hr ) )
                        {
                            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                            goto die;
                        }

                        // If we are going to use this source for both audio
                        // and video, get an unused split pin of the right
                        // type as a good place to start the other chain
			if (MatchID) {
			    GUID guid = MEDIATYPE_Video;
			    pSplit = FindOtherSplitterPin(pOutput, guid,0);
			    if (!pSplit) {
				MatchID = 0;
			    }
			}

                // we ARE re-using a previous source. Add the new range
                } else {
    			DbgLog((LOG_TRACE,1,TEXT("Adding another skew..")));

                        CComPtr< IPin > pPin;
                        _pAudSwitcherBase->GetInputPin( SwitchInPinToUse, &pPin);
                        ASSERT( pPin);
                        if( !pPin )
                        {
                            hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,E_OUTOFMEMORY);
                            goto die;
                        }
                        IPin * pCon;
                        hr = pPin->ConnectedTo(&pCon);
                        ASSERT(hr == S_OK);
                        pCon->Release( );
                        IBaseFilter *pFil = GetFilterFromPin(pCon);
                        ASSERT( pFil);
                        if( !pFil )
                        {
                            hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,E_OUTOFMEMORY);
                            goto die;
                        }
                        CComQIPtr<IDexterSequencer, &IID_IDexterSequencer>
                            pDex( pFil );
                        ASSERT(pDex);
                        if( !pDex )
                        {
                            hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,E_OUTOFMEMORY);
                            goto die;
                        }
                        hr = pDex->AddStartStopSkew(skew.rtStart, skew.rtStop,
                            skew.rtSkew, skew.dRate);
                        ASSERT(SUCCEEDED(hr));
                        if(FAILED(hr))
                        {
                            hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,hr);
                            goto die;
			}

                        // If we are going to use this source for both audio
                        // and video, get an unused split pin of the right
                        // type as a good place to start the other chain
			if (MatchID) {
			    ASSERT(FALSE);	// can't do both!
			    GUID guid = MEDIATYPE_Video;
			    pSplit = FindOtherSplitterPin(pCon, guid,0);
			    if (!pSplit) {
			        MatchID = 0;
			    }
			}

		}

		// remember which source we are going to use on the
		// other splitter pin
		if (MatchID) {
		    m_share[m_cshare].MatchID = MatchID;
		    m_share[m_cshare].MyID = SourceID;
		    m_share[m_cshare].pPin = pSplit;
                    // remember what inpin group 0's switch used for this src
		    m_share[m_cshare].nSwitch0InPin = SwitchInPinToUse;
		    m_cshare++;
		    if (m_cshare == m_cshareMax) {
			m_cshareMax += 25;
			m_share = (ShareAV *)CoTaskMemRealloc(m_share,
						m_cshareMax * sizeof(ShareAV));
			if (m_share == NULL) {
                            hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,
							E_OUTOFMEMORY);
                            goto die;
			}
		    }
		}

	    // DYNAMIC sources - load them later
	    //
	    }
	    else
	    {
    		DbgLog((LOG_TRACE,1,TEXT("Calling AddSourceToConnect")));

                // schedule this source to be dynamically loaded by the switcher
                // at a later time, this will merge skews
                AM_MEDIA_TYPE mt;
                ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE)); // safe

                if (!fShareSource || WhichGroup != 1) {
                    // Normal case - we are not a shared appendage
                    hr = m_pSwitcherArray[WhichGroup]->AddSourceToConnect(
							bstrName,
							&guid,
							0, StreamNumber, 0,
                                                        1, &skew,
                                                        SwitchInPinToUse,
                                                        FALSE, 0, mt, 0.0,
							pSetter);
                } else {
                    // We are a shared appendage.  Tell the group 0 
                    // switch about this source, which will build and
                    // destroy both chains to both switches at the same
                    // time.
                    ASSERT(WhichGroup == 1);
                    DbgLog((LOG_TRACE,1,TEXT("SHARING: Giving switch 0 info about switch 1")));
                    hr = m_pSwitcherArray[0]->AddSourceToConnect(
                        bstrName,
                        &guid, 0,
                        StreamNumber, 0,
                        1, &skew,
                        nSwitch0InPin,          // group 0's switch in pin
                        TRUE, SwitchInPinToUse, // our switch's pin
                        *pGroupMediaType, GroupFPS,
                        pSetter);
                }

	        if (FAILED(hr)) {
                    hr = _GenerateError( 1, DEX_IDS_INSTALL_PROBLEM, hr );
		    goto die;
	        }

                // remember which source we are going to use on the
                // other splitter pin
                if (MatchID) {
                    m_share[m_cshare].MatchID = MatchID;
                    m_share[m_cshare].MyID = SourceID;
                    m_share[m_cshare].pPin = NULL; // don't have this
                    // remember which group 0 switch in pin was used
                    m_share[m_cshare].nSwitch0InPin = SwitchInPinToUse;
                    m_cshare++;
                    if (m_cshare == m_cshareMax) {
                        m_cshareMax += 25;
                        m_share = (ShareAV *)CoTaskMemRealloc(m_share,
                                        m_cshareMax * sizeof(ShareAV));
                        if (m_share == NULL) {
                            hr =_GenerateError(2,DEX_IDS_GRAPH_ERROR,
                                                E_OUTOFMEMORY);
                            goto die;
                        }
                    }
                }

	    }

            // tell the switcher about input pins
            //
            hr = m_pSwitcherArray[WhichGroup]->InputIsASource( SwitchInPinToUse, TRUE );

            gridinpin++;
            if( !fCanReuse )
            {
                audswitcherinpin++;
            }

            // check and see if we have source effects
            //
            CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pSourceEffectable( pSource );
            long SourceEffectCount = 0;
            long SourceEffectInPin = 0;
            long SourceEffectOutPin = 0;
            CComPtr< IAMMixEffect > pSourceMixEffect;
            if( pSourceEffectable )
            {
                pSourceEffectable->EffectGetCount( &SourceEffectCount );
            }

            if( !EnableFx )
            {
                SourceEffectCount = 0;
            }

            if( SourceEffectCount )
            {
                // store these
                //
                SourceEffectInPin = audswitcherinpin;
                SourceEffectOutPin = audswitcheroutpin;
                
                // bump these to make room for the effects
                //
                audswitcheroutpin += SourceEffectCount;
                audswitcherinpin += SourceEffectCount;
                
                for( int SourceEffectN = 0 ; SourceEffectN < SourceEffectCount ; SourceEffectN++ )
                {
                    CComPtr< IAMTimelineObj > pEffect;
                    pSourceEffectable->GetEffect( &pEffect, SourceEffectN );
                    
                    if( !pEffect )
                    {
                        // didn't work, continue
                        //
                        continue; // source effects
                    }
                    
                    // ask if the effect is muted
                    //
                    BOOL effectMuted = FALSE;
                    pEffect->GetMuted( &effectMuted );
                    if( effectMuted )
                    {
                        // don't look at this effect
                        //
                        continue; // source effects
                    }
                    
                    // find the effect's lifetime
                    //
                    REFERENCE_TIME EffectStart = 0;
                    REFERENCE_TIME EffectStop = 0;
                    hr = pEffect->GetStartStop( &EffectStart, &EffectStop );
                    ASSERT( !FAILED( hr ) );
                    
                    // add in the effect's parent's time to get timeline time
                    //
                    EffectStart += SourceStart;
                    EffectStop += SourceStart;
                    
                    // align times to nearest timing boundary
                    //
                    hr = pEffect->FixTimes( &EffectStart, &EffectStop );
                    
                    // too short, we're ignoring it
                    if (EffectStart >= EffectStop)
                        continue;
                
                    // make sure we're within render range
                    //
                    if( m_rtRenderStart != -1 )
                    {
                        if( ( EffectStop <= m_rtRenderStart ) || ( EffectStart >= m_rtRenderStop ) )
                        {
                            // outside of range
                            //
                            continue; // source effects
                        }
                        else
                        {
                            // inside range, so skew for render range
                            //
                            EffectStart -= m_rtRenderStart;
                            EffectStop -= m_rtRenderStart;
                        }
                    }

                    // find the effect's GUID.
                    //
                    GUID EffectGuid;
                    hr = pEffect->GetSubObjectGUID( &EffectGuid );
                    
                    // get the effect's ID
                    //
                    long EffectID = 0;
                    pEffect->GetGenID( &EffectID );
                    
                    // tell the grid who is grabbing what
                    
                    bUsedNewGridRow = true;
                    AudGrid.WorkWithNewRow( SourceEffectInPin, gridinpin, LayerEmbedDepth, TrackPriority );
                    worked = AudGrid.RowIAmEffectNow( EffectStart, EffectStop, SourceEffectOutPin );
                    if( !worked )
                    {
                        hr = E_OUTOFMEMORY;
                        goto die;
                    }
                    
                    // instantiate the filter and hook it up
                    //
                    CComPtr< IBaseFilter > pAudEffectBase;
                    hr = _CreateObject(
                        EffectGuid,
                        IID_IBaseFilter,
                        (void**) &pAudEffectBase,
                        EffectID );
                    ASSERT( !FAILED( hr ) );
                    if( FAILED( hr ) )
                    {
                        hr = _GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
                        goto die;
                    }
                    
                    // if it's a volume effect, then do something special to give it properties
                    //
                    if( EffectGuid == CLSID_AudMixer )
                    {
                        IPin * pPin = GetInPin( pAudEffectBase, 0 );
                        ASSERT( pPin );
                        CComQIPtr< IAudMixerPin, &IID_IAudMixerPin > pMixerPin( pPin );
                        ASSERT( pMixerPin );
                        pMixerPin->SetEnvelopeRange( EffectStart, EffectStop );

                        hr = _SetPropsOnAudioMixer( pAudEffectBase, pGroupMediaType, GroupFPS, WhichGroup );
                        if( FAILED( hr ) )
                        {
                            goto die;
                        }
                        
                        CComPtr< IPropertySetter > pSetter;
                        hr = pEffect->GetPropertySetter( &pSetter );
                        IPin * pMixerInPin = GetInPin( pAudEffectBase, 0 );
                        CComQIPtr< IAudMixerPin, &IID_IAudMixerPin > pAudMixerPin( pMixerInPin );
                        if( pAudMixerPin )
                        {
			    if (pSetter) {
                                hr = pAudMixerPin->put_PropertySetter( pSetter );
			    }
			    // to make it easy to find which mixer pin
			    // goes with with volume envelope
			    long ID;
			    hr = pEffect->GetUserID(&ID);
			    hr = pAudMixerPin->put_UserID(ID);
                        }
                    } else {

			// Give the STATIC properties to the audio effect
			// general audio effects can't do dynamic props
			//
                        CComPtr< IPropertySetter > pSetter;
                        hr = pEffect->GetPropertySetter(&pSetter);
                        if (pSetter) {
			    pSetter->SetProps(pAudEffectBase, -1);
                        }
		    }
                        
                    // add it to the graph
                    //
                    hr = _AddFilter( pAudEffectBase, L"Audio Effect", EffectID );
                    ASSERT( !FAILED( hr ) );
                    if( FAILED( hr ) )
                    {
                        hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                        goto die;
                    }
                    
                    // find it's pins...
                    //
                    IPin * pFilterInPin = NULL;
                    pFilterInPin = GetInPin( pAudEffectBase, 0 );
                    ASSERT( pFilterInPin );
                    if( !pFilterInPin )
                    {
                        hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                        goto die;
                    }
                    IPin * pFilterOutPin = NULL;
                    pFilterOutPin = GetOutPin( pAudEffectBase, 0 );
                    ASSERT( pFilterOutPin );
                    if( !pFilterOutPin )
                    {
                        hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                        goto die;
                    }
                    CComPtr< IPin > pSwitcherOutPin;
                    _pAudSwitcherBase->GetOutputPin( SourceEffectOutPin, &pSwitcherOutPin );
                    ASSERT( pSwitcherOutPin );
                    if( !pSwitcherOutPin )
                    {
                        hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                        goto die;
                    }
                    CComPtr< IPin > pSwitcherInPin;
                    _pAudSwitcherBase->GetInputPin( SourceEffectInPin, &pSwitcherInPin );
                    ASSERT( pSwitcherInPin );

                    if( !pSwitcherInPin )
                    {
                        hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
			goto die;
                    }

                    // connect them
                    //
                    hr = _Connect( pSwitcherOutPin, pFilterInPin );
                    ASSERT( !FAILED( hr ) );
                    if( FAILED( hr ) )
                    {
                        hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
			goto die;
                    }
                    hr = _Connect( pFilterOutPin, pSwitcherInPin );
                    ASSERT( !FAILED( hr ) );
                    if( FAILED( hr ) )
                    {
                        hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
			goto die;
                    }

                    SourceEffectInPin++;
                    SourceEffectOutPin++;
                    gridinpin++;
                } // for all the effects

            } // if SourceEffectCount

          } // while sources

          if( !bUsedNewGridRow )
          {
              // nothing was on this track, so completely ignore it
              //
              continue;
          }

        } // if pTrack
                    
        DbgTimer AudioAfterSources( "(rendeng) Audio post-sources" );
                    
        REFERENCE_TIME TrackStart, TrackStop;
        pLayer->GetStartStop( &TrackStart, &TrackStop );
        
        AudGrid.DumpGrid( );
        
        // if we're a composition, it's time to deal with all the sub-tracks that need
        // to be mixed... enumerate all the comp's tracks, find out if they need waveforms
        // modified or need mixing, etc.
        
        bool fSkipDoneUnlessNew = false;

        CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pComp( pLayer );
        if( !pComp )
        {
            // not a composition, continue, please.
            //
            AudGrid.DumpGrid( );
            DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--Layer is not a composition, so continue...") ) );
            LastUsedNewGridRow = LayerEmbedDepth;   // last depth to call Done
            LastEmbedDepth = LayerEmbedDepth;
            goto NonVol; // do non-vol track/comp/group fx, then layer is done
        }

        // we must only call DoneWithLayer if we've called WorkWithNewRow above
        // (bUsedNewGridRow) or if we're a composition and some deeper depth
        // called DoneWithLayer.
        //
        if ((LastEmbedDepth <= LayerEmbedDepth ||
                LastUsedNewGridRow <= LayerEmbedDepth) && !bUsedNewGridRow) {
            LastEmbedDepth = LayerEmbedDepth;
            // after the goto, skip the DoneWithLayer, unless NewRow is called
            fSkipDoneUnlessNew = true;
            goto NonVol;
        }

        LastUsedNewGridRow = LayerEmbedDepth; // last depth to call DoneWithLay
        LastEmbedDepth = LayerEmbedDepth;

        {
        DbgTimer AudBeforeMix( "(rendeng) Audio, before mix" );
        // Find out how many Mixed tracks we have at once.
        // Find out if there's a volume envelope on the output pin
        // For each track...
        //      Find out if track has a volume envelope, if so,
        //      Transfer that track to the mixer input pin
        // Set the output track's envelope if any
        // put the mixer in the graph and hook it up

        // since we may have or may NOT have called WorkWithNewRow already, we need to tell the Grid
        // we're ABOUT to work with another row. If it turns out that we didn't need to
        // call this, it's okay, another call to it with the same audswitcherinpin will overwrite it.
        // LayerEmbedDepth will be the embed depth for this composition, and will be one LESS than
        // the embed depth of everything above it in the grid.
        //
        AudGrid.WorkWithNewRow( audswitcherinpin, gridinpin, LayerEmbedDepth, TrackPriority );
        
        // find out how many tracks are concurrent at the same time for THIS COMP ONLY
        //
        long MaxMixerTracks = AudGrid.MaxMixerTracks( );
        
        DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--Layer %ld is a COMP and has %ld mixed tracks"), CurrentLayer, MaxMixerTracks ) );
        
        // here's a blank mixer pointer...
        //
        HRESULT hr = 0;
        CComPtr< IBaseFilter > pMixer;
        REFERENCE_TIME VolEffectStart = -1;
        REFERENCE_TIME VolEffectStop = -1;
        REFERENCE_TIME CompVolEffectStart = -1;
        REFERENCE_TIME CompVolEffectStop = -1;
        
	// the UserID of the track and group volume effect object
        long IDSetter = 0;
        long IDOutputSetter = 0;
	    
        // figure out if the group needs an envelope.
        // Group Envelopes happen by setting volume on the OUTPUT pin, as opposed to
        // everything else setting input pin volumes.
        //
        CComPtr< IPropertySetter > pOutputSetter;
        if( CurrentLayer == AudioLayers - 1 )
        {
            DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--Layer %ld is the GROUP layer"), CurrentLayer ) );
            
            // ask it if it has any effects
            //
            long TrackEffectCount = 0;
            CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pTrackEffectable( pLayer );
            if( pTrackEffectable )
            {
                pTrackEffectable->EffectGetCount( &TrackEffectCount );
                
                // for each effect, see if there's a waveform modifier
                //
                for( int e = 0 ; e < TrackEffectCount ; e++ )
                {
                    CComPtr< IAMTimelineObj > pEffect;
                    pTrackEffectable->GetEffect( &pEffect, e );
                    if( !pEffect )
                    {
                        continue;
                    }
                    
                    // ask if the effect is muted
                    //
                    BOOL effectMuted = FALSE;
                    pEffect->GetMuted( &effectMuted );
                    if( effectMuted )
                    {
                        // don't look at this effect
                        //
                        continue; // track effects
                    }
                    
                    // find the effect's lifetime
                    //
                    REFERENCE_TIME EffectStart = 0;
                    REFERENCE_TIME EffectStop = 0;
                    hr = pEffect->GetStartStop( &EffectStart, &EffectStop );
                    ASSERT( !FAILED( hr ) );
                    
                    // add in the effect's parent's time to get timeline time
                    //
                    EffectStart += TrackStart;
                    EffectStop += TrackStart;
                    
                    // align times to nearest frame boundary
                    //
                    hr = pEffect->FixTimes( &EffectStart, &EffectStop );
                    
                    // too short, we're ignoring it
                    if (EffectStart >= EffectStop)
                        continue;
                
                    // make sure we're within render range
                    //
                    if( m_rtRenderStart != -1 ) {
                        if( ( EffectStop <= m_rtRenderStart ) || ( EffectStart >= m_rtRenderStop ) )
                        {
                            continue; // track effects
                        }
                        else
                        {
                            EffectStart -= m_rtRenderStart;
                            EffectStop -= m_rtRenderStart;
                        }
		    }
                        
                    // find the effect's GUID
                    //
                    GUID EffectGuid;
                    hr = pEffect->GetSubObjectGUID( &EffectGuid );
                        
                    // if the effect is a volume effect, then do something special to the audio mixer pin
                    //
                    if( EffectGuid != CLSID_AudMixer )
                    {
                        continue; // track effects
                    }
                    
                    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--Group layer needs an envelope on it") ) );
                    hr = pEffect->GetPropertySetter( &pOutputSetter );
		    CompVolEffectStart = EffectStart;
		    CompVolEffectStop = EffectStop;
		    hr = pEffect->GetUserID(&IDOutputSetter); // remember ID too
                    break;

                } // for effects
            } // if pTrackEffectable
        } // if the group layer
        
        // run through and find out if any of our tracks have volume envelopes on them
        //
        long CompTracks = 0;
        pComp->VTrackGetCount( &CompTracks );

        CComPtr< IAMTimelineObj > pTr;
        
        // ask each track
        //
        for( int t = 0 ; t < CompTracks ; t++ )
        {
            CComPtr< IPropertySetter > pSetter;
            
            // get the next track
            //
            CComPtr< IAMTimelineObj > pNextTr;
            pComp->GetNextVTrack(pTr, &pNextTr);
            if (!pNextTr)
                continue;
            pTr = pNextTr;
            
            // ask it if it has any effects
            //
            long TrackEffectCount = 0;
            CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pTrackEffectable( pTr );
            if( !pTrackEffectable )
            {
                continue;
            }
            pTrackEffectable->EffectGetCount( &TrackEffectCount );
            
            // for each effect, see if there's a waveform modifier
            //
            for( int e = 0 ; e < TrackEffectCount ; e++ )
            {
                CComPtr< IAMTimelineObj > pEffect;
                pTrackEffectable->GetEffect( &pEffect, e );
                if( !pEffect )
                {
                    continue;
                }
                
                // ask if the effect is muted
                //
                BOOL effectMuted = FALSE;
                pEffect->GetMuted( &effectMuted );
                if( effectMuted )
                {
                    // don't look at this effect
                    //
                    continue; // track effects
                }
                
                // find the effect's lifetime
                //
                REFERENCE_TIME EffectStart = 0;
                REFERENCE_TIME EffectStop = 0;
                hr = pEffect->GetStartStop( &EffectStart, &EffectStop );
                ASSERT( !FAILED( hr ) );
                
                // add in the effect's parent's time to get timeline time
                //
                EffectStart += TrackStart;
                EffectStop += TrackStart;
                
                // align times to nearest frame boundary
                //
                hr = pEffect->FixTimes( &EffectStart, &EffectStop );
                
                // too short, we're ignoring it
                if (EffectStart >= EffectStop)
                    continue;
                
                // make sure we're within render range
                //
                if( m_rtRenderStart != -1 ) {
                    if( ( EffectStop <= m_rtRenderStart ) || ( EffectStart >= m_rtRenderStop ) )
                    {
                        continue; // track effecs
                    }
                    else
                    {
                        EffectStart -= m_rtRenderStart;
                        EffectStop -= m_rtRenderStart;
                    }
		}
                    
                // find the effect's GUID
                //
                GUID EffectGuid;
                hr = pEffect->GetSubObjectGUID( &EffectGuid );
                    
                // if the effect is a volume effect, then do something special to the audio mixer pin
                //
                if( EffectGuid == CLSID_AudMixer )
                {
                    hr = pEffect->GetPropertySetter( &pSetter );
		    hr = pEffect->GetUserID(&IDSetter);	// remember ID too
                    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--Layer %ld of COMP needs an envelope on it, need Mixer = TRUE"), e ) );
		    // NOTE: Only 1 volume effect per track is supported!
                    VolEffectStart = EffectStart;
                    VolEffectStop = EffectStop;
                    break;
                }
                    
            } // for effects
            
            // this pin will be sent to the mixer if we need an envelope (on the track)
            // OR, if the output volume needs enveloped, we need to send this track to the mixer as well.
            //
            if (pSetter || IDSetter || pOutputSetter || IDOutputSetter)
            {
                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--Created mixer...") ) );
                
                if( !pMixer )
                {
                    hr = _CreateObject(
                        CLSID_AudMixer,
                        IID_IBaseFilter,
                        (void**) &pMixer );
                    ASSERT( !FAILED( hr ) );
                    if( FAILED( hr ) )
                    {
                        hr = _GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
                        goto die;
                    }
                    
                    CComQIPtr< IAudMixer, &IID_IAudMixer > pAudMixer( pMixer );
                    hr = pAudMixer->put_InputPins( CompTracks );
                    hr = pAudMixer->InvalidatePinTimings( );
                }
                
                // get the property setter, which contains the envelope
                //
                // can't fail
                ASSERT( !FAILED( hr ) );
                
                IPin * pMixerInPin = GetInPin( pMixer, t );
                CComQIPtr< IAudMixerPin, &IID_IAudMixerPin > p( pMixerInPin );

                // tell the mixer audio pin about the property setter
                // we only set the props if we have props
                //
                if( pSetter )
                {
                    hr = p->put_PropertySetter( pSetter );
                    DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--Set envelope on mixer's %ld input pin"), t ) );
		}

		if (IDSetter) {
		    // to make it easy to find which mixer pin
		    // goes with with volume envelope
		    hr = p->put_UserID(IDSetter);
		}

                // transfer all normal outputs to the mixer's input pin instead,
                // (this does NOT deal with the mixer's output pin)
                //
                // NOTE: The reason this logic works in conjunction with DoMix below is
                // because the grid stealing functions look for OUTPUT pins. XFerToMixer will
                // create a new grid row, but assign the old row completely to the mixer's input
                // pin. The new grid row thus becomes a proxy for the old grid row and DoMix is
                // fooled into thinking it's okay. Same thing with DoMix, it takes values from
                // the old rows and assigns them to the mixer, and creates a mixed row. It all works.
                //
                // !!! check return value
                worked = AudGrid.XferToMixer(pMixer, audswitcheroutpin, t, VolEffectStart, VolEffectStop );
                if( !worked )
                {
                    hr = E_OUTOFMEMORY;
                    goto die;
                }
                
                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--Transferring grid pins to mixers %ld pin"), t ) );
                
                AudGrid.DumpGrid( );
                
            } // if need mixer
            
        } // for tracks
        
        // if we have a volume envelope we need to put on the mixer's output...
        //
        // tell the mixer audio pin about the property setter
        //
	if (pOutputSetter || IDOutputSetter) {
            IPin * pMixerInPin = GetOutPin( pMixer, 0 );
            CComQIPtr< IAudMixerPin, &IID_IAudMixerPin > p( pMixerInPin );
	    if (pOutputSetter)
	    {
                hr = p->put_PropertySetter( pOutputSetter );
                DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--Set envelope on mixer's output pin") ) );

                // tell the output what it's valid envelope range is, we got these times way above
                //
                hr = p->SetEnvelopeRange( CompVolEffectStart, CompVolEffectStop );
	    }
	    if (IDOutputSetter) {
	        // to make it easy to find which mixer pin
	        // goes with with volume envelope
	        hr = p->put_UserID(IDOutputSetter);
	    }

        }
        
        // NOTE: if MaxMixerTracks > 1 then we will already force ALL the tracks to go to the mixer, and we don't need
        // to worry about envelopes
        
        // if we don't need a mixer, we can just go on with our layer search
        //
        if( !pMixer && ( MaxMixerTracks < 2 ) )
        {
            // this means we have ONE track under us, and it doesn't have a waveform. Go through
            // and force the output track # in the grid that had the output pin to be OUR track #
            // so the mix above us will work right
            //
            // NOTE: we've told the grid that we've got a new row by calling WorkWithNewRow, but we're
            // now not going to need it. Fortunately, YoureACompNow does the right thing. Calling DoneWithLayer
            // below will also happily ignore the "fake" new row. As long as we didn't bump audmixerinpin,
            // we're okay.
            //
            worked = AudGrid.YoureACompNow( TrackPriority );
            if( !worked )
            {
                hr = E_OUTOFMEMORY;
                goto die;
            }
            
            DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--layer didn't need a mixer, so we're done.") ) );
            AudGrid.DumpGrid( );
            goto NonVol;
        }
        
        // create mixer
        //
        if( !pMixer )
        {
            hr = _CreateObject(
                CLSID_AudMixer,
                IID_IBaseFilter,
                (void**) &pMixer );
            
            // tell the mixer to be this big, so we can validate timing ranges on the input
            // pins without having to create them one by one
            //
            CComQIPtr< IAudMixer, &IID_IAudMixer > pAudMixer( pMixer );
            hr = pAudMixer->put_InputPins( CompTracks );
            hr = pAudMixer->InvalidatePinTimings( );
            DbgLog( ( LOG_TRACE, RENDER_TRACE_LEVEL, TEXT("REND--Creating a mixer!") ) );
        }
        
        // give the mixer the buffer size it needs and the media type
        //
        hr = _SetPropsOnAudioMixer( pMixer, pGroupMediaType, GroupFPS, WhichGroup );
        if( FAILED( hr ) )
        {
            goto die;
        }
        
        // add it to the graph and...
        //
        hr = _AddFilter( pMixer, L"AudMixer" );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
            goto die;
        }
        
        // connect up the input mixer pins. 
        //
        for( t = 0 ; t < CompTracks ; t++ )
        {
            CComPtr< IPin > pSwitchOutPin;
            _pAudSwitcherBase->GetOutputPin( audswitcheroutpin + t, &pSwitchOutPin );
            ASSERT( pSwitchOutPin );
            IPin * pMixerInPin = GetInPin( pMixer, t );
            ASSERT( pMixerInPin );
            hr = _Connect( pMixerInPin, pSwitchOutPin );
        }
        
        // connect the output mixer pin to the input switcher
        //
        IPin * pMixerOutPin = GetOutPin( pMixer, 0 );
        CComPtr< IPin > pSwitchInPin;
        _pAudSwitcherBase->GetInputPin( audswitcherinpin, &pSwitchInPin );
        hr = _Connect( pMixerOutPin, pSwitchInPin );
        
        // do the mix, rely on the grid's function to tell the pins what's what
        //
        worked = AudGrid.DoMix( pMixer, audswitcheroutpin );
        if( !worked )
        {
            hr = E_OUTOFMEMORY;
            goto die;
        }
        
        // make all tracks in the grid which have an output now think they have
        // the output track priority of their parent's
        //
        worked = AudGrid.YoureACompNow( TrackPriority );
        if( !worked )
        {
            hr = E_OUTOFMEMORY;
            goto die;
        }
        
        // we used this many pins up doing the connecting.
        //
        audswitcherinpin++;
        gridinpin++;
        audswitcheroutpin += CompTracks ;
        
        AudGrid.DumpGrid( );
        }

        // now do non-volume effects

NonVol:

        // reset.  fSkipDoneUnlessNew wants to see if this gets set now
        bUsedNewGridRow = false;

        CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pTrackEffectable( pLayer );
        long TrackEffectCount = 0;
        if( pTrackEffectable )
        {
            pTrackEffectable->EffectGetCount( &TrackEffectCount );
        }
        
        if( !EnableFx )
        {
            TrackEffectCount = 0;
        }
        
        if( TrackEffectCount )
        {
            for( int TrackEffectN = 0 ; TrackEffectN < TrackEffectCount ; TrackEffectN++ )
            {
                CComPtr< IAMTimelineObj > pEffect;
                pTrackEffectable->GetEffect( &pEffect, TrackEffectN );
                if( !pEffect )
                {
                    // didn't work, so continue
                    //
                    continue; // track effects
                }
                
                // ask if the effect is muted
                //
                BOOL effectMuted = FALSE;
                pEffect->GetMuted( &effectMuted );
                if( effectMuted )
                {
                    // don't look at this effect
                    //
                    continue; // track effects
                }
                
                // find the effect's lifetime
                //
                REFERENCE_TIME EffectStart = 0;
                REFERENCE_TIME EffectStop = 0;
                hr = pEffect->GetStartStop( &EffectStart, &EffectStop );
                ASSERT( !FAILED( hr ) );
                
                // add in the effect's parent's time to get timeline time
                //
                EffectStart += TrackStart;
                EffectStop += TrackStart;
                
                // align times to nearest frame boundary
                //
                hr = pEffect->FixTimes( &EffectStart, &EffectStop );
                
                // too short, we're ignoring it
                if (EffectStart >= EffectStop)
                    continue;
                
                // make sure we're within render range
                //
                if( m_rtRenderStart != -1 )
                {
                    if( ( EffectStop <= m_rtRenderStart ) || ( EffectStart >= m_rtRenderStop ) )
                    {
                        continue; // track effecs
                    }
                    else
                    {
                        EffectStart -= m_rtRenderStart;
                        EffectStop -= m_rtRenderStart;
                    }
                }
                    
                // find the effect's GUID
                //
                GUID EffectGuid;
                hr = pEffect->GetSubObjectGUID( &EffectGuid );
                
                long EffectID = 0;
                pEffect->GetGenID( &EffectID );
                
                // if it's a volume effect, ignore it until later
                //
                if( EffectGuid == CLSID_AudMixer )
                {
                    continue;
                }
                
                // tell the grid who is grabbing what
                //
                bUsedNewGridRow = true;
                AudGrid.WorkWithNewRow( audswitcherinpin, gridinpin, LayerEmbedDepth, TrackPriority );
                worked = AudGrid.RowIAmEffectNow( EffectStart, EffectStop, audswitcheroutpin );
                if( !worked )
                {
                    hr = E_OUTOFMEMORY;
                    goto die;
                }

                // instantiate the filter and hook it up
                //
                CComPtr< IBaseFilter > pAudEffectBase;
                hr = _CreateObject(
                    EffectGuid,
                    IID_IBaseFilter,
                    (void**) &pAudEffectBase,
                    EffectID );
                if( FAILED( hr ) )
                {
                    VARIANT var;
                    BSTR bstr;
                    VariantFromGuid(&var, &bstr, &EffectGuid);
                    hr = _GenerateError(2, DEX_IDS_INVALID_AUDIO_FX, E_INVALIDARG,
                        &var);
                    if (var.bstrVal)
                        SysFreeString(var.bstrVal);
                    goto die;
                }
                
                // Give the STATIC properties to the NON-MIXER audio effect
                // general audio effects can't do dynamic props
                //
                CComPtr< IPropertySetter > pSetter;
                hr = pEffect->GetPropertySetter(&pSetter);
                if (pSetter) {
                    pSetter->SetProps(pAudEffectBase, -1);
                }

                // add it to the graph
                //
                hr = _AddFilter( pAudEffectBase, L"Audio Effect", EffectID );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                
                // find it's pins...
                //
                IPin * pFilterInPin = NULL;
                pFilterInPin = GetInPin( pAudEffectBase, 0 );
                if( !pFilterInPin )
                {
                    VARIANT var;
                    BSTR bstr;
                    VariantFromGuid(&var, &bstr, &EffectGuid);
                    hr = _GenerateError(2, DEX_IDS_INVALID_AUDIO_FX, E_INVALIDARG,
                        &var);
                    if (var.bstrVal)
                        SysFreeString(var.bstrVal);
                    goto die;
                }
                IPin * pFilterOutPin = NULL;
                pFilterOutPin = GetOutPin( pAudEffectBase, 0 );
                if( !pFilterOutPin )
                {
                    VARIANT var;
                    BSTR bstr;
                    VariantFromGuid(&var, &bstr, &EffectGuid);
                    hr = _GenerateError(2, DEX_IDS_INVALID_AUDIO_FX, E_INVALIDARG,
                        &var);
                    if (var.bstrVal)
                        SysFreeString(var.bstrVal);
                    goto die;
                }
                CComPtr< IPin > pSwitcherOutPin;
                _pAudSwitcherBase->GetOutputPin( audswitcheroutpin, &pSwitcherOutPin );
                ASSERT( pSwitcherOutPin );
                if( !pSwitcherOutPin )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                CComPtr< IPin > pSwitcherInPin;
                _pAudSwitcherBase->GetInputPin( audswitcherinpin, &pSwitcherInPin );
                ASSERT( pSwitcherInPin );
                if( !pSwitcherInPin )
                {
                    hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    goto die;
                }
                
                // connect them
                //
                hr = _Connect( pSwitcherOutPin, pFilterInPin );
                if( FAILED( hr ) )
                {
                    VARIANT var;
                    BSTR bstr;
                    VariantFromGuid(&var, &bstr, &EffectGuid);
                    hr = _GenerateError(2, DEX_IDS_INVALID_AUDIO_FX, E_INVALIDARG,
                        &var);
                    if (var.bstrVal)
                        SysFreeString(var.bstrVal);
                    goto die;
                }
                hr = _Connect( pFilterOutPin, pSwitcherInPin );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    VARIANT var;
                    BSTR bstr;
                    VariantFromGuid(&var, &bstr, &EffectGuid);
                    hr = _GenerateError(2, DEX_IDS_INVALID_AUDIO_FX, E_INVALIDARG,
                        &var);
                    if (var.bstrVal)
                        SysFreeString(var.bstrVal);
                    goto die;
                }
                
                // bump to make room for effect
                //
                audswitcherinpin++;
                gridinpin++;
                audswitcheroutpin++;
                    
            } // for all the effects
            
        } // if any effects on track

        if (!(!bUsedNewGridRow && fSkipDoneUnlessNew)) {
            AudGrid.DoneWithLayer( );
        }
        AudGrid.DumpGrid( );
        
    } // while AudioLayers
    
die:
    // free the re-using source stuff now that we're either done or we
    // hit an error
    for (int yyy = 0; yyy < cList; yyy++) {
	SysFreeString(pREUSE[yyy].bstrName);
        if (pREUSE[yyy].pMiniSkew)      // failed re-alloc would make this NULL
	    QzTaskMemFree(pREUSE[yyy].pMiniSkew);
    }
    if (pREUSE)
        QzTaskMemFree(pREUSE);
    if (FAILED(hr))
	return hr;

    AudGrid.PruneGrid( );
    if( !worked )
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }
    AudGrid.DumpGrid( );
    
    // make the switch connections now
    //
    for( int aip = 0 ; aip < audinpins ; aip++ )
    {
        AudGrid.WorkWithRow( aip );
        long SwitchPin = AudGrid.GetRowSwitchPin( );
        REFERENCE_TIME InOut = -1;
        REFERENCE_TIME Stop = -1;
        int nUsed = 0; // the # of ranges the silent source is needed for
        STARTSTOPSKEW *pSkew;
        int nSkew = 0;
        
        if( AudGrid.IsRowTotallyBlank( ) )
        {
            continue;
        }

        while (1) 
        {
            long Value = 0;
            AudGrid.RowGetNextRange( &InOut, &Stop, &Value );
            if( InOut == Stop || InOut >= TotalDuration ) {
                break;
            }
            
            if( Value >= 0 || Value == ROW_PIN_OUTPUT) {
                if (Value == ROW_PIN_OUTPUT) {
                    Value = 0;
                }
                
                // do some fancy processing for setting up the SILENT regions
                //
                if (aip == 0) {
                    if( nUsed == 0 ) {
                        nSkew = 10;	// start with space for 10
                        pSkew = (STARTSTOPSKEW *)CoTaskMemAlloc(nSkew *
                            sizeof(STARTSTOPSKEW));
                        if (pSkew == NULL)
                            return _GenerateError( 1, DEX_IDS_GRAPH_ERROR,	
                            E_OUTOFMEMORY);
                    } else if (nUsed == nSkew) {
                        nSkew += 10;
                        pSkew = (STARTSTOPSKEW *)CoTaskMemRealloc(pSkew, nSkew *
                            sizeof(STARTSTOPSKEW));
                        if (pSkew == NULL)
                            return _GenerateError( 1, DEX_IDS_GRAPH_ERROR,	
                            E_OUTOFMEMORY);
                    }
                    pSkew[nUsed].rtStart = InOut;
                    pSkew[nUsed].rtStop = Stop;
                    pSkew[nUsed].rtSkew = 0;
                    pSkew[nUsed].dRate = 1.0;
                    nUsed++;
                }
                
                hr = m_pSwitcherArray[WhichGroup]->SetX2Y(InOut, SwitchPin, Value);
                ASSERT(SUCCEEDED(hr));
                if (FAILED(hr)) {
                    return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                }
            }
            
            // either it's unassigned or another track has higher priority and
            // no transition exists at this time, so it should be invisible
            //
            else if( Value == ROW_PIN_UNASSIGNED || Value < ROW_PIN_OUTPUT )
            {
                // make sure not to program anything if this is a SILENCE source
                // that will be programmed later
                if (aip > 0 || nUsed) {
                    hr = m_pSwitcherArray[WhichGroup]->SetX2Y(InOut, SwitchPin,
                        ROW_PIN_UNASSIGNED );
                    ASSERT( !FAILED( hr ) );
                    if( FAILED( hr ) )
                    {
                        // must be out of memory
                        return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                    }
                }
            }
            
            // this should never happen
            //
            else
            {
                ASSERT( 0 );
            }
            
        }
        
        // not dynamic - load silent source now
        //
        if( !( m_nDynaFlags & CONNECTF_DYNAMIC_SOURCES ) ) {
            
            if (nUsed) {
                IPin * pOutPin = NULL;
                hr = BuildSourcePart(
                    m_pGraph, 
                    FALSE, 
                    0, 
                    pGroupMediaType, 
                    GroupFPS,
                    0, 
                    0, 
                    nUsed, 
                    pSkew, 
                    this, 
                    NULL, 
                    NULL,
                    NULL,
                    &pOutPin, 
                    0, 
                    m_pDeadCache,
                    FALSE,
                    m_MedLocFilterString,
                    m_nMedLocFlags,
                    m_pMedLocChain, NULL, NULL );
                
                CoTaskMemFree(pSkew);
                
                if (FAILED(hr)) {
                    // error already logged
                    return hr;
                }
                
                pOutPin->Release(); // not the last ref
                
                // get the switch pin
                //
                CComPtr< IPin > pSwitchIn;
                _pAudSwitcherBase->GetInputPin(SwitchPin, &pSwitchIn);
                ASSERT( pSwitchIn );
                if( !pSwitchIn )
                {
                    return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                }
                
                // connect to the switch
                //
                hr = _Connect( pOutPin, pSwitchIn );
                ASSERT( !FAILED( hr ) );
                if( FAILED( hr ) )
                {
                    return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
                }
                
                // tell the switcher that we're a source pin
                //
                hr = m_pSwitcherArray[WhichGroup]->InputIsASource(SwitchPin,TRUE);
            }
            
            
            // DYNAMIC - load silent source later
            //
        } else {
            if (nUsed) {
                // this will merge skews
                AM_MEDIA_TYPE mt;
                ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE)); // safe
                hr = m_pSwitcherArray[WhichGroup]->AddSourceToConnect(
                    NULL, &GUID_NULL,
                    0, 0, 0,
                    nUsed, pSkew, SwitchPin, FALSE, 0, mt, 0.0, NULL);
                CoTaskMemFree(pSkew);
                if (FAILED(hr))	// out of memory?
                    return _GenerateError( 1, DEX_IDS_INSTALL_PROBLEM, hr );
                
                // tell the switcher that we're a source pin
                //
                hr = m_pSwitcherArray[WhichGroup]->InputIsASource(SwitchPin,TRUE);
            }
        }
    }
    
    // finally, at long last, see if the switch used to have something connected
    // to it. If it did, restore the connection
    // !!! this might fail if we're using 3rd party filters which don't
    // accept input pin reconnections if the output pin is already connected.\
    //
    if( m_pSwitchOuttie[WhichGroup] )
    {
        CComPtr< IPin > pSwitchRenderPin;
        _pAudSwitcherBase->GetOutputPin( 0, &pSwitchRenderPin );
        hr = _Connect( pSwitchRenderPin, m_pSwitchOuttie[WhichGroup] );
        ASSERT( !FAILED( hr ) );
        m_pSwitchOuttie[WhichGroup].Release( );
    }

    m_nGroupsAdded++;
    
    return hr;
}

//############################################################################
// 
//############################################################################

long CRenderEngine::_HowManyMixerOutputs( long WhichGroup )
{
    HRESULT hr = 0;
    DbgTimer d( "(rendeng) HowManyMixerOutputs" );
    
    // ask timeline how many actual tracks it has
    //
    long AudioTrackCount = 0;   // tracks only
    long AudioLayers = 0;       // tracks including compositions
    m_pTimeline->GetCountOfType( WhichGroup, &AudioTrackCount, &AudioLayers, TIMELINE_MAJOR_TYPE_TRACK );
    
    // how many layers do we have?
    //
    CComPtr< IAMTimelineObj > pGroupObj;
    hr = m_pTimeline->GetGroup( &pGroupObj, WhichGroup );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        return 0;
    }
    CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pGroupComp( pGroupObj );
    if( !pGroupComp )
    {
        return 0;
    }
    
    long MixerPins = 0;
    
    // add source filters for each source on the timeline
    //
    for(  int CurrentLayer = 0 ; CurrentLayer < AudioLayers ; CurrentLayer++ )
    {
        // get the layer itself
        //
        CComPtr< IAMTimelineObj > pLayer;
        hr = pGroupComp->GetRecursiveLayerOfType( &pLayer, CurrentLayer, TIMELINE_MAJOR_TYPE_TRACK );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            continue; // audio layers
        }
        
        CComQIPtr< IAMTimelineTrack, &IID_IAMTimelineTrack > pTrack( pLayer );
        
        CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pComp( pLayer );
        if( !pComp )
        {
            continue; // layers
        }
        
        // run through and find out if any of our tracks have volume envelopes on them
        //
        long CompTracks = 0;
        pComp->VTrackGetCount( &CompTracks );
        
        MixerPins += CompTracks;
        
    } // while AudioLayers
    
    return MixerPins;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CRenderEngine::RenderOutputPins( )
{

    CAutoLock Lock( &m_CritSec );
    DbgTimer d( "(rendeng) RenderOutputPins" );

#ifdef DEBUG
    long ttt1 = timeGetTime( );
#endif
    
    // if it's broken, don't do anything.
    //
    if( m_hBrokenCode )
    {
        return E_RENDER_ENGINE_IS_BROKEN;
    }
    
    // need a graph to render anything
    //
    if( !m_pGraph )
    {
        return E_INVALIDARG;
    }
    
    HRESULT hr = 0;
    
    long GroupCount = 0;
    hr = m_pTimeline->GetGroupCount( &GroupCount );
    
    // need some groups first
    //
    if( !GroupCount )
    {
        return E_INVALIDARG;
    }
    
    // hookup each group in the timeline
    //
    for( int CurrentGroup = 0 ; CurrentGroup < GroupCount ; CurrentGroup++ )
    {
        DbgTimer d( "(rendereng) RenderOutputPins, for group" );

        CComPtr< IAMTimelineObj > pGroupObj;
        hr = m_pTimeline->GetGroup( &pGroupObj, CurrentGroup );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            //            hr = _GenerateError( 2, DEX_IDS_TIMELINE_PARSE, hr );
            continue;
        }
        CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( pGroupObj );
        if( !pGroup )
        {
            //            hr = _GenerateError( 2, DEX_IDS_TIMELINE_PARSE, hr );
            continue;
        }
        AM_MEDIA_TYPE MediaType;
        ZeroMemory( &MediaType, sizeof( MediaType ) ); // safe
        hr = pGroup->GetMediaType( &MediaType );
        GUID MajorType = MediaType.majortype;
        SaferFreeMediaType( MediaType );
        if( FAILED( hr ) )
        {
            //            hr = _GenerateError( 2, DEX_IDS_TIMELINE_PARSE, hr );
            continue;
        }
        CComQIPtr< IBaseFilter, &IID_IBaseFilter > pSwitcherBase( m_pSwitcherArray[CurrentGroup] );
        if( !pSwitcherBase )
        {
            //            hr = _GenerateError( 2, DEX_IDS_INTERFACE_ERROR, hr );
            // couldn't find pin, may as well render the rest of them
            //
            continue;
        }
        CComPtr< IPin > pSwitchOut;
        m_pSwitcherArray[CurrentGroup]->GetOutputPin( 0, &pSwitchOut );
        ASSERT( pSwitchOut );
        if( !pSwitchOut )
        {
            hr = _GenerateError( 2, DEX_IDS_GRAPH_ERROR, E_FAIL );
            return hr;
        }
        
        if( FAILED( hr ) )
        {
            _CheckErrorCode( hr );
            return hr;
        }
        
        // see if output pin is already connected
        //
        CComPtr< IPin > pConnected;
        pSwitchOut->ConnectedTo( &pConnected );
        if( pConnected )
        {
            continue;
        }

        if( MajorType == MEDIATYPE_Video )
        {
            // The Dexter Queue has an output queue to improve performance by
            // letting the graph get ahead during fast parts so slow DXT's don't
            // drag us down!  MUXES typically have their own queues... only do
            // this for preview mode!
            //
            CComPtr< IBaseFilter > pQueue;
            hr = _CreateObject( CLSID_DexterQueue,
                IID_IBaseFilter,
                (void**) &pQueue );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                _CheckErrorCode( hr );
                return _GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
            }
            
            // ask how much buffering this group wants
            //
            int nOutputBuffering;
            hr = pGroup->GetOutputBuffering(&nOutputBuffering);
            ASSERT(SUCCEEDED(hr));
            
            CComQIPtr< IAMOutputBuffering, &IID_IAMOutputBuffering > pBuffer ( 
                pQueue );
            hr = pBuffer->SetOutputBuffering( nOutputBuffering );
            ASSERT(SUCCEEDED(hr));
            if( FAILED( hr ) )
            {
                return hr;
            }
            
            // put the QUEUE in the graph
            //
            hr = _AddFilter( pQueue, L"Dexter Queue" );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                _CheckErrorCode( hr );
                return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
            }
            
            // find some pins
            //
            IPin * pQueueInPin = GetInPin( pQueue , 0 );
            ASSERT( pQueueInPin );
            if( !pQueueInPin )
            {
                _CheckErrorCode( hr );
                return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
            }
            IPin * pQueueOutPin = GetOutPin( pQueue , 0 );
            ASSERT( pQueueOutPin );
            if( !pQueueOutPin )
            {
                _CheckErrorCode( hr );
                return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
            }
            
            // connect the QUEUE to the switch
            //
            hr = _Connect( pSwitchOut, pQueueInPin );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                _CheckErrorCode( hr );
                return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
            }
            
            // create a video renderer, to provide a destination
            //
            CComPtr< IBaseFilter > pVidRenderer;
            hr = _CreateObject(
                CLSID_VideoRenderer,
                IID_IBaseFilter,
                (void**) &pVidRenderer );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                _CheckErrorCode( hr );
                return _GenerateError( 2, DEX_IDS_INSTALL_PROBLEM, hr );
            }
            
            // put it in the graph
            //
            hr = _AddFilter( pVidRenderer, L"Video Renderer" );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                _CheckErrorCode( hr );
                return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
            }
            
            // find a pin
            //
            IPin * pVidRendererPin = GetInPin( pVidRenderer , 0 );
            ASSERT( pVidRendererPin );
            if( !pVidRendererPin )
            {
                _CheckErrorCode( hr );
                return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
            }
            
            // connect the QUEUE to the video renderer
            //
            hr = _Connect( pQueueOutPin, pVidRendererPin );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                _CheckErrorCode( hr );
                return _GenerateError( 2, DEX_IDS_GRAPH_ERROR, hr );
            }
        }
        else if( MajorType == MEDIATYPE_Audio )
        {
            // create a audio renderer so we can hear it
            CComPtr< IBaseFilter > pAudRenderer;
            hr = _CreateObject(
                CLSID_DSoundRender,
                IID_IBaseFilter,
                (void**) &pAudRenderer );
            if( FAILED( hr ) )
            {
                return VFW_S_AUDIO_NOT_RENDERED;
            }
            
            hr = _AddFilter( pAudRenderer, L"Audio Renderer" );
            if( FAILED( hr ) )
            { 
                return VFW_S_AUDIO_NOT_RENDERED;
            }
            
            IPin * pAudRendererPin = GetInPin( pAudRenderer , 0 );
            if( !pAudRendererPin )
            {
		m_pGraph->RemoveFilter(pAudRenderer);
                return VFW_S_AUDIO_NOT_RENDERED;
            }
            
            hr = _Connect( pSwitchOut, pAudRendererPin );
            if( FAILED( hr ) )
            {
		m_pGraph->RemoveFilter(pAudRenderer);
                return VFW_S_AUDIO_NOT_RENDERED;
            }
        }
        else
        {
            // !!! just call render???
        }
    } // for all groups
    
#ifdef DEBUG
    ttt1 = timeGetTime( ) - ttt1;
    DbgLog((LOG_ERROR,1, "RENDENG::RenderOutputPins took %ld ms", ttt1 ));
#endif

    return hr;
}

//############################################################################
// attempts to set a range where scrubbing will not have to reconnect
//############################################################################

STDMETHODIMP CRenderEngine::SetInterestRange( REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    CAutoLock Lock( &m_CritSec );
    
    // if it's broken, don't do anything.
    //
    if( m_hBrokenCode )
    {
        return E_RENDER_ENGINE_IS_BROKEN;
    }
    
    // can't set an interest range if the timeline's not been set
    //
    if( !m_pTimeline )
    {
        return E_INVALIDARG;
    }
    
    HRESULT hr = 0;
    hr = m_pTimeline->SetInterestRange( Start, Stop );
    if( FAILED( hr ) )
    {
        //        return hr;
    }
    
    return NOERROR;
}

//############################################################################
// tells us where we want to render from
//############################################################################

STDMETHODIMP CRenderEngine::SetRenderRange( REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    CAutoLock Lock( &m_CritSec );
    
    m_rtRenderStart = Start;
    m_rtRenderStop = Stop;
    return NOERROR;
}

//############################################################################
// tells the render engine to allocate whatever resources it needs to. (connect the graph)
//############################################################################

STDMETHODIMP CRenderEngine::Commit( )
{
    // !!! do this
    return E_NOTIMPL;
}

//############################################################################
// informs the render engine we would like to free up as much mem as possible. (disconnect the graph)
//############################################################################

STDMETHODIMP CRenderEngine::Decommit( )
{
    // !!! do this
    return E_NOTIMPL;
}

//############################################################################
// ask some info about render engine
//############################################################################

STDMETHODIMP CRenderEngine::GetCaps( long Index, long * pReturn )
{
    // !!! do this
    return E_NOTIMPL;
}

//############################################################################
// 
//############################################################################

HRESULT CRenderEngine::_SetPropsOnAudioMixer( IBaseFilter * pBaseFilter, AM_MEDIA_TYPE * pMediaType, double GroupFPS, long WhichGroup )
{
    HRESULT hr = 0;
    
    // give the mixer the buffer size and media type
    //
    CComQIPtr<IAudMixer, &IID_IAudMixer> pAudMixer(pBaseFilter);
    hr = pAudMixer->set_OutputBuffering(4,(int)(1000.0 / GroupFPS ) + 100 );
    ASSERT( !FAILED( hr ) );
    hr = pAudMixer->put_MediaType( pMediaType );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        VARIANT var;
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = WhichGroup;
        return _GenerateError(2, DEX_IDS_BAD_MEDIATYPE, hr, &var );
    }
    
    return hr;
}

//############################################################################
// called by the SR to tell this renderer it's the compressed RE.
//############################################################################

STDMETHODIMP CRenderEngine::DoSmartRecompression( )
{
    CAutoLock Lock( &m_CritSec );
    m_bSmartCompress = TRUE;
    return NOERROR;
}

//############################################################################
// called by the SR to tell us we're being controlled by the SRE.
//############################################################################

STDMETHODIMP CRenderEngine::UseInSmartRecompressionGraph( )
{
    CAutoLock Lock( &m_CritSec );
    m_bUsedInSmartRecompression = TRUE;
    return NOERROR;
}

//############################################################################
// 
//############################################################################
// IObjectWithSite::SetSite
// remember who our container is, for QueryService or other needs
STDMETHODIMP CRenderEngine::SetSite(IUnknown *pUnkSite)
{
    // note: we cannot addref our site without creating a circle
    // luckily, it won't go away without releasing us first.
    m_punkSite = pUnkSite;
    
    return S_OK;
}

//############################################################################
// 
//############################################################################
// IObjectWithSite::GetSite
// return an addrefed pointer to our containing object
STDMETHODIMP CRenderEngine::GetSite(REFIID riid, void **ppvSite)
{
    if (m_punkSite)
        return m_punkSite->QueryInterface(riid, ppvSite);
    
    return E_NOINTERFACE;
}

//############################################################################
// 
//############################################################################
// Forward QueryService calls up to the "real" host
STDMETHODIMP CRenderEngine::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    IServiceProvider *pSP;
    
    if (!m_punkSite)
        return E_NOINTERFACE;
    
    HRESULT hr = m_punkSite->QueryInterface(IID_IServiceProvider, (void **) &pSP);
    
    if (SUCCEEDED(hr)) {
        hr = pSP->QueryService(guidService, riid, ppvObject);
        pSP->Release();
    }
    
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CRenderEngine::SetSourceNameValidation( BSTR FilterString, IMediaLocator * pCallback, LONG Flags )
{
    CAutoLock Lock( &m_CritSec );
    
    if( FAILED( ValidateFilenameIsntNULL( FilterString ) ) )
    {
        m_MedLocFilterString[0] = 0;                            
        m_MedLocFilterString[1] = 0;
    }
    else
    {
        HRESULT hr = StringCchCopy( m_MedLocFilterString, _MAX_PATH, FilterString );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    m_pMedLocChain = pCallback;
    m_nMedLocFlags = Flags;
    return NOERROR;
}

STDMETHODIMP CRenderEngine::SetInterestRange2( double Start, double Stop )
{
    return SetInterestRange( DoubleToRT( Start ), DoubleToRT( Stop ) );
}

STDMETHODIMP CRenderEngine::SetRenderRange2( double Start, double Stop )
{
    return SetRenderRange( DoubleToRT( Start ), DoubleToRT( Stop ) );
}

// IMPORTANT! This function either creates the object, period, or if it's in the cache,
// "restores" it and puts it in the graph FOR YOU. DO NOT call AddFilter( ) yourself on a restored
// filter, or it will be added twice to the same graph. Call the internal _AddFilter( ) method
// instead, which checks for you if it's already added.
//
HRESULT CRenderEngine::_CreateObject( CLSID Clsid, GUID Interface, void ** ppObject, long ID )
{
    HRESULT hr = 0;

    // if we want something from the cache, ID will be non-zero
    //
    if( ID != 0 )
    {
        CComPtr< IBaseFilter > pFilter = NULL;
        hr = m_pDeadCache->ReviveFilterToGraph( m_pGraph, ID, &pFilter );
        if( pFilter ) 
        {
            hr = pFilter->QueryInterface( Interface, ppObject );
            return hr;
        }
    }

    DbgLog( ( LOG_TRACE, 2, "RENDENG::Creating object with ID %ld", ID ) );

    hr = CoCreateInstance( Clsid, NULL, CLSCTX_INPROC_SERVER, Interface, ppObject );
    return hr;
}

/*
Tearing down the graph

Sources: pull them off and put them in the dead zone. When we want to put
a source back in, do a lookup based on the source GenID.

Effects: pull them off and put them in the dead zone based on the parent's
index. When we need to put them back in, do a lookup based on the parent's
index.

Transitions: same as effects.

Output pins from the big switcher do NOT get put into the dead zone - they
stay connected! The configuration of the timeline doesn't affect output pins


*/


// Look for matching source in group w/ diff MT. This would be very expensive,
// so we are going to look in the same spot as we are in, in our group. We will
// only check the same physical track # (eg. 4th track in this group, not
// counting how many comps are in there too, or how they're arranged, so that
// just adding extra comp layers to one group (like MediaPad does) won't spoil
// finding the matching source.  It also has to be the same source #, eg.
// the 5th source in that track. If everything about that source matches, and
// it's the other media type, we can use 1 source filter for both the audio and
// video and avoid opening the source twice
// BUT: We only share sources for groups with the same frame rate.  Otherwise
// seeking to a spot might end up in a different video segment than audio
// segment, so only one group will seek the parser, and it might be on the pin
// that is ignoring seeks.
//
HRESULT CRenderEngine::_FindMatchingSource(BSTR bstrName, REFERENCE_TIME SourceStart, REFERENCE_TIME SourceStop, REFERENCE_TIME MediaStart, REFERENCE_TIME MediaStop, int WhichGroup, int WhichTrack, int WhichSource, AM_MEDIA_TYPE *pGroupMediaType, double GroupFPS, long *ID)
{
#ifdef DEBUG
    DWORD dw = timeGetTime();
#endif

    DbgLog((LOG_TRACE,1,TEXT("FindMatchingSource")));

    while (1) {
	int group = WhichGroup + 1;	// we can only share with the next group

        CComPtr< IAMTimelineObj > pGroupObj;
        HRESULT hr = m_pTimeline->GetGroup(&pGroupObj, group);
        if (FAILED(hr)) {
	    break;
	}
        CComQIPtr<IAMTimelineGroup, &IID_IAMTimelineGroup> pGroup(pGroupObj);
	if (pGroup == NULL) {
	    return E_OUTOFMEMORY;
	}

	// if the frame rate doesn't match, don't share sources (see above)
	double fps;
        hr = pGroup->GetOutputFPS(&fps);
	if (FAILED(hr) || fps != GroupFPS) {
	    break;
	}

	// we need a group with a different media type to share sources
	CMediaType mt;
	hr = pGroup->GetMediaType(&mt);
	if (FAILED(hr) || mt.majortype == pGroupMediaType->majortype) {
	    break;
	}

    	CComQIPtr <IAMTimelineNode, &IID_IAMTimelineNode> pNode(pGroup);
	ASSERT(pNode);
        CComPtr< IAMTimelineObj > pTrackObj;
	hr = pNode->XGetNthKidOfType(TIMELINE_MAJOR_TYPE_TRACK, WhichTrack,
				&pTrackObj);
	if (pTrackObj == NULL) {
	    break;
	}

	// Eric promises this will become faster
        CComPtr< IAMTimelineObj > pSourceObj;
    	CComQIPtr <IAMTimelineNode, &IID_IAMTimelineNode> pNode2(pTrackObj);
	ASSERT(pNode2);
	hr = pNode2->XGetNthKidOfType(TIMELINE_MAJOR_TYPE_SOURCE, WhichSource,
				&pSourceObj);

	if (pSourceObj == NULL) {
	    break;
	}

        CComQIPtr<IAMTimelineSrc, &IID_IAMTimelineSrc> pSource(pSourceObj);
	ASSERT(pSource);

	REFERENCE_TIME mstart, mstop, start, stop;
	pSourceObj->GetStartStop(&start, &stop);
	if (start != SourceStart || stop != SourceStop) {
	    break;
	}
	CComBSTR bstr;
	hr = pSource->GetMediaName(&bstr);
	if (FAILED(hr)) {
	    break;
	}

        if (DexCompareW(bstr, bstrName)) { // safe
	    break;
	}
	pSource->GetMediaTimes(&mstart, &mstop);
	if (mstart != MediaStart || mstop != MediaStop) {
	    break;
	}
	
	// I don't believe it!  We found a match!
	pSourceObj->GetGenID(ID);
#ifdef DEBUG
        DbgLog((LOG_TRACE,1,TEXT("Source MATCHES group %d  ID %d"),
			(int)group, (int)(*ID)));
    	dw = timeGetTime() - dw;
    	DbgLog((LOG_TIMING,2,TEXT("Match took %d ms"), (int)dw));
#endif
	return S_OK;
    }

#ifdef DEBUG
    dw = timeGetTime() - dw;
    DbgLog((LOG_TIMING,2,TEXT("Failed match took %d ms"), (int)dw));
#endif
    DbgLog((LOG_TRACE,1,TEXT("Failed to find matching source")));
    return E_FAIL;
}


// remove the filter attached to this pin from the dangly list
//
HRESULT CRenderEngine::_RemoveFromDanglyList(IPin *pDanglyPin)
{
    if (m_cdangly == 0)
	return S_OK;	// there is no list

    CheckPointer(pDanglyPin, E_POINTER);
    CComPtr <IPin> pIn;

    pDanglyPin->ConnectedTo(&pIn);
    if (pIn == NULL)
	return S_OK;	// it won't be on the list

    IBaseFilter *pF = GetFilterFromPin(pIn);
    ASSERT(pF);

    for (int z = 0; m_cdangly; z++) {
	if (m_pdangly[z] == pF) {
	    m_pdangly[z] = NULL;
	    break;
	}
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\stillvid\loadgif.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: loadgif.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

/*-- 
Structs from IE img.hxx 
--*/

enum
{
    gifNoneSpecified =  0, // no disposal method specified
    gifNoDispose =      1, // do not dispose, leave the bits there
    gifRestoreBkgnd =   2, // replace the image with the background color
    gifRestorePrev =    3  // replace the image with the previous pixels
};


#define dwGIFVerUnknown     ((DWORD)0)   // unknown version of GIF file
#define dwGIFVer87a         ((DWORD)87)  // GIF87a file format
#define dwGIFVer89a         ((DWORD)89)  // GIF89a file format.

/** End Structs **/
 
#define MAXCOLORMAPSIZE     256

#define TRUE    1
#define FALSE   0

#define CM_RED      0
#define CM_GREEN    1
#define CM_BLUE     2

#define MAX_LWZ_BITS        12

#define INTERLACE       0x40
#define LOCALCOLORMAP   0x80
#define BitSet(byte, bit)   (((byte) & (bit)) == (bit))

#define LM_to_uint(a,b)         ((((unsigned int) b)<<8)|((unsigned int)a))

#define dwIndefiniteGIFThreshold 300    // 300 seconds == 5 minutes
                                        // If the GIF runs longer than
                                        // this, we will assume the author
                                        // intended an indefinite run.
#define dwMaxGIFBits 13107200           // keep corrupted GIFs from causing
                                        // us to allocate _too_ big a buffer.
                                        // This one is 1280 X 1024 X 10.

typedef struct _GIFSCREEN
{
        unsigned long Width;
        unsigned long Height;
        unsigned char ColorMap[3][MAXCOLORMAPSIZE];
        unsigned long NumColors;
        unsigned long ColorResolution;
        unsigned long Background;
        unsigned long AspectRatio;
}
GIFSCREEN;

typedef struct _GIF89
{
        long transparent;
        long delayTime;
        long inputFlag;
        long disposal;
}
GIF89;

#define MAX_STACK_SIZE  ((1 << (MAX_LWZ_BITS)) * 2)
#define MAX_TABLE_SIZE  (1 << MAX_LWZ_BITS)
typedef struct m_gifinfo
{
    GIF89 Gif89;
    long lGifLoc;
    long ZeroDataBlock;

/*
 **  Pulled out of nextCode
 */
    long curbit, lastbit, get_done;
    long last_byte;
    long return_clear;
/*
 **  Out of nextLWZ
 */
    unsigned short *pstack, *sp;
    long stacksize;
    long code_size, set_code_size;
    long max_code, max_code_size;
    long clear_code, end_code;

/*
 *   Were statics in procedures
 */
    unsigned char buf[280];
    unsigned short *table[2];
    long tablesize;
    long firstcode, oldcode;

} GIFINFO,*PGIFINFO;

typedef struct LIST
{
    PBYTE pbImage;
    long delayTime;
    LIST  *next;
}  LIST;

/*
 DirectAnimation wrapper class for GIF info
*/
class CImgGif
{
   // Class methods
   public:
      CImgGif(HANDLE hFile);
      ~CImgGif();

      BOOL          Read(unsigned char *buffer, DWORD len);
      long          ReadColorMap(long number, RGBQUAD *pRGB);
      long          DoExtension(long label);
      long          GetDataBlock(unsigned char *buf);
      HRESULT       ReadImage(long x, long y, long left, long top, long width, long height, long stride, int transparency, BOOL fInterlace, BOOL fGIFFrame, RGBQUAD *prgb, PBYTE pData);
      HRESULT       Dispose2(LPBYTE, long, long, long, long, long);
      HRESULT       Dispose3(LPBYTE, LPBYTE, long, long, long, long, long);
      long          readLWZ();
      long          nextLWZ();
      long          nextCode(long code_size);
      BOOL          initLWZ(long input_code_size);
      unsigned short *  growStack();
      BOOL          growTables();
      
   // Data members
   public:
      HANDLE              m_hFile;
      BOOL                m_fInterleaved;
      BOOL                m_fInvalidateAll;
      int                 m_yLogRow;
      GIFINFO             m_gifinfo;
      //int                 m_xWidth;
      //int                 m_yHeight;
      LONG                m_ITrans;
      LIST *              m_pList;    //header point to a circular link list
      LIST *              m_pListTail; //point to a circular link list
      GIFSCREEN           m_GifScreen;
      long                m_imageCount;
      DWORD               m_dwGIFVer;
        
      HRESULT ReadGIFMaster(VIDEOINFO *pvi);
      HRESULT OpenGIFFile ( LIST **ppList, CMediaType *pmt);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\stillvid\loadgif2.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: loadgif2.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// !!! support transparent GIFs by controlling background colour (black or
//     random is what you get now)
// !!! support getting gif size and frame count with IMediaDet?
// !!! support just using some frames from the GIF by supporting MediaTimes?
// !!! backwards playback would be easy

#include <streams.h>
#include "loadgif.h"

//*X* 
CImgGif::CImgGif( HANDLE hFile) 
{
   m_hFile      =hFile;
   
   m_pList      =NULL;
   m_pListTail  =NULL; 

   m_gifinfo.pstack = NULL;
   m_gifinfo.table[0] = NULL;
   m_gifinfo.table[1] = NULL;
}

CImgGif::~CImgGif() 
{
   free(m_gifinfo.pstack);
   free(m_gifinfo.table[0]);
   free(m_gifinfo.table[1]);
    
   //delete the (possibly) circular link list
   if(m_pList != NULL)
   {
        LIST *p=m_pList->next;

        while(m_pList !=p && p != NULL)
        {
            LIST *p1 = p->next;
            delete [] p->pbImage;
            delete p;
            p = p1;
        }
           
	delete [] m_pList->pbImage;
        delete m_pList;

        m_pList=NULL;
        m_pListTail=NULL;
   }          
    

}

#ifndef DEBUG
#pragma optimize("t",on)
#endif

BOOL CImgGif::Read(unsigned char *buffer, DWORD len)
{
    DWORD lenout = 0;
   
    BOOL b = ReadFile( m_hFile,
			buffer,				// pointer to buffer that receives daata
			len,		// Number of bytes to read
			&lenout,				// Munber of bytes read
			NULL);

    return (b && (lenout == len));
}

long CImgGif::ReadColorMap(long number, RGBQUAD *pRGB)
{
    long i;
    unsigned char rgb[3];

    for (i = 0; i < number; ++i)
    {
        if (!Read(rgb, sizeof(rgb)))
        {
        	DbgLog((LOG_TRACE, 1, TEXT("bad gif colormap\n")));
            return (TRUE);
        }

	// !!! SUPERBLACK is reserved for the transparency key - don't allow
	// it to actually appear in the bitmap
	// Converting to 16 bit makes anything < 8 turn into 0
	if (rgb[0] < 8 && rgb[1] < 8 && rgb[2] < 8) {
	    rgb[0] = 8;
	    rgb[1] = 8;
	    rgb[2] = 8;
	}

        pRGB[i].rgbRed   = rgb[0];
        pRGB[i].rgbGreen = rgb[1];
        pRGB[i].rgbBlue  = rgb[2];
        pRGB[i].rgbReserved = 255; // opaque

    }
    return FALSE;
}
//*X****************************************************
//  Called by nextCode(), nextLWZ(), DoExtension(), ReadImage()
//  m_ modified:  m_gifinfo.ZeroDataBlock
//*X*****************************************************
long CImgGif::GetDataBlock(unsigned char *buf)
{
   unsigned char count;

   count = 0;
   if (!Read(&count, 1))
   {
        return -1;
   }
   m_gifinfo.ZeroDataBlock = count == 0;

   if ((count != 0) && (!Read(buf, count)))
   {
        return -1;
   }

   return ((long) count);
}

#define MIN_CODE_BITS 5
#define MIN_STACK_SIZE 64
#define MINIMUM_CODE_SIZE 2
//*X****************************************************
//  Called by:    ReadImage()
//  m_ modified:  m_gifinfo.*
//*X*****************************************************
BOOL CImgGif::initLWZ(long input_code_size)
{
   if(input_code_size < MINIMUM_CODE_SIZE)
     return FALSE;

   m_gifinfo.set_code_size  = input_code_size;
   m_gifinfo.code_size      = m_gifinfo.set_code_size + 1;
   m_gifinfo.clear_code     = 1 << m_gifinfo.set_code_size;
   m_gifinfo.end_code       = m_gifinfo.clear_code + 1;
   m_gifinfo.max_code_size  = 2 * m_gifinfo.clear_code;
   m_gifinfo.max_code       = m_gifinfo.clear_code + 2;

   m_gifinfo.curbit         = m_gifinfo.lastbit = 0;
   m_gifinfo.last_byte      = 2;
   m_gifinfo.get_done       = FALSE;

   m_gifinfo.return_clear = TRUE;
    
    if(input_code_size >= MIN_CODE_BITS)
        m_gifinfo.stacksize = ((1 << (input_code_size)) * 2);
    else
        m_gifinfo.stacksize = MIN_STACK_SIZE;

    if ( m_gifinfo.pstack != NULL )
        free( m_gifinfo.pstack );
    if ( m_gifinfo.table[0] != NULL  )
        free( m_gifinfo.table[0] );
    if ( m_gifinfo.table[1] != NULL  )
        free( m_gifinfo.table[1] );

    m_gifinfo.table[0] = 0;
    m_gifinfo.table[1] = 0;
    m_gifinfo.pstack = 0;

    m_gifinfo.pstack = (unsigned short *) malloc((m_gifinfo.stacksize)*sizeof(unsigned short));
    if(m_gifinfo.pstack == 0){
        goto ErrorExit;
    }    
    m_gifinfo.sp = m_gifinfo.pstack;

    // Initialize the two tables.
    m_gifinfo.tablesize = (m_gifinfo.max_code_size);

    m_gifinfo.table[0] = (unsigned short *) malloc((m_gifinfo.tablesize)*sizeof(unsigned short));
    m_gifinfo.table[1] = (unsigned short *) malloc((m_gifinfo.tablesize)*sizeof(unsigned short));
    if((m_gifinfo.table[0] == 0) || (m_gifinfo.table[1] == 0)){
        goto ErrorExit;
    }

    return TRUE;

   ErrorExit:
    if(m_gifinfo.pstack){
        free(m_gifinfo.pstack);
        m_gifinfo.pstack = 0;
    }

    if(m_gifinfo.table[0]){
        free(m_gifinfo.table[0]);
        m_gifinfo.table[0] = 0;
    }

    if(m_gifinfo.table[1]){
        free(m_gifinfo.table[1]);
        m_gifinfo.table[1] = 0;
    }

    return FALSE;
}
//*X****************************************************
//  Called by:    nextLWZ()
//  m_ modified:  m_gifinfo.return_clea
//  m_ depends:  m_gifinfo.buf[0],m_gifinfo.clear_code
//               m_gifinfo.return_clea,m_gifinfo.curbi
//              m_gifinfo.lastbit, m_gifinfo.get_done
//*X*****************************************************
long CImgGif::nextCode(long code_size)
{
   static const long maskTbl[16] =
   {
          0x0000, 0x0001, 0x0003, 0x0007,
          0x000f, 0x001f, 0x003f, 0x007f,
          0x00ff, 0x01ff, 0x03ff, 0x07ff,
          0x0fff, 0x1fff, 0x3fff, 0x7fff,
   };
   long i, j, ret, end;
   unsigned char *buf = &m_gifinfo.buf[0];

   if (m_gifinfo.return_clear)
   {
        m_gifinfo.return_clear = FALSE;
        return m_gifinfo.clear_code;
   }

   end = m_gifinfo.curbit + code_size;

   if (end >= m_gifinfo.lastbit)
   {
        long count;

        if (m_gifinfo.get_done)
        {
            return -1;
        }
        buf[0] = buf[m_gifinfo.last_byte - 2];
        buf[1] = buf[m_gifinfo.last_byte - 1];

        if ((count = GetDataBlock(&buf[2])) == 0)
            m_gifinfo.get_done = TRUE;
        if (count < 0)
        {
            return -1;
        }
        m_gifinfo.last_byte = 2 + count;
        m_gifinfo.curbit = (m_gifinfo.curbit - m_gifinfo.lastbit) + 16;
        m_gifinfo.lastbit = (2 + count) * 8;

        end = m_gifinfo.curbit + code_size;

        // Okay, bug 30784 time. It's possible that we only got 1
        // measly byte in the last data block. Rare, but it does happen.
        // In that case, the additional byte may still not supply us with
        // enough bits for the next code, so, as Mars Needs Women, IE
        // Needs Data.
        if ( end >= m_gifinfo.lastbit && !m_gifinfo.get_done )
        {
        // protect ourselve from the ( theoretically impossible )
        // case where between the last data block, the 2 bytes from
        // the block preceding that, and the potential 0xFF bytes in
        // the next block, we overflow the buffer.
        // Since count should always be 1,
            ASSERT( count == 1 );
        // there should be enough room in the buffer, so long as someone
        // doesn't shrink it.
            if ( count + 0x101 >= sizeof( m_gifinfo.buf ) )
            {
                ASSERT ( FALSE ); // 
                return -1;
            }

            if ((count = GetDataBlock(&buf[2 + count])) == 0)
                m_gifinfo.get_done = TRUE;
            if (count < 0)
            {
              return -1;
            }
            m_gifinfo.last_byte += count;
            m_gifinfo.lastbit = m_gifinfo.last_byte * 8;

            end = m_gifinfo.curbit + code_size;
        }
   }

   j = end / 8;
   i = m_gifinfo.curbit / 8;

   if (i == j)
        ret = buf[i];
   else if (i + 1 == j)
        ret = buf[i] | (((long) buf[i + 1]) << 8);
   else
        ret = buf[i] | (((long) buf[i + 1]) << 8) | (((long) buf[i + 2]) << 16);

   ret = (ret >> (m_gifinfo.curbit % 8)) & maskTbl[code_size];

   m_gifinfo.curbit += code_size;

   return ret;
}

//*X****************************************************
//  Called by:    nextLWZ()
//  m_ modified:  m_gifinfo.*
//  m_ depends:  m_gifinfo.*
//*X*****************************************************
// Grows the stack and returns the top of the stack.
unsigned short * CImgGif::growStack()
{
    long index;
    unsigned short *lp;
    
    if (m_gifinfo.stacksize >= MAX_STACK_SIZE) return 0;

    index = (long)(m_gifinfo.sp - m_gifinfo.pstack);
    lp = (unsigned short *)realloc(m_gifinfo.pstack, (m_gifinfo.stacksize)*2*sizeof(unsigned short));
    if(lp == 0)
        return 0;
        
    m_gifinfo.pstack = lp;
    m_gifinfo.sp = &(m_gifinfo.pstack[index]);
    m_gifinfo.stacksize = (m_gifinfo.stacksize)*2;
    lp = &(m_gifinfo.pstack[m_gifinfo.stacksize]);
    return lp;
}

//*X****************************************************
//  Called by:    nextLWZ()
//  m_ modified:  m_gifinfo.table
//  m_ depends:  m_gifinfo.table
//*X*****************************************************
BOOL CImgGif::growTables()
{
    unsigned short *lp;

    lp = (unsigned short *) realloc(m_gifinfo.table[0], (m_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    m_gifinfo.table[0] = lp;
    
    lp = (unsigned short *) realloc(m_gifinfo.table[1], (m_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    m_gifinfo.table[1] = lp;

    return TRUE;

}
//*X****************************************************
//  Called by:    ReadImage()
//  m_ modified:  
//  m_ depends:  m_gifinfo.sp, m_gifinfo.pdysvk
//  Call:        nextLWZ()
//*X*****************************************************
inline long CImgGif::readLWZ()
{
   return((m_gifinfo.sp > m_gifinfo.pstack) ? *--(m_gifinfo.sp) : nextLWZ());
}

//*X****************************************************
//  Called by:    readLWZ() which is called by ReadImage() which is called by ReadGIFMaster()
//  m_ modified:  
//  m_ depends:  m_gifinfo.*
//  Call:        readCode(), growTables()
//*X*****************************************************
#define CODE_MASK 0xffff
long CImgGif::nextLWZ()
{
    long code, incode;
    unsigned short usi;
    unsigned short *table0 = m_gifinfo.table[0];
    unsigned short *table1 = m_gifinfo.table[1];
    unsigned short *pstacktop = &(m_gifinfo.pstack[m_gifinfo.stacksize]);

    while ((code = nextCode(m_gifinfo.code_size)) >= 0)
    {
        if (code == m_gifinfo.clear_code)
        {
            /* corrupt GIFs can make this happen */
            if (m_gifinfo.clear_code >= (1 << MAX_LWZ_BITS))
            {
                return -2;
            }

            
            m_gifinfo.code_size = m_gifinfo.set_code_size + 1;
            m_gifinfo.max_code_size = 2 * m_gifinfo.clear_code;
            m_gifinfo.max_code = m_gifinfo.clear_code + 2;

            if(!growTables())
                return -2;
                    
            table0 = m_gifinfo.table[0];
            table1 = m_gifinfo.table[1];

            m_gifinfo.tablesize = m_gifinfo.max_code_size;


            for (usi = 0; usi < m_gifinfo.clear_code; ++usi)
            {
                table1[usi] = usi;
            }
            memset(table0,0,sizeof(unsigned short )*(m_gifinfo.tablesize));
            memset(&table1[m_gifinfo.clear_code],0,sizeof(unsigned short)*((m_gifinfo.tablesize)-m_gifinfo.clear_code));
            m_gifinfo.sp = m_gifinfo.pstack;
            do
            {
                    m_gifinfo.firstcode = m_gifinfo.oldcode = nextCode(m_gifinfo.code_size);
            }
            while (m_gifinfo.firstcode == m_gifinfo.clear_code);
            return m_gifinfo.firstcode;
        }

        if (code == m_gifinfo.end_code)
        {
            long count;
            unsigned char buf[260];

            if (m_gifinfo.ZeroDataBlock)
            {
                    return -2;
            }

            while ((count = GetDataBlock(buf)) > 0)
                    ;

            if (count != 0)
            return -2;
        }

        incode = code;

        if (code >= m_gifinfo.max_code)
        {
            if (m_gifinfo.sp >= pstacktop)
            {
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
            }
            *(m_gifinfo.sp)++ = (unsigned short)((CODE_MASK ) & (m_gifinfo.firstcode));
            code = m_gifinfo.oldcode;
        }

        while (code >= m_gifinfo.clear_code)
        {
            if (m_gifinfo.sp >= pstacktop)
            {
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
            }
            *(m_gifinfo.sp)++ = table1[code];
            if (code == (long)(table0[code]))
            {
                return (code);
            }
            code = (long)(table0[code]);
        }

        if (m_gifinfo.sp >= pstacktop){
            pstacktop = growStack();
            if(pstacktop == 0)
                return -2;
        }

        m_gifinfo.firstcode = (long)table1[code];
        *(m_gifinfo.sp)++ = table1[code];

        if ((code = m_gifinfo.max_code) < (1 << MAX_LWZ_BITS))
        {
            table0[code] = (unsigned short)((m_gifinfo.oldcode) & CODE_MASK);
            table1[code] = (unsigned short)((m_gifinfo.firstcode) & CODE_MASK);
            ++m_gifinfo.max_code;
            if ((m_gifinfo.max_code >= m_gifinfo.max_code_size) && (m_gifinfo.max_code_size < ((1 << MAX_LWZ_BITS))))
            {
                m_gifinfo.max_code_size *= 2;
                ++m_gifinfo.code_size;
                if(!growTables())
                    return -2;
       
                table0 = m_gifinfo.table[0];
                table1 = m_gifinfo.table[1];

                // Tables have been reallocated to the correct size but initialization
                // still remains to be done. This initialization is different from
                // the first time initialization of these tables.
                memset(&(table0[m_gifinfo.tablesize]),0,
                    sizeof(unsigned short )*(m_gifinfo.max_code_size - m_gifinfo.tablesize));

                memset(&(table1[m_gifinfo.tablesize]),0,
                    sizeof(unsigned short )*(m_gifinfo.max_code_size - m_gifinfo.tablesize));

                m_gifinfo.tablesize = (m_gifinfo.max_code_size);
            }
        }

        m_gifinfo.oldcode = incode;

        if (m_gifinfo.sp > m_gifinfo.pstack)
            return ((long)(*--(m_gifinfo.sp)));
    }
    return code;
}

#ifndef DEBUG
// Return to default optimization flags
#pragma optimize("",on)
#endif

//*X****************************************************
//  Called by:    ReadGIFMaster()
//  m_ modified:  
//  m_ depends:  
//  Call: GetDataBlack(), initLWZ()
//*X*****************************************************
//
// This function will fill pbImage with a 32 bit RGB decoding of the GIF.
// left, top, width, height are in pixels, stride is in bytes
//
HRESULT CImgGif::ReadImage(long w, long h, long left, long top, long width, long height, long stride, int trans, BOOL fInterlace, BOOL fGIFFrame, RGBQUAD *prgb, PBYTE pbImage)
{
    unsigned char *dp, c;
    long v;
   long xpos = 0, ypos = 0;
    // long padlen = ((len + 3) / 4) * 4;
    DWORD cbImage = 0;
    char buf[256]; // need a buffer to read trailing blocks (up to terminator)

    /*
       ** Initialize the Compression routines
    */
    if (!Read(&c, 1))
    {
        return (NULL);
    }

    /*
       **  If this is an "uninteresting picture" ignore it.
    */
    // !!! height is not the image height, it's smaller
    cbImage = stride * height * sizeof(char);

    if (c == 1)
    {
        // Netscape seems to field these bogus GIFs by filling treating them
        // as transparent. While not the optimal way to simulate this effect,
        // we'll fake it by pushing the initial code size up to a safe value,
        // consuming the input, and returning a buffer full of the transparent
        // color or zero, if no transparency is indicated.
        if (initLWZ(MINIMUM_CODE_SIZE))
            while (readLWZ() >= 0);
        else {
             DbgLog((LOG_TRACE, 1, TEXT("GIF: failed LZW decode.\n")));
             //RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
        }

        if (m_gifinfo.Gif89.transparent != -1)
            FillMemory(pbImage, cbImage, (unsigned char)m_gifinfo.Gif89.transparent);
        else // fall back on the background color 
            FillMemory(pbImage, cbImage, 0);
                
        return NOERROR;
    }
    else if (initLWZ(c) == FALSE)
    {
        DbgLog((LOG_TRACE, 1, TEXT("GIF: failed LZW decode.\n")));
        //RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
        return NULL;
    }

    // go to the first pixel we care about
    pbImage += stride * top + left * 4;

    if (fInterlace)
    {
        //*X* image is interlaced
        long i;
        long pass = 0, step = 8;

        if (!fGIFFrame && (height > 4))
            m_fInterleaved = TRUE;

        for (i = 0; i < height; i++)
        {
            dp = &pbImage[stride * ((height-1) - ypos)];
            for (xpos = 0; xpos < width; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                // the GIF may be asking us to fill in bits off screen that
                // will fault, but we still need to read them from the stream
                if (left + xpos < w && top + (height - 1) - ypos < h) {
		    if (v != trans)
                        *((RGBQUAD *)dp) = prgb[v];
		    dp+=4;
                }
            }
            ypos += step;
            while (ypos >= height)
            {
                if (pass++ > 0)
                    step /= 2;
                ypos = step / 2;
            }
            if (!fGIFFrame)
            {
                m_yLogRow = i;

            }
        }

        if (!fGIFFrame && height <= 4)
        {
            m_yLogRow = height-1;
        }
    }
    else
    {

        if (!fGIFFrame) 
            m_yLogRow = -1;

        for (ypos = height-1; ypos >= 0; ypos--)
        {
            dp = &pbImage[stride * ypos];
            for (xpos = 0; xpos < width; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                // the GIF may be asking us to fill in bits off screen that
                // will fault, but we still need to read them from the stream
                if (left + xpos < w && top + ypos < h) {
		    if (v != trans)
                        *((RGBQUAD *)dp) = prgb[v];
		    dp+=4;
                }

            }
            if (!fGIFFrame)
            {
                m_yLogRow++;
            }
        }

    }

    // consume blocks up to image block terminator so we can proceed to the next image
    while (GetDataBlock((unsigned char *) buf) > 0)
               ;

    return NOERROR;

abort:
    return ERROR;
}


// This will zero out a sub rect of 32bpp pbImage, required for dispose method 2
//
HRESULT CImgGif::Dispose2(LPBYTE pbImage, long stride, long Left, long Top, long Width, long Height)
{
    for (long z = Top; z < Top + Height; z++) {
    	LPDWORD pdw = (LPDWORD)(pbImage + z * stride + Left * 4);
	for (long y = 0; y < Width; y++) {
    	    *pdw++ = 0;
	}
    }
    return S_OK;
}


// This will copy a sub rect from one 32bpp image to another, required for
// dispose method 3
//
HRESULT CImgGif::Dispose3(LPBYTE pbImage, LPBYTE pbSrc, long stride, long Left, long Top, long Width, long Height)
{
    for (long z = Top; z < Top + Height; z++) {
    	LPDWORD pdwDest = (LPDWORD)(pbImage + z * stride + Left * 4);
    	LPDWORD pdwSrc = (LPDWORD)(pbSrc + z * stride + Left * 4);
	for (long y = 0; y < Width; y++) {
    	    *pdwDest++ = *pdwSrc++;
	}
    }
    return S_OK;
}


//*X****************************************************
//  Called by:    ReadGIFMaster()
//  m_ modified:  
//  m_ depends:  
//  Call: GetDataBlack(), memcmp(), initLWZ()
//  We should consume all extension bits, but do nothing about it.
//*X*****************************************************
long CImgGif::DoExtension(long label)
{
    unsigned char buf[256];
    int count;

    switch (label)
    {
        case 0x01:              /* Plain Text Extension */
            break;
        case 0xff:              /* Application Extension */
            // Is it the Netscape looping extension
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 11)
            {
                char *szNSExt = "NETSCAPE2.0";

                if ( memcmp( buf, szNSExt, strlen( szNSExt ) ) == 0 )
                { // if it has their signature, get the data subblock with the iter count
                    count = GetDataBlock((unsigned char *) buf);
                }
            }
            //*X* consume all bits
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
            break;
        case 0xfe:              /* Comment Extension */
            while (GetDataBlock((unsigned char *) buf) > 0)
            {
                DbgLog((LOG_TRACE, 1, TEXT("GIF comment: %s\n"), buf));
            }
            return FALSE;
        case 0xf9:              /* Graphic Control Extension */
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 3)
            {
                m_gifinfo.Gif89.disposal = (buf[0] >> 2) & 0x7;
                DbgLog((LOG_TRACE,3,TEXT("disposal=%d"),
					(int)m_gifinfo.Gif89.disposal));
                m_gifinfo.Gif89.inputFlag = (buf[0] >> 1) & 0x1;
                m_gifinfo.Gif89.delayTime = LM_to_uint(buf[1], buf[2]);
                if ((buf[0] & 0x1) != 0) {
                    m_gifinfo.Gif89.transparent = buf[3];
                    DbgLog((LOG_TRACE,3,TEXT("transparency=%d"), (int)buf[3]));
                } else {
                    m_gifinfo.Gif89.transparent = -1;
		}
            }
            DbgLog((LOG_TRACE,3,TEXT("count=%d (%d,%d,%d,%d)"), count,
				(int)buf[0],
				(int)buf[1],
				(int)buf[2],
				(int)buf[3]));
            while ((count = GetDataBlock((unsigned char *) buf)) > 0)
                DbgLog((LOG_TRACE,3,TEXT("count=%d"), count));
                ;
            return FALSE;
        default:
            DbgLog((LOG_TRACE,3,TEXT("UNKNOWN BLOCK")));
            break;
    }

    while ((count = GetDataBlock((unsigned char *) buf)) > 0)
        DbgLog((LOG_TRACE,3,TEXT("count=%d"), count));
        ;

    return FALSE;
}

//*X****************************************************
//  Called by:    ReadGIFMaster()
//  Call:
//*X*****************************************************
BOOL IsGifHdr(BYTE * pb)
{
    return(pb[0] == 'G' && pb[1] == 'I' && pb[2] == 'F'
        && pb[3] == '8' && (pb[4] == '7' || pb[4] == '9') && pb[5] == 'a');
}

//*X****************************************************
//  Called by:    BIT_Make_DIB_PAL_Header(), BIT_Make_DIB_RGB_Header_Screen()
////*X*****************************************************
void BuildBitMapInfoHeader(LPBITMAPINFOHEADER lpbi
                            , int xsize
                            , int ysize
                            , long BitCount
                            , WORD biClrUsed )
{
    lpbi->biSize = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth = xsize;
    lpbi->biHeight = ysize;
    lpbi->biPlanes = 1;
    lpbi->biBitCount = (WORD)BitCount;
    lpbi->biCompression = BI_RGB;         /* no compression */
    lpbi->biSizeImage = 0;                /* not needed when not compressed */
    lpbi->biXPelsPerMeter = 0;
    lpbi->biYPelsPerMeter = 0;
    lpbi->biClrUsed = biClrUsed;
    lpbi->biClrImportant = 0;
}
//*X****************************************************
//  Called by:  
//  m_ modified:  ,
//  m_ depends:  
//  Call: ReadColorMap(), Read(),IsGifHdr(),
//*X*****************************************************
HRESULT CImgGif::ReadGIFMaster( VIDEOINFO *pvi)
{
    CheckPointer(pvi, E_POINTER);

    unsigned char buf[16];
    unsigned char c;
    bool useGlobalColormap;
    long imageNumber = 1;   //*X* Const. 
    long NumColors; 
    WORD bitCount, gBitCount;
    HRESULT hr=ERROR;
    // to store the GIF global palette and each local frame palette
    RGBQUAD rgbGlobal[256];
    RGBQUAD rgbLocal[256];
    int disposal = 1;  // default to no disposal
    long oldLeft, oldTop, oldWidth, oldHeight;
    LIST *pListOldTail = NULL;
    ASSERT(m_pList == NULL);
    ASSERT(m_pListTail == NULL);

    LPBITMAPINFOHEADER lpbi = HEADER(pvi);

        //*X* read to get media type, and init m_gifinfo, m_GifScreen

        //*X* i add
        m_dwGIFVer=dwGIFVerUnknown;
    
        //*X* m_gifinfo is CimgGif's private var which holds all gif infomation
        m_gifinfo.ZeroDataBlock = 0;

        /*
        * Initialize GIF89 extensions
        */
        m_gifinfo.Gif89.transparent = -1;
        m_gifinfo.Gif89.delayTime   = 10;
        m_gifinfo.Gif89.inputFlag   = -1;
        m_gifinfo.Gif89.disposal    = disposal;
        m_gifinfo.lGifLoc           = 0;


        //*X* read len(6) characters into buffer 
        if (!Read(buf, 6))
        {
            DbgLog((LOG_TRACE, 1, TEXT("GIF: error reading magic number\n")));
            goto exitPoint;
        }

        //*X* check whether it is a gif file GIF87/9a
        if (!IsGifHdr(buf)) {
            DbgLog((LOG_TRACE, 1, TEXT("GIF: Malformed header\n")));
            goto exitPoint;
        }


        //*X* 
        m_dwGIFVer = (buf[4] == '7') ? dwGIFVer87a : dwGIFVer89a;

        //*X* read len(7) characters into buffer 
        if (!Read(buf, 7))
        {
            DbgLog((LOG_TRACE, 1, TEXT("GIF: failed to read screen descriptor\n")));
            //RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
            goto exitPoint;
        }
    
        //*X* get video config
        m_GifScreen.Width = LM_to_uint(buf[0], buf[1]);
        m_GifScreen.Height = LM_to_uint(buf[2], buf[3]);

        m_GifScreen.NumColors = 2 << (buf[4] & 0x07);
        // gBitCount   =(buf[4] & 0x07)+1;
	gBitCount = 8;
        //m_GifScreen.ColorResolution = (((buf[4] & 0x70) >> 3) + 1);
        m_GifScreen.Background = buf[5];
//!!!
        m_GifScreen.AspectRatio = buf[6];

        DbgLog((LOG_TRACE, 2, TEXT("GIF FILE: (%d,%d) %d\n"),
			(int)m_GifScreen.Width, (int)m_GifScreen.Height,
			(int)buf[4]));
    
        //*X* color map in this GIF file
        if (BitSet(buf[4], LOCALCOLORMAP))
        {      
             /* Global Colormap */

            if (ReadColorMap(m_GifScreen.NumColors, rgbGlobal))
            {
                DbgLog((LOG_TRACE, 1, TEXT("error reading global colormap\n")));
                goto exitPoint;
            }
           
        }


        //*X* ch