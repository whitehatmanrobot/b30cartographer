*************************************************
//
//  SQLLEX.H
//
//  SQL Level 1 DFA Table & Tokens
//
//  Copyright 1998 Microsoft Corporation
//
//***************************************************************************


#ifndef _SQLLEX_H_

#define SQL_1_TOK_EOF       0
#define SQL_1_TOK_ERROR     1
#define SQL_1_TOK_IDENT     100
#define SQL_1_TOK_QSTRING   101
#define SQL_1_TOK_INT       102
#define SQL_1_TOK_REAL      103
#define SQL_1_TOK_CHAR      104

#define SQL_1_TOK_LE        105
#define SQL_1_TOK_LT        106
#define SQL_1_TOK_GE        107
#define SQL_1_TOK_GT        108
#define SQL_1_TOK_EQ        109
#define SQL_1_TOK_NE        110

#define SQL_1_TOK_DOT           111
#define SQL_1_TOK_OPEN_PAREN    112
#define SQL_1_TOK_CLOSE_PAREN   113
#define SQL_1_TOK_ASTERISK      114
#define SQL_1_TOK_COMMA         115

#define SQL_1_TOK_SELECT        120
#define SQL_1_TOK_WHERE         121
#define SQL_1_TOK_FROM          122
#define SQL_1_TOK_LIKE          123
#define SQL_1_TOK_OR            124
#define SQL_1_TOK_AND           125
#define SQL_1_TOK_NOT           126
#define SQL_1_TOK_IS            127
#define SQL_1_TOK_NULL          128

extern LexEl Sql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\inc\sqleval.h ===
#ifndef __provider_sql_eval_lib__
#define __provider_sql_eval_lib__
#if _MSC_VER > 1000
#pragma once
#endif 

#include <wbemprov.h>
#include <objbase.h>
#include <list>
using namespace std;
struct SQL_LEVEL_1_RPN_EXPRESSION;
// object to be evaluated by sql eval
// a CSqlEvalee is provided based on IWbemClassObject
// To Evaluate different object, provide your class inherit from
// CSqlEvalee

class CSqlEvalee
{
public:
	virtual const VARIANT* Get(WCHAR*)=0;
};

class CSqlWmiEvalee : public CSqlEvalee
{
protected:
	IWbemClassObject* m_pInstance;
	VARIANT m_v;
public:
	CSqlWmiEvalee(
		IWbemClassObject*);
	~CSqlWmiEvalee();
	const VARIANT* Get(WCHAR*);
};
// sql eval
class CQueryEnumerator;

class CSqlEval
{
	
public:
	virtual BOOL Evaluate(CSqlEvalee*);
	virtual ~CSqlEval(){};
	virtual void GenerateQueryEnum(CQueryEnumerator&){};
	static CSqlEval* CreateClass(
		SQL_LEVEL_1_RPN_EXPRESSION*,
		int* );
};

class CSqlEvalAnd : public CSqlEval
{
public:
	BOOL Evaluate(CSqlEvalee*);
	CSqlEvalAnd(
		SQL_LEVEL_1_RPN_EXPRESSION*,
		int* );
	void GenerateQueryEnum(CQueryEnumerator&);
	virtual ~CSqlEvalAnd();
protected:
	CSqlEval* m_left;
	CSqlEval* m_right;

};

class CSqlEvalOr: public CSqlEval
{
public:
	BOOL Evaluate(CSqlEvalee*);
	CSqlEvalOr(
		SQL_LEVEL_1_RPN_EXPRESSION*,
		int* );
	void GenerateQueryEnum(CQueryEnumerator&);
	virtual ~CSqlEvalOr();
protected:
	CSqlEval* m_left;
	CSqlEval* m_right;

};

class CSqlEvalNot: public CSqlEval
{
public:
	BOOL Evaluate(CSqlEvalee*);
	CSqlEvalNot(
		SQL_LEVEL_1_RPN_EXPRESSION*,
		int* );
	virtual ~CSqlEvalNot();
	void GenerateQueryEnum(CQueryEnumerator&);
protected:
	CSqlEval* m_exp;
};

class CSqlEvalExp: public CSqlEval
{
	enum DATATYPE{IntergerType, StringType};
public:
	BOOL Evaluate(CSqlEvalee*);
	CSqlEvalExp(
		SQL_LEVEL_1_RPN_EXPRESSION*,
		int* );
	~CSqlEvalExp();
protected:
	virtual void GenerateQueryEnum(CQueryEnumerator&);
	BSTR m_BstrName;
	VARIANT m_v;
	int m_op;
	DWORD m_dw;
	BSTR m_bstr;
	int m_DataType;
};


class CQueryEnumerator
{
	friend CSqlEvalExp;
	friend CSqlEvalAnd;
	friend CSqlEvalOr;
	friend CSqlEvalNot;
	enum{INITIAL_SIZE = 10};
	class CStringArray
	{
	protected:
		WCHAR** m_ppWstr;
		int m_cNumString;
		BOOL m_bIsNull;
		BOOL	StringArrayCopy(
			WCHAR***,
			WCHAR**,
			int cArgs);

	public:
		CStringArray();
		~CStringArray();
		CStringArray(CStringArray&);
		CStringArray(
			WCHAR**,
			int cNumString);
		CStringArray& operator=(CStringArray&);
		int Size();
		BOOL IsNULL(){return m_bIsNull;};
		void Merge(CStringArray&);
		const WCHAR** Data();

	};
protected:
	void ArrayMerge(
		CStringArray&);
	void ArrayDelete();
	void ArrayAdd(CStringArray&);
	CStringArray	m_QueryFields;
	CStringArray*	m_QuerySet;
	int			m_cNumOfRecordInSet;
	int			m_index;
	int		m_MaxSize;


public:
	CQueryEnumerator(
		WCHAR**,	//array of string identifying the name fields to
					//be queried
		int cArg	// number of argument
		);
	CQueryEnumerator(CQueryEnumerator&);
	
	void And(CQueryEnumerator&);
	void Or(CQueryEnumerator&);
	virtual ~CQueryEnumerator();
//	DWORD InitEnumerator(
//		WCHAR**,	//array of string identifying the name fields to
//					//be queried
//		int cArg,	// number of argument
//		CSqlEval*);
	const WCHAR** GetNext(int&);
	void Reset(void);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\zonerpc.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zonerpc.c

Abstract:

    Domain Name System (DNS) Server

    Zone RPC routines for admin tool.

Author:

    Jim Gilroy (jamesg)     October, 1995

Revision History:

--*/


#include "dnssrv.h"

#include "ds.h"

#include "rpcw2k.h"     //  downlevel Windows 2000 RPC functions


#define MAX_RPC_ZONE_COUNT_DEFAULT          65536
#define MAX_RPC_ZONE_ALLOCATION_RETRIES     7


DNS_STATUS
Rpc_WriteRootHints(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );



//
//  Zone RPC Utilities
//

VOID
freeZoneList(
    IN OUT  PDNS_RPC_ZONE_LIST  pZoneList
    )
/*++

Routine Description:

    Deep free of list of DNS_RPC_ZONE structures.

Arguments:

    pZoneList -- ptr RPC_ZONE_LIST structure to free

Return Value:

    None

--*/
{
    DWORD           i;
    PDNS_RPC_ZONE   pzone;

    if ( !pZoneList )
    {
        return;
    }

    for ( i = 0; i < pZoneList->dwZoneCount; ++i )
    {
        pzone = pZoneList->ZoneArray[ i ];
        if ( pzone )
        {
            MIDL_user_free( pzone->pszZoneName );
            MIDL_user_free( pzone->pszDpFqdn );
            MIDL_user_free( pzone );
        }
    }
    MIDL_user_free( pZoneList );
}



PDNS_RPC_ZONE
allocateRpcZone(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Allocate \ create RPC zone struct for zone.

Arguments:

    pZone -- zone to create RPC zone struct for

Return Value:

    RPC zone struct.
    NULL on allocation failure.

--*/
{
    PDNS_RPC_ZONE   prpcZone;

    DNS_DEBUG( RPC2, ( "allocateRpcZone( %s )\n", pZone->pszZoneName ));

    //  allocate and attach zone

    prpcZone = ( PDNS_RPC_ZONE ) MIDL_user_allocate( sizeof(DNS_RPC_ZONE) );
    if ( !prpcZone )
    {
        return NULL;
    }

    prpcZone->dwRpcStructureVersion = DNS_RPC_ZONE_VER;

    //  copy zone name

    prpcZone->pszZoneName = Dns_StringCopyAllocate_W(
                                    pZone->pwsZoneName,
                                    0 );
    if ( !prpcZone->pszZoneName )
    {
        MIDL_user_free( prpcZone );
        return NULL;
    }

    //  set type and flags

    prpcZone->ZoneType = (UCHAR) pZone->fZoneType;
    prpcZone->Version  = DNS_RPC_VERSION;

    *(PDWORD) &prpcZone->Flags = 0;

    if ( pZone->fPaused )
    {
        prpcZone->Flags.Paused = TRUE;
    }
    if ( IS_ZONE_SHUTDOWN( pZone ) )
    {
        prpcZone->Flags.Shutdown = TRUE;
    }
    if ( pZone->fReverse )
    {
        prpcZone->Flags.Reverse = TRUE;
    }
    if ( pZone->fAutoCreated )
    {
        prpcZone->Flags.AutoCreated = TRUE;
    }
    if ( pZone->fDsIntegrated )
    {
        prpcZone->Flags.DsIntegrated = TRUE;
    }
    if ( pZone->bAging )
    {
        prpcZone->Flags.Aging = TRUE;
    }

    //  two bits reserved for update

    prpcZone->Flags.Update = pZone->fAllowUpdate;

    //  Directory partition members

    if ( !pZone->pDpInfo )
    {
        prpcZone->dwDpFlags = DNS_DP_LEGACY & DNS_DP_ENLISTED;
        prpcZone->pszDpFqdn = NULL;
    }
    else
    {
        prpcZone->dwDpFlags = ZONE_DP( pZone )->dwFlags;
        prpcZone->pszDpFqdn = Dns_StringCopyAllocate_A(
                                        ZONE_DP( pZone )->pszDpFqdn,
                                        0 );
    }

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcZone(
            "New zone for RPC: ",
            prpcZone );
    }
    return prpcZone;
}



VOID
freeRpcZoneInfo(
    IN OUT  PDNS_RPC_ZONE_INFO  pZoneInfo
    )
/*++

Routine Description:

    Deep free of DNS_RPC_ZONE_INFO structure.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( !pZoneInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - name string
    //      - data file string
    //      - secondary IP array
    //      - WINS server array
    //  then zone info itself
    //

    MIDL_user_free( pZoneInfo->pszZoneName );
    MIDL_user_free( pZoneInfo->pszDataFile );
    MIDL_user_free( pZoneInfo->aipMasters );
    MIDL_user_free( pZoneInfo->aipSecondaries );
    MIDL_user_free( pZoneInfo->aipNotify );
    MIDL_user_free( pZoneInfo->aipScavengeServers );
    MIDL_user_free( pZoneInfo->pszDpFqdn );
    MIDL_user_free( pZoneInfo->pwszZoneDn );
    MIDL_user_free( pZoneInfo );
}



PDNS_RPC_ZONE_INFO
allocateRpcZoneInfo(
    IN      PZONE_INFO  pZone
    )
/*++

Routine Description:

    Create RPC zone info to return to admin client.

Arguments:

    pZone -- zone

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE_INFO  pzoneInfo;

    pzoneInfo = MIDL_user_allocate_zero( sizeof( DNS_RPC_ZONE_INFO ) );
    if ( !pzoneInfo )
    {
        goto done_failed;
    }

    //
    //  fill in fixed fields
    //

    pzoneInfo->dwZoneType           = pZone->fZoneType;
    pzoneInfo->fReverse             = pZone->fReverse;
    pzoneInfo->fAutoCreated         = pZone->fAutoCreated;
    pzoneInfo->fAllowUpdate         = pZone->fAllowUpdate;
    pzoneInfo->fUseDatabase         = pZone->fDsIntegrated;
    pzoneInfo->fSecureSecondaries   = pZone->fSecureSecondaries;
    pzoneInfo->fNotifyLevel         = pZone->fNotifyLevel;

    pzoneInfo->fPaused              = IS_ZONE_PAUSED( pZone );
    pzoneInfo->fShutdown            = IS_ZONE_SHUTDOWN( pZone );
    pzoneInfo->fUseWins             = IS_ZONE_WINS( pZone );
    pzoneInfo->fUseNbstat           = IS_ZONE_NBSTAT( pZone );

    pzoneInfo->fAging               = pZone->bAging;
    pzoneInfo->dwNoRefreshInterval  = pZone->dwNoRefreshInterval;
    pzoneInfo->dwRefreshInterval    = pZone->dwRefreshInterval;
    pzoneInfo->dwAvailForScavengeTime =
                    pZone->dwAgingEnabledTime + pZone->dwRefreshInterval;

    if ( IS_ZONE_FORWARDER( pZone ) )
    {
        pzoneInfo->dwForwarderTimeout   = pZone->dwForwarderTimeout;
        pzoneInfo->fForwarderSlave      = pZone->fForwarderSlave;
    }

    //
    //  fill in zone name
    //

    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pzoneInfo->pszZoneName,
                pZone->pszZoneName ) )
    {
        goto done_failed;
    }

    //
    //  database filename
    //

#ifdef FILE_KEPT_WIDE
    if ( ! RpcUtil_CopyStringToRpcBufferEx(
                &pzoneInfo->pszDataFile,
                pZone->pszDataFile,
                TRUE,       // unicode in
                FALSE       // UTF8 out
                ) )
    {
        goto done_failed;
    }
#else
    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pzoneInfo->pszDataFile,
                pZone->pszDataFile ) )
    {
        goto done_failed;
    }
#endif

    //
    //  master list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipMasters,
                pZone->aipMasters ) )
    {
        goto done_failed;
    }

    //
    //  local master list for stub zones
    //

    if ( IS_ZONE_STUB( pZone ) &&
        ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipLocalMasters,
                pZone->aipLocalMasters ) )
    {
        goto done_failed;
    }

    //
    //  secondary and notify lists
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipSecondaries,
                pZone->aipSecondaries ) )
    {
        goto done_failed;
    }
    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipNotify,
                pZone->aipNotify ) )
    {
        goto done_failed;
    }

    //
    //  scavenging servers
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipScavengeServers,
                pZone->aipScavengeServers ) )
    {
        goto done_failed;
    }

    //
    //  Directory partition members.
    //

    if ( pZone->pDpInfo )
    {
        pzoneInfo->dwDpFlags = ( ( PDNS_DP_INFO ) pZone->pDpInfo )->dwFlags;
        if ( ( ( PDNS_DP_INFO ) pZone->pDpInfo )->pszDpFqdn )
        {
            if ( ! RpcUtil_CopyStringToRpcBuffer(
                        &pzoneInfo->pszDpFqdn,
                        ( ( PDNS_DP_INFO ) pZone->pDpInfo )->pszDpFqdn ) )
            {
                goto done_failed;
            }
        }
    }
    else if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        pzoneInfo->dwDpFlags = DNS_DP_LEGACY | DNS_DP_ENLISTED;
    }

    if ( pZone->pwszZoneDN )
    {
        pzoneInfo->pwszZoneDn = Dns_StringCopyAllocate_W(
                                        pZone->pwszZoneDN,
                                        0 );
    }

    //
    //  xfr time info
    //

    if ( IS_ZONE_SECONDARY( pZone ) )
    {
        pzoneInfo->dwLastSuccessfulXfr = pZone->dwLastSuccessfulXfrTime;
        pzoneInfo->dwLastSuccessfulSoaCheck = pZone->dwLastSuccessfulSoaCheckTime;
    }


    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneInfo(
            "RPC zone info leaving allocateRpcZoneInfo():\n",
            pzoneInfo );
    }
    return pzoneInfo;

done_failed:

    //  free newly allocated info block

    freeRpcZoneInfo( pzoneInfo );
    return NULL;
}



//
//  Zone type conversion
//

DNS_STATUS
Rpc_ZoneResetToDsPrimary(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwLoadOptions,
    IN      DWORD           dwDpFlags,
    IN      LPSTR           pszDpFqdn
    )
/*++

Routine Description:

    Reset zone to DS integrated primary.

    Assumes zone is locked for update.

Arguments:

    pZone -- zone to make DS primary

    dwLoadOptions -- load options to\from DS

    dwDpFlags -- DP flags for specifying built-in DP as target

    pszDpFqdn -- DP FQDN for specifying custom DP as target

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DWORD           oldType = pZone->fZoneType;
    BOOL            oldDsIntegrated = pZone->fDsIntegrated;
    PWSTR           pwszoldFileName = NULL;
    PDNS_DP_INFO    pdp;

    ASSERT( pZone && pZone->pszZoneName && pZone->fLocked );

    DNS_DEBUG( RPC, (
        "Rpc_ZoneResetToDsPrimary( %s ):\n"
        "    load options   = 0x%08X\n"
        "    DP flags       = 0x%08X\n"
        "    DP FQDN        = %s\n",
        pZone->pszZoneName,
        dwLoadOptions,
        dwDpFlags,
        pszDpFqdn ));

    //
    //  Not-auth zones cannot be converted to primary because
    //  we don't have a copy of the zone data locally.
    //

    if ( IS_ZONE_NOTAUTH( pZone ) )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    if ( pZone->pwsDataFile )
    {
        pwszoldFileName = Dns_StringCopyAllocate_W( pZone->pwsDataFile, 0 );
    }

    //
    //  verify that have data
    //      - may have secondary that has not received a transfer
    //

    if ( !IS_ZONE_CACHE( pZone ) &&
         ( !pZone->pSoaRR || IS_ZONE_EMPTY( pZone ) ) )
    {
        ASSERT( IS_ZONE_SECONDARY( pZone ) );
        ASSERT( !pZone->pSoaRR );
        ASSERT( IS_ZONE_EMPTY( pZone ) );

        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  if already DS integrated -- done
    //

    if ( pZone->fDsIntegrated )
    {
        if ( pZone->fZoneType == DNS_ZONE_TYPE_SECONDARY ||
             IS_ZONE_CACHE( pZone ) )
        {
            ASSERT( FALSE );
            status = DNS_ERROR_INVALID_TYPE;
            goto Done;
        }

        //
        //  This function does not move zones between partitions, so if the
        //  zone is already DS-integrated but it not currently located in
        //  the specified target partition, return an error.
        //

        if ( Dp_FindPartitionForZone(
                dwDpFlags,
                pszDpFqdn,
                FALSE,                      //  auto-create allowed
                &pdp ) != ERROR_SUCCESS ||
             pdp != pZone->pDpInfo )
        {
            status = DNS_ERROR_INVALID_PROPERTY;
            goto Done;
        }

        status = ERROR_SUCCESS;
        goto Done;
    }

    //  verify can use DS -- or don't bother
    //      - don't wait for open
    //      - don't log error if can not open

    status = Ds_OpenServer( 0 );
    if ( status != ERROR_SUCCESS )
    {
        status = DNS_ERROR_DS_UNAVAILABLE;
        goto Done;
    }

    //
    //  Reset zone type but not for the root hint zone.
    //
    
    if ( !IS_ZONE_CACHE( pZone ) )
    {
        pZone->fZoneType = DNS_ZONE_TYPE_PRIMARY;
    }

    //
    //  temporarily convert to DS integrated and attempt load operation
    //  essentially three types of attempts:
    //      default (0 flag)    -- attempt to write back zone, fails if zone exists
    //      overwrite DS        -- write back zone, deleting current DS if exists
    //      overwrite memory    -- load zone from DS, delete memory if successful
    //
    //  note:  can have separate primary\secondary blocks if
    //  want to limit secondary semantics
    //      -- only write if nothing there, otherwise read (exclude DS dump possiblity)
    //      -- read if in DS, otherwise fail
    //

    pZone->fDsIntegrated = TRUE;

    //
    //  Reset zone's type and database.
    //

    if ( !IS_ZONE_CACHE( pZone ) )
    {
        //
        //  This step is not required for the root hints zone.
        //
        
        status = Zone_ResetType(
                    pZone,
                    DNS_ZONE_TYPE_PRIMARY,
                    NULL );                     //  masters
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }
    }

    status = Zone_DatabaseSetup(
                pZone,
                TRUE,           //  DS integrated
                NULL,           //  file name
                0,              //  file name len
                ( dwLoadOptions & DNS_ZONE_LOAD_IMPERSONATING ) ?
                    ZONE_CREATE_IMPERSONATING :
                    0,
                NULL,           //  DP pointer
                dwDpFlags,
                pszDpFqdn );
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  If necessary write zone to DS.
    //

    if ( dwLoadOptions & DNS_ZONE_LOAD_OVERWRITE_MEMORY )
    {
        status = Zone_Load( pZone );
    }
    else
    {
        status = Ds_WriteZoneToDs(
                    pZone,
                    dwLoadOptions );
    }
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  on successful conversion move database file to backup directory
    //

    File_MoveToBackupDirectory( pwszoldFileName );

    status = ERROR_SUCCESS;
    goto Done;

Failure:

    pZone->fZoneType = (DWORD) oldType;
    pZone->fDsIntegrated = FALSE;

Done:

    FREE_HEAP( pwszoldFileName );
    return status;
}



DNS_STATUS
zoneResetToPrimary(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile
    )
/*++

Routine Description:

    Reset zone to primary. Assumes zone is locked for update. This
    function is always called in RPC client context.

Arguments:

    pZone -- zone to make regular (non-DS) primary

    pszFile -- data file for zone

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DWORD           oldType;
    BOOL            oldDsIntegrated;

    ASSERT( pZone && pZone->pszZoneName && pZone->fLocked );

    DNS_DEBUG( RPC, (
        "zoneResetToPrimary( %s ):\n"
        "    File     = %s\n",
        pZone->pszZoneName,
        pszFile ));

    //
    //  Not-auth zones cannot be converted to primary because
    //  we don't have a copy of the zone data locally.
    //

    if ( IS_ZONE_NOTAUTH( pZone ) )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //
    //  if no datafile -- forget it
    //

    if ( !pszFile || !*pszFile )
    {
        return DNS_ERROR_PRIMARY_REQUIRES_DATAFILE;
    }

    //
    //  verify that have data
    //      - may have secondary that has not received a transfer
    //

    if ( !pZone->pSoaRR || IS_ZONE_EMPTY( pZone ) )
    {
        ASSERT( IS_ZONE_SECONDARY( pZone ) );
        ASSERT( !pZone->pSoaRR );
        ASSERT( IS_ZONE_EMPTY( pZone ) );

        return DNS_ERROR_ZONE_IS_SHUTDOWN;
    }

    //
    //  save old type and DS info
    //

    oldType = (DWORD) pZone->fZoneType;
    oldDsIntegrated = (BOOL) pZone->fDsIntegrated;

    if ( oldType == DNS_ZONE_TYPE_SECONDARY
        || oldType == DNS_ZONE_TYPE_STUB )
    {
        pZone->fZoneType = DNS_ZONE_TYPE_PRIMARY;
    }

    //
    //  reset zone's database
    //

    status = Zone_DatabaseSetup(
                pZone,
                FALSE,          //  not DsIntegrated
                pszFile,
                0,
                ZONE_CREATE_IMPERSONATING,
                NULL,           //  DP pointer
                0,              //  DP flags
                NULL );         //  DP FQDN
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  if file, attempt to write back
    //

    //  restoring original
    if ( !File_WriteZoneToFile( pZone, NULL, DNS_FILE_IMPERSONATING ) )
    {
        status = ERROR_CANTWRITE;
        goto Failure;
    }


    //
    //  reset zone type and setup as primary
    //

    if ( ! IS_ZONE_CACHE( pZone ) )
    {
        status = Zone_ResetType(
                    pZone,
                    DNS_ZONE_TYPE_PRIMARY,
                    NULL );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }
    }

    //
    //  if originally DS integrated, must remove from DS
    //
    //  DEVNOTE: could return status warning if DS delete fails
    //

    if ( oldDsIntegrated )
    {
        status = Ds_DeleteZone( pZone, DNS_DS_DEL_IMPERSONATING );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "DS delete of zone %s failed, when changing to standard primary.\n",
                pZone->pszZoneName ));
        }
    }

    return ERROR_SUCCESS;

Failure:

    pZone->fZoneType = (DWORD) oldType;
    pZone->fDsIntegrated = (BOOL) oldDsIntegrated;
    return status;
}



DNS_STATUS
zoneResetToSecondary(
    IN OUT  PZONE_INFO          pZone,
    IN      LPSTR               pszFile,
    IN      PDNS_ADDR_ARRAY     aipMasters
    )
/*++

Routine Description:

    Reset zone to secondary. Assumes zone is locked for update. This function
    is always called in the context of an RPC client.

Arguments:

    pZone -- zone to make secondary

    pszFile -- data file for zone

    aipMasters -- master IP array

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DWORD           oldType = ( DWORD ) pZone->fZoneType;
    BOOL            oldDsIntegrated = ( BOOL ) pZone->fDsIntegrated;

    ASSERT( pZone && pZone->pszZoneName && pZone->fLocked );

    DNS_DEBUG( RPC, (
        "zoneResetToSecondary( %s ):\n"
        "    File     = %s\n",
        pZone->pszZoneName,
        pszFile ));

    //
    //  Validate master list.
    //

    status = Zone_ValidateMasterIpList( aipMasters );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  If the zone is currently file-backed, write back.
    //

    if ( !IS_ZONE_DSINTEGRATED( pZone ) )
    {
        File_WriteZoneToFile( pZone, NULL, DNS_FILE_IMPERSONATING );
    }

    //
    //  if previously primary reset zone type
    //  if previously secondary just update master list
    //
    //  note:   admin calls Rpc_ZoneResetTypeEx() for all sorts of property
    //          changes, and Zone_ResetType() will have the effect of
    //          reinitializing all XFR information (effectively turning on
    //          expired zone) which is not what we want when adding a master
    //          to the list
    //

    if ( oldType != DNS_ZONE_TYPE_SECONDARY )
    {
        //
        //  If we're changing zone type and the zone is currently DS-integrated
        //  we need to nuke the zone from the DS before we change any of the
        //  important zone properties.
        //

        if ( oldDsIntegrated )
        {
            status = Ds_DeleteZone( pZone, DNS_DS_DEL_IMPERSONATING );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( ANY, (
                    "DS delete of zone %s failed when changing to standard secondary\n",
                    pZone->pszZoneName ));
            }
        }

        //
        //  For not-auth zones clean out the zone data to force
        //  good clean transfer.
        //

        if ( oldType == DNS_ZONE_TYPE_STUB || oldType == DNS_ZONE_TYPE_FORWARDER )
        {
            File_DeleteZoneFileA( pszFile );
            File_DeleteZoneFileA( pZone->pszDataFile );
            Zone_DumpData( pZone );
        }

        //
        //  Reset the zone's type and database.
        //

        status = Zone_ResetType(
                    pZone,
                    DNS_ZONE_TYPE_SECONDARY,
                    aipMasters );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }

        status = Zone_DatabaseSetup(
                    pZone,
                    FALSE,          //  DsIntegrated
                    pszFile,
                    0,
                    ZONE_CREATE_IMPERSONATING,
                    NULL,           //  DP pointer
                    0,              //  DP flags
                    NULL );         //  DP FQDN
    }
    else
    {
        //
        //  Not changing type so set database and masters.
        //

        status = Zone_DatabaseSetup(
                    pZone,
                    FALSE,          //  not DsIntegrated
                    pszFile,
                    0,
                    ZONE_CREATE_IMPERSONATING,
                    NULL,           //  DP pointer
                    0,              //  DP flags
                    NULL );         //  DP FQDN
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }

        status = Zone_SetMasters(
                    pZone,
                    aipMasters,
                    FALSE,
                    DNS_REG_IMPERSONATING );
    }

    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    Xfr_ForceZoneExpiration( pZone );

    return status;

Failure:

    pZone->fZoneType = ( DWORD ) oldType;
    pZone->fDsIntegrated = ( BOOL ) oldDsIntegrated;
    return status;
}



DNS_STATUS
zoneResetToStub(
    IN OUT  PZONE_INFO          pZone,
    IN      BOOL                fDsIntegrated,
    IN      LPSTR               pszFile,
    IN      PDNS_ADDR_ARRAY     aipMasters,
    IN      DWORD               dwDpFlags,
    IN      LPSTR               pszDpFqdn
    )
/*++

Routine Description:

    Reset zone to stub. Assumes zone is locked for update. This function is
    always called in the context of an RPC client.

Arguments:

    pZone -- zone to make secondary

    fDsIntegrated -- is the new zone to become ds-integrated?
    
    pszFile -- data file for zone

    aipMasters -- master IP array

    dwDpFlags -- DP flags for specifying built-in DP as target

    pszDpFqdn -- DP FQDN for specifying custom DP as target

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "zoneResetToStub" )

    DNS_STATUS      status;
    DWORD           oldType;
    BOOL            oldDsIntegrated = FALSE;

    ASSERT( pZone && pZone->pszZoneName && pZone->fLocked );

    DNS_DEBUG( RPC, (
        "%s( %s ):\n"
        "    File             = %s\n"
        "    DS-integrated    = %d\n",
        fn,
        pZone->pszZoneName,
        pszFile,
        fDsIntegrated ));

    //
    //  W2K protection: do not allow stub and forwarders to be moved to
    //  the legacy partition unless we are in Whistler domain mode.
    //
    
    if ( fDsIntegrated ) 
    {
        PDNS_DP_INFO    pDpInfo = NULL;

        status = Dp_FindPartitionForZone(
                        dwDpFlags,
                        pszDpFqdn,
                        TRUE,
                        &pDpInfo );
        if ( status != ERROR_SUCCESS )
        {
            return status;
        }

        if ( !IS_WHISTLER_DOMAIN() && IS_DP_LEGACY( pDpInfo ) )
        {
            return ERROR_NOT_SUPPORTED;
        }
    }

    //
    //  validate master list
    //

    status = Zone_ValidateMasterIpList( aipMasters );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  save current type in case of failure
    //

    oldType = ( DWORD ) pZone->fZoneType;
    oldDsIntegrated = ( BOOL ) pZone->fDsIntegrated;

    //
    //  note:   admin calls Rpc_ZoneResetTypeEx() for all sorts of property
    //          changes, and Zone_ResetType() will have the effect of
    //          reinitializing all XFR information (effectively turning on
    //          expired zone) which is not what we want when adding a master
    //          to the list
    //

    if ( oldType != DNS_ZONE_TYPE_STUB || oldDsIntegrated != fDsIntegrated )
    {
        //
        //  Delete the current zone files so that any data present
        //  will not be read back when the zone file is loaded.
        //

        File_DeleteZoneFileA( pszFile );
        File_DeleteZoneFileA( pZone->pszDataFile );

        //
        //  Clear out existing zone data. 
        //

        Zone_DumpData( pZone );

        //
        //  If we're changing zone type and the zone is currently DS-integrated
        //  we need to nuke the zone from the DS before we change any of the
        //  important zone properties.
        //

        if ( oldDsIntegrated )
        {
            status = Ds_DeleteZone( pZone, DNS_DS_DEL_IMPERSONATING );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( ANY, (
                    "DS delete of zone %s failed when changing to standard secondary\n",
                    pZone->pszZoneName ));
            }
        }

        //
        //  Reset zone's type and database.
        //

        status = Zone_ResetType(
                    pZone,
                    DNS_ZONE_TYPE_STUB,
                    aipMasters );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }

        status = Zone_DatabaseSetup(
                    pZone,
                    fDsIntegrated,
                    pszFile,
                    0,
                    ZONE_CREATE_IMPERSONATING,
                    NULL,           //  DP pointer
                    dwDpFlags,
                    pszDpFqdn );
    }
    else
    {
        status = Zone_SetMasters(
                    pZone,
                    aipMasters,
                    FALSE,
                    DNS_REG_IMPERSONATING );
    }
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  If necessary write zone to DS.
    //

    if ( fDsIntegrated )
    {
        status = Ds_WriteZoneToDs( pZone, DNS_ZONE_LOAD_OVERWRITE_DS );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }
    }

    return status;

Failure:

    DNS_DEBUG( RPC, (
        "%s: failed %d\n",
        fn,
        status ));

    pZone->fZoneType = ( DWORD ) oldType;
    pZone->fDsIntegrated = ( BOOL ) oldDsIntegrated;
    return status;
}



DNS_STATUS
zoneResetToForwarder(
    IN OUT  PZONE_INFO          pZone,
    IN      BOOL                fDsIntegrated,
    IN      LPSTR               pszFile,
    IN      PDNS_ADDR_ARRAY     aipMasters,
    IN      DWORD               dwDpFlags,
    IN      LPSTR               pszDpFqdn
    )
/*++

Routine Description:

    Reset zone to forwarder. Assumes zone is locked for update. This function
    is always called in the context of an RPC client

Arguments:

    pZone -- zone to make secondary

    fDsIntegrated -- is the new zone to become ds-integrated?
    
    pszFile -- data file for zone

    aipMasters -- master IP array

    dwDpFlags -- DP flags for specifying built-in DP as target

    pszDpFqdn -- DP FQDN for specifying custom DP as target

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "zoneResetToForwarder" )

    DNS_STATUS      status;
    DWORD           oldType;
    BOOL            oldDsIntegrated = FALSE;

    ASSERT( pZone && pZone->pszZoneName && pZone->fLocked );

    DNS_DEBUG( RPC, (
        "%s( %s ):\n"
        "    File             = %s\n",
        fn,
        pZone->pszZoneName,
        pszFile ));

    //
    //  validate master list
    //

    status = Zone_ValidateMasterIpList( aipMasters );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  W2K protection: do not allow stub and forwarders to be moved to
    //  the legacy partition unless we are in Whistler domain mode.
    //
    
    if ( fDsIntegrated ) 
    {
        PDNS_DP_INFO    pDpInfo = NULL;

        status = Dp_FindPartitionForZone(
                        dwDpFlags,
                        pszDpFqdn,
                        TRUE,
                        &pDpInfo );
        if ( status != ERROR_SUCCESS )
        {
            return status;
        }

        if ( !IS_WHISTLER_DOMAIN() && IS_DP_LEGACY( pDpInfo ) )
        {
            return ERROR_NOT_SUPPORTED;
        }
    }

    //
    //  save current type in case of failure
    //

    oldType = ( DWORD ) pZone->fZoneType;
    oldDsIntegrated = ( BOOL ) pZone->fDsIntegrated;

    //
    //  if file, write back before we switch types
    //

    if ( !oldDsIntegrated )
    {
        File_WriteZoneToFile( pZone, NULL, DNS_FILE_IMPERSONATING );
    }

    //
    //  note:   admin calls Rpc_ZoneResetTypeEx() for all sorts of property
    //          changes, and Zone_ResetType() will have the effect of
    //          reinitializing all XFR information (effectively turning on
    //          expired zone) which is not what we want when adding a master
    //          to the list
    //

    if ( oldType != DNS_ZONE_TYPE_FORWARDER || oldDsIntegrated != fDsIntegrated )
    {
        //
        //  Delete the current zone files so that any data present
        //  will not be read back when the zone file is loaded.
        //

        File_DeleteZoneFileA( pszFile );
        File_DeleteZoneFileA( pZone->pszDataFile );

        //
        //  Clear out existing zone data. 
        //

        Zone_DumpData( pZone );

        //
        //  If we're changing zone type and the zone is currently DS-integrated
        //  we need to nuke the zone from the DS before we change any of the
        //  important zone properties.
        //

        if ( oldDsIntegrated )
        {
            status = Ds_DeleteZone( pZone, DNS_DS_DEL_IMPERSONATING );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( ANY, (
                    "DS delete of zone %s failed when changing to standard secondary\n",
                    pZone->pszZoneName ));
            }
        }

        //
        //  Reset zone's database.
        //

        status = Zone_ResetType(
                    pZone,
                    DNS_ZONE_TYPE_FORWARDER,
                    aipMasters );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }

        status = Zone_DatabaseSetup(
                    pZone,
                    fDsIntegrated,
                    pszFile,
                    0,
                    ZONE_CREATE_IMPERSONATING,
                    NULL,           //  DP pointer
                    dwDpFlags,
                    pszDpFqdn );
    }
    else
    {
        status = Zone_SetMasters(
                    pZone,
                    aipMasters,
                    FALSE,
                    DNS_REG_IMPERSONATING );
    }
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  If necessary, write zone to DS.
    //

    if ( fDsIntegrated )
    {
        status = Ds_WriteZoneToDs( pZone, DNS_ZONE_LOAD_OVERWRITE_DS );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }
    }

    return status;

Failure:

    DNS_DEBUG( RPC, (
        "%s: failed %d\n",
        fn,
        status ));

    pZone->fZoneType = ( DWORD ) oldType;
    pZone->fDsIntegrated = ( BOOL ) oldDsIntegrated;
    return status;
}



//
//  Dispatched RPC Zone Operations
//

DNS_STATUS
Rpc_ResetZoneTypeEx(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's database setup. This function is always called in the context
    of an RPC client.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE_CREATE_INFO   pinfo = ( PDNS_RPC_ZONE_CREATE_INFO )pData;
    DNS_STATUS                  status;
    DWORD                       fdsIntegrated;
    DWORD                       originalType;
    DWORD                       newType;
    BOOL                        fexpireZone = FALSE;
    PDNS_ADDR_ARRAY             paipmasters = NULL;
    BOOL                        flocked = FALSE;

    originalType = pZone->fZoneType;
    newType = pinfo->dwZoneType;
    fdsIntegrated = pinfo->fDsIntegrated;

    DNS_DEBUG( RPC, (
        "RpcResetZoneTypeEx( %s ):\n"
        "    New type     = %d\n"
        "    Load options = %p\n"
        "    DS Integrate = %d\n"
        "    File         = %s\n",
        pZone->pszZoneName,
        newType,
        pinfo->fLoadExisting,
        fdsIntegrated,
        pinfo->pszDataFile ));

    if ( pinfo->aipMasters )
    {
        paipmasters = DnsAddrArray_CreateFromIp4Array( pinfo->aipMasters );
        if ( !paipmasters )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
    }

    //
    //  for any database change, lock zone
    //  this is just a simplification, otherwise we have to lock specifically
    //  for those causing DS load, or DS\file write
    //
    
    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        status = DNS_ERROR_ZONE_LOCKED;
        goto Done;
    }
    flocked = TRUE;

    //
    //  Call the appropriate reset type function.
    //

    switch ( newType )
    {
        case DNS_ZONE_TYPE_PRIMARY:
            if ( fdsIntegrated )
            {
                status = Rpc_ZoneResetToDsPrimary(
                            pZone,
                            pinfo->fLoadExisting,
                            pinfo->dwDpFlags,
                            pinfo->pszDpFqdn );
            }
            else
            {
                status = zoneResetToPrimary(
                            pZone,
                            pinfo->pszDataFile );
            }
            break;

        case DNS_ZONE_TYPE_SECONDARY:
            status = zoneResetToSecondary(
                        pZone,
                        pinfo->pszDataFile,
                        paipmasters );
            fexpireZone = TRUE;
            break;

        case DNS_ZONE_TYPE_STUB:
            status = zoneResetToStub(
                        pZone,
                        fdsIntegrated,
                        pinfo->pszDataFile,
                        paipmasters,
                        pinfo->dwDpFlags,
                        pinfo->pszDpFqdn );
            fexpireZone = TRUE;
            break;

        case DNS_ZONE_TYPE_FORWARDER:
            status = zoneResetToForwarder(
                        pZone,
                        fdsIntegrated,
                        pinfo->pszDataFile,
                        paipmasters,
                        pinfo->dwDpFlags,
                        pinfo->pszDpFqdn );
            break;

        default:
            DNS_DEBUG( RPC, (
                "RpcResetZoneTypeEx( %s ): invalid zone type %d\n",
                pZone->pszZoneName,
                newType ));
            status = DNS_ERROR_INVALID_ZONE_TYPE;
            goto Done;
            break;
    }

    Done:
    
    //
    //  if successful, update boot file
    //

    if ( status == ERROR_SUCCESS )
    {
        Config_UpdateBootInfo();
    }

    if ( flocked )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
    }
    
    DnsAddrArray_Free( paipmasters );

    //
    //  Do this outside zone lock, else it's possible the SOA response
    //  will be received while the zone is still locked.
    //

    if ( fexpireZone )
    {
        Xfr_ForceZoneExpiration( pZone );
    }
    
    //
    //  If successful, log an event. On failure, an error code will be
    //  returned to the admin tool so there should be no need for an
    //  event log.
    //

    if ( status == ERROR_SUCCESS )
    {
        if ( IS_ZONE_DSINTEGRATED( pZone ) )
        {
            if ( originalType != pZone->fZoneType )
            {
                //  The zone type has been changed and the zone is now DS.

                PVOID   argArray[] =
                {
                    pZone->pszZoneName,
                    ( PVOID ) ( DWORD_PTR ) pZone->fZoneType,
                    pZone->pwszZoneDN ? pZone->pwszZoneDN : L"N/A"
                };

                BYTE    typeArray[] =
                {
                    EVENTARG_UTF8,
                    EVENTARG_DWORD,
                    EVENTARG_UNICODE
                };

                Ec_LogEvent(
                    g_pServerEventControl,
                    DNS_EVENT_ZONE_RESET_TYPE_COMPLETE_DS,
                    NULL,
                    sizeof( argArray ) / sizeof( argArray[ 0 ] ),
                    argArray,
                    typeArray,
                    ERROR_SUCCESS );
            }
            else
            {
                //  The zone type has NOT been changed and the zone is now DS.

                PVOID   argArray[] =
                {
                    pZone->pszZoneName,
                    pZone->pwszZoneDN ? pZone->pwszZoneDN : L"N/A"
                };

                BYTE    typeArray[] =
                {
                    EVENTARG_UTF8,
                    EVENTARG_UNICODE
                };

                Ec_LogEvent(
                    g_pServerEventControl,
                    DNS_EVENT_ZONE_MOVE_COMPLETE_DS,
                    NULL,
                    sizeof( argArray ) / sizeof( argArray[ 0 ] ),
                    argArray,
                    typeArray,
                    ERROR_SUCCESS );
            }
        }
        else
        {
            if ( originalType != pZone->fZoneType )
            {
                //  The zone type has been changed and the zone is now file-backed.

                PVOID   argArray[] =
                {
                    pZone->pszZoneName,
                    ( PVOID ) ( DWORD_PTR ) pZone->fZoneType,
                    pZone->pszDataFile ? pZone->pszDataFile : "N/A"
                };

                BYTE    typeArray[] =
                {
                    EVENTARG_UTF8,
                    EVENTARG_DWORD,
                    EVENTARG_UTF8
                };

                Ec_LogEvent(
                    g_pServerEventControl,
                    DNS_EVENT_ZONE_RESET_TYPE_COMPLETE_FILE,
                    NULL,
                    sizeof( argArray ) / sizeof( argArray[ 0 ] ),
                    argArray,
                    typeArray,
                    ERROR_SUCCESS );
            }
            else
            {
                //  The zone type has NOT been changed and the zone is now file-backed

                PVOID   argArray[] =
                {
                    pZone->pszZoneName,
                    pZone->pszDataFile ? pZone->pszDataFile : "N/A"
                };

                BYTE    typeArray[] =
                {
                    EVENTARG_UTF8,
                    EVENTARG_UTF8
                };

                Ec_LogEvent(
                    g_pServerEventControl,
                    DNS_EVENT_ZONE_MOVE_COMPLETE_FILE,
                    NULL,
                    sizeof( argArray ) / sizeof( argArray[ 0 ] ),
                    argArray,
                    typeArray,
                    ERROR_SUCCESS );
            }
        }
    }

    return status;
}



DNS_STATUS
Rpc_WriteAndNotifyZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Write zone to file and notify secondaries. Should be called after
    admin changes to the primary zone. This function is always called
    in the security context of an RPC client.

Arguments:

    pZone -- zone to increment

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_WriteAndNotifyZone( %s ):\n",
        pZone->pszZoneName ));

    //  root-hints write has special call

    if ( IS_ZONE_CACHE( pZone ) )
    {
        return Rpc_WriteRootHints( dwClientVersion, ( PSTR ) pszOperation, 0, NULL );
    }

    //
    //  must be primary zone
    //      - secondary not updateable, and always written after AXFR
    //
    //  DEVNOTE: not really true with IXFR, may want to enable secondary write
    //

    if ( !IS_ZONE_PRIMARY( pZone ) )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }
    if ( ! pZone->pSoaRR )
    {
        return DNS_ERROR_ZONE_CONFIGURATION_ERROR;
    }

    //
    //  if zone is NOT dirty, no need to write back or notify
    //

    if ( ! pZone->fDirty )
    {
        return ERROR_SUCCESS;
    }

    //
    //  lock out transfer while rebuilding
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        return DNS_ERROR_ZONE_LOCKED;
    }

    //
    //  re-build zone information that depends on RRs
    //      - name server list
    //      - pointer to SOA record
    //      - WINS or NBSTAT info
    //
    //  note:  except for changes to NS list, this should already be
    //          setup, as individual RR routines do proper zone actions
    //          for SOA, WINS, NBSTAT
    //

    Zone_GetZoneInfoFromResourceRecords( pZone );

    //
    //  update zone version
    //
    //  DEVNOTE: admin tool currently uses this as write zone to file
    //      not update version
    //
    //  Zone_UpdateVersion( pZone );

    //
    //  write zone back to file
    //     - skip if we're ds integrated.
    //

    if ( !pZone->fDsIntegrated &&
         !File_WriteZoneToFile( pZone, NULL, DNS_FILE_IMPERSONATING ) )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
        return( ERROR_CANTWRITE );
    }
    Zone_UnlockAfterAdminUpdate( pZone );

    //
    //  notify secondaries of update
    //
    //  obviously faster to do this before file write;  doing write first
    //  so that zone is less likely to be locked when SOA requests come
    //  from secondaries
    //

    Xfr_SendNotify( pZone );

    return ERROR_SUCCESS;
}



DNS_STATUS
Rpc_DeleteZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Delete zone.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_DeleteZone( %s ):\n",
        pZone->pszZoneName ));

    //
    //  no DIRECT cache delete
    //  delete of cache "zone" only done when admin makes
    //  server authoritative for the root domain
    //

    if ( IS_ZONE_CACHE( pZone ) )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //  no delete of DS zone, if in boot-from-DS mode
    //      (must do delete from DS)

    if ( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY  &&
        pZone->fDsIntegrated )
    {
        DNS_DEBUG( RPC, (
            "Refusing delete of DS zone, while booting from directory.\n" ));
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //  lock zone -- lock out transfer or other admin action

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        return DNS_ERROR_ZONE_LOCKED;
    }

    //  delete zone info

    Zone_Delete( pZone, ZONE_DELETE_IMPERSONATING );

    //  update boot info

    Config_UpdateBootInfo();

    return ERROR_SUCCESS;
}



DNS_STATUS
Rpc_RenameZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Rename zone.

Arguments:

    pZone -- zone to rename

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    static const char *         fn = "Rpc_RenameZone";
    PDNS_RPC_ZONE_RENAME_INFO   pinfo = ( PDNS_RPC_ZONE_RENAME_INFO ) pData;
    DNS_STATUS                  status = ERROR_SUCCESS;

    DNS_DEBUG( RPC, (
        "%s( %s )\n    to %s\n",
        fn,
        pZone->pszZoneName,
        pinfo->pszNewZoneName ));

    //
    //  Not allowed on cache zone.
    //

    if ( IS_ZONE_CACHE( pZone ) )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //
    //  Rename the zone and update boot info.
    //

    status = Zone_Rename( pZone,
                pinfo->pszNewZoneName,
                pinfo->pszNewFileName );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    Config_UpdateBootInfo();

    return status;
}



DNS_STATUS
Rpc_ExportZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Export zone to file. This function is always called in the context of
    an RPC client.

Arguments:

    pZone -- zone to export

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "Rpc_ExportZone" )
    
    PDNS_RPC_ZONE_EXPORT_INFO   pinfo = ( PDNS_RPC_ZONE_EXPORT_INFO ) pData;
    DNS_STATUS                  status = ERROR_SUCCESS;
    BOOL                        fZoneLocked = FALSE;
    PWCHAR                      pwsZoneFile = NULL;
    WCHAR                       wsFilePath[ MAX_PATH + 1 ];
    HANDLE                      hFile;

    DNS_DEBUG( RPC, (
        "%s( %s )\n    to file %s\n",
        fn,
        pZone->pszZoneName,
        pinfo->pszZoneExportFile ));

    //
    //  Make a wide copy of the filename.
    //

    if ( ( pwsZoneFile = Dns_StringCopyAllocate(
                            pinfo->pszZoneExportFile,
                            0,                          // length
                            DnsCharSetUtf8,
                            DnsCharSetUnicode ) ) == NULL )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Test to see if the file exists. We do not allow this operation
    //  to overwrite an existing file. Note we must synthesize the full
    //  file path, but later we only pass the bare file name to
    //  File_WriteZoneToFile(). Hopefully both functions synthesize
    //  the full file path the same way.
    //

    if ( !File_CreateDatabaseFilePath(
                wsFilePath,
                NULL,           //  backup file path
                pwsZoneFile ) )
    {
        status = ERROR_OPEN_FAILED;
        goto Done;
    }

    if ( ( hFile = CreateFileW(
                        wsFilePath,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL ) ) != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
        status = ERROR_ALREADY_EXISTS;
        goto Done;
    }

    //
    //  The zone must be locked to iterate it.
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        status = DNS_ERROR_ZONE_LOCKED;
        goto Done;
    }
    fZoneLocked = TRUE;

    //
    //  Write the zone to file.
    //

    if ( !File_WriteZoneToFile( pZone, pwsZoneFile, DNS_FILE_IMPERSONATING ) )
    {
        status = ERROR_INVALID_DATA;
    }

    //
    //  Free allocations and locks.
    //

    Done:

    FREE_HEAP( pwsZoneFile );

    if ( fZoneLocked )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
    }

    return status;
}



DNS_STATUS
Rpc_ReloadZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Delete zone.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_ReloadZone( %s ):\n",
        pZone->pszZoneName ));

    //
    //  Write the zone back to storage if dirty, otherwise the reload
    //  will overwrite any changes nodes in memory.
    //

    Zone_WriteBack(
        pZone,
        FALSE );        //  shutdown flag

    return Zone_Load( pZone );
}



DNS_STATUS
Rpc_RefreshSecondaryZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Force refresh of secondary zone.
    Zone immediately contacts primary for refresh.

Arguments:

    pZone -- zone to refresh

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_RefreshSecondaryZone( %s ):\n",
        pZone->pszZoneName ));

    Xfr_ForceZoneRefresh( pZone );
    return ERROR_SUCCESS;
}



DNS_STATUS
Rpc_ExpireSecondaryZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Force expiration of secondary zone.
    Unlike Refresh call, this invalidates zone data and causes
    it to contact primary for refresh.

Arguments:

    pZone -- zone to expire

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_ExpireSecondaryZone( %s ):\n",
        pZone->pszZoneName ));

    Xfr_ForceZoneExpiration( pZone );
    return ERROR_SUCCESS;
}



DNS_STATUS
Rpc_DeleteZoneFromDs(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Delete zone, including data in DS. The function must always be
    called while impersonating an RPC client.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status;

    DNS_DEBUG( RPC, (
        "Rpc_DeleteZoneFromDS( %s ):\n",
        pZone->pszZoneName ));

    if ( !IS_ZONE_DSINTEGRATED( pZone ) )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    //
    //  Attempt to delete from DS. If successful, delete from memory.
    //

    status = Ds_DeleteZone( pZone, DNS_DS_DEL_IMPERSONATING );

    if ( status == ERROR_SUCCESS )
    {
        Zone_Delete( pZone, ZONE_DELETE_IMPERSONATING );
    }

    Done:

    DNS_DEBUG( RPC, (
        "Leaving Rpc_DeleteZoneFromDS status = %d (0x%08X)\n",
        status, status ));

    return status;
}



DNS_STATUS
Rpc_UpdateZoneFromDs(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Refresh zone from DS, picking up any updates.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_UpdateZoneFromDs( %s ):\n",
        pZone->pszZoneName ));

    return  Ds_ZonePollAndUpdate(
                pZone,
                TRUE );     //  force poll
}



DNS_STATUS
Rpc_PauseZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Pause zone.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_PauseZone( %s ):\n",
        pZone->pszZoneName ));

    PAUSE_ZONE( pZone );

    return ERROR_SUCCESS;
}



DNS_STATUS
Rpc_ResumeZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Resume zone.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_ResumeZone( %s ):\n",
        pZone->pszZoneName ));

    //  no aging refreshes, while paused, so reset
    //  scavenge on-line time

    pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();

    RESUME_ZONE( pZone );

    return ERROR_SUCCESS;
}


#if DBG

DNS_STATUS
Rpc_LockZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Lock or unlock zone for testing.

Arguments:

    pZone -- zone to refresh

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    LPSTR   psztype;
    BOOL    block;
    BOOL    breturn = FALSE;

    if ( !pZone )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );
    ASSERT( pData );
    psztype = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;
    block   = ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;

    DNS_DEBUG( ANY, (
        "Rpc_LockZone( %s ):\n"
        "    type = %s %s\n",
        pZone->pszZoneName,
        psztype,
        block ? "lock" : "unlock" ));

    //
    //  lock according to desired operation
    //

    if ( block )
    {
        if ( strcmp( psztype, "read" ) == 0 )
        {
            breturn = Zone_LockForReadEx( pZone, 0, 10000, __FILE__, __LINE__ );
        }
        else if ( strcmp( psztype, "write" ) == 0 )
        {
            breturn = Zone_LockForWriteEx( pZone, 0, 10000, __FILE__, __LINE__ );
        }
        else if ( strcmp( psztype, "admin" ) == 0 )
        {
            breturn = Zone_LockForAdminUpdate( pZone );
        }
        else if ( strcmp( psztype, "update" ) == 0 )
        {
            breturn = Zone_LockForUpdate( pZone );
        }
        else if ( strcmp( psztype, "xfr-recv" ) == 0 )
        {
            breturn = Zone_LockForXfrRecv( pZone );
        }
        else if ( strcmp( psztype, "xfr-send" ) == 0 )
        {
            breturn = Zone_LockForXfrSend( pZone );
        }
        else if ( strcmp( psztype, "file" ) == 0 )
        {
            breturn = Zone_LockForFileWrite( pZone );
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }

        if ( !breturn )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  unable to lock zone %s!\n",
                pZone->pszZoneName ));
            return DNS_ERROR_ZONE_LOCKED;
        }
    }

    //
    //  unlock
    //      note that write locks will ASSERT if you come in on a different
    //      thread than the locking thread
    //
    //      one approach would be to make the write locks assumable when locking
    //      (above) and assume them here
    //
    //      currently provide hack-around in "write" unlocks, by giving flag
    //      that specifically ignores this ASSERT
    //

    else    // unlock
    {
        if ( strcmp( psztype, "read" ) == 0 )
        {
            Zone_UnlockAfterReadEx( pZone, 0, __FILE__, __LINE__ );
        }
        else if ( strcmp( psztype, "write" ) == 0 )
        {
            Zone_UnlockAfterWriteEx(
                pZone,
                LOCK_FLAG_IGNORE_THREAD,
                __FILE__,
                __LINE__ );
        }
        else if ( strcmp( psztype, "admin" ) == 0 ||
                  strcmp( psztype, "update" ) == 0 )
        {
            Zone_UnlockAfterWriteEx(
                pZone,
                LOCK_FLAG_IGNORE_THREAD | LOCK_FLAG_UPDATE,
                __FILE__,
                __LINE__ );
        }
        else if ( strcmp( psztype, "xfr-recv" ) == 0 )
        {
            Zone_UnlockAfterWriteEx(
                pZone,
                LOCK_FLAG_IGNORE_THREAD | LOCK_FLAG_XFR_RECV,
                __FILE__,
                __LINE__ );
        }
        else if ( strcmp( psztype, "xfr-send" ) == 0 )
        {
            Zone_UnlockAfterXfrSend( pZone );
        }
        else if ( strcmp( psztype, "file" ) == 0 )
        {
            Zone_UnlockAfterFileWrite( pZone );
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    DNS_DEBUG( ANY, (
        "RPC initiated zone (%s) lock operation successful!\n",
        pZone->pszZoneName ));

    return ERROR_SUCCESS;
}
#endif



DNS_STATUS
Rpc_ResetZoneDatabase(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's database setup. This function is always called in the
    context of an RPC client.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DWORD           fdsIntegrated;
    LPSTR           pszfile;

    fdsIntegrated = ((PDNS_RPC_ZONE_DATABASE)pData)->fDsIntegrated;
    pszfile = ((PDNS_RPC_ZONE_DATABASE)pData)->pszFileName;

    DNS_DEBUG( RPC, (
        "RpcResetZoneDatabase( %s ):\n"
        "    UseDatabase = %d\n"
        "    File = %s\n",
        pZone->pszZoneName,
        fdsIntegrated,
        pszfile ));

    //
    //  for any database change, lock zone
    //  this is just a simplification, otherwise we have to lock specifically
    //  for those causing DS load, or DS\file write
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        return DNS_ERROR_ZONE_LOCKED;
    }

    //
    //  if changing zone backing store, then should be calling full
    //      type\database reset API above
    //  exception is changing cache file
    //

    if ( (BOOL)pZone->fDsIntegrated != (BOOL)fdsIntegrated )
    {
        return ERROR_INVALID_PARAMETER;
    }

    status = Zone_DatabaseSetup(
                pZone,
                fdsIntegrated,
                pszfile,
                0,
                ZONE_CREATE_IMPERSONATING,
                pZone->pDpInfo,
                0,              //  DP flags
                NULL );         //  DP FQDN

    if ( status == ERROR_SUCCESS )
    {
        Config_UpdateBootInfo();
    }

    Zone_UnlockAfterAdminUpdate( pZone );
    return status;
}



DNS_STATUS
Rpc_ResetZoneMasters(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's master servers.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    BOOL                fLocalMasters;
    PDNS_ADDR_ARRAY     paipmasters = NULL;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneMasters( %s ):\n",
        pZone->pszZoneName ));

    if ( !IS_ZONE_SECONDARY( pZone ) && !IS_ZONE_FORWARDER( pZone ) )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    if ( pData )
    {
        paipmasters = DnsAddrArray_CreateFromIp4Array( ( PIP_ARRAY ) pData );
        if ( !paipmasters )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
    }

    //
    //  If the operation string starts with "Local", we are setting
    //  the zone's local masters - currently only allowed for stub zones.
    //

    fLocalMasters = _strnicmp( pszOperation, "Local", 5 ) == 0;
    if ( fLocalMasters && !IS_ZONE_STUB( pZone ) )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    //
    //  Set the zone's master server list.
    //

    status = Zone_SetMasters(
                pZone,
                paipmasters,
                fLocalMasters,
                DNS_REG_IMPERSONATING );

    Done:
    
    if ( status == ERROR_SUCCESS )
    {
        Config_UpdateBootInfo();
    }
    
    DnsAddrArray_Free( paipmasters );

    return status;
}



DNS_STATUS
Rpc_ResetZoneSecondaries(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's secondary information.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    DWORD               fnotify;
    DWORD               fsecure;
    PDNS_ADDR_ARRAY     arrayNotify = NULL;
    PDNS_ADDR_ARRAY     arraySecure = NULL;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneSecondaries( %s )\n",
        pZone->pszZoneName ));

    if ( IS_ZONE_FORWARDER( pZone ) || IS_ZONE_STUB( pZone ))
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    //
    //  extract params
    //

    fsecure = ( ( PDNS_RPC_ZONE_SECONDARIES ) pData )->fSecureSecondaries;
    arraySecure = DnsAddrArray_CreateFromIp4Array(
                    ( ( PDNS_RPC_ZONE_SECONDARIES ) pData )->aipSecondaries );
    fnotify = ( ( PDNS_RPC_ZONE_SECONDARIES ) pData )->fNotifyLevel;
    arrayNotify = DnsAddrArray_CreateFromIp4Array(
                    ( ( PDNS_RPC_ZONE_SECONDARIES ) pData )->aipNotify );

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneSecondaries( %s )\n"
        "    fsecure      = %d\n"
        "    secure array = %p\n"
        "    fnotify      = %d\n"
        "    notify array = %p\n",
        pZone->pszZoneName,
        fsecure,
        arraySecure,
        fnotify,
        arrayNotify ));

    //
    //  allow for partial reset
    //
    //  becauses admin tool may in the future use different property
    //  pages to set notify and secondary info, allow for partial resets
    //

    if ( fsecure == ZONE_PROPERTY_NORESET )
    {
        fsecure = pZone->fSecureSecondaries;
        arraySecure = pZone->aipSecondaries;
    }
    if ( fnotify == ZONE_PROPERTY_NORESET )
    {
        fnotify = pZone->fNotifyLevel;
        arrayNotify = pZone->aipNotify;
    }

    if ( fnotify > ZONE_NOTIFY_HIGHEST_VALUE  ||
         fsecure > ZONE_SECSECURE_HIGHEST_VALUE )
    {
        status = ERROR_INVALID_DATA;
        goto Done;
    }

    status = Zone_SetSecondaries(
                pZone,
                fsecure,
                arraySecure,
                fnotify,
                arrayNotify,
                DNS_REG_IMPERSONATING );

    if ( status == ERROR_SUCCESS )
    {
        //
        //  Update boot info and notify the new secondary list 
        //

        Config_UpdateBootInfo();
        Xfr_SendNotify( pZone );
    }

    Done:

    DnsAddrArray_Free( arrayNotify );
    DnsAddrArray_Free( arraySecure );

    return status;
}



DNS_STATUS
Rpc_ResetZoneScavengeServers(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's secondary information.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_ADDR_ARRAY     pserverArray = NULL;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneScavengeServers( %s )\n"
        "    server array = %p\n",
        pZone->pszZoneName,
        ( PIP_ARRAY ) pData ));

    //
    //  scavenge servers only relevant for DS integrated primaries
    //      - copy new list to zone block
    //      - free old list
    //      - write new list to zone's DS properties

    if ( pZone->bAging )
    {
        if ( pData )
        {
            pserverArray = DnsAddrArray_CreateFromIp4Array( ( PIP_ARRAY ) pData );
            IF_NOMEM( !pserverArray )
            {
                return DNS_ERROR_NO_MEMORY;
            }
        }
        Timeout_FreeAndReplaceZoneIPArray(
            pZone,
            &pZone->aipScavengeServers,
            pserverArray );

        Ds_WriteZoneProperties( NULL, pZone );
        return ERROR_SUCCESS;
    }
    else
    {
        Timeout_FreeAndReplaceZoneIPArray(
            pZone,
            &pZone->aipScavengeServers,
            NULL );
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }
}



DNS_STATUS
Rpc_ResetZoneAllowAutoNS(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's list of servers who can auto create NS records.
    
Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_ADDR_ARRAY     piparray = NULL;
    PDB_RECORD          prrNs = NULL;
    UPDATE_LIST         updateList;
    BOOL                fApplyUpdate = FALSE;
    BOOL                fLocked = FALSE;
    DNS_STATUS          status = ERROR_SUCCESS;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneAllowAutoNS( %s )\n"
        "    server array = %p\n",
        pZone->pszZoneName,
        ( PIP_ARRAY ) pData ));

    if ( !IS_ZONE_DSINTEGRATED( pZone ) )
    {
        DNS_DEBUG( RPC, (
            "Rpc_ResetZoneAllowAutoNS( %s ) - zone must be ds-integrated\n",
            pZone->pszZoneName ));
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    if ( !Zone_LockForDsUpdate( pZone ) )
    {
        DNS_PRINT((
            "WARNING: failed to lock zone %s for set auto NS list!\n",
            pZone->pszZoneName ));
        status = DNS_ERROR_ZONE_LOCKED;
        goto Done;
    }
    fLocked = TRUE;

    if ( pData )
    {
        piparray = DnsAddrArray_CreateFromIp4Array( ( PIP_ARRAY ) pData );
        IF_NOMEM( !piparray )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
    }
    Timeout_FreeAndReplaceZoneIPArray(
        pZone,
        &pZone->aipAutoCreateNS,
        piparray );

    //
    //  Reset zone auto-create flag.
    //

    Zone_SetAutoCreateLocalNS( pZone );

    //
    //  Write the zone properties back. This will cause other servers
    //  to reload the zone and reset their individual NS records.
    //

    Ds_WriteZoneProperties( NULL, pZone );

    //
    //  Add/remove this server's own NS record from the zone root.
    //

    Up_InitUpdateList( &updateList );
    updateList.Flag |= DNSUPDATE_DS;

    prrNs = RR_CreatePtr(
                NULL,                   // no dbase name
                SrvCfg_pszServerName,
                DNS_TYPE_NS,
                pZone->dwDefaultTtl,
                MEMTAG_RECORD_AUTO );
    if ( prrNs )
    {
        if ( RR_IsRecordInRRList(
                    pZone->pZoneRoot->pRRList,
                    prrNs,
                    0 ) )
        {
            //
            //  The zone has the local NS ptr, remove it if required.
            //

            if ( pZone->fDisableAutoCreateLocalNS )
            {
                //
                //  Add the RR as a deletion to the update list and remove the
                //  RR from the searchBlob list so it doesn't get added by
                //  the update below.
                //

                DNS_DEBUG( DS, (
                    "Rpc_ResetZoneAllowAutoNS: zone (%S) root node %p\n"
                    "    DS info has local NS record, removing it\n",
                    pZone->pwsZoneName,
                    pZone->pZoneRoot ));

                Up_CreateAppendUpdate(
                    &updateList,
                    pZone->pZoneRoot,
                    NULL,               //  add list
                    DNS_TYPE_NS,        //  delete type
                    prrNs );            //  delete list
                prrNs = NULL;
                fApplyUpdate = TRUE;
            }
        }
        else if ( !pZone->fDisableAutoCreateLocalNS )
        {
            //
            //  Must add the NS RR.
            //

            DNS_DEBUG( DS, (
                "Rpc_ResetZoneAllowAutoNS: zone (%S) root node %p\n"
                "    DS info has no local NS record, adding it\n",
                pZone->pwsZoneName,
                pZone->pZoneRoot ));

            Up_CreateAppendUpdate(
                &updateList,
                pZone->pZoneRoot,
                prrNs,              //  add list
                0,                  //  delete type
                NULL );             //  delete list
            prrNs = NULL;
            fApplyUpdate = TRUE;
        }
    }

    //
    //  Apply the update!
    //

    if ( fApplyUpdate )
    {
        DNS_STATUS      updatestatus;

        updatestatus = Up_ApplyUpdatesToDatabase(
                            &updateList,
                            pZone,
                            DNSUPDATE_DS );
        if ( updatestatus != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "Rpc_ResetZoneAllowAutoNS: zone (%S) root node %p\n"
                "    error %d applying update\n",
                pZone->pwsZoneName,
                pZone->pZoneRoot,
                updatestatus ));
        }
        if ( updatestatus != ERROR_SUCCESS )
        {
            goto Done;
        }

        updatestatus = Ds_WriteNodeToDs(
                            NULL,                   //  default LDAP handle
                            pZone->pZoneRoot,
                            DNS_TYPE_ALL,
                            DNSDS_REPLACE,
                            pZone,
                            0 );                    //  flags
        if ( updatestatus != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "Rpc_ResetZoneAllowAutoNS: zone (%S) root node %p\n"
                "    error %d applying update\n",
                pZone->pwsZoneName,
                pZone->pZoneRoot,
                updatestatus ));
        }

        if ( updatestatus != ERROR_SUCCESS )
        {
            goto Done;
        }
    }
    Up_FreeUpdatesInUpdateList( &updateList );

    //
    //  Cleanup and return.
    //

    Done:

    if ( fLocked )
    {
        Zone_UnlockAfterDsUpdate( pZone );
    }

    RR_Free( prrNs );       //  Will have been NULLed if not to be freed.

    DNS_DEBUG( DS, (
        "Rpc_ResetZoneAllowAutoNS on zone %S returning %d\n",
        pZone->pwsZoneName,
        status ));
    return status;
}   //  Rpc_ResetZoneAllowAutoNS



DNS_STATUS
Rpc_ResetZoneStringProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone LPWSTR property.
    It is permissable to set a string value to NULL.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPWSTR      value;
    LPWSTR      pwszValueForZone = NULL;
    LPWSTR *    ppwszZoneString = NULL;
    LPSTR       pszPropName = NULL;

    //  extract property name and value

    if ( dwTypeId != DNSSRV_TYPEID_LPWSTR )
    {
        return ERROR_INVALID_PARAMETER;
    }
    value = ( LPWSTR ) pData;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneStringProperty():\n"
        "    zone = %s\n"
        "    op   = %s\n"
        "    val  = \"%S\"\n",
        pZone->pszZoneName,
        pszOperation,
        value ));

    //
    //  Set property.
    //

    if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE ) == 0 )
    {
        //
        //  The incoming string is Unicode but save it in the
        //  zone structure as UTF8 for comparison convenience.
        //

        if ( value )
        {
            pwszValueForZone = ( LPWSTR ) Dns_StringCopyAllocate(
                                                ( PCHAR ) value,
                                                0,
                                                DnsCharSetUnicode,
                                                DnsCharSetUtf8 );
            if ( !pwszValueForZone )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Done;
            }
        }

        pszPropName = DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE_PRIVATE;
        ppwszZoneString = ( LPWSTR * ) &pZone->pszBreakOnUpdateName;
    }
    else
    {
        status = DNS_ERROR_INVALID_PROPERTY;
        goto Done;
    }

    //
    //  Copy (if not already copied) value and save to zone structure.
    //  Note: it is legal to set the value to NULL.
    //

    if ( ppwszZoneString )
    {
        if ( value )
        {
            if ( !pwszValueForZone )
            {
                pwszValueForZone = Dns_StringCopyAllocate_W( value, 0 );
            }
            if ( !pwszValueForZone )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Done;
            }
        }
        Timeout_FreeAndReplaceZoneData(
            pZone,
            ppwszZoneString,
            pwszValueForZone );
    }

    //
    //  Reset property in registry.
    //

    if ( pszPropName )
    {
        status = Reg_SetValue(
                    0,                  //  flags
                    NULL,
                    pZone,
                    pszPropName,        //  actually a Unicode string
                    DNS_REG_WSZ,
                    value ? value : L"",
                    0 );                //  length
    }

    //
    //  Cleanup and return.
    //
    
    Done:

    return status;
}   //  Rpc_ResetZoneStringProperty


DNS_STATUS
Rpc_ResetZoneDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone DWORD property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD       value;
    DWORD       oldValue;
    DNS_STATUS  status;
    BOOLEAN     boolValue;
    BOOL        bsecureChange = FALSE;


    //  extract property name and value

    if ( dwTypeId != DNSSRV_TYPEID_NAME_AND_PARAM || !pData )
    {
        return ERROR_INVALID_PARAMETER;
    }
    pszOperation = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;
    value        = ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;
    boolValue    = (BOOLEAN) (value != 0);

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneDwordProperty():\n"
        "    zone = %s\n"
        "    op   = %s\n"
        "    val  = %d (%p)\n",
        pZone->pszZoneName,
        pszOperation,
        value, value ));

    //
    //  currently, cache zone doesn't have any of these properties
    //

    if ( IS_ZONE_CACHE( pZone ) )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //
    //  turn on\off update
    //      - update only allowed on primary
    //      - secure update only on DS-primary
    //      - note update change, will timestamp changes on DS zones
    //
    //  if turning update ON
    //      - reset scanenging start time, as won't have been doing aging
    //      updates while update was off
    //      - notify netlogon
    //

    if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_ALLOW_UPDATE ) == 0 )
    {
        if ( ! IS_ZONE_PRIMARY( pZone ) ||
             ( !pZone->fDsIntegrated && ZONE_UPDATE_SECURE == (UCHAR)value ) )
        {
            return DNS_ERROR_INVALID_ZONE_TYPE;
        }

        if ( pZone->fAllowUpdate != (UCHAR)value )
        {
            bsecureChange = TRUE;
            oldValue = pZone->fAllowUpdate;
            pZone->fAllowUpdate = (UCHAR) value;

            if ( oldValue == ZONE_UPDATE_OFF )
            {
                pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();

                Service_SendControlCode(
                    g_wszNetlogonServiceName,
                    SERVICE_CONTROL_DNS_SERVER_START );
            }
        }
    }

    //  turn on\off secondary security
    //  NOTE: value is stored in a boolean but it takes more than just zero and one!

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_SECURE_SECONDARIES ) == 0 )
    {
        if ( ( int ) value < 0 || ( int ) value > ZONE_SECSECURE_HIGHEST_VALUE )
        {
            return ERROR_INVALID_PARAMETER;
        }
        pZone->fSecureSecondaries = ( BOOLEAN ) value;
    }

    //  turn on\off notify

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_NOTIFY_LEVEL ) == 0 )
    {
        pZone->fNotifyLevel = boolValue;
    }

    //  turn on\off update logging

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_LOG_UPDATES ) == 0 )
    {
        pZone->fLogUpdates = boolValue;
    }

    //
    //  set scavenging properties
    //      - no refresh interval
    //      - refresh interval
    //      - scavenging on\off
    //
    //  for refresh\norefresh times, 0 value will mean restore default
    //

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_NOREFRESH_INTERVAL ) == 0 )
    {
        if ( value == 0 )
        {
            //value = DNS_DEFAULT_NOREFRESH_INTERVAL_HR;
            value = SrvCfg_dwDefaultNoRefreshInterval;
        }
        pZone->dwNoRefreshInterval = value;
    }

    //
    //  refresh interval
    //

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_REFRESH_INTERVAL ) == 0 )
    {
        if ( value == 0 )
        {
            //value = DNS_DEFAULT_REFRESH_INTERVAL_HR;
            value = SrvCfg_dwDefaultRefreshInterval;
        }
        pZone->dwRefreshInterval = value;
    }

    //
    //  scavenge on\off
    //      - if turning on, then reset start of scavenge time
    //      note, do not do this unless was previously off, otherwise
    //      repeated admin "set" operation keeps moving out scavenge time
    //

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_AGING ) == 0 )
    {
        if ( !pZone->bAging && boolValue )
        {
            pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();
        }
        pZone->bAging = boolValue;
    }

    //
    //  forwarder slave flag
    //

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_FWD_SLAVE ) == 0 )
    {
        if ( !IS_ZONE_FORWARDER( pZone ) )
        {
            return DNS_ERROR_INVALID_ZONE_TYPE;
        }
        pZone->fForwarderSlave = boolValue;
    }

    //
    //  forwarder timeout
    //

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_FWD_TIMEOUT ) == 0 )
    {
        if ( !IS_ZONE_FORWARDER( pZone ) )
        {
            return DNS_ERROR_INVALID_ZONE_TYPE;
        }
        pZone->dwForwarderTimeout = value;
    }

    //
    //  changing all other DWORD properties
    //      - type
    //      - secure secondaries
    //      - DS integration
    //  should all be done in context of specific reset operation
    //

    else
    {
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //
    //  reset property DWORD in registry
    //

    status = Reg_SetDwordValue(
                DNS_REG_IMPERSONATING,
                NULL,
                pZone,
                pszOperation,
                value );

    ASSERT( status == ERROR_SUCCESS ||
            ( status == ERROR_OPEN_FAILED &&
                pZone->fDsIntegrated &&
                SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY ) );

    //
    //  reset property in DS
    //

    if ( pZone->fDsIntegrated )
    {
        if ( bsecureChange )
        {
            //
            // Get current Time & set zone llSecureUpdateTime value
            // Note: the time won't match the whenCreated on the ms, but
            // it should be close enough. The benefit this way, is that
            // we don't need to write, read whenChanged, & write again.
            //
            //  DEVNOTE: only really need time when go TO secure
            //      but writing it is harmless
            //

            LONGLONG llTime = GetSystemTimeInSeconds64();

            ASSERT( llTime > 0 );

            DNS_DEBUG( RPC, (
                "Setting zone->llSecureUpdateTime = %I64d\n",
                llTime ));

            pZone->llSecureUpdateTime = llTime;
       }

       //   write changes to the DS

       status = Ds_WriteZoneProperties( NULL, pZone );

       if ( status == ERROR_SUCCESS && IS_ZONE_AUTHORITATIVE( pZone ) )
       {
           //
           // Touch DC=@ node to mark that the security on this node hasn't
           // node expired.
           // The security on the @ node should never be expired (otherwise we
           // introduce a security hole when the zone update state is flipped & anyone
           // can take over this node. We want to prevent this.
           // All we need to do is generate a node DS write. Currently the node dnsproperty
           // isn't used for anything (& even if it was this write is valid property update),
           // so we'll use this to generate the write.
           //
           //   DEVNOTE: ridiculous;  a better way is simply to special case "@" dn
           //       since we NEVER use any other node property but have to read and write
           //       it because of this
           //

           if ( pZone->pZoneRoot )
           {
               status = Ds_WriteNodeProperties(
                            pZone->pZoneRoot,
                            DSPROPERTY_ZONE_SECURE_TIME );
           }
       }
    }

    return status;
}



DNS_STATUS
Rpc_ResetAllZonesDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset all zones DWORD property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS dwLastError = ERROR_SUCCESS, status;
    PZONE_INFO pzone;

    DNS_DEBUG( RPC, (
        "Rpc_ResetAllZonesDwordProperty\n" ));

    for ( pzone = Zone_ListGetNextZone( NULL );
          pzone != NULL;
          pzone = Zone_ListGetNextZone( pzone ) )
    {

        if ( pzone->fAutoCreated || IS_ZONE_CACHE ( pzone ) )
        {
            // rpc op on AutoCreated is not supported (see dispatching function).
            continue;
        }

        status = Rpc_ResetZoneDwordProperty(
                    dwClientVersion,
                    pzone,
                    pszOperation,
                    dwTypeId,
                    pData );
        if ( status != ERROR_SUCCESS )
        {
            dwLastError = status;
        }
    }

    DNS_DEBUG( RPC, (
        "Exit <%lu>: Rpc_ResetAllZonesDwordProperty\n",
        dwLastError ));

    return dwLastError;
}



//
//  Dispatched RPC Zone Queries
//

DNS_STATUS
Rpc_GetZoneInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone info.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE_INFO  pinfo;

    DNS_DEBUG( RPC, (
        "RpcGetZoneInfo()\n"
        "  client ver       = 0x%08lX\n"
        "  zone name        = %s\n",
        dwClientVersion,
        pZone->pszZoneName ));

    if ( dwClientVersion == DNS_RPC_W2K_CLIENT_VERSION )
    {
        return W2KRpc_GetZoneInfo(
                    dwClientVersion,
                    pZone,
                    pszQuery,
                    pdwTypeId,
                    ppData );
    }

    //
    //  allocate\create zone info
    //

    pinfo = allocateRpcZoneInfo( pZone );
    if ( !pinfo )
    {
        DNS_PRINT(( "ERROR:  unable to allocate DNS_RPC_ZONE_INFO block.\n" ));
        goto DoneFailed;
    }

    //  set return ptrs

    * ( PDNS_RPC_ZONE_INFO * ) ppData = pinfo;
    *pdwTypeId = DNSSRV_TYPEID_ZONE_INFO;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneInfo(
            "GetZoneInfo return block",
            pinfo );
    }
    return ERROR_SUCCESS;

DoneFailed:

    //  free newly allocated info block

    return DNS_ERROR_NO_MEMORY;
}



DNS_STATUS
Rpc_GetZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone info.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE  prpcZone;

    DNS_DEBUG( RPC, ( "RpcGetZone(%s)\n", pZone->pszZoneName ));

    //
    //  allocate\create zone info
    //

    prpcZone = allocateRpcZone( pZone );
    if ( !prpcZone )
    {
        DNS_PRINT(( "ERROR:  unable to allocate DNS_RPC_ZONE block.\n" ));
        goto DoneFailed;
    }

    //  set return ptrs

    * ( PDNS_RPC_ZONE * ) ppData = prpcZone;
    *pdwTypeId = DNSSRV_TYPEID_ZONE;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZone(
            "GetZone return block",
            prpcZone );
    }
    return ERROR_SUCCESS;

DoneFailed:

    //  free newly allocated info block

    return DNS_ERROR_NO_MEMORY;
}



DNS_STATUS
Rpc_QueryZoneDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone DWORD property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD   value;

    DNS_DEBUG( RPC, ( "RpcQueryZoneDwordProperty(%s)\n", pZone->pszZoneName ));

    //
    //  check for each match, until get table going
    //

    if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_TYPE ) == 0 )
    {
        value = pZone->fZoneType;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_ALLOW_UPDATE ) == 0 )
    {
        value = pZone->fAllowUpdate;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_DS_INTEGRATED ) == 0 )
    {
        value = pZone->fDsIntegrated;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_SECURE_SECONDARIES ) == 0 )
    {
        value = pZone->fSecureSecondaries;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_NOTIFY_LEVEL ) == 0 )
    {
        value = pZone->fNotifyLevel;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_AGING ) == 0 )
    {
        value = pZone->bAging;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_NOREFRESH_INTERVAL ) == 0 )
    {
        value = pZone->dwNoRefreshInterval;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_REFRESH_INTERVAL ) == 0 )
    {
        value = pZone->dwRefreshInterval;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_FWD_TIMEOUT ) == 0 )
    {
        value = pZone->dwForwarderTimeout;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_FWD_SLAVE ) == 0 )
    {
        value = pZone->fForwarderSlave;
    }
    else
    {
        return DNS_ERROR_INVALID_PROPERTY;
    }

    * ( PDWORD ) ppData = value;
    *pdwTypeId = DNSSRV_TYPEID_DWORD;
    return ERROR_SUCCESS;
}



DNS_STATUS
Rpc_QueryZoneIPArrayProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone IP array property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PIP_ARRAY           pip4array = NULL;
    PDNS_ADDR_ARRAY     value = NULL;

    DNS_DEBUG( RPC, ( "Rpc_QueryZoneIPArrayProperty( %s )\n", pZone->pszZoneName ));

    //
    //  check for each match, until get table going
    //

    if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_ALLOW_AUTONS ) == 0 )
    {
        value = pZone->aipAutoCreateNS;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_MASTERS ) == 0 )
    {
        value = pZone->aipMasters;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_LOCAL_MASTERS ) == 0 )
    {
        value = pZone->aipLocalMasters;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_SECONDARIES ) == 0 )
    {
        value = pZone->aipSecondaries;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_NOTIFY_LIST ) == 0 )
    {
        value = pZone->aipNotify;
    }
    else
    {
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //
    //  Allocate a copy of the IP array and return it. If we have a NULL array
    //  return NULL to the client so it knows the request was valid but there is
    //  no array set.
    //

    if ( value )
    {
        pip4array = DnsAddrArray_CreateIp4Array( value );
        if ( !pip4array )
        {
            return DNS_ERROR_NO_MEMORY;
        }
    }
    *( PIP_ARRAY * ) ppData = pip4array;
    *pdwTypeId = DNSSRV_TYPEID_IPARRAY;
    return ERROR_SUCCESS;
}   //  Rpc_QueryZoneIPArrayProperty



DNS_STATUS
Rpc_QueryZoneStringProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone string property - returns wide string.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    LPWSTR      pwszValue = NULL;
    LPSTR       pszValue = NULL;

    DNS_DEBUG( RPC, (
        "Rpc_QueryZoneStringProperty( %s, %s )\n",
        pZone->pszZoneName,
        pszQuery ));

    //
    //  Check for each match, until get table going. Set either the wide
    //  or narrow value string pointer.
    //

    if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE ) == 0 )
    {
        pszValue = pZone->pszBreakOnUpdateName;
    }
    else
    {
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //
    //  Copy (converting if necessary) the wide or narrow string.
    //

    if ( pszValue )
    {
        pwszValue = Dns_StringCopyAllocate(
                            pszValue,
                            0,                          // length
                            DnsCharSetUtf8,
                            DnsCharSetUnicode );
    }
    else if ( pwszValue )
    {
        pwszValue = Dns_StringCopyAllocate_W(
                            pwszValue,
                            0 );
    }

    * ( LPWSTR * ) ppData = pwszValue;
    *pdwTypeId = DNSSRV_TYPEID_LPWSTR;
    return ERROR_SUCCESS;
}   //  Rpc_QueryZoneIPArrayProperty



DNS_STATUS
Rpc_CreateZone(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Create a new zone. This is a "ServerOperation" in the RPC sense.

    This function should always be called in the security context of
    the RPC client.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "Rpc_CreateZone" )

    PDNS_RPC_ZONE_CREATE_INFO pcreate = (PDNS_RPC_ZONE_CREATE_INFO)pData;

    PDNS_DP_INFO        pDpInfo = NULL;
    PZONE_INFO          pzone;
    PDB_NODE            pnodeCache;
    PDB_NODE            pnodeRoot;
    DWORD               zoneType = pcreate->dwZoneType;
    DNS_STATUS          status;
    INT                 i;
    BOOL                fAutodelegate;
    DWORD               dw;
    PDNS_ADDR_ARRAY     paipmasters = NULL;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcUnion(
            "Rpc_CreateZone ",
            DNSSRV_TYPEID_ZONE_CREATE,
            pcreate );
    }

    //
    //  verify that zone type is valid
    //

    if ( zoneType != DNS_ZONE_TYPE_PRIMARY
        && zoneType != DNS_ZONE_TYPE_SECONDARY
        && zoneType != DNS_ZONE_TYPE_STUB
        && zoneType != DNS_ZONE_TYPE_FORWARDER )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Exit;
    }
    if ( !pcreate->pszZoneName )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  Check if the zone already exists.
    //

    pzone = Zone_FindZoneByName( (LPSTR) pcreate->pszZoneName );
    if ( pzone )
    {
        DNS_DEBUG( RPC, (
            "Zone %s already exists!\n",
            pcreate->pszZoneName ));
        status = IS_ZONE_FORWARDER( pzone ) ?
                    DNS_ERROR_FORWARDER_ALREADY_EXISTS :
                    DNS_ERROR_ZONE_ALREADY_EXISTS;
        goto Exit;
    }

    //
    //  Verify directory partition params. If the flags parameter specifies
    //  a built-in partition then the DP FQDN parameter is ignored.
    //

    if ( ( pcreate->dwDpFlags || pcreate->pszDpFqdn ) &&
         !IS_DP_INITIALIZED() )
    {
        status = ERROR_NOT_SUPPORTED;
        goto Exit;
    }

    if ( pcreate->dwDpFlags & 
         ~( DNS_DP_LEGACY | DNS_DP_DOMAIN_DEFAULT | DNS_DP_FOREST_DEFAULT ) )
    {
        //  Only certain flags have meaning here.
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    i = 0;
    if ( pcreate->dwDpFlags & DNS_DP_LEGACY )           ++i;
    if ( pcreate->dwDpFlags & DNS_DP_DOMAIN_DEFAULT )   ++i;
    if ( pcreate->dwDpFlags & DNS_DP_FOREST_DEFAULT )   ++i;

    if ( !pcreate->fDsIntegrated &&
        ( i != 0 || pcreate->pszDpFqdn != NULL ) )
    {
        //  partition specified for non-DS integrated zone!
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    if ( i > 1 )
    {
        //  Can specify at most one flag.
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  Find the partition specified. If not found then the zone can't be created.
    //
    //  For built-in partitions if the zone is not enlisted or not created, attempt
    //  to create it now using the admin's credentials.
    //

    if ( i || pcreate->pszDpFqdn ) 
    {
        status = Dp_FindPartitionForZone(
                        pcreate->dwDpFlags,
                        pcreate->pszDpFqdn,
                        TRUE,
                        &pDpInfo );
        if ( status != ERROR_SUCCESS )
        {
            goto Exit;
        }
    }
    
    //
    //  W2K issue: W2K currently will load a stub/forwarder zone as a primary
    //  zone. This is very bad - W2K was supposed to ignore these zone types 
    //  but the W2K code that does this was #if 0'ed. SP4 or SP5 will properly
    //  ignore stub/forwarder zones but in order not to hose SP3 and below
    //  we are going to allow stub/forwarder zones only in NDNCs.
    //  
    //  If we are in WDM this restriction is removed.
    //
    
    if ( pcreate->fDsIntegrated &&
         !IS_WHISTLER_DOMAIN() &&
         ( zoneType == DNS_ZONE_TYPE_FORWARDER ||
           zoneType == DNS_ZONE_TYPE_STUB ) &&
         IS_DP_LEGACY( pDpInfo ) )
    {
        status = ERROR_NOT_SUPPORTED;
        DNS_PRINT((
            "ERROR: failing stub/forwarder zone creation for zone %s\n"
            "    stub and forward zones may only be created in NDNCs in non-WDM\n"
            "    status = %d\n",
            pcreate->pszZoneName,
            status ));
        goto Exit;
    }

    //
    //  if zone root already exists, delete any existing cached records within zone
    //
    //  --  if creating in middle of authoritative zone => no delete
    //
    //  DEVNOTE: creating zone within existing, delete if file?
    //      might want to change this case to delete if reading from a file
    //
    //  --  if creating in cached area, delete everything in desired zone
    //      root's subtree EXCEPT any underlying authoritative zones
    //
    //  DEVNOTE: need zone split function
    //
    //  DEVNOTE: clean cache on new zone create
    //              - delete subtree of zone
    //              - or delete whole cache

    pnodeCache = Lookup_ZoneNodeFromDotted(
                    NULL,               // cache
                    (LPSTR) pcreate->pszZoneName,
                    0,
                    LOOKUP_FQDN,
                    LOOKUP_FIND_PTR,    // find mode
                    NULL );             // no status
    if ( pnodeCache )
    {
        RpcUtil_DeleteNodeOrSubtreeForAdmin(
            pnodeCache,
            NULL,       //  no zone
            NULL,       //  no update list
            TRUE );     //  deleting subtree
    }

    //
    //  create primary zone?
    //      - create zone info
    //      - load database file, if specified
    //      - otherwise auto-create default zone records (SOA, NS)
    //

    if ( zoneType == DNS_ZONE_TYPE_PRIMARY )
    {
        DWORD   createFlag = ZONE_CREATE_IMPERSONATING;

        if ( pcreate->fLoadExisting ||
             ( pcreate->dwFlags & DNS_ZONE_LOAD_EXISTING ) )
        {
            createFlag |= ZONE_CREATE_LOAD_EXISTING;
        }
        else
        {
            createFlag |= ZONE_CREATE_DEFAULT_RECORDS;
        }

        //  catch DS failure
        //  temporarily special case DS integrated create until UI
        //      straightened out, allow both load attempt and
        //      default create if zone not yet in DS
        //      - don't wait for open
        //      - don't log error if can not open

        if ( pcreate->fDsIntegrated )
        {
            status = Ds_OpenServer( 0 );
            if ( status != ERROR_SUCCESS )
            {
                goto Exit;
            }
            createFlag |= ZONE_CREATE_DEFAULT_RECORDS;
        }

        status = Zone_CreateNewPrimary(
                    & pzone,
                    (LPSTR) pcreate->pszZoneName,
                    (LPSTR) pcreate->pszAdmin,
                    (LPSTR) pcreate->pszDataFile,
                    pcreate->fDsIntegrated,
                    pDpInfo,
                    createFlag );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  Failure to admin create primary zone %s.\n"
                "    status = %d (%p).\n",
                pcreate->pszZoneName,
                status, status ));
            goto Exit;
        }

        //  DC promo transitional zone
        //      - write regkey, on reboot it is fixed

        if ( pcreate->dwFlags &
            ( DNS_ZONE_CREATE_FOR_DCPROMO |
                DNS_ZONE_CREATE_FOR_DCPROMO_FOREST ) )
        {
            Reg_SetDwordValue(
                DNS_REG_IMPERSONATING,
                NULL,
                pzone,
                DNS_REGKEY_ZONE_DCPROMO_CONVERT,
                pcreate->dwFlags & DNS_ZONE_CREATE_FOR_DCPROMO_FOREST ?
                    DCPROMO_CONVERT_FOREST :
                    DCPROMO_CONVERT_DOMAIN );
        }
    }

    //
    //  create a zone with master IP list (secondary, stub, or forwarder)
    //

    else
    {
        ZONE_TYPE_SPECIFIC_INFO     ztsi;
        PZONE_TYPE_SPECIFIC_INFO    pztsi = NULL;

        paipmasters = DnsAddrArray_CreateFromIp4Array( pcreate->aipMasters );
        if ( !paipmasters )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
        
        status = Zone_ValidateMasterIpList( paipmasters );
        if ( status != ERROR_SUCCESS )
        {
            goto Exit;
        }

        //
        //  Set up ztsi (zone type specific info).
        //

        if ( zoneType == DNS_ZONE_TYPE_FORWARDER )
        {
            ztsi.Forwarder.dwTimeout = pcreate->dwTimeout;
            ztsi.Forwarder.fSlave = ( BOOLEAN ) pcreate->fSlave;
            pztsi = &ztsi;
        }

        //
        //  Create the zone.
        //

        status = Zone_Create(
                    &pzone,
                    zoneType,
                    (LPSTR) pcreate->pszZoneName,
                    0,
                    0,                      //  flags
                    paipmasters,
                    pcreate->fDsIntegrated,
                    pDpInfo,
                    pcreate->pszDataFile,
                    0,
                    pztsi,
                    NULL );                 //  existing zone
        if ( status != ERROR_SUCCESS )
        {
            goto Exit;
        }

        //
        //  Forwarder zones:
        //      - They never change so manually set them dirty to force write-back.
        //      - Start it up now.
        //

        if ( IS_ZONE_FORWARDER( pzone ) )
        {
            MARK_DIRTY_ZONE( pzone );
            status = Zone_PrepareForLoad( pzone );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( RPC, (
                    "Rpc_CreateZone( %s ) = %d from Zone_PrepareForLoad\n",
                    pcreate->pszZoneName,
                    status ));
                goto Exit;
            }
            status = Zone_ActivateLoadedZone( pzone );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( RPC, (
                    "Rpc_CreateZone( %s ) = %d from Zone_ActivateLoadedZone\n",
                    pcreate->pszZoneName,
                    status ));
                goto Exit;
            }
        }

        //
        //  If the zone is a forwarder, write it back to registry. Technically
        //  this is probably ok for all zone types but we are just about to ship
        //  .NET and I want to minimize code changes. For forwarder zones, the
        //  ForwarderTimeout and ForwarderSlave values need to be committed to
        //  the registry somehow. We cannot do this in Zone_Create() because
        //  on reload these parameters have not been read yet, so we need to
        //  force a write-back of these parameters here.
        //  
        //  To see the load code that causes this to be necessary, look in
        //  boot.c. Notice that in setupZoneFromRegistry(), the zone is created
        //  with a call to Zone_Create_W() but the ForwarderTimeout and
        //  ForwarderSlave values are not set to their ultimate values until
        //  later when loadRegistryZoneExtensions() is called.
        //
        
        if ( IS_ZONE_FORWARDER( pzone ) )
        {
            Zone_WriteZoneToRegistry( pzone );
        }

        //
        //  Write AD-integrated zones to DS.
        //

        if ( IS_ZONE_DSINTEGRATED( pzone ) )
        {
            status = Ds_WriteZoneToDs( pzone, 0 );
            if ( status != ERROR_SUCCESS )
            {
                goto Failed;
            }
        }

        //  unlock zone
        //      zone is created locked, unlock here and let
        //      secondary zone control thread contact master and do transfer

        Zone_UnlockAfterAdminUpdate( pzone );
    }

    ASSERT( pzone && pzone->pZoneTreeLink );


    //
    //  Add delegation to parent zone?
    //  Do not do this for stub or forwarder zones. Also skip 
    //  autodelegation if the new zone is secondary and
    //  begins with _msdcs. This is generally an forest-wide 
    //  zone so adding an autodelegation may cause
    //  clients across the forest to hit branch office servers.
    //

    fAutodelegate = !IS_ZONE_FORWARDER( pzone ) && !IS_ZONE_STUB( pzone );

    if ( fAutodelegate && !IS_ZONE_PRIMARY( pzone ) )
    {
        #define DNS_MSDCS_ZONE_NAME_PREFIX          "_msdcs."
        #define DNS_MSDCS_ZONE_NAME_PREFIX_LEN      7

        fAutodelegate = 
             _strnicmp( pzone->pszZoneName,
                        DNS_MSDCS_ZONE_NAME_PREFIX,
                        DNS_MSDCS_ZONE_NAME_PREFIX_LEN ) != 0;
    }

    //
    //  These operations should be performed in the server context.
    //
            
    status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_SERVER_CONTEXT );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    if ( fAutodelegate )
    {
        Zone_CreateDelegationInParentZone( pzone );
    }

    //
    //  DEVNOTE: set additional zone properties (Update, Unicode, etc.) on create
    //      - AllowUpdate
    //      - Unicode file
    //      - Secondaries
    //      - secondary security
    //

    //
    //  update boot info
    //

    Config_UpdateBootInfo();

    //
    //  Revert to RPC client context.
    //
    
    status = RpcUtil_SwitchSecurityContext( RPC_SWITCH_TO_CLIENT_CONTEXT );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    goto Exit;

Failed:

    Zone_Delete( pzone, ZONE_DELETE_IMPERSONATING );

Exit:

    DnsAddrArray_Free( paipmasters );
    
    DNS_DEBUG( RPC, (
        "Rpc_CreateZone( %s ) = %d (%p)\n",
        pcreate->pszZoneName,
        status, status ));

    //
    //  If a zone was created successfully, mark the server as configured.
    //
    
    if ( status == ERROR_SUCCESS && !SrvCfg_fAdminConfigured )
    {
        DnsSrv_SetAdminConfigured( TRUE );
    }

    return status;
}



DNS_STATUS
Rpc_EnumZones(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Enumerate zones.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

    None

Return Value:

    None

--*/
{
    PZONE_INFO          pzone = NULL;
    DWORD               count = 0;
    PDNS_RPC_ZONE       prpcZone;
    DNS_STATUS          status;
    PDNS_RPC_ZONE_LIST  pzoneList = NULL;
    BOOL                completed = FALSE;
    DWORD               zonePointerCount = MAX_RPC_ZONE_COUNT_DEFAULT;
    DWORD               retries = MAX_RPC_ZONE_ALLOCATION_RETRIES;

    DNS_RPC_ENUM_ZONES_FILTER   filter = { 0 };

    filter.dwFilter = ( DWORD ) ( ULONG_PTR ) pDataIn;

    DNS_DEBUG( RPC, (
        "RpcEnumZones():\n"
        "    client ver   = 0x%08lX\n", 
        "    filter       = 0x%08lX\n",
        dwClientVersion,
        filter.dwFilter ));

    if ( dwClientVersion == DNS_RPC_W2K_CLIENT_VERSION )
    {
        return W2KRpc_EnumZones(
                    dwClientVersion,
                    pZone,
                    pszOperation,
                    dwTypeIn,
                    pDataIn,
                    pdwTypeOut,
                    ppDataOut );
    }

    //
    //  allocate zone enumeration block
    //  by default allocate space for 64k zones, if go over this we do
    //  a huge reallocation
    //

    //
    //  add all zones that pass filter in a retry loop for cases where
    //  we have more zones than will fit in a reasonably sized array
    //

    while ( !completed && retries-- > 0 )
    {
        //
        //  Allocate a new zone list point array. If we have one from the
        //  last loop, free it.
        //

        freeZoneList( pzoneList );
        pzoneList = ( PDNS_RPC_ZONE_LIST )
                        MIDL_user_allocate(
                            sizeof( DNS_RPC_ZONE_LIST ) +
                            sizeof( PDNS_RPC_ZONE ) * zonePointerCount );
        IF_NOMEM( !pzoneList )
        {
            return DNS_ERROR_NO_MEMORY;
        }
        pzoneList->dwRpcStructureVersion = DNS_RPC_ZONE_LIST_VER;
        pzoneList->dwZoneCount = 0;

        //
        //  Stuff all matching zones into the zone list.
        //

        completed = TRUE;
        count = 0;
        pzone = NULL;

        while ( ( pzone = Zone_ListGetNextZoneMatchingFilter(
                                    pzone,
                                    &filter ) ) != NULL )
        {
            //  check against max count, set up for larger allocation if full

            if ( count >= zonePointerCount )
            {
                completed = FALSE;
                zonePointerCount *= 2;
                break;
            }

            //  create RPC zone struct for zone
            //  add to list, keep count

            prpcZone = allocateRpcZone( pzone );
            IF_NOMEM( !prpcZone )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Failed;
            }
            pzoneList->ZoneArray[ count++ ] = prpcZone;
            ++pzoneList->dwZoneCount;
        }
    }

    //  set return count
    //  set returned type
    //  return enumeration

    if ( pzoneList )
    {
        pzoneList->dwZoneCount = count;
    }

    * ( PDNS_RPC_ZONE_LIST * ) ppDataOut = pzoneList;
    *pdwTypeOut = DNSSRV_TYPEID_ZONE_LIST;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneList(
            "Leaving R_DnsEnumZones() zone list sent:",
            pzoneList );
    }
    return ERROR_SUCCESS;

Failed:

    DNS_PRINT((
        "R_DnsEnumZones(): failed\n"
        "    status       = %p\n",
        status ));

    pzoneList->dwZoneCount = count;
    freeZoneList( pzoneList );
    return status;
}



DNS_STATUS
Rpc_EnumZones2(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Enumerate zones version 2. This is just like the original
    EnumZones function but instead of a simple DWORD filter it
    allows for a more complex filter structure.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

    None

Return Value:

    None

--*/
{
    PZONE_INFO          pzone = NULL;
    DWORD               count = 0;
    PDNS_RPC_ZONE       prpcZone;
    DNS_STATUS          status;
    PDNS_RPC_ZONE_LIST  pzoneList = NULL;
    BOOL                completed = FALSE;
    DWORD               zonePointerCount = MAX_RPC_ZONE_COUNT_DEFAULT;
    DWORD               retries = MAX_RPC_ZONE_ALLOCATION_RETRIES;

    PDNS_RPC_ENUM_ZONES_FILTER  pfilter =
                        ( PDNS_RPC_ENUM_ZONES_FILTER ) pDataIn;

    DNS_DEBUG( RPC, (
        "RpcEnumZones2():\n"
        "    client ver       = 0x%08lX\n",
        "    filter DWORD     = 0x%08lX\n"
        "    filter storage   = %s\n"
        "    filter query     = %s\n",
        dwClientVersion,
        pfilter ? pfilter->dwFilter : 0,
        pfilter ? pfilter->pszPartitionFqdn : "NULL",
        pfilter ? pfilter->pszQueryString : "NULL" ));

    //
    //  allocate zone enumeration block
    //  by default allocate space for 64k zones, if go over this we do
    //  a huge reallocation
    //

    //
    //  add all zones that pass filter in a retry loop for cases where
    //  we have more zones than will fit in a reasonably sized array
    //

    while ( !completed && retries-- > 0 )
    {
        //
        //  Allocate a new zone list point array. If we have one from the
        //  last loop, free it.
        //

        freeZoneList( pzoneList );
        pzoneList = ( PDNS_RPC_ZONE_LIST )
                        MIDL_user_allocate(
                            sizeof( DNS_RPC_ZONE_LIST ) +
                            sizeof( PDNS_RPC_ZONE ) * zonePointerCount );
        IF_NOMEM( !pzoneList )
        {
            return DNS_ERROR_NO_MEMORY;
        }
        pzoneList->dwRpcStructureVersion = DNS_RPC_ZONE_LIST_VER;
        pzoneList->dwZoneCount = 0;

        //
        //  Stuff all matching zones into the zone list.
        //

        completed = TRUE;
        count = 0;
        pzone = NULL;

        while ( pzone = Zone_ListGetNextZoneMatchingFilter(
                                    pzone,
                                    pfilter ) )
        {
            //  check against max count, set up for larger allocation if full

            if ( count >= zonePointerCount )
            {
                completed = FALSE;
                zonePointerCount *= 2;
                break;
            }

            //  create RPC zone struct for zone
            //  add to list, keep count

            prpcZone = allocateRpcZone( pzone );
            IF_NOMEM( !prpcZone )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Failed;
            }
            pzoneList->ZoneArray[ count++ ] = prpcZone;
            ++pzoneList->dwZoneCount;
        }
    }

    //  set return count
    //  set returned type
    //  return enumeration

    if ( pzoneList )
    {
        pzoneList->dwZoneCount = count;
    }

    *(PDNS_RPC_ZONE_LIST *)ppDataOut = pzoneList;
    *pdwTypeOut = DNSSRV_TYPEID_ZONE_LIST;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneList(
            "Leaving R_DnsEnumZones() zone list sent:",
            pzoneList );
    }
    return ERROR_SUCCESS;

Failed:

    DNS_PRINT((
        "R_DnsEnumZones2(): failed\n"
        "  status       = %08X\n",
        status ));

    pzoneList->dwZoneCount = count;
    freeZoneList( pzoneList );
    return status;
}   //  Rpc_EnumZones2



DNS_STATUS
Rpc_WriteDirtyZones(
    IN      DWORD       dwClientVersion,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Write back dirty zones. This function is always called in the security
    context of an RPC client.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PZONE_INFO  pzone = NULL;
    DNS_STATUS  status = ERROR_SUCCESS;

    DNS_DEBUG( RPC, ( "Rpc_WriteDirtyZones():\n" ));

    //
    //  loop through all zones
    //      - if dirty
    //  => then write back
    //

    while ( pzone = Zone_ListGetNextZone( pzone ) )
    {
        if ( !pzone->fDirty )
        {
            continue;
        }

        if ( IS_ZONE_CACHE( pzone ) )
        {
            Zone_WriteBackRootHints( FALSE );
        }

        //
        //  lock out transfer while rebuilding
        //

        if ( !Zone_LockForAdminUpdate( pzone ) )
        {
            status = DNS_ERROR_ZONE_LOCKED;
            continue;
        }

        //
        //  re-build zone information that depends on RRs
        //      - name server list
        //      - pointer to SOA record
        //      - WINS or NBSTAT info
        //
        //  note:  except for changes to NS list, this should already be
        //          setup, as individual RR routines do proper zone actions
        //          for SOA, WINS, NBSTAT
        //

        Zone_GetZoneInfoFromResourceRecords( pzone );

        //
        //  write zone back to file
        //

        if ( !pzone->fDsIntegrated  )
        {
            if ( !File_WriteZoneToFile( pzone, NULL, DNS_FILE_IMPERSONATING ) )
            {
                status = ERROR_CANTWRITE;
            }
        }
        Zone_UnlockAfterAdminUpdate( pzone );

        //
        //  notify secondaries of update
        //
        //  obviously faster to do this before file write;  doing write first
        //  so that zone is less likely to be locked when SOA requests come
        //  from secondaries
        //

        if ( !IS_ZONE_CACHE( pzone ) )
        {
            Xfr_SendNotify( pzone );
        }
    }

    //  note, we have error code if ANY zone failed

    return status;
}

//
//  End of zonerpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\inc\sql_1.h ===
//***************************************************************************
//
//  SQL_1.H
//
//  Level 1 Syntax SQL Parser
//
//  Copyright 1999 Microsoft Corporation
//
//
//=================================================================


#ifndef _SQL_1_H_
#define _SQL_1_H_

#include <wbemprov.h>


struct SQL_LEVEL_1_TOKEN
{
    enum { OP_EXPRESSION = 1, TOKEN_AND, TOKEN_OR, TOKEN_NOT };
    enum { IFUNC_NONE = 0, IFUNC_UPPER = 1, IFUNC_LOWER = 2 };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    

    // If the field is a OP_EXPRESSION, then the following are used.
    enum { OP_EQUAL = 1, OP_NOT_EQUAL, OP_EQUALorGREATERTHAN,
		       OP_EQUALorLESSTHAN, OP_LESSTHAN, OP_GREATERTHAN, OP_LIKE };
    
    BSTR    pPropertyName;		// Name of the property on which the operator is applied
    int     nOperator;			// Operator that is applied on property
    BOOL	bConstIsStrNumeric;	// True if the vConstValue is a BSTR and is a UINT32 or any 64bit number
	VARIANT vConstValue;		// Value applied by operator
    BSTR    pPropName2;         // Property compared to.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "
    
    SQL_LEVEL_1_TOKEN();
    SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN&);
   ~SQL_LEVEL_1_TOKEN(); 
    SQL_LEVEL_1_TOKEN& operator=(SQL_LEVEL_1_TOKEN &Src);
    
    void Dump(FILE *);
};


// Contains RPN version of expression.
// ===================================

struct SQL_LEVEL_1_RPN_EXPRESSION
{
    int nNumTokens;
    int nCurSize;
    SQL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;

	int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
	BSTR *pbsRequestedPropertyNames;  // Array of property names which values are to be returned if
    
    SQL_LEVEL_1_RPN_EXPRESSION();
   ~SQL_LEVEL_1_RPN_EXPRESSION();
   
   //Note: this method deletes the token it is passed as an argument
    void AddToken(SQL_LEVEL_1_TOKEN *pTok);
    void AddToken(SQL_LEVEL_1_TOKEN &pTok);
    void AddProperty(LPWSTR pProp);
    void Dump(const char *pszTextFile);
};


class SQL1_Parser
{
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;
    SQL_LEVEL_1_RPN_EXPRESSION* m_pExpression;

	//Cleanup used by d'tor and SetSource
	void Cleanup();

	//Init used by c'tor and SetSource
	void Init(CGenLexSource *pSrc);

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    LPWSTR     m_pIdent;
    LPWSTR     m_pPropComp;
	BOOL       m_bConstIsStrNumeric;
        
    // Parsing functions.
    // ==================
    BOOL Next();
    
    int parse();

    int prop_list();
    int class_name();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int unknown_func_expr();
    int typed_constant();

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL
        };

    SQL1_Parser(CGenLexSource *pSrc);
   ~SQL1_Parser();

    int GetQueryClass(LPWSTR pBuf, int nBufSize);
       
    int Parse(SQL_LEVEL_1_RPN_EXPRESSION **pOutput);
        // use operator delete on pOutput
            
    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
	void SetSource(CGenLexSource *pSrc);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\ntrkcomm\opathlex.cpp ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\ntrkcomm\ntrkcomm.cpp ===
#include <objbase.h>
#include <ntrkcomm.h>


//
//  Most of the functions in this module need to call CoImpersonateClient.
//  This macro wraps the call and a check on the return code.

#define DNS_IMPERSONATE_CLIENT();               \
{                                               \
    HRESULT scimpcli = CoImpersonateClient();   \
    if ( FAILED( scimpcli ) )                   \
    {                                           \
        throw scimpcli;                         \
    }                                           \
}

CWbemServices::CWbemServices(
	IWbemServices* pNamespace)
	:m_pWbemServices(NULL)
{
	m_pWbemServices = pNamespace;
	if(m_pWbemServices != NULL)
		m_pWbemServices->AddRef();
}

CWbemServices::~CWbemServices()
{
	if(m_pWbemServices != NULL)
		m_pWbemServices->Release();
}

HRESULT
CWbemServices::CreateClassEnum(
	/* [in] */ BSTR Superclass,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext __RPC_FAR *pCtx,
	/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
	) 
{
	SCODE sc = m_pWbemServices->CreateClassEnum(
		Superclass,
		lFlags,
		pCtx,
		ppEnum);
	DNS_IMPERSONATE_CLIENT();	
	return sc;
}

HRESULT
CWbemServices::CreateInstanceEnum(
	/* [in] */ BSTR Class,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext __RPC_FAR *pCtx,
	/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
	HRESULT hr = m_pWbemServices->CreateInstanceEnum(
		Class,
		lFlags,
		pCtx,
		ppEnum);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}

HRESULT
CWbemServices::DeleteClass(
	/* [in] */ BSTR Class,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext __RPC_FAR *pCtx,
	/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	HRESULT hr = m_pWbemServices->DeleteClass(
		Class,
		lFlags,
		pCtx,
		ppCallResult);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}

HRESULT
CWbemServices::DeleteInstance(
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	HRESULT hr = m_pWbemServices->DeleteInstance(
		ObjectPath,
		lFlags,
		pCtx,
		ppCallResult);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}



HRESULT
CWbemServices::ExecMethod(
	BSTR strObjectPath, 
	BSTR MethodName, 
	long lFlags, 
	IWbemContext* pCtx,
    IWbemClassObject* pInParams,
	IWbemClassObject** ppOurParams, 
	IWbemCallResult** ppCallResult) 
{
	HRESULT hr = m_pWbemServices->ExecMethod(
		strObjectPath, 
		MethodName, 
		lFlags, 
		pCtx,
		pInParams,
		ppOurParams, 
		ppCallResult) ;
	DNS_IMPERSONATE_CLIENT();	
	return hr;	
}

HRESULT
CWbemServices::ExecNotificationQuery(
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
	HRESULT hr = m_pWbemServices->ExecNotificationQuery(
		QueryLanguage,
		Query,
		lFlags,
		pCtx,
		ppEnum);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}

HRESULT
CWbemServices::ExecQuery(
	/* [in] */ BSTR QueryLanguage,
	/* [in] */ BSTR Query,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext __RPC_FAR *pCtx,
	/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
	HRESULT hr = m_pWbemServices->ExecQuery(
		QueryLanguage,
		Query,
		lFlags,
		pCtx,
		ppEnum);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}

HRESULT
CWbemServices::GetObject(
	/* [in] */ BSTR ObjectPath,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext __RPC_FAR *pCtx,
	/* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
	/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	HRESULT hr = m_pWbemServices->GetObject(
		ObjectPath,
		lFlags,
		pCtx,
		ppObject,
		ppCallResult);
	DNS_IMPERSONATE_CLIENT();	
	return hr;

}
 
HRESULT
CWbemServices::PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	HRESULT hr = m_pWbemServices->PutClass(
		pObject,
		lFlags,
		pCtx,
		ppCallResult);
	DNS_IMPERSONATE_CLIENT();	
	return hr;

}

HRESULT
CWbemServices::PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{	

	HRESULT hr = m_pWbemServices->PutInstance(
		pInst,
		lFlags,
		pCtx,
		ppCallResult);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}

/*CImpersonatedProvider
*  Purpose: provide a general solution for impersonate client for 
*  Wbem providers.
*  USAGE:
*  Inherit from this class, and implement abstact virtual functions.
*  child class should implement function prefixed with "Do".
* ******************************************/
CImpersonatedProvider::CImpersonatedProvider(
	BSTR ObjectPath,
	BSTR User, 
	BSTR Password, 
	IWbemContext * pCtx)
	:m_cRef(0), m_pNamespace(NULL)
{

}
CImpersonatedProvider::~CImpersonatedProvider()
{
	if(m_pNamespace)
		delete m_pNamespace;
}

STDMETHODIMP_(ULONG) 
CImpersonatedProvider::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) 
CImpersonatedProvider::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}
STDMETHODIMP 
CImpersonatedProvider::QueryInterface(
	REFIID riid, 
	PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}

STDMETHODIMP 
CImpersonatedProvider::Initialize(
	LPWSTR pszUser, LONG lFlags,
    LPWSTR pszNamespace, LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	LONG lStatus = WBEM_S_INITIALIZED;
	m_pNamespace = new CWbemServices(pNamespace); 
	if(m_pNamespace == NULL)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
		lStatus = WBEM_E_FAILED;
	}
		
    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(lStatus,0);
    return hr;
}



HRESULT
CImpersonatedProvider::CreateInstanceEnumAsync(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	DNS_IMPERSONATE_CLIENT();
	return DoCreateInstanceEnumAsync(
		Class,
		lFlags,
		pCtx,
		pResponseHandler);
}

HRESULT
CImpersonatedProvider::DeleteInstanceAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	DNS_IMPERSONATE_CLIENT();
	return DoDeleteInstanceAsync(
		ObjectPath,
		lFlags,
		pCtx,
		pResponseHandler);
}


HRESULT
CImpersonatedProvider::ExecMethodAsync(
	const BSTR strObjectPath,
	const BSTR MethodName, 
	long lFlags, 
	IWbemContext* pCtx,
    IWbemClassObject* pInParams,
	IWbemObjectSink* pResponseHandler)
{
	DNS_IMPERSONATE_CLIENT();
	return DoExecMethodAsync(
		strObjectPath,
		MethodName,
		lFlags,
		pCtx,
		pInParams,
		pResponseHandler);
	
}


HRESULT
CImpersonatedProvider::ExecQueryAsync(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	DNS_IMPERSONATE_CLIENT();
	return DoExecQueryAsync(
		QueryLanguage,
		Query,
		lFlags,
		pCtx,
		pResponseHandler);
	
}

HRESULT
CImpersonatedProvider::GetObjectAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	DNS_IMPERSONATE_CLIENT();
	return DoGetObjectAsync(
		ObjectPath,
		lFlags,
		pCtx,
		pResponseHandler);
	
}


HRESULT
CImpersonatedProvider::PutInstanceAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	DNS_IMPERSONATE_CLIENT();
	return DoPutInstanceAsync(
		pInst,
		lFlags,
		pCtx,
		pResponseHandler);
	
}

// CWbemInstanceMgr

CWbemInstanceMgr::CWbemInstanceMgr(
	IWbemObjectSink* pHandler,
	DWORD dwSize)
	:m_pSink(NULL), m_ppInst(NULL), m_dwIndex(0)
{
	m_pSink = pHandler;
	if(m_pSink != NULL)
		m_pSink->AddRef();
	m_dwThreshHold = dwSize;
	m_ppInst = new IWbemClassObject*[dwSize];
	for(DWORD i = 0; i < dwSize; i++)
		m_ppInst[i] = NULL;
}
CWbemInstanceMgr::~CWbemInstanceMgr()
{
	if(m_ppInst != NULL)
	{
		if(m_dwIndex >0)
		{
			m_pSink->Indicate(
				m_dwIndex,
				m_ppInst);
		}

		for(DWORD i =0; i<m_dwIndex; i++)
		{
			if(m_ppInst[i] != NULL)
				(m_ppInst[i])->Release();
		}
		delete [] m_ppInst;
	}
	if(m_pSink != NULL)
		m_pSink->Release();

}

void
CWbemInstanceMgr::Indicate(IWbemClassObject* pInst)
{
	if(pInst == NULL)
		throw WBEM_E_INVALID_PARAMETER;

	m_ppInst[m_dwIndex++] = pInst;
	pInst->AddRef();
	if(m_dwIndex == m_dwThreshHold)
	{

		SCODE  sc = m_pSink->Indicate(
			m_dwIndex,
			m_ppInst);
		if(sc != S_OK)
			throw sc;
		
		// reset state
		for(DWORD i=0; i< m_dwThreshHold; i++)
		{
			if(m_ppInst[i] != NULL)
				(m_ppInst[i])->Release();
			m_ppInst[i] = NULL;
		}
		m_dwIndex = 0;
	
	}
	return;
}

void
CWbemInstanceMgr::SetStatus(
	LONG lFlags,
	HRESULT hr,
	BSTR strParam,
	IWbemClassObject* pObjParam)
{
	m_pSink->SetStatus(
		lFlags,
		hr,
		strParam,
		pObjParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\ntrkcomm\genlex.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    wchar_t * newptr;
                    m_nCurBufSize += 256;
                    newptr = ( wchar_t * ) HeapReAlloc(
                                                GetProcessHeap(),
                                                0,
                                                m_pTokenBuf,
                                                m_nCurBufSize * 2 );
                    if ( !newptr )
                    {
                        return 0;   //  out of memory
                    }
                    m_pTokenBuf = newptr;
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\ntrkcomm\sqllex.cpp ===
//***************************************************************************
//
//  SQLLEX.CPP
//
//  SQL Level 1 DFA Table
//
//  24-Jun-95       Created.
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <sqllex.h>             

#define ST_STRING   22
#define ST_IDENT    27
#define ST_GE       32
#define ST_LE       34
#define ST_NE       37
#define ST_NUMERIC  39
#define ST_REAL     42
#define ST_STRING2  48
#define ST_STRING_ESC 53
#define ST_STRING2_ESC 54

// DFA State Table for SQL Level 1 lexical symbols.
// ================================================

LexEl Sql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

/* 3 */  L'(',   GLEX_EMPTY, 0,          SQL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 4 */  L')',   GLEX_EMPTY, 0,  SQL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 5 */  L'.',   GLEX_EMPTY, 0,  SQL_1_TOK_DOT,         GLEX_ACCEPT,
/* 6 */  L'*',   GLEX_EMPTY, 0,  SQL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 7 */  L'=',   GLEX_EMPTY, 0,  SQL_1_TOK_EQ,          GLEX_ACCEPT,

/* 8 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 9 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 10 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 11 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 12 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 13 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 14 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 15 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 19 */ 0,      GLEX_EMPTY, 0,  SQL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  SQL_1_TOK_COMMA, GLEX_ACCEPT,

    // Unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        SQL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 22 */   L'\n', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 23 */   L'\r', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 24 */   L'"',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 25 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 26 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 27 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 28 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 29 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 32 */  L'=',   GLEX_EMPTY,  0,  SQL_1_TOK_GE,  GLEX_ACCEPT,
/* 33 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 34 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_LE,  GLEX_ACCEPT,
/* 35 */  L'>',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,  GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,    0,  SQL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 37 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,     GLEX_ACCEPT,
/* 38 */  GLEX_ANY,  GLEX_EMPTY,   0,  SQL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 39 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 40 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 41 */  GLEX_ANY, GLEX_EMPTY, 0,          SQL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 42 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 43 */  L'E',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 44 */  L'e',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 45 */  L'+',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 46 */  L'-',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 47 */  GLEX_ANY,       GLEX_EMPTY,   0,     SQL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 48 */   L'\n',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 49 */   L'\r',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 50 */   L'\'',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 51 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 52 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 53 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\ntrkcomm\sqleval.cpp ===
#include "sqleval.h"
#include <stdio.h>
#include <genlex.h>
#include <sqllex.h>
#include <sql_1.h>

// CSqlWmiEvalee
CSqlWmiEvalee::~CSqlWmiEvalee()
{
    if(m_pInstance)
        m_pInstance->Release();
}


CSqlWmiEvalee::CSqlWmiEvalee(
    IWbemClassObject* pInst)
    :m_pInstance(NULL)
{
    m_pInstance = pInst;
    if(m_pInstance)
        m_pInstance->AddRef();
    VariantInit(&m_v);
}

const VARIANT*
CSqlWmiEvalee::Get(
    WCHAR* wszName)
{
    VariantClear(&m_v);
    BSTR bstr = SysAllocString(wszName);
    if (bstr != NULL)
    {
        SCODE sc = m_pInstance->Get(
            bstr, 
            0, 
            &m_v,
            NULL,
            NULL);
        SysFreeString(bstr);
        if(sc != S_OK)
                throw sc;
    }
    
    return &m_v;
}
// CSqlEval

CSqlEval*
CSqlEval::CreateClass(
    SQL_LEVEL_1_RPN_EXPRESSION* pExpr,
    int* pNumberOfToken)
{
    if(pExpr== NULL || *pNumberOfToken<= 0)
        return NULL;
    SQL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens+(*pNumberOfToken-1);
    
//    (*pNumberOfToken)--;
    switch(pToken->nTokenType)
    {
    case SQL_LEVEL_1_TOKEN::TOKEN_AND:
        return new CSqlEvalAnd(
            pExpr,
            pNumberOfToken);
    case SQL_LEVEL_1_TOKEN::TOKEN_OR:
        return new CSqlEvalOr(
            pExpr,
            pNumberOfToken);
    case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
        return new CSqlEvalExp(
            pExpr,
            pNumberOfToken);
    }
    return NULL;
}

BOOL
CSqlEval::Evaluate(
    CSqlEvalee* pInst)
{
    return TRUE;
}

// CSqlEvalAnd
CSqlEvalAnd::~CSqlEvalAnd()
{
    delete m_left;
    delete m_right;
}

CSqlEvalAnd::CSqlEvalAnd(
    SQL_LEVEL_1_RPN_EXPRESSION* pExpr,
    int* pTokens)
:m_left(NULL),m_right(NULL)
{
    (*pTokens)-- ;
    m_left = CSqlEval::CreateClass(
        pExpr,
        pTokens);
    m_right = CSqlEval::CreateClass(
        pExpr,
        pTokens);
    
}

BOOL
CSqlEvalAnd::Evaluate(
    CSqlEvalee* pInst)
{
    return m_left->Evaluate(pInst) && m_right->Evaluate(pInst);
}

void
CSqlEvalAnd::GenerateQueryEnum(CQueryEnumerator& qeInst)
{
    CQueryEnumerator qeNew = qeInst;
    m_left->GenerateQueryEnum(qeNew);

    m_right->GenerateQueryEnum(qeInst);
    qeInst.And(qeNew);

}


// CSqlEvalOR
CSqlEvalOr::~CSqlEvalOr()
{
    delete m_left;
    delete m_right;
}

CSqlEvalOr::CSqlEvalOr(
    SQL_LEVEL_1_RPN_EXPRESSION* pExpr,
    int* pTokens)
:m_left(NULL),m_right(NULL)
{
    (*pTokens)-- ;
    m_left = CSqlEval::CreateClass(
        pExpr,
        pTokens);
    m_right = CSqlEval::CreateClass(
        pExpr,
        pTokens);
    
}

BOOL
CSqlEvalOr::Evaluate(
    CSqlEvalee* pInst)
{
    return m_left->Evaluate(pInst) || m_right->Evaluate(pInst);
}

void
CSqlEvalOr::GenerateQueryEnum(CQueryEnumerator& qeInst)
{
    CQueryEnumerator qeNew = qeInst;
    m_left->GenerateQueryEnum(qeNew);

    m_right->GenerateQueryEnum(qeInst);
    qeInst.Or(qeNew);

}





// CSqlEvalExp
CSqlEvalExp::~CSqlEvalExp()
{
    SysFreeString(m_BstrName);
    VariantClear(&m_v);
}

CSqlEvalExp::CSqlEvalExp(
    SQL_LEVEL_1_RPN_EXPRESSION* pExpr,
    int* pTokens)
:m_BstrName(NULL) 
{
    VariantInit(&m_v);
    SQL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens+(*pTokens-1);
    (*pTokens)--;
    m_BstrName = SysAllocString(pToken->pPropertyName);
    HRESULT hr = VariantCopy(&m_v, &(pToken->vConstValue));
    if ( FAILED( hr ) )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }
    m_op = pToken->nOperator;
    switch(m_v.vt)
    {
    case VT_I2:
        m_dw =  m_v.iVal;
        m_DataType = IntergerType;
        break;
    case VT_I4:
        m_dw = m_v.lVal;
        m_DataType = IntergerType;
        break;
    case VT_BOOL:
        m_DataType = IntergerType;
        m_dw = m_v.boolVal;
        break;
    case VT_BSTR:
        m_DataType = StringType;
        m_bstr = m_v.bstrVal;
        break;
    default:
        throw WBEM_E_INVALID_PARAMETER;
    }
}

BOOL
CSqlEvalExp::Evaluate(
    CSqlEvalee* pInst)
{

    BOOL Result=FALSE;
    const VARIANT* pv = pInst->Get(m_BstrName);
    
    switch(m_DataType)
    {
    case IntergerType:
        DWORD dw;
        switch(pv->vt)
        {
        case VT_I2:
            dw =  pv->iVal;
            break;
        case VT_I4:
            dw = pv->lVal;
            break;
        case VT_BOOL:
            dw = pv->boolVal;
            break;
        }

        // compare
        switch(m_op)
        {
        case SQL_LEVEL_1_TOKEN::OP_EQUAL:
            Result = (dw == m_dw);
            break;
        case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
            Result = !(dw == m_dw);
            break;
        case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
            Result = (dw >= m_dw);
            break;
        case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
            Result = (dw <= m_dw);
            break;
        case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
            Result = (dw < m_dw);
            break;
        case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
            Result = (dw > m_dw);
            break;
        }
        break;
    case StringType:
        int rt = _wcsicmp(pv->bstrVal, m_bstr);
        switch(m_op)
        {
        case SQL_LEVEL_1_TOKEN::OP_EQUAL:
            Result = (rt == 0);
            break;
        case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
            Result = !(rt == 0);
            break;
        case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
            Result = (rt > 0 || rt == 0);
            break;
        case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
            Result = (rt < 0 || rt == 0);
            break;
        case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
            Result = (rt < 0);
            break;
        case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
            Result = (rt > 0 );
            break;
        }
        break;
    }

    return Result;
}

void
CSqlEvalExp::GenerateQueryEnum(CQueryEnumerator& qeInst)
{
    int nSize = qeInst.m_QueryFields.Size();
    const WCHAR** ppName = qeInst.m_QueryFields.Data();
    WCHAR** ppWstr = new WCHAR*[nSize];
    if ( ppWstr )
    {
        for(int i=0;  i< nSize; i++)
        {
            if(_wcsicmp( m_BstrName, ppName[i]) == 0)
            {
                ppWstr[i] = m_v.bstrVal;
            }
            else
                ppWstr[i] = NULL;
        }
        CQueryEnumerator::CStringArray strArray(
            ppWstr,
            nSize);
        delete [] ppWstr;
        qeInst.ArrayAdd(strArray);
    }
}


//CQueryEnumerator;
CQueryEnumerator::CQueryEnumerator(
    WCHAR** ppKeyName,
    int cArg  ):
    m_index(0),m_cNumOfRecordInSet(0),
    m_QuerySet(NULL), m_MaxSize(INITIAL_SIZE)
{
    m_QueryFields = CStringArray(
    ppKeyName,
    cArg);

}


CQueryEnumerator::CQueryEnumerator(
    CQueryEnumerator& instEnumerator)                                  
    :m_index(0), m_MaxSize(INITIAL_SIZE),
    m_QuerySet(NULL), m_cNumOfRecordInSet(0)
{

    m_QueryFields = instEnumerator.m_QueryFields;
    int nSize = instEnumerator.m_cNumOfRecordInSet;
    for(int i=0; i< nSize; i++)
    {
        ArrayAdd(instEnumerator.m_QuerySet[i]);
    }
            
}


CQueryEnumerator::~CQueryEnumerator()
{    
    ArrayDelete();
}

/*
DWORD
CQueryEnumerator::InitEnumerator(
    WCHAR** wszFieldNames,
    int cArg,
    CSqlEval* pEval)
{
    m_QueryFields = CStringArray(
        wszFieldNames,
        cArg);
    

    return S_OK;
}
*/
const
WCHAR**
CQueryEnumerator::GetNext(int& cElement)
{
    if(m_index == m_cNumOfRecordInSet)
    {
        return NULL;
    }
    else
    {
        cElement = m_QuerySet[m_index].Size();
        return m_QuerySet[m_index++].Data();
    }
}


void
CQueryEnumerator::ArrayMerge(
    CQueryEnumerator::CStringArray& strArray)
{
    
    for(int i=0; i< m_cNumOfRecordInSet; i++)
    {
        // if all element of strArray are null, no need to proceed
        if( !strArray.IsNULL())
            m_QuerySet[i].Merge(strArray);
    }
    
}


void
CQueryEnumerator::ArrayAdd(
    CQueryEnumerator::CStringArray & strArray )
{
    // if all elements are null for strArray, means no keys are 
    // selected,we should therefore replace M_querySet this StrArray
    if ( strArray.IsNULL() )
    {
        ArrayDelete();
    }

    if ( m_QuerySet == NULL )
    {
        m_QuerySet = new CStringArray[ m_MaxSize ];
        if ( !m_QuerySet )
        {
            return;
        }
    }

    // if array is full, then expand
    if ( m_index == m_MaxSize )
    {
        CStringArray * pOldSet = m_QuerySet;
        m_MaxSize = m_MaxSize * 2;
        m_QuerySet = new CStringArray[ m_MaxSize ];
        if ( !m_QuerySet )
        {
            return;
        }
        for( int i =0; i < m_MaxSize; i++ )
        {
            if( i < m_index )
            {
                m_QuerySet[ i ] = pOldSet[ i ];
            }
        }
        delete [] pOldSet;
    }

    if ( !( m_cNumOfRecordInSet > 0 && ( m_QuerySet[0] ).IsNULL() ) )
    {
        m_QuerySet[ m_index++ ] = strArray;
        m_cNumOfRecordInSet = m_index;
    }
}


void
CQueryEnumerator::ArrayDelete()
{
    delete [] m_QuerySet;
    m_QuerySet = NULL;
    m_cNumOfRecordInSet = 0;
    m_MaxSize = INITIAL_SIZE;
    m_index = 0;
}

void
CQueryEnumerator::And(
    CQueryEnumerator& instEnumerator)
{
    int nSize = instEnumerator.m_cNumOfRecordInSet;
    if ( nSize > 0 )
    {
        CQueryEnumerator qeOld = *this;
        ArrayDelete();    
        for ( int i=0; i< nSize; i++ )
        {   
            CQueryEnumerator qeNew = qeOld;
            if ( !qeNew.m_QuerySet )
            {
                return;
            }
            qeNew.ArrayMerge( instEnumerator.m_QuerySet[ i ] );
            for ( int j=0; j< qeNew.m_cNumOfRecordInSet; ++j )
            {
                ArrayAdd( qeNew.m_QuerySet[ j ] );
            }
        }
    }    
}

void
CQueryEnumerator::Or(
    CQueryEnumerator& instEnumerator)
{
    for(int i=0; i< instEnumerator.m_cNumOfRecordInSet; i++)
    {

        if(instEnumerator.m_QuerySet[i].IsNULL())
        {
            if(m_cNumOfRecordInSet > 0)
                ArrayDelete();
            ArrayAdd(instEnumerator.m_QuerySet[i]);
        }
        else
        {
            ArrayAdd(instEnumerator.m_QuerySet[i]);
        }
    }
    
}
void
CQueryEnumerator::Reset()
{
    m_index = 0;
}
// CStringArray

CQueryEnumerator::CStringArray::CStringArray()
:m_ppWstr(NULL), m_cNumString(0), m_bIsNull(TRUE)
{
}

CQueryEnumerator::CStringArray::~CStringArray()
{
    if(m_ppWstr != NULL)
    {
        for (int i=0; i< m_cNumString; i++)
        {
            delete [] m_ppWstr[i];
        }
        delete [] m_ppWstr;
    }
}

CQueryEnumerator::CStringArray::CStringArray(
    WCHAR **ppWstrInput,
    int cNumString)
    :m_ppWstr(NULL)
{
    m_cNumString = cNumString;
    m_bIsNull = !StringArrayCopy(
        &m_ppWstr,
        ppWstrInput,
        cNumString);
    
}
CQueryEnumerator::CStringArray::CStringArray(
    CQueryEnumerator::CStringArray& strArray)
    :m_ppWstr(NULL)
{
    m_cNumString = strArray.m_cNumString;
    m_bIsNull = !StringArrayCopy(
        &m_ppWstr,
        strArray.m_ppWstr,
        strArray.m_cNumString);
}

CQueryEnumerator::CStringArray&
CQueryEnumerator::CStringArray::operator =(
    CQueryEnumerator::CStringArray& strArray)
{
    if(m_ppWstr != NULL)
    {
        for (int i=0; i< m_cNumString; i++)
        {
            delete [] *m_ppWstr;
            *m_ppWstr = NULL;
        }
        delete [] m_ppWstr;
        m_ppWstr = NULL;
    }

    m_cNumString = strArray.m_cNumString;
    m_bIsNull= !StringArrayCopy(
        &m_ppWstr,
        strArray.m_ppWstr,
        strArray.m_cNumString);
    return *this;
}

int CQueryEnumerator::CStringArray::Size()
{
    return m_cNumString;
}

const 
WCHAR**
CQueryEnumerator::CStringArray::Data()
{
    return (const WCHAR**) m_ppWstr;
}

// return true if any element is copied,
// false if no element is copied, and no element set to NULL

BOOL
CQueryEnumerator::CStringArray::StringArrayCopy(
    WCHAR*** pppDest,
    WCHAR** ppSrc,
    int cArgs)
{
    BOOL bFlag = FALSE;
    if(cArgs >0 && ppSrc != NULL)
    {
        *pppDest = new WCHAR*[cArgs];
        if ( *pppDest )
        {
            for(int i=0; i< cArgs; i++)
            {
                (*pppDest)[i] = NULL;
                if(ppSrc[i] != NULL)
                {
                    int len = wcslen(ppSrc[i]);
                    (*pppDest)[i] = new WCHAR[len+1];
                    if ( (*pppDest)[i] == NULL )
                    {
                        //
                        //  Free memory already allocated on allocation failure.
                        //
                        
                        for ( int j = 0; j < i; ++j )
                        {
                            delete [] (*pppDest)[ j ];
                        }
                        delete [] *pppDest;
                        *pppDest = NULL;
                        
                        throw WBEM_E_OUT_OF_MEMORY;
                    }
                    wcscpy((*pppDest)[i], ppSrc[i]);
                    bFlag = TRUE;
                }
            }
        }
    }
    return bFlag;
}

void
CQueryEnumerator::CStringArray::Merge(
    CQueryEnumerator::CStringArray& instStrArray)
{
    if(instStrArray.Size() != m_cNumString)
        throw WBEM_E_FAILED;
    const WCHAR** ppSrc = instStrArray.Data();
    for(int i=0; i<m_cNumString; i++)
    {
        // if source is null, we leave target string as it was
        if( ppSrc[i] != NULL)
        {
            if(m_ppWstr[i] == NULL)
            {
                m_ppWstr[i] = new WCHAR[wcslen(ppSrc[i])+1];
                if ( m_ppWstr[i] == NULL )
                {
                    throw WBEM_E_OUT_OF_MEMORY;
                }
                wcscpy(m_ppWstr[i], ppSrc[i]);
            }
            else
            {
                // a key can not take two different value
                if(_wcsicmp(m_ppWstr[i], ppSrc[i]) != 0)
                    throw WBEM_E_INVALID_PARAMETER;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifndef _MFC_VER
#define _MFC_VER 0x0600
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#if _MFC_VER >= 0x0600
#define CBRS_GRIPPER        0x00400000L
#endif

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#if _MFC_VER >= 0x0600
#define CBRS_ALL            0x0040FFFFL
#else
#define CBRS_ALL            0xFFFFL
#endif

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#if _MFC_VER >= 0x0600
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar
#endif

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#if _MFC_VER >= 0x0600
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
#endif
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#if _MFC_VER >= 0x0600
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#endif
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

#if _MFC_VER >= 0x0600
// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D
#endif

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\ntrkcomm\sql_1.cpp ===
//***************************************************************************
//
//  SQL_1.CPP
//
//  Level 1 Syntax SQL Parser
//
//  Implements the syntax described in SQL_1.BNF.  This translates the input
//  into an RPN stream of tokens.
//
//  21-Jun-96       Created.
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <sqllex.h>
#include <sql_1.h>

//#define trace(x) printf x
#define trace(x)

static DWORD TranslateIntrinsic(LPWSTR pFuncName)
{
    if (_wcsicmp(pFuncName, L"UPPER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_UPPER;
    if (_wcsicmp(pFuncName, L"LOWER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_LOWER;
    return SQL_LEVEL_1_TOKEN::IFUNC_NONE;
}

SQL1_Parser::SQL1_Parser(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(Sql_1_LexTable, pSrc);
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_pIdent = 0;
	m_bConstIsStrNumeric = FALSE;

    m_pExpression = new SQL_LEVEL_1_RPN_EXPRESSION;
}

SQL1_Parser::~SQL1_Parser()
{
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    delete m_pLexer;
    delete m_pExpression;
}


int SQL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    // Scan until 'FROM' and then get the class name.
    // ==============================================

    for (;;)
    {
        m_nCurrentToken = m_pLexer->NextToken();

        if (m_nCurrentToken == SQL_1_TOK_EOF)
        {
            m_pLexer->Reset();
            return FAILED;
        }

        if (_wcsicmp(m_pLexer->GetTokenText(), L"from") == 0)
        {
            m_nCurrentToken = m_pLexer->NextToken();
            if (m_nCurrentToken != SQL_1_TOK_IDENT)
            {
                m_pLexer->Reset();
                return FAILED;
            }

            // If here, we have the class name.
            // ================================
            if (wcslen(m_pLexer->GetTokenText()) >= (size_t)nBufLen)
            {
                m_pLexer->Reset();
                return BUFFER_TOO_SMALL;
            }

            wcscpy(pDestBuf, m_pLexer->GetTokenText());
            break;
        }
    }

    // Reset the scanner.
    // ==================
    m_pLexer->Reset();

    return SUCCESS;
}

//
//  NOTE: the caller must delete the output expression.
//

int SQL1_Parser::Parse(SQL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    *pOutput = 0;

    int nRes = parse();
    if (nRes)
        return nRes;

    *pOutput = m_pExpression;
    m_pExpression = 0;

    return SUCCESS;
}

LPSTR ToAnsi(LPWSTR Src)
{
    static char buf[256];
	WideCharToMultiByte(CP_ACP, NULL, Src, -1, buf, 256, NULL, NULL);
    return buf;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL SQL1_Parser::Next()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == SQL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == SQL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        if (_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = SQL_1_TOK_SELECT;
        else if (_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = SQL_1_TOK_FROM;
        else if (_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = SQL_1_TOK_WHERE;
        else if (_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = SQL_1_TOK_LIKE;
        else if (_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = SQL_1_TOK_OR;
        else if (_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = SQL_1_TOK_AND;
        else if (_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = SQL_1_TOK_NOT;
        else if (_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = SQL_1_TOK_IS;
        else if (_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = SQL_1_TOK_NULL;
        else if (_wcsicmp(m_pTokenText, L"TRUE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_INT;
            m_pTokenText = L"65535";
        }
        else if (_wcsicmp(m_pTokenText, L"FALSE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_INT;
            m_pTokenText = L"0";
        }
    }

    return TRUE;
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int SQL1_Parser::parse()
{
    int nRes;

    // SELECT
    // ======
    if (!Next())
        return LEXICAL_ERROR;
    if (m_nCurrentToken != SQL_1_TOK_SELECT)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <prop_list>
    // ===========
    if (nRes = prop_list())
        return nRes;

    // FROM
    // ====
    if (m_nCurrentToken != SQL_1_TOK_FROM)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <classname>
    // ===========
    if (nRes = class_name())
        return nRes;

    // WHERE clause.
    // =============
    return opt_where();
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int SQL1_Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_EOF)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != SQL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is SQL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != SQL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int SQL1_Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != SQL_1_TOK_ASTERISK &&
        m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    if (!Next())
        return LEXICAL_ERROR;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::prop_list_2()
{
    if (m_nCurrentToken == SQL_1_TOK_COMMA)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int SQL1_Parser::property_name()
{
    if (m_nCurrentToken == SQL_1_TOK_ASTERISK)
    {
        trace(("Asterisk\n"));
        m_pExpression->nNumberOfProperties = 0;
            // This signals 'all properties' to the evaluator
        return SUCCESS;
    }

    // Else a property name.
    // =====================

    trace(("Property name %S\n", m_pTokenText));

    m_pExpression->AddProperty(m_pTokenText);

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int SQL1_Parser::class_name()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pExpression->bsClassName = SysAllocString(m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int SQL1_Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int SQL1_Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_OR)
        {
            trace(("Token OR\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int SQL1_Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_AND)
        {
            trace(("Token AND\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int SQL1_Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
        pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
        m_pExpression->AddToken(pNewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        if ( !m_pIdent )
        {
            return FAILED;
        }

        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == SQL_1_TOK_INT ||
             m_nCurrentToken == SQL_1_TOK_REAL ||
             m_nCurrentToken == SQL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER <trailing_prop_expr2>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
    if ( !m_pIdent )
    {
        return FAILED;
    }

    wcscpy(m_pIdent, m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return trailing_prop_expr2();
}

//***************************************************************************
//
//  <trailing_prop_expr2> ::= OPEN_PAREN IDENTIFIER CLOSE_PAREN;
//  <trailing_prop_expr2> ::= <>;
//
//***************************************************************************
// ok

int SQL1_Parser::trailing_prop_expr2()
{
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        // If we got to this point, the string pointed to by m_pIdent
        // was an intrinsic function and not a property name, and we
        // are about to get the property name, so we have to translate
        // the function name to its correct code before overwriting it.
        // ============================================================
        trace(("Translating intrinsic function %S\n", m_pIdent));
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        if ( !m_pIdent )
        {
            return FAILED;
        }

        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
    }

    trace(("Property name is %S\n", m_pIdent));
    return SUCCESS;
}


//***************************************************************************
//
//  <leading_ident_expr> ::= OPEN_PAREN <unknown_func_expr>;
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int SQL1_Parser::leading_ident_expr()
{
    int nRes;
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return unknown_func_expr();
    }
    if (SUCCESS ==  comp_operator())
    {
        return trailing_const_expr();
    }    
    else if(SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != SQL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
        return SUCCESS;
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <unknown_func_expr> ::= IDENTIFIER CLOSE_PAREN
//                          <rel_operator> <trailing_const_expr>;
//
//  <unknown_func_expr> ::= <typed_constant> CLOSE_PAREN
//                          <rel_operator> <trailing_prop_expr>;
//
//***************************************************************************
// ok
int SQL1_Parser::unknown_func_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        if ( !m_pIdent )
        {
            return FAILED;
        }

        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = rel_operator())
            return nRes;
        return trailing_const_expr();
    }

    // Else the other production.
    // ==========================

    if (nRes = typed_constant())
        return nRes;

    // If here, we know that the leading ident was
    // an intrinsic function.
    // ===========================================

    m_dwConstFunction = TranslateIntrinsic(m_pIdent);
    delete m_pIdent;
    m_pIdent = 0;

    if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;
    if (nRes = rel_operator())
        return nRes;

    return trailing_prop_expr();
}

//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//
//***************************************************************************

int SQL1_Parser::trailing_or_null()
{
    if (m_nCurrentToken == SQL_1_TOK_NULL)
    {
	    if (!Next())
		    return LEXICAL_ERROR;
		else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
			return SUCCESS;
        }
    }
    return trailing_const_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_const_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("Function applied to typed const = %S\n", m_pTokenText));

        m_dwConstFunction = TranslateIntrinsic(m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;
	if (!Next())
            return LEXICAL_ERROR;

        if (nRes = typed_constant())
            return nRes;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    return typed_constant();
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the SQL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int SQL1_Parser::finalize()
{
    HRESULT     hr;
    
    // At this point, we have all the info needed for a token.
    // =======================================================

    SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
    if ( pNewTok == NULL )
    {
        return FAILED;
    }

    pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
    pNewTok->pPropertyName = SysAllocString(m_pIdent);
    pNewTok->nOperator = m_nRelOp;

    VariantInit(&pNewTok->vConstValue);
    hr = VariantCopy(&pNewTok->vConstValue, &m_vTypedConst);
    if ( FAILED( hr ) )
    {
		throw WBEM_E_OUT_OF_MEMORY;
    }
   
    pNewTok->dwPropertyFunction = m_dwPropFunction;
    pNewTok->dwConstFunction = m_dwConstFunction;
	pNewTok->bConstIsStrNumeric = m_bConstIsStrNumeric;

    m_pExpression->AddToken(pNewTok);

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    m_pIdent = 0;
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
	m_bConstIsStrNumeric = FALSE;

    return SUCCESS;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int SQL1_Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
	m_bConstIsStrNumeric = FALSE;

    if (m_nCurrentToken == SQL_1_TOK_INT)
    {
        trace((" Integer\n"));
		DWORD x = wcslen(m_pTokenText);

		if (*m_pTokenText == L'-')
		{
			//negative

			if ((x < 11) || 
				((x == 11) && (wcscmp(m_pTokenText, L"-2147483648") <= 0)))
			{
				V_VT(&m_vTypedConst) = VT_I4;
				V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
			}
			else
			{
				trace((" Actually Integer String\n"));
				V_VT(&m_vTypedConst) = VT_BSTR;
				V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
				m_bConstIsStrNumeric = TRUE;
			}
		}
		else
		{
			//positive

			if ((x < 10) || 
				((x == 10) && (wcscmp(m_pTokenText, L"2147483647") <= 0)))
			{
				V_VT(&m_vTypedConst) = VT_I4;
				V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
			}
			else
			{
				trace((" Actually Integer String\n"));
				V_VT(&m_vTypedConst) = VT_BSTR;
				V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
				m_bConstIsStrNumeric = TRUE;
			}
		}

    }
    else if (m_nCurrentToken == SQL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
    }
    else if (m_nCurrentToken == SQL_1_TOK_REAL)
    {
		trace((" Real\n"));
		V_VT(&m_vTypedConst) = VT_R8;
		V_R8(&m_vTypedConst) = 0.0;

		if (m_pTokenText)
		{
			VARIANT varFrom;
			varFrom.vt = VT_BSTR;
			varFrom.bstrVal = SysAllocString(m_pTokenText);

			if(varFrom.bstrVal != NULL)
			{
				VariantClear(&m_vTypedConst);
				VariantInit(&m_vTypedConst);
				SCODE sc = VariantChangeTypeEx(&m_vTypedConst, &varFrom, 0, 0x409, VT_R8);
				VariantClear(&varFrom);

				if(sc != S_OK) 
				{
					VariantClear(&m_vTypedConst);
					VariantInit(&m_vTypedConst);
					return LEXICAL_ERROR;
				}
			}
		}
    }
    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>; 
//  <rel_operator> ::= <comp_operator>; 
//
//***************************************************************************

int SQL1_Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == SQL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != SQL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
		return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
		return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));

		if (m_pIdent)
		{
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
		}
		else
		{
			trace(("    REL OP changed to >=\n"));
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
		}
    }
    else if (m_nCurrentToken == SQL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));

		if (m_pIdent)
		{
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
		}
		else
		{
			trace(("    REL OP changed to >\n"));
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
		}
    }
    else if (m_nCurrentToken == SQL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));

		if (m_pIdent)
		{
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
		}
		else
		{
			trace(("    REL OP changed to <=\n"));
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
		}
    }
    else if (m_nCurrentToken == SQL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));

		if (m_pIdent)
		{
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
		}
		else
		{
			trace(("    REL OP changed to <\n"));
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
		}
    }
    else if (m_nCurrentToken == SQL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

SQL_LEVEL_1_RPN_EXPRESSION::SQL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    pArrayOfTokens = 0;
    bsClassName = 0;
	nNumberOfProperties = 0;
 	pbsRequestedPropertyNames = 0;
    nCurSize = 32;
    nCurPropSize = 32;
    pArrayOfTokens = new SQL_LEVEL_1_TOKEN[nCurSize];
    pbsRequestedPropertyNames = new BSTR[nCurPropSize];
}

SQL_LEVEL_1_RPN_EXPRESSION::~SQL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    for (int i = 0; i < nNumberOfProperties; i++)
        SysFreeString(pbsRequestedPropertyNames[i]);
    delete pbsRequestedPropertyNames;        
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN *pTok)
{
	AddToken(*pTok);
    delete pTok;
	pTok = NULL;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN &pTok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 32;
        SQL_LEVEL_1_TOKEN *pTemp = new SQL_LEVEL_1_TOKEN[nCurSize];
        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = pTok;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddProperty(LPWSTR pProp)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 32;

        BSTR * pTemp = new BSTR[ nCurPropSize ];
        if ( !pTemp )
        {
            return;
        }

        memcpy(pTemp, pbsRequestedPropertyNames,
            sizeof(BSTR) * nNumberOfProperties);
        delete pbsRequestedPropertyNames;
        pbsRequestedPropertyNames = pTemp;
    }

    pbsRequestedPropertyNames[nNumberOfProperties++] = SysAllocString(pProp);
}

void SQL_LEVEL_1_RPN_EXPRESSION::Dump(const char *pszTextFile)
{
    FILE *f = fopen(pszTextFile, "wt");
    if (!f)
        return;

    fprintf(f, "----RPN Expression----\n");
    fprintf(f, "Class name = %S\n", bsClassName);
    fprintf(f, "Properties selected: ");

    if (!nNumberOfProperties)
    {
        fprintf(f, "* = all properties selected\n");
    }
    else for (int i = 0; i < nNumberOfProperties; i++)
    {
        fprintf(f, "%S ", pbsRequestedPropertyNames[i]);
    }
    fprintf(f, "\n------------------\n");
    fprintf(f, "Tokens:\n");

    for (int i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i].Dump(f);

    fprintf(f, "---end of expression---\n");
    fclose(f);
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    pPropertyName = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
	bConstIsStrNumeric = FALSE;
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    pPropertyName = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
	bConstIsStrNumeric = FALSE;

    *this = Src;
}

SQL_LEVEL_1_TOKEN& SQL_LEVEL_1_TOKEN::operator =(SQL_LEVEL_1_TOKEN &Src)
{
	//first clear any old values...
    if (pPropertyName)
        SysFreeString(pPropertyName);

    VariantClear(&vConstValue);

    nTokenType = Src.nTokenType;
    pPropertyName = SysAllocString(Src.pPropertyName);
    nOperator = Src.nOperator;
    HRESULT hr = VariantCopy(&vConstValue, &Src.vConstValue);
    if ( FAILED( hr ) )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }
    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
	bConstIsStrNumeric = Src.bConstIsStrNumeric;
    return *this;
}

SQL_LEVEL_1_TOKEN::~SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    if (pPropertyName)
        SysFreeString(pPropertyName);

    nOperator = 0;
    VariantClear(&vConstValue);
}

void SQL_LEVEL_1_TOKEN::Dump(FILE *f)
{
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            fprintf(f, "OP_EXPRESSION ");
            break;
        case TOKEN_AND:
            fprintf(f, "TOKEN_AND ");
            break;
        case TOKEN_OR:
            fprintf(f, "TOKEN_OR ");
            break;
        case TOKEN_NOT:
            fprintf(f, "TOKEN_NOT ");
            break;
        default:
            fprintf(f, "Error: no token type specified\n");
    }

    if (nTokenType == OP_EXPRESSION)
    {
        char *pOp = "<no op>";
        switch (nOperator)
        {
            case OP_EQUAL: pOp = "OP_EQUAL"; break;
            case OP_NOT_EQUAL: pOp = "OP_NOT_EQUAL"; break;
            case OP_EQUALorGREATERTHAN: pOp = "OP_EQUALorGREATERTHAN"; break;
            case OP_EQUALorLESSTHAN: pOp = "OP_EQUALorLESSTHAN"; break;
            case OP_LESSTHAN: pOp = "OP_LESSTHAN"; break;
            case OP_GREATERTHAN: pOp = "OP_GREATERTHAN"; break;
            case OP_LIKE: pOp = "OP_LIKE"; break;
        }

        fprintf(f, "    Property = %S\n", pPropertyName);
        fprintf(f, "    Operator = %s\n", pOp);
        fprintf(f, "    Value =    ");

        switch (V_VT(&vConstValue))
        {
            case VT_I4:
                fprintf(f, "VT_I4 = %d\n", V_I4(&vConstValue));
                break;
            case VT_BSTR:
                fprintf(f, "VT_BSTR = %S\n", V_BSTR(&vConstValue));
                break;
            case VT_R8:
                fprintf(f, "VT_R8 = %f\n", V_R8(&vConstValue));
                break;
            default:
                fprintf(f, "<unknown>\n");
        }

        switch (dwPropertyFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to property\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to property\n");
                break;
        }
        switch (dwConstFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to const value\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to const value\n");
                break;
        }

    }

    fprintf(f, " <end of token>\n");
}

/////////////////////////////////////////////////////////////////////////////
//
// Algorithm for evaluating the expression, assuming that it has been
// tokenized and translated to Reverse Polish.
//
// Starting point:  (a) An array of SQL tokens.
//                  (b) An empty boolean token stack.
//
// 1.  Read Next Token
//
// 2.  If a SIMPLE EXPRESSION, evaluate it to TRUE or FALSE, and
//     place this boolean result on the stack.  Go to 1.
//
// 3.  If an OR operator, then pop a boolean token into A,
//     pop another boolean token into B. If either A or B are TRUE,
//     stack TRUE.  Else stack FALSE.
//     Go to 1.
//
// 4.  If an AND operator, then pop a boolean token into A,
//     and pop another into B.  If both are TRUE, stack TRUE.
//     Else stack FALSE.
//     Go to 1.
//
// 5.  If a NOT operator, reverse the value of the top-of-stack boolean.
//     Go to 1.
//
// At end-of-input, the result is at top-of-stack.
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsbase.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsbase.h
//
//	Implementation File:
//		dnsbase.cpp
//
//	Description:
//		Definition of the CDnsbase class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include "common.h"
#include "dnsWrap.h"
class CSqlEval;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsBase
//
//	Description:
//  interface class defines all operations can be performed on provider
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsBase  
{
public:
	virtual SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler) = 0;
	virtual SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler ) = 0;
	virtual SCODE ExecuteMethod(
		CObjPath &,
		WCHAR *,
		long,
		IWbemClassObject *,
		IWbemObjectSink *
		) =0;

	virtual SCODE PutInstance( 
		IWbemClassObject *,
        long ,
		IWbemContext *,
		IWbemObjectSink* ); 
	virtual SCODE DeleteInstance( 
		CObjPath &, 
		long ,
		IWbemContext * ,
		IWbemObjectSink *
		); 
	virtual SCODE ExecQuery(
	    CSqlEval * ,
        long lFlags,
        IWbemContext * pCtx,
        IWbemObjectSink * pResponseHandler) ;

	
	CDnsBase();
	CDnsBase(
        const WCHAR *, 
        CWbemServices *);
	virtual  ~CDnsBase();

protected:
    CWbemServices *  m_pNamespace;
	IWbemClassObject* m_pClass;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dconvert.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dconvert.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client Library

    RPC record conversion routines.
    Convert DNS_RECORD records into RPC buffer.

Author:

    Jing Chen (t-jingc)     June, 1998
    reverse functions of rconvert.c

Revision History:

--*/


#include "dnsclip.h"


//
//  size of string in RPC format
//

#define STRING_UTF8_BUF_SIZE( string, fUnicode ) \
        Dns_GetBufferLengthForStringCopy( \
            (string),   \
            0,          \
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )

//
//  Writing strings to RPC buffer format
//

#define WRITE_STRING_TO_RPC_BUF(buf, psz, len, funicode) \
        Dns_StringCopy(     \
            (buf),          \
            NULL,           \
            (psz),          \
            (len),          \
            ((funicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )


//
//  size of name in RPC format
//

#define NAME_UTF8_BUF_SIZE( string, fUnicode ) \
        Dns_GetBufferLengthForStringCopy( \
            (string),   \
            0,          \
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )


//
//  Writing names to RPC buffer format
//

#define WRITE_NAME_TO_RPC_BUF(buf, psz, len, funicode) \
        Dns_StringCopy(     \
            (buf),          \
            NULL,           \
            (psz),          \
            (len),          \
            ((funicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )


//
//  Private protos
//

PDNS_RPC_RECORD
Rpc_AllocateRecord(
    IN      DWORD           BufferLength
    );



//
//  RPC buffer conversion functions
//

PDNS_RPC_RECORD
ADnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert A record from DNS Record to RPC buffer.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;

    DNS_ASSERT( pRR->wDataLength == sizeof(IP_ADDRESS) );

    prpcRR = Rpc_AllocateRecord( sizeof(IP_ADDRESS) );
    if ( !prpcRR )
    {
        return NULL;
    }
    prpcRR->Data.A.ipAddress = pRR->Data.A.IpAddress;

    return prpcRR;
}



PDNS_RPC_RECORD
PtrDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Process PTR compatible record from wire.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  PTR data is another domain name
    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE(pRR->Data.PTR.pNameHost, funicode);

    prpcRR = Rpc_AllocateRecord( sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  write hostname into buffer, immediately following PTR data struct
    //

    prpcRR->Data.PTR.nameNode.cchNameLength = (UCHAR)length;

    WRITE_NAME_TO_RPC_BUF(
        prpcRR->Data.PTR.nameNode.achName,      // buffer
        pRR->Data.PTR.pNameHost,
        0,
        funicode );

    return prpcRR;
}



PDNS_RPC_RECORD
SoaDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert SOA record from DNS Record to RPC buffer.

Arguments:

    pRR - ptr to record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD     prpcRR;
    DWORD               length1;
    DWORD               length2;
    PDNS_RPC_NAME       pnamePrimary;
    PDNS_RPC_NAME       pnameAdmin;
    BOOL                funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length1 = NAME_UTF8_BUF_SIZE( pRR->Data.SOA.pNamePrimaryServer, funicode );

    length2 = NAME_UTF8_BUF_SIZE( pRR->Data.SOA.pNameAdministrator, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_SOA_FIXED_DATA + sizeof(DNS_RPC_NAME) * 2 +
                    length1 + length2 );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy fixed fields
    //

    RtlCopyMemory(
        (PCHAR) & prpcRR->Data.SOA.dwSerialNo,
        (PCHAR) & pRR->Data.SOA.dwSerialNo,
        SIZEOF_SOA_FIXED_DATA );

    //
    //  copy names into RR buffer
    //      - primary server immediately follows SOA data struct
    //      - responsible party follows primary server
    //

    pnamePrimary = &prpcRR->Data.SOA.namePrimaryServer;
    pnamePrimary->cchNameLength = (UCHAR) length1;

    pnameAdmin = DNS_GET_NEXT_NAME( pnamePrimary );
    pnameAdmin->cchNameLength = (UCHAR) length2;

    WRITE_NAME_TO_RPC_BUF(
        pnamePrimary->achName,
        pRR->Data.Soa.pNamePrimaryServer,
        0,
        funicode );

    WRITE_NAME_TO_RPC_BUF(
        pnameAdmin->achName,
        pRR->Data.Soa.pNameAdministrator,
        0,
        funicode );

    return prpcRR;
}



PDNS_RPC_RECORD
TxtDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read TXT compatible record from wire.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           bufLength;
    DWORD           length;
    INT             count;
    PCHAR           pch;
    PCHAR *         ppstring;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //      - allocate space for each string
    //      - and ptr for each string
    //

    bufLength = 0;
    count = pRR->Data.TXT.dwStringCount;
    ppstring = pRR->Data.TXT.pStringArray;

    while ( count-- )
    {
        length = STRING_UTF8_BUF_SIZE( *ppstring++, funicode );
        bufLength += sizeof(DNS_RPC_NAME) + length;
    }

    //  allocate

    prpcRR = Rpc_AllocateRecord( bufLength );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  go back through list copying strings to buffer
    //      - ptrs to strings are saved to argv like data section
    //          ppstring walks through this section
    //      - first string written immediately following data section
    //      - each subsequent string immediately follows predecessor
    //          pchbuffer keeps ptr to position to write strings
    //
    //  JBUGBUG:  a mess
    //

    pch = (PCHAR) &prpcRR->Data.TXT;
    ppstring = pRR->Data.TXT.pStringArray;
    count =  pRR->Data.TXT.dwStringCount;

    while ( count-- )
    {
        length = STRING_UTF8_BUF_SIZE( *ppstring, funicode );
        (UCHAR) *pch++ += (UCHAR) length;    //+1 for TXT type only

        length = WRITE_STRING_TO_RPC_BUF(
                    pch,
                    *ppstring++,
                    0,
                    funicode );
        pch += length;
#if DBG
        DNS_PRINT((
            "Read text string %s\n",
            * (ppstring - 1) ));
#endif
    }

    return prpcRR;
}



PDNS_RPC_RECORD
MinfoDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read MINFO record from wire.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           length1;
    DWORD           length2;
    PDNS_RPC_NAME   prpcName1;
    PDNS_RPC_NAME   prpcName2;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //

    length1 = NAME_UTF8_BUF_SIZE( pRR->Data.MINFO.pNameMailbox, funicode );
    length2 = NAME_UTF8_BUF_SIZE( pRR->Data.MINFO.pNameErrorsMailbox, funicode );

    prpcRR = Rpc_AllocateRecord( sizeof(DNS_RPC_NAME) * 2 + length1 + length2 );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy names into RR buffer
    //      - mailbox immediately follows MINFO data struct
    //      - errors mailbox immediately follows primary server
    //

    prpcName1 = &prpcRR->Data.MINFO.nameMailBox;
    prpcName1->cchNameLength = (UCHAR) length1;

    prpcName2 = DNS_GET_NEXT_NAME( prpcName1);
    prpcName2->cchNameLength = (UCHAR) length2;

    WRITE_NAME_TO_RPC_BUF(
        prpcName1->achName,
        pRR->Data.MINFO.pNameMailbox,
        0,
        funicode );

    WRITE_NAME_TO_RPC_BUF(
        prpcName2->achName,
        pRR->Data.MINFO.pNameErrorsMailbox,
        0,
        funicode );

    return prpcRR;
}



PDNS_RPC_RECORD
MxDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    convert MX compatible record.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.MX.pNameExchange, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_MX_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy preference
    //

    prpcRR->Data.MX.wPreference = pRR->Data.MX.wPreference;

    //
    //  write hostname into buffer, immediately following MX struct
    //

    prpcName = &prpcRR->Data.MX.nameExchange;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.MX.pNameExchange,
        0,
        funicode );

    return prpcRR;
}



PDNS_RPC_RECORD
FlatDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert memory copy compatible record.
    Includes AAAA and WINS types.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = pRR->wDataLength;

    prpcRR = Rpc_AllocateRecord( bufLength );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy packet data to record
    //

    RtlCopyMemory(
        & prpcRR->Data,
        & pRR->Data,
        bufLength );

    return prpcRR;
}



PDNS_RPC_RECORD
SrvDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    convert SRV record.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.SRV.pNameTarget, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_SRV_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy SRV fixed fields
    //

    prpcRR->Data.SRV.wPriority = pRR->Data.SRV.wPriority;
    prpcRR->Data.SRV.wWeight   = pRR->Data.SRV.wWeight;
    prpcRR->Data.SRV.wPort     = pRR->Data.SRV.wPort;

    //
    //  write hostname into buffer, immediately following SRV struct
    //

    prpcName = &prpcRR->Data.SRV.nameTarget;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.SRV.pNameTarget,
        0,
        funicode );

    return prpcRR;
}



PDNS_RPC_RECORD
NbstatDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read WINSR record from wire.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.WINSR.pNameResultDomain, funicode );

    prpcRR = Rpc_AllocateRecord(
                SIZEOF_NBSTAT_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy WINSR fixed fields
    //

    prpcRR->Data.WINSR.dwMappingFlag   = pRR->Data.WINSR.dwMappingFlag;
    prpcRR->Data.WINSR.dwLookupTimeout = pRR->Data.WINSR.dwLookupTimeout;
    prpcRR->Data.WINSR.dwCacheTimeout  = pRR->Data.WINSR.dwCacheTimeout;

    //
    //  write hostname into buffer, immediately following WINSR struct
    //

    prpcName = &prpcRR->Data.WINSR.nameResultDomain;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.WINSR.pNameResultDomain,
        0,
        funicode );

    return prpcRR;
}



//
//  Jump table for DNS_RECORD => RPC buffer conversion.
//

typedef PDNS_RPC_RECORD (* RECORD_TO_RPC_CONVERT_FUNCTION)( PDNS_RECORD );

RECORD_TO_RPC_CONVERT_FUNCTION   RecordToRpcConvertTable[] =
{
    NULL,                       //  ZERO
    ADnsRecordConvert,          //  A
    PtrDnsRecordConvert,        //  NS
    PtrDnsRecordConvert,        //  MD
    PtrDnsRecordConvert,        //  MF
    PtrDnsRecordConvert,        //  CNAME
    SoaDnsRecordConvert,        //  SOA
    PtrDnsRecordConvert,        //  MB
    PtrDnsRecordConvert,        //  MG
    PtrDnsRecordConvert,        //  MR
    NULL,                       //  NULL
    FlatDnsRecordConvert,       //  WKS
    PtrDnsRecordConvert,        //  PTR
    TxtDnsRecordConvert,        //  HINFO
    MinfoDnsRecordConvert,      //  MINFO
    MxDnsRecordConvert,         //  MX
    TxtDnsRecordConvert,        //  TXT
    MinfoDnsRecordConvert,      //  RP
    MxDnsRecordConvert,         //  AFSDB
    TxtDnsRecordConvert,        //  X25
    TxtDnsRecordConvert,        //  ISDN
    MxDnsRecordConvert,         //  RT
    NULL,                       //  NSAP
    NULL,                       //  NSAPPTR
    NULL,                       //  SIG
    NULL,                       //  KEY
    NULL,                       //  PX
    NULL,                       //  GPOS
    FlatDnsRecordConvert,       //  AAAA
    NULL,                       //  29
    NULL,                       //  30
    NULL,                       //  31
    NULL,                       //  32
    SrvDnsRecordConvert,        //  SRV

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    NULL,                       //  DNS_TYPE_ATMA
    NULL,                       //  0x0023
    NULL,                       //  0x0024
    NULL,                       //  0x0025
    NULL,                       //  0x0026
    NULL,                       //  0x0027
    NULL,                       //  0x0028

    NULL,                       //  DNS_TYPE_TKEY
    NULL,                       //  DNS_TYPE_TSIG

    FlatDnsRecordConvert,       //  WINS
    NbstatDnsRecordConvert      //  WINS-R
};



PDNS_RPC_RECORD
Rpc_AllocateRecord(
    IN      DWORD           BufferLength
    )
/*++

Routine Description:

    Allocate RPC record structure.

Arguments:

    wBufferLength - desired buffer length (beyond structure header)

Return Value:

    Ptr to buffer.
    NULL on error.

--*/
{
    PDNS_RPC_RECORD prr;

    if ( BufferLength > MAXWORD )
    {
        return NULL;
    }

    prr = ALLOCATE_HEAP( SIZEOF_DNS_RPC_RECORD_HEADER + BufferLength );
    if ( !prr )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    // set datalength to buffer length

    prr->wDataLength = (WORD) BufferLength;

    return( prr );
}




PDNS_RPC_RECORD
DnsConvertRecordToRpcBuffer(
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Convert standard DNS record to RPC buffer.

Arguments:

    pRecord  -- DNS Record to be converted.

    //fUnicode -- flag, write records into unicode

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRecord;
    WORD            index;
    WORD            type;
    RECORD_TO_RPC_CONVERT_FUNCTION   pFunc;


    DNS_ASSERT( DNS_IS_DWORD_ALIGNED(pRecord) );
    IF_DNSDBG( RPC2 )
    {
        DNS_PRINT((
            "Enter DnsConvertRecordToRpcBuffer()\n"
            "    pRecord   = %p\n",
            pRecord ));
    }

    //
    //  convert record
    //      set unicode flag if converting
    //

    type = pRecord->wType;
    index = INDEX_FOR_TYPE( type );
    DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

    if ( !index || !(pFunc = RecordToRpcConvertTable[ index ]) )
    {
        //  if unknown type try flat record copy -- best we can
        //  do to protect if server added new types since admin built

        DNS_PRINT((
            "ERROR:  no DNS_RECORD to RPC conversion routine for type %d.\n"
            "    using flat conversion routine.\n",
            type ));
        pFunc = FlatDnsRecordConvert;
    }

    prpcRecord = (*pFunc)( pRecord );
    if ( ! prpcRecord )
    {
        DNS_PRINT((
            "ERROR:  Record build routine failure for record type %d.\n"
            "    status = %p\n\n",
            type,
            GetLastError() ));
        return NULL;
    }

    //
    //  fill out record structure
    //

    prpcRecord->wType = type;
    prpcRecord->dwTtlSeconds = pRecord->dwTtl;

    IF_DNSDBG( INIT )
    {
        DNS_PRINT(( "New RPC buffer built\n" ));
    }


    IF_DNSDBG( RPC2 )
    {
        DNS_PRINT((
            "Finished DnsConvertRpcBufferToRecords()" ));
    }

    return prpcRecord;
}

//
//  End dconvert.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsbase.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: dnsbase.cpp
//
//  Description:    
//      Implementation of CDnsbase class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////

#include "DnsWmi.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsBase::CDnsBase()
{

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CProvBase::CProvBase
//
//	Description:
//		constructor
//
//	Arguments:
//      wzName            [IN]    class name
//      pNamespace        [IN]    WMI namespace
//
//	Return Value:
//		none
//
//--
/////////////////////////////////////////////////////////////////////////////

CDnsBase::CDnsBase(
	const WCHAR *   wzName,
	CWbemServices * pNamespace)
	:m_pNamespace(NULL),
	m_pClass(NULL)
{
	m_pNamespace = pNamespace;
	BSTR bstrClass = SysAllocString(wzName);
	SCODE sc;
	
	if(bstrClass == NULL)
	{
		sc = WBEM_E_OUT_OF_MEMORY;
	}
	else
	{
		sc = m_pNamespace->GetObject(
			bstrClass, 
			0,
			0,
			&m_pClass, 
			NULL);
		SysFreeString(bstrClass);
	}

	// failed to construct object, 
	if( FAILED ( sc ) )
	{
		throw sc;
		
	}
}

CDnsBase::~CDnsBase()
{
	if(m_pClass)
		m_pClass->Release();
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsBase::PutInstance
//
//	Description:
//		default implementation of PutInstance
//
//	Arguments:
//      pInst               [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsBase::PutInstance(
	IWbemClassObject *  pInst ,
    long                lFlags,
	IWbemContext*       pCtx ,
	IWbemObjectSink *   pHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}; 
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CProvBase::DeleteInstance
//
//	Description:
//		delete the instance pointed by ObjectPath
//
//	Arguments:
//      ObjectPath          [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsBase::DeleteInstance( 
	CObjPath&			ObjectPath,
	long				lFlags,
	IWbemContext *		pCtx,
	IWbemObjectSink *	pHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}


SCODE CDnsBase::ExecQuery(
	CSqlEval*			pSqlEval,
    long				lFlags,
    IWbemContext *		pCtx,
    IWbemObjectSink *	pHandler) 
{
	return EnumInstance(
		lFlags,
		pCtx,
		pHandler);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnscache.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnscache.h
//
//	Implementation File:
//		dnscache.cpp
//
//	Description:
//		Definition of the CDnscache class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


#include "dnsbase.h"
class CObjPath;
/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsCache
//
//	Description:
//      class defination for dns cache
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsCache  :  CDnsBase
{
public:
	CDnsCache();
	CDnsCache(
		const WCHAR*, 
		CWbemServices*);
	~CDnsCache();
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 
	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pResponseHandler 
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnscache.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: dnscache.cpp
//
//  Description:    
//      Implementation of CDnscache class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsCache::CreateThis(
    const WCHAR *       wszName,         //class name
    CWbemServices *     pNamespace,  //namespace
    const char *        szType         //str type id
    )
{
    return new CDnsCache(wszName, pNamespace);
}
CDnsCache::CDnsCache()
{

}
CDnsCache::CDnsCache(
	const WCHAR* wszName,
	CWbemServices *pNamespace)
	:CDnsBase(wszName, pNamespace)
{
	
}


CDnsCache::~CDnsCache()
{

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsCache::EnumInstance
//
//	Description:
//		enum instances of dns cache
//
//	Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsCache::EnumInstance(
	long				lFlags,
	IWbemContext *		pCtx,
	IWbemObjectSink *	pHandler )
{
	CWbemClassObject Inst;
	m_pClass->SpawnInstance(0,&Inst);
	CDnsWrap& dns = CDnsWrap::DnsObject();
	Inst.SetProperty(
		dns.GetServerName(),
		PVD_DOMAIN_SERVER_NAME);
	Inst.SetProperty(
		PVD_DNS_CACHE,
		PVD_DOMAIN_FQDN);
	Inst.SetProperty(
		PVD_DNS_CACHE,
		PVD_DOMAIN_CONTAINER_NAME);
	pHandler->Indicate(1, &Inst);
	return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsCache::GetObject
//
//	Description:
//		retrieve cache object based given object path
//
//	Arguments:
//      ObjectPath          [IN]    object path to cluster object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsCache::GetObject(
	CObjPath &          ObjectPath,
	long                lFlags,
	IWbemContext  *     pCtx,
	IWbemObjectSink *   pHandler)
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	wstring wstrServer = ObjectPath.GetStringValueForProperty(
		PVD_DOMAIN_SERVER_NAME);

	if(WBEM_S_NO_ERROR != dns.ValidateServerName(wstrServer.data()))
		return WBEM_E_FAILED;
	wstring wstrContainer = ObjectPath.GetStringValueForProperty(
			PVD_DOMAIN_CONTAINER_NAME);
	if(_wcsicmp(
        wstrContainer.data(),
		PVD_DNS_CACHE) == 0)
	{
		wstring wstrFQDN= ObjectPath.GetStringValueForProperty(
				PVD_DOMAIN_FQDN);
		if(_wcsicmp(wstrFQDN.data(),
				PVD_DNS_CACHE) == 0)
		{
			// founded
			CWbemClassObject Inst;
			m_pClass->SpawnInstance(0, &Inst);
			Inst.SetProperty(
				dns.GetServerName(),
				PVD_DOMAIN_SERVER_NAME);
			Inst.SetProperty(
				PVD_DNS_CACHE,
				PVD_DOMAIN_FQDN);
			Inst.SetProperty(
				PVD_DNS_CACHE,
				PVD_DOMAIN_CONTAINER_NAME);
			pHandler->Indicate(1, &Inst);
		}
	}

	return WBEM_S_NO_ERROR;

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsCache::ExecuteMethod
//
//	Description:
//		execute methods defined for cache class in the mof 
//
//	Arguments:
//      ObjectPath          [IN]    object path to cluster object
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsCache::ExecuteMethod(
	CObjPath &          objPath,
	WCHAR *             wzMethodName,
	long                lFlag,
	IWbemClassObject *  pInArgs,
	IWbemObjectSink *   pHandler) 
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	wstring wstrServer =  objPath.GetStringValueForProperty(
		PVD_DOMAIN_SERVER_NAME);
	
	if( FAILED ( dns.ValidateServerName(wstrServer.data())) )
		return WBEM_E_INVALID_PARAMETER;

	if(_wcsicmp(
		wzMethodName,  
		PVD_MTH_CACHE_CLEARDNSSERVERCACHE) == 0)
	{
		  return dns.dnsClearCache();
	}
	else if(_wcsicmp(
		wzMethodName,
		PVD_MTH_ZONE_GETDISTINGUISHEDNAME) == 0)
	{
		wstring wstrName;
		wstring wstrCache = PVD_DNS_CACHE;
		CWbemClassObject OutParams, OutClass, Class ;
		HRESULT hr;
	
		dns.dnsDsZoneName(wstrName, wstrCache);


		BSTR ClassName=NULL;
		ClassName = AllocBstr(PVD_CLASS_CACHE); 
		hr = m_pNamespace->GetObject(ClassName, 0, 0, &Class, NULL);
		SysFreeString(ClassName);
		if ( SUCCEEDED ( hr ) )
		{
			Class.GetMethod( wzMethodName, 0, NULL, &OutClass );
			OutClass.SpawnInstance(0, &OutParams);
			OutParams.SetProperty(wstrName, PVD_DNS_RETURN_VALUE);
			hr = pHandler->Indicate(1, &OutParams);
		}

		return hr;
	}
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsCache::PutInstance
//
//	Description:
//		save this instance
//
//	Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsCache::PutInstance(
	IWbemClassObject *  pInst ,
    long                lFlags,
	IWbemContext*       pCtx ,
	IWbemObjectSink *   pHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}; 

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsCache::DeleteInstance
//
//	Description:
//		delete the object specified in rObjPath
//
//	Arguments:
//      rObjPath            [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsCache::DeleteInstance( 
	CObjPath &          ObjectPath,
	long                lFlags,
	IWbemContext *      pCtx,
	IWbemObjectSink *   pResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsdomain.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsdomain.h
//
//	Implementation File:
//		dnscache.cpp
//
//	Description:
//		Definition of the CDnsDomain class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"

class CObjPath;
class CDnsRpcNode;
/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsDomain
//
//	Description:
//      class defination for dns domain
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsDomain : public CDnsBase 
{
public:
	CDnsDomain();
	~CDnsDomain();
	CDnsDomain(
		const WCHAR*,
		CWbemServices*
		);
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 
	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pHandler 
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );
    static SCODE InstanceFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsdomaindomaincontainment.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsdomanidomaincontainment.h
//
//	Implementation File:
//		dnsdomanidomaincontainment.cpp
//
//	Description:
//		Definition of the CDnsDomainDomainContainment class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"
class CObjPath;
class CDnsRpcNode;


class CDnsDomainDomainContainment  : CDnsBase
{
public:
	CDnsDomainDomainContainment();
	CDnsDomainDomainContainment(
		const WCHAR*, 
		CWbemServices*
		);
	~CDnsDomainDomainContainment();
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;
	static SCODE InstanceFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
		);
    static CDnsBase* CreateThis(
        const WCHAR *       wszName,        
        CWbemServices *     pNamespace,  
        const char *        szType       
        );



};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsclip.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnsclip.h

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Main header file for DNS client API library.

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

--*/


#ifndef _DNSCLIP_INCLUDED_
#define _DNSCLIP_INCLUDED_

#pragma warning(disable:4214)
#pragma warning(disable:4514)
#pragma warning(disable:4152)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>

//  headers are screwed up
//  if you bring in nt.h, then don't bring in winnt.h and
//  then you miss these

#ifndef MAXWORD
#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXWORD     0xffff
#define MAXDWORD    0xffffffff
#endif

#include <winsock2.h>
#include "dnsrpc_c.h"   //  MIDL generated RPC interface definitions
#include <dnsrpc.h>

#include <stdio.h>
#include <stdlib.h>

#define  NO_DNSAPI_DLL
#include "dnslib.h"


//
//  Internal routines
//
#ifdef __cplusplus
extern "C"
{
#endif

VOID
DnssrvCopyRpcNameToBuffer(
    IN      PSTR            pResult,
    IN      PDNS_RPC_NAME   pName
    );

PDNS_RPC_RECORD
DnsConvertRecordToRpcBuffer(
    IN      PDNS_RECORD     pRecord
    );

PVOID
DnssrvMidlAllocZero(
    IN      DWORD           dwSize
    );

PDNS_NODE
DnsConvertRpcBuffer(
    OUT     PDNS_NODE *     ppNodeLast,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[],
    IN      BOOLEAN         fUnicode
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsStub(
    IN      LPCSTR      Server,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     PBYTE *     ppBuffer
    );

#ifdef __cplusplus
}
#endif  // __cplusplus
//
//  Heap routines
//  Use dnsapi.dll memory routines
//

#define ALLOCATE_HEAP(iSize)            Dns_Alloc(iSize)
#define ALLOCATE_HEAP_ZERO(iSize)       Dns_AllocZero(iSize)
#define REALLOCATE_HEAP(pMem,iSize)     Dns_Realloc((pMem),(iSize))
#define FREE_HEAP(pMem)                 Dns_Free(pMem)


//
//  Debug stuff
//

#if DBG

#undef  ASSERT
#define ASSERT( expr )          DNS_ASSERT( expr )

#define DNSRPC_DEBUG_FLAG_FILE  ("dnsrpc.flag")
#define DNSRPC_DEBUG_FILE_NAME  ("dnsrpc.log")

#define DNS_DEBUG_EVENTLOG      0x00000010
#define DNS_DEBUG_RPC           0x00000020
#define DNS_DEBUG_STUB          0x00000040

#define DNS_DEBUG_HEAP          0x00010000
#define DNS_DEBUG_HEAP_CHECK    0x00020000
#define DNS_DEBUG_REGISTRY      0x00080000

#endif

#endif //   _DNSCLIP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsdomain.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: dnsdomain.cpp
//
//  Description:    
//      Implementation of CDnsDomain class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        create an instance of CDnsDomain
//
//    Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
CDnsBase* 
CDnsDomain::CreateThis(
    const WCHAR *       wszName,         //class name
    CWbemServices *     pNamespace,  //namespace
    const char *        szType         //str type id
    )
{
    return new CDnsDomain(wszName, pNamespace);
}

CDnsDomain::CDnsDomain()
{

}

CDnsDomain::CDnsDomain(
    const WCHAR *   wszName,
    CWbemServices * pNamespace)
    :CDnsBase(wszName, pNamespace)
{
}

CDnsDomain::~CDnsDomain()
{
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        call back function to enum domain instance. 
//      if pNode represents a domain node, create a wmi domain instance
//
//    Arguments:
//      ParentDomain        [IN]    Parent domain
//      pFilter             [IN]    pointer to object that contains the criteria to filter
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsDomain::InstanceFilter(
    CDomainNode &       ParentDomain,
    PVOID               pFilter,
    CDnsRpcNode *       pNode,
    IWbemClassObject *  pClass,
    CWbemInstanceMgr &  InstMgr )
    
{
    if (!pNode->IsDomainNode())
        return 0;
    CWbemClassObject NewInst;
    CDnsWrap& dns = CDnsWrap::DnsObject();
    pClass->SpawnInstance(0, &NewInst);
    
    //setting server name
    NewInst.SetProperty(
        dns.GetServerName(),
        PVD_DOMAIN_SERVER_NAME );
    
    // setting container name             
    NewInst.SetProperty(
        ParentDomain.wstrZoneName, 
        PVD_DOMAIN_CONTAINER_NAME );

    // concatinate domain name
    wstring wstrParentFQDN = ParentDomain.wstrNodeName;
    wstring wstrFQDN = pNode->GetNodeName();
    wstrFQDN += PVD_DNS_LOCAL_SERVER + wstrParentFQDN;

    // setting domain name
    NewInst.SetProperty(
        wstrFQDN, 
        PVD_DOMAIN_FQDN );

    InstMgr.Indicate( NewInst.data() );
    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enum instances of dns domain
//
//    Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsDomain::EnumInstance(
    long                lFlags,
    IWbemContext *        pCtx,
    IWbemObjectSink *    pHandler)
{
    // Get all zones
    list<CDomainNode> objList, domainList;
    CDnsWrap& dns = CDnsWrap::DnsObject();
    SCODE sc = dns.dnsEnumDomainForServer(&objList);

    list<CDomainNode>::iterator i;
    CWbemInstanceMgr InstMgr(
        pHandler,
        100);
    for(i=objList.begin(); i!=objList.end(); ++i)
    {
        sc = dns.dnsEnumRecordsForDomainEx(
            *i,
            NULL,
            &InstanceFilter,
            TRUE,
            DNS_TYPE_ALL,
            DNS_RPC_VIEW_ALL_DATA,
            m_pClass,
            InstMgr);
        // Zones are domains, let's set them
        CWbemClassObject NewInst;
        if( SUCCEEDED ( m_pClass->SpawnInstance(0, &NewInst) ) )
        {
            
            wstring wstrNodeName = i->wstrNodeName;
            NewInst.SetProperty(
                dns.GetServerName(), 
                PVD_DOMAIN_SERVER_NAME);
            NewInst.SetProperty(
                i->wstrZoneName, 
                PVD_DOMAIN_CONTAINER_NAME);
            if(! _wcsicmp(i->wstrZoneName.data(), PVD_DNS_ROOTHINTS) ||
                ! _wcsicmp(i->wstrZoneName.data(), PVD_DNS_CACHE) )
                 wstrNodeName = i->wstrZoneName;
            
            NewInst.SetProperty(
                wstrNodeName,
                PVD_DOMAIN_FQDN);
            pHandler->Indicate(
                1,
                &NewInst);
        }
    }

    return sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        retrieve domain object pointed by the given object path
//
//    Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomain::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler)
{
    // validate input
    wstring wstrServerName = 
        ObjectPath.GetStringValueForProperty(
            PVD_DOMAIN_SERVER_NAME);
    if( wstrServerName.empty() ||
        ObjectPath.GetStringValueForProperty(
            PVD_DOMAIN_CONTAINER_NAME).empty() ||
        ObjectPath.GetStringValueForProperty(PVD_DOMAIN_FQDN).empty()
        )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    CDnsWrap& dns = CDnsWrap::DnsObject();
    if(WBEM_S_NO_ERROR != dns.ValidateServerName(wstrServerName.data()))
        return WBEM_E_INVALID_PARAMETER;

    SCODE sc = dns.dnsGetDomain(
        ObjectPath,
        m_pClass,
        pHandler);
    return sc;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        execute methods defined for domain class in the mof 
//
//    Arguments:
//      ObjPath             [IN]    pointing to the object that the 
//                                  method should be performed on
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomain::ExecuteMethod(
    CObjPath &          ObjPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
    CDnsWrap& dns = CDnsWrap::DnsObject();
    wstring wstrDomainName =  ObjPath.GetStringValueForProperty(
        PVD_DOMAIN_FQDN);

    if( _wcsicmp(
            wzMethodName,
            PVD_MTH_ZONE_GETDISTINGUISHEDNAME) == 0 )
    {
        wstring wstrName;
        CWbemClassObject OutParams, OutClass, Class ;
        HRESULT hr;
    
        dns.dnsDsZoneName(wstrName, wstrDomainName);

        BSTR ClassName=NULL;
        ClassName = AllocBstr(PVD_CLASS_DOMAIN); 
        hr = m_pNamespace->GetObject(ClassName, 0, 0, &Class, NULL);
        SysFreeString(ClassName);
        if ( SUCCEEDED ( hr ) )
        {
            Class.GetMethod( wzMethodName, 0, NULL, &OutClass);
            OutClass.SpawnInstance(0, &OutParams);
            OutParams.SetProperty(wstrName, PVD_DNS_RETURN_VALUE);
            hr = pHandler->Indicate(1, &OutParams);
        }

        return hr;
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        save this instance
//
//    Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsDomain::PutInstance(
    IWbemClassObject *  pInst ,
    long                lFlags,
    IWbemContext*       pCtx ,
    IWbemObjectSink *   pHandler)
{

    return WBEM_S_NO_ERROR;
}; 
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        delete the object specified in ObjectPath
//
//    Arguments:
//      ObjectPath          [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomain::DeleteInstance( 
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pHandler) 
{
    wstring wstrContainer = ObjectPath.GetStringValueForProperty(
        PVD_DOMAIN_CONTAINER_NAME);
    string strContainer;
    WcharToString(
        wstrContainer.data(),
        strContainer);

    wstring wstrDomain = ObjectPath.GetStringValueForProperty(PVD_DOMAIN_FQDN);
    string strDomain;
    WcharToString(
        wstrDomain.data(), 
        strContainer);

    CDnsWrap& dns = CDnsWrap::DnsObject();
    SCODE sc =  dns.dnsDeleteDomain(
        (char*)strContainer.data(),
        (char*) strDomain.data());
    pHandler->SetStatus(
        0,
        sc,
        NULL,
        NULL);
    return WBEM_S_NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsdomaindomaincontainment.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: DnsDomainDomainContainment.cpp
//
//  Description:    
//      Implementation of CDnsDomainDomainContainment class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"

 
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        create an instance of CDnsDomainDomainContainment
//
//    Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
CDnsBase* 
CDnsDomainDomainContainment::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsDomainDomainContainment(wszName, pNamespace);
}


CDnsDomainDomainContainment::CDnsDomainDomainContainment()
{
}


CDnsDomainDomainContainment::CDnsDomainDomainContainment(
    const WCHAR* wszName,
    CWbemServices *pNamespace)
    :CDnsBase(wszName, pNamespace)
{
}


CDnsDomainDomainContainment::~CDnsDomainDomainContainment()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//
//    Description:
//        enum instances of domain and domain association
//
//    Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomainDomainContainment::EnumInstance( 
    long                lFlags,
    IWbemContext *        pCtx,
    IWbemObjectSink *    pHandler)
{
    // get top level zones
    list<CDomainNode> objList;
    CDnsWrap& dns = CDnsWrap::DnsObject();
    SCODE sc = dns.dnsEnumDomainForServer(&objList);
    list<CDomainNode>::iterator i;
    CWbemInstanceMgr InstMgr(
        pHandler);
    // enumerate all domaindomain for all zones
    for(i=objList.begin(); i!=objList.end(); ++i)
    {
        sc = dns.dnsEnumRecordsForDomainEx(
            *i,
            NULL,
            InstanceFilter,
            TRUE,
            DNS_TYPE_ALL,
            DNS_RPC_VIEW_ALL_DATA,
            m_pClass, 
            InstMgr);
    }

    return sc;

}


SCODE 
CDnsDomainDomainContainment::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler
    )
{
    return WBEM_S_NO_ERROR;
}


SCODE CDnsDomainDomainContainment::ExecuteMethod(    
    CObjPath &          objPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler
    ) 
{
    return WBEM_S_NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        call back function to enum domain instance. 
//      if pNode represents a domain node, create a wmi domain instance
//
//    Arguments:
//      CDomainNode         [IN]    Parent domain
//      pFilter             [IN]    pointer to object that contains the criteria to filter
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomainDomainContainment::InstanceFilter(
    CDomainNode &       ParentDomain,
    PVOID               pFilter,
    CDnsRpcNode *       pNode,
    IWbemClassObject *  pClass,
    CWbemInstanceMgr &  InstMgr
    )
{
    CWbemClassObject NewInst;
    if(!pNode->IsDomainNode())
        return WBEM_S_NO_ERROR;
    CDnsWrap& dns = CDnsWrap::DnsObject();
    pClass->SpawnInstance(0, &NewInst);
    
    // setting object path for parent in association
    CObjPath objPathParent;
    objPathParent.SetClass(PVD_CLASS_DOMAIN);
    objPathParent.AddProperty(
        PVD_DOMAIN_SERVER_NAME,
        dns.GetServerName().data() );
    objPathParent.AddProperty(
        PVD_DOMAIN_CONTAINER_NAME, 
        ParentDomain.wstrZoneName.data() );
    objPathParent.AddProperty(
        PVD_DOMAIN_FQDN, 
        ParentDomain.wstrNodeName.data() );
    NewInst.SetProperty(
        objPathParent.GetObjectPathString(),
        PVD_ASSOC_PARENT);

    //setting object path for child in association
    wstring wzFQDN = pNode->GetNodeName();
    wzFQDN += PVD_DNS_LOCAL_SERVER + ParentDomain.wstrNodeName;
     CObjPath opChild = objPathParent;
    opChild.SetProperty(
        PVD_DOMAIN_FQDN,
        wzFQDN.data() );
    NewInst.SetProperty(
        opChild.GetObjectPathString(),
        PVD_ASSOC_CHILD );
    InstMgr.Indicate(NewInst.data());
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\common.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		common.h
//
//	Implementation File:
//		util.cpp
//
//	Description:
//		Definition of the CDnsbase class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include <wbemprov.h>
#include <objbase.h>
#include "ntrkcomm.h"
#include <string>
#include <list>
#include <memory>

using namespace std;


class CDnsBase;
class CDnsRpcNode;
class CObjPath;
class CDomainNode;
class CWbemInstanceMgr;


typedef LPVOID * PPVOID;
typedef SCODE (*FILTER) (
	CDomainNode&, 
	//CObjPath*, 
	PVOID,
	CDnsRpcNode*, 
	IWbemClassObject* ,
	CWbemInstanceMgr& 
	);
typedef CDnsBase* (*FPNEW) (
    const WCHAR*,
    CWbemServices*,
    const char*
    );
SCODE CreateClass(
	const WCHAR* , 
	CWbemServices* p, 
	void** );

//string convertion
BSTR 
AllocBstr(const WCHAR* );

int 
CharToWchar(
	LPCSTR, 
	LPWSTR* 
	);
wstring 
CharToWstring(
	LPCSTR , 
	DWORD 
	);
wstring IpAddressToString(DWORD ip);
int 
WcharToChar(
	LPCWSTR , 
	LPSTR* 
	);
int 
WcharToString(
	LPCWSTR,
	string& 
	);

//WBEM_CLASSS
extern const WCHAR* const PVD_CLASS_SERVER;

extern const WCHAR* const PVD_CLASS_DOMAIN;
extern const WCHAR* const PVD_CLASS_ZONE;
extern const WCHAR* const PVD_CLASS_CACHE;
extern const WCHAR* const PVD_CLASS_ROOTHINTS;
extern const WCHAR* const PVD_CLASS_RESOURCERECORD;
extern const WCHAR* const PVD_CLASS_RR_A;
extern const WCHAR* const PVD_CLASS_RR_SOA; 
extern const WCHAR* const PVD_CLASS_RR_PTR;
extern const WCHAR* const PVD_CLASS_RR_NS ;
extern const WCHAR* const PVD_CLASS_RR_CNAME; 
extern const WCHAR* const PVD_CLASS_RR_MB;
extern const WCHAR* const PVD_CLASS_RR_MD;
extern const WCHAR* const PVD_CLASS_RR_MF;
extern const WCHAR* const PVD_CLASS_RR_MG;
extern const WCHAR* const PVD_CLASS_RR_MR;
extern const WCHAR* const PVD_CLASS_RR_MINFO;
extern const WCHAR* const PVD_CLASS_RR_RP;
extern const WCHAR* const PVD_CLASS_RR_MX;
extern const WCHAR* const PVD_CLASS_RR_AFSDB;
extern const WCHAR* const PVD_CLASS_RR_RT;
extern const WCHAR* const PVD_CLASS_RR_HINFO;
extern const WCHAR* const PVD_CLASS_RR_ISDN;
extern const WCHAR* const PVD_CLASS_RR_TXT;
extern const WCHAR* const PVD_CLASS_RR_X25;
extern const WCHAR* const PVD_CLASS_RR_NULL;
extern const WCHAR* const PVD_CLASS_RR_WKS;
extern const WCHAR* const PVD_CLASS_RR_AAAA;
extern const WCHAR* const PVD_CLASS_RR_SRV;
extern const WCHAR* const PVD_CLASS_RR_ATMA;
extern const WCHAR* const PVD_CLASS_RR_WINS;
extern const WCHAR* const PVD_CLASS_RR_WINSR;

extern const WCHAR* const PVD_CLASS_SERVERDOMAIN;
extern const WCHAR* const PVD_CLASS_DOMAINDOMAIN;
extern const WCHAR* const PVD_CLASS_DOMAINRESOURCERECORD;
// server
extern const WCHAR* const PVD_SRV_ADDRESS_ANSWER_LIMIT;
extern const WCHAR* const PVD_SRV_BOOT_METHOD;
extern const WCHAR* const PVD_SRV_DS_POLLING_INTERVAL;
extern const WCHAR* const PVD_SRV_EVENT_LOG_LEVEL;
extern const WCHAR* const PVD_SRV_ALLOW_UPDATE;
extern const WCHAR* const PVD_SRV_AUTO_CACHE_UPDATE;
extern const WCHAR* const PVD_SRV_AUTO_REVERSE_ZONES;
extern const WCHAR* const PVD_SRV_BIND_SECONDARIES;
extern const WCHAR* const PVD_SRV_DISJOINT_NETS;
extern const WCHAR* const PVD_SRV_DS_AVAILABLE;
extern const WCHAR* const PVD_SRV_FORWARD_DELEGATION;
extern const WCHAR* const PVD_SRV_LOCAL_NETPRIORITY;
extern const WCHAR* const PVD_SRV_LOOSE_WILDCARDING;
extern const WCHAR* const PVD_SRV_NO_RECURSION;
extern const WCHAR* const PVD_SRV_FORWARDERS_IPADDRESSES_ARRAY;
extern const WCHAR* const PVD_SRV_FORWARD_TIMEOUT;
extern const WCHAR* const PVD_SRV_ROUND_ROBIN;
extern const WCHAR* const PVD_SRV_SECURE_RESPONSES;
extern const WCHAR* const PVD_SRV_SLAVE;
extern const WCHAR* const PVD_SRV_STRICT_FILE_PARSING;
extern const WCHAR* const PVD_SRV_AUTO_CONFIG_FILE_ZONES;
extern const WCHAR* const PVD_SRV_DEFAULT_AGING_STATE;
extern const WCHAR* const PVD_SRV_DEFAULT_REFRESH_INTERVAL;
extern const WCHAR* const PVD_SRV_DEFAULT_NOREFRESH_INTERVAL;
extern const WCHAR* const PVD_SRV_ENABLE_EDNS;
extern const WCHAR* const PVD_SRV_EDNS_CACHE_TIMEOUT;
extern const WCHAR* const PVD_SRV_MAX_UDP_PACKET_SIZE;
extern const WCHAR* const PVD_SRV_ENABLE_DNSSEC;
extern const WCHAR* const PVD_SRV_ENABLE_DP;
extern const WCHAR* const PVD_SRV_WRITE_AUTHORITY_NS;
extern const WCHAR* const PVD_SRV_LISTEN_IP_ADDRESSES_ARRAY;
extern const WCHAR* const PVD_SRV_LOG_LEVEL;
extern const WCHAR* const PVD_SRV_MAX_CACHE_TTL;
extern const WCHAR* const PVD_SRV_NAME_CHECK_FLAG; 
extern const WCHAR* const PVD_SRV_RECURSION_RETRY;
extern const WCHAR* const PVD_SRV_RECURSION_TIMEOUT; 
extern const WCHAR* const PVD_SRV_RPC_PROTOCOL;
extern const WCHAR* const PVD_SRV_SEND_ON_NON_DNS_PORT;
extern const WCHAR* const PVD_SRV_SERVER_IP_ADDRESSES_ARRAY;
extern const WCHAR* const PVD_SRV_SERVER_NAME;
extern const WCHAR* const PVD_SRV_VERSION;
extern const WCHAR* const PVD_SRV_STARTED;
extern const WCHAR* const PVD_SRV_STARTMODE;
// resource record

extern const WCHAR* const PVD_REC_CONTAINER_NAME;
extern const WCHAR* const PVD_REC_SERVER_NAME;
extern const WCHAR* const PVD_REC_DOMAIN_NAME;
extern const WCHAR* const PVD_REC_OWNER_NAME;
extern const WCHAR* const PVD_REC_CLASS;
extern const WCHAR* const PVD_REC_RDATA;
extern const WCHAR* const PVD_REC_TXT_REP; 
extern const WCHAR* const PVD_REC_TTL;
extern const WCHAR* const PVD_REC_TYPE;

extern const WCHAR* const PVD_REC_AAAA_IP;
extern const WCHAR* const PVD_REC_AFSBD_SERVER_NAME;
extern const WCHAR* const PVD_REC_AFSBD_SUB_TYPE;
extern const WCHAR* const PVD_REC_ATMA_FORMAT;
extern const WCHAR* const PVD_REC_ATMA_ATM_ADDRESS;
extern const WCHAR* const PVD_REC_A_IP;
extern const WCHAR* const PVD_REC_CNAME_PRIMARY_NAME;
extern const WCHAR* const PVD_REC_HINFO_CPU;
extern const WCHAR* const PVD_REC_HINFO_OS;
extern const WCHAR* const PVD_REC_ISDN_ISDN_NUM;
extern const WCHAR* const PVD_REC_ISDN_SUB_ADDRESS;
extern const WCHAR* const PVD_REC_MB_MBHOST;
extern const WCHAR* const PVD_REC_MD_MDHOST;
extern const WCHAR* const PVD_REC_MF_MFHOST;
extern const WCHAR* const PVD_REC_MG_MGMAILBOX;
extern const WCHAR* const PVD_REC_MINFO_ERROR_MAILBOX;
extern const WCHAR* const PVD_REC_MINFO_RESP_MAILBOX;
extern const WCHAR* const PVD_REC_MR_MRMAILBOX;
extern const WCHAR* const PVD_REC_MX_MAIL_EXCHANGE;
extern const WCHAR* const PVD_REC_MX_PREFERENCE;
extern const WCHAR* const PVD_REC_NS_NSHOST;
extern const WCHAR* const PVD_REC_NULL_NULLDATA;
extern const WCHAR* const PVD_REC_PTR_PTRDOMAIN_NAME;
extern const WCHAR* const PVD_REC_RP_RPMAILBOX;
extern const WCHAR* const PVD_REC_RP_TXT_DOMAIN_NAME;
extern const WCHAR* const PVD_REC_RT_HOST;
extern const WCHAR* const PVD_REC_RT_PREFERENCE;
extern const WCHAR* const PVD_REC_SOA_EXPIRE_LIMIT;
extern const WCHAR* const PVD_REC_SOA_TTL;
extern const WCHAR* const PVD_REC_SOA_PRIMARY_SERVER;
extern const WCHAR* const PVD_REC_SOA_REFRESH;
extern const WCHAR* const PVD_REC_SOA_RESPONSIBLE;
extern const WCHAR* const PVD_REC_SOA_RETRY_DELAY;
extern const WCHAR* const PVD_REC_SOA_SERIAL_NUMBER; 
extern const WCHAR* const PVD_REC_SRV_PORT;
extern const WCHAR* const PVD_REC_SRV_PRIORITY;
extern const WCHAR* const PVD_REC_SRV_WEIGHT;
extern const WCHAR* const PVD_REC_SRV_DOMAINNAME;
extern const WCHAR* const PVD_REC_TXT_TEXT;
extern const WCHAR* const PVD_REC_WINSR_TIMEOUT;
extern const WCHAR* const PVD_REC_WINSR_MAPPING_FLAG;
extern const WCHAR* const PVD_REC_WINSR_RESULT_DOMAIN;
extern const WCHAR* const PVD_REC_WINSR_CACHE_TIMEOUT;

extern const WCHAR* const PVD_REC_WINS_TIMEOUT;
extern const WCHAR* const PVD_REC_WINS_MAPPING_FLAG;
extern const WCHAR* const PVD_REC_WINS_WINS_SERVER;
extern const WCHAR* const PVD_REC_WINS_CACHE_TIMEOUT;
extern const WCHAR* const PVD_REC_WKS_INTERNET_ADDRESS;
extern const WCHAR* const PVD_REC_WKS_IP_PROTOCOL;
extern const WCHAR* const PVD_REC_WKS_BIT_MASK;
extern const WCHAR* const PVD_REC_X25_PSDNADDRESS;

// domain 


extern const WCHAR* const PVD_DOMAIN_CONTAINER_NAME;
extern const WCHAR* const PVD_DOMAIN_FQDN;
extern const WCHAR* const PVD_DOMAIN_SERVER_NAME;


//
//  Zone properties
//

extern const WCHAR* const PVD_ZONE_ALLOW_UPDATE;
extern const WCHAR* const PVD_ZONE_AUTO_CREATED;
extern const WCHAR* const PVD_ZONE_DISABLE_WIN_SRECORD_REPLICATION;
extern const WCHAR* const PVD_ZONE_NOTIFY;
extern const WCHAR* const PVD_ZONE_PAUSED;
extern const WCHAR* const PVD_ZONE_REVERSE;
extern const WCHAR* const PVD_ZONE_AGING;
extern const WCHAR* const PVD_ZONE_SECURE_SECONDARIES;
extern const WCHAR* const PVD_ZONE_SHUTDOWN;
extern const WCHAR* const PVD_ZONE_USE_WINS;
extern const WCHAR* const PVD_ZONE_MASTERS_IP_ADDRESSES_ARRAY;
extern const WCHAR* const PVD_ZONE_LOCAL_MASTERS_IP_ADDRESSES_ARRAY;
extern const WCHAR* const PVD_ZONE_DATA_FILE;
extern const WCHAR* const PVD_ZONE_SECONDARIES_IP_ADDRESSES_ARRAY;
extern const WCHAR* const PVD_ZONE_NOTIFY_IPADDRESSES_ARRAY;
extern const WCHAR* const PVD_ZONE_ZONE_TYPE;
extern const WCHAR* const PVD_ZONE_DS_INTEGRATED;
extern const WCHAR* const PVD_ZONE_AVAIL_FOR_SCAVENGE_TIME;
extern const WCHAR* const PVD_ZONE_REFRESH_INTERVAL;
extern const WCHAR* const PVD_ZONE_NOREFRESH_INTERVAL;
extern const WCHAR* const PVD_ZONE_SCAVENGE_SERVERS;
extern const WCHAR* const PVD_ZONE_FORWARDER_SLAVE;
extern const WCHAR* const PVD_ZONE_FORWARDER_TIMEOUT;
extern const WCHAR* const PVD_ZONE_LAST_SOA_CHECK;
extern const WCHAR* const PVD_ZONE_LAST_GOOD_XFR;


//domaindomain
//domain resource record containment
// server domain  containment
extern const WCHAR* const PVD_ASSOC_CHILD;
extern const WCHAR* const PVD_ASSOC_PARENT;
// method
extern const WCHAR* const PVD_MTH_SRV_RESTART;
extern const WCHAR* const PVD_MTH_SRV_START_SERVICE;
extern const WCHAR* const PVD_MTH_SRV_STOP_SERVICE;
extern const WCHAR* const PVD_MTH_ZONE_RESUMEZONE;
extern const WCHAR* const PVD_MTH_ZONE_PAUSEZONE;
extern const WCHAR* const PVD_MTH_ZONE_RELOADZONE;
extern const WCHAR* const PVD_MTH_ZONE_FORCEREFRESH;
extern const WCHAR* const PVD_MTH_ZONE_UPDATEFROMDS;
extern const WCHAR* const PVD_MTH_ZONE_WRITEBACKZONE;
extern const WCHAR* const PVD_MTH_ZONE_AGEALLRECORDS;
extern const WCHAR* const PVD_MTH_ZONE_CHANGEZONETYPE;
extern const WCHAR* const PVD_MTH_ZONE_CREATEZONE;
extern const WCHAR* const PVD_MTH_ZONE_RESETNOTIFYIPARRAY;
extern const WCHAR* const PVD_MTH_ZONE_RESETSECONDARYIPARRAY;
extern const WCHAR* const PVD_MTH_ZONE_GETDISTINGUISHEDNAME;
extern const WCHAR* const PVD_MTH_ZONE_ARG_ZONENAME;
extern const WCHAR* const PVD_MTH_ZONE_ARG_ZONETYPE;
extern const WCHAR* const PVD_MTH_ZONE_ARG_DATAFILENAME;
extern const WCHAR* const PVD_MTH_ZONE_ARG_IPADDRARRAY;
extern const WCHAR* const PVD_MTH_ZONE_ARG_ADMINEMAILNAME;
extern const WCHAR* const PVD_MTH_ZONE_ARG_NODENAME;
extern const WCHAR* const PVD_MTH_ZONE_ARG_APPLYTOSUBTREE;
extern const WCHAR* const PVD_MTH_ZONE_ARG_DSINTEGRATED;
extern const WCHAR* const PVD_MTH_ZONE_ARG_SECURITY;
extern const WCHAR* const PVD_MTH_ZONE_ARG_NOTIFY;
extern const WCHAR* const PVD_MTH_ZONE_ARG_MASTERIPARRAY;
extern const WCHAR* const PVD_MTH_ZONE_ARG_MASTERSLOCAL;
extern const WCHAR* const PVD_MTH_ZONE_ARG_SECONDARYIPARRAY;
extern const WCHAR* const PVD_MTH_ZONE_ARG_NOTIFYIPARRAY;

extern const WCHAR* const PVD_MTH_REC_CREATEINSTANCEFROMTEXTREPRESENTATION;
extern const WCHAR* const PVD_MTH_REC_MODIFY;
extern const WCHAR* const PVD_MTH_REC_CREATEINSTANCEFROMPROPERTYDATA;
extern const WCHAR* const PVD_MTH_REC_GETOBJECTBYTEXT;
extern const WCHAR* const PVD_MTH_REC_ARG_DNSSERVER_NAME;
extern const WCHAR* const PVD_MTH_REC_ARG_CONTAINER_NAME;
extern const WCHAR* const PVD_MTH_REC_ARG_TEXTREP;
extern const WCHAR* const PVD_MTH_REC_ARG_RR;
extern const WCHAR* const PVD_MTH_RH_WRITEBACKROOTHINTDATAFILE;
extern const WCHAR* const PVD_MTH_CACHE_CLEARDNSSERVERCACHE;
//general
extern const WCHAR* const PVD_DNS_CACHE;
extern const WCHAR* const PVD_DNS_ROOTHINTS;
extern const WCHAR* const PVD_DNS_LOCAL_SERVER;
extern const WCHAR* const PVD_DNS_RETURN_VALUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsdomainresourcerecordcontainment.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		DnsDomainResourceRecordContainment.h
//
//	Implementation File:
//		DnsDomainResourceRecordContainment.cpp
//
//	Description:
//		Definition of the CDnsDomainResourceRecordContainment class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"
class CObjPath;


class CDnsDomainResourceRecordContainment  : CDnsBase
{
public:
	CDnsDomainResourceRecordContainment();
	CDnsDomainResourceRecordContainment(
		const WCHAR*, 
		CWbemServices*
		);
	~CDnsDomainResourceRecordContainment();
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;
	static SCODE InstanceFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
		);
    static CDnsBase* CreateThis(
        const WCHAR *       wszName,        
        CWbemServices *     pNamespace,  
        const char *        szType       
        );




};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsdomainresourcerecordcontainment.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: DnsDomainResourceRecordContainment.cpp
//
//  Description:    
//      Implementation of CDnsDomainResourceRecordContainment class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsDomainResourceRecordContainment::CreateThis(
    const WCHAR *       wszName,         //class name
    CWbemServices *     pNamespace,  //namespace
    const char *        szType         //str type id
    )
{
    return new CDnsDomainResourceRecordContainment(wszName, pNamespace);
}
CDnsDomainResourceRecordContainment::CDnsDomainResourceRecordContainment()
{

}
CDnsDomainResourceRecordContainment::CDnsDomainResourceRecordContainment(
	const WCHAR* wszName, 
	CWbemServices *pNamespace)
	:CDnsBase(wszName, pNamespace)
{

}

CDnsDomainResourceRecordContainment::~CDnsDomainResourceRecordContainment()
{

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//
//	Description:
//		enum instances of domain and record association
//
//	Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomainResourceRecordContainment::EnumInstance( 
    long				lFlags,
    IWbemContext *		pCtx,
    IWbemObjectSink *	pHandler)
{
	list<CDomainNode> objList;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	SCODE sc = dns.dnsEnumDomainForServer(&objList);
	list<CDomainNode>::iterator i;
	CWbemInstanceMgr InstMgr(
		pHandler);
	for(i=objList.begin(); i!=objList.end(); ++i)
	{
		sc = dns.dnsEnumRecordsForDomainEx(
			*i,
			NULL,
			InstanceFilter,
			TRUE,
			DNS_TYPE_ALL,
			DNS_RPC_VIEW_ALL_DATA,
			m_pClass,
			InstMgr);
	}
	return sc;
}

SCODE 
CDnsDomainResourceRecordContainment::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler
    )
{
		return WBEM_E_NOT_SUPPORTED;
}

SCODE CDnsDomainResourceRecordContainment::ExecuteMethod(
    CObjPath &          objPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler
    )
{
		return WBEM_E_NOT_SUPPORTED;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		call back function to enum domain and record association instance. 
//      if pNode represents a domain node, create a wmi domain instance
//
//	Arguments:
//      ParentDomain        [IN]    Parent domain
//      pFilter             [IN]    pointer to object that contains the criteria to filter
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsDomainResourceRecordContainment::InstanceFilter(
    CDomainNode &       ParentDomain,
    PVOID               pFilter,
    CDnsRpcNode *       pNode,
    IWbemClassObject *  pClass,
    CWbemInstanceMgr &  InstMgr
    )
{
	if (pNode->IsDomainNode())
		return 0;
	
//	CObjPath* pFilterObj = (CObjPath*) pFilter;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	CObjPath objPathParent;
	objPathParent.SetClass(PVD_CLASS_DOMAIN);
	objPathParent.AddProperty(
		PVD_DOMAIN_SERVER_NAME, 
		dns.GetServerName().data()
		);
	objPathParent.AddProperty(
		PVD_DOMAIN_CONTAINER_NAME, 
		ParentDomain.wstrZoneName.data()
		);
	objPathParent.AddProperty(
		PVD_DOMAIN_FQDN, 
		ParentDomain.wstrNodeName.data()
		);

	wstring wstrOwner = pNode->GetNodeName();
	if(!wstrOwner.empty())
		wstrOwner += PVD_DNS_LOCAL_SERVER + ParentDomain.wstrNodeName;
	else
		wstrOwner = ParentDomain.wstrNodeName;

	CDnsRpcRecord* p;
	while(  (p = pNode->GetNextRecord()) != NULL )
	{
		auto_ptr<CDnsRpcRecord> pRec(p);

		CObjPath objPathChild;

		// populate rdata section
		pRec->GetObjectPath(
			dns.GetServerName(),
			ParentDomain.wstrZoneName,
			ParentDomain.wstrNodeName,
			wstrOwner,
			objPathChild);
		
		CWbemClassObject NewInst;
		pClass->SpawnInstance(0, &NewInst);
		// set domain ref
		NewInst.SetProperty(
			objPathParent.GetObjectPathString(), 
			PVD_ASSOC_PARENT
			);
		// set record ref
		NewInst.SetProperty(
			objPathChild.GetObjectPathString(), 
			PVD_ASSOC_CHILD
			);
		InstMgr.Indicate(NewInst.data());
	}

	
	return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsresourcerecord.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: Dnsresourcerecord.cpp
//
//  Description:    
//      Implementation of CDnsResourceRecord class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CDnsResourceRecord::CDnsResourceRecord()
{

}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        create an instance of CDnsResourceRecord
//
//    Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
CDnsBase* 
CDnsResourceRecord::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsResourceRecord(wszName, pNamespace, szType);
}


CDnsResourceRecord::CDnsResourceRecord(
    const WCHAR* wszName,
    CWbemServices *pNamespace,
    const char* szType)
    :CDnsBase(wszName, pNamespace)
{
        
    m_wType = Dns_RecordTypeForName(
        (char*)szType,
        0       // null terminated
        );
    if(m_wType == 0)
        m_wType = DNS_TYPE_ALL;
    m_wstrClassName = wszName;

}


CDnsResourceRecord::~CDnsResourceRecord()
{
}


CDnsResourceRecord::CDnsResourceRecord(
    WCHAR* wsClass, 
    char* szType)
{
    
    m_wType = Dns_RecordTypeForName(
        szType,
        0       // null terminated
        );
    if(m_wType == 0)
        m_wType = DNS_TYPE_ALL;
    m_wstrClassName = wsClass;

}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enum instances of dns record
//
//    Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsResourceRecord::EnumInstance( 
    long                lFlags,
    IWbemContext *        pCtx,
    IWbemObjectSink *    pHandler)
{
    IWbemClassObject* pNewInst;
    list<CDomainNode> objList;
    CDnsWrap& dns = CDnsWrap::DnsObject();
    SCODE sc = dns.dnsEnumDomainForServer(&objList);
    list<CDomainNode>::iterator i;
    CWbemInstanceMgr InstanceMgr(
        pHandler);
    for(i=objList.begin(); i!=objList.end(); ++i)
    {
        
        sc = dns.dnsEnumRecordsForDomainEx(
            *i,
            NULL,
            &InstanceFilter, 
            TRUE,
            m_wType,
            DNS_RPC_VIEW_ALL_DATA,
            m_pClass,
            InstanceMgr);
    }
    
    return sc;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        retrieve record object pointed by the given object path
//
//    Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsResourceRecord::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler)
{

    CDomainNode objNode;
    objNode.wstrZoneName = ObjectPath.GetStringValueForProperty(
        PVD_REC_CONTAINER_NAME );
    wstring wstrNodeName = ObjectPath.GetStringValueForProperty(
        PVD_REC_DOMAIN_NAME );
    if(_wcsicmp(wstrNodeName.data(), PVD_DNS_CACHE) == 0 ||
        _wcsicmp(wstrNodeName.data(), PVD_DNS_ROOTHINTS) ==0)
    {
        wstrNodeName = L"";
        ObjectPath.SetProperty(PVD_REC_OWNER_NAME,L"");
    }
    objNode.wstrNodeName = wstrNodeName;

    CDnsWrap& dns = CDnsWrap::DnsObject();
    CWbemInstanceMgr InstMgr(
        pHandler);
    SCODE sc =     dns.dnsEnumRecordsForDomainEx(
        objNode,
        &ObjectPath,
        &GetObjectFilter, 
        FALSE,
        m_wType,
        DNS_RPC_VIEW_ALL_DATA,
        m_pClass,
        InstMgr);

    return sc;

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        execute methods defined for record class in the mof 
//
//    Arguments:
//      ObjPath             [IN]    pointing to the object that the 
//                                  method should be performed on
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsResourceRecord::ExecuteMethod(    
    CObjPath &          ObjPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
    CDnsWrap& dns = CDnsWrap::DnsObject();
    SCODE sc;

    CComPtr<IWbemClassObject> pOutParams;
    CComPtr<IWbemClassObject> pOutClass;
    sc = m_pClass->GetMethod(wzMethodName, 0, NULL, &pOutClass);
    if(sc != S_OK)
    {
        return sc;
    }
    
    pOutClass->SpawnInstance(0, &pOutParams);
    
    if(_wcsicmp(
        wzMethodName,
        PVD_MTH_REC_GETOBJECTBYTEXT) == 0)
    {
        return GetObjectFromText(
            pInArgs,
            pOutParams,
            pHandler);
    }
    else if(_wcsicmp(
        wzMethodName,
        PVD_MTH_REC_CREATEINSTANCEFROMTEXTREPRESENTATION) == 0)
    {
        return CreateInstanceFromText(
            pInArgs,
            pOutParams,
            pHandler);
    }
    else if (_wcsicmp(
        wzMethodName,
        PVD_MTH_REC_CREATEINSTANCEFROMPROPERTYDATA) == 0)
    {
        return CreateInstanceFromProperty(
            pInArgs,
            pOutParams,
            pHandler);

    }
    else if (_wcsicmp(
        wzMethodName,
        PVD_MTH_REC_MODIFY) == 0)
    {
        return Modify(ObjPath,
            pInArgs,
            pOutParams,
            pHandler);
    }
    else
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        call back function to enum record instance. 
//
//    Arguments:
//      ParentDomain        [IN]    Parent domain
//      pFilter             [IN]    pointer to object that contains the criteria to filter
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsResourceRecord::InstanceFilter(
    CDomainNode &       ParentDomain,
    PVOID               pFilter,
    CDnsRpcNode *       pNode,
    IWbemClassObject *  pClass,
    CWbemInstanceMgr &  InstMgr )
{
    if(!pNode || !pClass )
        return WBEM_E_FAILED;
    if (pNode->IsDomainNode())
        return 0;
    CDnsRpcRecord* pRec=NULL;
    CDnsWrap& dns = CDnsWrap::DnsObject();
    wstring wzContainer = ParentDomain.wstrZoneName;
    wstring wstrFQDN;
    if( ParentDomain.wstrNodeName.empty())
    {
        wstrFQDN = ParentDomain.wstrZoneName;
    }
    else
    {
        wstrFQDN = ParentDomain.wstrNodeName;
    }
    wstring wstrNodeName = pNode->GetNodeName();
    if (!wstrNodeName.empty())
    {
        wstrNodeName += PVD_DNS_LOCAL_SERVER + wstrFQDN;
    }
    else
    {
        wstrNodeName = wstrFQDN;
    }

    while( (pRec = pNode->GetNextRecord()) != NULL)
    {
        auto_ptr<CDnsRpcRecord> apRec(pRec);
        CWbemClassObject NewInst;
        pClass->SpawnInstance(0, &NewInst);
        NewInst.SetProperty(
            dns.GetServerName(), 
            PVD_REC_SERVER_NAME);
        NewInst.SetProperty(
            wzContainer, 
            PVD_REC_CONTAINER_NAME);
        NewInst.SetProperty(
            wstrFQDN,
            PVD_REC_DOMAIN_NAME);
        NewInst.SetProperty(
            wstrNodeName, 
            PVD_REC_OWNER_NAME);
        NewInst.SetProperty(
            pRec->GetTextRepresentation(wstrNodeName),
            PVD_REC_TXT_REP);
        apRec->ConvertToWbemObject(NewInst);
        InstMgr.Indicate(NewInst.data());
    }

    
    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        call back function in response to ExceQuery call. Return instances
//      that satisfy query language
//
//    Arguments:
//      ParentDomain        [IN]    Parent domain
//      pFilter             [IN]    pointer to CSqlEval object that implements 
//                                  logic based on sql language to filter 
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsResourceRecord::QueryFilter(
    CDomainNode &       ParentDomain,
    PVOID               pFilter,
    CDnsRpcNode *       pNode,
    IWbemClassObject *  pClass,
    CWbemInstanceMgr &  InstMgr )
{
    DBG_FN( "CDnsResourceRecord::QueryFilter" );
    
    if(!pNode || !pClass || !pFilter)
    {
        return WBEM_E_FAILED;
    }
    if (pNode->IsDomainNode())
    {
        return 0;
    }

    CSqlEval* pFilterObj = (CSqlEval*) pFilter;
    CDnsRpcRecord* pRec=NULL;
    CDnsWrap& dns = CDnsWrap::DnsObject();
    wstring wzContainer = ParentDomain.wstrZoneName;
    wstring wstrFQDN;
    if( ParentDomain.wstrNodeName.empty())
    {
        wstrFQDN = ParentDomain.wstrZoneName;
    }
    else
    {
        wstrFQDN = ParentDomain.wstrNodeName;
    }
    wstring wstrNodeName = pNode->GetNodeName();
    if (!wstrNodeName.empty())
    {
        wstrNodeName += PVD_DNS_LOCAL_SERVER + wstrFQDN;
    }
    else
    {
        wstrNodeName = wstrFQDN;
    }

    while( (pRec = pNode->GetNextRecord()) != NULL)
    {
        auto_ptr<CDnsRpcRecord> apRec(pRec);
        CWbemClassObject NewInst;
        pClass->SpawnInstance(0, &NewInst);
        NewInst.SetProperty(
            dns.GetServerName(), 
            PVD_REC_SERVER_NAME);
        NewInst.SetProperty(
            wzContainer, 
            PVD_REC_CONTAINER_NAME);
        NewInst.SetProperty(
            wstrFQDN,
            PVD_REC_DOMAIN_NAME);
        NewInst.SetProperty(
            wstrNodeName, 
            PVD_REC_OWNER_NAME);
        NewInst.SetProperty(
            pRec->GetTextRepresentation(wstrNodeName),
            PVD_REC_TXT_REP);
        pRec->ConvertToWbemObject(NewInst);
        
        CSqlWmiEvalee sqlEvalee( NewInst.data() );
        if( pFilterObj->Evaluate( &sqlEvalee ) )
        {
            DNS_DEBUG( RPCRR, (
                "%s: indicating node %S %S\n", fn,
                wstrNodeName.c_str(),
                pRec->GetTextRepresentation(wstrNodeName).c_str() ));
            InstMgr.Indicate( NewInst.data() );
        }
        else
        {
            DNS_DEBUG( RPCRR, (
                "%s: not indicating node %S %S\n", fn,
                wstrNodeName.c_str(),
                pRec->GetTextRepresentation(wstrNodeName).c_str() ));
        }
    }

    
    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        call back function to enum record instance. 
//
//    Arguments:
//      ParentDomain        [IN]    Parent domain
//      pFilter             [IN]    pointer to an CObjPath object that 
//                                  contains the criteria to filter
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsResourceRecord::GetObjectFilter(
    CDomainNode &       ParentDomain,
    PVOID               pFilter,
    CDnsRpcNode *       pNode,
    IWbemClassObject *  pClass,
    CWbemInstanceMgr &  InstMgr )
{

    if(!pNode || !pClass || !pFilter)
        return WBEM_E_FAILED;
    
    if (pNode->IsDomainNode())
        return 0;
    
    CObjPath* pFilterObj = (CObjPath*) pFilter;
    CDnsRpcRecord* pRec=NULL;
    
    wstring wstrResultOwner = pNode->GetNodeName();
    if(wstrResultOwner.empty())
        wstrResultOwner = ParentDomain.wstrNodeName;
    else
        wstrResultOwner += PVD_DNS_LOCAL_SERVER + ParentDomain.wstrNodeName;
    while( (pRec = pNode->GetNextRecord()) != NULL)
    {
        auto_ptr<CDnsRpcRecord> apRec(pRec);    
        wstring wstrSourceOwner = 
            pFilterObj->GetStringValueForProperty(
            PVD_REC_OWNER_NAME);
        if(_wcsicmp(wstrResultOwner.data(), wstrSourceOwner.data())==0)
        {
            wstring wstrData = pRec->GetData();
            if(_wcsicmp(wstrData.data(),
                pFilterObj->GetStringValueForProperty(
                PVD_REC_RDATA).data()) == 0)
            {
                // now find match
                CWbemClassObject NewInst;
                pClass->SpawnInstance(0, &NewInst);
                NewInst.SetProperty(
                    CDnsWrap::DnsObject().GetServerName(),
                    PVD_REC_SERVER_NAME);
                NewInst.SetProperty(
                    ParentDomain.wstrZoneName,
                    PVD_REC_CONTAINER_NAME);
                NewInst.SetProperty(
                    ParentDomain.wstrNodeName,
                    PVD_REC_DOMAIN_NAME);
                NewInst.SetProperty(
                    wstrResultOwner, 
                    PVD_REC_OWNER_NAME);
                NewInst.SetProperty(
                    pRec->GetTextRepresentation(wstrResultOwner),
                    PVD_REC_TXT_REP);
                apRec->ConvertToWbemObject(NewInst);
                InstMgr.Indicate(NewInst.data());
            }
        }

    }
    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        save this instance
//
//    Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsResourceRecord::PutInstance(
    IWbemClassObject *  pInst ,
    long                lFlags,
    IWbemContext*       pCtx ,
    IWbemObjectSink *   pHandler)
{
    DWORD dwType;
    if(!pInst)
    {
        return WBEM_E_FAILED;
    }
    CDnsRpcRecord* pRecord = NULL;
    SCODE sc = CDnsRpcRecord::CreateClass(
        m_wType, 
        (PVOID*) &pRecord);
    if (sc != S_OK)
    {
        return sc;
    }
    auto_ptr<CDnsRpcRecord> apRecord(pRecord);
    CWbemClassObject Inst(pInst);
    string strOwner;
    Inst.GetProperty(
        strOwner, 
        PVD_REC_OWNER_NAME);
    string strRdata;
    Inst.GetProperty(
        strRdata,
        PVD_REC_RDATA);
    string strZone ;
    Inst.GetProperty(
        strZone,
        PVD_REC_CONTAINER_NAME);

    sc = apRecord->Init(
        strOwner,
        strRdata ); 
    if( FAILED ( sc ) )
    {
        return sc;
    }
    sc = apRecord->SendToServer(
        strZone.data(),
        CDnsRpcRecord::AddRecord);

    return WBEM_S_NO_ERROR;
}; 


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        delete the object specified in ObjectPath
//
//    Arguments:
//      ObjectPath          [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsResourceRecord::DeleteInstance( 
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pHandler) 
{
    CDnsRpcRecord* pRecord = NULL;

    // get Rdata
    wstring wstrRdata = ObjectPath.GetStringValueForProperty(
        PVD_REC_RDATA);
    string strRdata;
    WcharToString(wstrRdata.data(), strRdata);

    // get owner
    wstring wstrOwner = ObjectPath.GetStringValueForProperty(
        PVD_REC_OWNER_NAME);    
    string strOwner;
    WcharToString(wstrOwner.data(), strOwner);

    SCODE sc = CDnsRpcRecord::CreateClass(
        m_wType,
        (PVOID*) &pRecord);
    if ( FAILED ( sc ) )
    {
        return sc;
    }
    auto_ptr<CDnsRpcRecord> apRecord(pRecord);    
    string strZone;
    sc = apRecord->Init(
                    strOwner,
                    strRdata ); 
    if( FAILED(sc ) )
    {
        return sc;
    }
    wstring wstrContainer = ObjectPath.GetStringValueForProperty(
        PVD_REC_CONTAINER_NAME);
    string strContainer;
    WcharToString(wstrContainer.data(), strContainer);
    sc = apRecord->SendToServer(
        strContainer.data(),
        CDnsRpcRecord::DeleteRecord);

    return sc;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        modify a record. for the given objpath, it tries to get the record first, 
//      error out if not exist. Create new record based on pInArgs, error out if conflict
//      existing one. if success, delete old record.
//
//    Arguments:
//      objPath             [IN]    point to record to be modified
//      pInArgs             [IN]    new property of a record to be modified to 
//      pOutParams          [IN]    new object path after modify
//      pHandler            [IN]    wmi sink
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsResourceRecord::Modify(
    CObjPath&           objPath,
    IWbemClassObject*   pInArgs,
    IWbemClassObject*   pOutParams,
    IWbemObjectSink*    pHandler)
{
    CDnsWrap& dns = CDnsWrap::DnsObject();
    //Get zonename
    wstring wstrZone = objPath.GetStringValueForProperty(
        PVD_REC_CONTAINER_NAME);
    if(wstrZone.empty())
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    string strZone;
    WcharToString(wstrZone.data(), strZone);

    //Get owner
    wstring wstrOwner = objPath.GetStringValueForProperty(
        PVD_REC_OWNER_NAME);
    if(wstrOwner.empty())
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    string strOwner;
    WcharToString(wstrOwner.data(), strOwner);

    //Get Rdata
    wstring wstrRdata = objPath.GetStringValueForProperty(
        PVD_REC_RDATA);
    if(wstrRdata.empty())
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    string strRdata;
    WcharToString(wstrRdata.data(), strRdata);

    // create class
    CDnsRpcRecord* pRecord;
    SCODE sc = CDnsRpcRecord::CreateClass(
        m_wType, 
        (PVOID*) &pRecord);
    if ( FAILED ( sc ) )
    {
        return sc;
    }
    auto_ptr<CDnsRpcRecord> apRec(pRecord);
    CWbemClassObject InstInArgs(pInArgs);
    sc = apRec->Init(
        m_wstrClassName,
        strOwner, 
        strRdata,
        InstInArgs );
    if ( FAILED ( sc ) )
    {
        return sc;
    }
    apRec->SendToServer(
        strZone.data(),
        CDnsRpcRecord::AddRecord);

    // new record created, delete old one
    if ( apRec->RdataIsChanged()) 
    {
        try
        {
            CDnsRpcRecord* pOldRecord;
            sc = CDnsRpcRecord::CreateClass( m_wType, (PVOID*) &pOldRecord );
            if ( FAILED ( sc ) )
            {
                throw sc;
            }
            auto_ptr<CDnsRpcRecord> apOldRec(pOldRecord);    
            sc = apOldRec->Init(
                strOwner,
                strRdata);
            if ( FAILED ( sc ) )
            {
                throw sc;
            }
            apOldRec->SendToServer(
                strZone.data(),
                CDnsRpcRecord::DeleteRecord);
        }
        catch(SCODE sc_e)
        {    
            // if we fail to delete old record,
            // delete the one we just created
            apRec->SendToServer(
                strZone.data(),
                CDnsRpcRecord::DeleteRecord);
            return sc_e;
        }
    }
    //
    // set output 
    //
    CObjPath newObjPath;
    apRec->GetObjectPath(
        dns.GetServerName(),
        wstrZone,
        L"",
        wstrOwner,
        newObjPath);
    CWbemClassObject instOutParams(pOutParams);
    instOutParams.SetProperty(
        newObjPath.GetObjectPathString(),
        PVD_MTH_REC_ARG_RR);
    return pHandler->Indicate(1, &instOutParams);

}


SCODE 
CDnsResourceRecord::GetDomainNameFromZoneAndOwner(
    string & InZone,
    string & InOwner,
    string & OutNode
    )
{
    if( _stricmp( InOwner.c_str(), "@" ) == 0 )
    {
        OutNode = InZone;
        InOwner = InZone;
    }
    else if( _stricmp( InOwner.c_str(), InZone.c_str() ) == 0 )
    {
        OutNode = InZone;
    }
    else if( _wcsicmp( m_wstrClassName.c_str(), PVD_CLASS_RR_NS ) == 0 ) // NSType exception
    {
        OutNode = InOwner;
    }
    else {
        int posZone = InOwner.find( InZone, 0 );
        int posFirstPeriod = InOwner.find_first_of( '.' );
        string strtempZoneNode = InOwner.substr( posZone, InOwner.length() );
        string strtempPeriodNode = InOwner.substr( posFirstPeriod + 1, InOwner.length() );

        if( _stricmp( strtempZoneNode.c_str(), strtempPeriodNode.c_str() ) == 0 )
        {
            OutNode = strtempZoneNode;
        }
        else {
            OutNode = strtempPeriodNode;
        }
    }

    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        get an instance of record based on record text representation
//
//    Arguments:
//      pInArgs             [IN]    input args contains text rep of record
//      pOutParams          [IN]    output parameter
//      pHandler            [IN]    wmi sink
//
//    Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsResourceRecord::GetObjectFromText(
    IWbemClassObject *  pInArgs,
    IWbemClassObject *  pOutParams,
    IWbemObjectSink *   pHandler
    )
{

    // get zonename
    string strZone;
    CWbemClassObject InstInArgs(pInArgs);
    
    if(InstInArgs.GetProperty(
        strZone, 
        PVD_MTH_REC_ARG_CONTAINER_NAME) != S_OK)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    //get textrepresentation
    string strTextRep;
    if(InstInArgs.GetProperty(
        strTextRep,
        PVD_MTH_REC_ARG_TEXTREP) != S_OK)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    // get OwnerName
    string strOwner;
    int pos = strTextRep.find(' ');
    if(pos != string::npos)
    {
        strOwner = strTextRep.substr(0, pos);
    }

    // get recordType
    pos = strTextRep.find_first_not_of(' ', pos);    // move to record class
    pos = strTextRep.find_first_of(' ', pos);
    if(pos == string::npos)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    pos = strTextRep.find_first_not_of(' ', pos);
    int endpos = strTextRep.find(' ', pos);    // move to record type
    if(endpos == string::npos)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    string strRecordType = strTextRep.substr(pos,endpos-pos);
    // set the record type
    m_wType = Dns_RecordTypeForName(
        (char*)strRecordType.data(),
        0       // null terminated
        );

    // get Rdata

    pos = strTextRep.find_first_not_of(' ', endpos);
    string strRdata = strTextRep.substr(pos);

    string strNode = "";
    GetDomainNameFromZoneAndOwner(strZone, strOwner, strNode);

    //Form filter object
    CObjPath opFilter;
    opFilter.SetClass(PVD_CLASS_RESOURCERECORD);
    opFilter.AddProperty(PVD_REC_CONTAINER_NAME, strZone);
    opFilter.AddProperty(PVD_REC_DOMAIN_NAME, strNode);
    opFilter.AddProperty(PVD_REC_OWNER_NAME, strOwner);
    opFilter.AddProperty(PVD_REC_RDATA, strRdata);

    // get object
    return GetObject(
        opFilter,
        0,
        0,
        pHandler);
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        create an instance of record based on record text representation
//
//    Arguments:
//      pInArgs             [IN]    input args contains text rep of record
//      pOutParams          [IN]    output parameter
//      pHandler            [IN]    wmi sink
//
//    Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsResourceRecord::CreateInstanceFromText(
    IWbemClassObject *  pInArgs,
    IWbemClassObject *  pOutParams,
    IWbemObjectSink *   pHandler)
{
    CDnsWrap& dns = CDnsWrap::DnsObject();
    // get zone name
    string strZone;
    CWbemClassObject InstInArgs(pInArgs);
    if( FAILED ( InstInArgs.GetProperty(
        strZone, 
        PVD_MTH_REC_ARG_CONTAINER_NAME) ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    //get textrepresentation
    string strTextRep;
    if( FAILED ( InstInArgs.GetProperty(
        strTextRep,
        PVD_MTH_REC_ARG_TEXTREP) ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // get OwnerName
    string strOwner;
    int pos = strTextRep.find(' ');
    if(pos != string::npos)
    {
        strOwner = strTextRep.substr(0, pos);
    }

    // get recordType
        // move to record class
    pos = strTextRep.find_first_not_of(' ', pos);    
    pos = strTextRep.find_first_of(' ', pos);
    if(pos == string::npos)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

        // move to record type
    pos = strTextRep.find_first_not_of(' ', pos);
    int endpos = strTextRep.find(' ', pos);    
    if(endpos == string::npos)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    string strRecordType = strTextRep.substr(pos,endpos-pos);
    // get Rdata

    pos = strTextRep.find_first_not_of(' ', endpos);
    string strRdata = strTextRep.substr(pos);

    // set the record type
    m_wType = Dns_RecordTypeForName(
        (char*)strRecordType.data(),
        0       // null terminated
        );

    // create class
    CDnsRpcRecord* pRecord;
    SCODE sc = CDnsRpcRecord::CreateClass(
        m_wType, 
        (PVOID*) &pRecord);
    if ( FAILED ( sc ))
    {
        return sc;
    }
    
    auto_ptr<CDnsRpcRecord> apRecord(pRecord);        
    sc = apRecord->Init(
        strOwner, 
        strRdata
        );
    if ( FAILED ( sc ) )
    {
        return sc;
    }

    apRecord->SendToServer(
        strZone.data(),
        CDnsRpcRecord::AddRecord);

    // set output parameter
    CObjPath newObjPath;
    
    apRecord->GetObjectPath(
        dns.GetServerName(),
        CharToWstring(strZone.data(), strZone.length()),
        L"",
        CharToWstring(strOwner.data(), strOwner.length()),
        newObjPath );
    CWbemClassObject instOutParams( pOutParams );
    instOutParams.SetProperty(
        newObjPath.GetObjectPathString(),
        PVD_MTH_REC_ARG_RR);
    return pHandler->Indicate(1, &instOutParams);
    //done

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        create an instance of record based on input parameter 
//      with proper property setting
//
//    Arguments:
//      pInArgs             [IN]    input args contains property setting
//      pOutParams          [IN]    output parameter
//      pHandler            [IN]    wmi sink
//
//    Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsResourceRecord::CreateInstanceFromProperty(
    IWbemClassObject *  pInArgs,
    IWbemClassObject *  pOutParams,
    IWbemObjectSink *   pHandler
    )
{
    CDnsWrap& dns = CDnsWrap::DnsObject();
    CWbemClassObject InstInArgs(pInArgs);
    string strZone;
    // get zone name
    if( FAILED ( InstInArgs.GetProperty(
        strZone, 
        PVD_REC_CONTAINER_NAME) ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    // get owner name
    string strOwner;
    if( FAILED ( InstInArgs.GetProperty(
        strOwner,
        PVD_REC_OWNER_NAME) ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    string strRdata;

    // create class
    CDnsRpcRecord* pRecord;
    SCODE sc = CDnsRpcRecord::CreateClass(
        m_wType, 
        (PVOID*) &pRecord);
    if ( FAILED( sc ) )
    {
        return sc;
    }
    auto_ptr<CDnsRpcRecord> apRecord(pRecord);    
    sc = apRecord->Init(
        m_wstrClassName,
        strOwner, 
        strRdata,
        InstInArgs
        );
    if ( FAILED ( sc ) )
    {
        return sc;
    }
    apRecord->SendToServer(
        strZone.data(),
        CDnsRpcRecord::AddRecord);
    
    // set output parameter
    CObjPath newObjPath;
    apRecord->GetObjectPath(
        dns.GetServerName(),
        CharToWstring(strZone.data(),strZone.length()),
        L"",
        CharToWstring(strOwner.data(), strOwner.length()),
        newObjPath);

    CWbemClassObject instOutParams(pOutParams);
    instOutParams.SetProperty(
        newObjPath.GetObjectPathString(),
        PVD_MTH_REC_ARG_RR);
    return pHandler->Indicate(1, &instOutParams);
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enum instances of dns domain
//
//    Arguments:
//      pSqlEval            [IN]    pointer to CSqlEval object that implements 
//                                  logic based on sql language to filter 
//                                  which instance should be send to wmi
//                                  not used here
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////


SCODE CDnsResourceRecord::ExecQuery(
    CSqlEval *          pSqlEval,
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pHandler
    ) 
{
    SCODE sc = WBEM_S_NO_ERROR;
    const WCHAR * ppName[] = 
    {
        PVD_REC_CONTAINER_NAME,
        PVD_REC_DOMAIN_NAME,
        PVD_REC_OWNER_NAME
    };
    if (pSqlEval == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // converting from sql to a set of zone, domain and owner name to be queried on
    //
    CQueryEnumerator qeInst(
        (WCHAR**) ppName,
        3);
    pSqlEval->GenerateQueryEnum(qeInst);


    qeInst.Reset();
    BOOL flag = TRUE;
    CWbemInstanceMgr InstanceMgr(
                    pHandler);

    CDnsWrap& dns = CDnsWrap::DnsObject();
    //
    // loop through a array of ppName, figure out what zone, domain and owner
    // criteria should be used, then call dnsEnumRecordsForDomainEx with those 
    // parameter plus CSqlEval, CSqlEval is used further to filter out record
    //
    while(flag)
    {
        int nSize;
        const WCHAR **pp = qeInst.GetNext(nSize);
        if(pp != NULL)
        {
            // if no domain specified, do recursive search
            BOOL bRecursive = (pp[1] == NULL);

            //if zone not specified, enum all zones
            if(pp[0] == NULL)
            {
                list<CDomainNode> objList;
                sc = dns.dnsEnumDomainForServer(&objList);
                list<CDomainNode>::iterator i;
                for(i=objList.begin(); i!=objList.end(); ++i)
                {
                    //if(_wcsicmp(i->wstrZoneName.data(), PVD_DNS_ROOTHINTS)==0)
                    //    i->wstrNodeName = i->wstrZoneName;
                    if(pp[1] != NULL)
                    {
                        i->wstrNodeName = pp[1];
                        if(pp[2] != NULL)
                        {
                        //take only name ifself, not FQDN

                            i->wstrChildName = pp[2];
                            int pos = i->wstrChildName.find_first_of('.',0);
                            if(pos != string::npos)
                                i->wstrChildName = i->wstrChildName.substr(0,pos);

                        }
                    }

                    try
                    {
                        sc = dns.dnsEnumRecordsForDomainEx(
                            *i,
                            pSqlEval,
                            &QueryFilter, 
                            bRecursive,
                            m_wType,
                            DNS_RPC_VIEW_ALL_DATA,
                            m_pClass,
                            InstanceMgr);
                    }
                    catch(CDnsProvException e)
                    {
                        if(e.GetErrorCode() != DNS_ERROR_NAME_DOES_NOT_EXIST)
                            throw;

                    }
                }


            }
            else
            {
                CDomainNode node;
                if(pp[2] != NULL)
                {
                    //take only name ifself, not FQDN
                    if( pp[1] != NULL)
                    {
                        node.wstrChildName = pp[2];
                        int pos = node.wstrChildName.find_first_of('.',0);
                        if(pos != string::npos)
                            node.wstrChildName = node.wstrChildName.substr(0,pos);
                    }
                }

            
                node.wstrZoneName = pp[0];
                if(pp[1] != NULL)
                {
                    if ( _wcsicmp( pp[0], PVD_DNS_ROOTHINTS) != 0 &&
                         _wcsicmp ( pp[0], PVD_DNS_CACHE ) != 0 ) 
                    {
                        node.wstrNodeName = pp[1];
                    }
                }
                else
                {
                    if ( _wcsicmp( pp[0], PVD_DNS_ROOTHINTS) != 0 &&
                         _wcsicmp ( pp[0], PVD_DNS_CACHE ) != 0 )
                    {
                        node.wstrNodeName = pp[0];
                    }
                }

                sc = dns.dnsEnumRecordsForDomainEx(
                    node,
                    pSqlEval,
                    &QueryFilter, 
                    bRecursive,
                    m_wType,
                    DNS_RPC_VIEW_ALL_DATA,
                    m_pClass,
                    InstanceMgr);

            }
        }
        else
        {
            flag = FALSE;
        }
    }
    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsroothints.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: Dnsroothints.cpp
//
//  Description:    
//      Implementation of CDnsRootHints class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        create an instance of CDnsRootHints
//
//    Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsRootHints::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsRootHints(wszName, pNamespace);
}


CDnsRootHints::CDnsRootHints()
{
}


CDnsRootHints::CDnsRootHints(
    const WCHAR* wszName,
    CWbemServices *pNamespace)
    :CDnsBase(wszName, pNamespace)
{
}


CDnsRootHints::~CDnsRootHints()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enum instances of dns roothints
//
//    Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsRootHints::EnumInstance( 
    long lFlags,
    IWbemContext *pCtx,
    IWbemObjectSink FAR* pHandler)
{
    CDnsWrap& dns = CDnsWrap::DnsObject();
    CWbemClassObject InstNew;
    m_pClass->SpawnInstance(0, &InstNew);
    InstNew.SetProperty(
        dns.GetServerName(),
        PVD_DOMAIN_SERVER_NAME);
    InstNew.SetProperty(
        PVD_DNS_ROOTHINTS,
        PVD_DOMAIN_FQDN);
    InstNew.SetProperty(
        PVD_DNS_ROOTHINTS,
        PVD_DOMAIN_CONTAINER_NAME);
    pHandler->Indicate(1, &InstNew);
    return WBEM_S_NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        retrieve roothints object pointed by the given object path
//
//    Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsRootHints::GetObject(
    CObjPath& ObjectPath,
    long lFlags,
    IWbemContext  *pCtx,
    IWbemObjectSink FAR* pHandler
                    )
{
    CDnsWrap& dns = CDnsWrap::DnsObject();
    wstring wstrServer = ObjectPath.GetStringValueForProperty(
        PVD_DOMAIN_SERVER_NAME);

    if(WBEM_S_NO_ERROR != dns.ValidateServerName(wstrServer.data()))
    {
        return WBEM_E_FAILED;
    }
    wstring wstrContainer = ObjectPath.GetStringValueForProperty(
            PVD_DOMAIN_CONTAINER_NAME);
    if(_wcsicmp(wstrContainer.data(),
            PVD_DNS_ROOTHINTS) == 0)
    {
        wstring wstrFQDN= ObjectPath.GetStringValueForProperty(
                PVD_DOMAIN_FQDN);
        if(_wcsicmp(wstrFQDN.data(),
                PVD_DNS_ROOTHINTS) == 0)
        {
            // found
            CWbemClassObject Inst;
            m_pClass->SpawnInstance(0, &Inst);
            Inst.SetProperty(
                dns.GetServerName(),
                PVD_DOMAIN_SERVER_NAME);
            Inst.SetProperty(
                PVD_DNS_ROOTHINTS,
                PVD_DOMAIN_FQDN);
            Inst.SetProperty(
                PVD_DNS_ROOTHINTS,
                PVD_DOMAIN_CONTAINER_NAME);
            pHandler->Indicate(1, &Inst);
        }
    }
    return WBEM_S_NO_ERROR;

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        execute methods defined for roothints class in the mof 
//
//    Arguments:
//      ObjPath             [IN]    pointing to the object that the 
//                                  method should be performed on
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsRootHints::ExecuteMethod(
    CObjPath &          ObjPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
    CDnsWrap& dns = CDnsWrap::DnsObject();
    wstring wstrZoneName =  ObjPath.GetStringValueForProperty(
        PVD_DOMAIN_CONTAINER_NAME);
    string strZoneName;
    WcharToString(wstrZoneName.data(), strZoneName);
    SCODE sc;

    if(_wcsicmp(
        wzMethodName,  
        PVD_MTH_RH_WRITEBACKROOTHINTDATAFILE ) == 0)
    {
        return dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_WRITE_BACK_ZONE);
    }

    else if(_wcsicmp(
        wzMethodName,
        PVD_MTH_ZONE_GETDISTINGUISHEDNAME) == 0)
    {
        wstring wstrName;
        wstring wstrRootHints = PVD_DNS_ROOTHINTS;
        CWbemClassObject OutParams, OutClass, Class ;
        HRESULT hr;
    
        dns.dnsDsZoneName(wstrName, wstrRootHints);


        BSTR ClassName=NULL;
        ClassName = AllocBstr(PVD_CLASS_ROOTHINTS); 
        hr = m_pNamespace->GetObject(ClassName, 0, 0, &Class, NULL);
        SysFreeString(ClassName);
        if ( SUCCEEDED ( hr ) )
        {
            Class.GetMethod(wzMethodName, 0, NULL, &OutClass);
            OutClass.SpawnInstance(0, &OutParams);
            OutParams.SetProperty(wstrName, PVD_DNS_RETURN_VALUE);
            hr = pHandler->Indicate(1, &OutParams);
        }

        return hr;
    }

    return S_OK;
    
}


SCODE CDnsRootHints::PutInstance(
    IWbemClassObject *pInst ,
    long lF,
    IWbemContext* pCtx ,
    IWbemObjectSink *pHandler)
{
    return WBEM_E_NOT_SUPPORTED;
}; 


SCODE CDnsRootHints::DeleteInstance( 
    CObjPath& ObjectPath,
    long lFlags,
    IWbemContext *pCtx,
    IWbemObjectSink *pResponseHandler) 
{
    return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsresourcerecord.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsdomain.h
//
//	Implementation File:
//		dnscache.cpp
//
//	Description:
//		Definition of the CDnsDomain class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


#include "dnsbase.h"
class CObjPath;

class CDnsResourceRecord  : CDnsBase
{
public:
	CDnsResourceRecord();
	CDnsResourceRecord(
		const WCHAR*,
		CWbemServices*, 
		const char*
		);
	~CDnsResourceRecord();
	CDnsResourceRecord(
		WCHAR*, 
		char*);
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;
	SCODE ExecQuery(
	    CSqlEval *          pSqlEval,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pHandler
        );
	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 
	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pHandler 
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );
    static SCODE InstanceFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
        );
		
	static SCODE GetObjectFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
        );
	static SCODE QueryFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
        );


protected:
	SCODE Modify(
        CObjPath&           objPath,
        IWbemClassObject*   pInArgs,
        IWbemClassObject*   pOutParams,
        IWbemObjectSink*    pHandler
        );

	SCODE CreateInstanceFromText(
	    IWbemClassObject *  pInArgs,
	    IWbemClassObject *  pOutParams,
	    IWbemObjectSink *   pHandler
        );
	SCODE CreateInstanceFromProperty(
	    IWbemClassObject *  pInArgs,
	    IWbemClassObject *  pOutParams,
	    IWbemObjectSink *   pHandler
        );
    SCODE GetObjectFromText(
        IWbemClassObject *  pInArgs,
        IWbemClassObject *  pOutParams,
        IWbemObjectSink *   pHandler
        ) ;
	SCODE GetDomainNameFromZoneAndOwner(
        string & InZone,
        string & InOwner,
        string & OutNode
        ) ;


	wstring m_wstrClassName;
	WORD m_wType;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsprov.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: Dnsprov.cpp
//
//  Description:    
//      Implementation of dll exported functions
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////

#include "DnsWmi.h"

                             
DEFINE_GUID(CLSID_DNS_SERVER,0x62269fec, 0x7b32, 0x11d2, 0x9a, 0xb7,0x00, 0x00, 0xf8, 0x75, 0xc5, 0xd4);
// { 62269fec-7b32-11d2-9ab7-0000f875c5d4 }

//  Count number of objects and number of locks.

long            g_cObj=0;
long            g_cLock=0;
HMODULE         ghModule;


extern DWORD        DnsWmiDebugFlag = 0;
extern DWORD        DnsLibDebugFlag = 0;



//***************************************************************************
//
// CompileMofFile
//
// Purpose: Automagically compile the MOF file into the WMI repository.
//
// Return:  S_OK or error if unable to compile or file MOF.
//
//***************************************************************************
static
SCODE
CompileMofFile(
    VOID )
{
    SCODE           sc = S_OK;
    const WCHAR     szMofRelativePath[] = L"\\system32\\wbem\\dnsprov.mof";
    WCHAR           szMofPath[ MAX_PATH + 5 ] = L"";
    IMofCompiler *  pMofComp = NULL;
    HANDLE          h;

    WBEM_COMPILE_STATUS_INFO    Info;

    //
    //  Formulate path of MOF file
    //
       
    if ( GetSystemWindowsDirectoryW(
            szMofPath,
            MAX_PATH - wcslen( szMofRelativePath ) ) == 0 )
    {
        sc = GetLastError();
        goto Done;
    }
    lstrcatW( szMofPath, szMofRelativePath );

    //
    //  Verify that MOF file exists.
    //

    h = CreateFileW(
            szMofPath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL );
    if ( h == INVALID_HANDLE_VALUE )
    {
        sc = ERROR_FILE_NOT_FOUND;
        goto Done;
    }
    CloseHandle( h );

    //
    //  Load and invoke the MOF compiler.
    //
           
    sc = CoCreateInstance(
            CLSID_MofCompiler,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMofCompiler,
            ( LPVOID * ) &pMofComp );
    if ( FAILED( sc ) )
    {
        goto Done;        
    }
    sc = pMofComp->CompileFile (
                ( LPWSTR ) szMofPath,
                NULL,                   // load into namespace specified in MOF file
                NULL,           // use default User
                NULL,           // use default Authority
                NULL,           // use default Password
                0,              // no options
                0,                              // no class flags
                0,              // no instance flags
                &Info );

    //
    //  Cleanup and return.
    //

    Done:

    if ( pMofComp )
    {
        pMofComp->Release();
    }
    return sc;
}   //  CompileMofFile


//***************************************************************************
//
BOOL 
WINAPI 
DllMain( 
        HANDLE hModule, 
    DWORD  dwReason, 
    LPVOID lpReserved
                                         )
{
    DBG_FN( "DllMain" );

    #if DBG

    DWORD   pid = GetCurrentProcessId();

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        CHAR    szBase[ MAX_PATH ];
        CHAR    szFlagFile[ MAX_PATH + 50 ];
        CHAR    szLogFile[ MAX_PATH + 50 ];

        //
        //  Initialize debug logging.
        //

        if ( GetWindowsDirectoryA( szBase, sizeof( szBase ) ) == 0 )
        {
            return FALSE;
        }
        strcat( szBase, DNSWMI_DBG_LOG_DIR );
        strcpy( szFlagFile, szBase );
        strcat( szFlagFile, DNSWMI_DBG_FLAG_FILE_NAME );
        sprintf(
            szLogFile,
            "%s" DNSWMI_DBG_LOG_FILE_BASE_NAME ".%03X.log",
            szBase,
            pid );

        Dns_StartDebug(
            0,
            szFlagFile,
            &DnsWmiDebugFlag,
            szLogFile,
            DNSWMI_DBG_LOG_FILE_WRAP );
        
        //  Turn off dnslib logging except for basic output controls.

        if ( pDnsDebugFlag )
        {
            pDnsDebugFlag = &DnsLibDebugFlag;
            *pDnsDebugFlag = 0x1000000D;
        }

        IF_DEBUG( START_BREAK )
        {
            DebugBreak();
        }
    }

    #endif

    DNS_DEBUG( INIT, (
        "%s: PID %03X reason %d returning TRUE\n", fn, pid, dwReason ));

    return TRUE;
}   //  DllMain


//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    DBG_FN( "DllCanUnloadNow" )

    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;

    DNS_DEBUG( INIT, ( "%s: returning 0x%08x\n", fn, sc ));

    return sc;
}


//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    SCODE       sc = S_OK;
    TCHAR       szID[ 128 ];
    WCHAR       wcID[ 128 ];
    TCHAR       szCLSID[ 128 ];
    TCHAR       szModule[ MAX_PATH + 1 ];
    TCHAR       *pName = TEXT("MS_NT_DNS_PROVIDER");
    TCHAR       *pModel = TEXT("Both");
    HKEY        hKey1, hKey2;

    ghModule = GetModuleHandle(TEXT("Dnsprov"));

    // Create the path.

    StringFromGUID2(
                CLSID_DNS_SERVER, 
                wcID,
                128);
#ifndef UNICODE
    wcstombs(szID, wcID, 128);
#else
        _tcscpy(szID, wcID);
#endif
    lstrcpy(
        szCLSID,
        TEXT("Software\\classes\\CLSID\\") );
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(
                HKEY_LOCAL_MACHINE, 
                szCLSID,
                &hKey1);
    RegSetValueEx(
                hKey1, 
                NULL,
                0,
                REG_SZ, 
                (BYTE *)pName, 
                lstrlen(pName)+1 );
    RegCreateKey(
                hKey1,
                TEXT("InprocServer32"),
                &hKey2);

    GetModuleFileName(
                ghModule, 
                szModule,
                MAX_PATH );
    szModule[ MAX_PATH ] = L'\0';
    RegSetValueEx(
                hKey2,
                NULL, 
                0,
                REG_SZ,
                (BYTE *)szModule, 
        lstrlen(szModule)+1);
    RegSetValueEx(
                hKey2, 
                TEXT("ThreadingModel"),
                0,
                REG_SZ, 
        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    //
    //  Compile the MOF file. If this fails, it would be good to
    //  tell the admin, but I don't have an easy way to do that.
    //

    CompileMofFile();

    return sc;

}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    TCHAR   szID[128];
    WCHAR   wcID[128];
    TCHAR       szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_DNS_SERVER, wcID, 128);
#ifndef UNICODE
    wcstombs(szID, wcID, 128);
#else
        _tcscpy(szID, wcID);
#endif


    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(
                HKEY_LOCAL_MACHINE, 
                szCLSID,
                &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(
                        hKey, 
                        TEXT("InProcServer32"));
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                TEXT("Software\\classes\\CLSID"),
                &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(
                        hKey,
                        szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    DBG_FN( "DllGetClassObject" )

    HRESULT hr;
    CProvFactory *pObj = NULL;

    if ( CLSID_DNS_SERVER != rclsid )
    {
        hr = E_FAIL;
        goto Done;
    }

    pObj = new CProvFactory();
    if ( NULL == pObj )
    {
        hr = E_OUTOFMEMORY;
        goto Done;
    }

    hr = pObj->QueryInterface( riid, ppv );
    if ( FAILED( hr ) )
    {
        delete pObj;
    }

    Done:

    DNS_DEBUG( INIT, ( "%s: returning 0x%08x\n", fn, hr ));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsroothints.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		DnsRootHints.h
//
//	Implementation File:
//		DnsRootHints.cpp
//
//	Description:
//		Definition of the CDnsRootHints class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"
class CObjPath;

class CDnsRootHints  : CDnsBase
{
public:
	CDnsRootHints();
	CDnsRootHints(
		const WCHAR*, 
		CWbemServices*);
	~CDnsRootHints();

	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 
	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pResponseHandler 
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsserverdomaincontainment.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: DnsServerDomainContainment.cpp
//
//  Description:    
//      Implementation of CDnsServerDomainContainment class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		create an instance of CDnsServerDomainContainment
//
//	Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
CDnsBase* 
CDnsServerDomainContainment::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsServerDomainContainment(wszName, pNamespace);
}


CDnsServerDomainContainment::CDnsServerDomainContainment()
{
}


CDnsServerDomainContainment::CDnsServerDomainContainment(
	const WCHAR* wszName,
	CWbemServices *pNamespace)
	:CDnsBase(wszName, pNamespace)
{
}


CDnsServerDomainContainment::~CDnsServerDomainContainment()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		enum instances of dns server and domain association
//
//	Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsServerDomainContainment::EnumInstance( 
	long				lFlags,
	IWbemContext *		pCtx,
	IWbemObjectSink *	pHandler
    )
{
	list<CObjPath> opList;
	list<CObjPath>::iterator i;
	SCODE sc;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	sc = dns.dnsEnumDomainForServer(&opList);
	if (FAILED(sc))
	{
		return sc;
	}

	CObjPath opServer;
	opServer.SetClass(PVD_CLASS_SERVER);
	opServer.AddProperty(
		PVD_SRV_SERVER_NAME,
		dns.GetServerName().data());

	for(i=opList.begin(); i!=opList.end(); ++i)
	{
		CWbemClassObject Inst;
		m_pClass->SpawnInstance(0, &Inst);
		Inst.SetProperty(
			opServer.GetObjectPathString(), 
			PVD_ASSOC_PARENT);
		Inst.SetProperty(
			(*i).GetObjectPathString(), 
			PVD_ASSOC_CHILD); 
		pHandler->Indicate(1, &Inst);
	}
	
	return WBEM_S_NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		retrieve server domain association object pointed by the 
//      given object path
//
//	Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsServerDomainContainment::GetObject(
	CObjPath &          ObjectPath,
	long                lFlags,
	IWbemContext  *     pCtx,
	IWbemObjectSink *   pHandler
    )
{
		return WBEM_E_NOT_SUPPORTED;
}

SCODE 
CDnsServerDomainContainment::ExecuteMethod(	
	CObjPath&,
	WCHAR*,
	long,
	IWbemClassObject*,
	IWbemObjectSink*) 
{
		return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsrpcrecord.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: dnsrpcreocrd.cpp
//
//  Description:    
//      Implementation of dns rpc related class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


// defination for CDnsRpcmemory

CDnsRpcMemory::CDnsRpcMemory()
{
}


CDnsRpcMemory::~CDnsRpcMemory()
{
}


PBYTE 
CDnsRpcMemory::IncrementPtrByNodeHead(PBYTE pByte)
{
        pByte += ((PDNS_RPC_NODE)pByte)->wLength;
        return DNS_NEXT_DWORD_PTR(pByte);
}


PBYTE
CDnsRpcMemory::IncrementPtrByRecord(PBYTE pByte)
{
        pByte += ((PDNS_RPC_RECORD)pByte)->wDataLength
                    + SIZEOF_DNS_RPC_RECORD_HEADER;
        
        return DNS_NEXT_DWORD_PTR(pByte);
}


SCODE 
CDnsRpcRecord::Init(
        string& strOwner,
        string& strRdata,
        DWORD dwTtl
    )
{
    m_dwTtl = dwTtl;
    m_strOwnerName = strOwner;
    
    ParseRdata(strRdata, m_cRdata);
    return BuildRpcRecord(m_cRdata, m_ppRdata+1);
}

SCODE
CDnsRpcRecord::Init(
        wstring&            wstrClass,
        string&             strOwner,
        string&             strRdata,
        CWbemClassObject&   Inst
    )
{
        if(Inst.GetProperty(
                &m_dwTtl,
                PVD_REC_TTL) != S_OK)
                m_dwTtl = 0;
        m_strOwnerName = strOwner;
        if(!strRdata.empty())
        {
                ParseRdata(
                        strRdata, 
                        m_cRdata);
        }

        // what value we got in wmi?
        const WCHAR** ppName = GetRdataName();
   for(int i = 0; i<m_cRdata; i++)
        {
            ReplaceRdata(
            i+1,
            ppName[i],
            Inst);
        }
        return BuildRpcRecord(m_cRdata, m_ppRdata+1);
        
}


CDnsRpcRecord::CDnsRpcRecord(
    WORD wRdataSize ) :
    m_pRecord( NULL ),
    m_pRecordRequiresFree( TRUE ),
    m_bRdataChange( FALSE ),
    m_cRdata( 0 )
{
    m_ppRdata = new char* [wRdataSize+1];
    if ( m_ppRdata )
    {
        for(int i=0; i<= wRdataSize; i++)
        {
            m_ppRdata[i] = NULL;
        }
        m_cRdata = wRdataSize;
    }
    else
    {
        m_cRdata = 0;
    }
}


CDnsRpcRecord::~CDnsRpcRecord()
{
    if(m_cRdata > 0)
    {
        for(int i = 0; i<= m_cRdata; i++)
        {
            delete [] m_ppRdata[i];
        }
    }
    delete [] m_ppRdata;
    if ( m_pRecord && m_pRecordRequiresFree )
    {
        FREE_HEAP( m_pRecord );
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              helper function to arguments from rdata string. each time the function
//      is called, it sets *ppszOut to the newly allocated buffer and copy the 
//      value over, and return a pointer that moved to the char after that rdata
//      argument
//
//      Arguments:
//      pszIn               [IN]    input Rdata string
//      ppszOut             [OUT]   output string which is one of the rdata arg
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

char* 
CDnsRpcRecord::GetNextArg(
        char *  pszIn, 
        char ** ppszOut
    )
{
        if(!pszIn || *pszIn == '\0')
    {
                return NULL;
    }
        char* bin ;
        //ignore leading space
        for(bin = pszIn; *bin == ' '; bin++);
        char* end;
        char delimeter = ' ';
        if( *bin == '\"')
    {
                delimeter = *bin++;
    }
        int length = 1;
        for(end = bin; *end != delimeter && *end != '\0'; end++, length++);
        if(delimeter == '\"')
    {
                end++;  // pass delimeter
    }
        *ppszOut = new char[length];
        strncpy(
                *ppszOut, 
                bin,
                length-1);
        *(*ppszOut+length-1) = '\0';
        return end;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              use data in record to set wbem object
//
//      Arguments:
//      Inst               [IN OUT]    wmi object 
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        Inst.SetProperty(
                (DWORD)1,
                PVD_REC_CLASS);
        Inst.SetProperty(
                GetTtl(),
                PVD_REC_TTL);
        return WBEM_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              creating concrete record type class based on a type value
//
//      Arguments:
//      wType               [IN]    type indicating the type of record
//      pptr                [OUT]   a pointer to base record class.
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::CreateClass(
        WORD        wType,
        PVOID *     pptr
    )
{

        switch ( wType)
        {
                case DNS_TYPE_ATMA:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcATMA(wType);
                        break;
                case DNS_TYPE_A:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcA(wType);
                        break;
                case DNS_TYPE_SOA:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcSOA(wType);
                        break;
                case DNS_TYPE_PTR:
                case DNS_TYPE_NS:
                case DNS_TYPE_CNAME:
                case DNS_TYPE_MD:
                case DNS_TYPE_MB:
                case DNS_TYPE_MF:
                case DNS_TYPE_MG:
                case DNS_TYPE_MR:

                        *pptr = (CDnsRpcRecord*) new CDnsRpcNS(wType);
                        break;
                case DNS_TYPE_MX:
                case DNS_TYPE_RT:
                case DNS_TYPE_AFSDB:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcMX(wType);
                        break;
                case DNS_TYPE_MINFO:
                case DNS_TYPE_RP:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcMINFO(wType);
                        break;
                case DNS_TYPE_AAAA:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcAAAA(wType);
                        break;
                case DNS_TYPE_HINFO:
                case DNS_TYPE_ISDN:
                case DNS_TYPE_X25:
                case DNS_TYPE_TEXT:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcTXT(wType);
                        break;
                case DNS_TYPE_WKS:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcWKS(wType);
                        break;
                case DNS_TYPE_SRV:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcSRV(wType);
                        break;
                case DNS_TYPE_WINS:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcWINS(wType);
                        break;
                case DNS_TYPE_WINSR:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcWINSR(wType);
                        break;
                default:
                                return WBEM_E_FAILED; 
                }
        
        return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              send the record to dns server to delete or add
//
//      Arguments:
//      szContainerName     [IN]    zone name
//      Type                [IN]    type of action,delete or add
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::SendToServer(
        const char* szContainerName,
        ActionType Type 
    )
{

        PDNS_RPC_RECORD pRecordToAdd=NULL, pRecordToDelete=NULL;
        if(Type == AddRecord)
    {
                pRecordToAdd = m_pRecord;
    }
        else if(Type == DeleteRecord)
    {
        pRecordToDelete = m_pRecord;
    }
        else
    {
        return WBEM_E_INVALID_PARAMETER;
    }

        int status = DnssrvUpdateRecord(
                PVD_DNS_LOCAL_SERVER,    // server
                szContainerName,                //zone
                m_strOwnerName.data(),  //node
                pRecordToAdd,            // RR to add
                pRecordToDelete
                );
        if ( status != ERROR_SUCCESS )  

    {
                CDnsWrap::DnsObject().ThrowException(status);
    }
        
        // when SOA saved, serial no. automaticly increment by 1
        if(m_wType == DNS_TYPE_SOA && Type == AddRecord)
        {               PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
                pData->SOA.dwSerialNo++;
        }
        return WBEM_S_NO_ERROR;

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              initialize a record based on PDNS_RPC_RECORD
//
//      Arguments:
//      pRecord         [IN]    pointer to a rpc record
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL 
CDnsRpcRecord::Init(
        PDNS_RPC_RECORD pRecord
    )
{
        if(!pRecord)
        {
                return FALSE;
        }
        m_pRecord = pRecord;
        m_pRecordRequiresFree = FALSE;
        m_wType = pRecord->wType;
        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              get the type of a record
//
//      Arguments:
//    
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

WORD
CDnsRpcRecord::GetType()
{
        if(m_pRecord==NULL)
    {
        return 0;
    }
        return m_pRecord->wType;
}

DWORD
CDnsRpcRecord::GetTtl()
{
        if(m_pRecord == NULL)
    {
        return 0;
    }
        return m_pRecord->dwTtlSeconds;
}

BOOL 
CDnsRpcRecord::RpcNameCopy(
        wstring&        wstrTarget, 
        PDNS_RPC_NAME   pName
    )
{
        wstrTarget = CharToWstring(
                pName->achName,
                pName->cchNameLength);
        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              retrieve object path from rpc record
//
//      Arguments:
//      wstrServer      [IN]        dns server name
//      wstrZone        [IN]        dns zone name
//      wstrDomain      [IN]        dns domain name
//      wstrOwner       [IN]        dns owner name
//      objOP           [IN OUT]    objpath to be set
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::GetObjectPath(
        wstring     wstrServer,
        wstring     wstrZone,
        wstring     wstrDomain,
        wstring     wstrOwner,
        CObjPath&   objOP
    )
{
    objOP.SetClass(m_pwszClassName);
        objOP.AddProperty(
                PVD_REC_RDATA, 
                GetData().data());

        objOP.AddProperty(
                PVD_REC_CLASS, 
                (WORD)1);
                
        objOP.AddProperty(
                        PVD_REC_SERVER_NAME, 
                        wstrServer.data()
                        );
        objOP.AddProperty(
                        PVD_REC_CONTAINER_NAME, 
                        wstrZone.data()
                        );
        objOP.AddProperty(
                        PVD_REC_DOMAIN_NAME, 
                        GetRecDomain(wstrZone, wstrDomain, wstrOwner).data()
                        );
        objOP.AddProperty(
                        PVD_REC_OWNER_NAME, 
                        wstrOwner.data()
                        );
        return WBEM_S_NO_ERROR;
}

wstring 
CDnsRpcRecord::GetTextRepresentation(
        wstring wstrNodeName  // fully qualified 
        )
{
        wstring wstrTxt = GetClass() + L" " + GetTypeString()+ L" ";
        return wstrNodeName + L" " + wstrTxt + GetData();
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              figure out what's domain name and return it
//
//      Arguments:
//    
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

wstring
CDnsRpcRecord::GetRecDomain(
        wstring wstrZone,
        wstring wstrDomain,
        wstring wstrOwner
    )
{
        
        if(!wstrDomain.empty())
        {
                return wstrDomain;
        }
        else if( _wcsicmp( wstrZone.c_str(), wstrOwner.c_str() ) == 0 )
        {
                wstrDomain = wstrZone;
        }
        else 
        {
                int posFirstPeriod = wstrOwner.find_first_of( '.' );
                if( posFirstPeriod == wstring::npos)
                        throw WBEM_E_INVALID_PARAMETER;
                wstrDomain = wstrOwner.substr(
                        posFirstPeriod + 1, 
                        wstrOwner.length() );
                //varify if this is valid domain
                //if(wstrZone.find(wstrDomain, 0) == string::npos)
                //      throw WBEM_E_INVALID_PARAMETER;
        }

        return wstrDomain;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              use the property value from Inst to modify Rdata. pwsz identifies
//      which value in Inst should be used. and wIndex identifies which
//      one in rdata should be replaced.
//
//      Arguments:
//      wIndex      [IN]        index for m_ppRdata
//      pwsz        [IN]        Name for Rdata field
//      Inst        [IN]        wmi object
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////


SCODE 
CDnsRpcRecord::ReplaceRdata(
    WORD                wIndex,   // index for m_ppRdata
    const WCHAR*        pwsz,   // Name for Rdata field
    CWbemClassObject&   Inst 
    )
{
    string str;
    wstring wstr;
    VARIANT v;
    VariantInit(&v);
    try
    {
        Inst.GetProperty(
                &v,
                pwsz);

        switch(v.vt)
        {
        case VT_I4:
            char sz[30];
            _ltoa(v.lVal, sz, 10);
            str = sz;
            break;
        case VT_BSTR:
            WcharToString(v.bstrVal, str);
            break;
        case VT_NULL:
            return WBEM_S_NO_ERROR;
        default:
            throw WBEM_E_INVALID_PARAMETER;
        }

        delete [] m_ppRdata[wIndex];

        m_ppRdata[wIndex] = new char[str.length()+1];
        if ( !m_ppRdata[wIndex] )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        strcpy(m_ppRdata[wIndex], str.data());
                m_bRdataChange = TRUE;  
        VariantClear(&v);
    }
    catch(...)
    {
        VariantClear(&v);
        throw;
    }

    return WBEM_S_NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              parse rdata string and save them as an array of string in 
//      member variable m_ppRdata
//
//      Arguments:
//      strRdata    [IN]        rdata string
//      wSize       [IN]        number of arg in rdata
//
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::ParseRdata(
        string& strRdata,
        WORD    wSize
        )
{
    m_ppRdata[0] =  new char[strRdata.length()+1];
    if ( !m_ppRdata[0] )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    strcpy(m_ppRdata[0], strRdata.data());
    char * bin = m_ppRdata[0];
    for(int i=1; i<=wSize; i++)
    {
        if(bin == NULL || *bin == '\0')
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        bin = GetNextArg(bin , &(m_ppRdata[i]));
    }
    return S_OK;
}

CDnsRpcRecord::RdataIsChanged()
{
        return m_bRdataChange;
}

CDnsRpcSOA::~CDnsRpcSOA()
{
}
CDnsRpcSOA::CDnsRpcSOA(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
        m_pwszClassName = PVD_CLASS_RR_SOA;
}


const 
WCHAR**
CDnsRpcSOA::GetRdataName(void)
{
        static const WCHAR* pwsz[] ={
                PVD_REC_SOA_PRIMARY_SERVER,
                PVD_REC_SOA_RESPONSIBLE,
                PVD_REC_SOA_SERIAL_NUMBER,
                PVD_REC_SOA_REFRESH,
                PVD_REC_SOA_RETRY_DELAY,
                PVD_REC_SOA_EXPIRE_LIMIT,
                PVD_REC_SOA_TTL};
        return pwsz;
}

SCODE 
CDnsRpcSOA::BuildRpcRecord(
                WORD argc, 
                char** argv)
{
    int cLength  = strlen(argv[0]);
    if(*(argv[0]+cLength-1) != '.')
    {
        char * pNew = new char[cLength+2];
        if ( !pNew )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        strcpy(pNew, argv[0]);
        strcat(pNew, ".");
        delete argv[0];
        argv[0] = pNew;
    }
    cLength  = strlen(argv[1]);
    if(*(argv[1]+cLength-1) != '.')
    {
        char * pNew = new char[cLength+2];
        if ( !pNew )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        strcpy(pNew, argv[1]);
        strcat(pNew, ".");
        delete argv[1];
        argv[1] = pNew;
    }
    return CDnsRpcRecord::BuildRpcRecord( argc, argv );
}


DWORD 
CDnsRpcSOA::GetMinimumTtl(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->SOA.dwMinimumTtl;
}

DWORD 
CDnsRpcSOA::GetExpire(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->SOA.dwExpire;
}

DWORD 
CDnsRpcSOA::GetRefresh(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->SOA.dwRefresh;
}

DWORD
CDnsRpcSOA::GetRetry(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->SOA.dwRetry;
}

DWORD 
CDnsRpcSOA::GetSerialNo(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->SOA.dwSerialNo;
}

wstring 
CDnsRpcSOA::GetPrimaryServer(void)
{
        wstring wstrTxt;
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        RpcNameCopy(wstrTxt, &(pData->SOA.namePrimaryServer));
        return wstrTxt;
}

wstring 
CDnsRpcSOA::GetResponsible(void)
{
        wstring wstrTxt;
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        int iLength = pData->SOA.namePrimaryServer.cchNameLength;
        RpcNameCopy(
                wstrTxt, 
                (PDNS_RPC_NAME)(pData->SOA.namePrimaryServer.achName+iLength));
        return wstrTxt;
}

wstring 
CDnsRpcSOA::GetData(void)
{
        char temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        sprintf(temp," %lu %lu %lu %lu %lu",
            pData->SOA.dwSerialNo,
            pData->SOA.dwRefresh,
            pData->SOA.dwRetry,
            pData->SOA.dwExpire,
            pData->SOA.dwMinimumTtl );
        return  GetPrimaryServer() +
                        L" " + 
                        GetResponsible()+
                        L" " + 
                        CharToWstring(temp, strlen(temp));

}

SCODE 
CDnsRpcSOA::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        Inst.SetProperty(
                GetExpire(),
                PVD_REC_SOA_EXPIRE_LIMIT);
        Inst.SetProperty(
                GetMinimumTtl(), 
                PVD_REC_SOA_TTL);
        Inst.SetProperty(
                GetRefresh(), 
                PVD_REC_SOA_REFRESH);
        Inst.SetProperty(
                GetRetry(),
                PVD_REC_SOA_RETRY_DELAY);
        Inst.SetProperty(
                GetSerialNo(),
                PVD_REC_SOA_SERIAL_NUMBER);
        Inst.SetProperty(
                GetPrimaryServer(),
                PVD_REC_SOA_PRIMARY_SERVER );
        Inst.SetProperty(
                GetResponsible(),
                PVD_REC_SOA_RESPONSIBLE);
        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}


CDnsRpcA::~CDnsRpcA()
{
}
CDnsRpcA::CDnsRpcA(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)

{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_A;    
}

SCODE
CDnsRpcA::ConvertToWbemObject(
        CWbemClassObject& Inst)
{

        Inst.SetProperty(
                GetIP(), 
                PVD_REC_A_IP);
        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
wstring 
CDnsRpcA::GetIP(void)
{
        char temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return IpAddressToString(pData->A.ipAddress);
}
wstring 
CDnsRpcA::GetData(void)
{
        return GetIP();
}

// CDnsRpcNS
CDnsRpcNS::CDnsRpcNS(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    switch (m_wType)
    {
                case DNS_TYPE_PTR:
                        m_pwszClassName = PVD_CLASS_RR_PTR;
                        break;
                case DNS_TYPE_NS:
                        m_pwszClassName = PVD_CLASS_RR_NS;
                        break;
                case DNS_TYPE_CNAME:
                        m_pwszClassName = PVD_CLASS_RR_CNAME;
                        break;
                case DNS_TYPE_MD:
                        m_pwszClassName = PVD_CLASS_RR_MD;
                        break;
                case DNS_TYPE_MB:
                        m_pwszClassName = PVD_CLASS_RR_MB;
                        break;
                case DNS_TYPE_MF:
                        m_pwszClassName =PVD_CLASS_RR_MF;
                        break;
                case DNS_TYPE_MG:
                        m_pwszClassName = PVD_CLASS_RR_MG;
                        break;
                case DNS_TYPE_MR:
                        m_pwszClassName = PVD_CLASS_RR_MR;
                        break;
                default:
            throw WBEM_E_INVALID_PARAMETER;
        }       

}
CDnsRpcNS::~CDnsRpcNS()
{
}       
const 
WCHAR**
CDnsRpcNS::GetRdataName(void)
{
        switch (m_wType)
    {
                case DNS_TYPE_PTR:
                {
                        static const WCHAR* pwszPTR[] =
                        {PVD_REC_PTR_PTRDOMAIN_NAME};
                        return pwszPTR;
                }
                case DNS_TYPE_NS:
                {
                        static const WCHAR* pwszNS[] =
                                {PVD_REC_NS_NSHOST};
                        return pwszNS;
                }
                case DNS_TYPE_CNAME:
                {
                        static const WCHAR* pwszCNAME[] =
                        {PVD_REC_CNAME_PRIMARY_NAME};
                        return pwszCNAME;
                }
                case DNS_TYPE_MD:
                {
                        static const WCHAR* pwszMD[] =
                        {PVD_REC_MD_MDHOST};
                        return pwszMD;
                }
                case DNS_TYPE_MB:
                {
                        static const WCHAR* pwszMB[] =
                                {PVD_REC_MB_MBHOST};
                        return pwszMB;
                }
                case DNS_TYPE_MF:
                {
                        static const WCHAR* pwszMF[] =
                                {PVD_REC_MF_MFHOST};
                        return pwszMF;
                }
                case DNS_TYPE_MG:
                {
                        static const WCHAR* pwszMG[] =
                                {PVD_REC_MG_MGMAILBOX};
                        return pwszMG;
                }
                case DNS_TYPE_MR:
                {
                        static const WCHAR* pwszMR[] =
                                {PVD_REC_MR_MRMAILBOX};
                        return pwszMR;
                }
                default:
            throw WBEM_E_INVALID_PARAMETER;
        }
        return NULL;
}

wstring 
CDnsRpcNS::GetNodeName(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        RpcNameCopy(wstrTxt, &(pData->NS.nameNode));
        return wstrTxt;

}

wstring
CDnsRpcNS::GetRecDomain(
        wstring wstrZone,
        wstring wstrDomain,
        wstring wstrOwner)
{
        
        if(m_wType == DNS_TYPE_NS)
        {
                return wstrOwner;
        }

        return CDnsRpcRecord::GetRecDomain(
                wstrZone,
                wstrDomain,
                wstrOwner);
}

wstring 
CDnsRpcNS::GetData(void)
{
        return GetNodeName();
}

SCODE
CDnsRpcNS::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        const WCHAR** ppName = GetRdataName();
    Inst.SetProperty(
        GetNodeName(),
        ppName[0]);
    Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}

SCODE 
CDnsRpcNS::BuildRpcRecord(
                WORD argc, 
                char** argv)
{
        
        int cLength  = strlen(argv[0]);
        if(*(argv[0]+cLength-1) != '.')
        {
                char * pNew = new char[ cLength + 2 ];
                if ( !pNew )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }
                strcpy(pNew, argv[0]);
                strcat(pNew, ".");
                delete argv[0];
                argv[0] = pNew;
        }
        return CDnsRpcRecord::BuildRpcRecord(
                argc,
                argv);
}

// CDnsRpcMX
CDnsRpcMX::CDnsRpcMX(WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    switch(m_wType)
    {
    case DNS_TYPE_MX:
        m_pwszClassName = PVD_CLASS_RR_MX;
        break;
    case DNS_TYPE_RT:
        m_pwszClassName = PVD_CLASS_RR_RT;
                break;
    case DNS_TYPE_AFSDB:
        m_pwszClassName = PVD_CLASS_RR_AFSDB;
                break;
    default:
        throw WBEM_E_INVALID_PARAMETER;
    }

}
CDnsRpcMX::~CDnsRpcMX()
{
}       

SCODE
CDnsRpcMX::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        const WCHAR** ppName = GetRdataName();
        Inst.SetProperty(
                GetPreference(),
                ppName[0]);

    Inst.SetProperty(
                GetNodeName(), 
                ppName[1]);

    Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcMX::GetRdataName(void)
{

    switch(m_wType)
    {
    case DNS_TYPE_MX:
        {
                static const WCHAR* pwszMX[] = 
                {PVD_REC_MX_PREFERENCE,
                PVD_REC_MX_MAIL_EXCHANGE};
                return pwszMX;
        }
    case DNS_TYPE_RT:
        {
                static const WCHAR* pwszRT[] = 
                { PVD_REC_RT_PREFERENCE,
                PVD_REC_RT_HOST};
                return pwszRT;
        }
    case DNS_TYPE_AFSDB:
        {
                static const WCHAR* pwszAFSDB[] = 
                {PVD_REC_AFSBD_SUB_TYPE,
                PVD_REC_AFSBD_SERVER_NAME};
                return pwszAFSDB;
        }
    default:
        throw WBEM_E_INVALID_PARAMETER;
    }
        return NULL;
}

wstring 
CDnsRpcMX::GetNodeName()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        RpcNameCopy(wstrTxt, &(pData->MX.nameExchange));
        return wstrTxt;
}

DWORD
CDnsRpcMX::GetPreference()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->MX.wPreference;
}
wstring 
CDnsRpcMX::GetData(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        WCHAR temp[MAX_PATH];
        swprintf(
                temp, 
                L" %d ", 
                pData->MX.wPreference);
        
        return temp + GetNodeName();
}

CDnsRpcMINFO::CDnsRpcMINFO(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    switch(m_wType)
        {
        case DNS_TYPE_MINFO:
        m_pwszClassName = PVD_CLASS_RR_MINFO;
                break;
        case DNS_TYPE_RP:
        m_pwszClassName = PVD_CLASS_RR_RP;
                break;
        default:
                throw WBEM_E_INVALID_PARAMETER;
        }

}
CDnsRpcMINFO::~CDnsRpcMINFO()
{
}       

SCODE
CDnsRpcMINFO::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        const WCHAR** ppName = GetRdataName();
    Inst.SetProperty(
        GetRPMailBox(),
        ppName[0]);
    Inst.SetProperty(
        GetErrMailBox(),
        ppName[1]);
        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcMINFO::GetRdataName(void)
{

    switch(m_wType)
        {
        case DNS_TYPE_MINFO:
        {       static const WCHAR* pwszMINFO[] = 
                {PVD_REC_MINFO_RESP_MAILBOX,
                PVD_REC_MINFO_ERROR_MAILBOX};
                return pwszMINFO;
        }
        case DNS_TYPE_RP:
        {
                static const WCHAR* pwszRP[] = 
        {PVD_REC_RP_RPMAILBOX, 
                PVD_REC_RP_TXT_DOMAIN_NAME};
                return pwszRP;
        }
        default:
                throw WBEM_E_INVALID_PARAMETER;
        }
        return NULL;
}

wstring 
CDnsRpcMINFO::GetRPMailBox()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        RpcNameCopy(
                wstrTxt, 
                &(pData->MINFO.nameMailBox));
        return wstrTxt;

}
wstring 
CDnsRpcMINFO::GetErrMailBox()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        int iLength = pData->MINFO.nameMailBox.cchNameLength;
        RpcNameCopy(
                wstrTxt,
                (PDNS_RPC_NAME)(pData->MINFO.nameMailBox.achName+iLength));
        return wstrTxt;
}

wstring 
CDnsRpcMINFO::GetData(void)
{
        return GetRPMailBox() + L" " + GetErrMailBox();
}

CDnsRpcAAAA::~CDnsRpcAAAA()
{
}
CDnsRpcAAAA::CDnsRpcAAAA(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_AAAA;
}
SCODE
CDnsRpcAAAA::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        Inst.SetProperty(
                GetIP(), 
                PVD_REC_AAAA_IP);
        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}

wstring 
CDnsRpcAAAA::GetData(void)
{
        return GetIP();
}

wstring 
CDnsRpcAAAA::GetIP(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        CHAR    ip6String[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

        Dns_Ip6AddressToString_A(
            ip6String,
            &pData->AAAA.ipv6Address );

        return  CharToWstring( ip6String, strlen(ip6String) );
}

const 
WCHAR**
CDnsRpcAAAA::GetRdataName(void)
{

        static const WCHAR* pwsz[] ={PVD_REC_AAAA_IP};
        return pwsz;
}

// CDnsRpcTXT

CDnsRpcTXT::~CDnsRpcTXT()
{
}
CDnsRpcTXT::CDnsRpcTXT(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA_HINFO)
{
        m_wType = wType;
    switch(m_wType)
    {
    case DNS_TYPE_HINFO:
        m_pwszClassName = PVD_CLASS_RR_HINFO;
                m_cRdata=NUM_OF_ARG_IN_RDATA_HINFO;
        break;
    case DNS_TYPE_ISDN:
        m_pwszClassName = PVD_CLASS_RR_ISDN;
                m_cRdata=NUM_OF_ARG_IN_RDATA_HINFO;
        break;
    case DNS_TYPE_X25:
        m_pwszClassName = PVD_CLASS_RR_X25;
                m_cRdata=NUM_OF_ARG_IN_RDATA_TXT;
                break;
    case DNS_TYPE_TEXT:
        m_pwszClassName = PVD_CLASS_RR_TXT;
                m_cRdata=NUM_OF_ARG_IN_RDATA_TXT;
                break;
    default:
        throw WBEM_E_INVALID_PARAMETER;
    }
}

SCODE
CDnsRpcTXT::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        const WCHAR** ppName = GetRdataName();
    Inst.SetProperty(
                GetString1(), 
                ppName[0]);
        //exception case .num of rdata arg varies depends on type. 
        // handle it.
        if(m_cRdata == 2)
        {
                Inst.SetProperty(
                        GetString2(),
                        ppName[1]);
        }
  Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);


  CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcTXT::GetRdataName(void)
{

        switch(m_wType)
    {
    case DNS_TYPE_HINFO:
        {
                static const WCHAR* pwszHINFO[] = 
                {PVD_REC_HINFO_CPU,
                PVD_REC_HINFO_OS};
                return pwszHINFO;
        }
    case DNS_TYPE_ISDN:
        {
                static const WCHAR* pwszISDN[] = 
                { PVD_REC_ISDN_ISDN_NUM,
                PVD_REC_ISDN_SUB_ADDRESS};
                return pwszISDN;
        }
    case DNS_TYPE_X25:
        {
                static const WCHAR* pwszX25[] = 
                {PVD_REC_X25_PSDNADDRESS};
                return pwszX25;
        }
    case DNS_TYPE_TEXT:
        {
                static const WCHAR* pwszTEXT[] = 
                {PVD_REC_TXT_TEXT};
        return pwszTEXT;
        }
    default:
        throw WBEM_E_INVALID_PARAMETER;
    }
        return NULL;
}

wstring
CDnsRpcTXT::GetString1()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        RpcNameCopy(
                wstrTxt, 
                &(pData->TXT.stringData));
        return wstrTxt;

}
wstring
CDnsRpcTXT::GetString2()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        int iLength = pData->TXT.stringData.cchNameLength;
        if( (m_pRecord->wDataLength-1) > iLength)
        {
                RpcNameCopy(
                        wstrTxt,
                        (PDNS_RPC_NAME)(pData->TXT.stringData.achName+iLength));
        }
        return wstrTxt;
}

wstring 
CDnsRpcTXT::GetTextRepresentation(
        wstring wstrNodeName)
{
        wstring wstrTxt = GetClass() + L" " + GetTypeString()+ L" ";
        return wstrNodeName + L" " + wstrTxt + GetData();
}
        

wstring 
CDnsRpcTXT::GetData(void)
{
        wstring wstrTxt = L"\"" + GetString1() + L"\"";
        wstring wstrTxt2 = GetString2();
        if(wstrTxt2.empty())
        {
                return wstrTxt;
        }
        else
                return wstrTxt + L" \""  +wstrTxt2 +L"\"";
}

CDnsRpcWKS::~CDnsRpcWKS()
{
}
CDnsRpcWKS::CDnsRpcWKS(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_WKS;
}

SCODE
CDnsRpcWKS::ConvertToWbemObject(
        CWbemClassObject& Inst)
{

        Inst.SetProperty(
                GetIP(), 
                PVD_REC_WKS_INTERNET_ADDRESS);
        Inst.SetProperty(
                GetIPProtocal(), 
                PVD_REC_WKS_IP_PROTOCOL);
        Inst.SetProperty(
                GetServices(),
                PVD_REC_WKS_BIT_MASK);

        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcWKS::GetRdataName(void)
{

        static const WCHAR* pwsz[] ={   
                PVD_REC_WKS_IP_PROTOCOL,
                PVD_REC_WKS_INTERNET_ADDRESS,
                PVD_REC_WKS_BIT_MASK};
        return pwsz;
}wstring 
CDnsRpcWKS::GetIP(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return IpAddressToString(pData->WKS.ipAddress);
}
wstring 
CDnsRpcWKS::GetIPProtocal(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        WSADATA wsaData;
        struct protoent * pProtoent;
        DNS_STATUS status = WSAStartup(
                DNS_WINSOCK_VERSION, 
                &wsaData );
    if ( status == SOCKET_ERROR )
    {
        status = WSAGetLastError();
                CDnsWrap::ThrowException(status);
    }
        // get protocal name
    pProtoent = getprotobynumber( pData->WKS.chProtocol );
    if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
        {
                status = WSAGetLastError();
                CDnsWrap::ThrowException(status);
        }
        return CharToWstring(
                pProtoent->p_name, 
                strlen(pProtoent->p_name));
}
wstring 
CDnsRpcWKS::GetServices(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        char temp[MAX_PATH];
        WORD wLength = m_pRecord->wDataLength -
                sizeof(pData->WKS.ipAddress) - 
                sizeof(pData->WKS.chProtocol)-1;
        UCHAR* p = &pData->WKS.bBitMask[1]; //ignore the first
        for(WORD i=0; i< wLength; i++)
        {
                temp[i] = *p++;
        }
        temp[i]='\0';
        wstring wstr = CharToWstring(temp, wLength);
        if(wstr.find_first_of(L" ") != string::npos)
        { //if string contains space, enclose it in quote
                
                wstr = L"\"" + wstr + L"\"";
        }

        return wstr;
}


wstring 
CDnsRpcWKS::GetData(void)
{
        
        return GetIPProtocal() +L" " + GetIP()+ L" " + GetServices();
}


// CDnsRpcSRV

CDnsRpcSRV::~CDnsRpcSRV()
{
}
CDnsRpcSRV::CDnsRpcSRV(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_SRV;
}

SCODE
CDnsRpcSRV::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        wstring wstrClassName;
        Inst.SetProperty(
                GetPriority(), 
                PVD_REC_SRV_PRIORITY);
        Inst.SetProperty(
                GetWeight(), 
                PVD_REC_SRV_WEIGHT);
        Inst.SetProperty(
                GetPort(), 
                PVD_REC_SRV_PORT);
        
        Inst.SetProperty(
                GetDomainName(), 
                PVD_REC_SRV_DOMAINNAME);
        

        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcSRV::GetRdataName(void)
{

        static const WCHAR* pwsz[] ={ 
                PVD_REC_SRV_PRIORITY,
                PVD_REC_SRV_WEIGHT,
                PVD_REC_SRV_PORT,
                PVD_REC_SRV_DOMAINNAME};
        return pwsz;
}

wstring 
CDnsRpcSRV::GetDomainName(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        RpcNameCopy(wstrTxt, &(pData->SRV.nameTarget));
        return wstrTxt;
}

DWORD
CDnsRpcSRV::GetPort()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->SRV.wPort;
}
DWORD
CDnsRpcSRV::GetPriority()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->SRV.wPriority;
}

DWORD
CDnsRpcSRV::GetWeight()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->SRV.wWeight;
}
        

wstring 
CDnsRpcSRV::GetData(void)
{
        WCHAR temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        swprintf(temp,
                        L"%d %d %d ",
                        pData->SRV.wPriority,
                        pData->SRV.wWeight,
                        pData->SRV.wPort);
        return temp + GetDomainName();
}


// CDnsRpcWINS

CDnsRpcWINS::~CDnsRpcWINS()
{
}
CDnsRpcWINS::CDnsRpcWINS(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_WINS;
}

SCODE
CDnsRpcWINS::ConvertToWbemObject(
        CWbemClassObject& Inst)
{

        Inst.SetProperty(
                GetCacheTimeOut(), 
                PVD_REC_WINS_CACHE_TIMEOUT);
        Inst.SetProperty(
                GetLookupTimeOut(), 
                PVD_REC_WINS_TIMEOUT);

        Inst.SetProperty(
                GetMapFlag(), 
                PVD_REC_WINS_MAPPING_FLAG );

        Inst.SetProperty(
                GetWinServer(), 
                PVD_REC_WINS_WINS_SERVER);


        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcWINS::GetRdataName(void)
{

        static const WCHAR* pwsz[] ={ 
                PVD_REC_WINS_MAPPING_FLAG,
                PVD_REC_WINS_TIMEOUT,
                PVD_REC_WINS_CACHE_TIMEOUT,
                PVD_REC_WINS_WINS_SERVER};
        return pwsz;
}

SCODE 
CDnsRpcWINS::BuildRpcRecord(
                WORD argc, 
                char** argv)
{
        char* pWinserver = argv[3];

        // if winser string has mutiple server, then change it from 
        // from flat string to array
        int nCount=0;
        char*p = pWinserver;
        while(*p != '\0')
        {
                if(*p != ' ')
                {
                        nCount++;
                        while(*(++p) != ' ' && *p != '\0' );
                }
                else
        {
                        p++;
        }
        }
        if(nCount >1 )
        {
                int nSize = strlen(pWinserver)+1;
                char* pArg = (char*) _alloca(nSize);
                strcpy(pArg, pWinserver);

                // alloc new array
                WORD cNewArray = argc+nCount-1;
                char** pNewArgv = (char**) _alloca(cNewArray*sizeof(char*));
                
                // copy old value first
                for(int i =0; i< argc-1; i++)
                {
                        pNewArgv[i] = (char*) _alloca(sizeof(char) * (strlen(argv[i])+1));
                        strcpy(pNewArgv[i], argv[i]);
                }

                        
                for(; i<cNewArray; i++)
                {
                        if(pArg == NULL || *pArg == '\0')
                                return WBEM_E_INVALID_PARAMETER;
                        pArg = GetNextArg(pArg , &(pNewArgv[i]));
                }
                return CDnsRpcRecord::BuildRpcRecord(cNewArray,
                        pNewArgv);
        }
        return CDnsRpcRecord::BuildRpcRecord(
                argc,
                argv);
}
DWORD
CDnsRpcWINS::GetCacheTimeOut()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINS.dwCacheTimeout;
}

DWORD
CDnsRpcWINS::GetLookupTimeOut()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINS.dwLookupTimeout;
}

DWORD
CDnsRpcWINS::GetMapFlag()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINS.dwMappingFlag;
}

wstring
CDnsRpcWINS::GetWinServer()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        wstring wstrServers;
        for(int i=0; i < pData->WINS.cWinsServerCount; i++)
        {
                wstrServers += IpAddressToString(
                        pData->WINS.aipWinsServers[i]);
                wstrServers +=L" ";
        }
        return L"\"" + wstrServers + L"\"";
}

wstring 
CDnsRpcWINS::GetData(void)
{
        WCHAR temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        swprintf(temp,
                        L"%d %d %d ",
                        pData->WINS.dwMappingFlag,
                        pData->WINS.dwLookupTimeout,
                        pData->WINS.dwCacheTimeout);
        return temp + GetWinServer() ;
}

// CDnsRpcWINSR

CDnsRpcWINSR::~CDnsRpcWINSR()
{
}
CDnsRpcWINSR::CDnsRpcWINSR(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_WINSR;
}

SCODE
CDnsRpcWINSR::ConvertToWbemObject(
        CWbemClassObject& Inst)
{

        Inst.SetProperty(
                GetCacheTimeOut(), 
                PVD_REC_WINSR_CACHE_TIMEOUT);
        Inst.SetProperty(
                GetLookupTimeOut(), 
                PVD_REC_WINSR_TIMEOUT);

        Inst.SetProperty(
                GetMapFlag(), 
                PVD_REC_WINSR_MAPPING_FLAG );

        Inst.SetProperty(
                GetResultDomain(), 
                PVD_REC_WINSR_RESULT_DOMAIN);


        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}

const 
WCHAR**
CDnsRpcWINSR::GetRdataName(void)
{

        static const WCHAR* pwsz[] ={ 
                PVD_REC_WINSR_MAPPING_FLAG,
                PVD_REC_WINSR_TIMEOUT,
                PVD_REC_WINSR_CACHE_TIMEOUT,
                PVD_REC_WINSR_RESULT_DOMAIN};
        return pwsz;
}

DWORD
CDnsRpcWINSR::GetCacheTimeOut()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINSR.dwCacheTimeout;
}

DWORD
CDnsRpcWINSR::GetLookupTimeOut()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINSR.dwLookupTimeout;
}

DWORD
CDnsRpcWINSR::GetMapFlag()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINSR.dwMappingFlag;
}

wstring
CDnsRpcWINSR::GetResultDomain()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        wstring wstrTxt;
        RpcNameCopy(wstrTxt, &(pData->WINSR.nameResultDomain));
        return wstrTxt;
}


wstring 
CDnsRpcWINSR::GetData(void)
{
        WCHAR temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        swprintf(temp,
                        L"%d %d %d ",
                        pData->WINSR.dwMappingFlag,
                        pData->WINSR.dwLookupTimeout,
                        pData->WINSR.dwCacheTimeout);
        return temp + GetResultDomain();
}

// CDnsRpcNULL

CDnsRpcNULL::~CDnsRpcNULL()
{
}
CDnsRpcNULL::CDnsRpcNULL(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_NULL;
}
SCODE
CDnsRpcNULL::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        Inst.SetProperty(
                        GetNullData(), 
                        PVD_REC_NULL_NULLDATA);

        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}

const 
WCHAR**
CDnsRpcNULL::GetRdataName(void)
{
        return NULL;
}

const 
WCHAR**
CDnsRpcA::GetRdataName(void)
{
        static const WCHAR* pwsz[] ={ PVD_REC_A_IP};
        return pwsz;
}

wstring 
CDnsRpcNULL::GetData(void)
{
        return GetNullData();
}

wstring 
CDnsRpcNULL::GetNullData(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        WCHAR temp[1000];
        WCHAR* pos = temp;
        for(int i=0; i < m_pRecord->wDataLength; i++)
        {
                swprintf(pos++,L"%c",pData->Null.bData[i]);
        }
        return temp;
}

SCODE
CDnsRpcNULL::Init(
                wstring& wstrClass,
                string& strOwner, 
                string& strRdata,
                CWbemClassObject& pInst
                )
{
        return WBEM_E_NOT_SUPPORTED;
}
SCODE 
CDnsRpcNULL::Init(
        string& strOwner,
        string& strRdata, 
        DWORD dwTtl)
{
        return WBEM_E_NOT_SUPPORTED;
}


// CDnsRpcATMA

CDnsRpcATMA::~CDnsRpcATMA()
{
}
CDnsRpcATMA::CDnsRpcATMA(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_ATMA;
}
SCODE
CDnsRpcATMA::ConvertToWbemObject(
        CWbemClassObject& Inst)
{

    Inst.SetProperty(
                        GetFormat(), 
                        PVD_REC_ATMA_FORMAT);
        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}


wstring 
CDnsRpcATMA::GetData(void)
{
        WCHAR temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        swprintf(temp,
                        L" %d ",
                        pData->ATMA.chFormat);
        return temp + GetAddress();
}

DWORD
CDnsRpcATMA::GetFormat(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->ATMA.chFormat;
}

wstring
CDnsRpcATMA::GetAddress()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        char temp[MAX_PATH];
        WORD wLength = m_pRecord->wDataLength -
                sizeof(pData->ATMA.chFormat)-1;
        UCHAR* p = &pData->ATMA.bAddress[1]; //ignore the first
        for(WORD i=0; i< wLength; i++)
        {
                temp[i] = *p++;
        }
        temp[i]='\0';
        wstring wstr = CharToWstring(temp, wLength);
        return wstr;
}

const 
WCHAR**
CDnsRpcATMA::GetRdataName(void)
{

        return NULL;
}

SCODE
CDnsRpcATMA::Init(
                wstring& wstrClass,
                string& strOwner, 
                string& strRdata,
                CWbemClassObject& pInst
                )
{
        return WBEM_E_NOT_SUPPORTED;
}
SCODE 
CDnsRpcATMA::Init(
        string& strOwner,
        string& strRdata, 
        DWORD dwTtl)
{
        return WBEM_E_NOT_SUPPORTED;
}




//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsRpcRecordSet::~CDnsRpcRecordSet()
{
        DnssrvFreeRecordsBuffer(m_pbStart);
}
CDnsRpcRecordSet::CDnsRpcRecordSet(
        CDomainNode& DomainNode,
        WORD wType,
        DWORD dwFlag,
        LPCSTR pszFilterStart,
        LPCSTR pszFilterStop
        )
        :m_pbStart(NULL),m_pbCurrent(NULL),m_pbStop(NULL),
        m_pbPrevious(NULL), m_bMoreData(FALSE)
{
        // remember query
        WcharToString(DomainNode.wstrZoneName.data(), m_strZone);
        WcharToString(DomainNode.wstrNodeName.data(), m_strNode);
        WcharToString(DomainNode.wstrChildName.data(), m_strStartChild);
        m_wType = wType;
        m_dwFlag = dwFlag;
        if(pszFilterStart)
                m_strFilterStart = pszFilterStart;
        if(pszFilterStop)
                m_strFilterStop = pszFilterStop;

        // make query 
        GetRecordSet();
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              a helper function when first called, it returns a block of rpc memory
//      of the record set. when more data follows, the next call release this 
//      memory block and then bring in next rpc memory block for the remaining 
//      records
//
//      Arguments:
//      wType               [IN]    type indicating the type of record
//      pptr                [OUT]   a pointer to base record class.
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

void
CDnsRpcRecordSet::GetRecordSet()
{
        DNS_STATUS              status = ERROR_SUCCESS;
    DWORD           dwBufferLength;
    PBYTE           pBuffer;
        WORD wRetryTime=1, wRetryMax=3;
        
        while(TRUE)
        {
                status = DnssrvEnumRecords(
                        PVD_DNS_LOCAL_SERVER,
                        m_strZone.empty() ? NULL : m_strZone.data(),
                        m_strNode.empty() ? "@" : m_strNode.data(),
                        m_strStartChild.empty() ? NULL : m_strStartChild.data(),
                        m_wType,
                        m_dwFlag,
                        m_strFilterStart.data(),
                        m_strFilterStop.data(),
                        &dwBufferLength,
                        &pBuffer);
                wRetryTime++;
                if( status == RPC_S_SERVER_TOO_BUSY && wRetryTime <= wRetryMax)
        {
                        Sleep(2000);
        }
                else
        {
            break;
        }
        }
        if( status == ERROR_SUCCESS || status == ERROR_MORE_DATA)
        {
                //let's free the record set
                if(m_pbStart != NULL)
                {
                        DnssrvFreeRecordsBuffer(m_pbStart);
                }
        // set beginning pointer to the rpc buffer
                m_pbStart = pBuffer;
                m_pbStop = m_pbStart + dwBufferLength;
                m_bMoreData = (status == ERROR_MORE_DATA);
        }
    //
    // we don't throw exeception if zone is shutdown.
    //
        else if(status == DNS_ERROR_NAME_DOES_NOT_EXIST)
        {
                DNS_STATUS CheckZoneStatus;
                PDNS_RPC_ZONE_INFO pZoneInfo=NULL;

                CheckZoneStatus = DnssrvGetZoneInfo(
                        PVD_DNS_LOCAL_SERVER,
                        m_strZone.data(),
                        &pZoneInfo );

                BOOL bShutDown=TRUE;
                if( CheckZoneStatus == ERROR_SUCCESS)
                {
                        // if zone is shutdown, ignor this zone, continue with the 
                        // rest zones
                        bShutDown = pZoneInfo->fShutdown;       
                }
        
        

                //clean up
                DnssrvFreeZoneInfo(pZoneInfo);

                if( CheckZoneStatus != ERROR_SUCCESS || bShutDown == FALSE )
                {
                        CDnsWrap::ThrowException(status);
                }


        }
        else
                CDnsWrap::ThrowException(status);
        return;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              return the next node in the record set
//
//      Arguments:
//      wType               [IN]    type indicating the type of record
//      pptr                [OUT]   a pointer to base record class.
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

const 
PDNS_RPC_NODE 
CDnsRpcRecordSet::GetNextNode()
{
        if (m_pbCurrent >= m_pbStop)
    {
                return NULL;
    }
        //return first node if current is NULL
        // otherwise, return the node follows the current
        if (m_pbCurrent == NULL)
        {
                m_pbCurrent = m_pbStart;
        }
        else
        {
                m_pbPrevious = m_pbCurrent;
                m_pbCurrent = IncrementPtrByNodeHead(m_pbCurrent);
                while (m_cRecord -- > 0)
                {
                        m_pbCurrent = IncrementPtrByRecord(m_pbCurrent);
                }
        }
        
        if (m_pbCurrent >= m_pbStop)
        {
                // prepare another query if there are more data
                if(m_bMoreData)
                {
                        PDNS_RPC_NODE pNode = (PDNS_RPC_NODE)m_pbPrevious;
                        WORD wSize = pNode->dnsNodeName.cchNameLength;
                        PCHAR p = new CHAR[wSize+1];
                        if ( !p )
                        {
                            return NULL;
                        }
                        strncpy(p,
                                pNode->dnsNodeName.achName, 
                                wSize);
                        *(p+wSize) = '\0';
                        m_strStartChild = p;
                        delete [] p;
                        // query again
                        GetRecordSet();
                        // skip the first record, since it's the last record in 
            // previous rpc buffer and it's already handled
                        m_pbCurrent = m_pbStart;
                        m_cRecord = ((PDNS_RPC_NODE)m_pbCurrent)->wRecordCount;
                        return GetNextNode();
                }
                else
        {
                        return NULL;
        }
        }
        else
        {
                m_cRecord = ((PDNS_RPC_NODE)m_pbCurrent)->wRecordCount;
                return (PDNS_RPC_NODE) m_pbCurrent;
        }

}

BOOL 
CDnsRpcRecordSet::IsDomainNode()
{
        return (m_cRecord == 0);
}

//class defination for CDnsRpcNode

CDnsRpcNode::~CDnsRpcNode()
{
}
CDnsRpcNode::CDnsRpcNode()
{
}


BOOL 
CDnsRpcNode::Init(
        PDNS_RPC_NODE pNode)
{
        if(!pNode)
    {
                return FALSE;
    }
        m_pNode = pNode;
        m_cRecord = m_pNode->wRecordCount;
        m_Index = 0;
        m_pCurrent = NULL;
        
        PDNS_RPC_NAME pName = &(m_pNode->dnsNodeName);
        m_wstrNodeName = CharToWstring(
                pName->achName, 
                (WORD)pName->cchNameLength);
        return TRUE;
}

BOOL 
CDnsRpcNode::IsDomainNode()
{
        return ( m_cRecord == 0 && m_Index ==0 && !m_wstrNodeName.empty());
        
}
wstring 
CDnsRpcNode::GetNodeName()
{
        return  m_wstrNodeName;
}

CDnsRpcRecord* 
CDnsRpcNode::GetNextRecord()
{
        if(m_cRecord == 0 || m_pNode == NULL)
    {
        return NULL;
    }

        CDnsRpcRecord * pRec = NULL;
        if (m_Index < m_cRecord )
        {
                if(m_Index ++ == 0)
        {
            m_pCurrent = IncrementPtrByNodeHead((PBYTE)m_pNode);
        }
                else
        {
            m_pCurrent = IncrementPtrByRecord((PBYTE) m_pCurrent);
        }
                
                SCODE sc = CDnsRpcRecord::CreateClass(
                        ((PDNS_RPC_RECORD)m_pCurrent)->wType, 
                        (PVOID*) &pRec
                        );
                if ( SUCCEEDED ( sc ) && pRec )
                {
                        pRec->Init( (PDNS_RPC_RECORD)m_pCurrent);
                        return pRec;
                }
                else
        {
                        return NULL;
        }
        }
        else
    {
                return NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              build a rpc record based on rdata arguments
//
//      Arguments:
//      argc                [IN]    number of argument in argv
//      argv                [IN]    array of string represent 
//
//      Return Value:
//              WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::BuildRpcRecord(
        WORD    argc, 
        char ** argv)
{

        PDNS_RECORD pdnsRecord;
        pdnsRecord = Dns_RecordBuild_A(
                NULL,           // ptr to RRSet
                (char*) m_strOwnerName.data(), //NULL, //(char*) strFQDN.data(),    // nameOwner
                m_wType,          // RR type in WORD
                TRUE,           // add record
                0,              // S.section
                argc,           // count of strings
                argv                    // strings to fill into RR
                );
    if ( ! pdnsRecord )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //  convert DNS_RECORD to RPC buffer

    m_pRecord = DnsConvertRecordToRpcBuffer( pdnsRecord );
    m_pRecordRequiresFree = TRUE;
    if ( ! m_pRecord )
    {
        return WBEM_E_FAILED;
    }

        if( m_dwTtl != 0)
        {
                m_pRecord->dwTtlSeconds = m_dwTtl;
                m_pRecord->dwFlags = DNS_RPC_RECORD_FLAG_TTL_CHANGE;
        }
        else
    {
                m_pRecord->dwFlags = DNS_RPC_RECORD_FLAG_DEFAULT_TTL;
    }
        return WBEM_S_NO_ERROR;

}

wstring CDnsRpcRecord::GetTypeString()
{
    if(m_pRecord==NULL)
    {
        return CharToWstring( NULL, 0 );
    }
    PCHAR pszType = Dns_RecordStringForType( m_pRecord->wType );
    return CharToWstring(pszType, strlen(pszType));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsrpcrecord.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		Dnsrpcrecord.h
//
//	Implementation File:
//		Dnsrpcrecord.cpp
//
//	Description:
//		Definition of the dns rpc record related class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsclip.h"
#include "common.h"

#ifndef DNS_WINSOCK2

#define DNS_WINSOCK_VERSION (0x0101)    //  Winsock 1.1

#else   // Winsock2

#define DNS_WINSOCK_VERSION (0x0002)    //  Winsock 2.0

#endif
  
class CDnsRpcRecord ;
class CWbemClassObject;
/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsRpcMemory
//
//	Description:
//      Define common pointer increment operation in memory block that's 
//      returned from dns rpc call
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsRpcMemory
{
public:
	CDnsRpcMemory();
	virtual ~CDnsRpcMemory();
	PBYTE IncrementPtrByRecord(PBYTE);
	PBYTE IncrementPtrByNodeHead(PBYTE);
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsRpcNode
//
//	Description:
//      represents a dns rpc node structure and related operations
//  
//
//	Inheritance:
//	    CDnsRpcMemory
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsRpcNode : public CDnsRpcMemory
{
public:  
	CDnsRpcNode();
	~CDnsRpcNode();
	BOOL Init(PDNS_RPC_NODE);
	BOOL IsDomainNode();
	CDnsRpcRecord* GetNextRecord();
	wstring GetNodeName();
protected:
	wstring m_wstrNodeName;
	PBYTE m_pCurrent;
	PDNS_RPC_NODE m_pNode;
	WORD m_cRecord;
	WORD m_Index;
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsRpcNode
//
//	Description:
//      base class for all concrete dns record type such A, SOA. defines operation and 
//      data member common to concrete record type
//  
//
//	Inheritance:
//	    CDnsRpcMemory
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsRpcRecord 
{

public:
	enum ActionType               
	{
	   AddRecord,
	   DeleteRecord
	} ;                

    CDnsRpcRecord( WORD wRdataSize );
    virtual ~CDnsRpcRecord();

    wstring GetTypeString();
	BOOL Init(
		PDNS_RPC_RECORD pRecord
		);
	wstring GetClass(
		void
		) {return L"IN";};
	WORD    GetType() ;
	DWORD	GetTtl();
	char* GetNextArg(
	    char *  pszIn, 
	    char ** ppszOut
        );
    static BOOL RpcNameCopy(
	    wstring&        wstrTarget, 
	    PDNS_RPC_NAME   pName
        );
	SCODE SendToServer(
	    const char* szContainerName,
	    ActionType Type 
		);
	BOOL RdataIsChanged();
	virtual SCODE ConvertToWbemObject(
		CWbemClassObject& Inst
		);
	virtual SCODE Init(
		string&, 
		string&,
		DWORD =0
		);
	virtual SCODE Init(
	    wstring&            wstrClass,
	    string&             strOwner,
	    string&             strRdata,
	    CWbemClassObject&   Inst
		);
	virtual SCODE GetObjectPath(
	    wstring     wstrServer,
	    wstring     wstrZone,
	    wstring     wstrDomain,
	    wstring     wstrOwner,
	    CObjPath&   objOP
		);
	virtual wstring GetTextRepresentation(
		wstring wstrNodeName
		);
	virtual wstring GetData(
		void
		) {return L"";};
	static SCODE CreateClass(
	    WORD        wType,
	    PVOID *     pptr
		);

protected:

	virtual const WCHAR** GetRdataName(void){return (const WCHAR**)NULL;};
	SCODE ParseRdata(
	    string& strRdata,
	    WORD    wSize
		);
	virtual SCODE BuildRpcRecord(
        WORD argc, 
        char ** argv
        );
	virtual wstring GetRecDomain(
	    wstring wstrZone,
	    wstring wstrDomain,
	    wstring wstrOwner
        );
    SCODE ReplaceRdata(
        WORD                wIndex,   // index for m_ppRdata
        const WCHAR*        pwsz,   // Name for Rdata field
        CWbemClassObject&   Inst 
        );

	//member data
	BOOL	m_bRdataChange;
	string	m_strOwnerName;		//record owner name
	WORD	m_wType;			// record type
	DWORD	m_dwTtl;			// time to live
    WORD	m_cRdata;
	char**	m_ppRdata;			// Rdata pointer;
    const WCHAR* m_pwszClassName;
    PDNS_RPC_RECORD m_pRecord;	
    BOOL    m_pRecordRequiresFree;  //  m_pRecord is allocated?
	
};

/* for record type
	DNS_TYPE_SOA
*/

class CDnsRpcSOA : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 7};
public:
	CDnsRpcSOA(WORD);
	~CDnsRpcSOA();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	DWORD GetSerialNo();
	DWORD GetRefresh();
	DWORD GetRetry();
	DWORD GetExpire();
	DWORD GetMinimumTtl();
	const WCHAR** GetRdataName();
	wstring GetPrimaryServer(void);
	wstring GetResponsible(void);
	SCODE BuildRpcRecord(
		WORD, 
		char** );

};

/* for record type
	DNS_TYPE_A
*/
class CDnsRpcA : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 1};
public:
	~CDnsRpcA();
	CDnsRpcA(WORD);
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	const WCHAR** GetRdataName(void);
	wstring GetIP(void);
}
;

/* for record type
	DNS_TYPE_PTR
    DNS_TYPE_NS
    DNS_TYPE_CNAME
    DNS_TYPE_MD
    DNS_TYPE_MB
    DNS_TYPE_MF
    DNS_TYPE_MG
    DNS_TYPE_MR
*/
class CDnsRpcNS : public  CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 1};
public:
	CDnsRpcNS(WORD);
	~CDnsRpcNS();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	wstring GetNodeName();
	SCODE BuildRpcRecord(
		WORD, 
		char**);
	wstring GetRecDomain(
		wstring ,
		wstring ,
		wstring );
	const WCHAR** GetRdataName();

};

/* for record type
	DNS_TYPE_RT
    DNS_TYPE_AFSDB
*/
class CDnsRpcMX : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 2};
public:

	CDnsRpcMX(WORD);
	~CDnsRpcMX();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	wstring GetNodeName();
	DWORD GetPreference();
	const WCHAR** GetRdataName();

};

/* for record type
	DNS_TYPE_MINFO
    DNS_TYPE_RP

*/
class CDnsRpcMINFO : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 2};
public:
	CDnsRpcMINFO(WORD);
	~CDnsRpcMINFO();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	wstring GetRPMailBox();
	wstring GetErrMailBox();
	const WCHAR** GetRdataName();
};

/* for record type
	DNS_TYPE_AAAA
*/
class CDnsRpcAAAA : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 1};
public:
	CDnsRpcAAAA(WORD);
	~CDnsRpcAAAA();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	wstring GetIP(void);
	const WCHAR** GetRdataName();

};

/* for record type
	DNS_TYPE_HINFO:
	DNS_TYPE_ISDN:
	DNS_TYPE_X25:
	DNS_TYPE_TEXT
*/
class CDnsRpcTXT : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA_TXT=1,
		NUM_OF_ARG_IN_RDATA_HINFO = 2
		};
public:
	CDnsRpcTXT(WORD);
	~CDnsRpcTXT();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetTextRepresentation(
		wstring
		);
	wstring GetData(void);
protected:
	wstring GetString1(void);
	wstring GetString2(void);
	const WCHAR** GetRdataName();
};
/* for record type
	DNS_TYPE_WKS
*/
class CDnsRpcWKS : CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 3};
public:
	CDnsRpcWKS(WORD);
	~CDnsRpcWKS();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	wstring GetIP(void);
	wstring GetIPProtocal(void);
	wstring GetServices(void);
	const WCHAR** GetRdataName();
};

/* for record type
	DNS_TYPE_SRV
*/
class CDnsRpcSRV : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 4};
public:
	CDnsRpcSRV(WORD);
	~CDnsRpcSRV();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	DWORD GetPriority(void);
	DWORD GetWeight(void);
	DWORD GetPort(void);
	wstring GetDomainName(void);
	const WCHAR** GetRdataName();

};

/* for record type
	DNS_TYPE_WINS
*/
class CDnsRpcWINS : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 4};
public:

	CDnsRpcWINS(WORD);
	~CDnsRpcWINS();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	DWORD GetMapFlag(void);
	DWORD GetLookupTimeOut(void);
	DWORD GetCacheTimeOut(void);
	wstring GetWinServer(void);
	const WCHAR** GetRdataName();
	SCODE BuildRpcRecord(
		WORD, 
		char**);
};
/* for record type
	DNS_TYPE_WINSR
*/
class CDnsRpcWINSR : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 4};
public:

	CDnsRpcWINSR(WORD);
	~CDnsRpcWINSR();

	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	DWORD GetMapFlag(void);
	DWORD GetLookupTimeOut(void);
	DWORD GetCacheTimeOut(void);
	wstring GetResultDomain(void);
	const WCHAR** GetRdataName();
};

/* DNS_TYPE_NULL
*/
class CDnsRpcNULL: public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 1};
public:
	CDnsRpcNULL(WORD);
	~CDnsRpcNULL();
	SCODE Init(
		string&, 
		string&,
		DWORD 
		);
	SCODE Init(
		wstring&,
		string&, 
		string&,
		CWbemClassObject&
		);

	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);

protected:
	wstring GetNullData(void);
	const WCHAR** GetRdataName();
};

class CDnsRpcATMA : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 2};
public:
	CDnsRpcATMA(WORD);
	~CDnsRpcATMA();
	SCODE Init(
		string&, 
		string&,
		DWORD =0
		);
	SCODE Init(
		wstring&,
		string&, 
		string&,
		CWbemClassObject&
		);

	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	DWORD GetFormat(void);
	wstring GetAddress(void);
	const WCHAR** GetRdataName();

};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsRpcNode
//
//	Description:
//      a recordset are collection of records can be returned for a query. 
//      when number of records are too large( eg error more data), mutiple
//      rpc call has to make to bring back all record. this class manage this
//      and retrieve nodes from the set 
//  
//
//	Inheritance:
//	    CDnsRpcMemory
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsRpcRecordSet : public CDnsRpcMemory
{

public:
	BOOL IsDomainNode();
	const PDNS_RPC_NODE GetNextNode();
	CDnsRpcRecordSet(
		CDomainNode&,
		WORD wType,
		DWORD dwFlag,
		LPCSTR pszFilterStart,
		LPCSTR pszFilterStop
		);
	~CDnsRpcRecordSet();

protected:
	void GetRecordSet();
	DWORD	m_cRecord;		//number of records in a node	
	PBYTE	m_pbPrevious;	
	PBYTE	m_pbCurrent;	// current node
	PBYTE	m_pbStop;		// end position
	PBYTE	m_pbStart;		// start position

	string	m_strZone;		
	string	m_strNode;
	string	m_strStartChild;
	string	m_strFilterStart;
	string	m_strFilterStop	;	
	WORD  m_wType;			// record type
	DWORD m_dwFlag;			
	BOOL  m_bMoreData;		//more data indicator
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsstatistics.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: DnsStatistics.cpp
//
//  Description:    
//      Implementation of CDnsStatistic class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsStatistic::CreateThis(
    const WCHAR *       wszName,         //class name
    CWbemServices *     pNamespace,  //namespace
    const char *        szType         //str type id
    )
{
    return new CDnsStatistic(wszName, pNamespace);
}

CDnsStatistic::CDnsStatistic()
{
}

CDnsStatistic::CDnsStatistic(
    const WCHAR* wszName,
    CWbemServices *pNamespace ) :
    CDnsBase( wszName, pNamespace )
{
}

CDnsStatistic::~CDnsStatistic()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CDnsStatistic::EnumInstance
//
//    Description:
//        Enum instances of statistics
//
//    Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsStatistic::EnumInstance(
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pHandler )
{
    SCODE       sc = S_OK;

    CDnsWrap & dns = CDnsWrap::DnsObject();

    sc = dns.dnsGetStatistics( m_pClass, pHandler );

    return sc;
}   //  CDnsStatistic::EnumInstance


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CDnsStatistic::GetObject
//
//    Description:
//        retrieve cache object based given object path
//
//    Arguments:
//      ObjectPath          [IN]    object path to cluster object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsStatistic::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler)
{
    return WBEM_E_NOT_SUPPORTED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CDnsStatistic::ExecuteMethod
//
//    Description:
//        execute methods defined for cache class in the mof 
//
//    Arguments:
//      ObjectPath          [IN]    object path to cluster object
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsStatistic::ExecuteMethod(
    CObjPath &          objPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
    return WBEM_E_NOT_SUPPORTED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CDnsStatistic::PutInstance
//
//    Description:
//        save this instance
//
//    Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsStatistic::PutInstance(
    IWbemClassObject *  pInst ,
    long                lFlags,
    IWbemContext*       pCtx ,
    IWbemObjectSink *   pHandler)
{
    return WBEM_E_NOT_SUPPORTED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CDnsStatistic::DeleteInstance
//
//    Description:
//        delete the object specified in rObjPath
//
//    Arguments:
//      rObjPath            [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsStatistic::DeleteInstance( 
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pResponseHandler )
{
    return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsserverdomaincontainment.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsdomanidomaincontainment.h
//
//	Implementation File:
//		dnsdomanidomaincontainment.cpp
//
//	Description:
//		Definition of the CDnsDomainDomainContainment class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"
class CObjPath;


class CDnsServerDomainContainment : CDnsBase 
{
public:
	CDnsServerDomainContainment();
	CDnsServerDomainContainment(
		const WCHAR*,
		CWbemServices*
		);
	~CDnsServerDomainContainment();
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;
    static CDnsBase* CreateThis(
        const WCHAR *       wszName,        
        CWbemServices *     pNamespace,  
        const char *        szType       
        );




};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnswrap.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: DnsWrap.cpp
//
//  Description:    
//      Implementation of dnswrap class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//
//  These string tables are in client\print.c
//

extern "C" LPSTR   MemTagStringsNT5[];
extern "C" LPSTR   MemTagStrings[];


//
//  These macros allow us to widen DNS RPC string constants.
//

#define MYTEXT2(str)     L##str
#define MYTEXT(str)      MYTEXT2(str)


//
//  Globals for statistics.
//

struct
{
    DWORD                   dwStatId;
    const WCHAR *           pszName;
} g_StatInfo[] =
{
    {   DNSSRV_STATID_TIME,             L"Time Stats" },
    {   DNSSRV_STATID_QUERY,            L"Query and Response Stats" },
    {   DNSSRV_STATID_QUERY2,           L"Query Stats" },
    {   DNSSRV_STATID_RECURSE,          L"Recursion Stats" },
    {   DNSSRV_STATID_MASTER,           L"Master Stats" },
    {   DNSSRV_STATID_SECONDARY,        L"Secondary Stats" },
    {   DNSSRV_STATID_WINS,             L"WINS Referral Stats" },
    {   DNSSRV_STATID_WIRE_UPDATE,      L"Packet Dynamic Update Stats" },
    {   DNSSRV_STATID_SKWANSEC,         L"Security Stats" },
    {   DNSSRV_STATID_DS,               L"DS Integration Stats" },
    {   DNSSRV_STATID_NONWIRE_UPDATE,   L"Internal Dynamic Update Stats" },
    {   DNSSRV_STATID_MEMORY,           L"Memory Stats" },
    {   DNSSRV_STATID_DBASE,            L"Database Stats" },
    {   DNSSRV_STATID_RECORD,           L"Record Stats" },
    {   DNSSRV_STATID_PACKET,           L"Packet Memory Usage Stats" },
    {   DNSSRV_STATID_NBSTAT,           L"Nbstat Memory Usage Stats" },
    {   DNSSRV_STATID_ERRORS,           L"Error Stats" },
    {   DNSSRV_STATID_TIMEOUT,          L"Timeout Stats" },
    {   DNSSRV_STATID_CACHE,            L"Query" },
    {   DNSSRV_STATID_PRIVATE,          L"Private Stats" },
    {   0,                              NULL }              //  terminator
};


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CDnsWrap::CDnsWrap()
:m_wszpServerName(NULL)
{
    CServerInfo serverInfo;
    PDNS_RPC_SERVER_INFO pdata = (PDNS_RPC_SERVER_INFO) serverInfo.m_pInfo;
    char* p = pdata->pszServerName;
    CharToWchar(p, &m_wszpServerName);
}


CDnsWrap::~CDnsWrap()
{
    delete [] m_wszpServerName;
}


CDnsWrap::CServerInfo::CServerInfo()
:m_pInfo(NULL)
{
    DWORD       dwtypeid;
    int status = DnssrvQuery(
        PVD_DNS_LOCAL_SERVER, 
        NULL,
        DNSSRV_QUERY_SERVER_INFO,
        &dwtypeid,
        &m_pInfo);
    
    if(status != ERROR_SUCCESS)
        ThrowException(status);
}


CDnsWrap::CServerInfo::~CServerInfo()
{
    DnssrvFreeServerInfo((PDNS_RPC_SERVER_INFO)m_pInfo);
}


CDnsWrap& CDnsWrap::DnsObject(void)
{
    static CDnsWrap dns;
    return dns;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enumerates record for a give domain. If bRecursive is true, enum all 
//      records including subdomain, otherwise, enum records directly under
//      the domain. It also take a call back function pFilter to allow
//      further filtering the records 
//
//    Arguments:
//      objNode             [IN ]   list of domains
//      pFilter             [IN]    pointer a class contains the criteria
//                                  on how to filter records
//        pfFilter            [IN]    call back function allows further 
//                                  processing of records using pFilter
//      bRecursive          [IN]    true for deep enum, otherwise false
//      wType,              [IN]    type of records to enum
//      dwFlag,             [IN]    flag
//      pClass,             [IN]    wmi class for the type of records to enum
//      InstMgr             [IN]    manage wmi object and send them wmi

//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsWrap::dnsEnumRecordsForDomainEx(    
    CDomainNode&        objNode,
    PVOID                pFilter,
    FILTER              pfFilter,
    BOOL                bRecursive,
    WORD                wType,
    DWORD               dwFlag,
    IWbemClassObject *  pClass,
    CWbemInstanceMgr&   InstMgr
    )
{
    
    CDnsRpcRecordSet RecordSet(
            objNode,
            wType,
            dwFlag,
            NULL,
            NULL);
    PDNS_RPC_NODE pNode=NULL;
    WCHAR DomainName[MAX_PATH] = L"";
    while (( pNode = RecordSet.GetNextNode()) != NULL)
    {
        CDnsRpcNode dnsNode;
        CObjPath opNew;
        if( !dnsNode.Init(pNode))
        {
                return WBEM_E_FAILED;
        }
        //find record node
        if(dnsNode.IsDomainNode())
        {
            
            // get domain name
            wstring wstrSubDomainName = dnsNode.GetNodeName();;
            wstrSubDomainName += PVD_DNS_LOCAL_SERVER + objNode.wstrNodeName;
            CDomainNode subDomain = objNode;
            subDomain.wstrNodeName = wstrSubDomainName;

            //recursion
            if(bRecursive)
            {
                dnsEnumRecordsForDomainEx(
                    subDomain,
                    pFilter, 
                    pfFilter,
                    bRecursive,
                    wType,
                    dwFlag,
                    pClass,
                    InstMgr);
                    
            }
        }

        pfFilter(
            objNode, 
            pFilter, 
            &dnsNode,  
            pClass, 
            InstMgr);
        }
                
    return WBEM_S_NO_ERROR;
}

SCODE 
CDnsWrap::dnsGetDomain(
    CObjPath&           objParent,
    IWbemClassObject*   pClass,
    IWbemObjectSink*    pHandler
    )
{

    // get top level domain
    wstring wstrZoneName = objParent.GetStringValueForProperty(
        PVD_DOMAIN_CONTAINER_NAME);
    wstring wstrNodeName = objParent.GetStringValueForProperty(
        PVD_DOMAIN_FQDN);
    list<CDomainNode> nodeList;
    dnsEnumDomainForServer(&nodeList);
    list<CDomainNode>::iterator i;
    BOOL FoundFlag = FALSE;
    // check for zone
    for(i=nodeList.begin(); i != nodeList.end(); ++i)
    {
        if(_wcsicmp(
            wstrZoneName.data(),
            i->wstrZoneName.data()) == 0 )
        {
            // only roothints and catch, NodeName is initialize to
            // nil, we can't do the compare 
            if(i->wstrNodeName.empty() ||
                (_wcsicmp(
                wstrNodeName.data(), 
                i->wstrNodeName.data())==0))
            {
                FoundFlag = TRUE;
                break;
            }
        }
    }

    // check for domain in container
    if(! FoundFlag)
    {
        DNS_STATUS status ;
        char    *pszZoneName=NULL, *pszNodeName=NULL, *pszStartChild=NULL;
        DWORD   dwBufferLength;
        PBYTE       pBuffer = NULL;
    

        WcharToChar(wstrZoneName.data(), &pszZoneName);
        WcharToChar(wstrNodeName.data(), &pszNodeName);

        status = DnssrvEnumRecords(
            PVD_DNS_LOCAL_SERVER,
            pszZoneName,
            pszNodeName,
            pszStartChild,
            DNS_TYPE_ALL,
            DNS_RPC_VIEW_ALL_DATA,
            NULL,
            NULL,
            & dwBufferLength,
            & pBuffer);
        delete [] pszNodeName;
        delete [] pszZoneName;
        DnssrvFreeRecordsBuffer(pBuffer);

        if (status != ERROR_SUCCESS)
            ThrowException(status);
        FoundFlag = TRUE;
    }

    if(FoundFlag)
    {

        CWbemClassObject Inst;
        pClass->SpawnInstance(0, &Inst);
        Inst.SetProperty(
            wstrNodeName, 
            PVD_DOMAIN_FQDN);
        Inst.SetProperty(
            wstrZoneName, 
            PVD_DOMAIN_CONTAINER_NAME);
        Inst.SetProperty(
            m_wszpServerName,
            PVD_DOMAIN_SERVER_NAME);

        // clean up
        pHandler->Indicate(1, &Inst);
    }

    return WBEM_S_NO_ERROR;

}
SCODE 
CDnsWrap::dnsDeleteDomain(
    char *  pszContainer, 
    char *  pszDomain
    )
{
     LONG status = DnssrvDeleteNode(
        PVD_DNS_LOCAL_SERVER,
        pszContainer,
        pszDomain,
        1 //fDeleteSubtree
        );
    if ( status != ERROR_SUCCESS )
    {
        ThrowException(status);
    }
    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enumeratr all zones including cache for local dns server, returns
//      them as a list of object path
//
//    Arguments:
//      pList               [IN OUT]    list of object path to domains
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsWrap::dnsEnumDomainForServer(
    list<CObjPath>* pList
    )
{

    PDNS_RPC_ZONE_LIST  pZoneList = NULL;
    DNS_STATUS status = DnssrvEnumZones(
        PVD_DNS_LOCAL_SERVER,
        ZONE_REQUEST_ALL_ZONES_AND_CACHE,
        NULL,
        &pZoneList);

    if(status == ERROR_SUCCESS)
    {
        DNS_RPC_ZONE* pDnsZone = NULL;
        CDnsWrap& dns = CDnsWrap::DnsObject();
        for(DWORD i = 0; i < pZoneList->dwZoneCount; i++)
        {
            pDnsZone = (pZoneList->ZoneArray[i]);
            if(_wcsicmp(pDnsZone->pszZoneName, PVD_DNS_LOCAL_SERVER))
            {
                CObjPath opInst;
                opInst.SetClass(PVD_CLASS_DOMAIN);
                opInst.AddProperty(
                    PVD_DOMAIN_SERVER_NAME ,
                    dns.GetServerName().data()
                    );
                opInst.AddProperty(
                    PVD_DOMAIN_CONTAINER_NAME, 
                    pDnsZone->pszZoneName
                    );
                opInst.AddProperty(
                    PVD_DOMAIN_FQDN, 
                    pDnsZone->pszZoneName
                    );
            
                pList->insert(
                    pList->end(),
                    opInst);
            }
        }
        
        // add catch domain
        CObjPath opCache;
        opCache.SetClass(PVD_CLASS_DOMAIN);
        opCache.AddProperty(
            PVD_DOMAIN_SERVER_NAME,
            dns.GetServerName().data()
            );
        opCache.AddProperty(
            PVD_DOMAIN_CONTAINER_NAME,
            PVD_DNS_CACHE
            );
        opCache.AddProperty(
            PVD_DOMAIN_FQDN,
            PVD_DNS_CACHE
            );

        //add roothints 
        CObjPath opRh;
        opRh.SetClass(PVD_CLASS_DOMAIN);
        opRh.AddProperty(
            PVD_DOMAIN_SERVER_NAME, 
            dns.GetServerName().data()
            );
        opRh.AddProperty(
            PVD_DOMAIN_CONTAINER_NAME, 
            PVD_DNS_ROOTHINTS
            );
        opRh.AddProperty(
            PVD_DOMAIN_FQDN, 
            PVD_DNS_ROOTHINTS
            );

        pList->insert(pList->begin(), opRh);    
        pList->insert(pList->begin(), opCache);    
    }

    // CLEAN UP
    DnssrvFreeZoneList(pZoneList);
    
    if(status != ERROR_SUCCESS)
    {
        ThrowException(status);
    }

    return WBEM_S_NO_ERROR;

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enumeratr all zones including cache for local dns server, returns
//      them as a list of domain node
//
//    Arguments:
//      pList               [IN OUT]    list of domains
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsWrap::dnsEnumDomainForServer(
    list<CDomainNode>* pList
    )
{

    PDNS_RPC_ZONE_LIST  pZoneList = NULL;
    LONG status = DnssrvEnumZones(
        PVD_DNS_LOCAL_SERVER,
        ZONE_REQUEST_ALL_ZONES_AND_CACHE,
        NULL,
        &pZoneList);

    DNS_RPC_ZONE * pDnsZone = NULL;
    if( status == ERROR_SUCCESS && pZoneList )
    {

        for(DWORD i = 0; i < pZoneList->dwZoneCount; i++)
        {
            pDnsZone = (pZoneList->ZoneArray[i]);
            if(_wcsicmp(pDnsZone->pszZoneName, L"."))
            {
                CDomainNode objNode;
                objNode.wstrNodeName = pDnsZone->pszZoneName;
                objNode.wstrZoneName = pDnsZone->pszZoneName;
                pList->insert(pList->end(), objNode);
            }
        }
        
        // add catch domain
        CDomainNode nodeCache;

        nodeCache.wstrZoneName = PVD_DNS_CACHE;
        //add roothints 
        CDomainNode nodeRH;
        nodeRH.wstrZoneName = PVD_DNS_ROOTHINTS;
        

        pList->insert(pList->begin(), nodeCache);    
        pList->insert(pList->begin(), nodeRH);    
    
    }

    // CLEAN UP
    DnssrvFreeZoneList(pZoneList);
    
    if (status != ERROR_SUCCESS)
    {
        ThrowException(status);
    }

    return WBEM_S_NO_ERROR;

}


SCODE 
CDnsWrap::ValidateServerName(
    const WCHAR* pwzStr)
{
    if(_wcsicmp(pwzStr, PVD_DNS_LOCAL_SERVER))
        if(_wcsicmp(pwzStr, L"127.0.0.1"))
            if(_wcsicmp(pwzStr, m_wszpServerName) )
                return WBEM_E_INVALID_PARAMETER;

    return WBEM_S_NO_ERROR;
}
SCODE 
CDnsWrap::dnsQueryServerInfo(
    const WCHAR*        strServerName,
    CWbemClassObject&   NewInst,
    IWbemObjectSink*    pHandler
    )
{
        // get dnsserver
    DWORD       dwtypeid;
    PVOID       pdata=NULL;
    DNS_STATUS  status;
    PDNS_RPC_SERVER_INFO pServerInfo = NULL;

    if(WBEM_S_NO_ERROR != ValidateServerName(strServerName))
        return WBEM_E_INVALID_PARAMETER;

    status = DnssrvQuery(
        strServerName, 
        NULL,
        DNSSRV_QUERY_SERVER_INFO,
        &dwtypeid,
        &pdata);
    
    if( status == ERROR_SUCCESS)
    {
        pServerInfo = (PDNS_RPC_SERVER_INFO) pdata;
        NewInst.SetProperty(
            pServerInfo->dwVersion, 
            PVD_SRV_VERSION);
        NewInst.SetProperty(
            pServerInfo->fDsAvailable,
            PVD_SRV_DS_AVAILABLE);
        // ListenAddress array
        if(pServerInfo->aipListenAddrs)
        {
            NewInst.SetProperty(
                pServerInfo->aipListenAddrs->AddrArray,
                pServerInfo->aipListenAddrs->AddrCount,
                MYTEXT( DNS_REGKEY_LISTEN_ADDRESSES ) );
        }
        if(pServerInfo->aipForwarders)
        {
            NewInst.SetProperty(
                pServerInfo->aipForwarders->AddrArray,
                pServerInfo->aipForwarders->AddrCount,
                MYTEXT( DNS_REGKEY_FORWARDERS ) );
        }
        
        if(pServerInfo->aipServerAddrs)
        {
            NewInst.SetProperty(
                pServerInfo->aipServerAddrs->AddrArray,
                pServerInfo->aipServerAddrs->AddrCount,
                PVD_SRV_SERVER_IP_ADDRESSES_ARRAY);
        }
    }

    DnssrvFreeServerInfo(pServerInfo);

    if ( status != ERROR_SUCCESS )
    {
        ThrowException(status);
    }

    return ERROR_SUCCESS;
}


SCODE 
CDnsWrap::dnsRestartServer(
    WCHAR* strServerName
    )
{
    
    LONG status =  DnssrvOperation(
        strServerName,
        NULL,
        DNSSRV_OP_RESTART,
        DNSSRV_TYPEID_NULL,
        NULL );
    if(status != ERROR_SUCCESS)
    {
        ThrowException(status);
    }
    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        using property value from wmi instance to set dns server property
//
//    Arguments:
//      Inst                [IN]   wmi instance whose property value
//                                 to be sent to dns server
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
    
SCODE
CDnsWrap::dnsServerPropertySet(
    CWbemClassObject&   Inst,
    BOOL                bGet
    )
{
    DBG_FN( "CDnsWrap::dnsServerPropertySet" )

    //
    // get mapping table
    //
    DWORD cNumOfEntries;
    PropertyTable* pt = (PropertyTable*)GetPropertyTable(&cNumOfEntries);

    for(int i=0; i<cNumOfEntries; i++)
    {
        FPDNSOPS fp;
        fp = pt[i].fpOperationSet;
        if(fp != NULL)
        {    
            DNS_DEBUG( INSTPROV, (
                "%s: Inst=%p prop=%S\n", fn,
                &Inst,
                pt[i].pwzProperty ));

            // set dns server property 
            fp(
                NULL,
                pt[i].pwzProperty,
                pt[i].OperationName,
                Inst);
        }

    }

    return S_OK;
}


SCODE
CDnsWrap::dnsDsServerName(
    wstring& wstrDsName)
{

    CServerInfo serverInfo;
    LPWSTR pwsz = DnssrvCreateDsServerName(
            (PDNS_RPC_SERVER_INFO)serverInfo.m_pInfo);
    if(pwsz)
        wstrDsName = pwsz;
    FREE_HEAP(pwsz);

    return WBEM_S_NO_ERROR;
}


SCODE
CDnsWrap::dnsDsZoneName(
    wstring& wstrDsName,
    wstring& wstrInZone
    )
{
    CServerInfo serverInfo;
    LPWSTR pwsz = DnssrvCreateDsZoneName(
            (PDNS_RPC_SERVER_INFO)serverInfo.m_pInfo,
            (LPWSTR)wstrInZone.data());
    if(pwsz)
        wstrDsName = pwsz;
    FREE_HEAP(pwsz);

    return WBEM_S_NO_ERROR;
}


SCODE
CDnsWrap::dnsDsNodeName(
    wstring&    wstrDsName,
    wstring&    wstrInZone,
    wstring&    wstrInNode
    )
{
    CServerInfo serverInfo;
    LPWSTR pwsz = DnssrvCreateDsNodeName(
            (PDNS_RPC_SERVER_INFO)serverInfo.m_pInfo,
            (LPWSTR)wstrInZone.data(),
            (LPWSTR)wstrInNode.data());
    if(pwsz)
        wstrDsName = pwsz;
    FREE_HEAP(pwsz);

    return WBEM_S_NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        retrive dns server property and output to wmi instance
//
//    Arguments:
//      Inst                [IN OUT]   wmi instance to receive property value
//                                      got from dns server
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsWrap::dnsServerPropertyGet(
    CWbemClassObject&   Inst,
    BOOL                bGet
    )
{
    //
    // get maping table
    //
    DWORD cNumOfEntries;
    PropertyTable* pt = (PropertyTable*)GetPropertyTable(&cNumOfEntries);

    // set array and name property
    dnsQueryServerInfo(
        PVD_DNS_LOCAL_SERVER,
        Inst,
        NULL);
    for(int i=0; i<cNumOfEntries; i++)
    {
        FPDNSOPS fp;
        fp = pt[i].fpOperationGet;
        if(fp != NULL)
        {    //
            // get property from dns, and set wmi property
            //
            fp(
                NULL,
                pt[i].pwzProperty,
                pt[i].OperationName,
                Inst);
        }
    }

    //
    //  Hard-code the Status property to OK.
    //

    Inst.SetProperty( L"OK", L"Status" );

    return S_OK;
}


/*---------------------------------------------------------------------------
*/
SCODE 
CDnsWrap::dnsGetDwordProperty(
    const char *        pszZoneName,
    const WCHAR*        wszWbemProperty, 
    const char*         pszOperationName,
    CWbemClassObject&   Inst
    )
{
    DWORD dwValue;
    DNS_STATUS status = DnssrvQueryDwordProperty(
        PVD_DNS_LOCAL_SERVER,
        pszZoneName,
        pszOperationName,
        &dwValue);
    
    if(status != ERROR_SUCCESS)
            ThrowException(status);
    
    Inst.SetProperty(
        dwValue,
        (WCHAR*)wszWbemProperty);

    return WBEM_S_NO_ERROR;
}


/*---------------------------------------------------------------------------
*/
SCODE 
CDnsWrap::dnsSetDwordProperty(
    const char *        pszZoneName,
    const WCHAR*        wszWbemProperty, 
    const char*         pszOperationName,
    CWbemClassObject&   Inst
    )
{
    
    DWORD dwValue;
    if(Inst.GetProperty(
        &dwValue,
        (WCHAR*)wszWbemProperty) == S_OK)
    {

        DNS_RPC_NAME_AND_PARAM  param;
        param.dwParam = dwValue;
        param.pszNodeName = (LPSTR) pszOperationName;

        DNS_STATUS status = DnssrvOperation(
            PVD_DNS_LOCAL_SERVER,
            pszZoneName,
            DNSSRV_OP_RESET_DWORD_PROPERTY,
            DNSSRV_TYPEID_NAME_AND_PARAM,
            & param );
    
        if(status != ERROR_SUCCESS)
            ThrowException(status);
    }

    return WBEM_S_NO_ERROR;
}


/*---------------------------------------------------------------------------
*/
SCODE 
CDnsWrap::dnsGetStringProperty(
    const char *        pszZoneName,
    const WCHAR *       wszWbemProperty, 
    const char *        pszDnssrvPropertyName,
    CWbemClassObject&   Inst
    )
{
    DWORD       dataType;
    PVOID       pdata;

    DNS_STATUS status = DnssrvQuery(
                            PVD_DNS_LOCAL_SERVER,
                            pszZoneName,
                            pszDnssrvPropertyName,
                            &dataType,
                            &pdata );
    if( status != ERROR_SUCCESS )
    {
        ThrowException( status );
    }
    if ( dataType != DNSSRV_TYPEID_LPWSTR )
    {
        ThrowException( WBEM_E_TYPE_MISMATCH );
    }
    
    Inst.SetProperty(
        ( PWSTR ) pdata,
        ( PWCHAR ) wszWbemProperty);
    return WBEM_S_NO_ERROR;
}


/*---------------------------------------------------------------------------
*/
SCODE 
CDnsWrap::dnsSetStringProperty(
    const char *        pszZoneName,
    const WCHAR *       wszWbemProperty, 
    const char *        pszDnssrvPropertyName,
    CWbemClassObject &  Inst
    )
{
    wstring val;
    if( Inst.GetProperty(
                val,
                ( PWCHAR ) wszWbemProperty ) == S_OK )
    {
        DNS_STATUS status = DnssrvResetStringProperty(
                                PVD_DNS_LOCAL_SERVER,
                                pszZoneName,
                                pszDnssrvPropertyName,
                                val.c_str(),
                                0 );
        if( status != ERROR_SUCCESS )
        {
            ThrowException( status );
        }
    }
    return WBEM_S_NO_ERROR;
}   //  CDnsWrap::dnsSetStringProperty


/*---------------------------------------------------------------------------
Read the property value from DNS server and set in class object.
*/
SCODE 
CDnsWrap::dnsGetIPArrayProperty(
    const char *        pszZoneName,
    const WCHAR *       wszWbemProperty, 
    const char *        pszDnssrvPropertyName,
    CWbemClassObject &  Inst
    )
{
    SCODE               sc = WBEM_S_NO_ERROR;
    DWORD               dataType = 0;
    PVOID               pdata = 0;
    SAFEARRAY *         psa = NULL;
    SAFEARRAYBOUND      rgsabound[ 1 ] = { 0, 0 };
    PIP_ARRAY           pipArray;

    //
    //  Retrieve the setting from the DNS server and check it's type.
    //

    DNS_STATUS status = DnssrvQuery(
                            PVD_DNS_LOCAL_SERVER,
                            pszZoneName,
                            pszDnssrvPropertyName,
                            &dataType,
                            &pdata );
    if( status != ERROR_SUCCESS )
    {
        sc = status;
        goto Done;
    }
    if ( dataType != DNSSRV_TYPEID_IPARRAY )
    {
        sc = WBEM_E_TYPE_MISMATCH;
        goto Done;
    }
    if ( pdata == NULL )
    {
        Inst.SetProperty(
            ( PWCHAR ) NULL,
            ( PWCHAR ) wszWbemProperty );
        goto Done;
    }
    pipArray = ( PIP_ARRAY ) pdata;

    //
    //  Create a SAFEARRAY of BSTRs to represent the IP address list.
    //

    rgsabound[ 0 ].cElements = pipArray->AddrCount;
    psa = SafeArrayCreate( VT_BSTR, 1, rgsabound );
    if ( psa == NULL )
    {
        sc = WBEM_E_OUT_OF_MEMORY;
        goto Done;
    }
    for ( int i = 0; i < pipArray->AddrCount; ++i )
    {
        BSTR bstr = AllocBstr(
                IpAddressToString( pipArray->AddrArray[ i ] ).c_str() );
        if ( bstr == NULL )
        {
            sc = WBEM_E_OUT_OF_MEMORY;
            goto Done;
        }
        LONG ix = i;
        sc = SafeArrayPutElement( psa, &ix, bstr );
        SysFreeString( bstr );
        if ( sc != S_OK )
        {
            goto Done;
        }
    }
            
    Inst.SetProperty(
        psa,
        ( PWCHAR ) wszWbemProperty );
    
    Done:

    if ( pdata )
    {
        //  JJW: do something to free RPC piparray???
    }
    if ( psa )
    {
        SafeArrayDestroy( psa );
    }
    
    return sc;
}   //  CDnsWrap::dnsGetIPArrayProperty


/*---------------------------------------------------------------------------
This function reads a string array property from the class object instance
and builds an IP array from the values read.

Caller must use FREE_HEAP to free the pIpArray.
*/
SCODE
CDnsWrap::buildIpArrayFromStringArrayProperty(
    CWbemClassObject &  Inst,
    LPCWSTR             wszWbemProperty,
    PIP_ARRAY *         ppIpArray
    )
{
    DBG_FN( "buildIpArrayFromStringArrayProperty" )

    if ( !ppIpArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    SCODE               sc = WBEM_S_NO_ERROR;
    SAFEARRAY *         psa = NULL;
    VARIANT             var;
    PIP_ARRAY           pipArray = NULL;

    VariantInit( &var );

    sc = Inst.GetProperty( &var, ( LPCWSTR ) wszWbemProperty );

    if( sc == S_OK && var.vt != VT_NULL )
    {
        if ( var.vt != ( VT_ARRAY |VT_BSTR ) )
        {
            sc = WBEM_E_TYPE_MISMATCH;
            goto Done;
        }

        sc = SafeArrayCopy( var.parray, &psa );

        BSTR * pbstr = NULL;
        sc = SafeArrayAccessData( psa, ( void ** ) &pbstr );
        if ( sc != S_OK )
        {
            goto Done;
        }

        int ipCount = psa->rgsabound[ 0 ].cElements;
        IP_ADDRESS * pipAddrArray = new IP_ADDRESS[ ipCount + 1 ];
        if ( pipAddrArray == NULL )
        {
            ThrowException( WBEM_E_OUT_OF_MEMORY );
        }
        for ( int i = 0; i < ipCount; ++i )
        {
            string str;
            WcharToString( pbstr[ i ], str );
            pipAddrArray[ i ] = inet_addr( str.c_str() );
        }
        SafeArrayUnaccessData( psa );

        pipArray = Dns_BuildIpArray( ipCount, pipAddrArray );

        delete [] pipAddrArray;
    }

    Done:

    VariantClear( &var );

    if ( psa )
    {
        SafeArrayDestroy( psa );
    }

    *ppIpArray = pipArray; 

    return sc;
}   //  CDnsWrap::buildIpArrayFromStringArrayProperty


/*---------------------------------------------------------------------------
Read the property value out of the class object and send to DNS server.

If the specified property does not exist on the object, do nothing and
return WBEM_S_NO_ERROR.
*/
SCODE 
CDnsWrap::dnsSetIPArrayProperty(
    const char *        pszZoneName,
    const WCHAR *       wszWbemProperty, 
    const char *        pszDnssrvPropertyName,
    CWbemClassObject &  Inst
    )
{
    DBG_FN( "CDnsWrap::dnsSetIPArrayProperty" )

    SCODE       sc = WBEM_S_NO_ERROR;
    PIP_ARRAY   pipArray = NULL;

    sc = buildIpArrayFromStringArrayProperty(
            Inst,
            wszWbemProperty,
            &pipArray );
    if ( sc != WBEM_NO_ERROR )
    {
        goto Done;
    }

    DNS_STATUS status = DnssrvResetIPListProperty(
                            PVD_DNS_LOCAL_SERVER,
                            pszZoneName,
                            pszDnssrvPropertyName,
                            pipArray,
                            0 );

    FREE_HEAP( pipArray );

    if ( status != ERROR_SUCCESS )
    {
        sc = status;
    }
    
    Done:

    return sc;
}   //  CDnsWrap::dnsSetIPArrayProperty


SCODE
CDnsWrap::dnsSetServerForwarders(
    const char *        pszZoneName,
    const WCHAR*        wszWbemProperty, 
    const char*         pszOperationName,
    CWbemClassObject &  Inst
    )
{

    // get forward ip array
    DWORD* pdwValue=NULL;
    DWORD dwSize;
    if(Inst.GetProperty(
        &pdwValue,
        &dwSize,
        (WCHAR*)wszWbemProperty) == S_OK)
    {
        DWORD dwSlave;
        DWORD dwTimeOut;
        try
        {
            if(Inst.GetProperty(
                &dwTimeOut,
                MYTEXT( DNS_REGKEY_FORWARD_TIMEOUT ) ) != S_OK)
            {
                return WBEM_E_INVALID_PARAMETER;
            }

            if(Inst.GetProperty(
                &dwSlave,
                MYTEXT( DNS_REGKEY_SLAVE ) ) != S_OK)
            {
                return WBEM_E_INVALID_PARAMETER;
            }

        }
        catch(...)
        {
            delete [] pdwValue;
            throw;
        }
        // now let's change it

        DNS_STATUS status = DnssrvResetForwarders(
            PVD_DNS_LOCAL_SERVER,
            dwSize,
            pdwValue,
            dwTimeOut,
            dwSlave );

        delete [] pdwValue;
        if(status != ERROR_SUCCESS)
        {
            ThrowException(status);
        }
    
    }
    
    return WBEM_S_NO_ERROR;
}

SCODE
CDnsWrap::dnsSetServerListenAddress(
    const char *        pszZoneName,
    const WCHAR*        wszWbemProperty, 
    const char*         pszOperationName,
    CWbemClassObject&   Inst
    )
{
    PIP_ARRAY   pipArray = NULL;
    SCODE       sc;

    sc = buildIpArrayFromStringArrayProperty(
            Inst,
            wszWbemProperty,
            &pipArray );
    if ( sc != WBEM_NO_ERROR )
    {
        ThrowException( sc );
    }

    DNS_STATUS status = ERROR_SUCCESS;
    
    if ( pipArray )
    {
        status = DnssrvResetServerListenAddresses(
                            PVD_DNS_LOCAL_SERVER,
                            pipArray->AddrCount,
                            pipArray->AddrArray );
    }

    FREE_HEAP( pipArray );

    if( status != ERROR_SUCCESS)
    {
        ThrowException( status );
    }
    return WBEM_S_NO_ERROR;
}   //  CDnsWrap::dnsSetServerListenAddress


SCODE 
CDnsWrap::dnsDeleteZone(
    CObjPath& objZone)
{
    wstring wstrZoneName = objZone.GetStringValueForProperty(
        PVD_DOMAIN_CONTAINER_NAME
        );

// dww - 6/14/99
// Added code to see if this is an integrated zone. If it is, you have to use
// The DNSSRV_OP_ZONE_DELETE_FROM_DS operation. All other zone types use the 
// DNSSRV_OP_ZONE_DELETE operation.
//
    // Get the Zone Type to determine if it is an integrated zone.
    DWORD dwValue = -1;
    LONG status = WBEM_S_NO_ERROR;
    char* pszZoneName = NULL;
    WcharToChar(wstrZoneName.data(), &pszZoneName);

    DnssrvQueryDwordProperty(
        PVD_DNS_LOCAL_SERVER,
        pszZoneName,
        DNS_REGKEY_ZONE_DS_INTEGRATED,
        &dwValue
        );

    if(dwValue == 1)  // integrated zone
    {
        status= DnssrvOperation(
                        PVD_DNS_LOCAL_SERVER,
                        pszZoneName,
                        DNSSRV_OP_ZONE_DELETE_FROM_DS,
                        DNSSRV_TYPEID_NULL,
                        (PVOID) NULL );
    }
    else 
    {
        status= DnssrvOperation(
                        PVD_DNS_LOCAL_SERVER,
                        pszZoneName,
                        DNSSRV_OP_ZONE_DELETE,
                        DNSSRV_TYPEID_NULL,
                        (PVOID) NULL );
    }
    delete [] pszZoneName;
    if( status != ERROR_SUCCESS)
        ThrowException(status);

    return WBEM_S_NO_ERROR;
}


wstring 
CDnsWrap::GetServerName(void)
{
    return m_wszpServerName;
}


SCODE 
CDnsWrap::dnsGetZone(
    const WCHAR*        wszServer, 
    const WCHAR*        wszZone,
    CWbemClassObject&   Inst,
    IWbemObjectSink*    pHandler
    )
{
    DBG_FN( "CDnsWrap::dnsGetZone" )

    DNS_STATUS status;
    char* pszZoneName = NULL;
    PDNS_RPC_ZONE_INFO pZoneInfo=NULL;
    WcharToChar(wszZone, &pszZoneName);
    status = DnssrvGetZoneInfo(
        wszServer,
        pszZoneName,
        &pZoneInfo );

    DNS_DEBUG( INSTPROV, (
        "%s: server %S zone %S\n", fn, wszServer, wszZone ));

    DWORD dwDsIntegratedValue = 0;
    if ( status == ERROR_SUCCESS)
    {
        status = DnssrvQueryDwordProperty(
            PVD_DNS_LOCAL_SERVER,
            pszZoneName,
            DNS_REGKEY_ZONE_DS_INTEGRATED,
            &dwDsIntegratedValue );
    }
    
    delete [] pszZoneName;
    if ( status == DNS_ERROR_ZONE_DOES_NOT_EXIST)
    {
        return WBEM_E_NOT_FOUND;
    }

    // setup wbem object

    if(status == ERROR_SUCCESS)
    {
        Inst.SetProperty(
            pZoneInfo->dwZoneType,    
            PVD_ZONE_ZONE_TYPE);

        // setup keys
        Inst.SetProperty(
            m_wszpServerName, 
            PVD_DOMAIN_SERVER_NAME);
        
        Inst.SetProperty(
            wszZone, 
            PVD_DOMAIN_CONTAINER_NAME);
        
        Inst.SetProperty(
            wszZone, 
            PVD_DOMAIN_FQDN);
        
        Inst.SetProperty(
            pZoneInfo->fAllowUpdate, 
            PVD_ZONE_ALLOW_UPDATE);
        
        Inst.SetProperty(
            pZoneInfo->fAutoCreated, 
            PVD_ZONE_AUTO_CREATED);
        
        Inst.SetProperty(
            pZoneInfo->fPaused, 
            PVD_ZONE_PAUSED );
        
        Inst.SetProperty(
            pZoneInfo->fReverse, 
            PVD_ZONE_REVERSE );
        
        Inst.SetProperty(
            pZoneInfo->fAging, 
            PVD_ZONE_AGING );
        
        Inst.SetProperty(
            pZoneInfo->fSecureSecondaries, 
            PVD_ZONE_SECURE_SECONDARIES );

        Inst.SetProperty(
            pZoneInfo->fNotifyLevel, 
            PVD_ZONE_NOTIFY);
       
        Inst.SetProperty(
            pZoneInfo->fShutdown, 
            PVD_ZONE_SHUTDOWN );
        
        Inst.SetProperty(
            pZoneInfo->fUseWins, 
            PVD_ZONE_USE_WINS);
        
        Inst.SetProperty(
            pZoneInfo->pszDataFile, 
            PVD_ZONE_DATA_FILE); 
        
        Inst.SetProperty(
            dwDsIntegratedValue, 
            PVD_ZONE_DS_INTEGRATED); 
        
       Inst.SetProperty(
            pZoneInfo->dwAvailForScavengeTime, 
            PVD_ZONE_AVAIL_FOR_SCAVENGE_TIME ); 
        
        Inst.SetProperty(
            pZoneInfo->dwNoRefreshInterval, 
            PVD_ZONE_NOREFRESH_INTERVAL ); 
        
        Inst.SetProperty(
            pZoneInfo->dwRefreshInterval, 
            PVD_ZONE_REFRESH_INTERVAL ); 
        
        Inst.SetProperty(
            pZoneInfo->fForwarderSlave, 
            PVD_ZONE_FORWARDER_SLAVE ); 
        
        Inst.SetProperty(
            pZoneInfo->dwForwarderTimeout, 
            PVD_ZONE_FORWARDER_TIMEOUT ); 
        
        if (pZoneInfo->aipMasters != NULL)
        {
            Inst.SetProperty(
                pZoneInfo->aipMasters->AddrArray,
                pZoneInfo->aipMasters->AddrCount,
                PVD_ZONE_MASTERS_IP_ADDRESSES_ARRAY );
        }
        
        if (pZoneInfo->aipSecondaries != NULL)
        {
          Inst.SetProperty(
                pZoneInfo->aipSecondaries->AddrArray,
                pZoneInfo->aipSecondaries->AddrCount,
                PVD_ZONE_SECONDARIES_IP_ADDRESSES_ARRAY );
        }

        if( pZoneInfo->aipNotify != NULL)
        {
            Inst.SetProperty(
                pZoneInfo->aipNotify->AddrArray,
                pZoneInfo->aipNotify->AddrCount,
                PVD_ZONE_NOTIFY_IPADDRESSES_ARRAY );
        }

        if( pZoneInfo->aipScavengeServers )
        {
            Inst.SetProperty(
                pZoneInfo->aipScavengeServers->AddrArray,
                pZoneInfo->aipScavengeServers->AddrCount,
                PVD_ZONE_SCAVENGE_SERVERS );
        }

        Inst.SetProperty(
            pZoneInfo->dwLastSuccessfulSoaCheck, 
            PVD_ZONE_LAST_SOA_CHECK );

        Inst.SetProperty(
            pZoneInfo->dwLastSuccessfulXfr, 
            PVD_ZONE_LAST_GOOD_XFR ); 
    }
    
    //clean up
    DnssrvFreeZoneInfo(pZoneInfo);

    if( status != ERROR_SUCCESS)
    {
        DNS_DEBUG( INSTPROV, (
            "%s: server %S zone %S throwing %s\n", fn, wszServer, wszZone, status ));
        ThrowException(status);
    }

    DNS_DEBUG( INSTPROV, (
        "%s: server %S zone %S returning WBEM_S_NO_ERROR\n", fn, wszServer, wszZone ));
    return WBEM_S_NO_ERROR;    
}


SCODE 
CDnsWrap::dnsSetProperty(
    const WCHAR*    wszZoneName, 
    const char*     pszPropertyName, 
    DWORD           dwValue
    )
{
    char * pszZone = NULL;
    WcharToChar(wszZoneName, &pszZone);

    return dnsSetProperty( pszZone, pszPropertyName, dwValue );
}


SCODE 
CDnsWrap::dnsSetProperty(
    const char*     pszZoneName, 
    const char*     pszPropertyName, 
    DWORD           dwValue
    )
{
    DBG_FN( "CDnsWrap::dnsSetDwordProperty" );

    DNS_DEBUG( INSTPROV, (
        "%s: zone %s property %s value %d\n", fn,
        pszZoneName,
        pszPropertyName,
        dwValue ));

    LONG status = DnssrvResetDwordProperty(
                        PVD_DNS_LOCAL_SERVER,
                        pszZoneName,
                        pszPropertyName,
                        dwValue );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INSTPROV, (
            "%s: throwing 0x%X for zone %s property %s\n", fn,
            status,
            pszZoneName,
            pszPropertyName ));
        ThrowException( status );
    }
    return WBEM_S_NO_ERROR;
}


SCODE 
CDnsWrap::dnsQueryProperty(
    const WCHAR*    wszZoneName, 
    const WCHAR*    wszPropertyName, 
    DWORD*          pdwResult
    )
{
    
    char * szZone = NULL;
    char * szProp = NULL;
    WcharToChar(wszZoneName, &szZone);
    WcharToChar(wszPropertyName, &szProp);
    LONG status = DnssrvQueryZoneDwordProperty(
        PVD_DNS_LOCAL_SERVER,
        szZone,
        szProp,
        pdwResult
    );

    delete [] szZone;
    delete [] szProp;
    
    if(status != ERROR_SUCCESS)
        ThrowException(status);
    return WBEM_S_NO_ERROR;
}


SCODE 
CDnsWrap::dnsResumeZone(
    const char* strZoneName
    )
{
    DNS_STATUS status = DnssrvResumeZone(
        PVD_DNS_LOCAL_SERVER,
        strZoneName);
    if(status != ERROR_SUCCESS)
    {
        ThrowException(status);
    }
    return WBEM_S_NO_ERROR;
}


SCODE 
CDnsWrap::dnsPauseZone(
    const char *strZoneName
    )
{
    int status = DnssrvPauseZone(
        PVD_DNS_LOCAL_SERVER,
        strZoneName        // zone name
        );

    if ( status != ERROR_SUCCESS )
    {
        ThrowException(status);
    }
    
    return WBEM_S_NO_ERROR;
}


void 
CDnsWrap::ThrowException(
    LONG status)
{
    CDnsProvException dnsExcep(Dns_StatusString(status),status);
    throw dnsExcep;
}


void 
CDnsWrap::ThrowException(
    LPCSTR ErrString
    )
{
    CDnsProvException dnsExcep(ErrString);
    throw dnsExcep;
}


SCODE CDnsWrap::dnsClearCache()
{
    DNS_STATUS status = DnssrvOperation(
        PVD_DNS_LOCAL_SERVER,
        NULL,
        DNSSRV_OP_CLEAR_CACHE,
        DNSSRV_TYPEID_NULL,
        NULL );
    if(status != S_OK)
        ThrowException(status);
    return WBEM_S_NO_ERROR;

}


SCODE CDnsWrap::dnsAgeAllRecords(
    const char *    pszZoneName, 
    const char *    pszNodeName, 
    BOOL            bAgeSubtree
    )
{
    DBG_FN( "CDnsWrap::dnsAgeAllRecords" );
    
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam       = ( DWORD ) bAgeSubtree;
    param.pszNodeName   = ( LPSTR ) pszNodeName;

    DNS_DEBUG( INSTPROV, (
        "%s: zone: %s node %s subtree %d\n", fn,
        pszZoneName,
        pszNodeName,
        bAgeSubtree ));

    DNS_STATUS status = DnssrvOperation(
                            PVD_DNS_LOCAL_SERVER,
                            pszZoneName,
                            DNSSRV_OP_FORCE_AGING_ON_NODE,
                            DNSSRV_TYPEID_NAME_AND_PARAM,
                            ( PVOID ) &param );
    if ( status != S_OK )
    {
        ThrowException( status );
    }
    return WBEM_S_NO_ERROR;
}   //  CDnsWrap::dnsAgeAllRecords


SCODE 
CDnsWrap::dnsOperation(
        string& strZone,    //zone name
        OpsFlag OperationID
        )
{
    string strOps;

    switch ( OperationID )
    {
        case DNS_WRAP_RELOAD_ZONE:
            strOps = DNSSRV_OP_ZONE_RELOAD;
            break;
        case DNS_WRAP_RESUME_ZONE:
            strOps = DNSSRV_OP_ZONE_RESUME;
            break;
        case DNS_WRAP_PAUSE_ZONE:
            strOps = DNSSRV_OP_ZONE_PAUSE;
            break;
        case DNS_WRAP_DS_UPDATE:
            strOps = DNSSRV_OP_ZONE_UPDATE_FROM_DS;
            break;
        case DNS_WRAP_WRITE_BACK_ZONE:
            strOps = DNSSRV_OP_ZONE_WRITE_BACK_FILE;
            break;
        case DNS_WRAP_REFRESH_SECONDARY:
            strOps = DNSSRV_OP_ZONE_REFRESH;
            break;
        default:
            return WBEM_E_FAILED;
    }

    DNS_STATUS status = DnssrvOperation(
                            PVD_DNS_LOCAL_SERVER,
                            strZone.data(),
                            strOps.data(),
                            DNSSRV_TYPEID_NULL,
                            NULL );
    if ( status != S_OK )
    {
        ThrowException( status );
    }
    return WBEM_S_NO_ERROR;
}   //  CDnsWrap::dnsOperation


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//      returns a mapping table that maps wbem property and dns property 
//      , and operation can be performed 
//      on the property such as get and set
//
//    Arguments:
//      pdwSize             [IN ]   size of the table

//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

PVOID
CDnsWrap::GetPropertyTable(
    DWORD* pdwSize
    )
{
    //
    //  Macros to simplify adding elements to the property array. 
    //

    #define DECLARE_DW_ELEMENT( str )   \
    {                                   \
        MYTEXT( str ),                  \
        str,                            \
        dnsSetDwordProperty,            \
        dnsGetDwordProperty             \
    }

    #define DECLARE_STR_ELEMENT( str )  \
    {                                   \
        MYTEXT( str ),                  \
        str,                            \
        dnsSetStringProperty,           \
        dnsGetStringProperty            \
    }

    #define DECLARE_IPARRAY_ELEMENT( str )  \
    {                                       \
        MYTEXT( str ),                      \
        str,                                \
        dnsSetIPArrayProperty,              \
        dnsGetIPArrayProperty               \
    }

    //
    //  Array of server properties.
    //

    static PropertyTable pt[] =
    {
        DECLARE_DW_ELEMENT( DNS_REGKEY_ADDRESS_ANSWER_LIMIT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_ALLOW_UPDATE ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_RPC_PROTOCOL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_NO_RECURSION ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_RECURSION_RETRY ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_RECURSION_TIMEOUT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_FORWARD_TIMEOUT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_SLAVE ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_AUTO_CACHE_UPDATE ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DISJOINT_NETS ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_ROUND_ROBIN ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_BIND_SECONDARIES ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_WRITE_AUTHORITY_NS ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_STRICT_FILE_PARSING ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_LOOSE_WILDCARDING ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_EVENTLOG_LEVEL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_LOG_LEVEL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_MAX_CACHE_TTL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_MAX_NEGATIVE_CACHE_TTL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DS_POLLING_INTERVAL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DS_TOMBSTONE_INTERVAL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_NAME_CHECK_FLAG ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_SEND_PORT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_BOOT_METHOD ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_NO_AUTO_REVERSE_ZONES ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_LOCAL_NET_PRIORITY ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_FORWARD_DELEGATIONS ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_SECURE_RESPONSES ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_AUTO_CONFIG_FILE_ZONES ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DEFAULT_AGING_STATE ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DEFAULT_REFRESH_INTERVAL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DEFAULT_NOREFRESH_INTERVAL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_ENABLE_DNSSEC ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_ENABLE_EDNS ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_EDNS_CACHE_TIMEOUT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_ENABLE_DP ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_XFR_CONNECT_TIMEOUT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_SCAVENGING_INTERVAL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_UPDATE_OPTIONS ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_LOG_FILE_MAX_SIZE ),
        DECLARE_STR_ELEMENT( DNS_REGKEY_LOG_FILE_PATH ),
        DECLARE_IPARRAY_ELEMENT( DNS_REGKEY_LOG_IP_FILTER_LIST ),
        {
            MYTEXT( DNS_REGKEY_FORWARDERS ),
            DNS_REGKEY_FORWARDERS,
            dnsSetServerForwarders,
            NULL
        },
        DECLARE_DW_ELEMENT( DNS_REGKEY_FORWARD_TIMEOUT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_SLAVE ),
        {
            MYTEXT( DNS_REGKEY_LISTEN_ADDRESSES ),
            DNS_REGKEY_LISTEN_ADDRESSES,
            dnsSetServerListenAddress,
            NULL
        },
    };

    static DWORD dwNumofElements =
        sizeof(pt)/sizeof(PropertyTable);
    *pdwSize = dwNumofElements;
    return &pt;
}

SCODE 
CDnsWrap::dnsZoneCreate(
    string &    strZoneName,
    DWORD       dwZoneType,
    BOOL        DsIntegrated,
    string &    strDataFile,
    string &    strAdmin,
    DWORD *     pIp,
    DWORD       cIp
    )
{
        
    DWORD       loadOptions = 0;
    LPSTR       pszData = NULL;

    //
    //  Pre-processing by zone type. Convert WMI zone type to RPC zone type
    //  by incremented by one: WMI type 0 is primary but RPC types start
    //  at cache.
    //

    ++dwZoneType;

    if( dwZoneType == DNS_ZONE_TYPE_SECONDARY )        
    {
        //  secondary zone must supply master ip array
        if ( cIp <=0 || pIp == NULL )
        {
            return WBEM_E_INVALID_PARAMETER;
        }
    }

    if( !strDataFile.empty())
    {
         loadOptions |= DNS_ZONE_LOAD_EXISTING;
         pszData = (LPSTR) strDataFile.data();
    }
    
    string strAdminEmail = strAdmin;
    if ( strAdminEmail.empty() )
    {
        strAdminEmail = "Admin";
    }

    DNS_STATUS status;

    status = DnssrvCreateZone(
                PVD_DNS_LOCAL_SERVER,               //  server
                (char*) strZoneName.data(),         //  zone name
                dwZoneType,                         //  zone type    
                strAdminEmail.data(),               //  admin email
                cIp,                                //  size of master
                pIp,                                //  master ips
                loadOptions,                        //  load options
                DsIntegrated,                       //  DS integrated
                pszData,                            //  data file name
                0,                                  //  timeout for forwarder zone
                0 );                                //  slave flag for forwarder zone

    if ( status != ERROR_SUCCESS )
    {
        ThrowException( status );
    }

    return WBEM_S_NO_ERROR;
}   //  CDnsWrap::dnsZoneCreate


SCODE 
CDnsWrap::dnsZoneChangeType(
    string &    strZone,
    DWORD       dwZoneType,
    BOOL        DsIntegrated,
    string &    strDataFile,
    string &    strAdmin,
    DWORD *     pIp,
    DWORD       cIp
    )
{
    DWORD       dwLoadOptions = TRUE;
    DWORD       cMaster = 0;

    //
    //  Convert WMI zone type to RPC zone type by incrementing by one.
    //

    ++dwZoneType;

    //
    //  Examine parameters.
    //

    if ( dwZoneType == DNS_ZONE_TYPE_PRIMARY )
    {
        if ( DsIntegrated && !strDataFile.empty() ||
             !DsIntegrated && strDataFile.empty() )
        {
            return WBEM_E_INVALID_PARAMETER;
        }
    }
    else if ( dwZoneType == DNS_ZONE_TYPE_SECONDARY )
    {
        if ( pIp == NULL || cIp <= 0 )
        {
            //  secondary must have master IP
            return WBEM_E_INVALID_PARAMETER;
        }
    }

    //
    //  Change zone type.
    //

    DNS_STATUS status;            
    status = DnssrvResetZoneTypeEx(
                    PVD_DNS_LOCAL_SERVER,
                    strZone.data(),
                    dwZoneType,
                    cIp,
                    pIp,
                    dwLoadOptions,
                    DsIntegrated,
                    strDataFile.data(),
                    0,          //  dwDpFlags
                    NULL );     //  pszDpFqdn

    if ( status != S_OK )
    {
        ThrowException( status);
    }
    return WBEM_S_NO_ERROR;
}   //  CDnsWrap::dnsZoneChangeType


SCODE
CDnsWrap::dnsZoneResetSecondary(
    string& strZoneName,
    DWORD   dwSecurity,
    DWORD*  pSecondaryIp,
    DWORD   cSecondaryIp,
    DWORD   dwNotify,
    DWORD * pNotifyIp,
    DWORD   cNotifyIp
    )
{
    DNS_STATUS status;
    DWORD       tdwNotifyLevel = ZONE_NOTIFY_ALL;
    DWORD       tdwSecurity = ZONE_SECSECURE_NO_SECURITY;

    if( dwSecurity <=3 )
    {
        tdwSecurity = dwSecurity;
    }
    if( dwNotify <=2)
    {
        tdwNotifyLevel = dwNotify;
    }
    status = DnssrvResetZoneSecondaries(
        PVD_DNS_LOCAL_SERVER,
        strZoneName.data(),
        tdwSecurity,
        cSecondaryIp,
        pSecondaryIp,
        tdwNotifyLevel,
        cNotifyIp,
        pNotifyIp);

    if ( status != ERROR_SUCCESS )
    {
        ThrowException(status);
    }

    return WBEM_S_NO_ERROR;
}


SCODE
CDnsWrap::dnsZoneResetMaster(
    string& strZoneName,
    DWORD*  pMasterIp,
    DWORD   cMasterIp,
    DWORD   dwLocal
    )
{
    DNS_STATUS status;
    DWORD dwValue = -1;

    status = DnssrvResetZoneMastersEx(
                PVD_DNS_LOCAL_SERVER,
                strZoneName.data(),
                cMasterIp,
                pMasterIp,
                dwLocal );
    if ( status != ERROR_SUCCESS )
    {
        ThrowException(status);
    }
    return WBEM_S_NO_ERROR;
}



SCODE
CDnsWrap::dnsZonePut(
    CWbemClassObject& Inst
    )
/*++

Routine Description:

    This function commits all of the property values in a zone
    object to the DNS server.

Arguments:

    Inst -- zone object

Return Value:

    S_OK on success.

--*/
{
    DBG_FN( "CDnsWrap::dnsZonePut" )

    SCODE sc;
    DNS_STATUS status = ERROR_SUCCESS;
    DWORD dwProperty = 0;
    DWORD dwZoneType = -1;
    DWORD * dwArray = NULL;
    DWORD dwArraySize = 0;
    string strZoneName;
    string strDataFile;
    DWORD dwValue;

    //
    //  Setting some properties, such as ScavengeServers on a zone where
    //  aging is not enabled, will result in DNS_ERROR_INVALID_ZONE_TYPE.
    //  I do not want to duplicate all of these rules in the WMI provider,
    //  so if the server returns DNS_ERROR_INVALID_ZONE_TYPE the WMI
    //  provider will assume everything is okay and continue.
    //
    
    #define DNS_CHECK_STATUS()                                          \
        if ( status == DNS_ERROR_INVALID_ZONE_TYPE )                    \
            status = ERROR_SUCCESS;                                     \
        else if ( status != ERROR_SUCCESS ) goto Done

    //
    //  Get basic properties of the new zone.
    //

    Inst.GetProperty( strZoneName, PVD_DOMAIN_CONTAINER_NAME );
    Inst.GetProperty( &dwZoneType, PVD_ZONE_ZONE_TYPE );

    DNS_DEBUG( INSTPROV, (
        "%s: zone %s\n", fn, strZoneName.c_str() ));

    //
    //  Retrieve properties from the class object and set values
    //  to the server.
    //

    if( dwZoneType == DNS_ZONE_TYPE_PRIMARY &&
        Inst.GetProperty(
                &dwProperty, 
                PVD_ZONE_ALLOW_UPDATE ) == S_OK )
    {
        status = dnsSetProperty(
                        strZoneName.data(), 
                        DNS_REGKEY_ZONE_ALLOW_UPDATE, 
                        dwProperty );
        DNS_CHECK_STATUS();
    }

    if( Inst.GetProperty(
                &dwProperty, 
                PVD_ZONE_REFRESH_INTERVAL ) == S_OK )
    {
        status = dnsSetProperty(
                        strZoneName.data(), 
                        DNS_REGKEY_ZONE_REFRESH_INTERVAL, 
                        dwProperty );
        DNS_CHECK_STATUS();
    }

    if( Inst.GetProperty(
                &dwProperty, 
                PVD_ZONE_NOREFRESH_INTERVAL ) == S_OK )
    {
        status = dnsSetProperty(
                        strZoneName.data(), 
                        DNS_REGKEY_ZONE_NOREFRESH_INTERVAL, 
                        dwProperty );
        DNS_CHECK_STATUS();
    }

    if ( dwZoneType == DNS_ZONE_TYPE_SECONDARY
         || dwZoneType == DNS_ZONE_TYPE_STUB
         || dwZoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        status = dnsSetIPArrayProperty(
                    strZoneName.data(), 
                    MYTEXT( DNS_REGKEY_ZONE_MASTERS ), 
                    DNS_REGKEY_ZONE_MASTERS,
                    Inst );
        DNS_CHECK_STATUS();

        status = dnsSetIPArrayProperty(
                    strZoneName.data(), 
                    MYTEXT( DNS_REGKEY_ZONE_LOCAL_MASTERS ), 
                    DNS_REGKEY_ZONE_LOCAL_MASTERS,
                    Inst );
        DNS_CHECK_STATUS();
    }

    status = dnsSetIPArrayProperty(
                strZoneName.data(), 
                MYTEXT( DNS_REGKEY_ZONE_SCAVENGE_SERVERS ), 
                DNS_REGKEY_ZONE_SCAVENGE_SERVERS,
                Inst );
    DNS_CHECK_STATUS();

    //
    //  Forwarder zone properties.
    //

    if ( dwZoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        if( Inst.GetProperty(
                    &dwProperty, 
                    MYTEXT( DNS_REGKEY_ZONE_FWD_SLAVE ) ) == S_OK )
        {
            status = dnsSetProperty(
                            strZoneName.data(), 
                            DNS_REGKEY_ZONE_FWD_SLAVE, 
                            dwProperty );
            DNS_CHECK_STATUS();
        }

        if( Inst.GetProperty(
                    &dwProperty, 
                    MYTEXT( DNS_REGKEY_ZONE_FWD_TIMEOUT ) ) == S_OK )
        {
            status = dnsSetProperty(
                            strZoneName.data(), 
                            DNS_REGKEY_ZONE_FWD_TIMEOUT, 
                            dwProperty );
            DNS_CHECK_STATUS();
        }
    }

    //
    //  To handle the zone data file, call DnssrvResetZoneDatabase
    //

    dwValue = 0;
    DnssrvQueryDwordProperty(
        PVD_DNS_LOCAL_SERVER,
        strZoneName.data(),
        DNS_REGKEY_ZONE_DS_INTEGRATED,
        &dwValue );
    if( Inst.GetProperty(
            strDataFile, 
            PVD_ZONE_DATA_FILE ) == S_OK )
    {
        if( status == S_OK && dwZoneType != 0 && !strDataFile.empty() )
        {
            status = DnssrvResetZoneDatabase(    
                            PVD_DNS_LOCAL_SERVER, 
                            strZoneName.data(),
                            dwValue,
                            strDataFile.data() );
            DNS_CHECK_STATUS();
        }
    }

    Done:    
    
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INSTPROV, (
            "%s: zone %s throwing %d\n", fn, strZoneName.c_str(), status ));
        ThrowException( status );
    }

    DNS_DEBUG( INSTPROV, (
        "%s: zone %s returning WBEM_S_NO_ERROR\n", fn, strZoneName.c_str() ));
    return WBEM_S_NO_ERROR;

    #undef DNS_CHECK_STATUS
}



static SCODE
dnsWrapCreateStatistic(
    IWbemClassObject *      pClass,
    IWbemObjectSink *       pHandler,
    DWORD                   dwStatCollection,
    const WCHAR *           pszStatisticName,
    CIMTYPE                 cimType,
    const void *            value
    )
/*++

Routine Description:

    Creates and populates a single DNS statistic object.

Arguments:

    pClass -- MicrosoftDNS_Statistic class object used to spawn new instance

    dwStatCollection -- index into global collection array

    pszStatisticName -- statistic name

    cimType - type of statistic 
                    VT_UI4: value is a DWORD
                    VT_BSTR: value is a pointer to a string

    value - interpret as per cimType

Return Value:

    S_OK or error code.

--*/
{
    CDnsWrap & dns = CDnsWrap::DnsObject();

    CWbemClassObject Inst;
    pClass->SpawnInstance( 0, &Inst);

    Inst.SetProperty( dns.GetServerName(), PVD_DOMAIN_SERVER_NAME );
    Inst.SetProperty( g_StatInfo[ dwStatCollection ].pszName, L"CollectionName" );
    Inst.SetProperty( g_StatInfo[ dwStatCollection ].dwStatId, L"CollectionId" );
    Inst.SetProperty( pszStatisticName, L"Name" );

    if ( cimType == VT_BSTR )
    {
        Inst.SetProperty( ( LPCWSTR ) value, L"StringValue" );
    }
    else
    {
        DWORD dw = ( DWORD ) ( DWORD_PTR ) value;

        Inst.SetProperty( dw, L"Value" );
    }

    pHandler->Indicate( 1, &Inst );

    return S_OK;
}   //  dnsWrapCreateStatistic



static SCODE
dnsWrapAddStatisticsForTypeArray(
    IWbemClassObject *      pClass,
    IWbemObjectSink *       pHandler,
    DWORD                   statCollIdx,
    PWSTR                   pszHeader,
    PDWORD                  pArray
    )
/*++

Routine Description:

    Adds DWORD statistics for each member of a type array.

Arguments:

    pClass -- WMI statistic class

    pHandler -- WMI object sink

    statCollIdx -- index into global stat information array

    pszHeader -- header text used to format statistic description

    pArray -- array of DWORDs for types


Return Value:

    None

--*/
{
    WCHAR sz[ 80 ];

    #define dwStat( pwszName, dwValue )     \
        dnsWrapCreateStatistic(             \
            pClass,                         \
            pHandler,                       \
            statCollIdx,                    \
            pwszName,                       \
            VT_UI4,                         \
            ( void * ) ( DWORD_PTR ) ( dwValue ) );

    for ( DWORD i = 0; i < STATS_TYPE_MAX; i++ )
    {
        if ( i == STATS_TYPE_MIXED || i == STATS_TYPE_UNKNOWN )
        {
            continue;
        }

        wsprintfW(
            sz,
            L"%s for %S type",
            pszHeader,
            Dns_RecordStringForType( ( WORD ) i ) );
        dwStat( sz, pArray[ i ] );
    }

    wsprintfW(
        sz,
        L"%s for unknown type",
        pszHeader );
    dwStat( sz, pArray[ STATS_TYPE_UNKNOWN ] );

    wsprintfW(
        sz,
        L"%s for mixed type",
        pszHeader );
    dwStat( sz, pArray[ STATS_TYPE_MIXED ] );

    #undef dwStat

    return S_OK;
}   //  dnsWrapAddStatisticsForTypeArray

    

static SCODE
dnsWrapHandleSingleStat(
    IWbemClassObject *      pClass,
    IWbemObjectSink *       pHandler,
    PDNSSRV_STAT            pStat
    )
/*++

Routine Description:

    Process a single statistic buffer by creating Statistic object
    instances for each of the members of the stat buffer.

Arguments:

    pClass -- WMI statistic class

    pHandler -- WMI object sink

    pStat -- buffer of stats to process

Return Value:

    None

--*/
{
    SCODE               sc = S_OK;
    const int           szBufferLen = 254;
    WCHAR               szBuffer[ szBufferLen ];
    SAFEARRAY *         psa = NULL;
    SAFEARRAYBOUND      rgsabound[ 1 ] = { 0, 0 };
    int                 statCollIdx = -1;

    //
    //  Get index into g_StatInfo element for this stat.
    //

    for ( int i = 0;
          g_StatInfo[ i ].dwStatId != 0 &&
                g_StatInfo[ i ].dwStatId != pStat->Header.StatId;
          ++i );
    if ( g_StatInfo[ i ].dwStatId != 0 )
    {
        statCollIdx = i;
    }

    //
    //  Macros to creating individual stat objects.
    //

    #define strStat( pwszName, pwszValue )  \
        dnsWrapCreateStatistic(             \
            pClass,                         \
            pHandler,                       \
            statCollIdx,                    \
            pwszName,                       \
            VT_BSTR,                        \
            pwszValue );

    #define dwStat( pwszName, dwValue )     \
        dnsWrapCreateStatistic(             \
            pClass,                         \
            pHandler,                       \
            statCollIdx,                    \
            pwszName,                       \
            VT_UI4,                         \
            ( void * ) ( DWORD_PTR ) ( dwValue ) );

    //
    //  Process the individual statistics in this stat collection.
    //

    switch ( pStat->Header.StatId )
    {
        case DNSSRV_STATID_TIME:
        {
            PDNSSRV_TIME_STATS      pstat = ( PDNSSRV_TIME_STATS ) pStat;
            SYSTEMTIME              localTime;

            SystemTimeToTzSpecificLocalTime(
                NULL,
                ( PSYSTEMTIME ) &pstat->ServerStartTime,
                &localTime );
            GetDateFormatW(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &localTime,
                NULL,
                szBuffer,
                szBufferLen );
            wcscat( szBuffer, L" " );
            GetTimeFormatW(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &localTime,
                NULL,
                szBuffer + wcslen( szBuffer ),
                szBufferLen - wcslen( szBuffer ) );

            strStat( L"Server started", szBuffer );

            SystemTimeToTzSpecificLocalTime(
                NULL,
                ( PSYSTEMTIME ) &pstat->LastClearTime,
                &localTime );
            GetDateFormatW(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &localTime,
                NULL,
                szBuffer,
                szBufferLen );
            wcscat( szBuffer, L" " );
            GetTimeFormatW(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &localTime,
                NULL,
                szBuffer + wcslen( szBuffer ),
                szBufferLen - wcslen( szBuffer ) );

            strStat( L"Statistics last cleared", szBuffer );

            dwStat( L"Seconds since start", pstat->SecondsSinceServerStart );
            dwStat( L"Seconds since statistics cleared", pstat->SecondsSinceLastClear );

            break;
        }

        case DNSSRV_STATID_QUERY:
        {
            PDNSSRV_QUERY_STATS  pstat = ( PDNSSRV_QUERY_STATS ) pStat;

            dwStat( L"Queries received", pstat->UdpQueries + pstat->TcpQueries );
            dwStat( L"Responses sent", pstat->UdpResponses + pstat->TcpResponses );
            dwStat( L"UDP queries received", pstat->UdpQueries );
            dwStat( L"UDP responses sent", pstat->UdpResponses );
            dwStat( L"UDP queries sent", pstat->UdpQueriesSent );
            dwStat( L"UDP responses received", pstat->UdpResponsesReceived );
            dwStat( L"TCP client connections", pstat->TcpClientConnections );
            dwStat( L"TCP queries received", pstat->TcpQueries );
            dwStat( L"TCP responses sent", pstat->TcpResponses );
            dwStat( L"TCP queries sent", pstat->TcpQueriesSent );
            dwStat( L"TCP responses received", pstat->TcpResponsesReceived );
            break;
        }

        case DNSSRV_STATID_QUERY2:
        {
            PDNSSRV_QUERY2_STATS  pstat = ( PDNSSRV_QUERY2_STATS ) pStat;

            dwStat( L"Total queries", pstat->TotalQueries );
            dwStat( L"Notify queries", pstat->Notify );
            dwStat( L"Update queries", pstat->Update );
            dwStat( L"TKeyNego queries", pstat->TKeyNego );
            dwStat( L"Standard queries", pstat->Standard );
            dwStat( L"A queries", pstat->TypeA );
            dwStat( L"NS queries", pstat->TypeNs );
            dwStat( L"SOA queries", pstat->TypeSoa );
            dwStat( L"MX queries", pstat->TypeMx );
            dwStat( L"PTR queries", pstat->TypePtr );
            dwStat( L"SRV queries", pstat->TypeSrv );
            dwStat( L"ALL queries", pstat->TypeAll );
            dwStat( L"IXFR queries", pstat->TypeIxfr );
            dwStat( L"AXFR queries", pstat->TypeAxfr );
            dwStat( L"Other queries", pstat->TypeOther );
            break;
        }

        case DNSSRV_STATID_RECURSE:
        {
            PDNSSRV_RECURSE_STATS  pstat = ( PDNSSRV_RECURSE_STATS ) pStat;

            dwStat( L"Queries recursed", pstat->QueriesRecursed );
            dwStat( L"Original questions recursed", pstat->OriginalQuestionRecursed );
            dwStat( L"Additional questions recursed", pstat->AdditionalRecursed );
            dwStat( L"Total questions recursed", pstat->TotalQuestionsRecursed );
            dwStat( L"Original questions recursed", pstat->OriginalQuestionRecursed );
            dwStat( L"Retries", pstat->Retries );
            dwStat( L"Total passes", pstat->LookupPasses );
            dwStat( L"To forwarders", pstat->Forwards );
            dwStat( L"Sends", pstat->Sends );

            dwStat( L"Total responses", pstat->Responses );
            dwStat( L"Responses unmatched", pstat->ResponseUnmatched );
            dwStat( L"Responses mismatched", pstat->ResponseMismatched );
            dwStat( L"Responses from forwarders", pstat->ResponseFromForwarder );
            dwStat( L"Authoritative responses", pstat->ResponseAuthoritative );
            dwStat( L"NotAuthoritative responses", pstat->ResponseNotAuth );
            dwStat( L"Answer responses", pstat->ResponseAnswer );
            dwStat( L"Empty responses", pstat->ResponseEmpty );
            dwStat( L"Name error responses", pstat->ResponseAnswer );
            dwStat( L"Rcode responses", pstat->ResponseRcode );
            dwStat( L"Delegation responses", pstat->ResponseDelegation );
            dwStat( L"Non-zone data responses", pstat->ResponseNonZoneData );
            dwStat( L"Unsecure responses", pstat->ResponseUnsecure );
            dwStat( L"Bad packet responses", pstat->ResponseBadPacket );

            dwStat( L"Forwarded responses", pstat->SendResponseDirect );
            dwStat( L"Continue current recursion responses", pstat->ContinueCurrentRecursion );
            dwStat( L"Continue current lookup responses", pstat->ContinueCurrentLookup );
            dwStat( L"Continue next lookup responses", pstat->ContinueNextLookup );

            dwStat( L"Send timeouts", pstat->PacketTimeout );
            dwStat( L"Final queued timeouts", pstat->FinalTimeoutQueued );
            dwStat( L"Final timeouts expired", pstat->FinalTimeoutExpired );

            dwStat( L"Recurse failures", pstat->RecursePassFailure );
            dwStat( L"Into authority failures", pstat->FailureReachAuthority );
            dwStat( L"Previous zone failures", pstat->FailureReachPreviousResponse );
            dwStat( L"Retry count failures", pstat->FailureRetryCount );
            dwStat( L"Cache update failures", pstat->CacheUpdateFailure );
            dwStat( L"Server failure responses", pstat->ServerFailure );
            dwStat( L"Total failures", pstat->Failures );

            dwStat( L"TCP recursions tried", pstat->TcpTry );
            dwStat( L"TCP recursion queries", pstat->TcpQuery );
            dwStat( L"TCP recursion responses", pstat->TcpResponse );
            dwStat( L"TCP recursion disconnects", pstat->TcpDisconnect );

            dwStat( L"Cache update queries allocated", pstat->CacheUpdateAlloc );
            dwStat( L"Cache update query responses", pstat->CacheUpdateResponse );
            dwStat( L"Cache update query retries", pstat->CacheUpdateRetry );
            dwStat( L"Cache update queries freed", pstat->CacheUpdateFree );
            dwStat( L"Cache update queries for root NS", pstat->RootNsQuery );
            dwStat( L"Cache update responses for root NS", pstat->RootNsResponse );
            dwStat( L"Cache update queries suspended", pstat->SuspendedQuery );
            dwStat( L"Cache update queries resumed", pstat->ResumeSuspendedQuery );

            break;
        }

        case DNSSRV_STATID_MASTER:
        {
            PDNSSRV_MASTER_STATS pstat = ( PDNSSRV_MASTER_STATS ) pStat;

            dwStat( L"Notifies sent", pstat->NotifySent );
            dwStat( L"Requests", pstat->Request );
            dwStat( L"NameErrors", pstat->NameError );
            dwStat( L"FormErrors", pstat->FormError );
            dwStat( L"Refused", pstat->Refused );
            dwStat( L"AxfrLimit refused", pstat->AxfrLimit );
            dwStat( L"Security refused", pstat->RefuseSecurity );
            dwStat( L"Shutdown refused", pstat->RefuseShutdown );
            dwStat( L"ServFail refused", pstat->RefuseServerFailure );
            dwStat( L"Transfer failures", pstat->Failure );
            dwStat( L"Transfer successes", pstat->AxfrSuccess + pstat->IxfrUpdateSuccess );
            dwStat( L"AXFR requests", pstat->AxfrRequest );
            dwStat( L"AXFR successes", pstat->AxfrSuccess );
            dwStat( L"AXFR in IXFR", pstat->IxfrAxfr );
            dwStat( L"IXFR requests", pstat->IxfrRequest );
            dwStat( L"IXFR successes", pstat->IxfrUpdateSuccess );
            dwStat( L"IXFR UDP requests", pstat->IxfrUdpRequest );
            dwStat( L"IXFR UDP successes", pstat->IxfrUdpSuccess );
            dwStat( L"IXFR UDP force TCP", pstat->IxfrUdpForceTcp );
            dwStat( L"IXFR UDP force AXFR", pstat->IxfrUdpForceAxfr );
            dwStat( L"IXFR TCP requests", pstat->IxfrTcpRequest );
            dwStat( L"IXFR TCP successes", pstat->IxfrTcpSuccess );
            dwStat( L"IXFR TCP force AXFR", pstat->IxfrAxfr );
            break;
        }

        case DNSSRV_STATID_SECONDARY:
        {
            PDNSSRV_SECONDARY_STATS pstat = (PDNSSRV_SECONDARY_STATS)pStat;

            dwStat( L"Notifies received", pstat->NotifyReceived );
            dwStat( L"Notifies invalid", pstat->NotifyInvalid );
            dwStat( L"Notifies primary", pstat->NotifyPrimary );
            dwStat( L"Notifies no version", pstat->NotifyNoVersion );
            dwStat( L"Notifies new version", pstat->NotifyNewVersion );
            dwStat( L"Notifies current version", pstat->NotifyCurrentVersion );
            dwStat( L"Notifies old version", pstat->NotifyOldVersion );
            dwStat( L"Notifies master unknown", pstat->NotifyMasterUnknown );

            dwStat( L"SOA requests", pstat->SoaRequest );
            dwStat( L"SOA responses", pstat->SoaResponse );
            dwStat( L"SOA invalid responses", pstat->SoaResponseInvalid );
            dwStat( L"SOA NameError responses", pstat->SoaResponseNameError );

            dwStat( L"AXFR requests", pstat->AxfrRequest );
            dwStat( L"AXFR in IXFR requests", pstat->IxfrTcpAxfr );
            dwStat( L"AXFR responses", pstat->AxfrResponse );
            dwStat( L"AXFR success responses", pstat->AxfrSuccess );
            dwStat( L"AXFR refused responses", pstat->AxfrRefused );
            dwStat( L"AXFR invalid responses", pstat->AxfrInvalid );

            dwStat( L"Stub zone AXFR requests", pstat->StubAxfrRequest );
            dwStat( L"Stub zone AXFR responses", pstat->StubAxfrResponse );
            dwStat( L"Stub zone AXFR success responses", pstat->StubAxfrSuccess );
            dwStat( L"Stub zone AXFR refused responses", pstat->StubAxfrRefused );
            dwStat( L"Stub zone AXFR invalid responses", pstat->StubAxfrInvalid );

            dwStat( L"IXFR UDP requests", pstat->IxfrUdpRequest );
            dwStat( L"IXFR UDP responses", pstat->IxfrUdpResponse );
            dwStat( L"IXFR UDP success responses", pstat->IxfrUdpSuccess );
            dwStat( L"IXFR UDP UseTcp responses", pstat->IxfrUdpUseTcp );
            dwStat( L"IXFR UDP UseAxfr responses", pstat->IxfrUdpUseAxfr );
            dwStat( L"IXFR UDP new primary responses", pstat->IxfrUdpNewPrimary );
            dwStat( L"IXFR UDP refused responses", pstat->IxfrUdpRefused );
            dwStat( L"IXFR UDP wrong server responses", pstat->IxfrUdpWrongServer );
            dwStat( L"IXFR UDP FormError responses", pstat->IxfrUdpFormerr );
            dwStat( L"IXFR UDP invalid responses", pstat->IxfrUdpInvalid );

            dwStat( L"IXFR TCP requests", pstat->IxfrTcpRequest );
            dwStat( L"IXFR TCP responses", pstat->IxfrTcpResponse );
            dwStat( L"IXFR TCP success responses", pstat->IxfrTcpSuccess );
            dwStat( L"IXFR TCP AXFR responses", pstat->IxfrTcpAxfr );
            dwStat( L"IXFR TCP FormError responses", pstat->IxfrTcpFormerr );
            dwStat( L"IXFR TCP refused responses", pstat->IxfrTcpRefused );
            dwStat( L"IXFR TCP invalid responses", pstat->IxfrTcpInvalid );
            break;
        }

        case DNSSRV_STATID_WINS:
        {
            PDNSSRV_WINS_STATS  pstat = ( PDNSSRV_WINS_STATS ) pStat;

            dwStat( L"WINS forward lookups", pstat->WinsLookups );
            dwStat( L"WINS forward lookup responses", pstat->WinsResponses );
            dwStat( L"WINS reverse lookups", pstat->WinsReverseLookups );
            dwStat( L"WINS reverse lookup responses", pstat->WinsReverseResponses );
            break;
        }

        case DNSSRV_STATID_NBSTAT:
        {
            PDNSSRV_NBSTAT_STATS  pstat = (PDNSSRV_NBSTAT_STATS)pStat;

            dwStat( L"Nbstat total buffers allocated", pstat->NbstatAlloc );
            dwStat( L"Nbstat total buffers freed", pstat->NbstatFree );
            dwStat( L"Nbstat net buffers allocated", pstat->NbstatNetAllocs );
            dwStat( L"Nbstat net bytes allocated", pstat->NbstatMemory );
            dwStat( L"Nbstat memory highwater mark", pstat->NbstatUsed );
            dwStat( L"Nbstat buffers returned", pstat->NbstatReturn );
            dwStat( L"Nbstat buffers in use", pstat->NbstatInUse );
            dwStat( L"Nbstat buffers on free list", pstat->NbstatInFreeList );
            break;
        }

        case DNSSRV_STATID_WIRE_UPDATE:
        case DNSSRV_STATID_NONWIRE_UPDATE:
        {
            PDNSSRV_UPDATE_STATS  pstat = ( PDNSSRV_UPDATE_STATS ) pStat;

            dwStat( L"Updates received", pstat->Received );
            dwStat( L"Updates forwarded", pstat->Forwards );
            dwStat( L"Updates retried", pstat->Retry );
            dwStat( L"Updates empty (precon only)", pstat->Empty );
            dwStat( L"Updates NoOps (duplicates)", pstat->NoOps );
            dwStat( L"Updates rejected", pstat->Rejected );
            dwStat( L"Updates completed", pstat->Completed );
            dwStat( L"Updates timed out", pstat->Timeout );
            dwStat( L"Updates in queue", pstat->InQueue );

            dwStat( L"Updates rejected", pstat->Rejected );
            dwStat( L"Updates rejected with FormError", pstat->FormErr );
            dwStat( L"Updates rejected with NameError", pstat->NxDomain );
            dwStat( L"Updates rejected with NotImpl", pstat->NotImpl );
            dwStat( L"Updates rejected with Refused", pstat->Refused );
            dwStat( L"Updates rejected with Refused (nonsecure)", pstat->RefusedNonSecure );
            dwStat( L"Updates rejected with Refused (access denied)", pstat->RefusedAccessDenied );
            dwStat( L"Updates rejected with YxDomain", pstat->YxDomain );
            dwStat( L"Updates rejected with YxRRSet", pstat->YxRrset );
            dwStat( L"Updates rejected with NxRRSet", pstat->NxRrset );
            dwStat( L"Updates rejected with NotAuth", pstat->NotAuth );
            dwStat( L"Updates rejected with NotZone", pstat->NotZone );


            dwStat( L"Secure update successes", pstat->SecureSuccess );
            dwStat( L"Secure update continues", pstat->SecureContinue );
            dwStat( L"Secure update failures", pstat->SecureFailure );
            dwStat( L"Secure update DS write failures", pstat->SecureDsWriteFailure );

            dwStat( L"Updates forwarded via TCP", pstat->TcpForwards );
            dwStat( L"Responses for forwarded updates", pstat->ForwardResponses );
            dwStat( L"Timeouts for forwarded updates", pstat->ForwardTimeouts );
            dwStat( L"Forwarded updates in queue", pstat->ForwardInQueue );

            dnsWrapAddStatisticsForTypeArray(
                pClass,
                pHandler,
                statCollIdx,
                L"Updates",
                pstat->UpdateType );
            break;
        }

        case DNSSRV_STATID_DS:
        {
            PDNSSRV_DS_STATS  pstat = ( PDNSSRV_DS_STATS ) pStat;

            dwStat( L"Nodes read", pstat->DsTotalNodesRead );
            dwStat( L"Records read", pstat->DsTotalRecordsRead );
            dwStat( L"Nodes loaded", pstat->DsNodesLoaded );
            dwStat( L"Records loaded", pstat->DsRecordsLoaded );
            dwStat( L"Update searches", pstat->DsUpdateSearches );
            dwStat( L"Update nodes read", pstat->DsUpdateNodesRead );
            dwStat( L"Update records read", pstat->DsUpdateRecordsRead );

            dwStat( L"Nodes added", pstat->DsNodesAdded );
            dwStat( L"Nodes modified", pstat->DsNodesModified );
            dwStat( L"Nodes tombstoned", pstat->DsNodesTombstoned );
            dwStat( L"Tombstones read", pstat->DsTombstonesRead );
            dwStat( L"Nodes deleted", pstat->DsNodesDeleted );
            dwStat( L"Nodes write suppressed", pstat->DsWriteSuppressed );
            dwStat( L"RR sets added", pstat->DsRecordsAdded );
            dwStat( L"RR sets replaced", pstat->DsRecordsReplaced );
            dwStat( L"Serial number writes", pstat->DsSerialWrites );
    
            dwStat( L"Update lists", pstat->UpdateLists );
            dwStat( L"Update nodes", pstat->UpdateNodes );
            dwStat( L"Updates suppressed ", pstat->UpdateSuppressed );
            dwStat( L"Update writes", pstat->UpdateWrites );
            dwStat( L"Update tombstones", pstat->UpdateTombstones );
            dwStat( L"Update record changes", pstat->UpdateRecordChange );
            dwStat( L"Update aging refresh", pstat->UpdateAgingRefresh );
            dwStat( L"Update aging on", pstat->UpdateAgingOn );
            dwStat( L"Update aging off", pstat->UpdateAgingOff );
            dwStat( L"Update from packet", pstat->UpdatePacket );
            dwStat( L"Update from packet (precon)", pstat->UpdatePacketPrecon );
            dwStat( L"Update from admin", pstat->UpdateAdmin );
            dwStat( L"Update from auto config", pstat->UpdateAutoConfig );
            dwStat( L"Update from scavenge", pstat->UpdateScavenge );

            dwStat( L"LDAP timed writes", pstat->LdapTimedWrites );
            dwStat( L"LDAP total write time", pstat->LdapWriteTimeTotal );
            dwStat( L"LDAP average write time", pstat->LdapWriteAverage );
            dwStat( L"LDAP writes < 10 ms", pstat->LdapWriteBucket0 );
            dwStat( L"LDAP writes < 100 ms", pstat->LdapWriteBucket1 );
            dwStat( L"LDAP writes < 1 s", pstat->LdapWriteBucket2 );
            dwStat( L"LDAP writes < 10 s", pstat->LdapWriteBucket3 );
            dwStat( L"LDAP writes < 100 s", pstat->LdapWriteBucket4 );
            dwStat( L"LDAP writes > 100 s", pstat->LdapWriteBucket5 );
            dwStat( L"LDAP writes max timeout", pstat->LdapWriteMax );

            dwStat( L"Total LDAP search time", pstat->LdapSearchTime );

            dwStat( L"Failed deletions", pstat->FailedDeleteDsEntries );
            dwStat( L"Failed reads", pstat->FailedReadRecords );
            dwStat( L"Failed modifies", pstat->FailedLdapModify );
            dwStat( L"Failed adds", pstat->FailedLdapAdd );

            dwStat( L"Polling passes with DS errors", pstat->PollingPassesWithDsErrors );

            dwStat( L"LDAP reconnects", pstat->LdapReconnects );

            dnsWrapAddStatisticsForTypeArray(
                pClass,
                pHandler,
                statCollIdx,
                L"LDAP writes",
                pstat->DsWriteType );
            break;
        }

        case DNSSRV_STATID_SKWANSEC:
        {
            PDNSSRV_SKWANSEC_STATS pstat = ( PDNSSRV_SKWANSEC_STATS ) pStat;

            dwStat( L"Security contexts created", pstat->SecContextCreate );
            dwStat( L"Security contexts freed", pstat->SecContextFree );
            dwStat( L"Security contexts timed out", pstat->SecContextTimeout );
            dwStat( L"Security contexts queue length", pstat->SecContextQueueLength );
            dwStat( L"Security contexts queued", pstat->SecContextQueue );
            dwStat( L"Security contexts queued in negotiation", pstat->SecContextQueueInNego );
            dwStat( L"Security contexts queued negotiation complete", pstat->SecContextQueueNegoComplete );
            dwStat( L"Security contexts dequeued", pstat->SecContextDequeue );

            dwStat( L"Security packet contexts allocated", pstat->SecPackAlloc );
            dwStat( L"Security packet contexts freed", pstat->SecPackFree );

            dwStat( L"Invalid TKEYs", pstat->SecTkeyInvalid );
            dwStat( L"Bad time TKEYs", pstat->SecTkeyBadTime );

            dwStat( L"FormErr TSIGs", pstat->SecTsigFormerr );
            dwStat( L"Echo TSIGs", pstat->SecTsigEcho );
            dwStat( L"BadKey TSIGs", pstat->SecTsigBadKey );
            dwStat( L"Verify success TSIGs", pstat->SecTsigVerifySuccess );
            dwStat( L"Verify failed TSIGs", pstat->SecTsigVerifyFailed );
            break;
        }

        case DNSSRV_STATID_MEMORY:
        {
            PDNSSRV_MEMORY_STATS pstat = ( PDNSSRV_MEMORY_STATS ) pStat;
            LPSTR * pnameArray = MemTagStrings;
            DWORD   count = MEMTAG_COUNT;

            dwStat( L"Total memory", pstat->StdUsed );
            dwStat( L"Allocation count", pstat->Alloc );
            dwStat( L"Free count", pstat->Free );

            dwStat( L"Standard allocs used", pstat->StdUsed );
            dwStat( L"Standard allocs returned", pstat->StdReturn );
            dwStat( L"Standard allocs in use", pstat->StdInUse );
            dwStat( L"Standard allocs memory", pstat->StdMemory );

            dwStat( L"Standard to heap allocs used", pstat->StdToHeapAlloc );
            dwStat( L"Standard to heap allocs returned", pstat->StdToHeapFree );
            dwStat( L"Standard to heap allocs in use", pstat->StdToHeapInUse );
            dwStat( L"Standard to heap allocs memory", pstat->StdToHeapMemory );

            dwStat( L"Standard blocks allocated", pstat->StdBlockAlloc );
            dwStat( L"Standard blocks used", pstat->StdBlockUsed );
            dwStat( L"Standard blocks returned", pstat->StdBlockReturn );
            dwStat( L"Standard blocks in use", pstat->StdBlockInUse );
            dwStat( L"Standard blocks in free list", pstat->StdBlockFreeList );
            dwStat( L"Standard block memory in free list", pstat->StdBlockFreeListMemory );
            dwStat( L"Standard block total memory", pstat->StdBlockMemory );

            for ( DWORD i = 0; i < count; ++i )
            {
                WCHAR sz[ 80 ];

                wsprintfW( sz, L"%S blocks allocated", pnameArray[ i ] );
                dwStat( sz, pstat->MemTags[ i ].Alloc );
                wsprintfW( sz, L"%S blocks freed", pnameArray[ i ] );
                dwStat( sz, pstat->MemTags[ i ].Free );
                wsprintfW( sz, L"%S blocks in use", pnameArray[ i ] );
                dwStat( sz, pstat->MemTags[ i ].Alloc - pstat->MemTags[ i ].Free );
                wsprintfW( sz, L"%S memory", pnameArray[ i ] );
                dwStat( sz, pstat->MemTags[ i ].Memory );
            }
            break;
        }

        case DNSSRV_STATID_DBASE:
        {
            PDNSSRV_DBASE_STATS  pstat = ( PDNSSRV_DBASE_STATS ) pStat;

            dwStat( L"Database nodes used", pstat->NodeUsed );
            dwStat( L"Database nodes returned", pstat->NodeReturn );
            dwStat( L"Database nodes in use", pstat->NodeInUse );
            dwStat( L"Database nodes memory", pstat->NodeMemory );
            break;
        }

        case DNSSRV_STATID_RECORD:
        {
            PDNSSRV_RECORD_STATS  pstat = ( PDNSSRV_RECORD_STATS ) pStat;

            dwStat( L"Records used", pstat->Used );
            dwStat( L"Records returned", pstat->Return );
            dwStat( L"Records in use", pstat->InUse );
            dwStat( L"Records memory", pstat->Memory );
            dwStat( L"Records queued for slow free", pstat->SlowFreeQueued );
            dwStat( L"Records slow freed", pstat->SlowFreeFinished );
            dwStat( L"Total records cached", pstat->CacheTotal );
            dwStat( L"Records currently cached", pstat->CacheCurrent );
            dwStat( L"Cached records timed out", pstat->CacheTimeouts );
            break;
        }

        case DNSSRV_STATID_PACKET:
        {
            PDNSSRV_PACKET_STATS  pstat = ( PDNSSRV_PACKET_STATS ) pStat;

            dwStat( L"UDP messages allocated", pstat->UdpAlloc );
            dwStat( L"UDP messages freed", pstat->UdpFree );
            dwStat( L"UDP messages net allocations", pstat->UdpNetAllocs );
            dwStat( L"UDP messages memory", pstat->UdpMemory );
            dwStat( L"UDP messages used", pstat->UdpUsed );
            dwStat( L"UDP messages returned", pstat->UdpReturn );
            dwStat( L"UDP messages in use", pstat->UdpInUse );
            dwStat( L"UDP messages in free list", pstat->UdpInFreeList );

            dwStat( L"UDP messages allocated", pstat->TcpAlloc );
            dwStat( L"UDP messages reallocated", pstat->TcpRealloc );
            dwStat( L"UDP messages freed", pstat->TcpFree );
            dwStat( L"UDP messages net allocations", pstat->TcpNetAllocs );
            dwStat( L"UDP messages memory", pstat->TcpMemory );

            dwStat( L"Recursion messages used", pstat->RecursePacketUsed );
            dwStat( L"Recursion messages returned", pstat->RecursePacketReturn );
            break;
        }

        case DNSSRV_STATID_TIMEOUT:
        {
            PDNSSRV_TIMEOUT_STATS  pstat = ( PDNSSRV_TIMEOUT_STATS ) pStat;

            dwStat( L"Nodes queued", pstat->SetTotal );
            dwStat( L"Nodes directed queued", pstat->SetDirect );
            dwStat( L"Nodes queued from reference", pstat->SetFromDereference );
            dwStat( L"Nodes queued from child delete", pstat->SetFromChildDelete );
            dwStat( L"Nodes duplicate (already queued)", pstat->AlreadyInSystem );

            dwStat( L"Nodes checked", pstat->Checks );
            dwStat( L"Recent access nodes checked", pstat->RecentAccess );
            dwStat( L"Active record nodes checked", pstat->ActiveRecord );
            dwStat( L"Can not delete nodes checked", pstat->CanNotDelete );
            dwStat( L"Deleted nodes checked", pstat->Deleted );

            dwStat( L"Timeout blocks created", pstat->ArrayBlocksCreated );
            dwStat( L"Timeout blocks deleted", pstat->ArrayBlocksDeleted );

            dwStat( L"Delayed frees queued", pstat->DelayedFreesQueued );
            dwStat( L"Delayed frees queued with function", pstat->DelayedFreesQueuedWithFunction );
            dwStat( L"Delayed frees executed", pstat->DelayedFreesExecuted );
            dwStat( L"Delayed frees executed with function", pstat->DelayedFreesExecutedWithFunction );
            break;
        }

        case DNSSRV_STATID_ERRORS:
        {
            PDNSSRV_ERROR_STATS pstat = ( PDNSSRV_ERROR_STATS ) pStat;

            dwStat( L"NoError", pstat->NoError );
            dwStat( L"FormError", pstat->FormError );
            dwStat( L"ServFail", pstat->ServFail );
            dwStat( L"NxDomain", pstat->NxDomain );
            dwStat( L"NotImpl", pstat->NotImpl );
            dwStat( L"Refused", pstat->Refused );
            dwStat( L"YxDomain", pstat->YxDomain );
            dwStat( L"YxRRSet", pstat->YxRRSet );
            dwStat( L"NxRRSet", pstat->NxRRSet );
            dwStat( L"NotAuth", pstat->NotAuth );
            dwStat( L"NotZone", pstat->NotZone );
            dwStat( L"Max", pstat->Max );
            dwStat( L"BadSig", pstat->BadSig );
            dwStat( L"BadKey", pstat->BadKey );
            dwStat( L"BadTime", pstat->BadTime );
            dwStat( L"UnknownError", pstat->UnknownError );
            break;
        }

        case DNSSRV_STATID_CACHE:
        {
            PDNSSRV_CACHE_STATS pstat = ( PDNSSRV_CACHE_STATS ) pStat;

            dwStat( L"Checks where cache exceeded limit", pstat->CacheExceededLimitChecks );
            dwStat( L"Successful cache enforcement passes", pstat->SuccessfulFreePasses );
            dwStat( L"Failed cache enforcement passes", pstat->FailedFreePasses );
            dwStat( L"Passes requiring aggressive free", pstat->PassesRequiringAggressiveFree );
            dwStat( L"Passes where nothing was freed", pstat->PassesWithNoFrees );
            break;
        }

        default:
            break;
    }

    //
    //  Cleanup and return.
    //

    return sc;
}



SCODE
CDnsWrap::dnsGetStatistics(
    IWbemClassObject *  pClass,
    IWbemObjectSink *   pHandler,
    DWORD               dwStatId
    )
/*++

Routine Description:

    Retrieve DNS statistics.

Arguments:

    dwStatId -- statistic ID or zero for all

    pClass -- ptr to StatisticsCollection class object

Return Value:

    None

--*/
{
    SCODE               sc = S_OK;
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_RPC_BUFFER     pstatbuff = NULL;
    BSTR                bstrStatClass = NULL;
    IWbemClassObject *  pStatClass = NULL;

    //
    //  Retrieve RPC stat buffer from server.
    //

    if ( dwStatId == 0 )
    {
        dwStatId = DNSSRV_STATID_ALL;
    }
    status = DnssrvGetStatistics(
                PVD_DNS_LOCAL_SERVER, 
                dwStatId,
                &pstatbuff );
    if ( status != ERROR_SUCCESS )
    {
        ThrowException( status );
    }
    if ( !pstatbuff )
    {
        ThrowException( ERROR_NO_DATA );
    }

    //
    //  Iterate stats in buffer. Add each "single stat" in the buffer
    //  to the WMI instance as a StatisticCollection. Add each individual
    //  statistics in each "single stat" buffer as a value to that
    //  statistic collection.
    //

    PDNSSRV_STAT    pstat;
    PBYTE           pch = pstatbuff ? &pstatbuff->Buffer[ 0 ] : NULL;
    PBYTE           pchstop = pstatbuff ? pch + pstatbuff->dwLength : NULL;

    while ( sc == S_OK && pch < pchstop )
    {
        pstat = ( PDNSSRV_STAT ) pch;
        pch = ( PBYTE ) GET_NEXT_STAT_IN_BUFFER( pstat );

        sc = dnsWrapHandleSingleStat( pClass, pHandler, pstat );
        if ( sc != S_OK )
        {
            break;
        }
    }

    //
    //  Cleanup and return.
    //

    SysFreeString( bstrStatClass );
    if ( pstatbuff )
    {
        MIDL_user_free( pstatbuff );
    }
    if ( pStatClass )
    {
        pStatClass->Release();
    }
    return sc;
}   //  CDnsWrap::dnsGetStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnsstatistics.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnscache.h
//
//	Implementation File:
//		dnscache.cpp
//
//	Description:
//		Definition of the CDnsStatistic class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


#include "dnsbase.h"

class CObjPath;


/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsStatistic
//
//	Description:
//
//      Class definition for DNS Server statistics
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsStatistic : CDnsBase
{
public:
	CDnsStatistic();

	CDnsStatistic(
		const WCHAR*, 
		CWbemServices*
        );

	~CDnsStatistic();

	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler
        );

	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 

	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pResponseHandler 
		); 

    static CDnsBase * CreateThis(
        const WCHAR *       wszName,
        CWbemServices *     pNamespace,
        const char *        szType
        );
};  //  CDnsStatistic
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnszone.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnszone.h
//
//	Implementation File:
//		dnszone.cpp
//
//	Description:
//		Definition of the CDnsZone.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"
class CObjPath;


class CDnsZone  : CDnsBase
{
public:
	CDnsZone();
	CDnsZone(
		const WCHAR*, 
		CWbemServices*
		);
	~CDnsZone();

	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 
	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pHandler 
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnswmi.h ===
/////////////////////////////////////////////////////////////////////////////
//
//      Copyright (c) 1999 Microsoft Corporation
//
//      Module Name:
//              wmi.h
//
//      Description:
//              Pre-compiled header file for DNS WMI provider project
//
//      Author:
//              Jeff Westhead (jwesth)      December 2000
//
//      Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include "DnsCliP.h"            //  private DNS client header

#include "ntrkcomm.h"

#include <initguid.h>

#include <string>
#include <list>
#include <memory>

#include "ProvFactory.h"
#include "InstanceProv.h"

#include <tchar.h>

#include "common.h"
#include "InstanceProv.h"
#include "Dnsbase.h"
#include "ObjectPath.h"
#include "sql_1.h"
#include "genlex.h"
#include "sqleval.h"
#include "Server.h"
#include "DnsDomain.h"
#include "DnsBase.h"
#include "DnsWrap.h"
#include "DnsCache.h"
#include "Dnsdomain.h"
#include "DnsZone.h"
#include "DnsDomainDomainContainment.h"
#include "DnsDomainResourceRecordContainment.h"
#include "DnsResourceRecord.h"
#include "DnsRootHints.h"
#include "DnsServerDomainContainment.h"
#include "DnsStatistics.h"
#include "DnsRpcRecord.h"

#include <crtdbg.h>
#include <atlbase.h>


//
//  Debug logging
//


extern DWORD        DnsWmiDebugFlag;


#if DBG

#define DNSWMI_DBG_LOG_DIR              "\\system32\\WBEM\\Logs\\"
#define DNSWMI_DBG_FLAG_FILE_NAME       "DnsWmi"
#define DNSWMI_DBG_LOG_FILE_BASE_NAME   "DnsWmi"
#define DNSWMI_DBG_LOG_FILE_WRAP        10000000

#define IF_DEBUG(a)         if ( (DnsWmiDebugFlag & DNS_DEBUG_ ## a) )
#define ELSE_IF_DEBUG(a)    else if ( (DnsWmiDebugFlag & DNS_DEBUG_ ## a) )

#define DNS_DEBUG( _flag_, _print_ )    \
        IF_DEBUG( _flag_ )              \
        {                               \
            (DnsDbg_Printf _print_ );   \
        }

//
//  Debug flags. Some of these flags are shared with DNSRPC.LIB
//

#define DNS_DEBUG_BREAKPOINTS   0x00000001
#define DNS_DEBUG_DEBUGGER      0x00000002
#define DNS_DEBUG_FILE          0x00000004

//  #define DNS_DEBUG_RPC       0x00000100
//  #define DNS_DEBUG_STUB      0x00000100

#define DNS_DEBUG_INIT          0x00000010
#define DNS_DEBUG_INSTPROV      0x00000020
#define DNS_DEBUG_RPCRR         0x00000040

#define DNS_DEBUG_START_BREAK   0x80000000

#define DNS_DEBUG_ALL           0xffffffff
#define DNS_DEBUG_ANY           0xffffffff
#define DNS_DEBUG_OFF           (0)

#else

#define IF_DEBUG(a)                 if (0)
#define ELSE_IF_DEBUG(a)            else if (0)

#define DNS_DEBUG( flag, print )

#endif


//
//  If you like having a local variable in functions to hold the function 
//  name so that you can include it in debug logs without worrying about 
//  changing all the occurences when the function is renamed, use this 
//  at the top of the function:
//      DBG_FN( "MyFunction" )      <--- NOTE: no semi-colon!!
//

#if DBG
#define DBG_FN( funcName ) static const char * fn = (funcName);
#else
#define DBG_FN( funcName )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnswrap.h ===
/////////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 1999 Microsoft Corporation
//
//    Module Name:
//        dnswrap.h
//
//    Implementation File:
//        dnswrap.cpp
//
//    Description:
//        Definition of the CDnsDomainDomainContainment class.
//
//    Author:
//        Henry Wang (Henrywa)    March 8, 2000
//
//    Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include <list>
class CObjPath;
class CDomainNode;
class CWbemClassObject;
using namespace std;
/////////////////////////////////////////////////////////////////////////////
//++
//
//    class CDnsBase
//
//    Description:
//  this is a wrap class for dns rpc API used in the provider. This class is
//  implemented as singlton class, that's at any time, there is only one instance
//  of this class.
//  
//
//    Inheritance:
//    
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsWrap  
{
protected:
// some def
    typedef SCODE (*FPDNSOPS)(
        const CHAR * pszZoneName,
        const WCHAR*,
        const CHAR*,
        CWbemClassObject&);
    //
    // map wbem property get and set to dns functions
    //
    typedef struct _table
    {
        const WCHAR* pwzProperty;//wbem property name
        CHAR*  OperationName;    // dns operation name
        FPDNSOPS fpOperationSet;
        FPDNSOPS fpOperationGet;
    } PropertyTable;

    //
    // dns server info class
    //
    class CServerInfo
    {
    public:
        CServerInfo();
        ~CServerInfo();
        PVOID m_pInfo;
    };
// end def
    WCHAR* m_wszpServerName;

    PVOID GetPropertyTable(
        DWORD*  pdwSize
        );

public:
    typedef enum{
        DNS_WRAP_RELOAD_ZONE,
        DNS_WRAP_DS_UPDATE,
        DNS_WRAP_WRITE_BACK_ZONE,
        DNS_WRAP_REFRESH_SECONDARY,
        DNS_WRAP_RESUME_ZONE,
        DNS_WRAP_PAUSE_ZONE
        } OpsFlag;

    SCODE dnsClearCache(void);

    SCODE dnsAgeAllRecords(
        const char *    pszZoneName, 
        const char *    pszNodeName, 
        BOOL            bAgeSubtree
        );

    SCODE dnsResumeZone(
        const char* strZoneName
        );

    wstring GetServerName(void);

    SCODE dnsPauseZone(
        const char *strZoneName
        );

    static CDnsWrap& DnsObject(void);

    CDnsWrap();

    virtual ~CDnsWrap();

    SCODE dnsEnumRecordsForDomainEx(
        CDomainNode&        objNode,
        PVOID                pFilter,
        FILTER              pfFilter,
        BOOL                bRecursive,
        WORD                wType,
        DWORD               dwFlag,
        IWbemClassObject *  pClass,
        CWbemInstanceMgr&   InstMgr
        );
    SCODE dnsGetDomain(
        CObjPath&           objParent,
        IWbemClassObject*   pClass,
        IWbemObjectSink*    pHandler
        );
    SCODE dnsEnumDomainForServer(
        list<CObjPath>* pList
        );
    SCODE dnsEnumDomainForServer(
        list<CDomainNode>* pList 
        );
    SCODE dnsDeleteDomain(
        char *  pszContainer, 
        char *  pszDomain
        );
    SCODE dnsRestartServer(
        WCHAR* strServerName 
        );
    SCODE dnsDsServerName(
        wstring&);
    SCODE dnsDsZoneName(
        wstring& wstrDsName,
        wstring& wstrInZone
        );
    SCODE dnsDsNodeName(
        wstring&    wstrDsName,
        wstring&    wstrInZone,
        wstring&    wstrInNode
        );
    SCODE dnsServerPropertySet(
        CWbemClassObject&   Inst,
        BOOL                bGet
        );
    SCODE dnsServerPropertyGet(
        CWbemClassObject&   Inst,
        BOOL                bGet
        );
    SCODE dnsQueryServerInfo(
        const WCHAR*        strServerName,
        CWbemClassObject&   NewInst,
        IWbemObjectSink*    pHandler
        );
    SCODE dnsDeleteZone(
        CObjPath&   objZone
        );
    SCODE dnsGetZone(
        const WCHAR*        wszServer, 
        const WCHAR*        wszZone,
        CWbemClassObject&   Inst,
        IWbemObjectSink*    pHandler
        );
    SCODE dnsQueryProperty(
        const WCHAR*    wszZoneName, 
        const WCHAR*    wszPropertyName, 
        DWORD*          pdwResult
        );

    static SCODE dnsGetDwordProperty(
        const char *        pszZoneName,
        const WCHAR*        wszWbemProperty, 
        const char*         pszOperationName,
        CWbemClassObject&   Inst
        );
    
    static SCODE dnsSetDwordProperty(
        const char *        pszZoneName,
        const WCHAR*        wszWbemProperty, 
        const char*         pszOperationName,
        CWbemClassObject&   Inst
        );

    static SCODE 
    dnsGetStringProperty(
        const char *        pszZoneName,
        const WCHAR *       wszWbemProperty, 
        const char *        pszDnssrvPropertyName,
        CWbemClassObject&   Inst
        );

    static SCODE 
    dnsSetStringProperty(
        const char *        pszZoneName,
        const WCHAR *       wszWbemProperty, 
        const char *        pszDnssrvPropertyName,
        CWbemClassObject&   Inst
        );

    static SCODE 
    dnsGetIPArrayProperty(
        const char *        pszZoneName,
        const WCHAR *       wszWbemProperty, 
        const char *        pszDnssrvPropertyName,
        CWbemClassObject&   Inst
        );

    static SCODE 
    dnsSetIPArrayProperty(
        const char *        pszZoneName,
        const WCHAR *       wszWbemProperty, 
        const char *        pszDnssrvPropertyName,
        CWbemClassObject&   Inst
        );

    static SCODE dnsSetServerListenAddress(
        const char *        pszZoneName,
        const WCHAR*        wszWbemProperty, 
        const char*         pszOperationName,
        CWbemClassObject&   Inst
        );

    static SCODE dnsSetServerForwarders(
        const char *        pszZoneName,
        const WCHAR*        wszWbemProperty, 
        const char*         pszOperationName,
        CWbemClassObject&   Inst
        );

    SCODE dnsSetProperty(
        const WCHAR*    wszZoneName, 
        const char*     pszPropertyName, 
        DWORD           dwValue
        );

    SCODE dnsSetProperty(
        const char*     pszZoneName, 
        const char*     pszPropertyName, 
        DWORD           dwValue
        );

    SCODE ValidateServerName(
        const WCHAR*    pwzStr
        );

    SCODE dnsOperation(
        string&,    //zone name
        OpsFlag
        );

    SCODE dnsZoneCreate(
        string &    strZoneName,
        DWORD       dwZoneType,
        BOOL        DsIntegrated,
        string &    strDataFile,
        string &    strAdmin,
        DWORD *     pIp,
        DWORD       cIp
        );

    SCODE dnsZoneChangeType(
        string &    strZone,
        DWORD       dwZoneType,
        BOOL        DsIntegrated,
        string &    strDataFile,
        string &    strAdmin,
        DWORD *     pIp,
        DWORD       cIp
        );

    SCODE dnsZoneResetMaster(
        string& strZoneName,
        DWORD*  pMasterIp,
        DWORD   cMasterIp,
        DWORD   dwLocal
        );

    SCODE dnsZoneResetSecondary(
        string& strZoneName,
        DWORD   dwSecurity,
        DWORD*  pSecondaryIp,
        DWORD   cSecondaryIp,
        DWORD   dwNotify,
        DWORD * pNotifyIp,
        DWORD   cNotifyIp
        );

    SCODE dnsZonePut(
        CWbemClassObject& Inst
        );

    SCODE
    CDnsWrap::dnsGetStatistics(
        IWbemClassObject *  pClass,
        IWbemObjectSink *   pHandler,
        DWORD               dwStatId = 0
        );

    static void ThrowException(
        LONG    status
        );
    static void ThrowException(
        LPCSTR ErrString
        );

    static SCODE
    buildIpArrayFromStringArrayProperty(
        CWbemClassObject &  Inst,
        LPCWSTR             wszWbemProperty,
        PIP_ARRAY *         ppIpArray
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\dnszone.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: dnszone.cpp
//
//  Description:    
//      Implementation of CDnsZone class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        create an instance of CDnsZone
//
//    Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsZone::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsZone(wszName, pNamespace);
}


CDnsZone::CDnsZone()
{
}


CDnsZone::CDnsZone(
    const WCHAR* wszName,
    CWbemServices *pNamespace)
    :CDnsBase(wszName, pNamespace)
{
}


CDnsZone::~CDnsZone()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enum instances of dns zone
//
//    Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsZone::EnumInstance( 
    long                lFlags,
    IWbemContext *        pCtx,
    IWbemObjectSink *    pHandler)
{
    list<CDomainNode> opList;
    list<CDomainNode>::iterator i;
    SCODE sc;
    CDnsWrap& dns = CDnsWrap::DnsObject();
    sc = dns.dnsEnumDomainForServer(&opList);
    if (FAILED(sc))
    {
        return sc;
    }


    for(i=opList.begin(); i!=opList.end(); ++i)
    {
        if(_wcsicmp(i->wstrZoneName.data(), PVD_DNS_CACHE)  &&
            _wcsicmp(i->wstrZoneName.data(), PVD_DNS_ROOTHINTS) )
        {
            CWbemClassObject Inst;
            m_pClass->SpawnInstance(0, &Inst);
            sc = dns.dnsGetZone(
                dns.GetServerName().data(),
                i->wstrZoneName.data(),
                Inst,
                pHandler);
            if ( SUCCEEDED ( sc ) )
            {
                pHandler->Indicate(1, &Inst);
            }
            
        }
    }

    return sc;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        retrieve record object pointed by the given object path
//
//    Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsZone::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler)
{
    DBG_FN( "CDnsZone::GetObject" )

    wstring wstrZone = ObjectPath.GetStringValueForProperty(
        PVD_DOMAIN_CONTAINER_NAME);
    wstring wstrNode = ObjectPath.GetStringValueForProperty(
        PVD_DOMAIN_FQDN);

    DNS_DEBUG( INSTPROV, (
        "%s: zone %S\n", fn, wstrNode.c_str() ));

    // incase of zone, container name and fqdn are same
    // roothints and cache are managed by roothints and cache class
    if( (_wcsicmp(wstrZone.data(), wstrNode.data()) != 0 ) ||
        _wcsicmp(wstrZone.data(), PVD_DNS_CACHE) == 0 ||
        _wcsicmp(wstrZone.data(), PVD_DNS_ROOTHINTS) ==0 )
    {
        return WBEM_S_NO_ERROR;
    }

    CWbemClassObject Inst;
    m_pClass->SpawnInstance(0, &Inst);

    CDnsWrap& dns = CDnsWrap::DnsObject();
    SCODE sc = dns.dnsGetZone(
        PVD_DNS_LOCAL_SERVER,
        ObjectPath.GetStringValueForProperty(PVD_DOMAIN_CONTAINER_NAME).data(),
        Inst,
        pHandler);
    if( SUCCEEDED ( sc ) )
    {
        pHandler->Indicate(1, &Inst);
    }

    return sc;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        save this instance
//
//    Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsZone::PutInstance( 
    IWbemClassObject *  pInst ,
    long                lFlags,
    IWbemContext*       pCtx ,
    IWbemObjectSink *   pHandler)
{
    DBG_FN( "CDnsZone::PutInstance" )

    DNS_DEBUG( INSTPROV, (
        "%s: pInst=%p\n", fn, pInst ));

    CDnsWrap& dns = CDnsWrap::DnsObject();
    CWbemClassObject Inst(pInst);
    return dns.dnsZonePut(Inst);
}; 

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        delete the object specified in ObjectPath
//
//    Arguments:
//      ObjectPath          [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////


SCODE 
CDnsZone::DeleteInstance( 
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pHandler) 
{
    CDnsWrap& dns = CDnsWrap::DnsObject();
    SCODE sc =  dns.dnsDeleteZone(ObjectPath);
    pHandler->SetStatus(
        0,
        sc, 
        NULL, 
        NULL);
    return sc;

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        execute methods defined in the mof 
//
//    Arguments:
//      ObjPath             [IN]    pointing to the object that the 
//                                  method should be performed on
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsZone::ExecuteMethod(
    CObjPath &          ObjPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
    DBG_FN( "CDnsZone::ExecuteMethod" )

    CDnsWrap& dns = CDnsWrap::DnsObject();
    wstring wstrZoneName =  ObjPath.GetStringValueForProperty(
        PVD_DOMAIN_CONTAINER_NAME);
    string strZoneName;
    WcharToString(wstrZoneName.data(), strZoneName);
    SCODE sc;
    if(_wcsicmp(wzMethodName,  PVD_MTH_ZONE_PAUSEZONE) == 0)
    {
        sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_PAUSE_ZONE);
    }
    else if(_wcsicmp(wzMethodName, PVD_MTH_ZONE_RESUMEZONE) == 0)
    {
        sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_RESUME_ZONE);
    }
    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_RELOADZONE ) == 0)
    {
        sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_RELOAD_ZONE);
    }
    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_FORCEREFRESH ) == 0)
    {
        sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_REFRESH_SECONDARY);
    }
    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_UPDATEFROMDS ) == 0)
    {
    
        sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_DS_UPDATE );
    }
    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_WRITEBACKZONE ) == 0)
    {
            sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_WRITE_BACK_ZONE);
    }

    else if( _wcsicmp(
                wzMethodName, 
                PVD_MTH_ZONE_CHANGEZONETYPE ) == 0)
    {
        CWbemClassObject Inst(pInArgs);
        string strDataFile, strAdmin;
        DWORD * pIp = NULL, cIp = 0, dwZoneType = -1;
        BOOL DsIntegrated = FALSE;

        Inst.GetProperty(
            strDataFile,
            PVD_MTH_ZONE_ARG_DATAFILENAME);
        
        Inst.GetProperty(
            strAdmin,
            PVD_MTH_ZONE_ARG_ADMINEMAILNAME);

        Inst.GetProperty(
            &pIp,
            &cIp,
            PVD_MTH_ZONE_ARG_IPADDRARRAY);

        Inst.GetProperty(
            &dwZoneType,
            PVD_MTH_ZONE_ARG_ZONETYPE);

        Inst.GetProperty(
            &DsIntegrated,
            PVD_MTH_ZONE_ARG_DSINTEGRATED );
        
        sc = dns.dnsZoneChangeType(
                    strZoneName,
                    dwZoneType,
                    DsIntegrated,
                    strDataFile,
                    strAdmin,
                    pIp,
                    cIp );
        delete [] pIp;
    }

    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_CREATEZONE) == 0)
    {
        CWbemClassObject Inst(pInArgs);
        CWbemClassObject wcoOutArgs;
        CWbemClassObject wcoOutArgsClass;
        string strDataFile, strAdmin, strNewZoneName;
        strAdmin = "Admin";
        DWORD * pIp = NULL, cIp = 0, dwZoneType = -1;
        BOOL DsIntegrated = FALSE;
        
        sc = m_pClass->GetMethod(wzMethodName, 0, NULL, &wcoOutArgsClass );
        if( FAILED ( sc ) )
        {
            return sc;
        }
    
        wcoOutArgsClass.SpawnInstance(0, & wcoOutArgs);

        Inst.GetProperty(
            strDataFile,
            PVD_MTH_ZONE_ARG_DATAFILENAME);
        
        Inst.GetProperty(
            strAdmin,
            PVD_MTH_ZONE_ARG_ADMINEMAILNAME);

        Inst.GetProperty(
            &DsIntegrated,
            PVD_MTH_ZONE_ARG_DSINTEGRATED );

        Inst.GetProperty(
            &pIp,
            &cIp,
            PVD_MTH_ZONE_ARG_IPADDRARRAY);

        Inst.GetProperty(
            &dwZoneType,
            PVD_MTH_ZONE_ARG_ZONETYPE);

        Inst.GetProperty(
            strNewZoneName,
            PVD_MTH_ZONE_ARG_ZONENAME);
        
        sc = dns.dnsZoneCreate(
                    strNewZoneName,
                    dwZoneType,
                    DsIntegrated,
                    strDataFile,
                    strAdmin,
                    pIp,
                    cIp );

        if ( SUCCEEDED ( sc ) )
        {
            CWbemClassObject wco;
            wstring wstrObjPath;
            m_pClass->SpawnInstance( 0 , & wco );

            wco.SetProperty(
                PVD_DNS_LOCAL_SERVER,
                PVD_DOMAIN_SERVER_NAME );
            wco.SetProperty(
                strNewZoneName.data(),
                PVD_DOMAIN_CONTAINER_NAME );
            wco.SetProperty(
                strNewZoneName.data(),
                PVD_DOMAIN_FQDN );
            wco.GetProperty(
                wstrObjPath,
                L"__RelPath");
            wcoOutArgs.SetProperty(
                wstrObjPath,
                L"RR" );
            pHandler->Indicate( 1, & wcoOutArgs );
        }
        delete [] pIp;
    }
    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_RESETSECONDARYIPARRAY) == 0)
    {
        DNS_DEBUG( INSTPROV, (
            "%s: executing %S\n", fn, PVD_MTH_ZONE_RESETSECONDARYIPARRAY ));

        CWbemClassObject Inst(pInArgs);
        DWORD *pSecondaryIp=NULL, cSecondaryIp=0, dwSecurity=-1;
        DWORD *pNotifyIp=NULL, cNotifyIp=0, dwNotify=-1;

        Inst.GetProperty(
            &pSecondaryIp,
            &cSecondaryIp,
            PVD_MTH_ZONE_ARG_SECONDARYIPARRAY);
        Inst.GetProperty(
            &pNotifyIp,
            &cNotifyIp,
            PVD_MTH_ZONE_ARG_NOTIFYIPARRAY);

        Inst.GetProperty(
            &dwSecurity,
            PVD_MTH_ZONE_ARG_SECURITY);
        Inst.GetProperty(
            &dwNotify,
            PVD_MTH_ZONE_ARG_NOTIFY);
        
        sc = dns.dnsZoneResetSecondary(
            strZoneName,
            dwSecurity,
            pSecondaryIp,
            cSecondaryIp,
            dwNotify,
            pNotifyIp,
            cNotifyIp);

        DNS_DEBUG( INSTPROV, (
            "%s: dnsZoneResetSecondary returned 0x%08X\n", fn, sc ));

        delete [] pSecondaryIp;
        delete [] pNotifyIp;
    }
    else if(_wcsicmp(
        wzMethodName,
        PVD_MTH_ZONE_GETDISTINGUISHEDNAME) == 0)
    {
        wstring wstrName;
        CWbemClassObject OutParams, OutClass, Class ;
        HRESULT hr;
    
        dns.dnsDsZoneName(wstrName, wstrZoneName);

        BSTR ClassName = AllocBstr( PVD_CLASS_ZONE ); 
        hr = m_pNamespace->GetObject(ClassName, 0, 0, &Class, NULL);
        SysFreeString(ClassName);
        if ( SUCCEEDED ( hr ) )
        {
            Class.GetMethod( wzMethodName, 0, NULL, &OutClass);
            OutClass.SpawnInstance(0, &OutParams);
            OutParams.SetProperty(wstrName, PVD_DNS_RETURN_VALUE);
            hr = pHandler->Indicate(1, &OutParams);
        }

        return hr;
    }
    else if( _wcsicmp( wzMethodName, 
                       PVD_MTH_ZONE_AGEALLRECORDS ) == 0 )
    {
        DNS_DEBUG( INSTPROV, (
            "%s: executing %S\n", fn, PVD_MTH_ZONE_AGEALLRECORDS ));

        CWbemClassObject Inst( pInArgs );

        string strNodeName;
        BOOL applyToSubtree = FALSE;

        Inst.GetProperty(
            strNodeName,
            PVD_MTH_ZONE_ARG_NODENAME );
        Inst.GetProperty(
            &applyToSubtree,
            PVD_MTH_ZONE_ARG_APPLYTOSUBTREE );

        sc = dns.dnsAgeAllRecords(
                    strZoneName.c_str(),
                    strNodeName.c_str(),
                    applyToSubtree );

            CWbemClassObject wco;
            wstring wstrObjPath;
            m_pClass->SpawnInstance( 0 , & wco );
    }
    else
    {
        return WBEM_E_NOT_SUPPORTED;    
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\instanceprov.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: instanceprov.cpp
//
//  Description:    
//      Implementation of CInstanceProv class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


long glNumInst = 0;



//***************************************************************************
//
// CInstanceProv::CInstanceProv
// CInstanceProv::~CInstanceProv
//
//***************************************************************************

CInstanceProv::CInstanceProv(
	BSTR ObjectPath,
	BSTR User, 
	BSTR Password, 
	IWbemContext * pCtx)
{
    DBG_FN( "ctor" )

    DNS_DEBUG( INSTPROV, (
        "%s: count before increment is %d\n"
        "  ObjectPath   %S\n"
        "  User         %S\n",
        fn, g_cObj, ObjectPath, User ));
        
    InterlockedIncrement(&g_cObj);
    return;
}

CInstanceProv::~CInstanceProv(void)
{
    DBG_FN( "dtor" )

    DNS_DEBUG( INSTPROV, (
        "%s: count before decrement is %d\n", fn, g_cObj ));
        
    InterlockedDecrement(&g_cObj);
#ifdef _DEBUG
	_CrtDumpMemoryLeaks();
#endif

    return;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::DoExecQueryAsync
//
//	Description:
//		enum instance for a given class
//
//	Arguments:
//      QueryLanguage       [IN]  
//           A valid BSTR containing one of the query languages 
//           supported by Windows Management. This must be WQL. 
//      Query               [IN]
//          A valid BSTR containing the text of the query
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CInstanceProv::DoExecQueryAsync( 
    BSTR             QueryLanguage,
    BSTR             Query,
    long             lFlags,
    IWbemContext     *pCtx,
    IWbemObjectSink  *pHandler
    ) 
{
	SQL_LEVEL_1_RPN_EXPRESSION * objQueryExpr = NULL;

    DBG_FN( "CIP::DoExecQueryAsync" )

    DNS_DEBUG( INSTPROV, (
        "%s: %S flags=%lu %S\n",
        fn, QueryLanguage, lFlags, Query ));

	SCODE sc = WBEM_S_NO_ERROR;
	try
	{
		CTextLexSource objQuerySource(Query);
		SQL1_Parser objParser(&objQuerySource);
		objParser.Parse( &objQueryExpr );
        if ( !objQueryExpr )
        {
            throw ( WBEM_E_OUT_OF_MEMORY );
        }

		CDnsBase* pDns = NULL ;

		sc = CreateClass(
			objQueryExpr->bsClassName,
			m_pNamespace, 
			(void**) &pDns);
	
		if ( FAILED ( sc ) )
		{
			return sc;
		}
		auto_ptr<CDnsBase> pDnsBase(pDns);
		
		int nNumTokens = objQueryExpr->nNumTokens;
		CSqlEval* pEval = CSqlEval::CreateClass(
			objQueryExpr,
			&nNumTokens);
		auto_ptr<CSqlEval> apEval(pEval);

		sc = pDnsBase->ExecQuery(
			&(*apEval),
			lFlags,
			pCtx,
			pHandler);
	}

	catch ( CDnsProvException e )
	{
		CWbemClassObject Status;
	    sc = SetExtendedStatus(e.what(), Status);
        if ( SUCCEEDED ( sc ) )
        {
            sc = pHandler->SetStatus(0, WBEM_E_FAILED,NULL,*(&Status));
			return sc;
        }
		
	}

	catch ( SCODE exSc )
	{
		sc = exSc;
	}

	catch ( ... )
	{
		sc =  WBEM_E_FAILED;
	}
	
	delete objQueryExpr;
	pHandler->SetStatus(0, sc,NULL,NULL);
	return sc;

};
    
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::DoCreateInstanceEnumAsync
//
//	Description:
//		enum instance for a given class
//
//	Arguments:
//      RefStr              [IN[    name the class to enumerate
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CInstanceProv::DoCreateInstanceEnumAsync( 
	BSTR                 RefStr,
	long                 lFlags,
	IWbemContext         *pCtx,
    IWbemObjectSink      *pHandler
    )
{
    DBG_FN( "CIP::DoCreateInstanceEnumAsync" );

    DNS_DEBUG( INSTPROV, (
        "%s: flags=%lu %S\n",
        fn, lFlags, RefStr ));
        
    SCODE sc;
    int iCnt;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

	try
	{
	
		CDnsBase* pDns = NULL ;
		sc = CreateClass(RefStr, m_pNamespace, (void**) &pDns);
		if( FAILED ( sc ) )
		{
			return sc;
		}

		auto_ptr<CDnsBase> pDnsBase(pDns);
		sc = pDnsBase->EnumInstance(
            lFlags,
            pCtx,
            pHandler);
	}
	catch(CDnsProvException e)
	{
		CWbemClassObject Status;
	    sc = SetExtendedStatus(e.what(), Status);
        if ( SUCCEEDED ( sc ) )
        {
            sc = pHandler->SetStatus(0, WBEM_E_FAILED,NULL,*(&Status));
			return sc;
        }
		
	}
	catch(SCODE exSc)
	{
		sc = exSc;
	}
	catch(...)
	{
		
		sc =  WBEM_E_FAILED;
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
	return sc;


}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::GetObject
//
//	Description:
//		Creates an instance given a particular path value.
//
//	Arguments:
//      ObjectPath          [IN]    object path to an object
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//      win32 error
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CInstanceProv::DoGetObjectAsync(
	BSTR                 ObjectPath,
	long                 lFlags,
	IWbemContext         *pCtx,
    IWbemObjectSink FAR* pHandler
    )
{
    DBG_FN( "CIP::DoGetObjectAsync" );

    DNS_DEBUG( INSTPROV, (
        "%s: flags=%lu %S\n",
        fn, lFlags, ObjectPath ));

    SCODE sc;
    IWbemClassObject FAR* pObj;
    BOOL bOK = FALSE;

    // Do a check of arguments and make sure we have pointer to Namespace

    if( ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL )
    {
        DNS_DEBUG( INSTPROV, (
            "%s: bad parameter - WBEM_E_INVALID_PARAMETER\n", fn ));
        return WBEM_E_INVALID_PARAMETER;
    }

    // do the get, pass the object on to the notify
    
	try
	{
		CObjPath ObjPath;
		if(!ObjPath.Init(ObjectPath))
		{
            DNS_DEBUG( INSTPROV, (
                "%s: bad object path - WBEM_E_INVALID_PARAMETER\n", fn ));
			return WBEM_E_INVALID_PARAMETER;
		}
		
		CDnsBase* pDns = NULL;
		wstring wstrClass = ObjPath.GetClassName();
		sc = CreateClass(
			(WCHAR*)wstrClass.data(), 
			m_pNamespace,
			(void**) &pDns);

		if( FAILED(sc) )
		{
            DNS_DEBUG( INSTPROV, (
                "%s: CreateClass returned 0x%08X\n", fn, sc ));
			return sc;
		}
		auto_ptr<CDnsBase> pDnsBase(pDns);
		sc =  pDnsBase->GetObject(
			ObjPath,
			lFlags,
			pCtx, 
			pHandler);
	}
	catch( CDnsProvException e )
	{
        DNS_DEBUG( INSTPROV, (
            "%s: caught CDnsProvException \"%s\"\n", fn, e.what() ));
		CWbemClassObject Status;
	    sc = SetExtendedStatus(e.what(), Status);
        if ( SUCCEEDED ( sc ) )
        {
            sc = pHandler->SetStatus(0, WBEM_E_FAILED,NULL,*(&Status));
        
			return sc;
		}
		
	}
	catch(SCODE exSc)
	{
		sc = exSc;
	}
	catch(...)
	{
		sc = WBEM_E_FAILED;
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
#ifdef _DEBUG
//	_CrtDumpMemoryLeaks();
#endif
	return sc;

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::DoPutInstanceAsync
//
//	Description:
//		save this instance
//
//	Arguments:
//      pInst               [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CInstanceProv::DoPutInstanceAsync( 
	IWbemClassObject *pInst,
    long             lFlags,
	IWbemContext     *pCtx,
	IWbemObjectSink  *pHandler
    ) 
{
    DBG_FN( "CIP::DoPutInstanceAsync" )

    DNS_DEBUG( INSTPROV, (
        "%s: flags=%lu pInst=%p\n",
        fn, lFlags, pInst ));
        
	SCODE sc;
	
    if(pInst == NULL || pHandler == NULL )
    {
        DNS_DEBUG( INSTPROV, (
            "%s: returning WBEM_E_INVALID_PARAMETER\n" ));
        return WBEM_E_INVALID_PARAMETER;
    }
	try
	{
		// get class name
		wstring wstrClass;
		CWbemClassObject Inst(pInst);
		Inst.GetProperty(
			wstrClass,
			L"__Class");
	
		wstring wstrPath;
		Inst.GetProperty(
			wstrPath, 
			L"__RelPath");
		
				
		CDnsBase* pDns = NULL;
		sc = CreateClass(
			wstrClass.data(),
			m_pNamespace,
			(void**) &pDns);

		if( FAILED(sc) )
		{
			return sc;
		}
		auto_ptr<CDnsBase> pDnsBase(pDns);

        DNS_DEBUG( INSTPROV, (
            "%s: doing base PutInstance\n"
            "  class: %S\n"
            "  path: %S\n", 
            fn,
            wstrClass.c_str(),
            wstrPath.c_str() ));

		sc = pDnsBase->PutInstance(
				pInst, 
				lFlags,
				pCtx, 
				pHandler);
	}
	catch(CDnsProvException e)
	{
        DNS_DEBUG( INSTPROV, (
            "%s: caught CDnsProvException \"%s\"\n", fn,
            e.what() ));

		CWbemClassObject Status;
	    sc = SetExtendedStatus(e.what(), Status);
        if (SUCCEEDED ( sc ))
        {
            sc = pHandler->SetStatus(0, WBEM_E_FAILED,NULL,*(&Status));
			return sc;
        }

	}
	catch(SCODE exSc)
	{
        DNS_DEBUG( INSTPROV, (
            "%s: cauught SCODE 0x%08X\n", fn, exSc ));

		sc = exSc;
	}
	catch(...)
	{
        DNS_DEBUG( INSTPROV, (
            "%s: cauught unknown exception returning WBEM_E_FAILED\n", fn ));

		sc = WBEM_E_FAILED;
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
#ifdef _DEBUG
//	_CrtDumpMemoryLeaks();
#endif
	return sc;


}
 
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::DoDeleteInstanceAsync
//
//	Description:
//		delete this instance
//
//	Arguments:
//      rObjPath            [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////      
      
SCODE CInstanceProv::DoDeleteInstanceAsync( 
    BSTR                 ObjectPath,
    long                 lFlags,
    IWbemContext *       pCtx,
    IWbemObjectSink *    pHandler
     ) 
{
    DBG_FN( "CIP::DoDeleteInstanceAsync" );

    DNS_DEBUG( INSTPROV, (
        "%s: flags=%lu %S\n",
        fn, lFlags, ObjectPath ));

	SCODE sc;
 
    // Do a check of arguments and make sure we have pointer to Namespace

    if(ObjectPath == NULL || pHandler == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // do the get, pass the object on to the notify
    
	try
		{
		CObjPath ObjPath;
		if(!ObjPath.Init(ObjectPath))
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		
		CDnsBase* pDns = NULL;
		wstring wstrClass = ObjPath.GetClassName();
		sc = CreateClass(
			(WCHAR*)wstrClass.data(), 
			m_pNamespace, 
			(void**) &pDns);

		if( FAILED(sc) )
		{
			return sc;
		}
		auto_ptr<CDnsBase> pDnsBase(pDns);
		sc = pDnsBase->DeleteInstance(
			ObjPath,
			lFlags,
			pCtx, 
			pHandler);
	}
	catch(CDnsProvException e)
	{
		CWbemClassObject Status;
	    sc = SetExtendedStatus(e.what(), Status);
        if (SUCCEEDED ( sc ))
        {
            sc = pHandler->SetStatus(0, WBEM_E_FAILED,NULL,*(&Status));
			return sc;
		}
		
	}
	catch(SCODE exSc)
	{
		sc = exSc;
	}
	catch(...)
	{
		sc = WBEM_E_FAILED;
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
	return sc;


}	
    
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::DoExecMethodAsync
//
//	Description:
//		execute methods for the given object
//
//	Arguments:
//      ObjectPath          [IN]    object path to a given object
//      pwszMethodName      [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams*          [IN]    Input parameters for the method
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CInstanceProv::DoExecMethodAsync(
	BSTR             strObjectPath, 
    BSTR             strMethodName, 
	long             lFlags, 
    IWbemContext     *pCtx,
	IWbemClassObject *pInParams, 
	IWbemObjectSink  *pHandler
    )
{
    DBG_FN( "CIP::DoExecMethodAsync" );

    DNS_DEBUG( INSTPROV, (
        "%s: flags=%lu method=%S %S\n",
        fn, lFlags, strMethodName, strObjectPath ));

	SCODE sc;
	if(strObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL
		|| strMethodName == NULL )
        return WBEM_E_INVALID_PARAMETER;
	
    CDnsBase * pDns;
    try 
	{

        CObjPath ObjPath;
	    if(!ObjPath.Init(strObjectPath))
	    {
		    return WBEM_E_INVALID_PARAMETER;
	    }
	    

	    wstring wstrClass = ObjPath.GetClassName();


	    sc = CreateClass(
		    wstrClass.data(),
		    m_pNamespace, 
		    (void**) &pDns);

	    if( FAILED(sc) )
	    {
		    return sc;
	    }
		auto_ptr<CDnsBase> pDnsBase(pDns);
		sc = pDnsBase->ExecuteMethod(
			ObjPath,
			strMethodName, 
			lFlags, 
			pInParams,
			pHandler);
	}

	catch(CDnsProvException e)
	{
        DNS_DEBUG( INSTPROV, (
            "%s: caught CDnsProvException %s\n",
            fn, e.what() ));

		CWbemClassObject Status;
	    sc = SetExtendedStatus(e.what(), Status);
        if (SUCCEEDED ( sc ))
        {
            sc = pHandler->SetStatus(
                0, 
                WBEM_E_FAILED,
                NULL,
                *(&Status));
			return sc;
		}
	
	}
	catch(SCODE exSc)
	{
		sc = exSc;
        DNS_DEBUG( INSTPROV, ( "%s: caught SCODE 0x%08X\n", fn, sc ));
	}
	catch(...)
	{
		sc = WBEM_E_FAILED;
        DNS_DEBUG( INSTPROV, ( "%s: caught unknown exception returning WBEM_E_FAILED\n", fn ));
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
#ifdef _DEBUG
//	_CrtDumpMemoryLeaks();
#endif

    DNS_DEBUG( INSTPROV, ( "%s: returning 0x%08X\n", fn, sc ));
	return sc;

	
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::SetExtendedStatus
//
//	Description:
//		create and set extended error status
//
//	Arguments:
//      ErrString           [IN]    Error message string
//      Inst                [IN OUT]    reference to WMI instance
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CInstanceProv::SetExtendedStatus(
    const char * ErrString, 
    CWbemClassObject & Inst )
{
    DBG_FN( "CIP::SetExtendedStatus" );

    DNS_DEBUG( INSTPROV, ( "%s: error string = %s\n", fn, ErrString ));

    IWbemClassObject* pStatus;
	BSTR bstrStatus = SysAllocString(L"__ExtendedStatus");
    if( bstrStatus == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
	
    SCODE  sc =  m_pNamespace->GetObject(
        bstrStatus, 
        0, 
        0,
        &pStatus, 
        NULL) ;
    SysFreeString(bstrStatus);
    if( SUCCEEDED ( sc ) )
    {
	    sc = pStatus->SpawnInstance(0, &Inst);
	    if ( SUCCEEDED ( sc ))
        {
            sc = Inst.SetProperty(
                ErrString, 
                L"Description");
        }
    }
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\provfactory.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		provfactory.h
//
//	Implementation File:
//		provfactory.cpp
//
//	Description:
//		Definition of the CProvFactory class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


#include "common.h"
#include "instanceprov.h"


class CProvFactory  : public IClassFactory
{
   protected:
        ULONG           m_cRef;

	public:
		CProvFactory();
		virtual ~CProvFactory();

		STDMETHODIMP         QueryInterface(REFIID, PPVOID);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);
		//IClassFactory members
	    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                       , PPVOID);
	    STDMETHODIMP         LockServer(BOOL);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\instanceprov.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		InstanceProv.h
//
//	Implementation File:
//		InstanceProv.cpp
//
//	Description:
//		Definition of the CInstanceProv.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include <wbemprov.h>
#include "ntrkcomm.h"
class CWbemClassObject;

class CInstanceProv : public CImpersonatedProvider
{
protected:
	SCODE SetExtendedStatus(
        const char* , 
        CWbemClassObject& );
 
public:
	CInstanceProv(
		BSTR =NULL, 
		BSTR =NULL , 
		BSTR =NULL, 
		IWbemContext * = NULL
		);
	virtual ~CInstanceProv();

	HRESULT STDMETHODCALLTYPE DoGetObjectAsync( 
	    BSTR                ObjectPath,
	    long                lFlags,
	    IWbemContext *		pCtx,
        IWbemObjectSink	*	pHandler
        );
    
	HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
	    IWbemClassObject *   pInst,
        long                 lFlags,
	    IWbemContext *       pCtx,
	    IWbemObjectSink *    pHandler
        ) ;
    
    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        BSTR                 ObjectPath,
        long                 lFlags,
        IWbemContext *       pCtx,
        IWbemObjectSink *    pHandler
        ) ;
    
    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
	    BSTR                 RefStr,
	    long                 lFlags,
	    IWbemContext         *pCtx,
        IWbemObjectSink      *pHandler
        );
     
    
    HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        BSTR                 QueryLanguage,
        BSTR                 Query,
        long                 lFlags,
        IWbemContext         *pCtx,
        IWbemObjectSink      *pHandler
        ) ;
    

    HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
	    BSTR             strObjectPath, 
        BSTR             strMethodName, 
	    long             lFlags, 
        IWbemContext     *pCtx,
	    IWbemClassObject *pInParams, 
	    IWbemObjectSink  *pHandler
        );
	

};

extern long       g_cObj;
extern long       g_cLock;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\objectpath.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: objectpath.cpp
//
//  Description:    
//      Implementation of CObjectpath and other utility class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CPropertyValue::~CPropertyValue()
{
    VariantClear(&m_PropValue);
}

CPropertyValue::CPropertyValue()
{
    VariantInit(&m_PropValue);
}

CPropertyValue::CPropertyValue(
    const CPropertyValue& pv)
{
    m_Operator = pv.m_Operator;
    m_PropName = pv.m_PropName;
    VariantInit(&m_PropValue);
    ( void ) VariantCopy( &m_PropValue, (VARIANT*)&pv.m_PropValue );
}

CPropertyValue& 
CPropertyValue::operator =(
    const CPropertyValue& pv)
{
    m_Operator = pv.m_Operator;
    m_PropName = pv.m_PropName;
    VariantInit(&m_PropValue);
    ( void ) VariantCopy( &m_PropValue, (VARIANT*)&pv.m_PropValue );
    return *this;
}

CObjPath::CObjPath()
{

}
CObjPath::CObjPath(
    const CObjPath& op)
{
    m_Class = op.m_Class;
    m_NameSpace = op.m_NameSpace;
    m_Server = op.m_Server;
    m_PropList = op.m_PropList;
}    



 CObjPath::~CObjPath()
{

}


wstring 
CObjPath::GetStringValueForProperty(
    const WCHAR* str
    )
{
    list<CPropertyValue>::iterator i;
    for(i=m_PropList.begin(); i!= m_PropList.end(); ++i)
    {
        if( _wcsicmp(
            (*i).m_PropName.data(),
            str) == 0
        )
        {
            if( i->m_PropValue.vt == VT_BSTR)
                return i->m_PropValue.bstrVal;
        }
    }
    return L"";
}

wstring 
CObjPath::GetClassName(void)
{
    return m_Class;
}



BOOL 
CObjPath::Init(
    const WCHAR* szObjPath
    )
{
    BOOL flag = TRUE;
    CPropertyValue* pObjPV=NULL;
    BSTR bstrInput = SysAllocString(szObjPath);
    CObjectPathParser objParser(e_ParserAcceptRelativeNamespace);
    ParsedObjectPath* pParsed = NULL;
    objParser.Parse(bstrInput, &pParsed);
    SysFreeString(bstrInput);
    if( pParsed == NULL)
    {
        return FALSE;
    }
    SetClass(pParsed->m_pClass);
    WORD wKeyCount = pParsed->m_dwNumKeys;
    for(DWORD i = 0; i < wKeyCount; i++)
    {
        KeyRef* pKeyRef = pParsed->m_paKeys[i];
        AddProperty(
            pKeyRef->m_pName, 
            &(pKeyRef->m_vValue)
            );
    }
    delete pParsed;

    return TRUE;
}


BOOL 
CObjPath::SetClass(
    const WCHAR *wszValue
    )               
{
    m_Class = wszValue;
    return TRUE;
}

BOOL 
CObjPath::SetNameSpace(
    const WCHAR *wszValue
    )                   
{
    m_NameSpace = wszValue;
    return TRUE;
}

BOOL 
CObjPath::SetServer(
    const WCHAR *wszValue)                
{
    m_Server = wszValue;
    return TRUE;
}

BOOL
CObjPath::SetProperty(
    const WCHAR* wszName, 
    const WCHAR* wszValue)
{
    list<CPropertyValue>::iterator i;
    for(i=m_PropList.begin(); i!= m_PropList.end(); ++i)
    {
        if ( _wcsicmp( (*i).m_PropName.data() ,  wszName )  == 0)
        {
            m_PropList.erase(i);
            break;
        }
    }  
    return AddProperty(wszName, wszValue);
    
}
BOOL 
CObjPath::AddProperty(
    const WCHAR *   wszName, 
    const WCHAR *   wszValue
    )
{

    CPropertyValue pv;
    pv.m_PropName = wszName;
    pv.m_Operator = L"=";
    pv.m_PropValue.vt = VT_BSTR;
    pv.m_PropValue.bstrVal = SysAllocString(wszValue);
    m_PropList.insert(m_PropList.end(), pv);
    return TRUE;
    
}
BOOL CObjPath::AddProperty(
    const WCHAR *   wszName,
    string &        strValue
    )
{
    wstring wstrValue = CharToWstring(strValue.data(), strValue.length());
    AddProperty(wszName, wstrValue.data());
    return TRUE;
}
wstring 
CObjPath::GetObjectPathString()
{
    list<CPropertyValue>::iterator i;
    
    ParsedObjectPath parsed;
    parsed.SetClassName(GetClassName().data());
    
    for(i=m_PropList.begin(); i!= m_PropList.end(); ++i)
    {
        parsed.AddKeyRefEx(i->m_PropName.data(), &(i->m_PropValue));
    }
    LPWSTR pwszPath;
    CObjectPathParser::Unparse(&parsed, &pwszPath);
    wstring wstrResult = pwszPath;
    delete [] pwszPath;
    return wstrResult;
}

BOOL
CObjPath::AddProperty(
    const WCHAR *   wszName, 
    VARIANT *       pvValue
    )
{
    CPropertyValue pvObj;
    pvObj.m_PropName = wszName;
    pvObj.m_Operator = L"=";
    ( void ) VariantCopy(&pvObj.m_PropValue, pvValue);
    m_PropList.insert(m_PropList.end(), pvObj);
    return TRUE;
}
BOOL
CObjPath::AddProperty(
    const WCHAR *   wszName, 
    WORD            wValue
    )
{
    VARIANT v;
    VariantInit(&v);
    v.vt = VT_I2;
    v.iVal = wValue;
    AddProperty(wszName, &v);
    VariantClear(&v);
    return TRUE;
}
BOOL
CObjPath::GetNumericValueForProperty(
    const WCHAR *   wszName, 
    WORD *          wValue
    )
{
    list<CPropertyValue>::iterator i;
    for(i=m_PropList.begin(); i!= m_PropList.end(); ++i)
    {
        if( _wcsicmp((*i).m_PropName.data(), wszName) == 0)
        {
            if(i->m_PropValue.vt == VT_I4)
            {
                *wValue = i->m_PropValue.iVal;
                return TRUE;
            }
                
        }
    }
    return FALSE;
}
CDomainNode::CDomainNode()
{
}
CDomainNode::~CDomainNode()
{
}
CDomainNode::CDomainNode(
    const CDomainNode& rhs)
{
    wstrZoneName = rhs.wstrZoneName;
    wstrNodeName = rhs.wstrNodeName;
    wstrChildName = rhs.wstrChildName;
}

CDnsProvException::CDnsProvException():m_dwCode(0)
{
}
CDnsProvException::CDnsProvException(const char* psz, DWORD dwCode)
{
    m_strError = psz;
    m_dwCode = dwCode;
}

CDnsProvException::~CDnsProvException()
{
}


CDnsProvException& 
CDnsProvException::operator =(
    const CDnsProvException& rhs)
{
    m_strError = rhs.m_strError;
    m_dwCode = rhs.m_dwCode;
    return *this;
}

const 
char* 
CDnsProvException::what() const
{
    return m_strError.data();
}
DWORD 
CDnsProvException::GetErrorCode()
{ 
    return m_dwCode;
}
CDnsProvException::CDnsProvException(
    const CDnsProvException& rhs)
{
    m_strError = rhs.m_strError;
    m_dwCode = rhs.m_dwCode;
}

CDnsProvSetValueException::CDnsProvSetValueException()
{
}
CDnsProvSetValueException::~CDnsProvSetValueException()
{
}

CDnsProvSetValueException::CDnsProvSetValueException(
    const WCHAR* pwz)
{
    string temp;
    WcharToString(pwz, temp);
    m_strError = "Failed to set value of " + temp;
}

CDnsProvSetValueException::CDnsProvSetValueException(
    const CDnsProvSetValueException &rhs)
{
    m_strError = rhs.m_strError;
}
CDnsProvSetValueException& 
CDnsProvSetValueException::operator =(
    const CDnsProvSetValueException &rhs)
{
    m_strError = rhs.m_strError;
    return *this;
}


CDnsProvGetValueException::CDnsProvGetValueException()
{
}
CDnsProvGetValueException::~CDnsProvGetValueException()
{
}

CDnsProvGetValueException::CDnsProvGetValueException(
    const WCHAR* pwz)
{
    string temp;
    WcharToString(pwz, temp);
    m_strError = "Fail to get value of " + temp;
}

CDnsProvGetValueException::CDnsProvGetValueException(
    const CDnsProvGetValueException &rhs)
{
    m_strError = rhs.m_strError;
}
CDnsProvGetValueException& 
CDnsProvGetValueException::operator =(
    const CDnsProvGetValueException &rhs)
{
    m_strError = rhs.m_strError;
    return *this;
}

// CWbemClassObject

CWbemClassObject::CWbemClassObject()
    : m_pClassObject( NULL )
{
    VariantInit( &m_v );
}
CWbemClassObject::CWbemClassObject(
    IWbemClassObject* pInst )
    : m_pClassObject( NULL )
{
    m_pClassObject = pInst;
    if ( m_pClassObject )
    {
        m_pClassObject->AddRef();
    }
    VariantInit( &m_v );
}

CWbemClassObject::~CWbemClassObject()
{
    if(m_pClassObject)
        m_pClassObject->Release();
    VariantClear(&m_v);
}
IWbemClassObject** 
CWbemClassObject::operator&()
{
    return &m_pClassObject;
}

SCODE
CWbemClassObject::SetProperty(
    DWORD   dwValue, 
    LPCWSTR wszPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    m_v.vt = VT_I4;
    m_v.lVal = dwValue;
    BSTR bstrName = AllocBstr(wszPropName);
    sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
    SysFreeString(bstrName);

    if( sc != S_OK)
    {
        CDnsProvSetValueException e(wszPropName);
        throw e;
    }

    return sc;
}



SCODE 
CWbemClassObject::SetProperty(
    UCHAR   ucValue, 
    LPCWSTR wszPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    m_v.vt = VT_UI1;
    m_v.bVal = ucValue;
    BSTR bstrName = AllocBstr(wszPropName);
    sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
    SysFreeString(bstrName);

    if( sc != S_OK)
    {
        CDnsProvSetValueException e(wszPropName);
        throw e;
    }

    return sc;
}


SCODE 
CWbemClassObject::SetProperty(
    LPCWSTR pszValue, 
    LPCWSTR wszPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    if(!pszValue)
        return 0;
    m_v.vt = VT_BSTR;
    m_v.bstrVal = AllocBstr(pszValue);
    BSTR bstrName = AllocBstr(wszPropName);

    sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
    VariantClear(&m_v);
    SysFreeString(bstrName);

    if( sc != S_OK)
    {
        CDnsProvSetValueException e(wszPropName);
        throw e;
    }

    return sc;
 
}



SCODE 
CWbemClassObject::SetProperty(
    wstring &   wstrValue, 
    LPCWSTR     wszPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    if(wstrValue.empty())
        return S_OK;
    m_v.vt = VT_BSTR;
    m_v.bstrVal = AllocBstr(wstrValue.data());
    BSTR bstrName = AllocBstr(wszPropName);

    sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
    SysFreeString(bstrName);

    if( sc != S_OK)
    {
        CDnsProvSetValueException e(wszPropName);
        throw e;
    }

    return sc;
}



SCODE 
CWbemClassObject::SetProperty(
    SAFEARRAY * psa, 
    LPCWSTR     wszPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    m_v.vt = (VT_ARRAY |VT_BSTR);
    m_v.parray = psa;
    BSTR bstrName = AllocBstr(wszPropName);
    sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
    SysFreeString(bstrName);
    if( sc != S_OK)
    {
        CDnsProvSetValueException e(wszPropName);
        throw e;
    }

    return sc;
}

SCODE 
CWbemClassObject::SetProperty(
    DWORD *     pdwValue, 
    DWORD       dwSize, 
    LPCWSTR     wszPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);

    SAFEARRAY * psa;
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwSize;
    try
    {

        psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
        if(psa == NULL)
        {
            throw WBEM_E_OUT_OF_MEMORY;
        }

        for(int i=0; i< dwSize; i++)
        {
            BSTR bstrIP = AllocBstr(
                IpAddressToString(pdwValue[i]).data());
            LONG ix = i;
            sc = SafeArrayPutElement(
                psa, 
                &ix, 
                bstrIP);
            SysFreeString(bstrIP);
            if( sc != S_OK)
                throw sc;
        }

        m_v.vt = (VT_ARRAY |VT_BSTR);
        m_v.parray = psa;
        BSTR bstrName = AllocBstr(wszPropName);
        sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
        SysFreeString(bstrName);
        
        if( sc != S_OK)
        {
            CDnsProvSetValueException e(wszPropName);
            throw e;
        }
            
    }
    catch(...)
    {
        if(psa != NULL)
            SafeArrayDestroy(psa);
        throw ;
    }

    return WBEM_S_NO_ERROR;
}


SCODE 
CWbemClassObject::SetProperty(
    LPCSTR  pszValue, 
    LPCWSTR wszPropName
    )
{
    if(pszValue == NULL)
        return S_OK;
    wstring wstrValue = CharToWstring(pszValue, strlen(pszValue));
    return SetProperty(wstrValue, wszPropName);
}


SCODE
CWbemClassObject::SpawnInstance(
    LONG lFlag,
    IWbemClassObject** ppNew)
{
    return m_pClassObject->SpawnInstance(lFlag, ppNew);
}

SCODE
CWbemClassObject::GetMethod(
    BSTR                name,
    LONG                lFlag,
    IWbemClassObject**  ppIN,
    IWbemClassObject**  ppOut
    )
{
    return m_pClassObject->GetMethod(
        name,
        lFlag,
        ppIN,
        ppOut);
}
    

SCODE 
CWbemClassObject::GetProperty(
    DWORD *     dwValue, 
    LPCWSTR     wszPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    BSTR bstrPropName = AllocBstr(wszPropName);
    sc = m_pClassObject->Get(bstrPropName, 0, &m_v,NULL, NULL);
    SysFreeString(bstrPropName);
    
    if(sc == S_OK)
    {
        if(m_v.vt == VT_I4)
        {
            *dwValue = m_v.lVal;
            return sc;
        }
        else if (m_v.vt == VT_BOOL)
        {
            if (m_v.boolVal == VARIANT_TRUE)
                *dwValue = 1;
            else
                *dwValue = 0;
            return sc;
        }
        else if(m_v.vt == VT_UI1)
        {
            *dwValue = (DWORD) m_v.bVal;
        }
        else if (m_v.vt == VT_NULL)
        {
            return WBEM_E_FAILED;
        }
    }

    // raise exception if sc is not S_OK or vt is not expected
    CDnsProvGetValueException e(wszPropName);
    throw e;
    
    return WBEM_E_FAILED;
}


SCODE 
CWbemClassObject::GetProperty(
    wstring &   wsStr, 
    LPCWSTR     wszPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    BSTR bstrPropName = AllocBstr(wszPropName);
    sc = m_pClassObject->Get(bstrPropName, 0, &m_v,NULL, NULL);
    SysFreeString(bstrPropName);
    if(sc == S_OK)
    {
        if(m_v.vt == VT_BSTR)
        {
            wsStr = m_v.bstrVal;
            return sc;
        }
        else if(m_v.vt == VT_NULL)
        {
            return WBEM_E_FAILED;
        }
    }

    CDnsProvGetValueException e(wszPropName);
    throw e;
    return WBEM_E_FAILED;
}


SCODE 
CWbemClassObject::GetProperty(
    string &    strStr, 
    LPCWSTR     wszPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    BSTR bstrPropName = AllocBstr(wszPropName);
    sc = m_pClassObject->Get(bstrPropName, 0, &m_v,NULL, NULL);
    SysFreeString(bstrPropName);
    if( sc == S_OK)
    {
        if(m_v.vt == VT_BSTR)
        {
            char* temp=NULL;
            WcharToChar(m_v.bstrVal, &temp);
            strStr = temp;
            delete [] temp;
            return sc;
        }
        else if (m_v.vt == VT_NULL)
        {
            return WBEM_E_FAILED;
        }
    }
    // exception
    CDnsProvGetValueException e(wszPropName);
    throw e;
    
    return WBEM_E_FAILED;
}

SCODE 
CWbemClassObject::GetProperty(
    BOOL *  bValue, 
    LPCWSTR szPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    BSTR bstrPropName = AllocBstr(szPropName);
    sc = m_pClassObject->Get(bstrPropName, 0, &m_v,NULL, NULL);
    SysFreeString(bstrPropName);
    if(m_v.vt == VT_BOOL)
    {
        *bValue = m_v.boolVal;
        return sc;
    }

    return WBEM_E_FAILED;
}


SCODE 
CWbemClassObject::GetProperty(
    DWORD **    ppValue, 
    DWORD *     dwSize, 
    LPCWSTR     szPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    BSTR bstrPropName = AllocBstr(szPropName);
    sc = m_pClassObject->Get(bstrPropName, 0, &m_v, NULL, NULL);
    SysFreeString(bstrPropName);
    *dwSize = 0;

    if(m_v.vt == (VT_ARRAY |VT_BSTR) && m_v.vt != VT_NULL)
    {
        SAFEARRAY* psa;
        sc = SafeArrayCopy(m_v.parray, &psa);
        if(sc == S_OK)
        {
            *dwSize = psa->rgsabound[0].cElements;
            *ppValue = new DWORD[*dwSize];
            if ( *ppValue )
            {
                BSTR* pbstr;
                sc = SafeArrayAccessData(psa, (void**) &pbstr);
                if(sc != S_OK)
                {   
                    delete [] *ppValue;
                    throw sc;
                }
                for(LONG i = 0; i < *dwSize; i++)
                {
                    //CHAR* pChar
                    string str;
                    WcharToString(pbstr[i], str);
                    (*ppValue)[i] = inet_addr(str.data());
                }
            }
            else
            {
                sc = E_OUTOFMEMORY;
            }
            return sc;
        }
    }

    return WBEM_E_FAILED;
}


SCODE 
CWbemClassObject::GetProperty(
    DWORD Value[], 
    DWORD *dwSize, 
    LPCWSTR szPropName
    )
{
    SCODE sc;
    VariantClear(&m_v);
    BSTR bstrPropName = AllocBstr(szPropName);
    sc = m_pClassObject->Get(bstrPropName, 0, &m_v,NULL, NULL);
    SysFreeString(bstrPropName);
    if(m_v.vt == (VT_ARRAY |VT_BSTR) && m_v.vt != VT_NULL)
    {
        SAFEARRAY* psa;
        try
        {
            sc = SafeArrayCopy(m_v.parray, &psa);
            if(sc != S_OK)
                throw sc;
            if(psa->rgsabound[0].cElements > *dwSize)
                throw WBEM_E_INVALID_PARAMETER;

            *dwSize = psa->rgsabound[0].cElements;
            BSTR* pbstr;
            sc = SafeArrayAccessData(psa, (void**) &pbstr);
            if(sc != S_OK)
                throw sc;
            
            for(LONG i = 0; i < *dwSize; i++)
            {
                //CHAR* pChar
                string str;
                WcharToString(pbstr[i], str);
                Value[i] = inet_addr(str.data());
            }
            SafeArrayDestroy(psa);
            return sc;
            
        }
        catch(SCODE sc)
        {
            SafeArrayDestroy(psa);
            throw sc;
        }

    }

    return WBEM_E_FAILED;
}

SCODE 
CWbemClassObject::GetProperty(
    VARIANT *   pv, 
    LPCWSTR     wszPropName 
    )
{
    SCODE sc;
    BSTR bstrPropName = AllocBstr(wszPropName);
    sc = m_pClassObject->Get(bstrPropName, 0, pv,NULL, NULL);
    SysFreeString(bstrPropName);
    if(sc != S_OK)
    {
        CDnsProvGetValueException e(wszPropName);
        throw e;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\server.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: server.cpp
//
//  Description:    
//      Implementation of CDnsserver class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        execute methods defined for dns server class in the mof 
//
//    Arguments:
//      ObjPath             [IN]    pointing to the object that the 
//                                  method should be performed on
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsServer::ExecuteMethod(    
    CObjPath &          ObjPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
    CDnsWrap& dns = CDnsWrap::DnsObject();

#if 0
    //
    //  Restart is so totally broken I'm not going to expose it.
    //

    if(_wcsicmp( wzMethodName, PVD_MTH_SRV_RESTART) == 0)
    {
        wstring wstrServer = ObjPath.GetStringValueForProperty(
            PVD_SRV_SERVER_NAME );
        int rt  = dns.dnsRestartServer((WCHAR*)wstrServer.data());
        if( rt != ERROR_SUCCESS)
        {
            return WBEM_E_FAILED;
        }
    }
    else
#endif

    if(_wcsicmp( wzMethodName, PVD_MTH_SRV_START_SERVICE) == 0)
    {
        return StartServer();
    }
    else if(_wcsicmp( wzMethodName, PVD_MTH_SRV_STOP_SERVICE) == 0)
    {
        return StopServer();
    }
    else if(_wcsicmp(
        wzMethodName,
        PVD_MTH_ZONE_GETDISTINGUISHEDNAME) == 0)
    {
        wstring wstrName ;
        CWbemClassObject OutParams, OutClass, Class ;
        HRESULT hr;
    
        dns.dnsDsServerName(wstrName);

        BSTR ClassName = AllocBstr(PVD_CLASS_SERVER); 
        if ( !ClassName )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = m_pNamespace->GetObject(ClassName, 0, 0, &Class, NULL);
        SysFreeString(ClassName);
        if ( SUCCEEDED ( hr ) )
        {
            Class.GetMethod( wzMethodName, 0, NULL, &OutClass);
            OutClass.SpawnInstance(0, &OutParams);
            OutParams.SetProperty(wstrName, PVD_DNS_RETURN_VALUE);
            hr = pHandler->Indicate(1, &OutParams);
        }

        return hr;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        retrieve record object pointed by the given object path
//
//    Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsServer::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler
    )
{
    SCODE sc;
    CWbemClassObject NewInst;
    sc = m_pClass->SpawnInstance(0, &NewInst);
    if(FAILED(sc))
    {
        return sc;
    }

    wstring wstrServerName = ObjectPath.GetStringValueForProperty(
        PVD_SRV_SERVER_NAME );
    if ( wstrServerName.empty())
    {
        return WBEM_E_FAILED;
    }

    SC_HANDLE   schService = NULL;
    SC_HANDLE    schSCManager = NULL;
    LPQUERY_SERVICE_CONFIG lpServiceConfig = NULL;
    DWORD cbBufSize;
    DWORD BytesNeeded;
    SERVICE_STATUS ServiceStatus;
    
    try
    {    
        if ((schSCManager = OpenSCManager (
            NULL,            // machine (NULL == local)
            NULL,            // database (NULL == default)
            SC_MANAGER_ALL_ACCESS))==NULL)    // access required
        {
            throw GetLastError();
        }

        if ((schService = OpenService(
            schSCManager, 
            "DNS", 
            SERVICE_ALL_ACCESS))==NULL)
        {
            throw GetLastError();
        }

        if (QueryServiceConfig(
            schService,     // handle to service
            lpServiceConfig, 
            0,   // size of structure
            &cbBufSize        // bytes needed
            ) == FALSE)
        {
            lpServiceConfig = 
                (LPQUERY_SERVICE_CONFIG)  new BYTE[cbBufSize];
            if ( !lpServiceConfig)
            {
                throw ( ERROR_OUTOFMEMORY );
            }
            if(QueryServiceConfig(
                schService,     // handle to service
                lpServiceConfig, 
                cbBufSize,   // size of structure
                &BytesNeeded // bytes needed
                ) == FALSE)
                throw GetLastError();
            
            wstring wstrStartMode;
            switch(lpServiceConfig->dwStartType)
            {
            case SERVICE_DEMAND_START:
                wstrStartMode = L"Manual";
                break;
            default:
                wstrStartMode = L"Automatic";
                break;
            }

            NewInst.SetProperty(
                wstrStartMode,
                PVD_SRV_STARTMODE);


            if(QueryServiceStatus(
                schService,               // handle to service
                &ServiceStatus  // pointer to service status structure
                ) == FALSE)
            {
                throw GetLastError();
            }
            
            DWORD dwStatus;
            switch(ServiceStatus.dwCurrentState)
            {
            case SERVICE_RUNNING:
                dwStatus = 1;
                break;
            default:
                dwStatus = 0;
            }

            NewInst.SetProperty(
                dwStatus,
                PVD_SRV_STARTED);
 
        }
 
        CDnsWrap& dns = CDnsWrap::DnsObject();
        NewInst.SetProperty(
            dns.GetServerName(),
            PVD_SRV_SERVER_NAME);
        dns.dnsServerPropertyGet(
            NewInst,
            TRUE);
    }
    catch(DWORD dwError)
    {
        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
        delete [] lpServiceConfig;

    }
    catch(CDnsProvException e)
    {
        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
        delete [] lpServiceConfig;
        lpServiceConfig=NULL;
        // if server not running, we still want to 
        //return an instance, so user can call start service 
        //
        if(_stricmp(e.what(), "RPC_S_SERVER_UNAVAILABLE") != 0)
        {
            throw e;
        }
    }

    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);
    delete [] lpServiceConfig;
    pHandler->Indicate(1,&NewInst);
    return sc;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enum instances of dns server
//
//    Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsServer::EnumInstance(
    long                lFlags,
    IWbemContext *        pCtx,
    IWbemObjectSink *    pHandler
    )
{


    // there is only one instance
    CObjPath ObjPath;
    ObjPath.SetClass(PVD_CLASS_SERVER);
    ObjPath.AddProperty(
        PVD_SRV_SERVER_NAME, 
        PVD_DNS_LOCAL_SERVER);
    return  GetObject(ObjPath, lFlags,pCtx,pHandler);

}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsServer::CDnsServer()
{

}
CDnsServer::CDnsServer(
    const WCHAR* wszName,
    CWbemServices *pNamespace)
    :CDnsBase(wszName, pNamespace)
{

}

CDnsServer::~CDnsServer()
{

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        create an instance of CDnsServer
//
//    Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsServer::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsServer(wszName, pNamespace);
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        start dns server
//
//    Arguments:
//    Return Value:
//        
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsServer::StartServer()
{
    SC_HANDLE   schService = NULL;
    SC_HANDLE    schSCManager = NULL;
    try
    {
        if ((schSCManager = OpenSCManager (
            NULL,            // machine (NULL == local)
            NULL,            // database (NULL == default)
            SC_MANAGER_ALL_ACCESS))==NULL)    // access required
        {
            throw GetLastError();
        }

        if ((schService = OpenService(
            schSCManager, 
            "DNS", 
            SERVICE_ALL_ACCESS))==NULL)
        {
            throw GetLastError();
        }

        // make sure database is not locked
        QUERY_SERVICE_LOCK_STATUS qsls;
        DWORD dwbBytesNeeded, dwRet=1;

        while(dwRet)
        {
            if(!QueryServiceLockStatus(
                schSCManager, 
                &qsls, 
                sizeof(qsls)+2, 
                &dwbBytesNeeded))
            {
                throw GetLastError();
            }
            
            if( (dwRet = qsls.fIsLocked) > 0)
            {
                Sleep(2000);
            }
        }

        if (StartService(
            schService, 
            0, 
            NULL)==FALSE)
        {
            throw GetLastError();
        }
        
        DWORD dwTimeOut=6000; // 6 sec
        DWORD dwTimeCount=0;
        while ( dwTimeCount < dwTimeOut)
        {

            SERVICE_STATUS ServiceStatus;
            if(QueryServiceStatus(
                schService,               // handle to service
                &ServiceStatus  // pointer to service status structure
                ) == FALSE)
            {
                throw GetLastError();
            }

            
            if(ServiceStatus.dwCurrentState != SERVICE_RUNNING)
            {
                Sleep(2000);
                dwTimeCount +=2000;
            }
            else 
            {
                break;
            }
        }

    }
    catch(DWORD dwError)
    {
        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
    
        CHAR szErrDesc[ MAX_PATH ];
        FormatMessage( 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            szErrDesc,
            MAX_PATH,
            NULL );

        CHAR szErr[ MAX_PATH + 40 ];
        strcpy(szErr, "Fail to start Dns because ");
        strcat(szErr, szErrDesc);
        CDnsProvException e(szErr);
        throw e;
    }
    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        stop dns server
//
//    Arguments:
//    Return Value:
//        
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsServer::StopServer()
{
    SERVICE_STATUS    ss;
    SC_HANDLE        schService = NULL;
    SC_HANDLE        schSCManager = NULL;
    try
    {
        if ((schSCManager = OpenSCManager (
                NULL,    // machine (NULL == local)
                NULL,    // database (NULL == default)
                SC_MANAGER_ALL_ACCESS))==NULL)    // access required
        {
            
            throw GetLastError();
        }

        if ((schService = OpenService(
            schSCManager, 
            "DNS", 
            SERVICE_ALL_ACCESS))==NULL)
        {
            throw GetLastError();
        }

        if (ControlService(
            schService, 
            SERVICE_CONTROL_STOP, 
            (LPSERVICE_STATUS)&ss) == FALSE)
        {
            throw GetLastError();
        }

        // check its state
        DWORD dwTimeOut=6000; // 6 sec
        DWORD dwTimeCount=0;
        while ( dwTimeCount < dwTimeOut)
        {

            SERVICE_STATUS ServiceStatus;
            if(QueryServiceStatus(
                schService,               // handle to service
                &ServiceStatus  // pointer to service status structure
                ) == FALSE)
            {
                throw GetLastError();
            }
            
            if(ServiceStatus.dwCurrentState != SERVICE_STOPPED)
            {
                Sleep(2000);
                dwTimeCount +=2000;
            }
            else 
                break;
        }
    }
    catch(DWORD dwError)
    {
        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
        
        CHAR szErrDesc[ MAX_PATH ];
        FormatMessage( 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            szErrDesc,
            MAX_PATH,
            NULL );

        CHAR szErr[ MAX_PATH + 40 ];
        strcpy(szErr, "Fail to stop Dns because ");
        strcat(szErr, szErrDesc);
        CDnsProvException e(szErr);
        throw e;
        
    }

    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);

    return WBEM_S_NO_ERROR;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        save this instance
//
//    Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsServer::PutInstance( 
    IWbemClassObject *  pInst ,
    long                lFlags,
    IWbemContext*       pCtx ,
    IWbemObjectSink *   pHandler
    )
{
    DBG_FN( "CDnsServer::PutInstance" )

    DNS_DEBUG( INSTPROV, (
        "%s: pInst=%p\n",  fn, pInst ));

    CDnsWrap& dns = CDnsWrap::DnsObject();
    CWbemClassObject Inst(pInst);
    dns.dnsServerPropertySet(
        Inst,
        FALSE);
    return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\server.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsserver.h
//
//	Implementation File:
//		dnsserver.cpp
//
//	Description:
//		Definition of the CDnsServerclass.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once



#include "dnsbase.h"
class CObjPath;


class CDnsServer : public CDnsBase 
{
public:
	CDnsServer();
	CDnsServer(
        const WCHAR*,
		CWbemServices*
		);
	~CDnsServer();
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );

protected:
	SCODE StartServer(void);
	SCODE StopServer(void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\provfactory.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight (c) 1999 Microsoft Corporation
//
//  Module Name: provfactory.cpp
//
//  Description:    
//      Implementation of CProvFactory class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
    {
        delete this;
    }
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CInstanceProv *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CInstanceProv();
    if (NULL==pObj)
    {
        return E_OUTOFMEMORY;
    }

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
    {
        delete pObj;
    }
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\objectpath.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		objectpath.h
//
//	Implementation File:
//		objectpath.cpp
//
//	Description:
//		Definition of the CObjpath class and other common class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


#include "common.h"
#include <list>
#include <string>
#include "genlex.h"		//wbem sdk header
#include "objpath.h"	//wbem sdk header


using namespace std;


class CPropertyValue
{
public:
	CPropertyValue();
	CPropertyValue(
		const CPropertyValue&
		);
	CPropertyValue& operator=(
		const CPropertyValue&
		);
	virtual ~CPropertyValue();
	wstring m_PropName;
	VARIANT m_PropValue;
	wstring m_Operator;
};


/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjPath
//
//	Description:
//		CObjpath class make it easier to work with Object path string
//
//	Inheritance:
//		
//
//--
/////////////////////////////////////////////////////////////////////////////

class CObjPath 
{
public:
	wstring GetObjectPathString();
	BOOL SetProperty(
	    const WCHAR *   wszName,
	    //string &        strValue
        const WCHAR *   wszValue
		);
	BOOL AddProperty(
		const WCHAR*,
		string&
        );
	BOOL AddProperty(
	    const WCHAR *   wszName, 
	    const WCHAR *   wszValue
		);
	BOOL AddProperty(
	    const WCHAR *   wszName, 
	    VARIANT *       pvValue
        );
	BOOL AddProperty(
	    const WCHAR *   wszName, 
	    WORD            wValue
		);
	BOOL SetServer(
		const WCHAR *
		);
	BOOL SetNameSpace(
    	const WCHAR *wszValue
  		);
	BOOL SetClass(
    	const WCHAR *wszValue
		);
	wstring	GetStringValueForProperty(
    	const WCHAR* str
		);
	BOOL GetNumericValueForProperty(
	    const WCHAR *   wszName, 
	    WORD *          wValue
		);
	wstring	GetClassName(void);
	BOOL Init(
    	const WCHAR* szObjPath
		);
/*	wstring m_Server;
	wstring m_NameSpace;
	wstring m_Class;
	list<CPropertyValue> m_PropList;
*/	
	CObjPath();
	CObjPath(
		const CObjPath&
		);
	virtual ~CObjPath();
protected:
	wstring m_Server;
	wstring m_NameSpace;
	wstring m_Class;
	list<CPropertyValue> m_PropList;

};

class CDomainNode
{
public:
	wstring wstrZoneName;
	wstring wstrNodeName;
	wstring wstrChildName;
	CDomainNode();
	~CDomainNode();
	CDomainNode(
		const CDomainNode& 
		);
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjPath
//
//	Description:
//		base provider exception class
//
//	Inheritance:
//		exception
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsProvException : public exception
{
public:
    CDnsProvException(
		const char* ,
		DWORD = 0);
    CDnsProvException();
	~CDnsProvException();
	CDnsProvException(
		const CDnsProvException& 
		) 
		throw();
    CDnsProvException& operator=(
		const CDnsProvException& 
		) throw();

	const char *what() const throw();
	DWORD GetErrorCode(void);
protected:
	string m_strError;
	DWORD m_dwCode;
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjPath
//
//	Description:
//		exception class specialized for set value exception
//
//	Inheritance:
//		CDnsProvException
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsProvSetValueException : public CDnsProvException
{
public:
	CDnsProvSetValueException();
	~CDnsProvSetValueException();
	CDnsProvSetValueException(
		const WCHAR*
		);
	CDnsProvSetValueException(
		const CDnsProvSetValueException& rhs
		) throw();
    CDnsProvSetValueException& operator=(
		const CDnsProvSetValueException& rhs
		) throw();
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjPath
//
//	Description:
//		exception class specialized for get value exception
//
//	Inheritance:
//		CDnsProvException
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsProvGetValueException : public CDnsProvException
{
public:
	CDnsProvGetValueException();
	~CDnsProvGetValueException();
	CDnsProvGetValueException(
		const WCHAR*
		);
	CDnsProvGetValueException(
		const CDnsProvGetValueException& rhs
		) throw();
    CDnsProvGetValueException& operator=(
		const CDnsProvGetValueException& rhs
		) throw();
};
/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWbemClassObject
//
//	Description:
//		Wrap for IWbemClassObject
//  
//
//	Inheritance:
//      	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CWbemClassObject
{
protected:
	IWbemClassObject* m_pClassObject;
	VARIANT m_v;
public:
	CWbemClassObject();
	CWbemClassObject(IWbemClassObject*);
	virtual ~CWbemClassObject();
	IWbemClassObject** operator&();
	
	SCODE SetProperty(
        LPCSTR  pszValue, 
        LPCWSTR wszPropName
        );

	SCODE SetProperty(
        DWORD   dwValue, 
        LPCWSTR wszPropName
		);
	SCODE SetProperty(
        UCHAR   ucValue, 
        LPCWSTR wszPropName
        );

	SCODE SetProperty(
        LPCWSTR pszValue, 
        LPCWSTR wszPropName
		);

	SCODE SetProperty(
        wstring &   wstrValue, 
        LPCWSTR     wszPropName
        );

	SCODE SetProperty(
        SAFEARRAY * psa, 
        LPCWSTR     wszPropName
        );
	SCODE SetProperty(
        DWORD *     pdwValue, 
        DWORD       dwSize, 
        LPCWSTR     wszPropName
        );


	SCODE GetProperty(
        DWORD *     dwValue, 
        LPCWSTR     wszPropName
		);

	SCODE GetProperty(
        wstring &   wsStr, 
        LPCWSTR     wszPropName
        );
	SCODE GetProperty(
        string &    strStr, 
        LPCWSTR     wszPropName
        );
	SCODE GetProperty(
        BOOL *  bValue, 
        LPCWSTR szPropName
		);
	SCODE GetProperty(
		SAFEARRAY** ,
		LPCWSTR);
	SCODE GetProperty(
        DWORD **    ppValue, 
        DWORD *     dwSize, 
        LPCWSTR     szPropName
		);
	SCODE GetProperty(
        DWORD Value[], 
        DWORD *dwSize, 
        LPCWSTR szPropName
        );
	SCODE GetProperty(
        VARIANT *   pv, 
        LPCWSTR     wszPropName 
        );
	SCODE GetMethod(
        BSTR                name,
        LONG                lFlag,
        IWbemClassObject**  ppIN,
        IWbemClassObject**  ppOut
        );
	SCODE SpawnInstance(
		LONG,
		IWbemClassObject**);

	IWbemClassObject* data() { return m_pClassObject;};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\ulti.h ===
//#if !defined(_DNS_UTIL_H_)
//#define _DNS_UTIL_H_

//#if _MSC_VER > 1000
//#pragma once
//#endif // _MSC_VER > 1000

#include <wbemprov.h>
//typedef LPVOID * PPVOID;

//SCODE CreateInst( IWbemServices * pNamespace, LPWSTR pKey, long lVal, 
//                                             IWbemClassObject ** pNewInst,
//                                             WCHAR * pwcClassName,
//											 IWbemContext  *pCtx); 



// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ds.inc ===
############################################################################
#
#   Copyright (C) 1992, Microsoft Corporation.
#
#   All rights reserved.
#
#   This file contains default definitions for building the DS project
#   under the NT build environment. It should be included into the sources
#   file of any component with a line of the form
#
#       !include ..\..\ds.inc
#
#   where the number of "..\"s is sufficient to reach the root of the
#   DS\SRC subtree.
#
############################################################################


MAJORCOMP=ds
# each subdirectory must define MINORCOMP

USE_MSVCRT=1

# Include code to support unit tests if INCLUDE_UNIT_TESTS env var is set.
!ifdef INCLUDE_UNIT_TESTS
C_DEFINES=$(C_DEFINES) -DINCLUDE_UNIT_TESTS
!endif

# Include code to support thalloc trace if USE_THALLOC_TRACE env var is set.
!ifdef USE_THALLOC_TRACE
C_DEFINES=$(C_DEFINES) -DUSE_THALLOC_TRACE
!endif

!if $(IA64)
# Emit LTCG codegen
LTCG_SRVWKS=1
!endif

# If you use a global pch file, the compiler emits warnings if the defines
#  used to build the pch are different than those used to build the
#  source module which references the pch. Such warnings are usually benign
#  but all the same should be avoided. The following macros define the
#  additional settings used to build each of the global pch's in the dsys
#  tree. Any sources file which references a global pch must set
#
#       C_DEFINES= $(C_DEFINES) $(xxxPCH_DEFINES)

!ifndef DONT_USE_NtDsPch

!ifdef CPLUSPLUSDIR
PRECOMPILED_CXX=1
PCH_NAME=ntdspchx
!else
PCH_NAME=ntdspch
!endif
PRECOMPILED_INCLUDE=$(PROJECT_ROOT)\ds\src\inc\$(PCH_NAME).h
PRECOMPILED_TARGET=$(O)\$(PCH_NAME).pch
HEADERFILE=/Fp$(PRECOMPILED_TARGET)
PRECOMPILED_OPTION=/Yu$(PCH_NAME).h $(HEADERFILE)
HEADEROBJNAME=$(O)\$(PCH_NAME).obj
HEADEROBJ=/Fo$(HEADEROBJNAME)

!if 0
! ifndef CPLUSPLUSDIR
PRECOMPILED_OPTION=/YuNtDsPch.h /Fp$(NTDS_INC)\c\$(O)\ntdspch.pch
HEADEROBJNAME= $(NTDS_INC)\c\$(O)\ntdspch.obj
!  ifdef USE_PDB_TO_COMPILE
PRECOMPILED_OPTION=$(PRECOMPILED_OPTION) /Fd$(NTDS_INC)\c\$(O)\pch.pdb
!  endif
! else
PRECOMPILED_OPTION=/YuNtDsPchX.h /Fp$(NTDS_INC)\cxx\$(O)\ntdspchx.pch
!  ifdef USE_PDB_TO_COMPILE
PRECOMPILED_OPTION=$(PRECOMPILED_OPTION) /Fd$(NTDS_INC)\cxx\$(O)\pch.pdb
!  endif
HEADEROBJNAME= $(NTDS_INC)\cxx\$(O)\ntdspchx.obj
PRECOMPILED_CXX=1
! endif
!endif

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\abw.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

      abw2.cxx

   Abstract:
      This module implements functions required for bandwidth throttling
       of network usage by ATQ module.

   Author:

       Murali R. Krishnan    ( MuraliK )     1-June-1995
       Bilal Alam            ( t-bilala )    7-March-1997

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Asynchronous Thread Queue DLL

--*/

#include "isatq.hxx"

//
// Global variables
//

extern PBANDWIDTH_INFO       g_pBandwidthInfo;

//
// Bandwidth Info shared variables
//

CRITICAL_SECTION        BANDWIDTH_INFO::sm_csSharedLock;
LIST_ENTRY              BANDWIDTH_INFO::sm_BornListHead;
LIST_ENTRY              BANDWIDTH_INFO::sm_ActiveListHead;
DWORD                   BANDWIDTH_INFO::sm_cBornList;
DWORD                   BANDWIDTH_INFO::sm_cActiveList;
ALLOC_CACHE_HANDLER*    BANDWIDTH_INFO::sm_pachBWInfos;
BOOL                    BANDWIDTH_INFO::sm_fGlobalEnabled;
BOOL                    BANDWIDTH_INFO::sm_fGlobalActive;
DWORD                   BANDWIDTH_INFO::sm_cNonInfinite;
DWORD                   BANDWIDTH_INFO::sm_cSamplesForTimeout;

//
// BANDWIDTH_INFO methods
//

VOID
BANDWIDTH_INFO::Initialize(
    IN BOOL             fPersistent
)
/*++
  Initialize bandwidth info object.  This is a pseudo-constructor for the
  class.

  Arguments:
    fPersistent - TRUE if this object is destroyed explicitly
                  FALSE if destroyed when refcount hits 0

  Returns:
    None

--*/
{
    _fMemberOfActiveList        = FALSE;
    _bandwidth.dwSpecifiedLevel = INFINITE;
    _bandwidth.dwLowThreshold   = INFINITE;
    _bandwidth.dwHighThreshold  = INFINITE;
    _cMaxBlockedList            = INFINITE;
    _fEnabled                   = FALSE;
    _Signature                  = ATQ_BW_INFO_SIGNATURE;
    _fIsFreed                   = FALSE;
    _fPersistent                = fPersistent;
    _cReference                 = 1;

    InitializeCriticalSection( &_csPrivateLock );
    SET_CRITICAL_SECTION_SPIN_COUNT( &_csPrivateLock,
                                     IIS_DEFAULT_CS_SPIN_COUNT);
    InitializeListHead( &_BlockedListHead );

    ZeroMemory( _rgBytesXfered, sizeof( _rgBytesXfered ) );

    _pBytesXferCur = _rgBytesXfered;  // points to start of array
    _cbXfered.QuadPart = 0;

    _pStatus = &sm_rgStatus[ ZoneLevelLow ][ 0 ];

    ClearStatistics();

    AddToBornList();

    SetDescription( "Default" );
}

VOID
BANDWIDTH_INFO::Terminate( VOID )
/*++
  Destroys bandwidth info object.  This is a pseudo-destructor.

  Arguments:
    None

  Returns:
    None

--*/
{
    Lock();

    // first prevent any new requests from getting blocked

    InterlockedExchangePointer((PVOID *) &_pStatus,
                               &sm_rgStatus[ZoneLevelLow][0] );

    // disable the descriptor

    InterlockedExchange( (LPLONG) &_fEnabled, FALSE );

    // now remove any blocked requests

    ATQ_REQUIRE( CheckAndUnblockRequests() );
    ATQ_ASSERT( _cCurrentBlockedRequests == 0 );
    ATQ_ASSERT( IsListEmpty( &_BlockedListHead ) );

    Unlock();

    DeleteCriticalSection( &_csPrivateLock );

    // remove self from shared bandwidth info list

    SharedLock();

    RemoveFromBornList();

    SharedUnlock();

    _Signature = ATQ_BW_INFO_SIGNATURE_FREE;
}

BOOL
BANDWIDTH_INFO::PrepareToFree( VOID )
{
    InterlockedExchange( (LPLONG) &_fIsFreed, TRUE );
    Dereference();
    return TRUE;
}

BOOL
BANDWIDTH_INFO::BlockRequest(
    IN OUT PATQ_CONT        pAtqContext
)
/*++
  Block this request on the queue of requests waiting to be processed.

  Arguments:
    pAtqContext   pointer to ATQ context information for request that needs
                  to be blocked.

  Returns:
    TRUE on success. FALSE if there are any errors.
    (Use GetLastError() for details)

--*/
{
    BOOL            fRet = TRUE;

    ATQ_ASSERT( pAtqContext != NULL);
    ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( IsValidAtqOp( pAtqContext->arInfo.atqOp ) );

    Lock();

    if ( _cCurrentBlockedRequests == _cMaxBlockedList )
    {
        fRet = FALSE;
    }
    else
    {
        pAtqContext->SetFlag( ACF_BLOCKED );

        InsertTailList( &_BlockedListHead, &pAtqContext->BlockedListEntry );

        IncCurrentBlockedRequests();
    }

    Unlock();

    return fRet;
}

BOOL
BANDWIDTH_INFO::RemoveFromBlockedList(
    IN PATQ_CONT            pAtqContext
)
/*++
  This function forcibly removes an ATQ context from blocked list of requests.

  Argument:
   pAtqContext    pointer to ATQ context whose request is in blocked list.

  Returns:
   TRUE on success and FALSE if there is any error.
--*/
{
    if ( !pAtqContext->IsBlocked() ) {

        // some other thread just removed this request from waiting list.
        return TRUE;
    }

    Lock();

    RemoveEntryList(&pAtqContext->BlockedListEntry);

    DecCurrentBlockedRequests();

    pAtqContext->ResetFlag( ACF_BLOCKED);

    Unlock();

    //
    // On such a forcible removal, we may have to make a callback indicating
    //   failure. Ignored!  To be done by the caller of this API.
    //

    return TRUE;
}

BOOL
BANDWIDTH_INFO::UnblockRequest(
    IN OUT PATQ_CONT        pAtqContext
)
/*++
  Unblocks this request from the queue of requests waiting to be processed.
  Call this function only when
       _pStatus[pAtqContext->atqOp] != StatusBlockOperation.
  First, this function removes the request from queue of requests and processes
   it according to status and operation to be performed.
  If the status is AllowRequest ==> this function restarts the operation.
  If the status is reject operation ==> rejects operation and invokes
                        call back function indicating the error status.

  Call this function after lock()ing


  Arguments:
    pAtqContext   pointer to ATQ context information for request that needs
                     to be unblocked.

  Returns:
    TRUE on success. FALSE if there are any errors.
    (Use GetLastError() for details)

--*/
{

    DBG_ASSERT(FALSE);
    return FALSE;
#if 0
    BOOL fRet = FALSE;

    ATQ_ASSERT( pAtqContext != NULL);
    ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );

    // Remove the request from the blocked list entry
    RemoveEntryList( &pAtqContext->BlockedListEntry);
    DecCurrentBlockedRequests();
    pAtqContext->ResetFlag( ACF_BLOCKED );

    // Check and re enable the operation of pAtqContext

    switch ( _pStatus[ pAtqContext->arInfo.atqOp ] ) {

      case StatusAllowOperation:

        IncTotalAllowedRequests();
        switch ( pAtqContext->arInfo.atqOp) {

          case AtqIoRead:
            {
                DWORD cbRead;  // Discard after calling ReadFile()
                DWORD dwFlags = 0;

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opReadWrite.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    fRet =
                        ((WSARecv( (SOCKET ) pAtqContext->hAsyncIO,
                                   pAtqContext->arInfo.uop.opReadWrite.pBufAll,
                                   pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                   &cbRead,
                                   &dwFlags,
                                   pAtqContext->arInfo.lpOverlapped,
                                   NULL
                                   ) == 0)||
                         (WSAGetLastError() == WSA_IO_PENDING)
                         );

                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                } else {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opReadWrite.buf1.len,
                      pAtqContext->arInfo.uop.opReadWrite.buf1.buf
                    };
                    fRet = (( WSARecv( (SOCKET ) pAtqContext->hAsyncIO,
                                       &wsaBuf,
                                       1,
                                       &cbRead,
                                       &dwFlags,
                                       pAtqContext->arInfo.lpOverlapped,
                                       NULL
                                       ) == 0)||
                            (WSAGetLastError() == WSA_IO_PENDING)
                            );
                }
                break;
            }

          case AtqIoWrite:
            {
                DWORD cbWrite;  // Discard after calling WriteFile()

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opReadWrite.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    fRet =
                        ((WSASend( (SOCKET ) pAtqContext->hAsyncIO,
                                   pAtqContext->arInfo.uop.opReadWrite.pBufAll,
                                   pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                   &cbWrite,
                                   0,
                                   pAtqContext->arInfo.lpOverlapped,
                                   NULL
                                   ) == 0)||
                         (WSAGetLastError() == WSA_IO_PENDING)
                         );

                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                } else {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opReadWrite.buf1.len,
                      pAtqContext->arInfo.uop.opReadWrite.buf1.buf
                    };
                    fRet = (( WSASend( (SOCKET ) pAtqContext->hAsyncIO,
                                       &wsaBuf,
                                       1,
                                       &cbWrite,
                                       0,
                                       pAtqContext->arInfo.lpOverlapped,
                                       NULL
                                       ) == 0)||
                            (WSAGetLastError() == WSA_IO_PENDING)
                            );
                }
                break;
            }

          case AtqIoXmitFile:
            {
                fRet = TransmitFile( (SOCKET ) pAtqContext->hAsyncIO,
                                     pAtqContext->arInfo.uop.opXmit.hFile,
                                     pAtqContext->arInfo.uop.opXmit.
                                         dwBytesInFile,
                                     0,
                                     pAtqContext->arInfo.lpOverlapped,
                                     pAtqContext->arInfo.uop.
                                           opXmit.lpXmitBuffers,
                                     pAtqContext->arInfo.uop.
                                           opXmit.dwFlags );

                if ( !fRet && (GetLastError() == ERROR_IO_PENDING) ) {
                    fRet = TRUE;
                }
                break;
            }

          case AtqIoXmitFileRecv:
            {
                DWORD cbRead;

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opXmitRecv.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opXmitRecv.pBufAll);
                    fRet = I_AtqTransmitFileAndRecv
                               ( (PATQ_CONTEXT) pAtqContext,
                                 pAtqContext->arInfo.uop.opXmitRecv.hFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBytesInFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.lpXmitBuffers,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwTFFlags,
                                 pAtqContext->arInfo.uop.opXmitRecv.pBufAll,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBufferCount
                                );
                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opXmitRecv.pBufAll);
                    pAtqContext->arInfo.uop.opXmitRecv.pBufAll = NULL;
                }
                else
                {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opXmitRecv.buf1.len,
                      pAtqContext->arInfo.uop.opXmitRecv.buf1.buf
                    };
                    fRet = I_AtqTransmitFileAndRecv
                               ( (PATQ_CONTEXT) pAtqContext,
                                 pAtqContext->arInfo.uop.opXmitRecv.hFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBytesInFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.lpXmitBuffers,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwTFFlags,
                                 &wsaBuf,
                                 1 );
                }

                if ( !fRet && GetLastError() == ERROR_IO_PENDING )
                {
                    fRet = TRUE;
                }
                break;
            }

          case AtqIoSendRecv:
            {
                WSABUF wsaSendBuf =
                { pAtqContext->arInfo.uop.opSendRecv.sendbuf1.len,
                  pAtqContext->arInfo.uop.opSendRecv.sendbuf1.buf
                };

                WSABUF wsaRecvBuf =
                {
                  pAtqContext->arInfo.uop.opSendRecv.recvbuf1.len,
                  pAtqContext->arInfo.uop.opSendRecv.recvbuf1.buf
                };

                LPWSABUF     pSendBuf = &wsaSendBuf;
                LPWSABUF     pRecvBuf = &wsaRecvBuf;

                if ( pAtqContext->arInfo.uop.opSendRecv.dwSendBufferCount > 1 )
                {
                    pSendBuf = pAtqContext->arInfo.uop.opSendRecv.pSendBufAll;
                }

                if ( pAtqContext->arInfo.uop.opSendRecv.dwRecvBufferCount > 1 )
                {
                    pRecvBuf = pAtqContext->arInfo.uop.opSendRecv.pRecvBufAll;
                }

                ATQ_ASSERT( pSendBuf != NULL );
                ATQ_ASSERT( pRecvBuf != NULL );

                fRet = I_AtqSendAndRecv
                                    ( (PATQ_CONTEXT) pAtqContext,
                                      pSendBuf,
                                      pAtqContext->arInfo.uop.opSendRecv.
                                        dwSendBufferCount,
                                      pRecvBuf,
                                      pAtqContext->arInfo.uop.opSendRecv.
                                        dwRecvBufferCount );

                if ( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll != NULL )
                {
                    ::LocalFree( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll );
                }

                if ( pAtqContext->arInfo.uop.opSendRecv.pRecvBufAll != NULL )
                {
                    ::LocalFree( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll );
                }

                if ( !fRet && (GetLastError() == ERROR_IO_PENDING ) ) {
                    fRet = TRUE;
                }

                break;
            }

          default:
            ATQ_ASSERT( FALSE);
            break;
        } // switch

        pAtqContext->arInfo.atqOp = AtqIoNone; // reset since operation done.
        break;

      case StatusRejectOperation:

        IncTotalRejectedRequests();
        if ( ((pAtqContext->arInfo.atqOp == AtqIoRead) ||
             (pAtqContext->arInfo.atqOp == AtqIoRead)) &&
             (pAtqContext->arInfo.uop.opReadWrite.pBufAll != NULL)
             ) {
            ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
            pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
        }
        pAtqContext->arInfo.atqOp = AtqIoNone; // reset since op rejected.
        SetLastError( ERROR_NETWORK_BUSY);
        fRet = FALSE;
        break;

      case StatusBlockOperation:
        // do nothing. we cannot unblock
        ATQ_ASSERT(FALSE);
        return (TRUE);

      default:
        ATQ_ASSERT( FALSE);
        break;
    } // switch

    if (!fRet) {

        // Call the completion function to signify the error in operation.

        //
        //  Reset the timeout value so requests don't
        //  timeout multiple times
        //

        InterlockedExchange(
                    (LPLONG ) &pAtqContext->NextTimeout,
                    ATQ_INFINITE
                    );

        InterlockedDecrement( &pAtqContext->m_nIO);

        pAtqContext->IOCompletion( 0,
                                   GetLastError(),
                                   pAtqContext->arInfo.lpOverlapped );
    } // on failure.

    return (fRet);
#endif
}

BOOL
BANDWIDTH_INFO::CheckAndUnblockRequests( VOID )
/*++
  Checks the list of blocked requests and identifies all operations
  that needs to be unblocked. This function unblocks those requests and
  removes them from blocked list.

  Always call this function after lock()ing

  Returns:
    TRUE on success and FALSE on failure.

--*/
{
    BOOL fRet = TRUE;

    //
    //  If the list is not empty, then check and process blocked requests.
    //

    if ( !IsListEmpty( &_BlockedListHead ) ) {

        PLIST_ENTRY pentry;

        //
        //  Scan the blocked requests list looking for pending requests
        //   that needs to be unblocked and unblock these requests.
        //

        for (pentry  = _BlockedListHead.Flink;
             pentry != &_BlockedListHead;
             pentry  = pentry->Flink )
          {
              PATQ_CONT pContext = CONTAINING_RECORD(pentry,
                                                     ATQ_CONTEXT,
                                                     BlockedListEntry );

              if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE)
                {
                    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                    fRet = FALSE;
                    break;
                }

              if ( !pContext->IsBlocked()) {

                  // This should not happen.
                  ATQ_ASSERT( !pContext->IsBlocked());
                  fRet = FALSE;
                  continue;
              }

              //
              //  Check to see if the status for operation has changed.
              //  If so, unblock the request.
              //

              if ( _pStatus[pContext->arInfo.atqOp] !=
                  StatusBlockOperation) {

                  fRet &= UnblockRequest( pContext );
              }

          } // scan list
    }

    return (fRet);
}

BOOL
BANDWIDTH_INFO::UpdateBandwidth(
    VOID
)
/*++
  This function updates the current bandwidth value using the histogram
   of bytes transferred.
  The histogram maintains a history of bytes transferred over different sample
   periods of a single minute. Each entry in the histogram corresponds to one
   interval of sample. The sum of all entries gives the total bytes transferred
   in a single minute. We divide this measure by 60 to obtain the count of
   bytes transferred over a second. This update bandwidth is used to
   reevalute the tuner of bandwidth throttle based on our throttling policy
   (specified in throttling algorithm). The updated action information is
   used by subsequent requests.
  In addition the _pcbXfered pointer is advanced forward using the
   histogram entries as a circular buffer, to obtain the count of bytes
   for next interval.

  Arguments:
    pdwPrivateBw - Filled with bandwidth for this descriptor

  Returns:
    TRUE on success. FALSE otherwise.

  Note:
   It is recommended that this function be called as infrequently as
    possible, using reasonable sample intervals.

--*/
{
    BOOL fRet = TRUE;
    ZoneLevel zonelevel;

    Lock();

    // accumulate current byte count to global counter, to minimize computation
    _cbXfered.QuadPart = _cbXfered.QuadPart + _pBytesXferCur->QuadPart;

    //
    // Current n/ws support a max of 1 to 100 MB/s. We can represent
    //  4GB/s in a DWORD. Hence the cast is used. This may need revision later.
    // Better yet, later we should store bandwidth as KB/seconds.
    //
    _dwMeasuredBw = (DWORD ) (_cbXfered.QuadPart/ATQ_AVERAGING_PERIOD);

    CIRCULAR_INCREMENT( _pBytesXferCur, _rgBytesXfered, ATQ_HISTOGRAM_SIZE);
    // Adjust the global cumulative bytes sent after increment.
    _cbXfered .QuadPart = _cbXfered.QuadPart - _pBytesXferCur->QuadPart;
    // Reset the counter to start with the new counter value.
    _pBytesXferCur->QuadPart = 0;

    //
    // update the operation status depending upon the bandwidth comparisons.
    // we use band/zone calculations to split the result into 3 zones.
    // Depending upon the zone we update the global status pointer to
    //   appropriate row.
    //

    if ( _dwMeasuredBw < ATQ_LOW_BAND_THRESHOLD(_bandwidth)) {

        //
        // Lower zone. Modify the pointer to OPERATION_STATUS accordingly.
        //

        zonelevel = ZoneLevelLow;

    } else if ( _dwMeasuredBw > ATQ_HIGH_BAND_THRESHOLD(_bandwidth)) {

        //
        // Higher zone. Modify the pointer to OPERATION_STATUS accordingly.
        //

        zonelevel = ZoneLevelHigh;

    } else {

        zonelevel = ZoneLevelMedium;
    }

    /*++
      Above calculation can be implemented as:
      zonelevel = (( sm_dwMeasuredBw > ATQ_LOW_BAND_THRESHOLD( sm_bandwidth)) +
                   ( sm_dwMeasuredBw > ATQ_HIGH_BAND_THRESHOLD( sm_bandwidth)));

      This is based on implicit dependence of ordering of ZoneLevel entries.
      So avoided for present now.
    --*/

    if ( _pStatus != &sm_rgStatus[zonelevel][0]) {

        // Status needs to be changed.
        _pStatus = &sm_rgStatus[zonelevel][0];

        // Examine and reenable blocked operations if any.
        fRet &= CheckAndUnblockRequests();
    }

    // remove the bandwidth info object from the list if it is
    // "inactive" (bandwidth = 0)

    if ( !_dwMeasuredBw )
    {
        // there should be no requests in the blocked queue!

        ATQ_ASSERT( _cCurrentBlockedRequests == 0 );

        RemoveFromActiveList();
    }

    Unlock();

    return fRet;
}

DWORD
BANDWIDTH_INFO::SetBandwidthLevel(
    IN DWORD                    Data
)
/*++
   Sets the bandwidth threshold

   Arguments:
      Data - Bandwidth threshold

   Returns:
      Old bandwidth threshold (DWORD)
--*/
{
    DWORD dwOldVal;
    INT iListDelta = 0;

    Lock();

    dwOldVal = _bandwidth.dwSpecifiedLevel;

    if ( Data != INFINITE) {

        DWORD dwTemp;

        _bandwidth.dwSpecifiedLevel  = ATQ_ROUNDUP_BANDWIDTH( Data );
        dwTemp = ( Data *9)/10;               //low threshold = 0.9*specified
        _bandwidth.dwLowThreshold    = ATQ_ROUNDUP_BANDWIDTH( dwTemp);
        dwTemp = ( Data *11)/10;              //high threshold= 1.1*specified
        _bandwidth.dwHighThreshold   = ATQ_ROUNDUP_BANDWIDTH( dwTemp);

        _fEnabled = TRUE;
        // we should recheck the throttling and blocked requests
        // Will be done when the next timeout occurs in the ATQ Timeout Thread

        if ( dwOldVal == INFINITE )
        {
            iListDelta = 1;
        }

    } else {

        _bandwidth.dwSpecifiedLevel = INFINITE;
        _bandwidth.dwLowThreshold   = INFINITE;
        _bandwidth.dwHighThreshold  = INFINITE;

        _fEnabled = FALSE;

        // enable all operations, since we are in low zone
        _pStatus = &sm_rgStatus[ZoneLevelLow][0];

        // we should recheck and enable all blocked requests.
        if ( _cCurrentBlockedRequests > 0) {
            ATQ_REQUIRE( CheckAndUnblockRequests());
        }

        if ( dwOldVal != INFINITE )
        {
            iListDelta = -1;
        }
    }

    Unlock();

    // update the static counter of how many non-infinite throttles we have

    if ( iListDelta )
    {
        SharedLock();

        if ( iListDelta > 0 )
        {
            sm_cNonInfinite++;
        }
        else
        {
            sm_cNonInfinite--;
        }
        sm_fGlobalEnabled = !!sm_cNonInfinite;

        SharedUnlock();
    }

    return dwOldVal;

}

DWORD
BANDWIDTH_INFO::SetMaxBlockedListSize(
    IN DWORD                    cMaxSize
)
/*++
   Sets the maximum size of blocked request list

   Arguments:
      cMaxSize - maximum size of list

   Returns:
      Old max size (DWORD)
--*/
{
    DWORD           cOldMax;

    Lock();

    cOldMax = _cMaxBlockedList;
    _cMaxBlockedList = cMaxSize;

    Unlock();

    return cOldMax;
}

DWORD
BANDWIDTH_INFO::QueryBandwidthLevel( VOID )
/*++
   Retrieve the current bandwidth level

   Arguments:
      None

   Returns:
      Set Bandwidth level (DWORD)
--*/
{
    DWORD dwBw;

    Lock();

    dwBw = _bandwidth.dwSpecifiedLevel;

    Unlock();

    return dwBw;
}

BOOL
BANDWIDTH_INFO::ClearStatistics( VOID )
{
    Lock();

    _cTotalAllowedRequests = 0;
    _cTotalBlockedRequests = 0;
    _cTotalRejectedRequests = 0;

    Unlock();

    return TRUE;
}

BOOL
BANDWIDTH_INFO::GetStatistics( OUT ATQ_STATISTICS * pAtqStats )
{
    ATQ_ASSERT( pAtqStats != NULL );

    pAtqStats->cRejectedRequests = _cTotalRejectedRequests;
    pAtqStats->cBlockedRequests = _cTotalBlockedRequests;
    pAtqStats->cAllowedRequests = _cTotalAllowedRequests;
    pAtqStats->cCurrentBlockedRequests = _cCurrentBlockedRequests;
    pAtqStats->MeasuredBandwidth = _dwMeasuredBw;

    return TRUE;
}

BOOL
BANDWIDTH_INFO::UpdateAllBandwidths( VOID )
{
    PLIST_ENTRY             pEntry;
    BOOL                    fRet = TRUE;
    DWORD                   dwCounter = 0;

    SharedLock();

    for ( pEntry = sm_ActiveListHead.Flink;
          pEntry != &sm_ActiveListHead; )
    {
        BANDWIDTH_INFO *pBandwidthInfo = CONTAINING_RECORD( pEntry,
                                                            BANDWIDTH_INFO,
                                                            _ActiveListEntry );

        ATQ_ASSERT( pBandwidthInfo != NULL );

        // we might be deleting this entry from the list.  Grab the next
        // link now before we do so the traversal can happen smoothly

        pEntry = pEntry->Flink;

        if ( !pBandwidthInfo->Enabled() )
        {
            continue;
        }

        if ( !pBandwidthInfo->UpdateBandwidth() )
        {
            fRet = FALSE;
            break;
        }

        ATQ_PRINTF(( DBG_CONTEXT, "pBWInfo =  %p (%s), Bandwidth = %u, Threshold = %d\n",
                     pBandwidthInfo,
                     pBandwidthInfo->_achDescription,
                     pBandwidthInfo->QueryMeasuredBw(),
                     pBandwidthInfo->QueryBandwidthLevel() ) );
    }

    SharedUnlock();

    return fRet;
}

BOOL
BANDWIDTH_INFO::AbwInitialize( VOID )
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, 10, sizeof(BANDWIDTH_INFO)};

    ATQ_ASSERT( sm_pachBWInfos == NULL );

    sm_pachBWInfos = new ALLOC_CACHE_HANDLER( "BandwidthInfos",
                                              &acConfig );

    if ( sm_pachBWInfos == NULL )
    {
        return FALSE;
    }

    InitializeListHead( &sm_ActiveListHead );
    InitializeListHead( &sm_BornListHead );
    InitializeCriticalSection( &sm_csSharedLock );

    sm_cActiveList          = 0;
    sm_cBornList            = 0;
    sm_fGlobalEnabled       = FALSE;
    sm_fGlobalActive        = FALSE;
    sm_cNonInfinite         = 0;
    sm_cSamplesForTimeout   = 1;

    g_pBandwidthInfo = new BANDWIDTH_INFO( TRUE );

    if ( !g_pBandwidthInfo )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
BANDWIDTH_INFO::AbwTerminate( VOID )
{
    PBANDWIDTH_INFO         pBandwidthInfo;

    ATQ_PRINTF(( DBG_CONTEXT,
                 "AbwTerminate() called.  Born List Size = %d\n",
                 sm_cBornList ));

    SharedLock();

    while( !IsListEmpty( &sm_BornListHead ) )
    {
        pBandwidthInfo = CONTAINING_RECORD( sm_BornListHead.Flink,
                                            BANDWIDTH_INFO,
                                            _BornListEntry );

        ATQ_ASSERT( pBandwidthInfo != NULL );

        delete pBandwidthInfo;
    }

    ATQ_ASSERT( sm_cBornList == 0 );
    ATQ_ASSERT( sm_cActiveList == 0 );
    ATQ_ASSERT( IsListEmpty( &sm_BornListHead ) );
    ATQ_ASSERT( IsListEmpty( &sm_ActiveListHead ) );

    SharedUnlock();

    DeleteCriticalSection( &sm_csSharedLock );

    if ( sm_pachBWInfos != NULL )
    {
        delete sm_pachBWInfos;
        sm_pachBWInfos = NULL;
    }

    return TRUE;
}


PVOID
AtqCreateBandwidthInfo( VOID )
/*++

Routine Description:

    Allocate a bandwidth throttling descriptor

Arguments:

    none

Return Value:

    If successful, pointer to allocated descriptor.  Otherwise NULL.

--*/
{
    PBANDWIDTH_INFO         pBandwidthInfo;

    pBandwidthInfo = new BANDWIDTH_INFO( FALSE );
    if ( pBandwidthInfo == NULL )
    {
        return NULL;
    }
    else
    {
        ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );
        return pBandwidthInfo;
    }
}


BOOL
AtqFreeBandwidthInfo(
    IN PVOID        pvBandwidthInfo
)
/*++

Routine Description:

    Free bandwidth throttling descriptor

Arguments:

    pBandwidthInfo - Descriptor to destroy

Return Value:

    TRUE If successful, else FALSE.

--*/
{
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    return pBandwidthInfo->PrepareToFree();
}


DWORD_PTR
AtqBandwidthSetInfo(
      IN PVOID                 pvBandwidthInfo,
      IN ATQ_BANDWIDTH_INFO    BwInfo,
      IN DWORD_PTR             Data
)
/*++

Routine Description:

    Set member of bandwidth descriptor

Arguments:

    pBandwidthInfo - Descriptor to change
    BwInfo - Value of descriptor to set
    Data - Data to set to

Return Value:

    Previous value of descriptor

--*/
{
    DWORD_PTR       dwOldVal = 0;
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( pBandwidthInfo &&
         pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE )
    {
        switch ( BwInfo )
        {
        case ATQ_BW_BANDWIDTH_LEVEL:
            dwOldVal = pBandwidthInfo->QueryBandwidthLevel();
            pBandwidthInfo->SetBandwidthLevel( (DWORD)Data );
            break;
        case ATQ_BW_MAX_BLOCKED:
            dwOldVal = pBandwidthInfo->QueryMaxBlockedSize();
            pBandwidthInfo->SetMaxBlockedListSize( (DWORD)Data );
            break;
        case ATQ_BW_DESCRIPTION:
            dwOldVal = Data;
            pBandwidthInfo->SetDescription( (CHAR*) Data );
            break;
        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ATQ_ASSERT( FALSE );
            break;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
    }

    return dwOldVal;
}


BOOL
AtqBandwidthGetInfo(
      IN PVOID                 pvBandwidthInfo,
      IN ATQ_BANDWIDTH_INFO    BwInfo,
      OUT DWORD_PTR *          pdwData
)
/*++

Routine Description:

    Get member of bandwidth descriptor

Arguments:

    pvBandwidthInfo - Descriptor to change
    BwInfo - Value of descriptor to set
    pdwData - Output here

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    BOOL            fRet = TRUE;
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );
    ATQ_ASSERT( pdwData );

    if ( pBandwidthInfo &&
         pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE &&
         pdwData )
    {
        switch ( BwInfo )
        {
        case ATQ_BW_BANDWIDTH_LEVEL:
            *pdwData = pBandwidthInfo->QueryBandwidthLevel();
            break;
        case ATQ_BW_MAX_BLOCKED:
            *pdwData = pBandwidthInfo->QueryMaxBlockedSize();
            break;
        case ATQ_BW_STATISTICS:
            fRet = pBandwidthInfo->GetStatistics( (ATQ_STATISTICS*) pdwData );
            break;
        case ATQ_BW_DESCRIPTION:
            *pdwData = (DWORD_PTR) pBandwidthInfo->QueryDescription();
            break;
        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ATQ_ASSERT( FALSE );
            fRet = FALSE;
            break;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\wmi\source\util.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: util.cpp
//
//  Description:    
//      const definition
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//
//  These macros allow us to widen DNS RPC string constants.
//

#define MYTXT2(str)     L##str
#define MYTXT(str)      MYTXT2(str)


const WCHAR* const PVD_CLASS_SERVER = L"MicrosoftDNS_Server";

const WCHAR* const PVD_CLASS_DOMAIN = L"MicrosoftDNS_Domain";
const WCHAR* const PVD_CLASS_ZONE = L"MicrosoftDNS_Zone";
const WCHAR* const PVD_CLASS_CACHE = L"MicrosoftDNS_Cache";
const WCHAR* const PVD_CLASS_ROOTHINTS = L"MicrosoftDNS_RootHints";
const WCHAR* const PVD_CLASS_RESOURCERECORD = L"MicrosoftDNS_ResourceRecord";
const WCHAR* const PVD_CLASS_RR_A = L"MicrosoftDNS_AType";
const WCHAR* const PVD_CLASS_RR_SOA = L"MicrosoftDNS_SOAType";
const WCHAR* const PVD_CLASS_RR_PTR = L"MicrosoftDNS_PTRType";
const WCHAR* const PVD_CLASS_RR_NS = L"MicrosoftDNS_NSType";
const WCHAR* const PVD_CLASS_RR_CNAME = L"MicrosoftDNS_CNAMEType";
const WCHAR* const PVD_CLASS_RR_MB = L"MicrosoftDNS_MBType";
const WCHAR* const PVD_CLASS_RR_MD = L"MicrosoftDNS_MDType";
const WCHAR* const PVD_CLASS_RR_MF = L"MicrosoftDNS_MFType";
const WCHAR* const PVD_CLASS_RR_MG = L"MicrosoftDNS_MGType";
const WCHAR* const PVD_CLASS_RR_MR = L"MicrosoftDNS_MRType";
const WCHAR* const PVD_CLASS_RR_MINFO = L"MicrosoftDNS_MINFOType";
const WCHAR* const PVD_CLASS_RR_RP = L"MicrosoftDNS_RPType";
const WCHAR* const PVD_CLASS_RR_MX = L"MicrosoftDNS_MXType";
const WCHAR* const PVD_CLASS_RR_AFSDB = L"MicrosoftDNS_AFSDBType";
const WCHAR* const PVD_CLASS_RR_RT = L"MicrosoftDNS_RTType";
const WCHAR* const PVD_CLASS_RR_HINFO = L"MicrosoftDNS_HINFOType";
const WCHAR* const PVD_CLASS_RR_ISDN = L"MicrosoftDNS_ISDNType";
const WCHAR* const PVD_CLASS_RR_TXT = L"MicrosoftDNS_TXTType";
const WCHAR* const PVD_CLASS_RR_X25 = L"MicrosoftDNS_X25Type";
const WCHAR* const PVD_CLASS_RR_NULL = L"MicrosoftDNS_NULLType";
const WCHAR* const PVD_CLASS_RR_WKS = L"MicrosoftDNS_WKSType";
const WCHAR* const PVD_CLASS_RR_AAAA = L"MicrosoftDNS_AAAAType";
const WCHAR* const PVD_CLASS_RR_SRV = L"MicrosoftDNS_SRVType";
const WCHAR* const PVD_CLASS_RR_ATMA = L"MicrosoftDNS_ATMAType";
const WCHAR* const PVD_CLASS_RR_WINS = L"MicrosoftDNS_WINSType";
const WCHAR* const PVD_CLASS_RR_WINSR = L"MicrosoftDNS_WINSRType";
const WCHAR* const PVD_CLASS_RR_KEY = L"MicrosoftDNS_KEYType";
const WCHAR* const PVD_CLASS_RR_SIG = L"MicrosoftDNS_SIGType";
const WCHAR* const PVD_CLASS_RR_NXT = L"MicrosoftDNS_NXTType";

const WCHAR* const PVD_CLASS_SERVERDOMAIN = L"MicrosoftDNS_ServerDomainContainment";
const WCHAR* const PVD_CLASS_DOMAINDOMAIN = L"MicrosoftDNS_DomainDomainContainment";
const WCHAR* const PVD_CLASS_DOMAINRESOURCERECORD = L"MicrosoftDNS_DomainResourceRecordContainment";

const WCHAR* const PVD_CLASS_STATISTIC= L"MicrosoftDNS_Statistic";

//  server

const WCHAR* const PVD_SRV_ADDRESS_ANSWER_LIMIT = L"AddressAnswerLimit";
const WCHAR* const PVD_SRV_BOOT_METHOD = L"BootMethod";
const WCHAR* const PVD_SRV_DS_POLLING_INTERVAL = L"DsPollingInterval";
const WCHAR* const PVD_SRV_EVENT_LOG_LEVEL = L"EventLogLevel";
const WCHAR* const PVD_SRV_ALLOW_UPDATE = L"AllowUpdate";
const WCHAR* const PVD_SRV_AUTO_CACHE_UPDATE = L"AutoCacheUpdate";
const WCHAR* const PVD_SRV_AUTO_REVERSE_ZONES = L"DisableAutoReverseZones";
const WCHAR* const PVD_SRV_BIND_SECONDARIES = L"SlowZoneTransfer";
const WCHAR* const PVD_SRV_DISJOINT_NETS = L"DisjointNets";
const WCHAR* const PVD_SRV_DS_AVAILABLE = L"DsAvailable";
const WCHAR* const PVD_SRV_FORWARD_DELEGATION = L"ForwardDelegations";
const WCHAR* const PVD_SRV_LOCAL_NETPRIORITY = L"LocalNetPriority";
const WCHAR* const PVD_SRV_LOOSE_WILDCARDING = L"LooseWildcarding";
const WCHAR* const PVD_SRV_NO_RECURSION = L"NoRecursion";
const WCHAR* const PVD_SRV_ROUND_ROBIN = L"RoundRobin";
const WCHAR* const PVD_SRV_SECURE_RESPONSES = L"SecureResponses";
const WCHAR* const PVD_SRV_SLAVE = L"Slave";
const WCHAR* const PVD_SRV_STRICT_FILE_PARSING = L"StrictFileParsing";
const WCHAR* const PVD_SRV_AUTO_CONFIG_FILE_ZONES = L"AutoConfigFileZones";
const WCHAR* const PVD_SRV_DEFAULT_AGING_STATE = L"DefaultAgingState";
const WCHAR* const PVD_SRV_DEFAULT_REFRESH_INTERVAL = L"DefaultRefreshInterval";
const WCHAR* const PVD_SRV_DEFAULT_NOREFRESH_INTERVAL = L"DefaultNoRefreshInterval";
const WCHAR* const PVD_SRV_ENABLE_EDNS = L"EnableEDnsProbes";
const WCHAR* const PVD_SRV_EDNS_CACHE_TIMEOUT = L"EDnsCacheTimeout";
const WCHAR* const PVD_SRV_MAX_UDP_PACKET_SIZE = L"MaximumUdpPacketSize";
const WCHAR* const PVD_SRV_ENABLE_DNSSEC = L"EnableDnsSec";
const WCHAR* const PVD_SRV_ENABLE_DP = MYTXT( DNS_REGKEY_ENABLE_DP );
const WCHAR* const PVD_SRV_UPDATE_OPTIONS = MYTXT( DNS_REGKEY_UPDATE_OPTIONS );

// dww - 6/24/99
// WriteAuthoritySoa removed from the schema.
// const WCHAR* const PVD_SRV_WRITE_AUTHIORITY_SOA = L"WriteAuthoritySoa";
const WCHAR* const PVD_SRV_WRITE_AUTHORITY_NS = L"WriteAuthorityNS";
const WCHAR* const PVD_SRV_LISTEN_IP_ADDRESSES_ARRAY = L"ListenIPAddresses";
const WCHAR* const PVD_SRV_LOG_LEVEL = L"LogLevel";
const WCHAR* const PVD_SRV_MAX_CACHE_TTL = L"MaxCacheTTL";
const WCHAR* const PVD_SRV_NAME_CHECK_FLAG = L"NameCheckFlag";
const WCHAR* const PVD_SRV_RECURSION_RETRY = L"RecursionRetry";
const WCHAR* const PVD_SRV_RECURSION_TIMEOUT = L"RecursionTimeout";
const WCHAR* const PVD_SRV_RPC_PROTOCOL = L"RpcProtocol";
const WCHAR* const PVD_SRV_SEND_ON_NON_DNS_PORT = L"SendOnNonDnsPort";
const WCHAR* const PVD_SRV_SERVER_IP_ADDRESSES_ARRAY = L"ServerAddresses";
const WCHAR* const PVD_SRV_SERVER_NAME = L"Name";
const WCHAR* const PVD_SRV_VERSION = L"Version";
const WCHAR* const PVD_SRV_STARTED = L"Started";
const WCHAR* const PVD_SRV_STARTMODE = L"StartMode";

// resource record

const WCHAR* const PVD_REC_CONTAINER_NAME = L"ContainerName";
const WCHAR* const PVD_REC_SERVER_NAME = L"DnsServerName";
const WCHAR* const PVD_REC_DOMAIN_NAME = L"DomainName";
const WCHAR* const PVD_REC_OWNER_NAME = L"OwnerName";
const WCHAR* const PVD_REC_CLASS = L"RecordClass";
const WCHAR* const PVD_REC_RDATA = L"RecordData";
const WCHAR* const PVD_REC_TXT_REP = L"TextRepresentation";
const WCHAR* const PVD_REC_TTL = L"TTL";
const WCHAR* const PVD_REC_TYPE = L"RecordType";

const WCHAR* const PVD_REC_AAAA_IP = L"IPv6Address";
const WCHAR* const PVD_REC_AFSBD_SERVER_NAME = L"ServerName";
const WCHAR* const PVD_REC_AFSBD_SUB_TYPE = L"SubType";
const WCHAR* const PVD_REC_ATMA_FORMAT = L"Format";
const WCHAR* const PVD_REC_ATMA_ATM_ADDRESS = L"ATMAddress";
const WCHAR* const PVD_REC_A_IP = L"IPAddress";
const WCHAR* const PVD_REC_CNAME_PRIMARY_NAME = L"PrimaryName";
const WCHAR* const PVD_REC_HINFO_CPU = L"CPU";
const WCHAR* const PVD_REC_HINFO_OS = L"OS";
const WCHAR* const PVD_REC_ISDN_ISDN_NUM = L"ISDNNumber";
const WCHAR* const PVD_REC_ISDN_SUB_ADDRESS = L"SubAddress";
const WCHAR* const PVD_REC_MB_MBHOST = L"MBHost";
const WCHAR* const PVD_REC_MD_MDHOST = L"MDHost";
const WCHAR* const PVD_REC_MF_MFHOST = L"MFHost";
const WCHAR* const PVD_REC_MG_MGMAILBOX = L"MGMailBox";
const WCHAR* const PVD_REC_MINFO_ERROR_MAILBOX = L"ErrorMailBox";
const WCHAR* const PVD_REC_MINFO_RESP_MAILBOX = L"ResponsibleMailBox";
const WCHAR* const PVD_REC_MR_MRMAILBOX = L"MRMailBox";
const WCHAR* const PVD_REC_MX_MAIL_EXCHANGE = L"MailExchange";
const WCHAR* const PVD_REC_MX_PREFERENCE = L"Preference";
const WCHAR* const PVD_REC_NS_NSHOST = L"NSHost";
const WCHAR* const PVD_REC_NULL_NULLDATA = L"NULLDATA";
const WCHAR* const PVD_REC_PTR_PTRDOMAIN_NAME = L"PTRDomainName";
const WCHAR* const PVD_REC_RP_RPMAILBOX = L"RPMailBox";
const WCHAR* const PVD_REC_RP_TXT_DOMAIN_NAME = L"TxtDomainName";
const WCHAR* const PVD_REC_RT_HOST = L"IntermediateHost";
const WCHAR* const PVD_REC_RT_PREFERENCE = L"Preference";
const WCHAR* const PVD_REC_SOA_EXPIRE_LIMIT = L"ExpireLimit";
const WCHAR* const PVD_REC_SOA_TTL = L"MinimumTTL";
const WCHAR* const PVD_REC_SOA_PRIMARY_SERVER = L"PrimaryServer";
const WCHAR* const PVD_REC_SOA_REFRESH = L"RefreshInterval";
const WCHAR* const PVD_REC_SOA_RESPONSIBLE = L"ResponsibleParty";
const WCHAR* const PVD_REC_SOA_RETRY_DELAY = L"RetryDelay";
const WCHAR* const PVD_REC_SOA_SERIAL_NUMBER = L"SerialNumber";
const WCHAR* const PVD_REC_SRV_PORT = L"Port";
const WCHAR* const PVD_REC_SRV_PRIORITY = L"Priority";
const WCHAR* const PVD_REC_SRV_WEIGHT = L"Weight";
const WCHAR* const PVD_REC_SRV_DOMAINNAME = L"DomainName";
const WCHAR* const PVD_REC_TXT_TEXT = L"DescriptiveText";
const WCHAR* const PVD_REC_WINSR_TIMEOUT = L"LookupTimeOut";
const WCHAR* const PVD_REC_WINSR_MAPPING_FLAG = L"MappingFlag";
const WCHAR* const PVD_REC_WINSR_RESULT_DOMAIN = L"ResultDomain";
const WCHAR* const PVD_REC_WINSR_CACHE_TIMEOUT = L"CacheTimeOut";

const WCHAR* const PVD_REC_WINS_TIMEOUT = L"LookupTimeOut";
const WCHAR* const PVD_REC_WINS_MAPPING_FLAG = L"MappingFlag";
const WCHAR* const PVD_REC_WINS_WINS_SERVER = L"WinsServers";
const WCHAR* const PVD_REC_WINS_CACHE_TIMEOUT = L"CacheTimeOut";
const WCHAR* const PVD_REC_WKS_INTERNET_ADDRESS = L"InternetAddress";
const WCHAR* const PVD_REC_WKS_IP_PROTOCOL = L"IPProtocol";
const WCHAR* const PVD_REC_WKS_BIT_MASK = L"Services";
const WCHAR* const PVD_REC_X25_PSDNADDRESS = L"PSDNAddress";

// domain 


const WCHAR* const PVD_DOMAIN_CONTAINER_NAME = L"ContainerName";
const WCHAR* const PVD_DOMAIN_FQDN = L"Name";
const WCHAR* const PVD_DOMAIN_SERVER_NAME = L"DnsServerName";

//zone


const WCHAR* const PVD_ZONE_ALLOW_UPDATE = L"AllowUpdate";
const WCHAR* const PVD_ZONE_AUTO_CREATED = L"AutoCreated";
const WCHAR* const PVD_ZONE_DISABLE_WIN_SRECORD_REPLICATION = L"DisableWINSRecordReplication";
//const WCHAR* const PVD_DS_INTEGRATED L"DsIntegrated"  
const WCHAR* const PVD_ZONE_NOTIFY = L"Notify";
const WCHAR* const PVD_ZONE_PAUSED = L"Paused";
const WCHAR* const PVD_ZONE_REVERSE = L"Reverse";
const WCHAR* const PVD_ZONE_AGING = L"Aging";
const WCHAR* const PVD_ZONE_SECURE_SECONDARIES = L"SecureSecondaries";
const WCHAR* const PVD_ZONE_SHUTDOWN = L"Shutdown";
const WCHAR* const PVD_ZONE_USE_WINS = L"UseWins";
const WCHAR* const PVD_ZONE_MASTERS_IP_ADDRESSES_ARRAY = L"MasterServers";
const WCHAR* const PVD_ZONE_LOCAL_MASTERS_IP_ADDRESSES_ARRAY = L"LocalMasterServers";
const WCHAR* const PVD_ZONE_DATA_FILE = L"DataFile";
const WCHAR* const PVD_ZONE_SECONDARIES_IP_ADDRESSES_ARRAY = L"SecondaryServers";
const WCHAR* const PVD_ZONE_NOTIFY_IPADDRESSES_ARRAY = L"NotifyServers";
const WCHAR* const PVD_ZONE_ZONE_TYPE = L"ZoneType";
const WCHAR* const PVD_ZONE_DS_INTEGRATED = L"DsIntegrated";
const WCHAR* const PVD_ZONE_AVAIL_FOR_SCAVENGE_TIME = L"AvailForScavengeTime";
const WCHAR* const PVD_ZONE_REFRESH_INTERVAL = L"RefreshInterval";
const WCHAR* const PVD_ZONE_NOREFRESH_INTERVAL = L"NoRefreshInterval";
const WCHAR* const PVD_ZONE_SCAVENGE_SERVERS = L"ScavengeServers";
const WCHAR* const PVD_ZONE_FORWARDER_SLAVE = L"ForwarderSlave";
const WCHAR* const PVD_ZONE_FORWARDER_TIMEOUT = L"ForwarderTimeout";
const WCHAR* const PVD_ZONE_LAST_SOA_CHECK = L"LastSuccessfulSoaCheck";
const WCHAR* const PVD_ZONE_LAST_GOOD_XFR = L"LastSuccessfulXfr";

//domaindomain
//domain resource record containment
// server domain  containment

const WCHAR* const PVD_ASSOC_CHILD = L"PartComponent";
const WCHAR* const PVD_ASSOC_PARENT = L"GroupComponent";
// method
const WCHAR* const PVD_MTH_SRV_RESTART = L"RestartDNSServer";
const WCHAR* const PVD_MTH_SRV_START_SERVICE = L"StartService";
const WCHAR* const PVD_MTH_SRV_STOP_SERVICE = L"StopService";
const WCHAR* const PVD_MTH_ZONE_RESUMEZONE = L"ResumeZone";
const WCHAR* const PVD_MTH_ZONE_PAUSEZONE = L"PauseZone";
const WCHAR* const PVD_MTH_ZONE_RELOADZONE = L"ReloadZone";
const WCHAR* const PVD_MTH_ZONE_FORCEREFRESH = L"ForceRefresh";
const WCHAR* const PVD_MTH_ZONE_UPDATEFROMDS = L"UpdateFromDS";
const WCHAR* const PVD_MTH_ZONE_WRITEBACKZONE = L"WriteBackZone";
const WCHAR* const PVD_MTH_ZONE_AGEALLRECORDS = L"AgeAllRecords";
const WCHAR* const PVD_MTH_ZONE_CHANGEZONETYPE = L"ChangeZoneType";
const WCHAR* const PVD_MTH_ZONE_CREATEZONE = L"CreateZone";
const WCHAR* const PVD_MTH_ZONE_RESETNOTIFYIPARRAY = L"ResetNotifyIpArray";
const WCHAR* const PVD_MTH_ZONE_RESETSECONDARYIPARRAY = L"ResetSecondaries";
const WCHAR* const PVD_MTH_ZONE_GETDISTINGUISHEDNAME = L"GetDistinguishedName";
const WCHAR* const PVD_MTH_ZONE_ARG_ZONENAME = L"ZoneName";
const WCHAR* const PVD_MTH_ZONE_ARG_ZONETYPE = L"ZoneType";
const WCHAR* const PVD_MTH_ZONE_ARG_DATAFILENAME = L"DataFileName";
const WCHAR* const PVD_MTH_ZONE_ARG_IPADDRARRAY = L"IpAddr";
const WCHAR* const PVD_MTH_ZONE_ARG_ADMINEMAILNAME = L"AdminEmailName";
const WCHAR* const PVD_MTH_ZONE_ARG_NODENAME = L"NodeName";
const WCHAR* const PVD_MTH_ZONE_ARG_APPLYTOSUBTREE = L"ApplyToSubtree";
const WCHAR* const PVD_MTH_ZONE_ARG_DSINTEGRATED = L"DsIntegrated";
const WCHAR* const PVD_MTH_ZONE_ARG_SECURITY = L"SecureSecondaries";
const WCHAR* const PVD_MTH_ZONE_ARG_NOTIFY = L"Notify";
const WCHAR* const PVD_MTH_ZONE_ARG_SECONDARYIPARRAY = L"SecondaryServers";
const WCHAR* const PVD_MTH_ZONE_ARG_NOTIFYIPARRAY = L"NotifyServers";


//
//  Methods and stuff
//

const WCHAR* const PVD_MTH_REC_CREATEINSTANCEFROMTEXTREPRESENTATION = L"CreateInstanceFromTextRepresentation";
const WCHAR* const PVD_MTH_REC_MODIFY = L"Modify";
const WCHAR* const PVD_MTH_REC_CREATEINSTANCEFROMPROPERTYDATA = L"CreateInstanceFromPropertyData";
const WCHAR* const PVD_MTH_REC_GETOBJECTBYTEXT = L"GetObjectByTextRepresentation";
const WCHAR* const PVD_MTH_REC_ARG_DNSSERVER_NAME = L"DnsServerName";
const WCHAR* const PVD_MTH_REC_ARG_CONTAINER_NAME = L"ContainerName";
const WCHAR* const PVD_MTH_REC_ARG_TEXTREP = L"TextRepresentation";
const WCHAR* const PVD_MTH_REC_ARG_RR = L"RR";
const WCHAR* const PVD_MTH_RH_WRITEBACKROOTHINTDATAFILE = L"WriteBackRootHintDatafile";
const WCHAR* const PVD_MTH_CACHE_CLEARDNSSERVERCACHE = L"ClearCache";
//general
const WCHAR* const PVD_DNS_CACHE = L"..Cache";
const WCHAR* const PVD_DNS_ROOTHINTS = L"..RootHints";
const WCHAR* const PVD_DNS_LOCAL_SERVER = L".";
const WCHAR* const PVD_DNS_RETURN_VALUE = L"ReturnValue";
class CClassData
{
public:
    const WCHAR* wszClassName;
    FPNEW pfConstruct;
    const char* szType;
};

CClassData g_ClassDataArray[]=
{
    {PVD_CLASS_SERVER,  CDnsServer::CreateThis, ""},
    {PVD_CLASS_DOMAIN,  CDnsDomain::CreateThis, ""},
    {PVD_CLASS_ZONE,    CDnsZone::CreateThis, ""},
    {PVD_CLASS_CACHE,   CDnsCache::CreateThis, ""},
    {PVD_CLASS_ROOTHINTS,   CDnsRootHints::CreateThis, ""},
    {PVD_CLASS_RESOURCERECORD, CDnsResourceRecord::CreateThis, ""},
    {PVD_CLASS_RR_A,    CDnsResourceRecord::CreateThis, "A"},
    {PVD_CLASS_RR_SOA,  CDnsResourceRecord::CreateThis, "SOA"},
    {PVD_CLASS_RR_NS,   CDnsResourceRecord::CreateThis, "NS"},
    {PVD_CLASS_RR_CNAME,CDnsResourceRecord::CreateThis, "CNAME"},
    {PVD_CLASS_RR_PTR,  CDnsResourceRecord::CreateThis, "PTR"},
	{PVD_CLASS_RR_MB, CDnsResourceRecord::CreateThis, "MB"},
	{PVD_CLASS_RR_MD, CDnsResourceRecord::CreateThis, "MD"},
	{PVD_CLASS_RR_MF, CDnsResourceRecord::CreateThis, "MF"},
	{PVD_CLASS_RR_MG, CDnsResourceRecord::CreateThis, "MG"},
	{PVD_CLASS_RR_MR, CDnsResourceRecord::CreateThis, "MR"},
	{PVD_CLASS_RR_MINFO, CDnsResourceRecord::CreateThis, "MINFO"},
	{PVD_CLASS_RR_RP, CDnsResourceRecord::CreateThis, "RP"},
	{PVD_CLASS_RR_MX, CDnsResourceRecord::CreateThis, "MX"},
	{PVD_CLASS_RR_AFSDB, CDnsResourceRecord::CreateThis, "AFSDB"},
	{PVD_CLASS_RR_RT, CDnsResourceRecord::CreateThis, "RT"},
	{PVD_CLASS_RR_HINFO, CDnsResourceRecord::CreateThis, "HINFO"},
	{PVD_CLASS_RR_ISDN, CDnsResourceRecord::CreateThis, "ISDN"},
	{PVD_CLASS_RR_TXT, CDnsResourceRecord::CreateThis, "TXT"},
	{PVD_CLASS_RR_X25, CDnsResourceRecord::CreateThis, "X25"},
	{PVD_CLASS_RR_NULL, CDnsResourceRecord::CreateThis, "NULL"},
	{PVD_CLASS_RR_WKS, CDnsResourceRecord::CreateThis, "WKS"},
	{PVD_CLASS_RR_AAAA, CDnsResourceRecord::CreateThis, "AAAA"},
	{PVD_CLASS_RR_SRV, CDnsResourceRecord::CreateThis, "SRV"},
	{PVD_CLASS_RR_ATMA, CDnsResourceRecord::CreateThis, "ATMA"},
	{PVD_CLASS_RR_WINS, CDnsResourceRecord::CreateThis, "WINS"},
	{PVD_CLASS_RR_WINSR, CDnsResourceRecord::CreateThis, "WINSR"},
    {PVD_CLASS_RR_SIG,    CDnsResourceRecord::CreateThis, "SIG"},
    {PVD_CLASS_RR_KEY,    CDnsResourceRecord::CreateThis, "KEY"},
    {PVD_CLASS_RR_NXT,    CDnsResourceRecord::CreateThis, "NXT"},
    {PVD_CLASS_SERVERDOMAIN, CDnsServerDomainContainment::CreateThis, ""},
    {PVD_CLASS_DOMAINDOMAIN, CDnsDomainDomainContainment::CreateThis,""},
    {PVD_CLASS_STATISTIC, CDnsStatistic::CreateThis,""},
    {PVD_CLASS_DOMAINRESOURCERECORD,
        CDnsDomainResourceRecordContainment::CreateThis,""}

};

int g_cClassDataEntries = sizeof(g_ClassDataArray) / sizeof(CClassData);


SCODE CreateClass(
	const WCHAR* strClassName, 
	CWbemServices* pNamespace, 
	void** ppNewClass)
{
    for(int i =0; i< g_cClassDataEntries; i++)
    {
        if(_wcsicmp(
            strClassName,
            g_ClassDataArray[i].wszClassName) == 0)
        {
            *ppNewClass = (void*) g_ClassDataArray[i].pfConstruct(
                strClassName, 
                pNamespace, 
                g_ClassDataArray[i].szType);
            return WBEM_S_NO_ERROR;
        }
    }

	throw WBEM_E_INVALID_PARAMETER;

	return S_OK;
}

BSTR AllocBstr(const WCHAR* pwsz)
{
    BSTR bstr = SysAllocString(pwsz);
    if (bstr == NULL)
        throw WBEM_E_OUT_OF_MEMORY;
    return bstr;
}

wstring 
CharToWstring(
    LPCSTR lpFromStr, 
    DWORD wLength)
{
	wstring wStr;
	if (wLength == 0)
		return wStr; //L"";

	WCHAR * pwchar = new WCHAR[ sizeof( WCHAR ) * ( wLength + 1 ) ];
    if ( !pwchar )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

	int rt = MultiByteToWideChar(	
                    CP_ACP,
		            0,
		            lpFromStr,
		            wLength,
		            pwchar,
		            wLength);
	if(rt != 0)
	{
		*(pwchar+wLength)=L'\0';
		wStr = pwchar;
	}

	delete [] pwchar;
	return wStr;
}
int 
CharToWchar(
    LPCSTR lpMultiByteStr, 
    LPWSTR* lppWideCharStr)
{
	int cchMultiByte;
	cchMultiByte = strlen(lpMultiByteStr);
	*lppWideCharStr = (WCHAR*) malloc ((cchMultiByte+1)*sizeof(WCHAR));
    if ( *lppWideCharStr == NULL )
    {
        return 0;
    }
	return  MultiByteToWideChar(  
        CP_ACP,			        //  code page
        0 ,			
        lpMultiByteStr,		    //  address of string to map
        -1,					    //  number of bytes in string
        *lppWideCharStr,		//  address of wide-character buffer
        cchMultiByte + 1        //  size of buffer
        );
}


int 
WcharToString(
    LPCWSTR lpWideCharStr, 
    string& str)
{
	char * temp = NULL;
	int rt = WcharToChar(lpWideCharStr, &temp);
	if ( rt != 0)
	{
		str = temp;
	}
	delete [] temp;
	return rt;
}

int 
WcharToChar(
    LPCWSTR lpWideCharStr, 
    LPSTR* lppMultiByteStr)
{
	int cWchar;
	if ( !lpWideCharStr )
		return 0;

	cWchar= wcslen(lpWideCharStr)+1;
	*lppMultiByteStr = ( CHAR * ) new char[ cWchar * sizeof ( CHAR ) ];
    if ( !*lppMultiByteStr )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

	return  WideCharToMultiByte(  
        CP_ACP,			// code page
        0,					// character-type options
        lpWideCharStr,		// address of string to map
        -1,					// number of bytes in string
        *lppMultiByteStr,	// address of wide-character buffer
        cWchar*sizeof(CHAR) ,// size of buffer
        NULL,
        NULL
        );
}

wstring 
IpAddressToString(DWORD ip)
{
	char temp[30];
	sprintf(temp, "%d.%d.%d.%d",
			* ( (PUCHAR) &ip + 0 ),
            * ( (PUCHAR) &ip + 1 ),
            * ( (PUCHAR) &ip + 2 ),
            * ( (PUCHAR) &ip + 3 ) );
     
	 return CharToWstring(temp, strlen(temp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for Internet Common Services.

   Author:

       Murali R. Krishnan    ( MuraliK )    02-Apr-1996

   Environment:

       Windows NT - User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

# ifndef _IIS_AUX_COUNTERS_HXX_
# define _IIS_AUX_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

/*++
  Counters belong to two categories
  1. Active Counter - one that counts up and down
      It is expected that this counter consists of the current
      active items and hence this should not be wildly high, unless
      there are large # of counted objects.

  2. Cumulative Counters - counts values up and up
      This count value is used to measure the # of times event(s)
      related to this counter occurred.

  Naming Conventions:
   prefixes used are: Aac & Cac
   Aac - Active Auxiliary Counter
   Cac - Cumulative Auxiliary Counter
   Ac  - Auxiliar Counter

--*/

typedef enum  {   // Ac - stands for Aux Counters.

    AacAtqContextsAlloced = 0,

    CacAtqContextsReused,
    CacAtqContextsCleanedup,
    CacAtqPrepareContexts,
    CacAtqPendingAcceptExScans,

    CacAtqContextsTimedOut,
    CacAtqWaitsForTimeout,
    CacAtqProcWhenTimeout,           // in processing when timeout occurred.

    AacIISMaxCounters                // sentinel counter
} ENUM_IIS_AUX_COUNTER;



#ifdef IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS    (AacIISMaxCounters)

//
// Macros for operating on these counters
//

# define AcIncrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
   g_AuxCounters[acCounter]++ : \
  0)

# define AcDecrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  g_AuxCounters[acCounter]-- : \
  0)

# define AcCounter( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ? g_AuxCounters[acCounter] : 0)


extern LONG g_AuxCounters[];


# else // IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS              (0)

# define AcIncrement( acCounter)       (0)    /* do nothing */
# define AcDecrement( acCounter)       (0)    /* do nothing */
# define AcCounter  ( acCounter)       (0)    /* do nothing */

#endif // IIS_AUX_COUNTERS


# endif // _IIS_AUX_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\atqdgram.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      atqmain.cxx

   Abstract:
      This module implements entry points for ATQ - Asynchronous Thread Queue.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Apr-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

--*/

#include "isatq.hxx"

typedef GUID UUID;

extern "C" {

#include <ntdsa.h>

};

VOID
AtqGetDatagramAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrRemote,
    OUT INT *        pcbsockaddrRemote
    )
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( g_fUseAcceptEx);
    ATQ_ASSERT( pContext->pEndpoint);

    *pSock   = (SOCKET) pContext->hAsyncIO;
    *pEndpointContext = pContext->pEndpoint->Context;
    *ppvBuff = pContext->pvBuff;

    //
    //  The buffer not only receives the initial received data, it also
    //  gets the sock addrs, which must be at least sockaddr_in + 16 bytes
    //  large
    //

    *ppsockaddrRemote = (PSOCKADDR) pContext->AddressInformation;
    *pcbsockaddrRemote = pContext->AddressLength;

    return;
} // AtqGetDatagramAddrs()


DWORD_PTR
AtqContextGetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    DWORD_PTR dwOldVal = 0;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE )
    {
        switch ( atqInfo ) {

        case ATQ_INFO_TIMEOUT:
            dwOldVal = pContext->TimeOut;
            break;

        case ATQ_INFO_RESUME_IO:

            //
            // set back the max timeout from pContext->TimeOut
            // This will ensure that timeout processing can go on
            //   peacefully.
            //

            {
                dwOldVal = pContext->NextTimeout;
            }
            break;

        case ATQ_INFO_COMPLETION:

            dwOldVal = (DWORD_PTR) pContext->pfnCompletion;
            break;

        case ATQ_INFO_COMPLETION_CONTEXT:

            dwOldVal = (DWORD_PTR) pContext->ClientContext;
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return dwOldVal;

} // AtqContextGetInfo()



BOOL
AtqWriteDatagramSocket(
    IN PATQ_CONTEXT  patqContext,
    IN LPWSABUF     pwsaBuffers,
    IN DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    I_SetNextTimeout(pContext);

    // count the number of bytes
    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf <= (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    //
    // See if the connection has already been closed.
    //
    if (pContext->hAsyncIO == NULL) {
        InterlockedDecrement( &pContext->m_nIO );
        SetLastError(WSAENOTSOCK);
        return FALSE;
    }
    
    fRes = ( (WSASendTo( (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       &cbWritten,
                       0,               // no flags
                       (PSOCKADDR) pContext->AddressInformation,
                       pContext->AddressLength,
                       lpo,
                       NULL             // no completion routine
                       ) == 0) ||
             (WSAGetLastError() == WSA_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); }

    return fRes;

} // AtqWriteDatagramSocket()



VOID
ATQ_CONTEXT::InitDatagramState(
            VOID
            )
{

    fDatagramContext= IS_DATAGRAM_CONTEXT(this);

    if (fDatagramContext) {

        //
        // The address information is stored in the buffer after
        // the data. Store a pointer to it as well as its
        // length
        //

        AddressLength = 2*MIN_SOCKADDR_SIZE;
        AddressInformation = (PVOID) ((PUCHAR) pvBuff + 
                                      GET_ALIGNED_LENGTH64(pEndpoint->InitialRecvSize));

        WsaMsg.name            = (PSOCKADDR)AddressInformation;
        WsaMsg.namelen         = AddressLength;
        WsaMsg.dwBufferCount   = 1;
        WsaMsg.lpBuffers       = &WsaBuf;
        WsaMsg.dwFlags         = 0;
        memset(&WsaMsg.Control, 0, sizeof(WsaMsg.Control));
        
        WsaBuf.buf = (PCHAR)pvBuff;
        WsaBuf.len = pEndpoint->InitialRecvSize;
        
        NextTimeout = ATQ_INFINITE;
    }

    return;
} // ATQ_CONTEXT::InitDatagramState


#define I_SetNextTimeout2( _c, _t ) {                               \
    (_c)->NextTimeout = AtqGetCurrentTick() + (_t);                 \
    if ( (_c)->NextTimeout < (_c)->ContextList->LatestTimeout ) {   \
        (_c)->ContextList->LatestTimeout = (_c)->NextTimeout;       \
    }                                                               \
}


DWORD_PTR
AtqContextSetInfo2(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo,
    DWORD_PTR              Data
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT   pContext = (PATQ_CONT) patqContext;
    DWORD_PTR   dwOldVal = 0;
    DWORD       timeout;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE ) {
        switch ( atqInfo ) {

        case ATQ_INFO_NEXT_TIMEOUT:
            dwOldVal = pContext->NextTimeout;
            timeout = CanonTimeout( (DWORD)Data );
            I_SetNextTimeout2( pContext, timeout );
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return dwOldVal;

} // AtqContextSetInfo2



VOID
AtqUpdatePerfStats(
    IN ATQ_CONSUMER_TYPE        ConsumerType,
    IN DWORD                    dwOperation,
    IN DWORD                    dwVal
    )
/*++

Routine Description:

    Updates DS Perfmon counters.

Arguments:

    ConsumerType - Which statistic to update.
    dwOperation  - What to do to statistic
                   FLAG_COUNTER_INCREMENT - increment the value - INC()
                   FLAG_COUNTER_DECREMENT - decrement the value - DEC()
                   FLAG_COUNTER_SET - set the value directly - ISET()

Return Value:

    None

--*/
{
    //
    // Make sure that g_pfnUpdatePerfCountersCallback has been set.
    //
    if (g_pfnUpdatePerfCounterCallback == NULL) {
        return;
    }

    switch ( ConsumerType ) {

        case AtqConsumerLDAP:
            g_pfnUpdatePerfCounterCallback(DSSTAT_ATQTHREADSLDAP, dwOperation, dwVal);
            break;

        case AtqConsumerOther:
            g_pfnUpdatePerfCounterCallback(DSSTAT_ATQTHREADSOTHER, dwOperation, dwVal);
            break;

        case AtqConsumerAtq:
            g_pfnUpdatePerfCounterCallback(DSSTAT_ATQTHREADSTOTAL, dwOperation, dwVal);
            break;

        default:
            ATQ_ASSERT( FALSE );
    }
} // AtqUpdatePerfStats


DWORD_PTR
AtqEndpointSetInfo2(
    IN PVOID                Endpoint,
    IN ATQ_ENDPOINT_INFO    EndpointInfo,
    IN DWORD_PTR            dwInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    Endpoint    - endpoint to set info on
    EndpointInfo - type of info to set
    dwInfo       - info to set

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

        case EndpointInfoConsumerType:
            dwVal = pEndpoint->ConsumerType;
            pEndpoint->ConsumerType = (ATQ_CONSUMER_TYPE)dwInfo;
            break;

      default:
        ATQ_ASSERT( FALSE );
    }
    return dwVal;
} // AtqEndpointSetInfo2()


DWORD_PTR
AtqSetInfo2(
    IN ATQ_INFO         atqInfo,
    IN DWORD_PTR        Data
    )
/*++

Routine Description:

    Sets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    DWORD_PTR dwOldVal = 0;

    switch ( atqInfo ) {

      case AtqUpdatePerfCounterCallback:

        dwOldVal = (DWORD_PTR) g_pfnUpdatePerfCounterCallback;
        g_pfnUpdatePerfCounterCallback =  (ATQ_UPDATE_PERF_CALLBACK ) Data;
        //
        // Now that we can communicate perf stats, update them to
        // where they are now.
        //
        AtqUpdatePerfStats(AtqConsumerAtq, FLAG_COUNTER_SET, g_cThreads);
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    }

    return dwOldVal;
} // AtqSetInfo2()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\atqmain.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      atqmain.cxx

   Abstract:
      This module implements entry points for ATQ - Asynchronous Thread Queue.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Apr-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqInitialize();
       BOOL  AtqTerminate();

       DWORD AtqSetInfo();
       DWORD AtqGetInfo();
       BOOL  AtqGetStatistics();
       BOOL  AtqClearStatistics();

       BOOL  AtqAddAcceptExSockets();
       BOOL  AtqAddAsyncHandle();
       DWORD AtqContextSetInfo();
       VOID  AtqCloseSocket();
       VOID  AtqFreeContext();

       BOOL  AtqReadFile();
       BOOL  AtqWriteFile();
       BOOL  AtqTransmitFile();
       BOOL  AtqPostCompletionStatus();

       PVOID AtqAllocateBandwidthInfo();
       BOOL  AtqFreeBandwidthInfo();
       DWORD AtqBandwidthSetInfo();
--*/

#include "isatq.hxx"
#include <inetsvcs.h>
#include "sched.hxx"

# define ATQ_REG_DEF_THREAD_TIMEOUT_PWS    (30*60)  // 30 minutes

/************************************************************
 * Globals
 ************************************************************/

// ------------------------------
// Configuration for ATQ package
// ------------------------------

extern CHAR g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY[];

// ----------------------------------------
// # of CPUs in machine (for thread-tuning)
// ----------------------------------------

extern DWORD g_cCPU;

//
// Used for guarding the initialization code
//

extern CRITICAL_SECTION MiscLock;

//
// concurrent # of threads to run per processor
//

DWORD g_cConcurrency = ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY;

//
//  Amount of time (in ms) a worker thread will be idle before suicide
//

DWORD g_msThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT * 1000;

BOOL  g_fUseAcceptEx = TRUE;    // Use AcceptEx if available

//
// The absolute thread limit
//

LONG   g_cMaxThreadLimit = ATQ_REG_DEF_POOL_THREAD_LIMIT;

//
// Should we use fake completion port
//

BOOL g_fUseFakeCompletionPort =  FALSE;

//
// Assumed minimum file transfer rate
//

DWORD g_cbMinKbSec = ATQ_REG_DEF_MIN_KB_SEC;

//
// Size of buffers for fake xmits
//

DWORD g_cbXmitBufferSize = ATQ_REG_DEF_NONTF_BUFFER_SIZE;

//
// number of active context list
//

DWORD g_dwNumContextLists = ATQ_NUM_CONTEXT_LIST;

//
// Max winsock datagram send.
//

DWORD g_cbMaxDGramSend = 2048;
 
/*

 Winsock functions that need to be filled in
 
 */
LPFN_GETACCEPTEXSOCKADDRS g_pfnGetAcceptExSockaddrs = NULL;
LPFN_ACCEPTEX   g_pfnAcceptEx   = NULL;
LPFN_WSARECVMSG g_pfnWSARecvMsg = NULL;
BOOL            g_bUseRecvMsg   = FALSE;

/*
   g_pfnExitThreadCallback()
    This routine sets the callback routine to be called when one of the
    Atq threads exit so that thread state data can be cleaned up. Currently
    support is for a single routine. One way to support multiple routines would
    be for the caller to save the return value. Such an application would not
    be able to delete the "saved" callback routine.
 */
ATQ_THREAD_EXIT_CALLBACK g_pfnExitThreadCallback = NULL;

//
// g_pfnUpdatePerfCountersCallback()
//  This routine is used to update PerfMon counters that are located in the
//  DS core.
//
ATQ_UPDATE_PERF_CALLBACK g_pfnUpdatePerfCounterCallback = NULL;

// ----------------------------------
// Fake Completion port
// -----------------------------------
//
// Used to gauge pool thread creation. This variable shows number of
// ATQ contexts // ready to be processed by ATQ pool thread. Basically
// this is length of outcoming queue in SIO module and is modified by
// routines there
//

DWORD   g_AtqWaitingContextsCount = 0;

// ------------------------------
// Current State Information
// ------------------------------


HANDLE* g_rghCompPort = NULL;    // Handles for the completion port (hashed by ideal processor)
LONG    g_cThreads = 0;          // number of thread in the pool
LONG    g_cAvailableThreads = 0; // # of threads waiting on the port.

//
// Is the NTS driver in use
//

BOOL    g_fUseDriver = FALSE;

//
// Current thread limit
//

LONG    g_cMaxThreads = ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS;

DWORD   g_cListenBacklog = ATQ_REG_DEF_LISTEN_BACKLOG;

BOOL    g_fShutdown = FALSE;   // if set, indicates that we are shutting down
                               // in that case, all threads should exit.

HANDLE  g_hShutdownEvent = NULL; // set when all running threads shutdown

// ------------------------------
// Bandwidth Throttling Info
// ------------------------------

PBANDWIDTH_INFO     g_pBandwidthInfo = NULL;

// ------------------------------
// Various State/Object Lists
// ------------------------------

//
// Used to switch context between lists
//

DWORD AtqGlobalContextCount = 0;

//
// List of active context
//

ATQ_CONTEXT_LISTHEAD AtqActiveContextList[ATQ_NUM_CONTEXT_LIST];

//
// List of Endpoints in ATQ - one per listen socket
//

LIST_ENTRY AtqEndpointList;
CRITICAL_SECTION AtqEndpointLock;

PALLOC_CACHE_HANDLER  g_pachAtqContexts;

#ifdef IIS_AUX_COUNTERS

LONG g_AuxCounters[NUM_AUX_COUNTERS];

#endif // IIS_AUX_COUNTERS

// ------------------------------
// local to this module
// ------------------------------

LONG  sg_AtqInitializeCount = -1;
BOOL  g_fSpudInitialized = FALSE;

DWORD
I_AtqGetGlobalConfiguration(VOID);

DWORD
I_NumAtqEndpointsOpen(VOID);

VOID
WaitForWinsockCallback(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    );

BOOL
WaitForWinsockToInitialize(
    VOID
    );


/************************************************************
 * Functions
 ************************************************************/

BOOL
AtqInitialize(
    IN DWORD   dwFlags
    )
/*++
Routine Description:

    Initializes the ATQ package

Arguments:
    dwFlags - DWORD containing the flags for use to initialize ATQ library.
    Notably in many cases one may not need the SPUD driver initialized
      for processes other than the IIS main process. This dword helps
      to shut off the unwanted flags.

    This is an ugly way to initialize/shutdown SPUD, but that is what we
    will do. SPUD supports only ONE completion port and hence when we use
    ATQ in multiple processes we should be careful to initialize SPUD only
    once and hopefully in the IIS main process!

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

Note:
    As of 4/16/97 the pszRegKey that is sent is no more utilized.
    We always load the internal configuration parameters from
     one single registry entry specified by PSZ_ATQ_CONFIG_PARAMS_REG_KEY
    The parameter is left in the command line for compatibility
      with old callers :( - NYI: Need to change this.
--*/
{
    DWORD       i;
    DWORD       dwErr;

    //
    // We need to acquire a lock here to make this thread safe
    //

    AcquireLock(&MiscLock);

    if ( InterlockedIncrement( &sg_AtqInitializeCount) != 0) {

        IF_DEBUG( API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqInitialize( %08x). ATQ is already initialized.\n",
                         dwFlags));
        }

        //
        // we are already initialized. Ignore the new registry settings
        //

        ReleaseLock(&MiscLock);
        return ( TRUE);
    }

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize[%08x]. Initializing....\n",
                     dwFlags));
    }

    DBG_REQUIRE( ALLOC_CACHE_HANDLER::Initialize());
    IF_DEBUG( INIT_CLEAN ) {
        DBGPRINTF(( DBG_CONTEXT, "Alloc Cache initialized\n" ));
    }

    if ( !SchedulerInitialize()) {
        DBGPRINTF(( DBG_CONTEXT, "Initializing Scheduler Failed\n"));
        InterlockedDecrement( &sg_AtqInitializeCount);
        ReleaseLock(&MiscLock);
        return FALSE;
    }

    DBG_REQUIRE( ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval() );

    IF_DEBUG( INIT_CLEAN ) {
        DBGPRINTF(( DBG_CONTEXT, "Scheduler Initialized\n" ));
    }

    //
    // Initialize context lists and crit sects
    //

    ATQ_CONTEXT_LISTHEAD * pacl;

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        pacl->Initialize();
    }

    InitializeListHead( &AtqEndpointList );
    InitializeCriticalSection( &AtqEndpointLock );

    //
    // init bandwidth throttling
    //

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwInitialize() );

    //
    //  Read registry configurable Atq options.  We have to read these now
    //  because concurrency is set for the completion port at creation time.
    //

    DWORD dwError = I_AtqGetGlobalConfiguration();

    if ( NO_ERROR != dwError) {
        SetLastError( dwError);
        InterlockedDecrement( &sg_AtqInitializeCount);
        IIS_PRINTF((buff,"GetGlobal failed\n"));
        ReleaseLock(&MiscLock);
        return ( FALSE);
    }

    //
    // Setup an allocation cache for the ATQ Contexts
    // NYI: Auto-tune the threshold limit
    //

    {
        ALLOC_CACHE_CONFIGURATION acConfig;

        DWORD nCachedAtq = ATQ_CACHE_LIMIT_NTS;

        if ( TsIsWindows95()) { nCachedAtq = ATQ_CACHE_LIMIT_W95; }

        acConfig.nConcurrency = 1;
        acConfig.nThreshold = nCachedAtq;
        acConfig.cbSize = sizeof(ATQ_CONTEXT);

        g_pachAtqContexts = new ALLOC_CACHE_HANDLER( "ATQ", &acConfig);

        if ( NULL == g_pachAtqContexts) {
            IIS_PRINTF((buff,"alloc failed %d\n", GetLastError()));
            goto cleanup;
        }
    }


    //
    //  Create the shutdown event
    //

    g_hShutdownEvent = IIS_CREATE_EVENT(
                           "g_hShutdownEvent",
                           &g_hShutdownEvent,
                           TRUE,        // Manual reset
                           FALSE        // Not signalled
                           );
    if ( !g_hShutdownEvent ) {
        OutputDebugString( " Create shutdown event failed\n");
        goto cleanup;
    }

    //
    //  Create the completion port
    //

    g_rghCompPort = new HANDLE[ g_cCPU ];
    if ( !g_rghCompPort ) {
        IIS_PRINTF((buff,"alloc failed %d\n", GetLastError()));
        goto cleanup;
    }
    ZeroMemory( g_rghCompPort, g_cCPU * sizeof( HANDLE ) );

    g_rghCompPort[0] = CreateIoCompletionPort(INVALID_HANDLE_VALUE,
                                            NULL,
                                            (DWORD) NULL,
                                            g_cConcurrency
                                            );

    if ( !g_rghCompPort[0] ) {

        OutputDebugString( " Create IoComp port failed\n");
        goto cleanup;
    }
    for ( size_t iCPU = 1; iCPU < g_cCPU; iCPU++ ) {
        if ( !DuplicateHandle(
				GetCurrentProcess(),
				g_rghCompPort[ 0 ],
				GetCurrentProcess(),
				&g_rghCompPort[ iCPU ],
				NULL,
				FALSE,
				DUPLICATE_SAME_ACCESS ) ) {
            OutputDebugString( " Create IoComp port failed\n");
            goto cleanup;
        }
    }

    //
    // initialize spud driver
    //

    if ( dwFlags & ATQ_INIT_SPUD_FLAG ) {
        (VOID) I_AtqSpudInitialize(g_rghCompPort[ 0 ]);
        g_fSpudInitialized = TRUE;
    }

    //
    // Ensure all other initializations also are done
    //

    g_cThreads  = 0;
    g_fShutdown = FALSE;
    g_cAvailableThreads = 0;

    if ( !I_AtqStartTimeoutProcessing( NULL ) ) {
        IIS_PRINTF((buff,"Start processing failed\n"));
        goto cleanup;
    }

    IF_DEBUG(INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT,
                    "fUseAcceptEx[%d] NT CompPort[%d] Platform[%d]"
                    " fUseDriver[%d]\n",
                    g_fUseAcceptEx,  !g_fUseFakeCompletionPort,
                    IISPlatformType(),
                    g_fUseDriver
                    ));
    }

    //
    // Create the initial ATQ thread.
    //

    (VOID)I_AtqCheckThreadStatus( (PVOID)UIntToPtr(ATQ_INITIAL_THREAD) );

    //
    // Create a second thread if we are NTS
    //

    if ( TsIsNtServer() ) {
        (VOID)I_AtqCheckThreadStatus( (PVOID)UIntToPtr(ATQ_INITIAL_THREAD) );
    }

    dwErr = I_AtqStartThreadMonitor();
    ATQ_ASSERT( dwErr != FALSE );

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, TRUE));
    }

    WaitForWinsockToInitialize();

    ReleaseLock(&MiscLock);
    return TRUE;

cleanup:
    IIS_PRINTF((buff,"cleanup!!!\n"));
    for (i=0; i<g_dwNumContextLists; i++) {

        AtqActiveContextList[i].Cleanup();
    }

    DeleteCriticalSection( &AtqEndpointLock);

    if ( g_hShutdownEvent != NULL ) {
        CloseHandle( g_hShutdownEvent );
        g_hShutdownEvent = NULL;
    }

    if ( g_rghCompPort != NULL ) {
        for ( size_t iCPU = 0; iCPU < g_cCPU; iCPU++ ) {
            if ( g_rghCompPort[ iCPU ] ) {
                CloseHandle( g_rghCompPort[ iCPU ] );
            }
        }
        delete [] g_rghCompPort;
        g_rghCompPort = NULL;
    }

    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwTerminate());

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, FALSE));
    }

    InterlockedDecrement( &sg_AtqInitializeCount);
    ReleaseLock(&MiscLock);
    return(FALSE);

} // AtqInitialize()





BOOL
AtqTerminate(
    VOID
    )
/*++

Routine Description:

    Cleans up the ATQ package.  Should only be called after all of the
    clients of ATQ have been shutdown.

Arguments:

    None.

Return Value:

    TRUE, if ATQ was shutdown properly
    FALSE, otherwise

--*/
{
    DWORD       currentThreadCount;
    ATQ_CONTEXT_LISTHEAD * pacl;

    // there are outstanding users, don't fully terminate
    if ( InterlockedDecrement( &sg_AtqInitializeCount) >= 0) {

        IF_DEBUG( API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqTerminate() - there are other users."
                         " Not terminating now\n"
                         ));
        }
        return (TRUE);
    }

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Terminating ATQ ...\n"
                     ));
    }


    //
    // All the ATQ endpoints should have been terminated before calling
    //  this ATQTerminate() function. If not, sorry return failure.
    //
    DWORD nEndpointsToBeClosed = I_NumAtqEndpointsOpen();

    if ( nEndpointsToBeClosed > 0) {

        DBGPRINTF(( DBG_CONTEXT,
                    " There are %d endpoints remaining to be closed."
                    " Somebody above stream did not close endpoints."
                    " BUG IN CODE ABOVE ATQ\n"
                    ,
                    nEndpointsToBeClosed
                    ));
        SetLastError( ERROR_NETWORK_BUSY);
        return ( FALSE);
    }


    if ( (g_hShutdownEvent == NULL) || g_fShutdown ) {

        //
        // We have not been intialized or have already terminated.
        //
        SetLastError( ERROR_NOT_READY );
        return FALSE;
    }

    // Cleanup variables in ATQ Bandwidth throttle module
    if ( !BANDWIDTH_INFO::AbwTerminate()) {

        // there may be a few blocked IO. We should avoid them all.
        // All clients should have cleaned themselves up before coming here.
        return (FALSE);
    }

    //
    // All clients should have cleaned themselves up before calling us.
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {

        pacl->Lock();

        if ( !IsListEmpty(&pacl->ActiveListHead)) {

            ATQ_ASSERT( IsListEmpty( &pacl->ActiveListHead));
            pacl->Unlock();

            IF_DEBUG( API_EXIT) {
                ATQ_PRINTF(( DBG_CONTEXT,
                             "AtqTerminate() - ContextList(%08x) has "
                             "Active Contexts. Failed Termination.\n",
                             pacl
                             ));
            }

            return FALSE;
        }

        pacl->Unlock();
    } // for

    //
    // Note that we are shutting down and prevent any more handles from
    // being added to the completion port.
    //

    g_fShutdown = TRUE;

    //
    // Attempt and remove the TimeOut Context from scheduler queue
    //
    DBG_REQUIRE( I_AtqStopTimeoutProcessing());
    DBG_REQUIRE( I_AtqStopThreadMonitor() );

    currentThreadCount = g_cThreads;
    if (currentThreadCount > 0) {

        DWORD       i;
        BOOL        fRes;
        OVERLAPPED  overlapped;

        //
        // Post a message to the completion port for each worker thread
        // telling it to exit. The indicator is a NULL context in the
        // completion.
        //

        ZeroMemory( &overlapped, sizeof(OVERLAPPED) );

        for (i=0; i<currentThreadCount; i++) {

            fRes = PostQueuedCompletionStatus( g_rghCompPort[ 0 ],
                                               0,
                                               0,
                                               &overlapped );

            ATQ_ASSERT( (fRes == TRUE) ||
                       ( (fRes == FALSE) &&
                        (GetLastError() == ERROR_IO_PENDING) )
                       );
        }
    }

    //
    // Now wait for the pool threads to shutdown.
    //

    DWORD dwErr =
        WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
#if 0
    DWORD dwWaitCount = 0;
    while ( dwErr == WAIT_TIMEOUT) {

        dwWaitCount++;
        DebugBreak();
        Sleep( 10*1000);  // sleep for some time
        dwErr =
            WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
    } // while
# endif // 0

    //
    // At this point, no other threads should be left running.
    //
    //
    //  g_cThreads counter is decremented by AtqPoolThread().
    //  AtqTerminate() is called during the DLL termination
    //  But at DLL termination, all ATQ pool threads are killed =>
    //    no one is decrementing the count. Hence this assert will always fail.
    //

    // ATQ_ASSERT( !g_cThreads );

    ATQ_REQUIRE( CloseHandle( g_hShutdownEvent ) );
    g_hShutdownEvent = NULL;

    for ( size_t iCPU = 0; iCPU < g_cCPU; iCPU++ ) {
        CloseHandle( g_rghCompPort[ iCPU ] );
    }
    delete [] g_rghCompPort;
    g_rghCompPort = NULL;

    //
    // Cleanup our synchronization resources
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        PLIST_ENTRY pEntry;

        pacl->Lock();

        if ( !IsListEmpty( &pacl->PendingAcceptExListHead)) {
            for ( pEntry = pacl->PendingAcceptExListHead.Flink;
                  pEntry != &pacl->PendingAcceptExListHead;
                  pEntry  = pEntry->Flink ) {

                PATQ_CONT pContext =
                    CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                pContext->Print();
            } // for
        }

        pacl->Unlock();
        pacl->Cleanup();
    }


    //
    // Free all the elements in the Allocation caching list
    //
    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    DeleteCriticalSection( &AtqEndpointLock);

    //
    // cleanup driver
    //

    if ( g_fSpudInitialized ) {
        (VOID)I_AtqSpudTerminate();
        g_fSpudInitialized = FALSE;
    }

    //
    // Cleanup scheduler
    //

    DBG_REQUIRE( ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval() );

    SchedulerTerminate();
    DBG_REQUIRE( ALLOC_CACHE_HANDLER::Cleanup());

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Successfully cleaned up.\n"
                     ));
    }

    return TRUE;
} // AtqTerminate()





DWORD_PTR
AtqSetInfo(
    IN ATQ_INFO         atqInfo,
    IN DWORD_PTR        Data
    )
/*++

Routine Description:

    Sets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    DWORD_PTR dwOldVal = 0;

    switch ( atqInfo ) {

    case AtqBandwidthThrottle:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwOldVal = g_pBandwidthInfo->SetBandwidthLevel( (DWORD)Data );
        break;

    case AtqBandwidthThrottleMaxBlocked:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwOldVal = g_pBandwidthInfo->SetMaxBlockedListSize( (DWORD)Data );
        break;

    case AtqExitThreadCallback:

        dwOldVal = (DWORD_PTR) g_pfnExitThreadCallback;
        g_pfnExitThreadCallback =  (ATQ_THREAD_EXIT_CALLBACK ) Data;
        break;

    case AtqMaxPoolThreads:
          // the value is per processor values
        // internally we maintain value for all processors
        dwOldVal = g_cMaxThreads/g_cCPU;
        g_cMaxThreads = (DWORD)Data * g_cCPU;
        break;

      //
      //  Increment or decrement the max thread count.  In this instance, we
      //  do not scale by the number of CPUs
      //

      case AtqIncMaxPoolThreads:
        InterlockedIncrement( (LONG *) &g_cMaxThreads );
        dwOldVal = TRUE;
        break;

      case AtqDecMaxPoolThreads:
        InterlockedDecrement( (LONG *) &g_cMaxThreads );
        dwOldVal = TRUE;
        break;


      case AtqMaxConcurrency:
        dwOldVal = g_cConcurrency;
        g_cConcurrency = (DWORD)Data;
        break;

      case AtqThreadTimeout:
        dwOldVal = g_msThreadTimeout/1000;  // convert back to seconds
        g_msThreadTimeout = (DWORD)Data * 1000; // convert value to millisecs
        break;

      case AtqUseAcceptEx:
        dwOldVal = g_fUseAcceptEx;
        if ( !TsIsWindows95() ) {
            g_fUseAcceptEx = (DWORD)Data;
        }
        break;

      case AtqMinKbSec:

        //
        //  Ignore it if the value is zero
        //

        if ( Data ) {
            dwOldVal = g_cbMinKbSec;
            g_cbMinKbSec = (DWORD)Data;
        }
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    }

    return dwOldVal;
} // AtqSetInfo()





DWORD_PTR
AtqGetInfo(
    IN ATQ_INFO  atqInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set

Return Value:

    The old value of the parameter

--*/
{
    DWORD_PTR dwVal = 0;

    switch ( atqInfo ) {

      case AtqBandwidthThrottle:
        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwVal = g_pBandwidthInfo->QueryBandwidthLevel();
        break;

      case AtqExitThreadCallback:

        dwVal = (DWORD_PTR) g_pfnExitThreadCallback;
        break;

      case AtqMaxPoolThreads:
        dwVal = g_cMaxThreads/g_cCPU;
        break;

      case AtqMaxConcurrency:
        dwVal = g_cConcurrency;
        break;

      case AtqThreadTimeout:
        dwVal = g_msThreadTimeout/1000; // convert back to seconds
        break;

      case AtqUseAcceptEx:
        dwVal = g_fUseAcceptEx;
        break;

      case AtqMinKbSec:
        dwVal = g_cbMinKbSec;
        break;

      case AtqMaxDGramSend:
        dwVal = g_cbMaxDGramSend;
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    } // switch

    return dwVal;
} // AtqGetInfo()





BOOL
AtqGetStatistics(IN OUT ATQ_STATISTICS * pAtqStats)
{
    if ( pAtqStats != NULL) {

        return g_pBandwidthInfo->GetStatistics( pAtqStats );

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        return (FALSE);
    }
} // AtqGetStatistics()





BOOL
AtqClearStatistics( VOID)
{
    return g_pBandwidthInfo->ClearStatistics();

} // AtqClearStatistics()





DWORD_PTR
AtqContextSetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo,
    DWORD_PTR              Data
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    DWORD_PTR dwOldVal = 0;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE )
    {
        switch ( atqInfo ) {

        case ATQ_INFO_TIMEOUT:
            dwOldVal = pContext->TimeOut;
            pContext->TimeOut = CanonTimeout( (DWORD)Data );
            break;

        case ATQ_INFO_RESUME_IO:

            //
            // set back the max timeout from pContext->TimeOut
            // This will ensure that timeout processing can go on
            //   peacefully.
            //

            {
                DWORD currentTime = AtqGetCurrentTick( );
                DWORD timeout;
                dwOldVal = pContext->NextTimeout;
                timeout = pContext->TimeOut;

                //
                // Set the new timeout
                //

                I_SetNextTimeout(pContext);

                //
                // Return the old
                //

                if ( currentTime >= dwOldVal ) {
                    ATQ_ASSERT((dwOldVal & ATQ_INFINITE) == 0);
                    dwOldVal = 0;
                } else if ( (dwOldVal & ATQ_INFINITE) == 0 ) {
                    dwOldVal -= currentTime;
                }

                // return correct units
                dwOldVal = UndoCanonTimeout( (DWORD)dwOldVal );
            }
            break;

        case ATQ_INFO_COMPLETION:
            dwOldVal = (DWORD_PTR) pContext->pfnCompletion;
            pContext->pfnCompletion = (ATQ_COMPLETION) Data;
            break;

        case ATQ_INFO_COMPLETION_CONTEXT:

            ATQ_ASSERT( Data != 0 );        // NULL context not allowed

            dwOldVal = (DWORD_PTR) pContext->ClientContext;
            pContext->ClientContext = (void *) Data;
            break;

        case ATQ_INFO_BANDWIDTH_INFO:
        {
            ATQ_ASSERT( Data != 0 );

            PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) Data;

            ATQ_ASSERT( pBandwidthInfo->QuerySignature() ==
                                                ATQ_BW_INFO_SIGNATURE );

            if ( !pBandwidthInfo->IsFreed() )
            {
                pContext->m_pBandwidthInfo = (PBANDWIDTH_INFO) Data;
                pContext->m_pBandwidthInfo->Reference();
            }
            break;
        }

        case ATQ_INFO_ABORTIVE_CLOSE:
            dwOldVal = pContext->IsFlag( ACF_ABORTIVE_CLOSE );
            if ( Data )
            {
                pContext->SetFlag( ACF_ABORTIVE_CLOSE );
            }
            else
            {
                pContext->ResetFlag( ACF_ABORTIVE_CLOSE );
            }
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return dwOldVal;

} // AtqContextSetInfo()



BOOL
AtqAddAsyncHandle(
    PATQ_CONTEXT * ppatqContext,
    PVOID          EndpointObject,
    PVOID          ClientContext,
    ATQ_COMPLETION pfnCompletion,
    DWORD          TimeOut,
    HANDLE         hAsyncIO
    )
/*++

Routine Description:

    Adds a handle to the thread queue

    The client should call this after the IO handle is opened
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

Arguments:

    ppatqContext - Receives allocated ATQ Context
    Context - Context to call client with
    pfnCompletion - Completion to call when IO completes
    TimeOut - Time to wait (sec) for IO completion (INFINITE is valid)
    hAsyncIO - Handle with pending read or write

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    return ( I_AtqAddAsyncHandle( (PATQ_CONT *) ppatqContext,
                                  (PATQ_ENDPOINT) EndpointObject,
                                  ClientContext,
                                  pfnCompletion,
                                  TimeOut,
                                  hAsyncIO)
             &&
             I_AddAtqContextToPort( *((PATQ_CONT *) ppatqContext))
            );

} // AtqAddAsyncHandle()




VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    )
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    INT       cbsockaddrLocal;
    INT       cbsockaddrRemote;
    DWORD     cb;

    ATQ_ASSERT( g_fUseAcceptEx);
    ATQ_ASSERT( pContext->pEndpoint);

    *pSock   = (SOCKET) pContext->hAsyncIO;
    *pEndpointContext = pContext->pEndpoint->Context;

    //
    //  The buffer not only receives the initial received data, it also
    //  gets the sock addrs, which must be at least sockaddr_in + 16 bytes
    //  large
    //

    g_pfnGetAcceptExSockaddrs( pContext->pvBuff,
                               (cb = pContext->pEndpoint->InitialRecvSize),
                               MIN_SOCKADDR_SIZE,
                               MIN_SOCKADDR_SIZE,
                               ppsockaddrLocal,
                               &cbsockaddrLocal,
                               ppsockaddrRemote,
                               &cbsockaddrRemote );

    *ppvBuff = ( ( cb == 0) ? NULL : pContext->pvBuff);

    return;
} // AtqGetAcceptExAddrs()




BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    )
/*++

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        BOOL fAbortiveClose;

        fAbortiveClose = pContext->IsFlag( ACF_ABORTIVE_CLOSE );
        pContext->ResetFlag( ACF_ABORTIVE_CLOSE );

        //
        //  Don't delete the socket if we don't have to
        //

        if ( pContext->IsState( ACS_SOCK_UNCONNECTED |
                                ACS_SOCK_CLOSED)
             ) {

            //
            //  Do nothing
            //

        } else {

            // default:
            // case ACS_SOCK_LISTENING:
            // case ACS_SOCK_CONNECTED: {

            HANDLE hIO;
            PATQ_ENDPOINT pEndpoint;

            pEndpoint = pContext->pEndpoint;

            pContext->MoveState( ACS_SOCK_CLOSED);

            //
            //  During shutdown, the socket may be closed while this thread
            //  is doing processing, so only give a warning if any of the
            //  following fail
            //

            hIO = (HANDLE )InterlockedExchangePointer((PVOID *) &pContext->hAsyncIO,
                                                      NULL);

            if ( hIO == NULL ) {

                //
                // No socket - it is already closed - do nothing.
                //

            } else {

                if ( pContext->fDatagramContext ) {
                    return TRUE;
                }

                if (fAbortiveClose || fShutdown ) {

                    //
                    //  If this is an AcceptEx socket, we must first force a
                    //  user mode context update before we can call shutdown
                    //

                    if ( (pEndpoint != NULL) && (pEndpoint->UseAcceptEx) ) {

                        if ( setsockopt( (SOCKET) hIO,
                                         SOL_SOCKET,
                                         SO_UPDATE_ACCEPT_CONTEXT,
                                         (char *) &pEndpoint->ListenSocket,
                                         sizeof(SOCKET) ) == SOCKET_ERROR ) {

                            ATQ_PRINTF(( DBG_CONTEXT,
                                         "[AtqCloseSocket] Warning- setsockopt "
                                         "failed, error %d, socket = %x,"
                                         " Context= %08x, Listen = %lx\n",
                                         GetLastError(),
                                         hIO,
                                         pContext,
                                         pEndpoint->ListenSocket ));
                        }
                    }
                } // setsock-opt call

                if ( fAbortiveClose ) {
                    LINGER  linger;

                    linger.l_onoff = TRUE;
                    linger.l_linger = 0;

                    if ( setsockopt( (SOCKET) hIO,
                                     SOL_SOCKET,
                                     SO_LINGER,
                                     (char *) &linger,
                                     sizeof(linger) ) == SOCKET_ERROR
                         ) {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket] Warning- setsockopt "
                                     "failed, error %d, socket = %x,"
                                     " Context= %08x, Listen = %lx\n",
                                     GetLastError(),
                                     hIO,
                                     pContext,
                                     pEndpoint->ListenSocket ));
                    }
                } // set up linger

                if ( fShutdown ) {

                    //
                    //  Note that shutdown can fail in instances where the
                    //  client aborts in the middle of a TransmitFile.
                    //  This is an acceptable failure case
                    //

                    shutdown( HandleToUlong(hIO), 1 );
                }

                DBG_ASSERT( hIO != NULL);

                if ( closesocket( HandleToUlong(hIO)) ) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqCloseSocket] Warning- closesocket "
                                 " failed, Context = %08x, error %d,"
                                 " socket = %x\n",
                                 pContext,
                                 GetLastError(),
                                 hIO ));
                }
            } // if (hIO != NULL)
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseSocket()


BOOL
AtqShutdownSocket(
    PATQ_CONTEXT patqContext,
    AtqShutdownFlag  flags
    )
/*++

  Routine Description:

    Performs a shutdown on an ATQ_CONTEXT socket.

  Arguments:

    patqContext - Context whose socket should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    HANDLE    hIO      = pContext->hAsyncIO;
    PATQ_ENDPOINT pEndpoint = pContext->pEndpoint;

    ATQ_ASSERT( patqContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

#if 0
    // AtqShutdownSocket should not be called on a closed context.
    ATQ_ASSERT( !(pContext->IsState( ACS_SOCK_UNCONNECTED | ACS_SOCK_CLOSED)) );
#endif

    if ( pContext->IsState( ACS_SOCK_UNCONNECTED | ACS_SOCK_CLOSED)) {

        //
        //  The socket has already been closed.  Do nothing.
        //
        return TRUE;

    }

    if ( pContext->fDatagramContext ) {
        return TRUE;
    }


    //
    //  If this is an AcceptEx socket, we must first force a
    //  user mode context update before we can call shutdown
    //

    if ( (pEndpoint != NULL) && (pEndpoint->UseAcceptEx) ) {

        if ( setsockopt( (SOCKET) hIO,
                         SOL_SOCKET,
                         SO_UPDATE_ACCEPT_CONTEXT,
                         (char *) &pEndpoint->ListenSocket,
                         sizeof(SOCKET) ) == SOCKET_ERROR ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqCloseSocket] Warning- setsockopt "
                         "failed, error %d, socket = %x,"
                         " Context= %08x, Listen = %lx\n",
                         GetLastError(),
                         hIO,
                         pContext,
                         pEndpoint->ListenSocket ));
        }
    }


    //
    //  Note that shutdown can fail in instances where the
    //  client aborts in the middle of a TransmitFile.
    //  This is an acceptable failure case
    //

    shutdown( HandleToUlong(hIO), flags );

    return TRUE;
} // AtqCloseSocket()



BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    )
/*++

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

    patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.

  Note:
   THIS FUNCTIONALITY IS ADDED TO SERVE A SPECIAL REQUEST!!!
   Most of the ATQ code thinks that the handle here is a socket.
   Except of course this function...
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext != NULL ) {

        HANDLE hIO;

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
        ATQ_ASSERT( !pContext->IsAcceptExRootContext());
        ATQ_ASSERT( !TsIsWindows95() );  // NYI

        hIO =
          (HANDLE ) InterlockedExchangePointer((PVOID *) &pContext->hAsyncIO,
                                               NULL);

        if ( (hIO == NULL) || !CloseHandle( hIO ) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqCloseFileHandle] Warning- CloseHandle failed, "
                        " Context = %08x, error %d, handle = %x\n",
                        pContext,
                        GetLastError(),
                        hIO ));
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseFileHandle()





VOID
AtqFreeContext(
    PATQ_CONTEXT patqContext,
    BOOL         fReuseContext
    )
/*++

Routine Description:

    Frees the context created in AtqAddAsyncHandle.
    Call this after the async handle has been closed and all outstanding
    IO operations have been completed. The context is invalid after this call.
    Call AtqFreeContext() for same context only ONCE.

Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

--*/
{
    PATQ_CONT pContext = (PATQ_CONT)patqContext;

    ATQ_ASSERT( pContext != NULL );

    IF_DEBUG( API_ENTRY) {

        ATQ_PRINTF(( DBG_CONTEXT, "AtqFreeContext( %08x (handle=%08x,"
                     " nIOs = %d), fReuse=%d)\n",
                     patqContext, patqContext->hAsyncIO,
                     pContext->m_nIO,
                     fReuseContext));
    }

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

#if 1
        //
        // !! DS change
        //
        //

        //
        //  If the socket is an AcceptEx socket, redo the AcceptEx and put
        //  it back on the in use list
        //

        PATQ_ENDPOINT pEndpoint = pContext->pEndpoint;

        //
        // If we have plenty of outstanding sockets (the number requested),
        // don't re-use this one.
        //

        if (pEndpoint != NULL) {
            if ( pEndpoint->nSocketsAvail >
                (LONG )(pEndpoint->nAcceptExOutstanding) ) {

                fReuseContext= FALSE;
            }
        }
#endif

        if ( fReuseContext ) {
            pContext->SetFlag( ACF_REUSE_CONTEXT);
        } else {
            pContext->ResetFlag( ACF_REUSE_CONTEXT);
        }

        if ( InterlockedDecrement(  &pContext->m_nIO) == 0) {

            //
            // The number of outstanding ref holders is ZERO.
            // Free up this ATQ context.
            //
            // We really do not free up the context - but try to reuse
            //  it if possible
            //

            DBG_ASSERT( pContext->lSyncTimeout == 0);
            AtqpReuseOrFreeContext( pContext, fReuseContext);
        }
    }

    return;
} // AtqFreeContext()



BOOL
AtqReadFile(
        IN PATQ_CONTEXT patqContext,
        IN LPVOID       lpBuffer,
        IN DWORD        BytesToRead,
        IN OVERLAPPED * lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async read using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    if (NULL == pContext->hAsyncIO) {
        // Only socket handles are used by ATQ, thus NULL is not allowed,
        // and indicates that ATQ has closed the socket.
        InterlockedDecrement( &pContext->m_nIO );
        SetLastError(WSAENOTSOCK);
        return FALSE;
    }

    fRes = ( ReadFile( pContext->hAsyncIO,
                      lpBuffer,
                      BytesToRead,
                      &cbRead,
                      lpo ) ||
            GetLastError() == ERROR_IO_PENDING);

    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqReadFile()



BOOL
AtqReadSocket(
        IN PATQ_CONTEXT  patqContext,
        IN LPWSABUF     pwsaBuffers,
        IN DWORD        dwBufferCount,
        IN OVERLAPPED *  lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async recv using the handle defined in the context
     as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqReadSocket(%08lx) called.\n", pContext));
    }

    if (pContext->IsFlag( ACF_RECV_ISSUED)) {
        IF_DEBUG( SPUD ) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqReadSocket -> WSARecv bypassed.\n"));
        }
        pContext->BytesSent = 0;
        pContext->SetFlag( ACF_RECV_CALLED);
        return TRUE;
    }

    I_SetNextTimeout(pContext);


    // count the number of bytes
    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    DWORD  lpFlags = 0;

    //
    // See if the connection has already been closed.
    //
    if (pContext->hAsyncIO == NULL) {
        InterlockedDecrement( &pContext->m_nIO );
        SetLastError(WSAENOTSOCK);
        return FALSE;
    }

    fRes = ( (WSARecv( (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       &cbRead,
                       &lpFlags,  // no flags
                       lpo,
                       NULL       // no completion routine
                       ) == 0) ||
             (WSAGetLastError() == WSA_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqReadSocket()



BOOL
AtqWriteFile(
    IN PATQ_CONTEXT patqContext,
    IN LPCVOID      lpBuffer,
    IN DWORD        BytesToWrite,
    IN OVERLAPPED * lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to write
    BytesToWrite - number of bytes to write
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( !TsIsWindows95() );  // NYI
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);
    pContext->BytesSent = BytesToWrite;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    if (NULL == pContext->hAsyncIO) {
        // Only socket handles are used by ATQ, thus NULL is not allowed,
        // and indicates that ATQ has closed the socket.
        InterlockedDecrement( &pContext->m_nIO );
        SetLastError(WSAENOTSOCK);
        return FALSE;
    }
    fRes = ( WriteFile( pContext->hAsyncIO,
                        lpBuffer,
                        BytesToWrite,
                        &cbWritten,
                        lpo ) ||
             GetLastError() == ERROR_IO_PENDING);
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqWriteFile()



BOOL
AtqWriteSocket(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf < (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( lpo == NULL ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    //
    // See if the connection has already been closed.
    //
    if (pContext->hAsyncIO == NULL) {
        InterlockedDecrement( &pContext->m_nIO );
        SetLastError(WSAENOTSOCK);
        return FALSE;
    }

    fRes = ( (WSASend( (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       &cbWritten,
                       0,               // no flags
                       lpo,
                       NULL             // no completion routine
                       ) == 0) ||
             (WSAGetLastError() == WSA_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqWriteSocket()




BOOL
AtqSyncWsaSend(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    )
/*++

  Routine Description:

    Does a sync write of an array of wsa buffers using WSASend.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    pcbWritten - ptr to count of bytes written

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{

    BOOL fRes = FALSE;
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    InterlockedIncrement( &pContext->m_nIO );
    //
    // See if the connection has already been closed.
    //
    if (pContext->hAsyncIO == NULL) {
        InterlockedDecrement( &pContext->m_nIO );
        SetLastError(WSAENOTSOCK);
        return FALSE;
    }

    fRes = ( WSASend(  (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       pcbWritten,
                       0,               // no flags
                       NULL,            // lpo == NULL for sync write
                       NULL             // no completion routine
                       ) == 0);

    InterlockedDecrement( &pContext->m_nIO );

    return fRes;

} // AtqSyncWsaSend()




BOOL
AtqTransmitFile(
    IN PATQ_CONTEXT            patqContext,
    IN HANDLE                  hFile,
    IN DWORD                   dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD                   dwFlags
    )
/*++

  Routine Description:

    Does a TransmitFile  using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    hFile - handle of file to read from
    dwBytesInFile - Bytes to transmit
    lpTransmitBuffers - transmit buffer structure
    dwFlags - Transmit file flags

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
#if 0
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    //
    //  For large file sends, the client's default timeout may not be
    //  adequte for slow links.  Scale based on bytes being sent
    //

    I_SetNextTimeout(pContext);
    pContext->BytesSent = dwBytesInFile;

    if ( dwFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwFlags = TF_WRITE_BEHIND;

    } else if ( dwFlags & TF_DISCONNECT ) {

        //
        //  If the socket is getting disconnected, mark it appropriately
        //

        pContext->MoveState( ( ( dwFlags & TF_REUSE_SOCKET )?
                               ACS_SOCK_UNCONNECTED:
                               ACS_SOCK_CLOSED
                               )
                             );
    }

    InterlockedIncrement( &pContext->m_nIO);

    fRes = (TransmitFile( (SOCKET ) pContext->hAsyncIO,
                           hFile,
                           dwBytesInFile,
                           0,
                           &pContext->Overlapped,
                           lpTransmitBuffers,
                           dwFlags ) ||
            (GetLastError() == ERROR_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

    //
    //  Restore the socket state if we failed so that the handle gets freed
    //

    if ( !fRes )
    {
        pContext->MoveState( ACS_SOCK_CONNECTED);
    }

    return fRes;
#else
    DBG_ASSERT(FALSE);
    return FALSE;
#endif
} // AtqTransmitFile()


BOOL
AtqReadDirChanges(IN PATQ_CONTEXT patqContext,
                  IN LPVOID       lpBuffer,
                  IN DWORD        BytesToRead,
                  IN BOOL         fWatchSubDir,
                  IN DWORD        dwNotifyFilter,
                  IN OVERLAPPED * lpo
                  )
/*++
  AtqReadDirChanges()

  Description:
    This function submits an Async ReadDirectoryChanges() call for
    the Async handle in the ATQ context supplied.
    It always requires a non-NULL overlapped pointer for processing
    this call.

  Arguments:
    patqContext  - pointer to ATQ Context
    lpBuffer     - buffer for the data to be read from ReadDirectoryChanges()
    BytesToRead  - count of bytes to read into buffer
    fWatchSubDir - should we watch for sub directory changes
    dwNotifyFilter - DWORD containing the flags for Notification
    lpo          - pointer to overlapped structure.

  Returns:
    TRUE if ReadDirectoryChanges() is successfully submitted.
    FALSE if there is any failure in submitting IO.
--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

#if 0
    if ( lpo == NULL ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);
    fRes = ReadDirectoryChangesW( pContext->hAsyncIO,
                          lpBuffer,
                          BytesToRead,
                          fWatchSubDir,
                          dwNotifyFilter,
                          &cbRead,
                          lpo,
                          NULL);
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
#else
    return FALSE;
#endif
} // AtqReadDirChanges()



BOOL
AtqPostCompletionStatus(
        IN PATQ_CONTEXT patqContext,
        IN DWORD        BytesTransferred
        )
/*++

Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{
    BOOL fRes;
    PATQ_CONT  pAtqContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    ATQ_ASSERT( (pAtqContext)->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !pAtqContext->IsBlocked()) {

        InterlockedIncrement( &pAtqContext->m_nIO);

        fRes = ( PostQueuedCompletionStatus( g_rghCompPort[ NtCurrentTeb()->IdealProcessor ],
                                          BytesTransferred,
                                          (DWORD_PTR) patqContext,
                                          &pAtqContext->Overlapped ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pAtqContext->m_nIO); };
    } else {

        //
        // Forcibly remove the context from blocking list.
        //

        fRes = pBandwidthInfo->RemoveFromBlockedList(pAtqContext);

        // There is a possibility of race conditions!
        //  If we cant remove an item from blocking list before
        //         its IO operation is scheduled.
        // there wont be any call back generated for this case!
    }

    return fRes;

} // AtqPostCompletionStatus



DWORD
I_AtqGetGlobalConfiguration(VOID)
/*++
Description:
   This function sets several global config params for the ATQ package.
   It also reads the global configuration from registry for ATQ.
   The values if present will override the defaults

Returns:
   Win32 Errorcode - NO_ERROR on success and anything else for error
--*/
{
    DWORD       dwError = NO_ERROR;
    DWORD       dwDefaultThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT;

    //
    // If this is a NTW, do the right thing
    //

    MEMORYSTATUS ms;

    //
    // get the memory size
    //

    ms.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus( &ms );

    //
    // attempt to use driver
    //

    g_fUseDriver = FALSE;

    //
    // Alloc two threads per MB of memory.
    //

    g_cMaxThreadLimit = (LONG)(ms.dwTotalPhys >> 19) + 2;

    if ( g_cMaxThreadLimit < ATQ_REG_MIN_POOL_THREAD_LIMIT ) {
        g_cMaxThreadLimit = ATQ_REG_MIN_POOL_THREAD_LIMIT;
    } else if ( g_cMaxThreadLimit > ATQ_REG_MAX_POOL_THREAD_LIMIT ) {
        g_cMaxThreadLimit = ATQ_REG_MAX_POOL_THREAD_LIMIT;
    }

    AtqSetInfo( AtqMaxConcurrency, ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY);
    AtqSetInfo( AtqUseAcceptEx, TRUE );
    AtqSetInfo( AtqMaxPoolThreads, ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS);
    AtqSetInfo( AtqThreadTimeout, ATQ_REG_DEF_THREAD_TIMEOUT);

    return ( dwError);
} // I_AtqGetGlobalConfiguration()



DWORD
I_NumAtqEndpointsOpen(VOID)
/*++
  Description:
    This function counts the number of Enpoints that remain open.

  Arguments:
     None

  Returns:
     DWORD containing the number of endpoints that are open.
--*/
{
    DWORD nEPOpen = 0;
    AcquireLock( &AtqEndpointLock);

    PLIST_ENTRY plEP;
    for( plEP  = AtqEndpointList.Flink;
         plEP != &AtqEndpointList;
         plEP  = plEP->Flink ) {

        nEPOpen++;
    } // for

    ReleaseLock( &AtqEndpointLock);
    return ( nEPOpen);
} // I_NumAtqEndpointsOpen()


#define WINSOCK_INIT_WAIT_TIME      (25 * 1000)  // 25 seconds
#define WINSOCK_INIT_WAIT_RETRIES   4



BOOL
WaitForWinsockToInitialize(
    VOID
    )
/*++

Routine Description:

    Spin until winsock comes up.

Arguments:

    None.

Return Value:

    TRUE if winsock is up. FALSE, if something bad happened.

--*/
{
    INT             err;
    WSADATA         wsaData;
    SOCKET          s = INVALID_SOCKET;
    SOCKADDR_IN     sockAddr;
    INT             retryCount = WINSOCK_INIT_WAIT_RETRIES;
    BOOL            fRet      = FALSE;
    BOOL            fTCP      = FALSE;
    BOOL            fSignaled = TRUE;
    BOOL            fAddr     = FALSE;
    DWORD           dwErr;
    DWORD           dwBytes;
    DWORD           cbMaxDGramSend;
    OVERLAPPED      Overlapped;
    HANDLE          hConfig = NULL;

    err = WSAStartup(MAKEWORD(2,0), &wsaData);
    if ( err != 0 ) {
        ATQ_PRINTF((DBG_CONTEXT,"err %d in WSAStartup\n", err));
        return FALSE;
    }

    Overlapped.hEvent = CreateEvent(NULL,   // default SD
                                    FALSE,  // auto reset the event
                                    FALSE,  // initialize as non signaled
                                    NULL);  // no name

    if (NULL == Overlapped.hEvent) {
        goto cleanup;
    }

    s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, NULL, WSA_FLAG_OVERLAPPED);
    if (INVALID_SOCKET != s) {

        fTCP = TRUE;

    } else {

        // TCP is not installed or setup.  Wait a reasonable amount of time for it
        // to be setup and then bail.

        // Get the initial handle so we will be sure and not miss it when/if
        // tcp is installed.  We don't need an overlapped structure for the
        // first call since it will complete emediately.
        if (WSAProviderConfigChange(&hConfig, NULL, NULL)) {
            ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize WSAProviderConfigChange returned 0x%x\n", WSAGetLastError()));
            goto cleanup;
        }

        s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, NULL, WSA_FLAG_OVERLAPPED);
        if (INVALID_SOCKET != s) {

            fTCP = TRUE;
        }

        while (retryCount && !fTCP) {

            if (fSignaled) {
                err = WSAProviderConfigChange(&hConfig,
                                              &Overlapped,
                                              NULL);

                if (err && (WSA_IO_PENDING != WSAGetLastError())) {
                    ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize ConfigChange failed with 0x%x\n", WSAGetLastError()));
                    goto cleanup;
                }
            }

            ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize waiting for socket . . .\n"));
            dwErr = WaitForSingleObject(Overlapped.hEvent, WINSOCK_INIT_WAIT_TIME);
            switch (dwErr) {
            default:
                // Something went pretty wrong here.
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize Failed at WaitForSingleObject with 0x%x\n", GetLastError()));
                goto cleanup;
            case WAIT_OBJECT_0:
                //
                // See if we have TCP now.
                //
                fSignaled = TRUE;
                s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, NULL, WSA_FLAG_OVERLAPPED);
                if (INVALID_SOCKET != s) {
                    //
                    // This will cause us to exit the retry loop
                    //
                    fTCP = TRUE;
                }
                break;
            case WAIT_TIMEOUT:
                // try again.  The event wasn't signaled so don't bother
                // calling WSAProviderConfigChange again.
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize waiting for TCP timed out.\n"));
                fSignaled = FALSE;
                break;
            }
            retryCount--;
        }
    }

    if (fTCP) {
        ATQ_ASSERT(TRUE == fSignaled);

        retryCount = WINSOCK_INIT_WAIT_RETRIES;

        // init sockAddr
        ZeroMemory(&sockAddr, sizeof(sockAddr));
        sockAddr.sin_family = AF_INET;
        sockAddr.sin_port = 0;
        sockAddr.sin_addr.s_addr = INADDR_ANY;

        err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));
        if ( err != SOCKET_ERROR ) {

            fAddr = TRUE;

        } else {

            err = WSAIoctl(s,
                           SIO_ADDRESS_LIST_CHANGE,
                           NULL,                // no input buffer
                           0,                   // size of input buffer
                           NULL,                // don't need an ouput buffer either
                           0,                   // size of out buffer
                           &dwBytes,            // bytes returned
                           &Overlapped,         // overlapped structure
                           NULL);               // no callback routine

            if (err && (WSAGetLastError() != WSA_IO_PENDING)) {
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize Failed at WSAIoctl with 0x%x\n", WSAGetLastError()));
                goto cleanup;
            }

            err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));
            if ( err != SOCKET_ERROR ) {

                fAddr = TRUE;

            }

            while (retryCount && !fAddr) {

                ATQ_PRINTF(( DBG_CONTEXT, "WaitWinsockToInitialize waiting for address . . .\n"));
                dwErr = WaitForSingleObject(Overlapped.hEvent, WINSOCK_INIT_WAIT_TIME);
                switch (dwErr) {
                default:
                    // Something went pretty wrong here.
                    ATQ_PRINTF(( DBG_CONTEXT, "WaitWinsockToInitialize Failed at WaitForSingleObject with 0x%x\n", GetLastError()));
                    goto cleanup;
                case WAIT_OBJECT_0:
                    //
                    // Register for address change notification again so that
                    // nothing is missed in case there still aren't any TCP
                    // addresses.
                    //
                    err = WSAIoctl(s,
                                   SIO_ADDRESS_LIST_CHANGE,
                                   NULL,                // no input buffer
                                   0,                   // size of input buffer
                                   NULL,                // don't need an ouput buffer either
                                   0,                   // size of out buffer
                                   &dwBytes,            // bytes returned
                                   &Overlapped,         // overlapped structure
                                   NULL);               // no callback routine

                    if (err && (WSA_IO_PENDING != WSAGetLastError())) {
                        ATQ_PRINTF(( DBG_CONTEXT, "WaitWinsockToInitialize Failed at WSAIoctl with 0x%x\n", WSAGetLastError()));
                        goto cleanup;
                    }

                    //
                    // See if we have an address to bind to now.
                    //
                    err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));
                    if (SOCKET_ERROR != err) {
                        //
                        // This will cause us to exit the retry loop
                        //
                        fAddr = TRUE;
                    }
                    break;
                case WAIT_TIMEOUT:
                    // try again.  The event wasn't signaled so don't bother
                    // calling WSAIoctl again.
                    ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize waiting for addr's timed out.\n"));
                    break;
                }
                retryCount--;

            }     // while
        } // if err != SOCKET_ERROR
    } // if fTCP

    if (fTCP && fAddr) {
        SOCKET s2;
        INT    size = sizeof(cbMaxDGramSend);
        GUID   RecvMsgGuid  = WSAID_WSARECVMSG;
        GUID   AcceptExGuid = WSAID_ACCEPTEX;
        GUID   GetAccptExAddrsGuid = WSAID_GETACCEPTEXSOCKADDRS;

        //
        // Set the return value as TRUE
        //
        fRet = TRUE;


        // record the largest possible datagram send.
        s2 = WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, NULL, NULL, 0);
        if ( s == INVALID_SOCKET) {

            err = WSAGetLastError();
            ATQ_PRINTF(( DBG_CONTEXT, "WSASocket failed with %d.\n", err));
        } else {

            err = getsockopt(s,
                             SOL_SOCKET,
                             SO_MAX_MSG_SIZE,
                             (PCHAR)&cbMaxDGramSend,
                             &size);

            if ( err == 0 ) {
                g_cbMaxDGramSend = cbMaxDGramSend;
                ATQ_PRINTF(( DBG_CONTEXT, "Setting g_cbMaxDGramSend to 0x%x\n", g_cbMaxDGramSend));
            } else {
                ATQ_PRINTF(( DBG_CONTEXT, "Cannot query max datagram size [err %d]\n",
                        WSAGetLastError()));
            }

            err = WSAIoctl(s2,
                           SIO_GET_EXTENSION_FUNCTION_POINTER,
                           &RecvMsgGuid,
                           sizeof(GUID),
                           &g_pfnWSARecvMsg,
                           sizeof(g_pfnWSARecvMsg),
                           &dwBytes,
                           NULL,
                           NULL
                           );

            if (err) {
                ATQ_PRINTF(( DBG_CONTEXT, "Failed to query for the WSARecvMsg pointer [err 0x%x]\n",
                             WSAGetLastError()));
            } else {
                g_bUseRecvMsg = TRUE;
            }
                    
            closesocket(s2);
        }

        err = WSAIoctl(s,
                       SIO_GET_EXTENSION_FUNCTION_POINTER,
                       &AcceptExGuid,
                       sizeof(GUID),
                       &g_pfnAcceptEx,
                       sizeof(g_pfnAcceptEx),
                       &dwBytes,
                       NULL,
                       NULL
                       );

        if (err) {
            ATQ_PRINTF(( DBG_CONTEXT, "Failed to query for the WSAAcceptEx pointer [err 0x%x]\n",
                         WSAGetLastError()));
            g_pfnAcceptEx = AcceptEx;
        }
        
        err = WSAIoctl(s,
                       SIO_GET_EXTENSION_FUNCTION_POINTER,
                       &GetAccptExAddrsGuid,
                       sizeof(GUID),
                       &g_pfnGetAcceptExSockaddrs,
                       sizeof(g_pfnGetAcceptExSockaddrs),
                       &dwBytes,
                       NULL,
                       NULL
                       );

        if (err) {
            ATQ_PRINTF(( DBG_CONTEXT, "Failed to query for the GetAcceptExAddrs pointer [err 0x%x]\n",
                         WSAGetLastError()));
            g_pfnGetAcceptExSockaddrs = GetAcceptExSockaddrs;
        }
    }

cleanup:

    if (NULL != hConfig) {
        CloseHandle(hConfig);
    }

    if (INVALID_SOCKET != s) {
        closesocket(s);
    }

    if (NULL != Overlapped.hEvent) {
        CloseHandle(Overlapped.hEvent);
    }

    if (!fRet) {
        WSACleanup();
    }

    IF_DEBUG(ERROR) {
        if (!fRet) {
            if (!fTCP) {
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize there's no sockets.\n"));
            } else {
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize there's no ip addresses.\n"));
            }
        }
    }
    return fRet;
} // WaitForWinsockToInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb )


// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants
//

#define DEBUG_SIO                   0x10000000
#define DEBUG_TIMEOUT               0x20000000
#define DEBUG_ENDPOINT              0x40000000
#define DEBUG_SPUD                  0x80000000

# define DEBUG_ALLOC_CACHE          0x01000000

// Use the default constants from pudebug.h

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\atqsupp.cxx ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

       atqsupp.cxx

   Abstract:

        Contains internal support routines for the ATQ package
        From atqnew.c

   Author:
        Murali R. Krishnan     (MuraliK)     02-Apr-1996

   Project:
        Internet Server Common DLL
--*/

#include "isatq.hxx"

typedef GUID UUID;

extern "C" {

#include <ntdsa.h>

}

DWORD AtqPoolThread( LPDWORD param );

VOID I_AtqThreadMonitor( IN PVOID NotUsed );

DWORD g_dwThreadMonitorCookie = 0;

extern PBANDWIDTH_INFO g_pBandwidthInfo;

# ifdef ENABLE_REUSE_THROTTLE

DWORD g_fAlwaysReuseSockets = TRUE;

# endif // ENABLE_REUSE_THROTTLE

//
// If this is true then no AtqPoolThreads have completed
// servicing an IO since the last time I_AtqThreadMonitor
// ran.
//
BOOL  g_fDeadManSwitch = FALSE;


/************************************************************
 * Functions for ATQ_CONTEXT
 ************************************************************/


PATQ_CONT
I_AtqAllocContextFromCache( VOID);

VOID
I_AtqFreeContextToCache(
            IN PATQ_CONT pAtqContext,
            IN BOOL UnlinkContext
            );
VOID
I_ResetListenSocket(
    IN PATQ_ENDPOINT pEndpoint
    );



PATQ_CONT
I_AtqAllocContextFromCache( VOID)
/*++
  This function attempts to allocate an ATQ context from the allocation cache.
  It then initializes the state information in the ATQ context object and
    returns the context on success.

  Arguments:
    None

  Returns:
    On success a valid pointer to ATQ_CONT. Otherwise NULL.

--*/
{
    PATQ_CONT  pAtqContext;

    DBG_ASSERT( NULL != g_pachAtqContexts);

    pAtqContext = (ATQ_CONTEXT * ) g_pachAtqContexts->Alloc();

    if ( NULL != pAtqContext ) {


        pAtqContext->ContextList =
            &AtqActiveContextList[(++AtqGlobalContextCount %
                                   g_dwNumContextLists)];

        pAtqContext->Signature = ATQ_CONTEXT_SIGNATURE;
    }

    return (pAtqContext);
} // I_AtqAllocContextFromCache()




VOID
I_AtqFreeContextToCache(
        IN PATQ_CONT pAtqContext
        )
/*++
  This function releases the given context to the allocation cache.

  Arguments:
    pAtqContext  pointer to the ATQ_CONTEXT that is being freed.

  Returns:
    None

  Issues:
    This function also performs some other cleanup specific to AtqContexts.
--*/
{

#if 0
      ATQ_PRINTF(( DBG_CONTEXT,
                 "[I_AtqFreeCtxtToCache] Freed up %08x\n",
                 pAtqContext
                 ));
#endif

    DBG_ASSERT( pAtqContext->Signature == ATQ_FREE_CONTEXT_SIGNATURE);
    DBG_ASSERT( pAtqContext->lSyncTimeout ==0);
    DBG_ASSERT( pAtqContext->m_nIO ==0);
    DBG_ASSERT( pAtqContext->m_acFlags == 0);
    DBG_ASSERT( pAtqContext->m_acState == 0);
    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);
    DBG_ASSERT( pAtqContext->pvBuff == NULL);
    DBG_ASSERT( pAtqContext->pEndpoint == NULL);
    DBG_ASSERT( pAtqContext->hAsyncIO == NULL);

    DBG_REQUIRE( g_pachAtqContexts->Free( pAtqContext));

    return;

} // I_AtqFreeContextToCache



void
ATQ_CONTEXT::Print( void) const
{
    DBGPRINTF(( DBG_CONTEXT,
                " ATQ_CONTEXT (%08x)\n"
                "\thAsyncIO            = %08lx   Signature        = %08lx\n"
                "\tOverlapped.Internal = %08lx   Overlapped.Offset= %08lx\n"
                "\tm_leTimeout.Flink   = %08lx   m_leTimeout.Blink= %08lx\n"
                "\tClientContext       = %08lx   ContextList      = %08lx\n"
                "\tpfnCompletion       = %08lx ()\n"
                "\tpEndPoint           = %08lx   fAcceptExContext = %s\n"
                "\tlSyncTimeout        = %8d     fInTimeout       = %s\n"

                "\tTimeOut             = %08lx   NextTimeout      = %08lx\n"
                "\tBytesSent           = %d (0x%08lx)\n"

                "\tpvBuff              = %08lx   JraAsyncIo       = %08lx\n"
                "\tfConnectionIndicated= %s      fBlocked         = %8lx\n"

                "\tState               = %8lx    Flags            = %8lx\n",
                this,
                hAsyncIO,
                Signature,
                Overlapped.Internal,
                Overlapped.Offset,
                m_leTimeout.Flink,
                m_leTimeout.Blink,
                ClientContext,
                ContextList,
                pfnCompletion,
                pEndpoint,
                (IsAcceptExRootContext() ? "TRUE" : "FALSE"),
                lSyncTimeout,
                (IsFlag( ACF_IN_TIMEOUT) ? "TRUE" : "FALSE"),
                TimeOut,
                NextTimeout,
                BytesSent,
                BytesSent,
                pvBuff,
                hJraAsyncIO,
                (IsFlag( ACF_CONN_INDICATED) ? "TRUE" : "FALSE"),
                IsBlocked(),
                m_acState, m_acFlags
                ));

    // Print the buffer if necessary.

    return;
} // ATQ_CONTEXT::Print()




VOID
ATQ_CONTEXT::HardCloseSocket( VOID)
/*++
  Description:
     This socket closes the socket by forcibly calling closesocket() on
     the socket. This function is used during the endpoint shutdown
     stage for an atq context

  Arguments:
     None

  Returns:
     None

--*/
{
    HANDLE haio = (HANDLE )
        InterlockedExchangePointer( (PVOID *) &hAsyncIO, NULL);

    DBG_ASSERT( IsState( ACS_SOCK_LISTENING) ||
                IsState( ACS_SOCK_CONNECTED) ||
                IsState( ACS_SOCK_CLOSED) ||
                IsState( ACS_SOCK_UNCONNECTED)
                );

    MoveState( ACS_SOCK_CLOSED);


    //
    //  Let us do a hard close on the socket (handle).
    //  This should generate an IO completion which will free this
    //     ATQ context
    //

    if ( !this->fDatagramContext ) {
        if ( (haio != NULL) &&
             (closesocket((SOCKET) haio) == SOCKET_ERROR)
             ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "Warning - "
                         " Context=%08x closesocket failed,"
                         " error %d, socket = %x\n",
                         this,
                         GetLastError(),
                         haio ));
            Print();
        }
    }

    return;
} // ATQ_CONTEXT::HardCloseSocket()



VOID
ATQ_CONTEXT::InitWithDefaults(
    IN ATQ_COMPLETION pfnCompletion,
    IN DWORD TimeOut,
    IN HANDLE hAsyncIO
    )
{
    DBG_ASSERT( this->Signature == ATQ_CONTEXT_SIGNATURE);

    this->InitTimeoutListEntry();

    this->Signature    = ATQ_CONTEXT_SIGNATURE;

     // start life at 1. This ref count will be freed up by AtqFreeContext()
    this->m_nIO = 1;

    this->pfnCompletion   = pfnCompletion;

    this->TimeOut         = TimeOut;
    this->TimeOutScanID   = 0;
    this->lSyncTimeout    = 0;

    this->hAsyncIO        = hAsyncIO;
    this->hJraAsyncIO     = HandleToUlong(hAsyncIO) | 0x80000000;

    this->m_acState       = 0;
    this->m_acFlags       = 0;

    this->fDatagramContext  = FALSE;

    // Initialize pbandwidthinfo to point to global object

    this->m_pBandwidthInfo  = g_pBandwidthInfo;

    ZeroMemory(
               &this->Overlapped,
               sizeof( this->Overlapped )
               );

    DBG_ASSERT( this->lSyncTimeout == 0);

    //
    // Following added for bandwidth throttling purposes
    //

    DBG_ASSERT( !this->IsBlocked());
    this->arInfo.atqOp    = AtqIoNone;
    this->arInfo.lpOverlapped = NULL;
    // bandwidth throttling initialization ends here.

} // ATQ_CONTEXT::InitWithDefaults()




VOID
ATQ_CONTEXT::InitNonAcceptExState(
    IN PVOID pClientContext
    )
{
    //
    //  Note that if we're not using AcceptEx, then we consider the client
    //  to have been notified externally (thus ACF_CONN_INDICATED is set).
    //  Also we set the next timeout to be infinite, which may be reset
    //   when the next IO is submitted.
    //

    this->NextTimeout          = ATQ_INFINITE;
    this->ClientContext        = pClientContext;
    this->pEndpoint            = NULL;
    this->SetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_CONNECTED);
    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT);

    //
    // Insert this into the active list - since this is a non-acceptex socket
    //

    DBG_ASSERT( this->ContextList != NULL);
    this->ContextList->InsertIntoActiveList( &this->m_leTimeout );

    return;

} // ATQ_CONTEXT::InitNonAcceptExState()



VOID
ATQ_CONTEXT::InitAcceptExState(
            IN DWORD NextTimeOut
            )
{
    this->NextTimeout          = NextTimeOut;
    this->ClientContext        = NULL;
    this->lSyncTimeout         = 0;

    this->ResetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_LISTENING);

    //
    //  Add it to the pending accept ex list
    //
    DBG_ASSERT( this->ContextList != NULL);

    this->ContextList->InsertIntoPendingList( &this->m_leTimeout);

    return;
} // ATQ_CONTEXT::InitAcceptExState()



BOOL
ATQ_CONTEXT::PrepareAcceptExContext(
    PATQ_ENDPOINT          pEndpoint
    )
/*++

Routine Description:

    Initializes the state for completely initializing the state and
    hence prepares the context for AcceptEx

    It expects the caller to send a AtqContext with certain characteristics
      1) this is not NULL
      2) this->pvBuff has valid values

    In the case of failure, caller should call
     pAtqContext->CleanupAndRelese() to free the memory associated with
     this object.

Arguments:

    pEndpoint     - pointer to endpoint object for this context

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

    The caller should free the object on a failure.

--*/
{
    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases
    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( this != NULL);
    DBG_ASSERT( this->pvBuff != NULL);

    //
    //  Make sure that we are adding a AcceptEx() version of AtqContext
    //

    DBG_ASSERT( pEndpoint->ConnectExCompletion != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    //  Fill out the context.  We set NextTimeout to INFINITE
    //  so the timeout thread will ignore this entry until an IO
    //  request is made unless this is an AcceptEx socket, that means
    //  we're about to submit the IO.
    //

    this->
        InitWithDefaults(
                         pEndpoint->IoCompletion,
                         pEndpoint->AcceptExTimeout, // canonical Timeout
                         this->hAsyncIO
                         );


    //
    // TBD: What is the circumstance in which this->pEndpoint!= NULL?
    //

    if ( this->pEndpoint == NULL ) {
        pEndpoint->Reference();
        this->pEndpoint  = pEndpoint;
    }

    this->InitDatagramState( );

    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

    this->InitAcceptExState( AtqGetCurrentTick() + TimeOut);

    DBG_ASSERT( this->pvBuff != NULL);

    return (TRUE);

} // ATQ_CONTEXT::PrepareAcceptExContext()




VOID
ATQ_CONTEXT::CleanupAndRelease( VOID)
/*++
  Routine Description:
     This function does the cleanup of the ATQ context. It does not
     attempt to do any reuse of the atq context. After cleanup
     the context is freed to the ATQ pool. Supplied context
     is not valid after calling this function.

  Arguments:
     None

  Returns:
     None
--*/
{
    DBG_ASSERT( this->m_nIO == 0);

    //
    //  Cleanup and free the ATQ Context entirely
    //

    if ( this->hAsyncIO != NULL ) {

        // It is too dangerous to assume that the handle is a socket!
        // But we will do that for fast-pathing IIS operations.

        SOCKET hIO =
            (SOCKET ) InterlockedExchangePointer( (PVOID *) &this->hAsyncIO,
                                                  NULL);
        //
        // no cleanups for datagram
        //

        if ( !this->fDatagramContext ) {

            if ( hIO != NULL &&
                 (closesocket( hIO ) == SOCKET_ERROR ) ) {

                ATQ_PRINTF(( DBG_CONTEXT,
                             "ATQ_CONTEXT(%08x)::CleanupAndRelease() : Warning"
                             " - Context=%08x, "
                             " closesocket failed, error %d, socket = %x\n",
                             this,
                             GetLastError(),
                             hIO ));
                this->Print();
            }
        }
    }

    DBG_ASSERT( this->hAsyncIO == NULL);

    if ( this->pvBuff != NULL ) {
        LocalFree( this->pvBuff );
        this->pvBuff = NULL;
    }

    //
    // Unlink from the list
    //

    DBG_ASSERT( this->ContextList != NULL);

    // NYI: Can I avoid this comparison?
    //
    // Check if this context is part of a timeout list.
    // If it is then remove it from the list
    // Only during shutdown code path, we will see trouble here.
    //
    if ( this->m_leTimeout.Flink != NULL ) {
        this->ContextList->RemoveFromList( &this->m_leTimeout);
    }

    //
    //  Deref the listen info if this context is associated with one
    //

    if ( this->pEndpoint != NULL ) {
        this->pEndpoint->Dereference();
        this->pEndpoint = NULL;
    }

    this->Signature    = ATQ_FREE_CONTEXT_SIGNATURE;
    this->lSyncTimeout = 0;
    this->m_acState    = 0;
    this->m_acFlags    = 0;

    I_AtqFreeContextToCache( this);

    return;
} // ATQ_CONTEXT::CleanupAndRelease()





inline VOID
DBG_PRINT_ATQ_SPUDCONTEXT( IN PATQ_CONT  pAtqContext,
                           IN PSPUD_REQ_CONTEXT reqContext)
{
    ATQ_PRINTF(( DBG_CONTEXT,
                 "[AtqPoolThread] pAtqContext = %08lx\n"
                 "[AtqPoolThread] IoStatus1.Status = %08lx\n"
                 "[AtqPoolThread] IoStatus1.Information = %08lx\n"
                 "[AtqPoolThread] IoStatus2.Status = %08lx\n"
                 "[AtqPoolThread] IoStatus2.Information = %08lx\n"
                 ,
                 pAtqContext,
                 reqContext->IoStatus1.Status,
                 reqContext->IoStatus1.Information,
                 reqContext->IoStatus2.Status,
                 reqContext->IoStatus2.Information
                 ));
    return;
} // DBG_PRINT_ATQ_SPUDCONTEXT()


VOID
AtqpUpdateBandwidth( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten)
{
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    DBG_ASSERT( pBandwidthInfo != NULL );
    DBG_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    // add the bandwidth info to active list if necessary

    pBandwidthInfo->AddToActiveList();

    //this will have problems when we use XmitFile for large files.

    pBandwidthInfo->UpdateBytesXfered( pAtqContext, cbWritten );
} // AtqpUpdateBandwidth()


VOID
AtqpCallOplockCompletion( IN PATQ_CONT pAtqContext,
                          IN DWORD cbWritten)
{
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion;
    PVOID OplockContext;
    POPLOCK_INFO pOplock;

    IF_DEBUG( SPUD) {
        DBGPRINTF(( DBG_CONTEXT,
                    "CallOplockCompletion on OpLockInfo=%08x.cbWritten = %d\n",
                    (POPLOCK_INFO ) pAtqContext, cbWritten));
    }

    //
    // The ATQ context object received is a fake one. We actually get
    //  back POPLOCK_INFO object that is used to extract the callback
    //  function & context for the callback
    //

    pOplock = (POPLOCK_INFO)pAtqContext;
    pfnOplockCompletion = (ATQ_OPLOCK_COMPLETION)pOplock->pfnOplockCompletion;
    OplockContext = (PVOID)pOplock->Context;

    LocalFree(pOplock);


    (*pfnOplockCompletion)(OplockContext, (DWORD)cbWritten);
    return;

} // AtqpCallOplockCompletion()



VOID
AtqpProcessContext( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten,
                    IN LPOVERLAPPED lpo,
                    IN BOOL       fRet)
{
    BOOL fDriverCall = FALSE;
    BOOL fRecvCalled = FALSE;
    PSPUD_REQ_CONTEXT  reqContext = NULL;
    DWORD dwError;

    DBG_ASSERT( pAtqContext != NULL);

    //
    // Check to see if this is a completion request from the
    // NTS kernel driver.
    //

    if ( lpo == NULL ) {

        if ( cbWritten == 0xffffffff ) {

            //
            // One of the SPUD's IO completion. Handle it appropriately.
            //

            reqContext = (PSPUD_REQ_CONTEXT)pAtqContext;

            pAtqContext = CONTAINING_RECORD( reqContext, ATQ_CONTEXT,
                                             spudContext );

            IF_DEBUG( SPUD) {
                DBG_PRINT_ATQ_SPUDCONTEXT( pAtqContext, reqContext);
            }
#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of all non-oplock notification.
            // This is for debugging purpose only.
            //
            // Code 0xfcfcfcfc indicates a SPUD I/O Completion
            //

            pAtqContext->NotifyIOCompletion( cbWritten, reqContext->IoStatus1.Status, 0xfcfcfcfc );
#endif

            cbWritten = (DWORD)reqContext->IoStatus1.Information;
            fRet = (reqContext->IoStatus1.Status == STATUS_SUCCESS);
            SetLastError(RtlNtStatusToDosError(reqContext->IoStatus1.Status));

            lpo = &pAtqContext->Overlapped;

            //
            // If the TransmitFile fails then the receive is not issued.
            //

            if ( fRet ) {
                fDriverCall = TRUE;
            } else {
                DBG_ASSERT( fDriverCall == FALSE);
                pAtqContext->ResetFlag( ACF_RECV_ISSUED);
            }
        } else {

            //
            // An Oplock notification - handle it via oplock path.
            //

            AtqpCallOplockCompletion( pAtqContext, cbWritten);
            return;
        }
    }

    dwError = (fRet) ? NO_ERROR: GetLastError();

    //
    //  If this is an AcceptEx listen socket atq completion, then the
    //  client Atq context we really want is keyed from the overlapped
    //  structure that is stored in the client's Atq context.
    //

    if ( pAtqContext->IsAcceptExRootContext() || pAtqContext->fDatagramContext ) {

        pAtqContext = CONTAINING_RECORD( lpo, ATQ_CONTEXT, Overlapped );

    }

#if CC_REF_TRACKING
    //
    // ATQ notification trace
    //
    // Notify client context of all non-oplock notification.
    // This is for debugging purpose only.
    //

    pAtqContext->NotifyIOCompletion( cbWritten, (fRet) ? NO_ERROR: GetLastError(), 0xfefefefe );
#endif

    DBG_CODE(
             if ( ATQ_CONTEXT_SIGNATURE != pAtqContext->Signature) {
                 pAtqContext->Print();
                 DBG_ASSERT( FALSE);
             });

    //
    // Busy wait for timeout processing to complete!
    //  This is ugly :( A fix in time for IIS 2.0/Catapult 1.0 release
    //

    InterlockedIncrement(  &pAtqContext->lSyncTimeout);
    while ( pAtqContext->IsFlag( ACF_IN_TIMEOUT)) {

        AcIncrement( CacAtqWaitsForTimeout);

        Sleep( ATQ_WAIT_FOR_TIMEOUT_PROCESSING);
    };

    //
    //  We need to make sure the timeout thread doesn't time this
    //  request out so reset the timeout value
    //

    InterlockedExchange( (LPLONG )&pAtqContext->NextTimeout,
                         (LONG ) ATQ_INFINITE);

    //
    // Update Bandwidth information on successful completion, if needed
    //

    if ( BANDWIDTH_INFO::GlobalEnabled() && fRet && cbWritten > 0)
    {
        AtqpUpdateBandwidth( pAtqContext, cbWritten);
    }
    
    //
    //  Is this a connection indication?
    //

    if ( !pAtqContext->IsFlag( ACF_CONN_INDICATED) &&
         !pAtqContext->fDatagramContext ) {

        PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

        if ( NULL == pEndpoint) {
            pAtqContext->Print();
            OutputDebugString( "Found an ATQ context with bad Endpoint\n");
            DBG_ASSERT( FALSE);
            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);
            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count
            return;
        }

        DBG_ASSERT( pEndpoint != NULL );

        //
        //  Indicate this socket is in use
        //

        InterlockedDecrement( &pEndpoint->nSocketsAvail );

        //
        //  If we're running low on sockets, add some more now
        //

        if ( pEndpoint->nSocketsAvail <
             (LONG )(pEndpoint->nAcceptExOutstanding >> 2) ) {

            AcIncrement( CacAtqPrepareContexts);

            (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                pEndpoint->nAcceptExOutstanding
                                                );
        }

        //
        //  If an error occurred on this completion,
        //    shutdown the socket
        //

        if ( !fRet ) {

            IF_DEBUG( ERROR) {
                if ( dwError != ERROR_OPERATION_ABORTED ) {
                    ATQ_PRINTF(( DBG_CONTEXT,
                                 " Free Context(%08x, EP=%08x) to cache. "
                                 "Err=%d, sock=%08x\n",
                                 pAtqContext, pEndpoint,
                                 dwError,
                                 pAtqContext->hAsyncIO));
                }
            }

            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);

            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count

            // balance original count
            InterlockedDecrement( &pAtqContext->m_nIO);
            // Free up the atq context without Reuse
            pAtqContext->CleanupAndRelease();
            return;
        }

        //
        //  Shutdown may close the socket from underneath us so don't
        //  assert, just warn.
        //

        if ( !pAtqContext->IsState( ACS_SOCK_LISTENING) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] Warning-Socket state not listening\n"
                         ));
            DBG_CODE( pAtqContext->Print());
        }

        pAtqContext->MoveState( ACS_SOCK_CONNECTED);

        //
        // Remove the context from the pending list and put
        // it on the active list
        //

        DBG_ASSERT( pAtqContext->ContextList != NULL);
        pAtqContext->ContextList->MoveToActiveList( &pAtqContext->m_leTimeout);

        //
        //  Set the connection indicated flag.  After we return from
        //  the connection completion routine we assume it's
        //  safe to call the IO completion routine
        //  (or the connection indication routine should do cleanup
        //  and never issue an IO request).  This is primarily for
        //  the timeout thread.
        //

        pAtqContext->ConnectionCompletion( cbWritten, lpo);
    } else {


        //
        //  Not a connection completion indication. I/O completion.
        //

        //
        //  If an error occurred on a TransmitFile (or other IO),
        //  set the state to connected so the socket will get
        //  closed on cleanup
        //

        if ( !fRet &&
             pAtqContext->IsState( ACS_SOCK_UNCONNECTED)
             ){
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

#if 0
        if (fDriverCall) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] pfnCompletion1(%08lx)\n",
                         pAtqContext ));
        }
#endif

        //
        // !!! DS
        // Indicate that we have completed a datagram context
        //

        if ( !pAtqContext->IsFlag( ACF_CONN_INDICATED) ) {

            PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

            pAtqContext->SetFlag( ACF_CONN_INDICATED);
            if ( pEndpoint != NULL ) {

                ATQ_ASSERT(pAtqContext->fDatagramContext);

                //
                // Decrement the in-use count here for
                //

                InterlockedDecrement( &pEndpoint->nSocketsAvail );

                //
                //  If we're running low on sockets, add some more now
                //

                if ( pEndpoint->nSocketsAvail <
                     (LONG )(pEndpoint->nAcceptExOutstanding >> 2) ) {

                    (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                        pEndpoint->nAcceptExOutstanding
                                                        );
                }
            }
            if (pAtqContext->IsBroadcast()) {
                ATQ_PRINTF((DBG_CONTEXT, "Ignoring broadcast recv.\n"));
                goto exit;
            }
        }

        pAtqContext->IOCompletion( cbWritten, dwError, lpo);

        if (fDriverCall) {
            pAtqContext->ResetFlag( ACF_RECV_ISSUED);
            fRet = (reqContext->IoStatus2.Status == STATUS_SUCCESS);
            SetLastError( RtlNtStatusToDosError(
                                         reqContext->IoStatus2.Status));

            //
            //  If an error occurred on a TransmitFile (or other IO),
            //  set the state to connected so the socket will get
            //  closed on cleanup
            //

            if ( !fRet &&
                 pAtqContext->IsState( ACS_SOCK_UNCONNECTED) ) {
                pAtqContext->MoveState( ACS_SOCK_CONNECTED);
            }

#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of status after 1st notification
            // This is for debugging purpose only.
            //
            // Code 0xfafafafa means we're processing a recv that
            // SPUD combined with another notification
            //

            pAtqContext->NotifyIOCompletion( pAtqContext->m_acFlags, reqContext->IoStatus1.Status, 0xfafafafa );
#endif
            if ( pAtqContext->IsFlag( ACF_RECV_CALLED ) ) {
                fRecvCalled = TRUE;
                pAtqContext->ResetFlag( ACF_RECV_CALLED);
            }

            if ((reqContext->IoStatus1.Status == STATUS_SUCCESS) &&
                (pAtqContext->ClientContext != NULL) &&
                fRecvCalled ) {

#if CC_REF_TRACKING
                //
                // ATQ notification trace
                //
                // Notify client context of all non-oplock notification.
                // This is for debugging purpose only.
                //
                // Code 0xfdfdfdfd means we're processing a recv that
                // SPUD combined with another notification
                //

                pAtqContext->NotifyIOCompletion( cbWritten, (fRet) ? NO_ERROR: GetLastError(), 0xfdfdfdfd );
#endif


                IF_DEBUG( SPUD) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqPoolThread] pfnCompletion2(%08lx)\n",
                                 pAtqContext ));
                };

                pAtqContext->IOCompletion( (DWORD)reqContext->IoStatus2.Information,
                                        (fRet) ? NO_ERROR : GetLastError(),
                                        lpo
                                        );
            }
        }
    }

exit:

    DBG_ASSERT( pAtqContext->lSyncTimeout > 0);
    InterlockedDecrement( &pAtqContext->lSyncTimeout);

    //
    // We do an interlocked decrement on m_nIO to sync up state
    //  so that the context is not prematurely deleted.
    //

    if ( InterlockedDecrement(  &pAtqContext->m_nIO) == 0) {

        //
        // The number of outstanding ref holders is ZERO.
        // Free up this ATQ context.
        //
        // We really do not free up the context - but try to reuse
        //  it if possible
        //

        // free the atq context now or reuse if possible.
        AtqpReuseOrFreeContext( pAtqContext,
                                (pAtqContext->
                                 IsFlag( ACF_REUSE_CONTEXT) != 0)
                                );
    }

    return;
} // AtqpProcessContext()


DWORD
AtqPoolThread(
    LPDWORD ThreadType
    )
/*++

Routine Description:

    This is the pool thread wait and dispatch routine

  Arguments:
    ThreadType : Indicates whether this is the initial pool thread,
    a temp thread, or just a joe blow pool thread.

  Return Value:

    Thread return value (ignored)

--*/
{
    PATQ_CONT    pAtqContext;
    BOOL         fRet;
    LPOVERLAPPED lpo;
    DWORD        cbWritten;
    DWORD        returnValue = NO_ERROR;
    DWORD        availThreads;
    DWORD        dwIOsServiced;


    AtqUpdatePerfStats(AtqConsumerAtq, FLAG_COUNTER_SET, g_cThreads);

    for (;;) {

        pAtqContext = NULL;
        InterlockedIncrement( &g_cAvailableThreads );

        fRet = GetQueuedCompletionStatus( g_rghCompPort[ NtCurrentTeb()->IdealProcessor ],
                                          &cbWritten,
                                          (PDWORD_PTR)&pAtqContext,
                                          &lpo,
                                          g_msThreadTimeout );

        availThreads = InterlockedDecrement( &g_cAvailableThreads );

        if ( fRet || lpo ) {

            if ( pAtqContext == NULL) {
                if ( g_fShutdown ) {

                    //
                    // This is our signal to exit.
                    //

                    returnValue = NO_ERROR;
                    break;
                }

                OutputDebugString( "A null context received\n");
                continue;  // some error in the context has occured.
            }

            //
            // Make sure we're not running out of threads
            //

            if ( availThreads == 0 ) {

                //
                //  Make sure there are pool threads to service the request
                //

                (VOID)I_AtqCheckThreadStatus( NULL );
            }

            AtqpProcessContext( pAtqContext, cbWritten, lpo, fRet);

            // Clear the dead man switch
            g_fDeadManSwitch = FALSE;
        } else {

            //
            // don't kill the initial thread
            //

            if ( ((DWORD_PTR)ThreadType == ATQ_INITIAL_THREAD) && !g_fShutdown ) {
                continue;
            }

            //
            //  An error occurred.  Either the thread timed out, the handle
            //  is going away or something bad happened.  Let the thread exit.
            //

            returnValue = GetLastError();

            break;
        }

    } // for

    if ( NULL != g_pfnExitThreadCallback) {

        //
        //  Client wishes to be told when ATQ threads terminate.
        //

        g_pfnExitThreadCallback();
    }

    if ( InterlockedDecrement( &g_cThreads ) == 0 ) {

        //
        // Wake up ATQTerminate()
        //
        IF_DEBUG( ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqPoolThread() - setting shutdown event %08x."
                         " g_cThreads = %d\n",
                         g_hShutdownEvent, g_cThreads
                         ));
        }

        SetEvent( g_hShutdownEvent );
    }

    AtqUpdatePerfStats(AtqConsumerAtq, FLAG_COUNTER_SET, g_cThreads);

    return returnValue;
} // AtqPoolThread




BOOL
I_AtqCheckThreadStatus(
    PVOID Context
    )
/*++

Routine Description:

    This routine makes sure there is at least one thread in
    the thread pool.  We're fast and loose so a couple of extra
    threads may be created.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    BOOL fRet = TRUE;

    //
    //  If no threads are available, kick a new one off up to the limit
    //
    //  WE NEED TO CHANGE THE CONDITIONS FOR STARTING ANOTHER THREAD
    //  IT SHOULD NOT BE VERY EASY TO START A THREAD ....
    //

    if ( (g_cAvailableThreads == 0) &&
         (g_cThreads < g_cMaxThreads) &&
         (g_cThreads < g_cMaxThreadLimit) ) {

        HANDLE hThread;
        DWORD  dwThreadID;

        InterlockedIncrement( &g_cThreads );

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqPoolThread,
                                Context,
                                0,
                                &dwThreadID );

        if ( hThread ) {
            CloseHandle( hThread );     // Free system resources
        } else {

            //
            // We fail if there are no threads running
            //

            if ( InterlockedDecrement( &g_cThreads ) == 0) {
                ATQ_PRINTF(( DBG_CONTEXT,
                    "AtqCheckThread: Cannot create ATQ threads\n"));
                fRet = FALSE;
            }
        }
    }

    return fRet;
} // I_AtqCheckThreadStatus()



/************************************************************
 *  Functions to Add/Delete Atq Contexts
 ************************************************************/


BOOL
I_AtqAddAsyncHandle(
    IN OUT PATQ_CONT  *    ppAtqContext,
    IN PATQ_ENDPOINT       pEndpoint,
    PVOID                  ClientContext,
    ATQ_COMPLETION         pfnCompletion,
    DWORD                  TimeOut,
    HANDLE                 hAsyncIO
    )
/*++

  Description:
    This functio adds creates a new NON-AcceptEx() based Atq Context,
     and includes it in proper lists fo ATQ Context management.


  Note:
    The client should call this after the IO handle is openned
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

--*/
{
    BOOL         fReturn = TRUE;

    DBG_ASSERT( ppAtqContext != NULL);
    DBG_ASSERT( ClientContext != NULL);

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        PATQ_CONT    pAtqContext;

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();
        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.  We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.
        //


        pAtqContext->InitWithDefaults(pfnCompletion,
                                      CanonTimeout( TimeOut ), hAsyncIO);

        //
        //  These data members are used if we're doing AcceptEx processing
        //

        pAtqContext->SetAcceptExBuffer( NULL);

        pAtqContext->InitNonAcceptExState(ClientContext);

        //
        // If an endpoint is provided, reference it
        //

        if ( pEndpoint != NULL ) {
            pEndpoint->Reference();
            pAtqContext->pEndpoint = pEndpoint;
        }

        *ppAtqContext = pAtqContext;
    }

    return (TRUE);

} // I_AtqAddAsyncHandle()




BOOL
I_AtqAddListenEndpointToPort(
    IN OUT PATQ_CONT    * ppAtqContext,
    IN PATQ_ENDPOINT    pEndpoint
    )
/*++

  Description:
    This function creates a new AtqContext for the given ListenSocket.
    It uses the listen socket as the AcceptEx() socket too for adding
     the atq context to the completion port.
    It assumes
      TimeOut to be INFINITE, with no Endpoint structure.

  Arguments:
    ppAtqContext - pointer to location that will contain the atq context
                   on successful return.
    pEndpoint - pointer to the endpoint.

  Returns:
    TRUE on success
    FALSE if there is a failure.

  Note:
    The caller should free the *ppAtqContext if there is a failure.

--*/
{
    BOOL         fReturn = TRUE;
    PATQ_CONT    pAtqContext;

    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();

        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.
        //  We set the TimeOut for this object to be ATQ_INFINITE,
        //   since we do not want any interference from the Timeout loop.
        //

        pAtqContext->InitWithDefaults(
                                      pEndpoint->IoCompletion,
                                      ATQ_INFINITE,
                                      (HANDLE)pEndpoint->ListenSocket
                                      );

        //
        //  These data members are used if we're doing AcceptEx processing
        //


        pAtqContext->SetAcceptExBuffer( NULL);

        //
        // Among AcceptEx ATQ Contexts,
        //  only the listen ATQ context will have the Endpoint field as NULL
        //
        pAtqContext->pEndpoint       = NULL;
        pAtqContext->SetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

        //
        // We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.

        DBG_ASSERT( g_fUseAcceptEx && pEndpoint->ConnectExCompletion != NULL);

        pAtqContext->InitAcceptExState( ATQ_INFINITE);

        *ppAtqContext = pAtqContext;
    }

    fReturn = I_AddAtqContextToPort( pAtqContext);

    return (fReturn);

} // I_AtqAddListenEndpointToPort()



BOOL
I_AtqAddAcceptExSocket(
    IN PATQ_ENDPOINT          pEndpoint,
    IN PATQ_CONT              pAtqContext
    )
/*++

Routine Description:

    Adds the AtqContext to the AcceptEx() waiters list,
    after allocating a new socket, since pAtqContext->hAsyncIO = NULL.

Arguments:

    pEndpoint - Information about this listenning socket
    patqReusedContext - optional context to use

Return Value:

    TRUE on success, FALSE on failure.
    On failure the caller should free the pAtqContext

--*/
{
    BOOL   fAddToPort = FALSE;
    BOOL   fSuccess = TRUE;

    DBG_ASSERT( pAtqContext != NULL);
    DBG_ASSERT( pAtqContext->pvBuff != NULL);
    DBG_ASSERT( !TsIsWindows95() );

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        SetLastError( ERROR_NOT_READY );
        return ( FALSE);
    }

    //
    //  Use the supplied socket if any.
    //  Otherwise create a new socket
    //

    if ( pAtqContext->hAsyncIO == NULL) {

        HANDLE sAcceptSocket;

        sAcceptSocket = (HANDLE )
#if WINSOCK11
            socket(
                   AF_INET,
                   SOCK_STREAM,
                   IPPROTO_TCP
                   );
#else
        WSASocketW(
                   AF_INET,
                   SOCK_STREAM,
                   IPPROTO_TCP,
                   NULL,  // protocol info
                   0,     // Group ID = 0 => no constraints
                   (g_fUseFakeCompletionPort ?
                    0:
                    WSA_FLAG_OVERLAPPED // completion port notifications
                    )
                   );
#endif // WINSOCK11

        if ( (SOCKET ) sAcceptSocket == INVALID_SOCKET ) {

            fSuccess = FALSE;
            sAcceptSocket = NULL;

            //
            // no need to unlink from any list, since we did not add it to any
            //

        } else {

            //
            // Setup the accept ex socket in the atq context.
            //

            pAtqContext->hAsyncIO = sAcceptSocket;
            pAtqContext->hJraAsyncIO  = HandleToUlong(sAcceptSocket) | 0x80000000;
            fAddToPort = TRUE;
            DBG_ASSERT( fSuccess);
        }
    }

    if ( fSuccess) {

        DWORD        cbRecvd;

        if ( g_fShutdown) {

            //
            // no need to unlink from any list, since we did not add it to any
            //

            SetLastError( ERROR_NOT_READY);
            return (FALSE);
        }

        DBG_ASSERT( pAtqContext->hAsyncIO != NULL);

        //
        // 1. Call I_AtqAddAsyncHandleEx() to establish the links with
        //  proper AcceptEx & AtqContext processing lists.
        //
        //  After 1, the atqcontext will be in the lists, so
        //    cleanup should remove the context from proper lists.
        //
        // 2. Add the socket to Completion Port (if new),
        //    i.e. if fAddToPort is true)
        //
        // 3. Submit the new socket to AcceptEx() so that it may be
        //  used for processing about the new connections.
        //

        // 1.
        DBG_ASSERT( pAtqContext->m_nIO == 0);
        DBG_REQUIRE( pAtqContext->PrepareAcceptExContext(pEndpoint));

        // increment outstanding async io operations before AcceptEx() call
        InterlockedIncrement( &pAtqContext->m_nIO);

        // 2.
        if ( fAddToPort ) {
            ATQ_ASSERT(!pAtqContext->fDatagramContext);
            fSuccess = I_AddAtqContextToPort( pAtqContext);
        }
        // 3.
        if (fSuccess) {
            if (!pEndpoint->fDatagram) {
                 fSuccess = g_pfnAcceptEx(
                                (SOCKET ) pEndpoint->ListenSocket,
                                (SOCKET ) pAtqContext->hAsyncIO,
                                pAtqContext->pvBuff,
                                pEndpoint->InitialRecvSize,
                                MIN_SOCKADDR_SIZE,
                                MIN_SOCKADDR_SIZE,
                                &cbRecvd,
                                &pAtqContext->Overlapped );

                 if (!fSuccess) {
                     fSuccess = (GetLastError() == ERROR_IO_PENDING);
                 }

            } else {

                int RetCode = 0;
                DWORD retry=0;

                //
                // For datagram, do a WSARecvFrom instead of AcceptEx.
                // All the output parameters have to be in the context
                // structure
                //

                for (;;) {

                    if (g_bUseRecvMsg) {
                    
                        RetCode = g_pfnWSARecvMsg(
                            (SOCKET) pAtqContext->hAsyncIO,
                            &pAtqContext->WsaMsg,
                            &cbRecvd,
                            &pAtqContext->Overlapped,
                            NULL
                            );

                    } else {
                        WSABUF Buffer;
                        DWORD lpFlags;

                        lpFlags = 0;
                        Buffer.len = pEndpoint->InitialRecvSize;
                        Buffer.buf = (char *) pAtqContext->pvBuff;

                        RetCode = WSARecvFrom(
                            (SOCKET) pAtqContext->hAsyncIO,
                            &Buffer,
                            1,                          // buffer count
                            &cbRecvd,
                            &lpFlags,
                            (PSOCKADDR) pAtqContext->AddressInformation,
                            &pAtqContext->AddressLength,
                            &pAtqContext->Overlapped,
                            NULL
                            );

                    }

                    //
                    // If this is a conn reset, then retry until we
                    // don't get this error anymore.  It looks like we
                    // get this everytime someone sends us something and
                    // then shuts down the socket before we can respond.
                    // The sockets layer seems to give us a max of 160 of
                    // these at a time, but for now retry infinitely since
                    // we don't know what this 160 is based on.
                    // RRandall - 7/16/99
                    //

                    if ( (RetCode == 0) ||
                         (WSAGetLastError() != WSAECONNRESET) ||
                         (!IS_BLOCK_ACTIVE(pEndpoint))) {
                        break;
                    }

                    ATQ_PRINTF((DBG_CONTEXT,"AtqRecvFrom[%x] reset error. Retrying[%d]\n",
                                pAtqContext, retry));
                    retry++;
                }

                if (RetCode != 0) {

                    fSuccess = (WSAGetLastError() == ERROR_IO_PENDING);
                }
            }
        }

        if ( fSuccess) {

            //
            //  We've successfully added this socket, increment the count
            //

            InterlockedIncrement( &pEndpoint->nSocketsAvail );

        } else {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqAddAcceptExSocket] Reusing an old context (%08x)"
                        " failed; error %d:%d, sAcceptSocket = %x, "
                        " pEndpoint = %lx, parm4 = %d, parm7 = %lx,"
                        " parm8 = %lx\n",
                        pAtqContext,
                        GetLastError(),
                        WSAGetLastError(),
                        pAtqContext->hAsyncIO,
                        pEndpoint,
                        pEndpoint->InitialRecvSize,
                        &cbRecvd,
                        &pAtqContext->Overlapped ));

            //
            // Unlink from the current list, where it was added as a result of
            //  step 1 above.
            //
            DBG_ASSERT( pAtqContext->ContextList != NULL);

            // balance the increment of the async operations outstanding
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) > 0);

            DBG_ASSERT( pAtqContext->m_leTimeout.Flink != NULL);
            pAtqContext->ContextList->
                RemoveFromList( &pAtqContext->m_leTimeout);

            //
            // balance the increment done
            // by pAtqContext->PrepareAcceptExContext()
            //
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) == 0);
            DBG_ASSERT( !fSuccess);

            //
            // the caller will free the Atq context on failure
            //
        }
    }

    return ( fSuccess);
} // I_AtqAddAcceptExSocket()




VOID
AtqpReuseContext( PATQ_CONT  pAtqContext)
/*++
  Description:
     This function attempts to reuse the ATQ context.
     It first cleans up the state and then uses the function
      I_AtqAddAccetpEx() socket to re-add the context to acceptex pool

  Arguments:
     pAtqContext - pointer to ATQ context that can be reused

  Returns:
     None
--*/
{
    PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    // Complete connection has been processed prior to coming here
    //

    DBG_ASSERT(pAtqContext->IsFlag( ACF_CONN_INDICATED));

    //
    // Remove from the current active list
    //
    if ( pAtqContext->m_leTimeout.Flink != NULL ) {
        pAtqContext->ContextList->RemoveFromList( &pAtqContext->m_leTimeout );
    }

    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);

    DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        //
        //  Either there is no socket or the socket must be in the
        //  unconnected state (meaning reused after TransmitFile)
        //


    DBG_ASSERT( !pAtqContext->hAsyncIO ||
                (  pAtqContext->hAsyncIO &&
                  (  pAtqContext->fDatagramContext ||
                     pAtqContext->IsState( ACS_SOCK_UNCONNECTED |
                                           ACS_SOCK_TOBE_FREED)
                  )
                )
              );

    //
    // !! DS
    //

    if ( pAtqContext->fDatagramContext ) {

        DBG_ASSERT(pEndpoint->fDatagram);
        pAtqContext->hAsyncIO = (HANDLE)pEndpoint->ListenSocket;
    }

    //
    // I need to make sure that the state information is cleaned up
    //  before re-adding the context to the list
    //

    if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

        //
        //  Failed to add the socket, free up the context without reuse
        //

        ATQ_PRINTF(( DBG_CONTEXT,
                     "[AtqpReuseContext] for (%08x) failed with "
                     " Error = %d;  Now freeing the context ...\n",
                     pAtqContext, GetLastError()
                     ));

        DBG_ASSERT( pAtqContext->m_nIO == 0);

        // free without reuse
        pAtqContext->CleanupAndRelease();
    }

    return;
} // AtqpReuseContext()



VOID
AtqpReuseOrFreeContext(
    PATQ_CONT    pAtqContext,
    BOOL         fReuseContext
    )
/*++
  Routine Description:
     This function does a free-up of the ATQ contexts. During the free-up
     path, we also attempt to reuse the ATQ context if the fReuseContext is
     set.

  Arguments:
     pAtqContext - pointer to the ATQ context that needs to be freedup
     fReuseContext - BOOLEAN flag indicating if this context should be reused

  Returns:
     None
--*/
{
    //
    // Get this object out of the Blocked Requests List.
    //

    if ( pAtqContext->IsBlocked()) {
        ATQ_REQUIRE( pAtqContext->m_pBandwidthInfo
                      ->RemoveFromBlockedList( pAtqContext ));
        DBG_ASSERT( !pAtqContext->IsBlocked());
    }

    DBG_ASSERT( pAtqContext->m_pBandwidthInfo != NULL);
    pAtqContext->m_pBandwidthInfo->Dereference();

    //
    //  Conditions for Reuse:
    //   1) fReuseContext == TRUE => caller wants us to reuse context
    //   2) pAtqContext->pEndpoint != NULL => valid endpoint exists
    //   3)  pEndpoint->UseAcceptEx => AcceptEx is enabled
    //   4)  pEndpoint->nSocketsAvail < nAcceptExOutstanding * 2 =>
    //           We do not have lots of outstanding idle sockets
    //       Condition (4) ensures that we do not flood the system
    //         with too many AcceptEx sockets as a result of some spike.
    //       AcceptEx sockets once added to the pool are hard to
    //         remove, because of various timing problems.
    //       Hence we want to prevent arbitrarily adding AcceptEx sockets.
    //
    //    In condition (4) I use a fudge factor of "2", so that
    //     we do continue to prevent reuse of sockets prematurely.
    //

    if ( fReuseContext &&
         (pAtqContext->pEndpoint != NULL)  &&
         (pAtqContext->pEndpoint->UseAcceptEx)
#ifdef ENABLE_REUSE_THROTTLE
         //
         // Reuse Throttle causes trouble in bursty traffic mode
         // especially with benchmarks like SpecWeb96
         //
         &&
         ( g_fAlwaysReuseSockets ||
           ((DWORD )pAtqContext->pEndpoint->nSocketsAvail <
            pAtqContext->pEndpoint->nAcceptExOutstanding * 2)
           )
#endif // ENABLE_REUSE_THROTTLE
         ) {

        //
        // Call the function to reuse context. On failure
        // the AtqpReuseContext will free up the context
        //

        AcIncrement( CacAtqContextsReused);

        AtqpReuseContext( pAtqContext);

    } else {

        AcIncrement( CacAtqContextsCleanedup);

        pAtqContext->CleanupAndRelease();

    }

    return;
} // AtqpReuseOrFreeContext()



BOOL
I_AtqPrepareAcceptExSockets(
    IN PATQ_ENDPOINT          pEndpoint,
    IN DWORD                  nSockets
    )
/*++

Routine Description:

    Prepare specified number of AcceptEx sockets for the given
      ListenSocket in [pEndpoint]

Arguments:

    pEndpoint - Information about this listenning socket
    nSockets    - number of AcceptEx() sockets to be created.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL   fReturn;
    DWORD  cbBuffer;
    DWORD  i;
    DWORD  dwRetryLimit;
    DWORD  dwRetryCount;

    if ( !g_fUseAcceptEx ) {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( pEndpoint->State != AtqStateActive ) {
        SetLastError( ERROR_NOT_READY );
        return(FALSE);
    }

    if ( pEndpoint->fAddingSockets) {
        //
        // Someone is already adding sockets. Do not add more
        // Just return success
        //
        return ( TRUE);
    }

    pEndpoint->fAddingSockets = TRUE;

    // calculate the buffer size
    cbBuffer = GET_ALIGNED_LENGTH64(pEndpoint->InitialRecvSize) + 2* MIN_SOCKADDR_SIZE;

    for ( fReturn = TRUE, i = 0 ; fReturn && i++ < nSockets; ) {

        PVOID        pvBuff;
        PATQ_CONT    pAtqContext;

        //
        //  Alloc a buffer for receive data
        //  TBD: Pool all these buffers into one large buffer.
        //

        pvBuff = LocalAlloc( LPTR, cbBuffer);

        //
        //  Get the ATQ context now because we need its overlapped structure
        //

        pAtqContext = I_AtqAllocContextFromCache();


        //
        // Now check if allocations are valid and do proper cleanup on failure
        //

        if ( pvBuff == NULL || pAtqContext == NULL) {

            if ( pvBuff ) {
                LocalFree( pvBuff );
                pvBuff = NULL;
            }

            if ( pAtqContext ) {
                I_AtqFreeContextToCache( pAtqContext );
                pAtqContext = NULL;
            }

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            fReturn = FALSE;
            break;
        } else {

            //
            // Add this socket to AtqContext lists & completion ports
            // From now on the called function will take care of freeing up
            //  pAtqContext, if there is a failure.
            //

            pAtqContext->SetAcceptExBuffer( pvBuff);
            if ( pEndpoint->fDatagram ) {
                pAtqContext->hAsyncIO = (HANDLE)pEndpoint->ListenSocket;
            } else {
                pAtqContext->hAsyncIO = NULL;
            }
            pAtqContext->hJraAsyncIO = 0;

            //
            // We need to try harder with datagram sockets since they
            // are less robust, so retry the operation a few times.
            //
            dwRetryLimit = pEndpoint->fDatagram ? 100 : 1;

            // assume failure.
            fReturn = FALSE;
            for (dwRetryCount = 0; dwRetryCount < dwRetryLimit && !fReturn; dwRetryCount++) {
                if (I_AtqAddAcceptExSocket(pEndpoint, pAtqContext)) {
                    // success - exit the loop
                    fReturn = TRUE;
                } else if (IS_BLOCK_ACTIVE(pEndpoint) && pEndpoint->fDatagram) {
                    // failure, but this is an active datagram endpoint so
                    // retry
                    Sleep(100);
                } else {
                    // just plain failure, bail and free up the context.
                    break;
                }
            }
            if (!fReturn) {
                //
                //  Failed to add the socket, free up the context without reuse
                //

                ATQ_PRINTF(( DBG_CONTEXT,
                             "[I_AtqPrepareAcceptExSockets] for Endpoint %08x"
                             " and AtqContext (%08x) failed with "
                             " Error = %d;  Now freeing the context ...",
                             pEndpoint, pAtqContext, GetLastError()
                           ));

                // free without reuse
                DBG_ASSERT( pAtqContext->m_nIO == 0);
                pAtqContext->CleanupAndRelease();
            }
        }
    } // for

    //
    // Finished Adding sockets. Indicate that by resetting the flab
    //

    pEndpoint->fAddingSockets = FALSE;

    ATQ_PRINTF(( DBG_CONTEXT,
                "PrepareAcceptExSockets( Endpoint[%08x], nSockets = %d)==>"
                " avail = %d; Total Refs = %d.\n",
                pEndpoint,
                nSockets,
                pEndpoint->nSocketsAvail,
                pEndpoint->m_refCount
                ));

    return ( fReturn);

} // I_AtqPrepareAcceptExSockets()


BOOL
I_AtqStartThreadMonitor(
    VOID
    )
/*++

Routine Description:

    Adds the ThreadMonitor function to the scheduler.

    Note: The scheduler should be initialized before getting to this function.

Arguments:

    None.

Return Value:

    TRUE if successful, FALSE on error

--*/
{

    g_dwThreadMonitorCookie =
        ScheduleWorkItem(
                         (PFN_SCHED_CALLBACK)I_AtqThreadMonitor,
                         NULL, // No need for a context
                         TimeToWait(ATQ_THREAD_MONITOR_PERIOD),
                         TRUE  // ask for periodic timeout
                         );

    if ( g_dwThreadMonitorCookie == 0 ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Error %d scheduling ThreadMonitor\n",GetLastError()));
        return(FALSE);
    }

    return(TRUE);
}



BOOL
I_AtqStopThreadMonitor(
    VOID
    )
/*++

Routine Description:

    Removes the ThreadMonitor function from the scheduler.

    Note: The scheduler should be initialized before getting to this function.

Arguments:

    None.

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( 0 != g_dwThreadMonitorCookie) {
        DBG_REQUIRE( RemoveWorkItem( g_dwThreadMonitorCookie ));
        g_dwThreadMonitorCookie = 0;
    }

    return ( TRUE);
}


VOID
I_AtqThreadMonitor(
    IN PVOID NotUsed
    )
/*++

Routine Description:

    Checks to see whether the AtqPoolThreads have stalled out for longer than
    ATQ_THREAD_MONITOR_PERIOD, and if so starts up a temporary AtqPoolThread.
    This is to prevent deadlocks due to all the atq threads being used by
    processes that are trying to call a network service on this same machine
    that also used atq.

Arguments:

    NotUsed - This argument is only here because sheduler callback functions
    require a PVOID argument.  It is not actually used in the body of the
    function.

Return Value:

    None.

--*/
{
    HANDLE  hThread;
    DWORD   dwThreadID;

    if (!g_fDeadManSwitch || 0 != g_cAvailableThreads) {
        // The switch has been cleared since
        // the last time or there are still available threads, the AtqPoolThreads
        // must not be stuck.
        g_fDeadManSwitch = TRUE;
        return;
    }

    ATQ_ASSERT( ATQ_REG_MAX_POOL_THREAD_LIMIT > g_cThreads );

    if ( ATQ_REG_MAX_POOL_THREAD_LIMIT > g_cThreads ) {
        // There are no free threads and there hasn't been any
        // for ATQ_THREAD_MONITOR_PERIOD.  Start up a temporary
        // thread to service calls until hopefully the rest of
        // the threads make some progress.
        ATQ_PRINTF(( DBG_CONTEXT, "AtqThreadMonitor: Starting a new thread.\n"));

        InterlockedIncrement( &g_cThreads );

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqPoolThread,
                                (PVOID)UIntToPtr(ATQ_TEMP_THREAD),  // Let the thread know that it is temporary.
                                0,
                                &dwThreadID );

        if ( hThread ) {
            CloseHandle( hThread );     // Free system resources
        } else {
            InterlockedDecrement( &g_cThreads );
            ATQ_PRINTF(( DBG_CONTEXT,
                "AtqThreadMonitor: Unable to create a temp thread.\n"));
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\acache.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       acache.cxx

   Abstract:
       This module implements the Allocation cache handler and associated
        objects.

   Author:

       Murali R. Krishnan    ( MuraliK )     12-Sept-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <isatq.hxx>
# include "acache.hxx"
# include "dbgutil.h"

// 
// # of CPUs in machine (for allocation threshold scaling)
// 
DWORD g_cCPU = 0;

//
// specifies the registry location to use for getting the ATQ Configuration
//   (Global overrides)
//
CHAR g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY[] =
 TEXT("System\\CurrentControlSet\\Services\\InetInfo\\Parameters");


//
// Lookaside cleanup interval
//

#define ACACHE_REG_LOOKASIDE_CLEANUP_INTERVAL \
                     TEXT( "LookasideCleanupInterval" )
#define ACACHE_REG_DEFAULT_CLEANUP_INTERVAL              ((15)*(60))

/************************************************************
 *    Inlined Documentation on Alloc-Cache
 *
 * Allocation Cache:
 *    This module is to cache the commonly allocated objects
 *    to serve following goals 
 *      1) we can have maximum reuse of blocks
 *      2) avoid traffic to the process heap manager
 *      3) gather statistics for understanding of usage
 *
 * Details on Allocation Cache:
 *   There is one ALLOC_CACHE_HANDLER (shortly ACH) object per 
 *   object that we decide to cache. The ACH is initialized by
 *   the configuration supplied during its construction. ACH serves
 *   as the main object for allocation/free of the objects it is created
 *   to cache. ACH gathers statistics of various operations and provides
 *   hooks to export the gathered statistics. There is a periodic cleanup
 *   scavenger that frees up long unused blocks thus reducing the working
 *   set of the system.
 *
 *   All ACH objects created are chained and maintained in the global
 *   list of allocation cache handler objects. This global list is used
 *   for enumeration, debugging, and statistics dumps
 *   
 * Allocation cache Configuration:
 * 
 *   Each ACH object is created with the ALLOC_CACHE_CONFIGURATION that
 *   specifies the (concurrency factor, threshold, size) desired.
 *   The concurrency factor ensures that we support the specified level 
 *   of concurrency in allocations. The threshold specifies the number 
 *   of objects that we will maintain (max) in the free-list. When the
 *   threshold is exceeded the freed objects are pushed to the process
 *   pool until the currently active objects fall below the threshold.
 *   In addition, each ACH object also retains a read-only name for the
 *   object allocated - for friendly tracking purposes.
 *
 *   There is also a global configuration parameter that specifies the 
 *   Lookaside cleanup interval. 
 *
 * Allocation and Free:
 *   Allocation allocates one free object from the free-list if any exist.
 *   Otherwise the allocation will result in fetching a new object from
 *   the process heap manager.
 *   A free adds the freed object to the free-list if the # free objects
 *   is less than the threshold specified. Otherwise the object is freed
 *   to the process heap manager.
 *   Statistics are gathered during both allocation and free operations.
 *
 * Statisitcs:
 *   Statistics are gathered during the alloc/free operations throughout
 *   the life-time of the ACH. These statistics are reported via the 
 *   DumpStatsToHtml() exported function. The statistics can also be 
 *   gathered by the NTSD helper function.
 *
 * Scheduled List cleanup:
 *   There is a scheduled work item for the lookaside cleanup interval. 
 *   The callback function walks through the list of ACH items on global
 *   list and takes snapshot of the # allocation calls. On a subsequent
 *   walk-through, if the # allocation calls remains the same (which will
 *   be the case if there is no allocation activity), then, the entire
 *   list of alloced objects is pruned. This pruning reduces the working
 *   set of the process.
 ************************************************************/

/************************************************************
 *    Static Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

CRITICAL_SECTION ALLOC_CACHE_HANDLER::sm_csItems;
LIST_ENTRY       ALLOC_CACHE_HANDLER::sm_lItemsHead;
DWORD            ALLOC_CACHE_HANDLER::sm_dwScheduleCookie;

/* class static */
BOOL
ALLOC_CACHE_HANDLER::Initialize(VOID)
{
    // get the number of processors for this machine
    // do it only for NT Server only (don't scale workstation)
    if ( TsIsNtServer() ) {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        g_cCPU = si.dwNumberOfProcessors;
    } else {
        g_cCPU = 1;
    }

    // initialize the class statics
    InitializeListHead( &sm_lItemsHead);
    InitializeCriticalSection( &sm_csItems);
    SET_CRITICAL_SECTION_SPIN_COUNT( &sm_csItems, IIS_DEFAULT_CS_SPIN_COUNT);
    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Initialize()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::Cleanup(VOID)
{
    DBG_ASSERT( sm_dwScheduleCookie == 0);

    DBG_ASSERT( IsListEmpty(&sm_lItemsHead));
    DeleteCriticalSection( &sm_csItems);

    return ( TRUE);

} // ALLOC_CACHE_HANDLER::Cleanup()


/* class static */
VOID
ALLOC_CACHE_HANDLER::InsertNewItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    InsertTailList( &sm_lItemsHead, &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::InsertNewItem()



/* class static */
VOID
ALLOC_CACHE_HANDLER::RemoveItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    RemoveEntryList( &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::RemoveItem()



/* class static */
BOOL
ALLOC_CACHE_HANDLER::DumpStatsToHtml(
   OUT CHAR * pchBuffer,
   IN OUT LPDWORD lpcchBuffer )
/*++
  Description:
    This function dumps the stats on all allocation cached objects
     to HTML format for diagnostics

  Arguments:
    pchBuffer - pointer to buffer that will contain the html results
    lpcchBuffer - pointer to DWORD containing the size of buffer on entry
               On return this contains the # of bytes written out to buffer

  Return:
    TRUE for success and FALSE for failure
    Look at GetLastError() for the error code.
--*/
{
    LIST_ENTRY  * pEntry;
    DWORD  iCount, cch;
    DWORD  cbTotalMem = 0;
    BOOL   fRet = TRUE;

    if ( (lpcchBuffer == NULL) ) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    EnterCriticalSection( &sm_csItems);

    if ( 300 < *lpcchBuffer ) {

        // Print the header blob
        cch = wsprintf( pchBuffer,
                        " AllocCacheTable Data <br>"
                        "<TABLE BORDER> <TR> "
                        "<TH> Item Name </TH> "
                        "<TH> Config(concurr, threshold, size) </TH> "
                        "<TH> # Total Items </TH> "
                        "<TH> # Alloc Calls </TH> "
                        "<TH> # Free Calls </TH> "
                        "<TH> # Free Entries </TH> "
                        "<TH> # Total Size (bytes) </TH> "
                        " </TR>"
                        );
    } else {
        cch = 300;
    }

    for ( pEntry = sm_lItemsHead.Flink, iCount = 0;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink, iCount++
          ) {

        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        cbTotalMem += pach->m_acConfig.cbSize * pach->m_nTotal;

        if ( (cch + 150 + strlen( pach->m_pszName)) < *lpcchBuffer) {
            cch += wsprintf( pchBuffer + cch,
                             " <TR> <TD> [%d] %s </TD> <TD> (%d, %d, %d) </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " </TR>"
                             ,
                             iCount,
                             pach->m_pszName,
                             pach->m_acConfig.nConcurrency,
                             pach->m_acConfig.nThreshold,
                             pach->m_acConfig.cbSize,
                             pach->m_nTotal,
                             pach->m_nAllocCalls,
                             pach->m_nFreeCalls,
                             pach->m_nFreeEntries,
                             pach->m_acConfig.cbSize * pach->m_nTotal
                             );
        } else {
            cch += 150 + strlen( pach->m_pszName);
        }
    } // for

    LeaveCriticalSection( &sm_csItems);

    //
    // dump the final summary
    //
    if ( (cch + 100 ) < *lpcchBuffer) {
        cch += wsprintf( pchBuffer + cch,
                         " <b>"
                         " <TR> </TR>"
                         " <TR> <TD> Total </TD> <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> %4d </TD>"
                         " </TR>"
                         "</b>"
                         " </TABLE>"
                         ,
                         cbTotalMem
                         );
    } else {
        cch += 100;
    }

    if ( *lpcchBuffer < cch ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fRet = FALSE;
    }

    *lpcchBuffer = cch;

    return (fRet);
} // ALLOC_CACHE_HANDLER::DumpStatsToHtml()

extern "C"
BOOL AllocCacheDumpStatsToHtml( OUT CHAR * pch, 
                                IN OUT LPDWORD lpcchBuff)
{
    return ( ALLOC_CACHE_HANDLER::DumpStatsToHtml( pch, lpcchBuff));
} 
    
/* class static */
BOOL
ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval( VOID )
{
    DWORD               dwError;
    DWORD               dwVal = 0;
    HKEY                hkey;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY,
                            0,
                            KEY_READ,
                            &hkey);

    if ( dwError == NO_ERROR ) {

        //
        // get the lookaside list cleanup period
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ACACHE_REG_LOOKASIDE_CLEANUP_INTERVAL,
                                   ACACHE_REG_DEFAULT_CLEANUP_INTERVAL );

        ATQ_REQUIRE( !RegCloseKey( hkey ) );
    }

    if ( dwVal != 0 )
    {
        sm_dwScheduleCookie =
            ScheduleWorkItem( ALLOC_CACHE_HANDLER::CleanupAllLookasides,
                              NULL,
                              dwVal * 1000,
                              TRUE );

        if ( sm_dwScheduleCookie == 0 )
        {
            return FALSE;
        }
    }

    return TRUE;
} // ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval( VOID )
{
    BOOL fReturn = TRUE;
    if ( sm_dwScheduleCookie )
    {
        fReturn = RemoveWorkItem( sm_dwScheduleCookie );
        if (fReturn) {
            sm_dwScheduleCookie = 0;
        }
    }

    return ( fReturn);
} // ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval()



/* class static */
VOID
ALLOC_CACHE_HANDLER::CleanupAllLookasides(
    IN PVOID            pvContext
)
{
    LIST_ENTRY *        pEntry;

    EnterCriticalSection( &sm_csItems);

    for ( pEntry = sm_lItemsHead.Flink;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink )
    {
        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        IF_DEBUG( ALLOC_CACHE) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Cleaning lookaside list for '%s' handler\n",
                         pach->m_pszName ));
        }

        pach->CleanupLookaside( FALSE );
    }

    LeaveCriticalSection( &sm_csItems);
} // ALLOC_CACHE_HANDLER::CleanupAllLookasides()




/************************************************************
 *    Member Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER(
    IN LPCSTR pszName,
    IN const ALLOC_CACHE_CONFIGURATION * pacConfig
    )
    : m_fValid ( FALSE),
      m_nTotal       (0),
      m_nAllocCalls  (0),
      m_nFreeCalls   (0),
      m_nFreeEntries (0),
      m_pszName      (pszName),
      m_nLastAllocCount(0)
{
    DBG_ASSERT( NULL != pacConfig );
    m_acConfig = *pacConfig;

    if ( pacConfig->nThreshold == INFINITE) {
        // this will be compared against a signed value. So be careful.
        m_acConfig.nThreshold = 0x7FFFFFFF;
    } else {
        // scale by the number of processors on MP machines
        m_acConfig.nThreshold *= g_cCPU;
    }

    InitializeCriticalSection( & m_csLock);
    SET_CRITICAL_SECTION_SPIN_COUNT( &m_csLock, IIS_DEFAULT_CS_SPIN_COUNT);

    m_lHead.Next = NULL;

    ALLOC_CACHE_HANDLER::InsertNewItem( this);
    m_fValid = TRUE;
    return;
} // ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER()



ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER(VOID)
{
    if ( m_fValid) {

        CleanupLookaside( TRUE );

        DeleteCriticalSection( & m_csLock);
        ALLOC_CACHE_HANDLER::RemoveItem( this);
    }

    DBG_ASSERT( 0 == m_nTotal );
    DBG_ASSERT( m_lHead.Next == NULL);
    return;
} // ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER()



VOID
ALLOC_CACHE_HANDLER::CleanupLookaside(
    IN BOOL             fForceCleanup
)
/*++
  Description:
    This function cleans up the lookaside list by removing excess storage space
    used by the objects allocated by this instance. This function is
    used by the periodic scavenging operation as well as for final cleanup.

  Arguments:
    fForceCleanup - forces a cleanup operation always.

  Returns:
     None
--*/
{
    if ( !fForceCleanup )
    {
        //
        // We are called for the regular scavenging operation
        // Take a snapshot of the # allocation calls so that
        //  we may cleanup space when services are idle.
        //

        IF_DEBUG( ALLOC_CACHE) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AllocCalls = %ld, LastAllocCount = %ld\n",
                         m_nAllocCalls,
                         m_nLastAllocCount ));
        }

        if ( m_nAllocCalls != m_nLastAllocCount )
        {
            InterlockedExchange( &m_nLastAllocCount,
                                 m_nAllocCalls );
            return;
        }
    }

    SINGLE_LIST_ENTRY listHeadCopy;

    //
    // make a copy of the first element in the list inside the lock
    // Free the entire chain outside the locked section.
    // Otherwise on a busy system the threads will be waiting for 
    //  this thread to complete
    //

    Lock();
    listHeadCopy.Next = m_lHead.Next;

    //
    // we are about to cleanup all entries -> so set state back properly.
    //
    m_lHead.Next      = NULL;
    m_nFreeEntries    = 0; // no more free-entries available
    Unlock();

    //
    // free up all the entries in the list
    //

    PSINGLE_LIST_ENTRY pl;
    pl = PopEntryList( &listHeadCopy);
    while ( pl != NULL) {

        InterlockedDecrement( &m_nTotal);
        ::LocalFree( pl);
        pl = PopEntryList( &listHeadCopy);
    } // for

    DBG_ASSERT( listHeadCopy.Next == NULL);

    return;
} // ALLOC_CACHE_HANDLER::CleanupLookaside()



LPVOID
ALLOC_CACHE_HANDLER::Alloc( VOID )
{
    LPVOID pv = NULL;

    if ( m_nFreeEntries > 0) {

        // 
        // There are free entries available - allocate from the free pool
        //

        Lock();

        // Check again if the free entry is available.
        if ( m_nFreeEntries > 0) {
            pv = (LPVOID )PopEntryList( & m_lHead);  // get the real object
            m_nFreeEntries--;
        }
        Unlock();
    }

    if ( NULL == pv) {

        //
        // No free entry. Need to alloc a new object.
        //

        pv = (LPVOID ) LocalAlloc( LPTR, m_acConfig.cbSize);

        if ( NULL != pv) {

            // initialize the list head properly and extract exact object.
            ((PSINGLE_LIST_ENTRY ) pv)->Next = NULL;

            // pv = (LPVOID ) (((PSINGLE_LIST_ENTRY ) pv));

            // update counters
            InterlockedIncrement( &m_nTotal);
        }
    }

    if ( NULL != pv ) { InterlockedIncrement( &m_nAllocCalls); }

    return ( pv);
} // ALLOC_CACHE_HANDLER::Alloc()



BOOL
ALLOC_CACHE_HANDLER::Free( LPVOID pv)
{
    // Assume that this is allocated using the Alloc() function
    DBG_ASSERT( NULL != pv);

    // store the items in the alloc cache.

    if ( m_nFreeEntries >= m_acConfig.nThreshold) {

        //
        // threshold for free entries is exceeded. free the object to 
        //  process pool
        //

        ::LocalFree( pv);
        InterlockedDecrement( &m_nTotal);
    } else {

        //
        // Store the given pointer in the single linear list
        //

        Lock();
        PushEntryList( &m_lHead,  (((PSINGLE_LIST_ENTRY ) pv)));
        m_nFreeEntries++;
        Unlock();
    }

    InterlockedIncrement( &m_nFreeCalls);

    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Free()




VOID
ALLOC_CACHE_HANDLER::Print( VOID)
{
    CHAR  rgchBuffer[8192];
    DWORD cchBuffer = sizeof(rgchBuffer);

    DBG_REQUIRE( IpPrint( rgchBuffer, &cchBuffer));

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));

    return;
} // ALLOC_CACHE_HANDLER::Print()



BOOL
ALLOC_CACHE_HANDLER::IpPrint( OUT CHAR * pchBuffer, IN OUT LPDWORD pcchSize)
{
    DWORD cchUsed;

    cchUsed = wsprintfA( pchBuffer,
                         "[%d]ALLOC_CACHE_HANDLER[%p]. Config: "
                         " ObjSize = %d. Concurrency=%d. Thres=%d.\n"
                         " TotalObjs = %d. Calls: Alloc(%d), Free(%d)."
                         " FreeEntries = %d.\n"
                         ,
                         GetCurrentThreadId(),
                         this,
                         m_acConfig.cbSize, m_acConfig.nConcurrency,
                         m_acConfig.nThreshold,
                         m_nTotal, m_nAllocCalls, m_nFreeCalls, m_nFreeEntries
                         );
    Lock();

    // NYI: Print the list of individual pointers
    Unlock();

    DBG_ASSERT( *pcchSize > cchUsed);
    *pcchSize = cchUsed;

    return (TRUE);
} // ALLOC_CACHE_HANDLER::IpPrint()



VOID
ALLOC_CACHE_HANDLER::QueryStats( IN ALLOC_CACHE_STATISTICS * pacStats )
{
    DBG_ASSERT( pacStats != NULL );

    pacStats->acConfig      = m_acConfig;
    pacStats->nTotal        = m_nTotal;
    pacStats->nAllocCalls   = m_nAllocCalls;
    pacStats->nFreeCalls    = m_nFreeCalls;
    pacStats->nFreeEntries  = m_nFreeEntries;

    return;
} // ALLOC_CACHE_HANDLER::QueryStats()


//
// Global functions
//


DWORD
I_AtqReadRegDword(
   IN HKEY     hkey,
   IN LPCSTR   pszValueName,
   IN DWORD    dwDefaultValue )
/*++

    NAME:       I_AtqReadRegDword

    SYNOPSIS:   Reads a DWORD value from the registry.

    ENTRY:      hkey - Openned registry key to read

                pszValueName - The name of the value.

                dwDefaultValue - The default value to use if the
                    value cannot be read.

    RETURNS     DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL ) {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) ) {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;

} // I_AtqReadRegDword()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\dllmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1996           **/
/**********************************************************************/

/*
    dllmain.cxx

        Library initialization for isatq.dll  --
           Internet Information Services - ATQ dll.

    FILE HISTORY:

        MuraliK     08-Apr-1996  Created.
*/


#include "isatq.hxx"


/************************************************************
 * Globals
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();


//
// is winsock initialized?
//

BOOL    g_fSocketsInitialized = FALSE;

//
// This Misc lock is used to guard the initialization code (and anything else
// that might come up later).
//

BOOL    miscLockInitialized = FALSE;
CRITICAL_SECTION    MiscLock;


/************************************************************
 * Functions
 ************************************************************/



extern "C"
BOOL WINAPI
DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:  {

        CREATE_DEBUG_PRINT_OBJECT( "isatq");
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            return ( FALSE);
        }

        //
        // Initialize global init critsect
        //

        miscLockInitialized =
            InitializeCriticalSectionAndSpinCount(&MiscLock, 400);

        if ( !miscLockInitialized ) {
            return FALSE;
        }

        SET_DEBUG_FLAGS( DEBUG_ERROR );

        //
        // Initialize sockets
        //

        {
            DWORD dwError = NO_ERROR;

            WSADATA   wsaData;
            INT       serr;

            //
            //  Connect to WinSock 2.0
            //

            serr = WSAStartup( MAKEWORD( 2, 0), &wsaData);

            if( serr != 0 ) {
                DBGPRINTF((DBG_CONTEXT,"WSAStartup failed with %d\n",serr));
                return(FALSE);
            }
            g_fSocketsInitialized = TRUE;
        }

        //
        // Initialize the platform type
        //
        INITIALIZE_PLATFORM_TYPE();
        ATQ_ASSERT(IISIsValidPlatform());

        DisableThreadLibraryCalls( hDll );
        break;
    }

    case DLL_PROCESS_DETACH:

        if ( lpvReserved != NULL) {

            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            break;
        }


        //
        // Cleanup sockets
        //

        if ( g_fSocketsInitialized ) {

            INT serr = WSACleanup();

            if ( serr != 0) {
                ATQ_PRINTF((DBG_CONTEXT,"WSACleanup failed with %d\n",
                            WSAGetLastError()));
            }
            g_fSocketsInitialized = FALSE;
        }

        if ( miscLockInitialized ) {
            DeleteCriticalSection(&MiscLock);
            miscLockInitialized = FALSE;
        }

        DELETE_DEBUG_PRINT_OBJECT();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return ( fReturn);

} // main()


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\atqendp.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      atqendp.cxx

   Abstract:
      This module implements ATQ endpoints

   Author:

       Johnson Apacible    (JohnsonA)     13-May-1996

   Environment:

       User Mode -- Win32

--*/

#include "isatq.hxx"

//
// Forward declarations
//

BOOL
I_CreateListenSocket(
    IN PATQ_ENDPOINT Endpoint
    );

BOOL
I_CloseListenSocket(
    IN PATQ_ENDPOINT Endpoint
    );

BOOL
StartListenThread(
    IN PATQ_ENDPOINT Endpoint
    );

extern DWORD g_cCPU;

# define ATQ_MIN_ACCEPTEX_TIMEOUT    (120)  // 2 minutes = 120 seconds

#define ATQ_CLOSE_ENDPOINT_SLEEP_TIME (200) // 200ms = 1/5 second
#define ATQ_CLOSE_ENDPOINT_TIMEOUT    ((100 * 1000) / ATQ_CLOSE_ENDPOINT_SLEEP_TIME)
                                            // 100 seconds

#define ATQ_MIN_ACCEPTEX_SOCKETS         (5)
#define ATQ_MAX_ACCEPTEX_SOCKETS         (150) // just seems like a lot.


PVOID
AtqCreateEndpoint(
    IN PATQ_ENDPOINT_CONFIGURATION Configuration,
    IN PVOID EndpointContext
    )

/*++

Routine Description:

    Creates a server instance.

Arguments:

    Context - Context value returned

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{

    DWORD timeout = Configuration->AcceptExTimeout;
    PATQ_ENDPOINT endpoint;
    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"AtqCreateEndpoint entered\n"));
    }

    //
    // Allocate list
    //

    endpoint = (PATQ_ENDPOINT)LocalAlloc(0,sizeof(ATQ_ENDPOINT));
    if ( endpoint == NULL ) {
        ATQ_PRINTF(( DBG_CONTEXT,"Unable to allocate ATQ Endpoint\n"));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error;
    }

    //
    // Initialize
    //

    ZeroMemory(endpoint,sizeof(ATQ_ENDPOINT));
    endpoint->Signature = ATQ_ENDPOINT_SIGNATURE;
    endpoint->m_refCount = 1;
    SET_BLOCK_STATE(endpoint, AtqStateActive);

    endpoint->EnableBw = FALSE;
    endpoint->ConnectCompletion = Configuration->pfnConnect;
    endpoint->ConnectExCompletion = Configuration->pfnConnectEx;
    endpoint->IoCompletion = Configuration->pfnIoCompletion;
    endpoint->fDatagram = Configuration->fDatagram;
    endpoint->ListenSocket = INVALID_SOCKET;
    endpoint->pListenAtqContext = NULL;
    endpoint->nAvailDuringTimeOut = 0;
    endpoint->nSocketsAvail = 0;
    endpoint->Context = EndpointContext;
    endpoint->fExclusive = Configuration->fLockDownPort;
    endpoint->fReverseQueuing = Configuration->fReverseQueuing;
    endpoint->cbDatagramWSBufSize = Configuration->cbDatagramWSBufSize;
    
    endpoint->InitialRecvSize = Configuration->cbAcceptExRecvBuffer;

    // we need to maintain at least 5 outstanding accept ex sockets
    // for our auto-tune algo to work.
    endpoint->nAcceptExOutstanding = 
        min((g_cCPU * (max(ATQ_MIN_ACCEPTEX_SOCKETS, Configuration->nAcceptExOutstanding))),
             ATQ_MAX_ACCEPTEX_SOCKETS);

    endpoint->fAddingSockets = FALSE;

    //
    // Check and set the timeout to be atleast minimum timeout for AcceptEx
    //
    if ( timeout <= ATQ_MIN_ACCEPTEX_TIMEOUT)  {
        timeout = ATQ_MIN_ACCEPTEX_TIMEOUT;
    }

    endpoint->AcceptExTimeout = CanonTimeout( timeout);

    endpoint->Port = Configuration->ListenPort;
    endpoint->IpAddress = Configuration->IpAddress;
    endpoint->ConsumerType = AtqConsumerOther;

    //endpoint->ContextList.Initialize( );

#if DBG
    endpoint->RefTraceLog = CreateRefTraceLog( TRACE_LOG_SIZE, 0 );
#endif

#if 0
    ATQ_PRINTF(( DBG_CONTEXT,"port %d nAX %d nAT %d nLB %d\n",
        endpoint->Port, endpoint->nAcceptExOutstanding,
        endpoint->AcceptExTimeout, g_cListenBacklog));
#endif

    //
    // Create the socket
    //

    if (!I_CreateListenSocket(endpoint) ) {

        goto error;
    }

    return((PVOID)endpoint);

error:

    if ( endpoint != NULL ) {
#if DBG
        if( endpoint->RefTraceLog != NULL ) {
            DestroyRefTraceLog( endpoint->RefTraceLog );
        }
#endif
        LocalFree( endpoint );
    }

    return(NULL);

} // AtqCreateEndpoint



BOOL
AtqStartEndpoint(
    IN PVOID Endpoint
    )
{
    BOOL useAcceptEx;
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    BOOL fReturn;

    ATQ_ASSERT(IS_BLOCK_ACTIVE(pEndpoint));

    pEndpoint->UseAcceptEx = useAcceptEx =
        ((g_fUseAcceptEx) && (pEndpoint->ConnectExCompletion != NULL)) ||
        pEndpoint->fDatagram;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"AtqStartEndpoint called. UseAcceptEx[%d]\n",
            useAcceptEx));
    }

    //
    // if AcceptEx is supported, create AcceptEx contexts
    //

    if ( useAcceptEx ) {

        //
        // Add AcceptEx sockets
        //

        fReturn = pEndpoint->ActivateEndpoint();

        if ( !fReturn ) {
            DBGPRINTF(( DBG_CONTEXT,"Error %d in %08x::ActivateEndpoint()\n",
                GetLastError(), pEndpoint));
        }

    } else {

        //
        // We need to start a listen thread
        //

        fReturn = StartListenThread( pEndpoint );

        if ( !fReturn ) {
            DBGPRINTF(( DBG_CONTEXT,"Error %d in %08x::StartListenThread()\n",
                GetLastError(), pEndpoint));
        }
    }

    return (fReturn);

} // AtqStartEndpoint



DWORD_PTR
AtqEndpointGetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ endpoint

Arguments:

    Endpoint    - endpoint to get data from
    EndpointInfo - type of info to get

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

      case EndpointInfoListenPort:
        dwVal = pEndpoint->Port;
        break;

      case EndpointInfoListenSocket:
        dwVal = pEndpoint->ListenSocket;
        break;

      default:
        ATQ_ASSERT( FALSE );
    }

    return dwVal;
} // AtqEndpointGetInfo()



DWORD_PTR
AtqEndpointSetInfo(
    IN PVOID                Endpoint,
    IN ATQ_ENDPOINT_INFO    EndpointInfo,
    IN DWORD_PTR            dwInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    Endpoint    - endpoint to set info on
    EndpointInfo - type of info to set
    dwInfo       - info to set

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

        case EndpointInfoAcceptExOutstanding:

        dwVal = pEndpoint->nAcceptExOutstanding;

        if ( dwVal < dwInfo ) {

            //
            // Make up for increased limit
            //

            if ( (DWORD ) pEndpoint->nSocketsAvail < (dwInfo >> 2) ) {
                (VOID ) I_AtqPrepareAcceptExSockets(
                                        pEndpoint,
                                        ((DWORD)dwInfo>>2) - pEndpoint->nSocketsAvail
                                        );
            }
            pEndpoint->nAcceptExOutstanding = (DWORD)dwInfo;
        }
        break;

      default:
        ATQ_ASSERT( FALSE );
    }

    return dwVal;
} // AtqEndpointSetInfo()




BOOL
AtqStopEndpoint(
    IN PVOID     Endpoint
    )
/*++

Routine Description:

    Stops the endpoint - marks the Endpoint as to be shutdown and closes
    the listening socket -> forcing new connections to stop for this endpoint

Arguments:

    Endpoint - endpoint to be stopped

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD  nClosed;

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqStopEndpoint( %08x)\n", pEndpoint));
    }

    //
    //  Find the listen socket info
    //

    AcquireLock( &AtqEndpointLock );

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Attempt to Stop Endpoint (%08x) more than once",
                     pEndpoint
                     ));
        ReleaseLock( &AtqEndpointLock );
        return(FALSE);
    }

    //
    //  Mark the listen info as no longer accepting connections
    //

    SET_BLOCK_STATE(pEndpoint, AtqStateClosed);

    //
    //  Remove the entry from the end points list
    //

    RemoveEntryList(&pEndpoint->ListEntry);
    ReleaseLock( &AtqEndpointLock );

    //
    // Close the listen socket which forces the cleanup for all the
    //  pending LISTEN ATQ contexts. We do this early on so that
    //  we can prevent any new entrant connections into the processing code.
    //

    I_CloseListenSocket( pEndpoint );

    //
    // Forcibly close all the pending LISTEN contexts tied to this endpoint
    //

    nClosed = pEndpoint->CloseAtqContexts( TRUE);

    DBGPRINTF(( DBG_CONTEXT,
                "ATQ_ENDPOINT(%08x)::Closed %d pending Listen sockets\n",
                pEndpoint, nClosed));

    //
    // if this is a non-acceptex socket, wait for the listen thread to die
    //

    if ( !pEndpoint->UseAcceptEx ) {
        WaitForSingleObject(pEndpoint->hListenThread, 10*1000);
    }

    return ( TRUE);

} // AtqStopEndpoint()


BOOL
AtqCloseEndpoint(
    IN PVOID     Endpoint
    )
/*++

Routine Description:

    Closes the endpoint - it forcefully fress up all references to the
    endpoint (held by ATQ Contexts) by shutting down the ATQ contexts.
    In the course of this operation if some context does not go away, this
    code will end up looping forever!

    Note: Should be called *after* AtqStopEndpoint()

Arguments:

    Endpoint - endpoint to be stopped

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD  nClosed;
    DWORD i;

    ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );


    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqCloseEndpoint( %08x)\n", pEndpoint));
    }

    if ( pEndpoint->State != AtqStateClosed) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Attempt to Close Endpoint (%08x) when it is "
                     " not stopped yet!\n'",
                     pEndpoint
                     ));
        return(FALSE);
    }

    //
    // wait for all the contexts for this endpoint to go away
    // or for about two minutes
    //

    i = 0;
    while (( pEndpoint->m_refCount > 1) && (i < ATQ_CLOSE_ENDPOINT_TIMEOUT)) {

        ATQ_PRINTF(( DBG_CONTEXT, " Endpoint(%08x) has %d refs\n",
                     pEndpoint, pEndpoint->m_refCount));

        //
        // Forcibly close all the contexts tied to this endpoint again!
        // Sometimes for some random reasons ATQ contexts get left out
        //  during the first clean we did above. In such case it is important
        //  to retry again
        // THIS IS UGLY. But if we did not do this then the Endpoint
        //  structure might get freed => ATQ contexts will be hanging on to
        //  dead ATQ endpoint
        //

        nClosed = pEndpoint->CloseAtqContexts();

        DBGPRINTF(( DBG_CONTEXT, " ATQ_ENDPOINT(%08x)::Closed %d sockets\n",
                    pEndpoint, nClosed));

        //
        // NYI: I need to auto-tune this sleep function
        //
        Sleep( ATQ_CLOSE_ENDPOINT_SLEEP_TIME); // sleep and check again.

        //
        // loop until timeout
        //
        i++;

        // wake up and check again.
    } // while (busy wait)

    //
    //  Undo the reference for being on the listen info list.
    //    decr final ref count => the endpoint will be cleaned up & freed
    //
    //  If we timed out just leak the endpoints!
    //

    if ( pEndpoint->m_refCount == 1 ) {
        pEndpoint->Dereference();

        return TRUE;
    } else {
        return FALSE;
    }

} // AtqCloseEndpoint()



BOOL
AtqStopAndCloseEndpoint(
    IN PVOID                    Endpoint,
    IN LPTHREAD_START_ROUTINE   lpCompletion,
    IN PVOID                    lpCompletionContext
    )
/*++

Routine Description:

    Stops the endpoint and closes it after forcing close of
    associated ATQ contexts.

Arguments:

    Endpoint - endpoint to shutdown.
    lpCompletion - routine to be called when endpoint is completely shutdown.
    lpCompletionContext - Context to be returned with the routine

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    BOOL fReturn;

    //
    // Warn all the callers of this to be deprecated API and pray that
    // they will all switch over
    //
    OutputDebugStringA( "\n-----------------------------------------------\n");
    OutputDebugStringA( " AtqStopAndCloseEndpoint() should NOT be called\n");
    OutputDebugStringA( "         Call 1) AtqStopEndpoint()  and \n");
    OutputDebugStringA( "              2) AtqCloseEndpoint() instead\n");
    OutputDebugStringA( "   For Now, this call will simulate 1 & 2\n");
    OutputDebugStringA( "-----------------------------------------------\n");


    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqStopAndCloseEndpoint( %08x)\n", pEndpoint));
    }

    fReturn = AtqStopEndpoint( Endpoint);

    if ( fReturn) {

        //
        // Call any custom shutdown function
        // NYI: Too Bad the Endpoint object is not a base class object
        //

        if ( lpCompletion != NULL ) {
            pEndpoint->ShutdownCallback = lpCompletion;
            pEndpoint->ShutdownCallbackContext = lpCompletionContext;
        }

        //
        // Now that the Endpoint is stopped and callback functions are called,
        //  Let us call the AtqCloseEndpoint() to cleanup the endpoint itself.
        //
        fReturn = AtqCloseEndpoint( Endpoint);
    }

    return (fReturn);

} // AtqStopAndCloseEndpoint()



BOOL
ATQ_ENDPOINT::ActivateEndpoint( VOID)
/*++

Routine Description:


    This function creates the initial listening socket & ATQ context for given
    endpoint. It also adds initial set of AcceptEx Sockets to the ATQ listening
    pool (if we are using the AcceptEx())

Arguments:
    None

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    PATQ_CONT   patqContext = NULL;
    BOOL        fReturn;
    DWORD       cInitial = this->nAcceptExOutstanding;

    //
    //  Add the listen socket
    //
    DBG_ASSERT( this->pListenAtqContext == NULL);

    fReturn =
        I_AtqAddListenEndpointToPort(
                                     (PATQ_CONT*)&this->pListenAtqContext,
                                     this
                                     );

    if ( !fReturn) {

        if ( this->pListenAtqContext ) {
            AtqFreeContext( this->pListenAtqContext, FALSE);
            this->pListenAtqContext = NULL;
        }

        return FALSE;
    }

    cInitial = max(cInitial, 1);

    if ( !TsIsNtServer( ) ) {

        //
        // Limit what a workstation can specify
        //

        cInitial = min(cInitial, ATQ_MIN_CTX_INC);
        this->nAcceptExOutstanding = cInitial;

    }

    //
    // start with 1/4 of the intended
    //

    cInitial = max( cInitial >> 2, 1);

    //
    //  Now add the acceptex sockets for this ListenInfo object
    //

    return(I_AtqPrepareAcceptExSockets(this, cInitial));

} // ATQ_ENDPOINT::ActivateEndpoint()



DWORD
ATQ_ENDPOINT::CloseAtqContexts( IN BOOL fPendingOnly)
/*++
  Description:
    This function searches for all ATQ contexts associated
     with the given endpoint and forcibly closes them all.

  Arguments:
    fPendingOnly - close only the pending sockets

  Returns:
    DWORD containing the number of ATQ contexts closed.
--*/
{
    DWORD  nClosed = 0;
    DWORD  i;
    PLIST_ENTRY   pEntry;
    PATQ_CONT     pContext;

    //
    //  Force a close on all the connected sockets so that all the holders
    //   and use of such contexts will bail out of this endpoint entirely.
    // NYI: We need a way to tag on all these lists on per-endpoint basis
    //

    for ( i = 0; i < g_dwNumContextLists; i++) {

        PLIST_ENTRY pListHead;

        AtqActiveContextList[i].Lock();

        //
        // Hard close sockets in the pending list
        //

        pListHead = &AtqActiveContextList[i].PendingAcceptExListHead;
        for ( pEntry = pListHead->Flink;
             pEntry != pListHead;
             pEntry  = pEntry->Flink ) {

            pContext = CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

            ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

            if ( (pContext->pEndpoint == this) &&
                 (pContext->IsState( ACS_SOCK_CONNECTED) ||
                  pContext->IsState( ACS_SOCK_LISTENING)
                  ) &&
                 (pContext->hAsyncIO  != NULL) ) {

                nClosed++;
                pContext->HardCloseSocket();
            }
        } // for items in pending list

        if ( !fPendingOnly) {
            //
            // Hard close sockets in the active list
            // Active list includes sockets in ACS_SOCK_CLOSED state
            //  that ought to be freed up, because we could have reached
            //  this through the optimizations for TransmitFile()
            //

            pListHead = &AtqActiveContextList[i].ActiveListHead;
            for ( pEntry = pListHead->Flink;
                  pEntry != pListHead;
                  pEntry  = pEntry->Flink ) {

                pContext = CONTAINING_RECORD( pEntry, ATQ_CONTEXT,
                                              m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

                if ( (pContext->pEndpoint == this)  &&
                     (pContext->IsState( ACS_SOCK_CONNECTED) ||
                      pContext->IsState( ACS_SOCK_LISTENING) ||
                      pContext->IsState( ACS_SOCK_CLOSED) ||
                      pContext->IsState( ACS_SOCK_UNCONNECTED)
                      ) &&
                     (pContext->hAsyncIO  != NULL) ) {

                    nClosed++;
                    pContext->HardCloseSocket();
                }
            } // for items in active list
        } // if (! fPendingOnly)

        AtqActiveContextList[i].Unlock();

    } // for

    return ( nClosed);

} // ATQ_ENDPOINT::CloseAtqContexts()


/************************************************************
 * Internal Functions
 ************************************************************/


BOOL
I_CreateListenSocket(
    IN PATQ_ENDPOINT pEndpoint
    )
/*++

    Creates a socket for listening to connections on given address.

    Arguments:

       lpSockAddress    pointer to local socket address structure used to bind
                           the given connection.
       lenSockAddress   length of the socket address structure.
       socketType       integer containing the type of the socket ( stream )
       socketProtocol   protocol to be used for the socket.
       nBackLog         Maximum length to which a queue of pending connections
                           may grow.

    Returns:
       NO_ERROR on success; otherwise returns Sockets error code.

--*/
{
    INT serr;
    SOCKET  sNew;
    SOCKADDR_IN inAddr;
    PSOCKADDR addr;
    INT addrLength;
    PLIST_ENTRY listEntry;
    PATQ_ENDPOINT scanEndpoint;
    DWORD     cbOut;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"I_CreateListenEndpoint called. \n"));
    }

    //
    // Create a new socket
    //

#if WINSOCK11
    sNew =  socket(
                AF_INET,
                SOCK_STREAM,
                IPPROTO_TCP
                );
#else
    sNew = WSASocket(
                  AF_INET,
                  pEndpoint->fDatagram ? SOCK_DGRAM : SOCK_STREAM,
                  pEndpoint->fDatagram ? IPPROTO_UDP: IPPROTO_TCP,
                  NULL,  // protocol info
                  0,     // Group ID = 0 => no constraints
                  WSA_FLAG_OVERLAPPED    // completion port notifications
                  );
# endif // WINSOCK11

    if ( sNew == INVALID_SOCKET ) {
        serr = WSAGetLastError();
        ATQ_PRINTF(( DBG_CONTEXT,
                    "Error %d in socket( %d, %d, %d)\n",
                    serr,
                    AF_INET,
                    SOCK_STREAM,
                    IPPROTO_TCP
                    ));

        goto cleanup;
    }

    //
    // Set EXCLUSIVE use if needed
    //

    if ( pEndpoint->fExclusive ) {
        ATQ_PRINTF(( DBG_CONTEXT,
                    " Setting %s port %d to exclusive access\n",
                    pEndpoint->fDatagram ? "UDP" : "TCP",
                    pEndpoint->Port));

        if ( setsockopt( sNew, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,
                        (const CHAR *) &pEndpoint->fExclusive,
                        sizeof( pEndpoint->fExclusive )) != 0) {

            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                        " setsockopt( %d, EXCLUSIVEADDR, FALSE) failed."
                        " Error = %d\n",
                        sNew, serr));
            serr = 0;
        }
    }

    if ( pEndpoint->fDatagram ) {

        //
        // ReverseQueuing means that if winsock runs out of buffer space for
        // receives then it will drop the oldest datagrams first.  The default 
        // is for it to drop the newest datagrams.
        //
        if ( pEndpoint->fReverseQueuing
            && WSAIoctl(sNew,                          // socket
                        SIO_ENABLE_CIRCULAR_QUEUEING,  // IoControlCode
                        NULL,                          // pvInBuffer
                        0,                             // cbInBuffer
                        NULL,                          // pvOutBuffer
                        0,                             // cbOutBuffer
                        &cbOut,                        // cbActualBytesReturned
                        NULL,                          // pvOverlapped
                        NULL)) {                       // pCompletionRoutine

            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                         " WSAIoctl( %d, SIO_ENABLE_CIRCULAR_QUEUEING...) failed.  Error = 0x%x\n",
                         sNew, serr));

            serr = 0;
        }

        //
        // If they have specified a winsock receive buffer size use that instead
        // the winsock default of 8K.
        //
        if ( pEndpoint->cbDatagramWSBufSize
             && setsockopt(sNew,
                           SOL_SOCKET,
                           SO_RCVBUF,
                           (char *)&pEndpoint->cbDatagramWSBufSize,
                           sizeof(pEndpoint->cbDatagramWSBufSize))) {
            
            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                         " setsockopt( %d, SO_RECVBUF, %d...) failed.  Error = 0x%x\n",
                         sNew, pEndpoint->cbDatagramWSBufSize, serr));

            serr = 0;
        }
    }
    
    //
    // See which address family we're dealing with
    //

    addr = (PSOCKADDR)&inAddr;
    addrLength = sizeof(inAddr);
    ZeroMemory(addr, addrLength);

    inAddr.sin_family = AF_INET;
    inAddr.sin_port = htons(pEndpoint->Port);
    inAddr.sin_addr.s_addr = pEndpoint->IpAddress;

    //
    // Bind an address to socket
    //

    if ( bind( sNew, addr, addrLength) != 0) {

        serr = WSAGetLastError();

        ATQ_PRINTF(( DBG_CONTEXT,
                    "bind ( socket = %d, Address = %08x, len = %d) "
                    " returns error = %u\n",
                    sNew, addr, addrLength, serr));

        goto cleanup;
    }

    //
    // Put the socket in listen mode
    //

    if ( !pEndpoint->fDatagram ) {

        if ( listen( sNew, g_cListenBacklog) != 0) {

            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                        " listen( %d, %d) returned %d.\n",
                        sNew, g_cListenBacklog, serr));
            goto cleanup;
        }
    }
    pEndpoint->ListenSocket = sNew;

    //
    // Link to server listen list
    //

    AcquireLock( &AtqEndpointLock);

    InsertTailList(
                &AtqEndpointList,
                &pEndpoint->ListEntry
                );

    ReleaseLock( &AtqEndpointLock);
    return(TRUE);

cleanup:

    if ( sNew != INVALID_SOCKET) {
        closesocket( sNew);
    }

    SetLastError(serr);
    return(FALSE);

} // I_CreateListenSocket




BOOL
I_CloseListenSocket(
    IN PATQ_ENDPOINT Endpoint
    )
/*++

  Closes the socket on which a listen was possibly established.

  Returns:
    TRUE, if successful,
    FALSE, otherwise

--*/
{
    INT  serr = NO_ERROR;
    LINGER linger;
    SOCKET s;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"I_CloseListenSocket called.\n"));
    }

    s = (SOCKET)InterlockedExchangePointer(
                    (PVOID *)&Endpoint->ListenSocket,
                    (PVOID)INVALID_SOCKET
                    );

    if ( s == INVALID_SOCKET) {
        return(TRUE);
    }

    //
    //  Enable linger with timeout of ZERO for "hard" close
    //
    //  Error code from sock option is ignored, since we are
    //   anyway closing the socket
    //

    linger.l_onoff = TRUE;
    linger.l_linger = 0;
    setsockopt( s, SOL_SOCKET, SO_LINGER, (PCHAR)&linger,sizeof(linger));

    //
    // Close the socket
    //

    if (closesocket(s) != 0) {
        serr = WSAGetLastError();
        ATQ_PRINTF(( DBG_CONTEXT,"error %d in closesocket\n",serr));
    } else {

        // Remove the socket from the ListenAtq Context as well
        //  since the socket is now closed here in this function.
        PATQ_CONTEXT patqc = Endpoint->pListenAtqContext;
        if ( patqc != NULL) {
            patqc->hAsyncIO = NULL;
        }
    }

    return (TRUE);
} // I_CloseListenSocket()




DWORD
ListenThreadFunc(
        LPVOID Context
        )
/*++

    Main loop waiting for connections. ( The core of server)
    The thread loops around waiting on an accept() call on
     listenSocket.
    If there is a new message on socket, it invokes the
     callback function for connection.

    NEVER returns untill it is requested to stop by someother
      thread using a call to TS_CONNECTION_INFO::StopConnectionThread().

    Returns:

      0 on success and error code if there is a fatal error.


--*/
{

    INT serr;
    register SOCKET  sNewConnection;
    SOCKADDR_IN sockAddrRemote;
    PATQ_ENDPOINT endpoint = (PATQ_ENDPOINT)Context;

    IF_DEBUG(ENDPOINT) {
        ATQ_PRINTF((DBG_CONTEXT,"ListenThreadFunc() running.\n"));
    }

    //
    //  Loop Forever
    //

    for( ; ;) {

        int cbAddr = sizeof( sockAddrRemote);

        //
        //  Wait for a connection
        //

        IF_DEBUG(ENDPOINT) {
            ATQ_PRINTF((DBG_CONTEXT,"Listening for new connection\n"));
        }

        if ((sNewConnection = WSAAccept(
                                    endpoint->ListenSocket,
                                    (LPSOCKADDR ) &sockAddrRemote,
                                    &cbAddr,
                                    NULL,
                                    0)) != INVALID_SOCKET) {

            //
            // Valid Connection has been established.
            // Invoke the callback function to process this connection
            //   and then continue the loop
            //

            IF_DEBUG(ENDPOINT) {
                ATQ_PRINTF((DBG_CONTEXT,"Got new connection. sock[%d]\n",
                    sNewConnection));
            }

            (*endpoint->ConnectCompletion)(
                                sNewConnection,
                                &sockAddrRemote,
                                endpoint->Context,
                                (PVOID)endpoint
                                );

        } else {

            //
            // Some low level error has occured.
            //

            serr = WSAGetLastError();
            ATQ_PRINTF((DBG_CONTEXT,"Error %d in accept\n", serr));

            if ( serr == WSAEINTR) {

                //
                // Socket was closed by low-level call. Get out.
                //

                break;
            }

            //
            // Check if we are shutting down and if so QUIT
            //

            if (!IS_BLOCK_ACTIVE(endpoint)) {
                IF_DEBUG(ENDPOINT) {
                    ATQ_PRINTF((DBG_CONTEXT,"ListenThread shutting down\n"));
                }
                break;
            }

            //
            // Perform a graceful recovery from failure. NYI
            //  ( Tricky code). Both FTP and Web server are to test it!
            //    Will add this code later. ( MuraliK)
            //

            IF_DEBUG(ENDPOINT) {
                ATQ_PRINTF((DBG_CONTEXT,"Unexpected error %d on accept\n",
                    serr));
            }
        }
    }

    //
    // Cleanup & Exit. Cleanup is done by the code which called the shut down.
    //

    IF_DEBUG(ENDPOINT) {
        ATQ_PRINTF((DBG_CONTEXT,"ListenThread exiting.\n"));
    }
    return ( 0);  // No errors

} // ListenThreadFunc()



BOOL
StartListenThread(
    IN PATQ_ENDPOINT Endpoint
    )
{
    DWORD  id;

    Endpoint->hListenThread = CreateThread(
                                        NULL,
                                        0,
                                        ListenThreadFunc,
                                        (PVOID )Endpoint,
                                        0,
                                        &id
                                        );

    if ( Endpoint->hListenThread != NULL) {
        return(TRUE);
    }

    return(FALSE);

} // StartListenThread



VOID
ATQ_ENDPOINT::CleanupEndpoint(
    VOID
    )
/*++

  Description:
     This function cleansup the internal state of the object and prepares
     it for the deletion.
     All endpoints should pass through this function when the ref count
     this zero.

--*/
{
    DBG_ASSERT( this->m_refCount == 0);
    ATQ_ASSERT( !IS_BLOCK_ACTIVE( this) );
    ASSERT( this->Signature == ATQ_ENDPOINT_SIGNATURE );

    // the following free will throw away the listen atq context
    if ( this->pListenAtqContext != NULL) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "Endpoint(%08x) frees listen context %08x\n",
                     this, this->pListenAtqContext));
        AtqFreeContext( this->pListenAtqContext, FALSE);
        this->pListenAtqContext = NULL;
    }

    if ( this->ShutdownCallback != NULL ) {
        //
        // This only happens when someone calls AtqStopAndCloseEndpoint which should
        // never happen in K2.
        //
        ASSERT( FALSE );
        this->ShutdownCallback( this->ShutdownCallbackContext);
    }

    this->Signature = ATQ_ENDPOINT_SIGNATURE_FREE;

#if DBG
    if( this->RefTraceLog != NULL ) {
        DestroyRefTraceLog( this->RefTraceLog );
    }
#endif

    return;

} // ATQ_ENDPOINT::CleanupEndpoint()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\hashtab.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       hashtab.cxx

   Abstract:
       Implements the member functions for Hash table

   Author:

       Murali R. Krishnan    ( MuraliK )     02-Oct-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# if !defined(dllexp)
# define dllexp __declspec( dllexport)
# endif

# include "isatq.hxx"
# include "hashtab.hxx"

# include "dbgutil.h"



/*++
  Organization of Hash Table

  The hash table consists of a set of hash buckets controlled
  by the number of buckets specified during creation.

  Each bucket consists of a set of bucket chunks. Each bucket
  owns a separate critical section to protect the entries in
  the bucket itself.

  Each bucket chunk consists of an array of MAX_ELEMENTS_PER_BUCKET
   HashTableBucketElement Entries (HTBE_ENTRY).

  Each HTBE_ENTRY maintains a hash value and pointer to the Hash Element.

--*/

/************************************************************
 *    HASH_TABLE_BUCKET
 ************************************************************/

struct HTBE_ENTRY {
    DWORD        m_hashValue;
    HT_ELEMENT * m_phte;

    inline
    BOOL IsMatch( DWORD hashValue, LPCSTR pszKey, DWORD cchKey) const
    { return ((hashValue == m_hashValue) &&
              (NULL != m_phte) &&
              m_phte->IsMatch( pszKey, cchKey)
              );
    }

    inline
    BOOL IsMatch( IN HT_ELEMENT * phte) const
    { return ( phte == m_phte); }

    inline BOOL
    IsEmpty( VOID) const { return ( NULL == m_phte); }

    VOID Print( VOID) const
    { m_phte->Print(); }
};

typedef HTBE_ENTRY * PHTBE_ENTRY;

//
// Chunk size should be carefully (empirically) chosen.
// Small Chunk size => large number of chunks
// Large Chunk size => high cost of search on failures.
// For now we choose the chunk size to be 20 entries.
# define MAX_ELEMENTS_PER_BUCKET    ( 20 )

struct HTB_ELEMENT {

    HTBE_ENTRY   m_rgElements[MAX_ELEMENTS_PER_BUCKET];
    DWORD        m_nElements;
    LIST_ENTRY   m_ListEntry;

    HTB_ELEMENT(VOID)
        : m_nElements ( 0)
    {
        InitializeListHead( &m_ListEntry);
        ZeroMemory( m_rgElements, sizeof( m_rgElements));
    }

    ~HTB_ELEMENT(VOID)
    { Cleanup(); }

    VOID Cleanup( VOID);

    inline
    HT_ELEMENT * Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey);

    inline
    BOOL Insert( IN DWORD hashVal, IN HT_ELEMENT * phte);

    inline
    BOOL Delete( IN HT_ELEMENT * phte);

    VOID Print( IN DWORD level) const;

    HTBE_ENTRY * FirstElement(VOID) { return ( m_rgElements); }
    HTBE_ENTRY * LastElement(VOID)
    { return ( m_rgElements + MAX_ELEMENTS_PER_BUCKET); }
    VOID NextElement( HTBE_ENTRY * & phtbe)
    { phtbe++; }

    VOID IncrementElements(VOID) { m_nElements++; }
    VOID DecrementElements(VOID) { m_nElements--; }
    DWORD NumElements( VOID) const { return ( m_nElements); }
    BOOL IsSpaceAvailable(VOID) const
    { return ( NumElements() < MAX_ELEMENTS_PER_BUCKET); }

    DWORD FindNextElement( IN OUT LPDWORD pdwPos,
                           OUT HT_ELEMENT ** pphte);

};

typedef HTB_ELEMENT * PHTB_ELEMENT;

class HASH_TABLE_BUCKET {

public:
    HASH_TABLE_BUCKET(VOID);
    ~HASH_TABLE_BUCKET( VOID);

    HT_ELEMENT * Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey);
    BOOL Insert( IN DWORD       hashVal,
                 IN HT_ELEMENT * phte,
                 IN BOOL        fCheckForDuplicate);

    BOOL Delete( IN HT_ELEMENT * phte);
    VOID Print( IN DWORD level);

    DWORD NumEntries( VOID);

    DWORD  InitializeIterator( IN HT_ITERATOR * phti);

    DWORD  FindNextElement( IN HT_ITERATOR * phti,
                                   OUT HT_ELEMENT ** pphte);
    DWORD  CloseIterator( IN HT_ITERATOR * phti);

private:
    CRITICAL_SECTION   m_csLock;

    LIST_ENTRY         m_lHead;
    DWORD              m_nEntries;

    HTB_ELEMENT        m_htbeFirst; // the first bucket chunk

    VOID Lock(VOID) { EnterCriticalSection( &m_csLock); }
    VOID Unlock( VOID) { LeaveCriticalSection( &m_csLock); }
};




/************************************************************
 *    Member Functions of HTB_ELEMENT
 ************************************************************/

VOID
HTB_ELEMENT::Cleanup( VOID)
{

    if ( m_nElements > 0) {
        PHTBE_ENTRY phtbeEntry;

        // free up all the entries in this bucket.
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            if ( !phtbeEntry->IsEmpty() ) {

                // release the object now.
                DecrementElements();

                // Assert that ref == 1
                DerefAndKillElement( phtbeEntry->m_phte);
                phtbeEntry->m_phte = NULL;
                phtbeEntry->m_hashValue = 0;
            }
        } // for
    }

    DBG_ASSERT( 0 == m_nElements);
    return;
} // HTB_ELEMENT::Cleanup()


inline
HT_ELEMENT *
HTB_ELEMENT::Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey)
{
    HT_ELEMENT * phte = NULL;

    if ( m_nElements > 0) {

        PHTBE_ENTRY phtbeEntry;
        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            //
            // If the hash values match and the strings match up, return
            //  the corresponding hash table entry object
            //
            if ( phtbeEntry->IsMatch( hashValue, pszKey, cchKey)) {

                // we found the entry. return it.
                phte = phtbeEntry->m_phte;
                DBG_REQUIRE( phte->Reference() > 0);
                break;
            }
        } // for
    }

    return ( phte);
} // HTB_ELEMENT::Lookup()


inline BOOL
HTB_ELEMENT::Insert( IN DWORD hashVal,
                     IN HT_ELEMENT * phte
                     )
{
    if ( m_nElements < MAX_ELEMENTS_PER_BUCKET) {

        // there is some empty space.
        // Find one such a slot and add this new entry

        PHTBE_ENTRY phtbeEntry;

        for (phtbeEntry = FirstElement();
             phtbeEntry < LastElement();
             NextElement( phtbeEntry)) {

            if ( phtbeEntry->IsEmpty() ) {

                DBG_ASSERT( NULL != phte);

                // Assume that the object phte already has non-zero ref count

                // we found a free entry. insert the new element here.
                phtbeEntry->m_hashValue = hashVal;
                phtbeEntry->m_phte = phte;
                IncrementElements();
                return ( TRUE);
            }
        } // for

        // we should not come here. If we do then there is trouble :(
        DBG_ASSERT( FALSE);
    }

    SetLastError( ERROR_INSUFFICIENT_BUFFER);
    return ( FALSE);
} // HTB_ELEMENT::Insert()


DWORD
HTB_ELEMENT::FindNextElement( IN OUT LPDWORD pdwPos, OUT HT_ELEMENT ** pphte)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;

    DBG_ASSERT( NULL != pdwPos );
    DBG_ASSERT( NULL != pphte );

    // Find the first valid element to return back.

    //
    // Given that deletion might happen any time, we cannot rely on the
    //   comparison  *pdwPos < m_nElements
    //
    // Do scans with *pdwPos < MAX_ELEMENTS_PER_BUCKET
    //

    if ( *pdwPos < MAX_ELEMENTS_PER_BUCKET ) {

        PHTBE_ENTRY phtbeEntry;

        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = m_rgElements + *pdwPos;
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            if ( phtbeEntry->m_phte != NULL ) {

                //
                // Store the element pointer and the offset
                // and return after referencing the element
                //
                *pphte = phtbeEntry->m_phte;
                (*pphte)->Reference();
                *pdwPos = ( 1 + (DWORD)(phtbeEntry - FirstElement()));
                dwErr = NO_ERROR;
                break;
            }
        } // for
    }

    return ( dwErr);
} // HTB_ELEMENT::FindNextElement()


inline BOOL
HTB_ELEMENT::Delete( IN HT_ELEMENT * phte)
{
    DBG_ASSERT( NULL != phte);

    if ( m_nElements > 0) {

        PHTBE_ENTRY phtbeEntry;
        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            //
            // If the hash values match and the strings match up,
            //  decrement ref count and kill the element.
            //
            if ( phtbeEntry->IsMatch( phte)) {

                // We found the entry.  Remove it from the table

                phtbeEntry->m_phte = NULL;
                DecrementElements();

                DerefAndKillElement( phte);

                return ( TRUE);
            }
        } // for
    }

    return ( FALSE);
} // HTB_ELEMENT::Delete()


VOID
HTB_ELEMENT::Print(IN DWORD level) const
{
    const HTBE_ENTRY * phtbeEntry;
    CHAR rgchBuffer[MAX_ELEMENTS_PER_BUCKET * 22 + 200];
    DWORD cch;
    DWORD i;

    cch = wsprintf( rgchBuffer,
                    "HTB_ELEMENT(%p)  # Elements %4d; "
                    "Flink: %p  Blink: %p\n"
                    ,
                    this, m_nElements,
                    m_ListEntry.Flink, m_ListEntry.Blink);

    if ( level > 0) {

        // NYI: I need to walk down the entire array.
        // Not just the first few entries
        for( i = 0; i < m_nElements; i++) {

            phtbeEntry = &m_rgElements[i];
            cch += wsprintf( rgchBuffer + cch,
                             "  %08x %p",
                         phtbeEntry->m_hashValue,
                             phtbeEntry->m_phte
                             );
            if ( i % 4 == 0) {
                rgchBuffer[cch++] = '\n';
                rgchBuffer[cch] = '\0';
            }
        } // for
    }

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));
    return;
} // HTB_ELEMENT::Print()



/************************************************************
 *    Member Functions of HASH_TABLE_BUCKET
 ************************************************************/

HASH_TABLE_BUCKET::HASH_TABLE_BUCKET(VOID)
    : m_nEntries ( 0),
      m_htbeFirst()
{
    InitializeListHead( &m_lHead);
    InitializeCriticalSection( & m_csLock);
    SET_CRITICAL_SECTION_SPIN_COUNT( &m_csLock, IIS_DEFAULT_CS_SPIN_COUNT);
} // HASH_TABLE_BUCKET::HASH_TABLE_BUCKET()


HASH_TABLE_BUCKET::~HASH_TABLE_BUCKET( VOID)
{
    PLIST_ENTRY pl;
    PHTB_ELEMENT phtbe;

    // Free up the elements in the list
    Lock();
    while ( !IsListEmpty( &m_lHead)) {
        pl = RemoveHeadList( &m_lHead);
        phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT, m_ListEntry);
        delete phtbe;
    } // while

    m_htbeFirst.Cleanup();
    Unlock();

    DeleteCriticalSection( &m_csLock);
} // HASH_TABLE_BUCKET::~HASH_TABLE_BUCKET()



HT_ELEMENT *
HASH_TABLE_BUCKET::Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey)
{
    HT_ELEMENT * phte;

    Lock();
    // 1. search in the first bucket
    phte = m_htbeFirst.Lookup( hashValue, pszKey, cchKey);

    if ( NULL == phte ) {

        // 2. search in the auxiliary buckets
        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink; (phte == NULL) && (pl != &m_lHead);
              pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl,
                                                     HTB_ELEMENT,
                                                     m_ListEntry);
            phte = phtbe->Lookup( hashValue, pszKey, cchKey);
        } // for
    }

    Unlock();

    return (phte);
} // HASH_TABLE_BUCKET::Lookup()


BOOL
HASH_TABLE_BUCKET::Insert( IN DWORD hashValue,
                           IN HT_ELEMENT * phte,
                           IN BOOL fCheckForDuplicate)
{
    BOOL fReturn = FALSE;

    if ( fCheckForDuplicate) {

        Lock();

        // do a lookup and find out if this data exists.
        HT_ELEMENT * phteLookedup = Lookup( hashValue,
                                            phte->QueryKey(),
                                            phte->QueryKeyLen()
                                            );

        if ( NULL != phteLookedup) {
            // the element is already present - return failure

            DerefAndKillElement( phteLookedup);
        }

        Unlock();

        if ( NULL != phteLookedup) {
            SetLastError( ERROR_DUP_NAME);
            return ( FALSE);
        }
    }

    Lock();

    // 1. try inserting in the first bucket chunk, if possible
    if ( m_htbeFirst.IsSpaceAvailable()) {

        fReturn = m_htbeFirst.Insert( hashValue, phte);
    } else {

        // 2. Find the first chunk that has space and insert it there.
        PLIST_ENTRY pl;
        HTB_ELEMENT * phtbe;

        for ( pl = m_lHead.Flink; (pl != &m_lHead);
              pl = pl->Flink) {

            phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT, m_ListEntry);

            if ( phtbe->IsSpaceAvailable()) {
                fReturn = phtbe->Insert( hashValue, phte);
                break;
            }
        } // for

        if ( !fReturn ) {

            //
            // We ran out of space.
            // Allocate a new bucket and insert the new element.
            //

            phtbe = new HTB_ELEMENT();
            if ( NULL != phtbe) {

                // add the bucket to the list of buckets and
                // then add the element to the bucket
                InsertTailList( &m_lHead, &phtbe->m_ListEntry);
                fReturn = phtbe->Insert(hashValue, phte);
            } else {

                IF_DEBUG( ERROR) {
                    DBGPRINTF(( DBG_CONTEXT,
                                " HTB(%08x)::Insert: Unable to add a chunk\n",
                                this));
                }
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    Unlock();

    return ( fReturn);
} // HASH_TABLE_BUCKET::Insert()



BOOL
HASH_TABLE_BUCKET::Delete( IN HT_ELEMENT * phte)
{
    BOOL fReturn = FALSE;


    // We do not know which bucket this element belongs to.
    // So we should try all chunks to delete this element.

    Lock();

    // 1. try deleting the element from first bucket chunk, if possible
    fReturn = m_htbeFirst.Delete( phte);

    if (!fReturn) {

        // it was not on the first bucket chunk.

        // 2. Find the first chunk that might contain this element
        // and delete it.
        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink;
              !fReturn && (pl != &m_lHead);
              pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl,
                                                     HTB_ELEMENT,
                                                     m_ListEntry);
            fReturn = phtbe->Delete( phte);
        } // for

        // the element should have been in the hash table,
        // otherwise the app is calling with wrong entry
        DBG_ASSERT( fReturn);
    }

    Unlock();

    return ( fReturn);
} // HASH_TABLE_BUCKET::Delete()


DWORD
HASH_TABLE_BUCKET::NumEntries( VOID)
{
    DWORD nEntries;

    Lock();

    nEntries = m_htbeFirst.NumElements();

    PLIST_ENTRY pl;

    for ( pl = m_lHead.Flink;
          (pl != &m_lHead);
          pl = pl->Flink) {

        HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                 m_ListEntry);
        nEntries += phtbe->NumElements();
    } // for

    Unlock();

    return (nEntries);

} // HASH_TABLE_BUCKET::NumEntries()


DWORD
HASH_TABLE_BUCKET::InitializeIterator( IN HT_ITERATOR * phti)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;

    //
    // find the first chunk that has a valid element.
    // if we find one, leave the lock on for subsequent accesses.
    // CloseIterator will shut down the lock
    // If we do not find one, we should unlock and return
    //

    phti->nChunkId = NULL;
    phti->nPos = 0;

    Lock();
    if ( m_htbeFirst.NumElements() > 0) {
        phti->nChunkId = (DWORD_PTR) &m_htbeFirst;
        dwErr = NO_ERROR;
    } else {

        // find the first chunk that has an element

        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink; (pl != &m_lHead); pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                     m_ListEntry);
            if ( phtbe->NumElements() > 0) {
                phti->nChunkId = (DWORD_PTR) phtbe;
                dwErr = NO_ERROR;
                break;
            }
        } // for
    }

    // if we did not find any elements, then unlock and return
    // Otherwise leave the unlocking to the CloseIterator()
    if ( dwErr == ERROR_NO_MORE_ITEMS) {

        // get out of this bucket completely.
        Unlock();
    }

    return ( dwErr);

} // HASH_TABLE_BUCKET::InitializeIterator()


DWORD
HASH_TABLE_BUCKET::FindNextElement( IN HT_ITERATOR * phti,
                                    OUT HT_ELEMENT ** pphte)
{
    //  this function should be called only when the bucket is locked.

    DWORD dwErr;
    HTB_ELEMENT * phtbe = (HTB_ELEMENT * )phti->nChunkId;

    //
    // phti contains the <chunk, pos> from which we should start scan for
    //   next element.
    //

    DBG_ASSERT( NULL != phtbe);
    dwErr = phtbe->FindNextElement( &phti->nPos, pphte);

    if ( ERROR_NO_MORE_ITEMS == dwErr ) {

        // scan the rest of the chunks for next element

        PLIST_ENTRY pl = ((phtbe == &m_htbeFirst) ? m_lHead.Flink :
                          phtbe->m_ListEntry.Flink);

        for ( ; (pl != &m_lHead); pl = pl->Flink) {

            phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                       m_ListEntry);
            if ( phtbe->NumElements() > 0) {
                phti->nPos = 0;
                dwErr = phtbe->FindNextElement( &phti->nPos, pphte);
                DBG_ASSERT( NO_ERROR == dwErr);
                phti->nChunkId = (DWORD_PTR) phtbe;
                break;
            }
        } // for
    }

    if ( dwErr == ERROR_NO_MORE_ITEMS) {

        phti->nChunkId = (DWORD ) NULL;
    }

    return ( dwErr);
} // HASH_TABLE_BUCKET::FindNextElement()


DWORD
HASH_TABLE_BUCKET::CloseIterator( IN HT_ITERATOR * phti)
{
    // just unlock the current bucket.
    Unlock();

    return ( NO_ERROR);
} // HASH_TABLE_BUCKET::CloseIterator()


VOID
HASH_TABLE_BUCKET::Print( IN DWORD level)
{
    Lock();
    DBGPRINTF(( DBG_CONTEXT,
                "\n\nHASH_TABLE_BUCKET (%08x): Head.Flink=%08x; Head.Blink=%08x\n"
                " Bucket Chunk # 0:\n"
                ,
                this, m_lHead.Flink, m_lHead.Blink
                ));

    m_htbeFirst.Print( level);

    if ( level > 0) {
        PLIST_ENTRY pl;
        DWORD i;

        for ( pl = m_lHead.Flink, i = 1;
              (pl != &m_lHead);
              pl = pl->Flink, i++) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                     m_ListEntry);
            DBGPRINTF(( DBG_CONTEXT, "\n Bucket Chunk # %d\n", i));
            phtbe->Print( level);
        } // for
    }

    Unlock();
    return;
} // HASH_TABLE_BUCKET::Print()




/************************************************************
 *    Member Functions of HASH_TABLE
 ************************************************************/

HASH_TABLE::HASH_TABLE( IN DWORD   nBuckets,
                        IN LPCSTR  pszIdentifier,
                        IN DWORD   dwHashTableFlags
                        )
    : m_nBuckets   ( nBuckets),
      m_dwFlags    ( dwHashTableFlags),
      m_nEntries   ( 0),
      m_nLookups   ( 0),
      m_nHits      ( 0),
      m_nInserts   ( 0),
      m_nFlushes   ( 0)
{
    if ( NULL != pszIdentifier) {

        lstrcpynA( m_rgchId, pszIdentifier, sizeof( m_rgchId));
    }

    m_prgBuckets = new HASH_TABLE_BUCKET[nBuckets];

} // HASH_TABLE::HASH_TABLE()



DWORD
HASH_TABLE::CalculateHash( IN LPCSTR pszKey, DWORD cchKey) const
{
    DWORD hash = 0;

    DBG_ASSERT( pszKey != NULL );

    if ( cchKey > 8) {
        //
        // hash the last 8 characters
        //
        pszKey = (pszKey + cchKey - 8);
    }

    while ( *pszKey != '\0') {

        //
        // This is an extremely slimey way of getting upper case.
        // Kids, don't try this at home
        // -johnson
        //

        DWORD ch = ((*pszKey++) & ~0x20);

        // NYI: this is a totally pipe-line unfriendly code. Improve this.
        hash <<= 2;
        hash ^= ch;
        hash += ch;
    } // while

    //
    // Multiply by length (to introduce some randomness.  Murali said so.
    //

    return( hash * cchKey);
} // CalculateHash()


VOID
HASH_TABLE::Cleanup(VOID)
{
    if ( NULL != m_prgBuckets ) {

        delete [] m_prgBuckets;
        m_prgBuckets = NULL;
    }

} // HASH_TABLE::Cleanup()



# define INCREMENT_LOOKUPS()  \
       { InterlockedIncrement( (LPLONG ) &m_nLookups); }

# define INCREMENT_HITS( phte)  \
       if ( NULL != phte) { InterlockedIncrement( (LPLONG ) &m_nHits); }

# define INCREMENT_INSERTS()  \
       { InterlockedIncrement( (LPLONG ) &m_nInserts); }

# define INCREMENT_FLUSHES()  \
       { InterlockedIncrement( (LPLONG ) &m_nFlushes); }

# define INCREMENT_ENTRIES( fRet)  \
       if ( fRet) { InterlockedIncrement( (LPLONG ) &m_nEntries); }

# define DECREMENT_ENTRIES( fRet)  \
       if ( fRet) { InterlockedDecrement( (LPLONG ) &m_nEntries); }

HT_ELEMENT *
HASH_TABLE::Lookup( IN LPCSTR pszKey, DWORD cchKey)
{
    // 1. Calculate the hash value for pszKey
    // 2. Find the bucket for the hash value
    // 3. Search for given item in the bucket
    // 4. return the result, after updating statistics

    DWORD hashVal = CalculateHash( pszKey, cchKey);
    HT_ELEMENT * phte;

    INCREMENT_LOOKUPS();

    DBG_ASSERT( NULL != m_prgBuckets);
    phte = m_prgBuckets[hashVal % m_nBuckets].Lookup( hashVal, pszKey, cchKey);

    INCREMENT_HITS( phte);

    return ( phte);
} // HASH_TABLE::Lookup()


BOOL
HASH_TABLE::Insert( HT_ELEMENT * phte, IN BOOL fCheckBeforeInsert)
{
    // 1. Calculate the hash value for key of the HT_ELEMENT object
    // 2. Find the bucket for the hash value
    // 3. Check if this item is not already present and insert
    //     it into the hash table.
    //  (the check can be bypassed if fCheck is set to FALSE)
    // 4. return the result, after updating statistics

    DWORD hashVal = CalculateHash( phte->QueryKey());
    BOOL  fRet;

    INCREMENT_INSERTS();

    DBG_ASSERT( NULL != m_prgBuckets);
    fRet = m_prgBuckets[hashVal % m_nBuckets].Insert( hashVal,
                                                      phte,
                                                      fCheckBeforeInsert);

    IF_DEBUG( ERROR) {
        if ( !fRet) {
            DBGPRINTF(( DBG_CONTEXT,
                        " Unable to insert %08x into bucket %d."
                        "  Bucket has %d elements. Error = %d\n",
                        phte, hashVal % m_nBuckets,
                        m_prgBuckets[hashVal % m_nBuckets].NumEntries(),
                        GetLastError()
                        ));
        }
    }
    INCREMENT_ENTRIES( fRet);

    return ( fRet);
} // HASH_TABLE::Insert()



BOOL
HASH_TABLE::Delete( HT_ELEMENT * phte)
{
    BOOL  fRet;
    DWORD hashVal = CalculateHash( phte->QueryKey(), phte->QueryKeyLen());

    DBG_ASSERT( NULL != m_prgBuckets);
    fRet = m_prgBuckets[hashVal % m_nBuckets].Delete( phte);

    DECREMENT_ENTRIES( fRet);

    return ( fRet);
} // HASH_TABLE::Delete()



VOID
HASH_TABLE::Print( IN DWORD level)
{
    DWORD i;

    DBGPRINTF(( DBG_CONTEXT,
                "HASH_TABLE(%08x) "
                "%s: nBuckets = %d; dwFlags = %d;"
                " nEntries = %d; nLookups = %d; nHits = %d;"
                " nInserts = %d; nFlushes = %d;"
                " m_prgBuckets = %d\n",
                this, m_rgchId, m_nBuckets, m_dwFlags,
                m_nEntries, m_nLookups, m_nHits, m_nInserts,
                m_nFlushes, m_prgBuckets));

    if ( level == 0 ) {

        CHAR rgchBuff[2000];
        DWORD cch;

        cch = wsprintfA( rgchBuff, "\tBucket  NumEntries\n");
        DBG_ASSERT( NULL != m_prgBuckets);
        for (i = 0; i < m_nBuckets; i++) {

            cch += wsprintf( rgchBuff + cch, "\t[%4d]  %4d,\n",
                             i, m_prgBuckets[i].NumEntries());
        } // for

        DBGDUMP(( DBG_CONTEXT, rgchBuff));
    } else {

        DBG_ASSERT( NULL != m_prgBuckets);
        for (i = 0; i < m_nBuckets; i++) {

            m_prgBuckets[i].Print( level);
        } // for
    }

    return;
} // HASH_TABLE::Print()



DWORD
HASH_TABLE::InitializeIterator( IN HT_ITERATOR * phti)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);

    // initialize the iterator
    phti->nBucketNumber = INFINITE;
    phti->nChunkId = NULL;
    phti->nPos = 0;

    if ( m_nEntries > 0) {
        // set the iterator to point to the first bucket with some elements.
        for ( DWORD i = 0; (i < m_nBuckets); i++) {

            dwErr = m_prgBuckets[i].InitializeIterator( phti);
            if ( dwErr == NO_ERROR) {
                phti->nBucketNumber = i;
                break;
            }
        }
    }

    return ( dwErr);
} // HASH_TABLE::InitializeIterator()


DWORD
HASH_TABLE::FindNextElement( IN HT_ITERATOR * phti,
                             OUT HT_ELEMENT ** pphte)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);
    DBG_ASSERT( NULL != pphte);

    if ( INFINITE != phti->nBucketNumber) {

        // iterator has some valid state use it.
        DBG_ASSERT( phti->nBucketNumber < m_nBuckets);

        dwErr =
            m_prgBuckets[ phti->nBucketNumber].FindNextElement( phti, pphte);

        if ( ERROR_NO_MORE_ITEMS == dwErr) {

            DBG_REQUIRE( m_prgBuckets[ phti->nBucketNumber].
                            CloseIterator( phti)
                         == NO_ERROR
                        );

            // hunt for the next bucket with an element.
            for ( DWORD i = (phti->nBucketNumber + 1); (i < m_nBuckets); i++) {

                dwErr = m_prgBuckets[i].InitializeIterator( phti);

                if ( dwErr == NO_ERROR) {
                    phti->nBucketNumber = i;
                    dwErr = m_prgBuckets[ i].FindNextElement( phti, pphte);
                    DBG_ASSERT( dwErr == NO_ERROR);
                    break;
                }
            } // for

            if ( ERROR_NO_MORE_ITEMS == dwErr) {
                // reset the bucket number
                phti->nBucketNumber = INFINITE;
            }
        }
    }

    return ( dwErr);
} // HASH_TABLE::FindNextElement()


DWORD
HASH_TABLE::CloseIterator( IN HT_ITERATOR * phti)
{
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);

    if ( INFINITE != phti->nBucketNumber) {
        DBG_ASSERT( phti->nBucketNumber < m_nBuckets);
        DBG_REQUIRE( m_prgBuckets[ phti->nBucketNumber].
                     CloseIterator( phti)
                     == NO_ERROR
                     );
        phti->nBucketNumber = INFINITE;
    }

    return ( NO_ERROR);
} // HASH_TABLE::CloseIterator()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\inetsvcs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetsvcs.h

Abstract:

    Header file for Internet Services common data/functions.

Author:

    Murali R. Krishnan (MuraliK)   20-Feb-1996  - Migrated from old tcpsvcs.h

Revision History:

--*/

#ifndef _INETSVCS_H_
#define _INETSVCS_H_

//
// Service DLLs are loaded into master service executable (eg: inetinfo.exe)
//   All the dlls should export this entry point
//    defined by INETSVCS_ENTRY_POINT
//
// Note that INETSVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//

#define INETSVCS_ENTRY_POINT         ServiceEntry
#define INETSVCS_ENTRY_POINT_STRING  "ServiceEntry"

//
// Start and stop RPC server entry point prototype.
//

typedef
DWORD
(*PTCPSVCS_START_RPC_SERVER_LISTEN) (
    VOID
    );

typedef
DWORD
(*PTCPSVCS_STOP_RPC_SERVER_LISTEN) (
    VOID
    );

//
// Structure containing "global" data for the various DLLs.
//

typedef struct _TCPSVCS_GLOBAL_DATA {

    //
    // Entry points provided by TCPSVCS.EXE.
    //

    PTCPSVCS_START_RPC_SERVER_LISTEN  StartRpcServerListen;
    PTCPSVCS_STOP_RPC_SERVER_LISTEN   StopRpcServerListen;

} TCPSVCS_GLOBAL_DATA, *PTCPSVCS_GLOBAL_DATA;

//
// Service DLL entry point prototype.
//

typedef
VOID
(*PINETSVCS_SERVICE_DLL_ENTRY) (
    IN DWORD argc,
    IN LPSTR argv[],
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    );


#if DBG
#define IIS_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define IIS_PRINTF( x )
#endif

#define BUG_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }


#define INIT_LOCK(_lock)        InitializeCriticalSection( _lock );
#define DELETE_LOCK(_lock)      DeleteCriticalSection( _lock );
#define ACQUIRE_LOCK(_lock)     EnterCriticalSection( _lock );
#define RELEASE_LOCK(_lock)     LeaveCriticalSection( _lock );

//
// Event used to indicate whether service is running as exe
//

#define IIS_AS_EXE_OBJECT_NAME  "Internet_infosvc_as_exe"


#endif	// ifndef _INETSVCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\sched.cxx ===
/*++
   Copyright    (c)    1995-1996     Microsoft Corporation

   Module Name:

       sched.cxx

   Abstract:

        This module contains a simple timer interface for scheduling future
        work items


   Author:

        John Ludeman    (johnl)     17-Jul-1995

   Project:

        Internet Servers Common Server DLL

   Revisions:
        Murali R. Krishnan  (MuraliK)     16-Sept-1996
          Added scheduler items cache
--*/

//
//  Include Headers
//

#include "isatq.hxx"
#include "sched.hxx"

//
//  Global definitions
//

#define LockScheduleList()      EnterCriticalSection( &csSchedulerLock )
#define UnlockScheduleList()    LeaveCriticalSection( &csSchedulerLock )

#define NUM_SCHEDULE_THREADS_PWS        1
#define NUM_SCHEDULE_THREADS_NTS        1

ALLOC_CACHE_HANDLER * SCHED_ITEM::sm_pachSchedItems = NULL;

SCHED_ITEM_STATE sg_rgSchedNextState[SI_OP_MAX][SI_MAX_ITEMS] = {
    // operation = SI_OP_ADD
    {
        SI_ERROR,
        SI_ACTIVE,
        SI_ERROR,
        SI_ERROR,
        SI_ERROR,
        SI_ERROR,
    },

    // operation = SI_OP_ADD_PERIODIC
    {
        SI_ERROR,
        SI_ACTIVE_PERIODIC,
        SI_ERROR,
        SI_ERROR,
        SI_ACTIVE_PERIODIC,  // rescheduling periodic item
        SI_ERROR,
    },

    // operation = SI_OP_CALLBACK
    {
        SI_ERROR,
        SI_ERROR,
        SI_TO_BE_DELETED,  // to be removed after completing callbacks
        SI_CALLBACK_PERIODIC,
        SI_ERROR,
        SI_ERROR,
    },

    // operation = SI_OP_DELETE
    {
        SI_ERROR,
        SI_ERROR,
        SI_IDLE,
        SI_IDLE,
        SI_TO_BE_DELETED,  // mark this to be deleted after return
        SI_TO_BE_DELETED,  // idempotent delete operations
    }
};



SCHED_ITEM *
I_FindSchedulerItem( DWORD dwCookie);

VOID
I_InsertIntoWorkItemList( SCHED_ITEM * psi);


DWORD
SchedulerThread(
    LPDWORD lpdwParam
    );

//
//  Global data items
//

LIST_ENTRY        ScheduleListHead;
CRITICAL_SECTION  csSchedulerLock;
BOOL              fSchedulerInitialized = FALSE;
BOOL              fSchedShutdown = FALSE;
HANDLE            hSchedulerEvent;
DWORD             cSchedThreads = 0;

//
//  Used as identification cookie for removing items
//

DWORD             dwSchedSerial = 0;


/************************************************************
 *  Public functions of Scheduler
 ************************************************************/



BOOL
SchedulerInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the scheduler/timer package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    DWORD   idThread;
    DWORD   i;
    DWORD   numThreads;

    if ( fSchedulerInitialized ) {
        return TRUE;
    }

    InitializeSecondsTimer();

    hSchedulerEvent = IIS_CREATE_EVENT(
                          "hSchedulerEvent",
                          &hSchedulerEvent,
                          FALSE,
                          FALSE
                          );

    if ( hSchedulerEvent == NULL ) {
        return FALSE;
    }

    if ( TsIsNtServer() ) {
        numThreads = NUM_SCHEDULE_THREADS_NTS;
    } else {
        numThreads = NUM_SCHEDULE_THREADS_PWS;
    }

    InitializeCriticalSection( &csSchedulerLock );
    SET_CRITICAL_SECTION_SPIN_COUNT( &csSchedulerLock,
                                     IIS_DEFAULT_CS_SPIN_COUNT);

    InitializeListHead( &ScheduleListHead );

    for ( i = 0; i < numThreads; i++ ) {

        HANDLE hSchedulerThread;

        hSchedulerThread =
            CreateThread( NULL,
                          0,
                          (LPTHREAD_START_ROUTINE) SchedulerThread,
                          NULL,
                          0,
                          &idThread );

        if ( !hSchedulerThread ) {
            DeleteCriticalSection( &csSchedulerLock );
            CloseHandle( hSchedulerEvent );
            return FALSE;
        }

        DBG_REQUIRE( CloseHandle( hSchedulerThread ));

        cSchedThreads++;
    }

    DBG_REQUIRE( SCHED_ITEM::Initialize());

    fSchedulerInitialized = TRUE;

    return TRUE;
} // SchedulerInitialize()



VOID
SchedulerTerminate(
    VOID
    )
/*++

Routine Description:

    Terminates and cleans up the scheduling package.  Any items left on the
    list are *not* called during cleanup.

--*/
{
    DWORD iRetry;

    if ( !fSchedulerInitialized || fSchedShutdown) {
        // either uninitialized or already shutting down
        return;
    }

    fSchedShutdown = TRUE;

    DBG_REQUIRE( SetEvent( hSchedulerEvent ) );

    LockScheduleList();

    //
    //  Delete all of the items that were scheduled, note we do *not*
    //  call any scheduled items in the list (there shouldn't be any)
    //

    if ( !IsListEmpty( &ScheduleListHead ) ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "[SchedulerTerminate] Warning - Items in schedule list "
                    "at termination\n" ));
    }

    UnlockScheduleList();

    //
    // If this function is called from DLL terminate, then the threads are dead
    //  So try finite times and give up
    // loop and wait for scheduler thread to die out
    //

    for ( iRetry = 0; cSchedThreads && (iRetry < 5); iRetry++) {

        //
        // Set the event again, so that some other thread will wake up and die
        //

        DBG_REQUIRE( SetEvent( hSchedulerEvent ) );
        Sleep( 100 );  // give some time for thread to die out
    } // for

    DeleteCriticalSection( &csSchedulerLock );
    CloseHandle( hSchedulerEvent );

    SCHED_ITEM::Cleanup();
    fSchedulerInitialized = FALSE;
} // SchedulerTerminate()



DWORD
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTime,
    BOOL               fPeriodic
    )
/*++

Routine Description:

    Adds a timed work item to the work list

Arguments:

    pfnCallback - Function to call
    pContext - Context to pass to the callback
    msecTime - number of milliseconds to wait before calling timeout
    nPriority - Thread priority to set for work item

Return Value:

    zero on failure, non-zero on success.  The return value can be used to
    remove the scheduled work item.

--*/
{
    SCHED_ITEM * psi;
    DWORD        dwRet;

    ATQ_ASSERT( fSchedulerInitialized );

    //
    // 1. alloc a new scheduler item
    //

    psi = new SCHED_ITEM( pfnCallback,
                          pContext,
                          msecTime,
                          ++dwSchedSerial );

    if ( !psi ) {

        //
        // unable to create the item - return error cookie '0'
        //

        return 0;
    }

    dwRet = psi->_dwSerialNumber;
    SCHED_OPS  siop = ((fPeriodic)? SI_OP_ADD_PERIODIC : SI_OP_ADD);
    psi->_siState = sg_rgSchedNextState[siop][SI_IDLE];

    //
    // 2. Insert the scheduler item into the active scheduler work-items list.
    //

    LockScheduleList();
    I_InsertIntoWorkItemList( psi);
    UnlockScheduleList();

    //
    // 3. Indicate to scheduler threads that there is one new item on the list
    //

    DBG_REQUIRE( SetEvent( hSchedulerEvent ));

    return dwRet;
} // ScheduleWorkItem()



BOOL
RemoveWorkItem(
    DWORD  dwCookie
    )
/*++

Routine Description:

    Removes a scheduled work item

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem

Return Value:

    TRUE if the item was found, FALSE if the item was not found.

--*/
{
    SCHED_ITEM * psi;
    BOOL fWait = FALSE;

    //
    // 1. lock the list
    //

    LockScheduleList();

    //
    // 2. Find scheduler item on the list.
    //

    psi = I_FindSchedulerItem( dwCookie);

    if ( NULL != psi) {

        //
        // 3. based on the state of the item take necessary actions.
        //

        SCHED_ITEM_STATE st =
            sg_rgSchedNextState[SI_OP_DELETE][psi->_siState];
        psi->_siState = st;
        switch ( st) {
        case SI_IDLE: {
            // delete immediately
            RemoveEntryList( &psi->_ListEntry );
            psi->_ListEntry.Flink = NULL;
            delete psi;
            break;
        }

        case SI_TO_BE_DELETED: {

            DBGPRINTF(( DBG_CONTEXT,
                        "SchedItem(%08x) marked to be deleted\n",
                        psi));
            // item will be deleted later.

            if (psi->FInsideCallbackOnOtherThread()) {
                // need to wait till callback complete
                psi->AddEvent();
                fWait = TRUE;
            }
            break;
        }

        default:
            DBG_ASSERT( FALSE);
            break;
        } // switch()
    }

    // 4. Unlock the list
    UnlockScheduleList();

    // 5. Wait for callback event and release the item
    if (fWait)
        psi->WaitForEventAndRelease();

    // return TRUE if we found the item
    return ( NULL != psi);
} // RemoveWorkItem()





DWORD
ScheduleAdjustTime(
    DWORD dwCookie,
    DWORD msecNewTime
    )
/*++
  This function finds the scheduler object for given cookie and changes
  the interval for next timeout of the item.

--*/
{
    SCHED_ITEM * psi;

    DBG_ASSERT( 0 != dwCookie);

    LockScheduleList();
    // 1. Find the work item for given cookie
    psi = I_FindSchedulerItem( dwCookie);

    if ( NULL != psi) {

        // 2. Remove the item from the list
        RemoveEntryList( &psi->_ListEntry );
        psi->_ListEntry.Flink = NULL;

        // 2. Change the timeout value

        psi->ChangeTimeInterval( msecNewTime);

        // 3. Recalc expiry time and reinsert into the list of work items.
        psi->CalcExpiresTime();
        I_InsertIntoWorkItemList( psi);
    }

    UnlockScheduleList();

    // 4. Indicate to scheduler threads that there is one new item on the list
    DBG_REQUIRE( SetEvent( hSchedulerEvent ));

    return ( (NULL != psi) ? NO_ERROR : ERROR_INVALID_PARAMETER);
} // ScheduleAdjustTime()



/************************************************************
 *  Internal functions of Scheduler
 ************************************************************/



VOID
I_InsertIntoWorkItemList( SCHED_ITEM * psi)
{
    SCHED_ITEM * psiList;
    LIST_ENTRY * pEntry;

    DBG_ASSERT( NULL != psi);

    DBG_ASSERT( (psi->_siState == SI_ACTIVE) ||
                (psi->_siState == SI_ACTIVE_PERIODIC) ||
                (psi->_siState == SI_CALLBACK_PERIODIC ) );

    // Assumed that the scheduler list is locked.

    //
    //  Insert the list in order based on expires time
    //

    for ( pEntry =  ScheduleListHead.Flink;
          pEntry != &ScheduleListHead;
          pEntry =  pEntry->Flink )
    {
        psiList = CONTAINING_RECORD( pEntry, SCHED_ITEM, _ListEntry );

        if ( psiList->_msecExpires > psi->_msecExpires )
        {
            break;
        }
    }

    //
    // Insert the item psi in front of the item pEntry
    //  This should work in whether the list is empty or this is the last item
    //  on the list
    //

    psi->_ListEntry.Flink = pEntry;
    psi->_ListEntry.Blink = pEntry->Blink;

    pEntry->Blink->Flink = &psi->_ListEntry;
    pEntry->Blink        = &psi->_ListEntry;

    return;
} // I_InsertIntoWorkItemList()


SCHED_ITEM *
I_FindSchedulerItem( DWORD dwCookie)
{
    PLIST_ENTRY  pEntry;
    SCHED_ITEM * psi = NULL;

    // Should be called with the scheduler list locked.

    for ( pEntry =  ScheduleListHead.Flink;
          pEntry != &ScheduleListHead;
          pEntry = pEntry->Flink )
    {
        psi = CONTAINING_RECORD( pEntry, SCHED_ITEM, _ListEntry );

        ATQ_ASSERT( psi->CheckSignature() );

        if ( dwCookie == psi->_dwSerialNumber ) {

            // found the match - return
            return ( psi);
        }
    } // for

    return ( NULL);
} // I_FindSchedulerItem()



DWORD
SchedulerThread(
    LPDWORD lpdwParam
    )
/*++

Routine Description:

    Initializes the scheduler/timer package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    DWORD        cmsecWait = INFINITE;
    __int64      TickCount;
    SCHED_ITEM * psi, * psiExpired;
    LIST_ENTRY * pEntry;
    BOOL         fListLocked = FALSE;
    DWORD        dwWait = 0;

    while (!fSchedShutdown) {

        ATQ_ASSERT(!fListLocked); // the list must be unlocked here

        while ( TRUE ) {

            MSG msg;

            //
            // Need to do MsgWait instead of WaitForSingleObject
            // to process windows msgs.  We now have a window
            // because of COM.
            //

            dwWait = MsgWaitForMultipleObjects( 1,
                                             &hSchedulerEvent,
                                             FALSE,
                                             cmsecWait,
                                             QS_ALLINPUT );

            if (fSchedShutdown) {
                goto exit;
            }

            if ( (dwWait == WAIT_OBJECT_0) ||
                 (dwWait == WAIT_TIMEOUT) ) {
                break;
            }

            while ( PeekMessage( &msg,
                                 NULL,
                                 0,
                                 0,
                                 PM_REMOVE ))
            {
                DispatchMessage( &msg );
            }
        }

        switch (dwWait) {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "[Scheduler] Error %d waiting on SchedulerEvent\n",
                        GetLastError() ));
            //  Fall through

        case WAIT_OBJECT_0:
            //  Means a new item has been scheduled, reset the timeout or
            //  we are shutting down

            LockScheduleList();
            fListLocked = TRUE;

            //  Get the timeout value for the first item in the list

            if (!IsListEmpty(&ScheduleListHead)) {
                psi = CONTAINING_RECORD( ScheduleListHead.Flink,
                                         SCHED_ITEM,
                                         _ListEntry );

                ATQ_ASSERT(psi->CheckSignature());

                //  Make sure the front item hasn't already expired

                TickCount = GetCurrentTimeInMilliseconds();

                if (TickCount > psi->_msecExpires) {
                    //  Run scheduled items
                    break;
                }

                // the delay is guaranteed NOT to be > 1<<32
                // as per parameter to SCHED_ITEM constructor

                cmsecWait = (DWORD)(psi->_msecExpires - TickCount);
            }
            else {
                cmsecWait = INFINITE;
            }

            UnlockScheduleList();
            fListLocked = FALSE;

            // Wait for something else (back to sleep)
            continue;

        case WAIT_TIMEOUT:
            //  Run scheduled items
            break;
        }

        //  Run scheduled items

        while (!fSchedShutdown) {
            //  Lock the list if needed

            if (!fListLocked) {
                LockScheduleList();
                fListLocked = TRUE;
            }

            //  No timeout by default (if no items found)

            cmsecWait = INFINITE;

            if (IsListEmpty(&ScheduleListHead))
                break;

            //  Find the first expired work item

            TickCount = GetCurrentTimeInMilliseconds();

            psiExpired = NULL;

            for ( pEntry  = ScheduleListHead.Flink;
                  pEntry != &ScheduleListHead;
                ) {
                psi = CONTAINING_RECORD(pEntry, SCHED_ITEM, _ListEntry);
                pEntry = pEntry->Flink;

                ATQ_ASSERT(psi->CheckSignature());

                if ( ((psi->_siState == SI_ACTIVE) ||
                      (psi->_siState == SI_ACTIVE_PERIODIC)) ) {

                    if (TickCount > psi->_msecExpires) {
                        //  Found Expired Item
                        psiExpired = psi;
                    }
                    else {
                        //  Since they are in sorted order once we hit one that's
                        //  not expired we don't need to look further
                        cmsecWait = (DWORD)(psi->_msecExpires - TickCount);
                    }
                    break;
                }
            }

            //  If no expired work items found, go back to sleep

            if (psiExpired == NULL) {
                break;
            }

            //  Take care of the found expired work item

            SCHED_ITEM_STATE st =
                sg_rgSchedNextState[SI_OP_CALLBACK][psiExpired->_siState];

            psiExpired->_siState = st;

            //  Take care of the NON-PERIODIC case

            if (st == SI_TO_BE_DELETED) { // non-periodic?

                //  Remove this item from the list
                RemoveEntryList( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                //  Unlock List
                ATQ_ASSERT(fListLocked);
                UnlockScheduleList();
                fListLocked = FALSE;

                //  Call callback funcitons
                psiExpired->_pfnCallback(psiExpired->_pContext);

                //  Get rid of the item regardless of state
                delete psiExpired;
                //  Find next expired item
                continue;
            }

            //  Take care of the PERIODIC case

            DBG_ASSERT(st == SI_CALLBACK_PERIODIC);

            psiExpired->_dwCallbackThreadId = GetCurrentThreadId();

            //  Unlock the list while in the callback
            ATQ_ASSERT(fListLocked);
            UnlockScheduleList();
            fListLocked = FALSE;

            //  While in PERIODIC callback the list is kept unlocked
            //  leaving the object exposed

            psiExpired->_pfnCallback( psiExpired->_pContext );

            //  Relock the list
            ATQ_ASSERT(!fListLocked);
            LockScheduleList();
            fListLocked = TRUE;

            psiExpired->_dwCallbackThreadId = 0;

            //  While in the callback the state can change
            if (psiExpired->_siState == SI_TO_BE_DELETED) {
                //  User requested delete

                //  Remove this item from the list
                RemoveEntryList( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                //  While in callback RemoveWorkItem() could have attached
                //  an event to notify itself when callback is done
                if (psiExpired->_hCallbackEvent) {
                    //  Signal the event after item is gone from the list
                    SetEvent(psiExpired->_hCallbackEvent);
                    //  RemoveWorkItem() will remove the item
                }
                else {
                    //  Get rid of the item
                    delete psiExpired;
                }
            }
            else {
                // no events attached
                DBG_ASSERT(psiExpired->_hCallbackEvent == NULL);

                // must still remain SI_CALLBACK_PERIODIC unless deleted
                DBG_ASSERT(psiExpired->_siState == SI_CALLBACK_PERIODIC);

                // NYI: For now remove from the list and reinsert it
                RemoveEntryList( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                // recalc the expiry time and reinsert into the list
                psiExpired->_siState =
                    sg_rgSchedNextState[SI_OP_ADD_PERIODIC]
                                       [psiExpired->_siState];
                psiExpired->CalcExpiresTime();
                I_InsertIntoWorkItemList(psiExpired);
            }

            //  Start looking in the list from the beginning in case
            //  new items have been added or other threads removed
            //  them

        } // while

        if (fListLocked) {
            UnlockScheduleList();
            fListLocked = FALSE;
        }

    } // while

exit:
    InterlockedDecrement( (LONG *) &cSchedThreads );
    return 0;
} // SchedulerThread()



BOOL
SCHED_ITEM::Initialize( VOID)
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, 25, sizeof(SCHED_ITEM)};

    if ( NULL != sm_pachSchedItems) {

        // already initialized
        return ( TRUE);
    }

    sm_pachSchedItems = new ALLOC_CACHE_HANDLER( "SchedItems",
                                                 &acConfig);

    return ( NULL != sm_pachSchedItems);
} // SCHED_ITEM::Initialize()


VOID
SCHED_ITEM::Cleanup( VOID)
{
    if ( NULL != sm_pachSchedItems) {

        delete sm_pachSchedItems;
        sm_pachSchedItems = NULL;
    }

    return;
} // SCHED_ITEM::Cleanup()


VOID *
SCHED_ITEM::operator new( size_t s)
{
    DBG_ASSERT( s == sizeof( SCHED_ITEM));

    // allocate from allocation cache.
    DBG_ASSERT( NULL != sm_pachSchedItems);
    return (sm_pachSchedItems->Alloc());
} // SCHED_ITEM::operator new()

VOID
SCHED_ITEM::operator delete( void * psi)
{
    DBG_ASSERT( NULL != psi);

    // free to the allocation pool
    DBG_ASSERT( NULL != sm_pachSchedItems);
    DBG_REQUIRE( sm_pachSchedItems->Free(psi));

    return;
} // SCHED_ITEM::operator delete()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\reftrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging reference count problems. This module uses the generic
    TRACE_LOG facility in tracelog.h.

    Ref count trace logs can be dumped via the !inetdbg.ref command
    in either NTSD or CDB.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#ifndef _REFTRACE_H_
#define _REFTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


#include <tracelog.h>


//
// This is the number of stack backtrace values captured in each
// trace log entry. This value is chosen to make the log entry
// exactly eight dwords long, making it a bit easier to interpret
// from within the debugger without the debugger extension.
//

#define REF_TRACE_LOG_STACK_DEPTH   5


//
// This defines the entry written to the trace log.
//

typedef struct _REF_TRACE_LOG_ENTRY {

    LONG NewRefCount;
    PVOID Context;
    PVOID Context1;
    PVOID Context2;
    PVOID Context3;
    DWORD Thread;
    PVOID Stack[REF_TRACE_LOG_STACK_DEPTH];

} REF_TRACE_LOG_ENTRY, *PREF_TRACE_LOG_ENTRY;


//
// Manipulators.
//

PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    );

VOID
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Context3
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _REFTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\pudebug.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        pudebug.h

   Abstract:

      This module declares the DEBUG_PRINTS object helpful in
       testing the programs

   Author:

      Murali R. Krishnan    ( MuraliK )    14-Dec-1994
      Modified to include a and other functions ( 22-Dec-1994)

   Revision History:
      MuraliK  16-May-1995   Added function to read debug flags.
      MuraliK  12-Sept-1996  Added functions to dump the output.

--*/

# ifndef _PUDEBUG_H_
# define _PUDEBUG_H_


/************************************************************
 *     Include Headers
 ************************************************************/

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# include <windows.h>

/***********************************************************
 *    Macros
 ************************************************************/

enum  PRINT_REASONS {
    PrintNone     = 0x0,   // Nothing to be printed
    PrintError    = 0x1,   // An error message
    PrintWarning  = 0x2,   // A  warning message
    PrintLog      = 0x3,   // Just logging. Indicates a trace of where ...
    PrintMsg      = 0x4,   // Echo input message
    PrintCritical = 0x5,   // Print and Exit
    PrintAssertion= 0x6    // Printing for an assertion failure
  };


enum  DEBUG_OUTPUT_FLAGS {
    DbgOutputNone     = 0x0,            // None
    DbgOutputKdb      = 0x1,            // Output to Kernel Debugger
    DbgOutputLogFile  = 0x2,            // Output to LogFile
    DbgOutputTruncate = 0x4,            // Truncate Log File if necessary
    DbgOutputStderr   = 0x8,            // Send output to std error
    DbgOutputBackup   = 0x10,           // Make backup of debug file ?
    DbgOutputAll      = 0xFFFFFFFF      // All the bits set.
  };


# define MAX_LABEL_LENGTH                 ( 100)



/*++
  class DEBUG_PRINTS

  This class is responsible for printing messages to log file / kernel debugger

  Currently the class supports only member functions for <ANSI> char.
   ( not unicode-strings).

--*/

typedef struct _DEBUG_PRINTS {

    CHAR         m_rgchLabel[MAX_LABEL_LENGTH];
    CHAR         m_rgchLogFilePath[MAX_PATH];
    CHAR         m_rgchLogFileName[MAX_PATH];
    HANDLE       m_LogFileHandle;
    HANDLE       m_StdErrHandle;
    BOOL         m_fInitialized;
    DWORD        m_dwOutputFlags;

} DEBUG_PRINTS, FAR * LPDEBUG_PRINTS;



LPDEBUG_PRINTS
 PuCreateDebugPrintsObject(
   IN const char * pszPrintLabel,
   IN DWORD  dwOutputFlags);

//
// frees the debug prints object and closes any file if necessary.
//  Returns NULL on success or returns pDebugPrints on failure.
//

LPDEBUG_PRINTS
 PuDeleteDebugPrintsObject(
   IN OUT LPDEBUG_PRINTS  pDebugPrints);



VOID
 PuDbgPrint(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...);                               // arglist

/*++
  PuDbgDump() does not do any formatting of output.
  It just dumps the given message onto the debug destinations.
--*/

VOID
 PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   );

//
// PuDbgAssertFailed() *must* be __cdecl to properly capture the
// thread context at the time of the failure.
//


VOID
__cdecl
 PuDbgAssertFailed(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszExpression,
   IN const char *         pszMessage);


VOID
 PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    );

VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    );


VOID
 PuSetDbgOutputFlags(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN DWORD                dwFlags);


DWORD
 PuGetDbgOutputFlags(
   IN const LPDEBUG_PRINTS       pDebugPrints);


//
// Following functions return Win32 error codes.
// NO_ERROR if success
//


DWORD
 PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFileName,
   IN const char *         pszPathForFile);


DWORD
 PuReOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);


DWORD
 PuCloseDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);


DWORD
  PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault);

 DWORD
  PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault);


DWORD
  PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg);


# define PuPrintToKdb( pszOutput)    \
                    if ( pszOutput != NULL)   {   \
                        OutputDebugString( pszOutput);  \
                    } else {}



# ifdef __cplusplus
};
# endif // __cplusplus

// begin_user_unmodifiable

# if DBG


/***********************************************************
 *    Macros
 ************************************************************/


extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
 DEBUG_PRINTS  *  g_pDebug;        // define a global debug variable


# define DECLARE_DEBUG_PRINTS_OBJECT()          \
         DEBUG_PRINTS  *  g_pDebug = NULL;


//
// Call the following macro as part of your initialization for program
//  planning to use the debugging class.
//
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)  \
        g_pDebug = PuCreateDebugPrintsObject( pszLabel, DEFAULT_OUTPUT_FLAGS);\
         if  ( g_pDebug == NULL) {   \
               OutputDebugStringA( "Unable to Create Debug Print Object \n"); \
         }

//
// Call the following macro once as part of the termination of program
//    which uses the debugging class.
//
# define DELETE_DEBUG_PRINT_OBJECT( )  \
        g_pDebug = PuDeleteDebugPrintsObject( g_pDebug);


# define VALID_DEBUG_PRINT_OBJECT()     \
        ( ( g_pDebug != NULL) && g_pDebug->m_fInitialized)


//
//  Use the DBG_CONTEXT without any surrounding braces.
//  This is used to pass the values for global DebugPrintObject
//     and File/Line information
//
# define DBG_CONTEXT        g_pDebug, __FILE__, __LINE__



# define DBG_CODE(s)          s          /* echoes code in debugging mode */


# define DBG_ASSERT( exp)    if ( !(exp)) { \
                                 PuDbgAssertFailed( DBG_CONTEXT, #exp, NULL); \
                             } else {}

# define DBG_ASSERT_MSG( exp, pszMsg)    \
                             if ( !(exp)) { \
                                  PuDbgAssertFailed( DBG_CONTEXT, #exp, pszMsg); \
                              } else {}

# define DBG_REQUIRE( exp)    DBG_ASSERT( exp)

# define DBG_LOG()            PuDbgPrint( DBG_CONTEXT, "\n")

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)   \
                  PuOpenDbgPrintFile( g_pDebug, (pszFile), (pszPath))

# define DBG_CLOSE_LOG_FILE( )   \
                  PuCloseDbgPrintFile( g_pDebug)


//
//  DBGPRINTF() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DBGPRINTF( ( DBG_CONTEXT, format-string, arguments for format list);
//
# define DBGPRINTF( args)     PuDbgPrint args

# define DBGDUMP( args)       PuDbgDump  args

# define DBGPRINT_CURRENT_TIME()  PuDbgPrintCurrentTime( DBG_CONTEXT)

# else // DBG


# define DECLARE_DEBUG_PRINTS_OBJECT()           /* Do Nothing */
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)    ((void)0) /* Do Nothing */
# define DELETE_DEBUG_PRINT_OBJECT( )            ((void)0) /* Do Nothing */
# define VALID_DEBUG_PRINT_OBJECT()              ( TRUE)

# define DBG_CODE(s)                             ((void)0) /* Do Nothing */

# define DBG_ASSERT(exp)                         ((void)0) /* Do Nothing */

# define DBG_ASSERT_MSG(exp, pszMsg)             ((void)0) /* Do Nothing */

# define DBG_REQUIRE( exp)                       ( (void) (exp))

# define DBGPRINTF( args)                        ((void)0) /* Do Nothing */

# define DBGDUMP( args)                          ((void)0) /* Do nothing */

# define DBG_LOG()                               ((void)0) /* Do Nothing */

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)    ((void)0) /* Do Nothing */

# define DBG_CLOSE_LOG_FILE()                    ((void)0) /* Do Nothing */

# define DBGPRINT_CURRENT_TIME()                 ((void)0) /* Do Nothing */

# endif // DBG


// end_user_unmodifiable

// begin_user_unmodifiable


#ifdef ASSERT
# undef ASSERT
#endif


# define ASSERT( exp)           DBG_ASSERT( exp)


# if DBG

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
 DWORD  g_dwDebugFlags;           // Debugging Flags

# define DECLARE_DEBUG_VARIABLE()     \
             DWORD  g_dwDebugFlags

# define SET_DEBUG_FLAGS( dwFlags)         g_dwDebugFlags = dwFlags
# define GET_DEBUG_FLAGS()                 ( g_dwDebugFlags)

# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
             g_dwDebugFlags = PuLoadDebugFlagsFromReg((hkey), (dwDefault))

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  \
             g_dwDebugFlags = PuLoadDebugFlagsFromRegStr((pszRegKey), (dwDefault))

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)  \
               PuSaveDebugFlagsInReg((hkey), (dwDbg))

# define DEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                } else {}

# define IF_DEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS())


# else   // DBG


# define DECLARE_DEBUG_VARIABLE()                /* Do Nothing */
# define SET_DEBUG_FLAGS( dwFlags)               /* Do Nothing */
# define GET_DEBUG_FLAGS()                       ( 0)
# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault) /* Do Nothing */

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  /* Do Nothing */

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)    /* Do Nothing */

# define DEBUG_IF( arg, s)                       /* Do Nothing */
# define IF_DEBUG( arg)                          if ( 0)

# endif // DBG

// end_user_unmodifiable

// begin_user_modifiable

//
//  Debugging constants consist of two pieces.
//  All constants in the range 0x0 to 0x8000 are reserved
//  User extensions may include additional constants (bit flags)
//

# define DEBUG_API_ENTRY                  0x00000001L
# define DEBUG_API_EXIT                   0x00000002L
# define DEBUG_INIT_CLEAN                 0x00000004L
# define DEBUG_ERROR                      0x00000008L

                   // End of Reserved Range
# define DEBUG_RESERVED                   0x00000FFFL

// end_user_modifiable




/***********************************************************
 *    Platform Type related variables and macros
 ************************************************************/

//
// Enum for product types
//

typedef enum _PLATFORM_TYPE {

    PtInvalid = 0,                 // Invalid
    PtNtWorkstation = 1,           // NT Workstation
    PtNtServer = 2,                // NT Server
    PtWindows95 = 3,               // Windows 95
    PtWindows9x = 4                // Windows 9x - not implemented

} PLATFORM_TYPE;

//
// IISGetPlatformType is the function used to the platform type
//

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus

PLATFORM_TYPE
IISGetPlatformType(
        VOID
        );

//
// External Macros
//

#define InetIsNtServer( _pt )           ((_pt) == PtNtServer)
#define InetIsNtWksta( _pt )            ((_pt) == PtNtWorkstation)
#define InetIsWindows95( _pt )          ((_pt) == PtWindows95)
#define InetIsValidPT(_pt)              ((_pt) != PtInvalid)

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE    g_PlatformType;


// Use the DECLARE_PLATFORM_TYPE macro to declare the platform type
#define DECLARE_PLATFORM_TYPE()  \
   PLATFORM_TYPE    g_PlatformType = PtInvalid;

// Use the INITIALIZE_PLATFORM_TYPE to init the platform type
// This should typically go inside the DLLInit or equivalent place.
#define INITIALIZE_PLATFORM_TYPE()  \
   g_PlatformType = IISGetPlatformType();

//
// Additional Macros to use the Platform Type
//

#define TsIsNtServer( )         InetIsNtServer(g_PlatformType)
#define TsIsNtWksta( )          InetIsNtWksta(g_PlatformType)
#define TsIsWindows95()         InetIsWindows95(g_PlatformType)
#define IISIsValidPlatform()    InetIsValidPT(g_PlatformType)
#define IISPlatformType()       (g_PlatformType)


/***********************************************************
 *    Some utility functions for Critical Sections
 ************************************************************/

//
// IISSetCriticalSectionSpinCount() provides a thunk for the
//  original NT API SetCriticalSectionSpinCount() for CS with Spin counts
// Users of this function should definitely dynlink with kernel32.dll,
//  Otherwise errors will surface to a large extent
//
extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
);

//
// Macro for the calls to SetCriticalSectionSpinCount()
//
# define SET_CRITICAL_SECTION_SPIN_COUNT( lpCS, dwSpins) \
  IISSetCriticalSectionSpinCount( (lpCS), (dwSpins))

//
// IIS_DEFAULT_CS_SPIN_COUNT is the default value of spins used by
//  Critical sections defined within IIS.
// NYI: We should have to switch the individual values based on experiments!
// Current value is an arbitrary choice
//
# define IIS_DEFAULT_CS_SPIN_COUNT   (400)

# endif  /* _DEBUG_HXX_ */

//
// The following macros allow the automatic naming of certain Win32 objects.
// See IIS\SVCS\IRTL\DBGSUPP\WIN32OBJ.C for details on the naming convention.
//
// Set IIS_NAMED_WIN32_OBJECTS to a non-zero value to enable named events,
// semaphores, and mutexes.
//

#if DBG
#define IIS_NAMED_WIN32_OBJECTS 1
#else
#define IIS_NAMED_WIN32_OBJECTS 0
#endif

#ifdef __cplusplus
extern "C" {
#endif


HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    );


HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );


HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    );

#ifdef __cplusplus
}   // extern "C"
#endif

#if IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    PuDbgCreateEvent(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (manual),                                                           \
        (state)                                                             \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    PuDbgCreateSemaphore(                                                   \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial),                                                          \
        (maximum)                                                           \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    PuDbgCreateMutex(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial)                                                           \
        )

#else   // !IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    CreateEventA(                                                           \
        NULL,                                                               \
        (manual),                                                           \
        (state),                                                            \
        NULL                                                                \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    CreateSemaphoreA(                                                       \
        NULL,                                                               \
        (initial),                                                          \
        (maximum),                                                          \
        NULL                                                                \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    CreateMutexA(                                                           \
        NULL,                                                               \
        (initial),                                                          \
        NULL                                                                \
        )

#endif  // IIS_NAMED_WIN32_OBJECTS


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\spud.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      spud.cxx

   Abstract:
      This module implements the user mode entry points for SPUD.SYS.
      SPUD = Special Purpose Utility Driver.

   Author:

       John Ballard ( jballard )     22-Oct-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqTransmitFileAndRecv();
       BOOL  AtqSendAndRecv();
       BOOL  AtqBatchRequest();

--*/


#include "isatq.hxx"
#include <tdi.h>
#include <afd.h>
#include <spud.h>
#include "uspud.h"

#if 0
VOID
EnableLoadDriverPrivilege(
    VOID
    );

#define SPUD_REG_PATH   \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Spud"

BOOL
I_AtqSpudInitialize(
            IN HANDLE hPort
            )
{
    NTSTATUS    status;
    UNICODE_STRING  DriverName;
    DWORD   Version = SPUD_VERSION;

    if ( !g_fUseDriver ) {
        return(FALSE);
    }

    EnableLoadDriverPrivilege();

    g_pfnRtlInitUnicodeString( &DriverName, SPUD_REG_PATH );
    status = g_pfnNtLoadDriver( &DriverName );
    if ( ( status != STATUS_SUCCESS ) &&
         ( status != STATUS_IMAGE_ALREADY_LOADED ) ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "NtLoadDriver failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    status = SPUDInitialize(Version, hPort);
    if ( status != STATUS_SUCCESS ) {

        if ( status == STATUS_INVALID_DEVICE_REQUEST ) {
            SPUDTerminate();
            if ( SPUDInitialize(Version, hPort) == STATUS_SUCCESS ) {
                return TRUE;
            }
        }

        ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDInitialize failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    return TRUE;

disable_driver:

    g_fUseDriver = FALSE;

    ATQ_PRINTF((DBG_CONTEXT, "SPUDInitialize: Disabling driver\n"));
    return(FALSE);
} // I_AtqSpudInitialize


BOOL
I_AtqSpudTerminate()
{
    NTSTATUS    status;

    status = SPUDTerminate();
    if ( status != STATUS_SUCCESS ) {

        IF_DEBUG(ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDTerminate failed!!! status == %08lx\n",
                     status
                     ));
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
I_AtqSpudCheckStatus(
    IN PATQ_CONT                patqContext             // pointer to ATQ context
    )
{
        ULONG status;

        status = SPUDCheckStatus( &patqContext->spudContext );

        if ( status != STATUS_SUCCESS ) {
                return FALSE;
        }

        return TRUE;
}

BOOL
I_AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
/*++
Routine Description:

    Calls SPUDTransmitFileAndRecv().  Cannot be blocked by bandwidth throttler

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_TRANSMIT_FILE_INFO transmitInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "I_AtqTransmitFileAndRecv(%08lx) called.\n", patqContext));
        }

        transmitInfo.WriteLength.QuadPart = dwBytesInFile;
        transmitInfo.SendPacketLength = 0;
        transmitInfo.FileHandle = hFile;
        transmitInfo.Flags = dwTFFlags;
        if ( lpTransmitBuffers != NULL ) {
            transmitInfo.Head = lpTransmitBuffers->Head;
            transmitInfo.HeadLength = lpTransmitBuffers->HeadLength;
            transmitInfo.Tail = lpTransmitBuffers->Tail;
            transmitInfo.TailLength = lpTransmitBuffers->TailLength;
        } else {
            transmitInfo.Head = NULL;
            transmitInfo.HeadLength = 0;
            transmitInfo.Tail = NULL;
            transmitInfo.TailLength = 0;
        }

        transmitInfo.Offset.LowPart = patqContext->Overlapped.Offset;
        transmitInfo.Offset.HighPart = 0;

        recvInfo.BufferArray = pwsaBuffers;
        recvInfo.BufferCount = dwBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        //
        // Set this flag here to avoid a race with completion handling code
        // Reset if SPUDTransmitFileAndRecv fails
        //
        patqCont->SetFlag( ACF_RECV_ISSUED);

        status = SPUDTransmitFileAndRecv( patqCont->hAsyncIO,
                                         &transmitInfo,
                                         &recvInfo,
                                         &patqCont->spudContext
                                         );

#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of all non-oplock notification.
            // This is for debugging purpose only.
            //
            // Code 0xfbfbfbfb indicates a SPUD TransmitFileAndRecv request
            //

            patqCont->NotifyIOCompletion( 0, status, 0xfbfbfbfb );
#endif

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "SPUDTransmitFileAndRecv failed!!! status == %08lx\n",
                         status
                         ));
            SetLastError(g_pfnRtlNtStatusToDosError(status));
            patqCont->MoveState( ACS_SOCK_CONNECTED);
            patqCont->ResetFlag( ACF_RECV_ISSUED);
            return FALSE;
        }

        return TRUE;
}

BOOL
AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {
        BOOL            fRes;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                "AtqTransmitFileAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqTransmitFile.\n", patqContext));
        }

        return AtqTransmitFile( patqContext,
                                hFile,
                                dwBytesInFile,
                                lpTransmitBuffers,
                                dwTFFlags );
    }

    I_SetNextTimeout(pContext);

    pContext->BytesSent = dwBytesInFile;

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent += pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf <= (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( dwTFFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwTFFlags = TF_WRITE_BEHIND;

    }

    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoXmitFileRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqTransmitFileAndRecv( patqContext,
                                         hFile,
                                         dwBytesInFile,
                                         lpTransmitBuffers,
                                         dwTFFlags,
                                         pwsaBuffers,
                                         dwBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoXmitFileRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;

        pContext->arInfo.uop.opXmitRecv.hFile = hFile;
        pContext->arInfo.uop.opXmitRecv.dwBytesInFile = dwBytesInFile;
        pContext->arInfo.uop.opXmitRecv.lpXmitBuffers = lpTransmitBuffers;
        pContext->arInfo.uop.opXmitRecv.dwTFFlags     = dwTFFlags;
        pContext->arInfo.uop.opXmitRecv.dwBufferCount = dwBufferCount;

        if ( dwBufferCount == 1) {
            pContext->arInfo.uop.opXmitRecv.buf1.len = pwsaBuffers->len;
            pContext->arInfo.uop.opXmitRecv.buf1.buf = pwsaBuffers->buf;
            pContext->arInfo.uop.opXmitRecv.pBufAll  = NULL;
        } else {

            DBG_ASSERT( dwBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opXmitRecv.pBufAll = pBuf;
                CopyMemory( pBuf, pwsaBuffers,
                            dwBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqTransmitFileAndRecv()

BOOL
I_AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
/*++
Routine Description:

    Calls SPUDSendAndRecv().  Cannot be blocked by bandwidth throttler.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_SEND_INFO          sendInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "I_AtqSendAndRecv(%08lx) called.\n", patqContext));
        }

        sendInfo.BufferArray = pwsaSendBuffers;
        sendInfo.BufferCount = dwSendBufferCount;
        sendInfo.AfdFlags = AFD_OVERLAPPED;
        sendInfo.TdiFlags = 0;

        recvInfo.BufferArray = pwsaRecvBuffers;
        recvInfo.BufferCount = dwRecvBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        //
        // Set this flag before SPUD call to avoid a race with completion
        // Reset if SPUDSendAndRecv fails
        //
        patqCont->SetFlag( ACF_RECV_ISSUED);

        status = SPUDSendAndRecv( patqCont->hAsyncIO,
                                 &sendInfo,
                                 &recvInfo,
                                 &patqCont->spudContext
                                 );

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDSendAndRecv failed!!! status == %08lx\n",
                     status
                     ));
             SetLastError(g_pfnRtlNtStatusToDosError(status));
             patqCont->ResetFlag( ACF_RECV_ISSUED);
             return FALSE;
        }

        return TRUE;
}

BOOL
AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
            "AtqSendAndRecv(%08lx) called.\n", patqContext));
    }

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {

        BOOL            fRes;
        DWORD           cbWritten;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqSendAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqWriteSocket.\n", patqContext));
        }

        return AtqWriteSocket( patqContext,
                               pwsaSendBuffers,
                               dwSendBufferCount,
                               &patqContext->Overlapped );
    }

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwSendBufferCount >= 1);
    pContext->BytesSent = pwsaSendBuffers->len;
    if ( dwSendBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaSendBuffers + 1;
            pWsaBuf <= (pwsaSendBuffers + dwSendBufferCount);
            pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }


    DBG_ASSERT( dwRecvBufferCount >= 1);
    pContext->BytesSent += pwsaRecvBuffers->len;
    if ( dwRecvBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaRecvBuffers + 1;
              pWsaBuf <= (pwsaRecvBuffers + dwRecvBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    switch ( pBandwidthInfo->QueryStatus( AtqIoSendRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqSendAndRecv( patqContext,
                                 pwsaSendBuffers,
                                 dwSendBufferCount,
                                 pwsaRecvBuffers,
                                 dwRecvBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoSendRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;
        pContext->arInfo.uop.opSendRecv.dwSendBufferCount = dwSendBufferCount;
        pContext->arInfo.uop.opSendRecv.dwRecvBufferCount = dwRecvBufferCount;

        if ( dwSendBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.sendbuf1.len = pwsaSendBuffers->len;
            pContext->arInfo.uop.opSendRecv.sendbuf1.buf = pwsaSendBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pSendBufAll  = NULL;
        } else {

            DBG_ASSERT( dwSendBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwSendBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pSendBufAll = pBuf;
                CopyMemory( pBuf, pwsaSendBuffers,
                            dwSendBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        if ( dwRecvBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.recvbuf1.len = pwsaRecvBuffers->len;
            pContext->arInfo.uop.opSendRecv.recvbuf1.buf = pwsaRecvBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pRecvBufAll = NULL;
        } else {

            DBG_ASSERT( dwRecvBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwRecvBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pRecvBufAll = pBuf;
                CopyMemory( pBuf, pwsaRecvBuffers,
                            dwRecvBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqSendAndRecv()




//
//  Short routine to enable the LoadDriverPrivilege for loading spud.sys
//

VOID EnableLoadDriverPrivilege(
    VOID
    )
{
    HANDLE ProcessHandle;
    HANDLE TokenHandle;
    BOOL Result;
    LUID LoadDriverValue;
    TOKEN_PRIVILEGES * TokenPrivileges;
    CHAR buf[ 5 * sizeof(TOKEN_PRIVILEGES) ];

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        goto Cleanup;
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 &TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        goto Cleanup;

    }

    //
    // Find out the value of LoadDriverPrivilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeLoadDriverPrivilege",
                 &LoadDriverValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges = (TOKEN_PRIVILEGES *) buf;

    TokenPrivileges->PrivilegeCount = 1;
    TokenPrivileges->Privileges[0].Luid = LoadDriverValue;
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                TokenPrivileges,
                sizeof(buf),
                NULL,
                NULL
                );
Cleanup:

    if ( TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }
}

HANDLE
AtqCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    DWORD SQOSFlags;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    POPLOCK_INFO pOplock;

    CreateFlags = 0;

//    DbgPrint("AtqCreateFileW - %ws\n", lpFileName );

    TranslationStatus = g_pfnRtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        (dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS) ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );


    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
        }
    } else {
        pOplock = NULL;
    }

    Status = SPUDCreateFile(
                &Handle,
                &Obja,
                &IoStatusBlock,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateFlags,
                si,
                sd,
                Length,
                LengthNeeded,
                pOplock
                );

    g_pfnRtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ||
             Status == STATUS_OPLOCK_NOT_GRANTED ) {
             SetLastError(ERROR_INVALID_ACCESS);
             return Handle;
        }
        if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            SetLastError(ERROR_ACCESS_DENIED);
        } else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
        }
        return INVALID_HANDLE_VALUE;
    }

    SetLastError(ERROR_SUCCESS);
    return Handle;

}

BOOL
AtqOplockAcknowledge(
    IN HANDLE   FileHandle,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
)
{
    POPLOCK_INFO pOplock;
    NTSTATUS Status;

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
            Status = SPUDOplockAcknowledge(
                          FileHandle,
                          pOplock
                          );

            if ( Status == STATUS_SUCCESS ) {
                return TRUE;
            }

        }
    }
    return FALSE;

}

#else

BOOL
I_AtqSpudInitialize(
            IN HANDLE hPort
            )
{
    return FALSE;
}

BOOL
I_AtqSpudTerminate()
{
    return TRUE;
}

BOOL
I_AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
{
    return FALSE;
}

BOOL
I_AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
{
    return FALSE;
}
#endif
BOOL
AtqSpudInitialized(
    VOID
)
{
    return g_fUseDriver;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\timer.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Wrap proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

    For DNS the added instructions are well worth the cost in that it
    eliminates any issue involving cleaning packet queues or resetting
    cache timeouts when millisecond timer (GetCurrentTime) wraps.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Environment:

    Win32 User Mode

Project:

    Common Code for Internet Services

Functions Exported:

    InitializeSecondsTimer()
    GetCurrentTimeInSeconds()

Revision History:
    MuraliK  14-Nov-1995 Made multi thread safe.
    
--*/


# include "isatq.hxx"


//
//  Timer globals
//

static LONG      g_lTimerInitialized = (LONG ) FALSE;
CRITICAL_SECTION    g_csTimerWrap;



VOID
InitializeSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Initialize DNS timer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( InterlockedExchange( &g_lTimerInitialized, (LONG ) TRUE) == FALSE) { 
        
        // I am the first thread to initialize. Let me do so.
          
        InitializeCriticalSection( &g_csTimerWrap );
        SET_CRITICAL_SECTION_SPIN_COUNT( &g_csTimerWrap, 
                                         IIS_DEFAULT_CS_SPIN_COUNT);
    }

} // InitializeSecondsTimer()



DWORD
GetCurrentTimeInSeconds(
    VOID
    )
/*++

Routine Description:

    Get current time in seconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetCurrentTime();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            dwWrapTime += (0xffffffff / 1000);
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (dwCurrentTime / 1000 + dwWrapTime);
}


__int64
GetCurrentTimeInMilliseconds(
    VOID
    )
/*++

Routine Description:

    Get current time in milliseconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetTickCount();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            ++dwWrapTime;
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (((__int64)dwWrapTime)<<32) |  dwCurrentTime;
}


//
//  End of timer.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\timeout.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
        timeout.cxx

   Abstract:
        This module contains code for timeout processing of ATQ contexts

   Author:

       Murali R. Krishnan    ( MuraliK )     16-July-1997

   Environment:
       Win32 - User Mode

   Project:
       Internet Server - Asynchronous Thread Queue Module

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "isatq.hxx"


/************************************************************
 * Globals
 ************************************************************/

DWORD   g_dwTimeoutCookie = 0; // Scheduler Cookie for timeout processing

DWORD   g_AtqCurrentTick = 1;

DWORD g_dwTimeout = ATQ_TIMEOUT_INTERVAL;  // active timeout value

/************************************************************
 *    Functions
 ************************************************************/



BOOL
I_TimeOutContext(
    PATQ_CONT pAtqContext
    )
/*++

Routine Description:

    This function does the actual timeout for a particular context.
    Note: The Context list lock is held while processing this function

Arguments:

    Context - Pointer to the context to be timed out

Return value:

    TRUE, if the completion routine was called
    FALSE, otherwise

--*/
{

    DWORD timeout;

    //
    //  Call client after re-checking that this item
    //  really has timed out

    //
    // Fake timeout
    //

    if ( pAtqContext->TimeOut == ATQ_INFINITE ) {
        pAtqContext->NextTimeout = ATQ_INFINITE;
        return(FALSE);
    }

    //
    // Was our timeout long enough?
    //

    // NYI: Optimize: CanonTimeout should be called only once per IO submitted
    timeout = CanonTimeout( pAtqContext->BytesSent/g_cbMinKbSec);
    if ( timeout > pAtqContext->TimeOut ) {

        //
        // Reset the Timeout value based on the bytes to be sent
        // as well as update the time when this pAtqContext be timedout
        //

        pAtqContext->TimeOut = timeout;
        pAtqContext->NextTimeout = AtqGetCurrentTick( ) + timeout;
        return(FALSE);
    }

    //
    // If this is on blocked list, remove it.
    //

    if ( pAtqContext->IsBlocked()) {
        PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;
        ATQ_ASSERT( pBandwidthInfo != NULL );
        ATQ_REQUIRE( pBandwidthInfo->RemoveFromBlockedList(pAtqContext));
    }

    //
    //  If we've already indicated this connection to the client,
    //  then we abort them by calling their IO completion routine
    //  and letting them cleanup.  Otherwise we close the socket
    //  which will generally cause an IO aborted completion that
    //  we will cleanup.  Note there is a window where we may
    //  close the socket out from under a client in their
    //  connection completion routine but that should be ok.
    //

    if ( pAtqContext->pfnCompletion &&
         pAtqContext->IsFlag( ACF_CONN_INDICATED)) {

        //
        //  TransmitFile socket state will be unconnected because
        //  we're expecting it to complete successfully.  Reset the
        //  state so the socket gets cleaned up properly
        //

        if ( pAtqContext->IsState( ACS_SOCK_UNCONNECTED) ) {
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

        AcIncrement( CacAtqContextsTimedOut);

        pAtqContext->NextTimeout = ATQ_INFINITE;

        pAtqContext->IOCompletion( 0, ERROR_SEM_TIMEOUT, NULL);

        //
        //  We can't touch any items on the list after notifying
        //  the client as the client may have re-entered
        //  and freed some items from the list
        //

        return(TRUE);

    } else {

        HANDLE hIO;

        hIO = (HANDLE ) InterlockedExchangePointer(
                                        (PVOID *) &pAtqContext->hAsyncIO,
                                        NULL
                                        );
        DBG_ASSERT(!pAtqContext->fDatagramContext);
        IF_DEBUG( TIMEOUT) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Timeout: closesocket(%d) Context=%08x\n",
                         hIO, pAtqContext));
        }
        closesocket( (SOCKET) hIO );
    }

    return(FALSE); // we can touch the items on current list.

} // I_TimeOutContext




VOID
AtqProcessTimeoutOfRequests(
    PATQ_CONTEXT_LISTHEAD ContextList
    )
/*++

Routine Description:

    Walks the list of Atq clients looking for any item that has timed out and
    notifies the client if it has.

    TimeOutScanID is used as a serial number to prevent evaluating the same
    context twice.  We start from the beginning of the list everytime we
    notify a client an Atq context has timed out.  We do this because the
    client timeout processing may remove any number of Items from the
    list (including the next couple of items in the list).

    This routine also checks to make sure outstanding AcceptEx sockets
    haven't been exhausted (if less then 25% available, adds some more).

--*/
{
    DWORD                  newLatest = ATQ_INFINITE;
    BOOL                   fRescan;

    //
    // See if the latest one is timed-out
    //

    if ( ContextList->LatestTimeout > AtqGetCurrentTick( ) ) {

        return;
    }

    // set the latest timeout in the context list,
    // to avoid races with IO being started.
    ContextList->LatestTimeout = ATQ_INFINITE;

    //
    //  Scan the timeout list looking for items that have timed out
    //  and adjust the timeout values
    //

    do {

        LIST_ENTRY *           pentry;
        LIST_ENTRY *           pentryNext;
        DWORD                  scanId = AtqGetCurrentTick( );

        ContextList->Lock( );

        fRescan = FALSE;

        for ( pentry  = ContextList->ActiveListHead.Flink;
              pentry != &ContextList->ActiveListHead;
              pentry  = pentryNext ) {

            PATQ_CONT              pContext;

            pentryNext = pentry->Flink;

            pContext = CONTAINING_RECORD(
                                pentry,
                                ATQ_CONTEXT,
                                m_leTimeout
                                );

            if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE ) {
                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                break;
            }

            //
            //  Ignore items we've already processed
            //

            if ( pContext->TimeOutScanID == scanId ) {
                continue;
            }

            pContext->TimeOutScanID = scanId;

            //
            // If there is an IO which has popped up now,
            //  we have to do nothing. This code was added to protect catapult!
            //
            pContext->SetFlag( ACF_IN_TIMEOUT);

            if ( !pContext->lSyncTimeout) {

                // no body is using this context. Check and synchronize
                // the timeout state.

                //
                //  The client specifies the IO doesn't timeout if
                //  INFINITE is in the TimeOut field of the ATQ context
                //  If we've timed out, then notify the client.
                //

                DWORD nextTimeout = pContext->NextTimeout;
                if ( nextTimeout > AtqGetCurrentTick() ) {


                    // pick up the latest "low" value for
                    // firing next timeout thread
                    if ( nextTimeout < newLatest ) {
                        newLatest = nextTimeout;
                    }
                } else if ( I_TimeOutContext(pContext) ) {

                    // we are done checking and processing timeout.
                    // reset the In Timeout flag
                    pContext->ResetFlag( ACF_IN_TIMEOUT);
                    fRescan = TRUE;
                    break;
                } else {

                    //
                    // It is possible that the timeout got reset
                    // Check for the latest "low" value
                    //
                    nextTimeout = pContext->NextTimeout;
                    if ( nextTimeout < newLatest ) {
                        newLatest = nextTimeout;
                    }
                }

            } else {
                AcIncrement( CacAtqProcWhenTimeout);
            }

            // we are done checkin and processing timeouts.
            // reset the In Timeout flag
            pContext->ResetFlag( ACF_IN_TIMEOUT);

        } // scan list

        // let other system threads also run happily for a while
        ContextList->Unlock( );

    } while (fRescan);

    if ( newLatest != ATQ_INFINITE) {
        // We picked up the latest timeout. store it.
        ContextList->LatestTimeout = newLatest;
    }

    return;

} // AtqProcessTimeoutOfRequests




//
// ACCEPT_EX_TIMEOUT_STATS collects statistics for the
//   timeout processing in the Pending AcceptEx List//
//
struct ACCEPT_EX_TIMEOUT_STATS {

    DWORD  m_nScanned;
    DWORD  m_nTimedOut;
    DWORD  m_nSkipped;
    DWORD  m_nConnected;
    DWORD  m_nNotConnected;
};


BOOL
I_TimeOutPendingAcceptExContext(
    PATQ_CONT pAtqContext
    )
/*++

Routine Description:

    This function does the actual timeout for a pending AcceptEx context.
    Note: The Context list lock is held while processing this function

Arguments:

    pAtqContext - Pointer to the context to be timed out

Return value:

    TRUE, if a tmieout operation was conducted.
    FALSE, otherwise

--*/
{
    DBG_ASSERT( pAtqContext != NULL);

    //
    // in the shutdown case it is possible that someone closed this socket already
    // so don't worry about it.
    //
    if ( pAtqContext->hAsyncIO == NULL ) {
        return TRUE;
    }

    //
    // Validate our assumptions about this Pending AcceptEx Context
    // there is an endpoint => AcceptEx context
    DBG_ASSERT( pAtqContext->pEndpoint != NULL);
    DBG_ASSERT( pAtqContext->IsState( ACS_SOCK_LISTENING));
    DBG_ASSERT( !pAtqContext->IsFlag( ACF_CONN_INDICATED));
    DBG_ASSERT( pAtqContext->TimeOut != ATQ_INFINITE);


    //
    // We will obtain the socket handle stored inside the AcceptEx Context
    //    and free up the context.
    // Warning:
    //   The AcceptEx socket did not have a connection when this function
    //   was called. However now between the time when the state was checked
    //   and the time this timeout operation completes, it is possible that
    //   a new connection is bound to this AcceptEx context => we can get IO completion.
    //   I need to handle this case
    //

    HANDLE hIO;

    hIO = (HANDLE ) InterlockedExchangePointer(
                            (PVOID *) &pAtqContext->hAsyncIO,
                            NULL
                            );
    DBG_ASSERT(!pAtqContext->fDatagramContext);
    IF_DEBUG( TIMEOUT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "TimeoutPendingAcceptExContext(%08x): closesocket(%d)\n",
                      pAtqContext, hIO));
    }

    closesocket( (SOCKET) hIO );

    return ( TRUE);
} // I_TimeOutPendingAcceptExContext()


BOOL
I_IsTimeoutForAcceptExContext(
    IN OUT PATQ_CONT                  pAtqContext,
    IN OUT ACCEPT_EX_TIMEOUT_STATS  * pAetStats
    )
/*++

Routine Description:

    This function checks to see if timeout operation has to be performed
    for a given AtqContext. It bases the decision on the a variety of
    details maintained in Atq Context and the Endpoint.
    Note: The Context list lock is held while processing this function

Arguments:

    pAtqContext - Pointer to the context to be timed out
    pAetStats   - pointer to AcceptEx Timeout Statistics structure

Return value:

    TRUE, if a tmieout operation has to be conducted.
    FALSE, when no timeout is required.

--*/
{
    DBG_ASSERT( pAtqContext);
    DBG_ASSERT( pAetStats);

    PATQ_ENDPOINT  pEndpoint;
    pEndpoint = pAtqContext->pEndpoint;

    if ( pEndpoint != NULL) {

        //
        // We will use getsockopt() to query the connection status
        //  for the socket inside the Atq context.
        // If Socket is not connected => leave it in the pool
        // If Socket is connected and waiting for receive operation =>
        //        do timeout processing
        //
        // The goal is to maintain a pool of sockets in listening state
        //  so that any new connection will be picked up quickly.
        //
        // getsockopt() is a very costly function.
        // We check to see if we have enough sockets available
        //  for an endpoint. If they are, then we bypass calling getsockopt
        // "enough" is defined as # of available sockets is at least
        //   25% of the total # of accept ex sockets outstanding.
        // Optimize calling getsockopt() based on
        //   current count in pEndpoint->nAvailDuringTimeOut
        //

        if ( pEndpoint->nAvailDuringTimeOut >
             ( pEndpoint->nAcceptExOutstanding >> 2)
             ) {

            // Already enough Contexts are available.
            //  Do nothing
            pAetStats->m_nSkipped++;

            return (FALSE); // Do not timeout
        }

        DWORD dwConnect;
        int   cbOptLen = sizeof( dwConnect );

        //
        // Query the socket layer if the current socket has a valid connection
        // An AcceptEx socket can be connected and waiting for new request to
        //   be read. If we are in such state we should not blow away context.
        //
        if (pAtqContext->hAsyncIO && (
                 getsockopt((SOCKET) pAtqContext->hAsyncIO,
                        SOL_SOCKET,
                        SO_CONNECT_TIME,
                        (char *) &dwConnect,
                        &cbOptLen ) != SOCKET_ERROR)
             ) {

            //
            //  A return value of 0xFFFFFFFF indicates that the given
            //   AcceptEx socket is not connected yet.
            //  Otherwise the socket is connected and is probably wating
            //   for request to be read or maybe a completion is already
            //   on its way.
            //

            if ( dwConnect == (DWORD) 0xFFFFFFFF ) {

                //
                //  Ignore the "Listen" socket context
                //

                pAetStats->m_nNotConnected++;

                DBG_ASSERT( NULL != pEndpoint);
                pEndpoint->nAvailDuringTimeOut++;

                // Update timeout values to give a breather interval
                pAtqContext->NextTimeout =
                    AtqGetCurrentTick() + pAtqContext->TimeOut;

                return ( FALSE);  // Do not timeout
            }
            else if ( !pAtqContext->IsFlag(ACF_WINSOCK_CONNECTED) ) {

                //
                // Mark that this context has connection indicated.
                // If this context waits around in connected state for
                //  long-time we need to blow the context away.
                //

                pAetStats->m_nConnected++;

                // Update timeout values to give a breather interval
                pAtqContext->NextTimeout =
                    AtqGetCurrentTick() + pAtqContext->TimeOut;

                pAtqContext->SetFlag(ACF_WINSOCK_CONNECTED);

                return (FALSE); // do not timeout now
            }
        }
    } // if Endpoint exists

    return (TRUE); // yes timeout this context
} // I_IsTimeoutForAcceptExContext()


VOID
I_AtqProcessPendingListens(
    IN PATQ_CONTEXT_LISTHEAD pContextList
    )
/*++

Routine Description:

    Walks the list of Pending accept ex and makes sure none has timed out.
    Also checks to see if we need to allocate more AcceptEx sockets.

  Arguments:
    pContextList - pointer to ATQ_CONTEXT_LISTHEAD object

  Returns:
    None

--*/
{
    BOOL                    fRescan;

    ACCEPT_EX_TIMEOUT_STATS AetStats;

    //
    // Initialize Statistics block
    //
    AetStats.m_nScanned         = 0;
    AetStats.m_nTimedOut        = 0;
    AetStats.m_nSkipped         = 0;
    AetStats.m_nConnected       = 0;
    AetStats.m_nNotConnected    = 0;


    //
    //  Look through the listening sockets to make sure the AcceptEx sockets
    //  haven't been exhausted
    //

    do {

        LIST_ENTRY *           pentry;
        LIST_ENTRY *           pentryNext;
        DWORD                  scanId = AtqGetCurrentTick( );

        fRescan = FALSE;

        pContextList->Lock();

        for ( pentry  = pContextList->PendingAcceptExListHead.Flink;
              pentry != &pContextList->PendingAcceptExListHead;
              pentry  = pentryNext ) {

            PATQ_CONT      pContext;

            pentryNext = pentry->Flink;
            pContext = CONTAINING_RECORD(
                                pentry,
                                ATQ_CONTEXT,
                                m_leTimeout
                                );

            if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE ) {
                DBG_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                break;
            }

            //
            //  Ignore items we've already processed
            //

            if ( pContext->TimeOutScanID == scanId ) {
                continue;
            }

            AetStats.m_nScanned++;
            pContext->TimeOutScanID = scanId;

            if ( pContext->fDatagramContext ) {
                continue;
            }

            //
            // If the context has Timeout value smaller than the one in our global tick
            //  then examine if this context can be timedout
            //

            DBG_CODE( if ( pContext->IsAcceptExRootContext())
                        {
                            DBG_ASSERT( pContext->TimeOut == ATQ_INFINITE);
                            DBG_ASSERT( pContext->NextTimeout == ATQ_INFINITE);
                        }
                        );

            if ( pContext->NextTimeout <= AtqGetCurrentTick()) {

                //
                // Protect against the race with the normal IO completion
                //
                pContext->SetFlag( ACF_IN_TIMEOUT);

                if ( !pContext->lSyncTimeout ) {

                    if ( !I_IsTimeoutForAcceptExContext( pContext, &AetStats)) {

                        pContext->ResetFlag( ACF_IN_TIMEOUT);
                        continue;
                    }

                    if ( I_TimeOutPendingAcceptExContext(pContext)) {
                        AetStats.m_nTimedOut++;
                        fRescan = TRUE;
                        pContext->ResetFlag(ACF_IN_TIMEOUT);
                        break;
                    }
                } // if (!pContext->lSyncTimeout)

                pContext->ResetFlag( ACF_IN_TIMEOUT);
            } // if the context's timeout value <= CurrentTick
            else {

                //
                // Timeout value has not been reached. Skip this context
                //

                AetStats.m_nSkipped++;
           }
        } // scan list

        pContextList->Unlock();

    } while (fRescan);

    IF_DEBUG( TIMEOUT) {
       DBGPRINTF(( DBG_CONTEXT,
                   "TimeoutPendingListens( CtxtList[%d], AtqTick=%d)\n"
                   " Contexts Scanned=%d, Skipped=%d, TimedOut=%d,"
                   " Connected=%d, NotConnected=%d\n",
                   pContextList - AtqActiveContextList, AtqGetCurrentTick(),
                   AetStats.m_nScanned, AetStats.m_nSkipped,
                   AetStats.m_nTimedOut, AetStats.m_nConnected,
                   AetStats.m_nNotConnected
                ));
    }

# ifdef IIS_AUX_COUNTERS
    g_AuxCounters[CacAtqPendingAcceptExScans] += AetStats.m_nScanned;
# endif // IIS_AUX_COUNTERS

    return;

} // I_AtqProcessPendingListens()




VOID
I_AtqCheckEndpoints(
            VOID
            )
/*++
  Description:
    This function checks all the listen info objects and adds appropriate
     number of accept ex sockets as necessary.

  Arguments:
    None

  Returns:
    None
--*/
{
    LIST_ENTRY *  pEntry;
    PATQ_ENDPOINT pEndpoint;

    AcquireLock( &AtqEndpointLock);

    for ( pEntry  = AtqEndpointList.Flink;
          pEntry != &AtqEndpointList;
          pEntry  = pEntry->Flink ) {

        pEndpoint = CONTAINING_RECORD(
                                    pEntry,
                                    ATQ_ENDPOINT,
                                    ListEntry
                                    );

        DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        DBG_ASSERT( pEndpoint->nSocketsAvail >= 0);

        //
        // Check to make sure outstanding AcceptEx sockets
        // haven't been exhausted (if less then 25% available, adds some more).
        //

        if ( !pEndpoint->fDatagram ) {

            if ( ((DWORD ) pEndpoint->nSocketsAvail) <
                 (pEndpoint->nAcceptExOutstanding >> 2) ) {

                IF_DEBUG( TIMEOUT ) {
                    DBGPRINTF(( DBG_CONTEXT,
                                "[Timeout] Adding AcceptEx Contexts for EP=%08x; nAvail = %d;\n",
                                pEndpoint, pEndpoint->nSocketsAvail));
                }

                (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                    pEndpoint->nAcceptExOutstanding
                                                    );
            }
        }

        //
        // set to zero, so recount will be done during next timeout loop
        //

        pEndpoint->nAvailDuringTimeOut = 0;

    }

    ReleaseLock( &AtqEndpointLock);

    return;
} // I_AtqCheckEndpoints



VOID
I_AtqTimeOutWorker(VOID)
/*++
  Description:
    This function handles timeout processing using the simple
    clock algorithm, wherein partial set of lists are scanned
    during each timeout processing call.

  Arguments:
    None


  Returns:
    None
--*/
{
    DWORD start;
    PATQ_CONTEXT_LISTHEAD pContextList;

    IF_DEBUG(TIMEOUT) {
        DBGPRINTF((DBG_CONTEXT, "TimeoutWorker: entered\n"));
    }

    start = (AtqGetCurrentTick() & 0x1);

    for ( pContextList = AtqActiveContextList + start;
          pContextList < (AtqActiveContextList + g_dwNumContextLists) ;
          pContextList += 2 ) {

        IF_DEBUG(TIMEOUT) {
            DBGPRINTF((DBG_CONTEXT,
                       "TimeoutWorker: Processing list[%d] = %08x\n",
                       (pContextList - AtqActiveContextList),
                       pContextList));
        }

        AtqProcessTimeoutOfRequests( pContextList );
        I_AtqProcessPendingListens( pContextList );
    } // for

    if ( start != 0 ) {
        I_AtqCheckEndpoints( );
    }

    return;

} // I_AtqTimeOutWorker()




VOID
WINAPI
I_AtqTimeoutCompletion(
    IN PVOID Context
    )
/*++

Routine Description:

    Callback routine for the scheduled version of the timeout thread.

    The callback assumes timeouts are rounded to ATQ_TIMEOUT_INTERVAL

    In addition to timing out requests when necessary, the timeout thread
     also performs the job of bandwidth calculation and tuning the bandwidth
     throttle operation (which works on feedback mechanism).
    At every sampling interval the scheduled callback comes in and it updates
     the bandwidth.

Arguments:

    Context - Context returned by the scheduler thread.

Return Value:

    none.

--*/
{
    DWORD Timeout = ATQ_TIMEOUT_INTERVAL;
    BOOL  fDoContextTimeout = TRUE;

    if ( g_fShutdown ) {

        ATQ_PRINTF(( DBG_CONTEXT,
            "Detected a shutdown while entering timeout callback\n"));
        return;
    }

    InterlockedIncrement( (PLONG)&g_AtqCurrentTick );

    //
    //  Perform necessary steps to handle Bandwidth throttling.
    //

    ATQ_ASSERT( BANDWIDTH_INFO::sm_cSamplesForTimeout >= 1);

    IF_DEBUG(TIMEOUT) {
        DBGPRINTF((DBG_CONTEXT,
                 "Timeout: BANDWIDTH_INFO::cSamplesForTimeout=%d\n",
                 BANDWIDTH_INFO::sm_cSamplesForTimeout ));
    }

    if ( BANDWIDTH_INFO::GlobalActive() ) {

        --(BANDWIDTH_INFO::sm_cSamplesForTimeout);

        // Perform a sampling to update measured bandwidth +
        //  apply feedback policy

        BANDWIDTH_INFO::UpdateAllBandwidths();

        Timeout = ATQ_SAMPLE_INTERVAL_IN_SECS;
        if ( BANDWIDTH_INFO::sm_cSamplesForTimeout != 0) {

            // We have not reached timeout yet. So skip context timeouts

            fDoContextTimeout = FALSE;
        } else {

            // We had reached the timeout interval for requests.
            // Examine and release requests.
            ATQ_ASSERT( BANDWIDTH_INFO::sm_cSamplesForTimeout == 0);

            // reset the count of samples before proceeding.
            BANDWIDTH_INFO::sm_cSamplesForTimeout = NUM_SAMPLES_PER_TIMEOUT_INTERVAL;
        }
    } else {
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 1;
    }

    //
    // We are at a Timeout Interval. Examine and timeout requests.
    //

    if ( fDoContextTimeout ) {
        I_AtqTimeOutWorker();
    }

    if ( Timeout != g_dwTimeout) {

        // the scheduled interval is different from this current interval
        // Inidicate the changed timeout value to the scheduler

        ScheduleAdjustTime( g_dwTimeoutCookie, TimeToWait(Timeout));
        g_dwTimeout = Timeout;
    }

    return;
} // I_AtqTimeoutCompletion




BOOL
I_AtqStartTimeoutProcessing(
    IN PVOID Context
    )
/*++

Routine Description:

    Starts the timeout processing. It always uses the scheduler to schedule
    a timeout operation.

    Note: The scheduler should be initialized before getting to this function.

Arguments:

    Context - Context passed to the thread creation or scheduler thread.

Return Value:

    TRUE, if ok
    FALSE, otherwise

--*/
{
    ATQ_ASSERT( ATQ_SAMPLE_INTERVAL_IN_SECS < ATQ_TIMEOUT_INTERVAL );

    if ( BANDWIDTH_INFO::GlobalEnabled() ) {
        g_dwTimeout = ATQ_SAMPLE_INTERVAL_IN_SECS;
        BANDWIDTH_INFO::sm_cSamplesForTimeout =
            NUM_SAMPLES_PER_TIMEOUT_INTERVAL;
    } else {
        g_dwTimeout = ATQ_TIMEOUT_INTERVAL;
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 1;
    }

    g_dwTimeoutCookie =
        ScheduleWorkItem(
                         (PFN_SCHED_CALLBACK)I_AtqTimeoutCompletion,
                         Context,
                         TimeToWait(g_dwTimeout)
                         , TRUE  // ask for periodic timeout
                         );

    if ( g_dwTimeoutCookie == 0 ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Error %d scheduling timeout\n",GetLastError()));
        return(FALSE);
    }

    return(TRUE);

} // I_AtqStartTimeoutProcessing()



BOOL
I_AtqStopTimeoutProcessing(
    VOID
    )
/*++

Routine Description:

    Stops the timeout processing. It terminates the scheduled workitem and
    cleans up any state.

    Note: The scheduler should be terminated only after this call

Arguments:

    Context - Context passed to the thread creation or scheduler thread.

Return Value:

    TRUE, if ok
    FALSE, otherwise

--*/
{

    if ( 0 != g_dwTimeoutCookie) {
        DBG_REQUIRE( RemoveWorkItem( g_dwTimeoutCookie ));
        g_dwTimeoutCookie = 0;
    }

    return ( TRUE);

} // I_AtqStopTimeoutProcessing()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\timer.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Domain Name System (DNS) Server

    Wrap proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Revision History:

--*/


#ifndef _TIMER_INCLUDED_
#define _TIMER_INCLUDED_

VOID
InitializeSecondsTimer(
    VOID
    );

DWORD
GetCurrentTimeInSeconds(
    VOID
    );

__int64
GetCurrentTimeInMilliseconds(
    VOID
    );

#endif  // _TIMER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\uspud.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    uspud.h

    This module contains usermode interface to the spud.sys driver.


*/

#ifndef _USPUD_H_
#define _USPUD_H_


#ifdef __cplusplus
extern "C" {
#endif

extern
NTSTATUS
NTAPI
SPUDTransmitFileAndRecv(
    HANDLE                  hSocket,                // Socket handle to use for operation
    PAFD_TRANSMIT_FILE_INFO transmitInfo,           // transmit file req info
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );


extern
NTSTATUS
NTAPI
SPUDSendAndRecv(
    HANDLE                  hSocket,                // Socket handle to use for operation
    PAFD_SEND_INFO          sendInfo,               // send req info
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );


extern
NTSTATUS
NTAPI
SPUDCancel(
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );

extern
NTSTATUS
NTAPI
SPUDCheckStatus(
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );

extern
NTSTATUS
NTAPI
SPUDGetCounts(
    PSPUD_COUNTERS      SpudCounts,              // Counters
    DWORD               ClearCounts
    );

extern
NTSTATUS
NTAPI
SPUDInitialize(
    DWORD       Version,        // Version information from spud.h
    HANDLE      hPort           // Handle of completion port for atq
    );

extern
NTSTATUS
NTAPI
SPUDTerminate(
    VOID
    );

extern
NTSTATUS
NTAPI
SPUDCreateFile(
    OUT PHANDLE FileHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateOptions,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded,
    IN PVOID pOplock
    );

extern
NTSTATUS
NTAPI
SPUDOplockAcknowledge(
    IN HANDLE FileHandle,
    IN PVOID pOplock
    );

#ifdef __cplusplus
}
#endif

#endif //!_USPUD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dscommon\alert.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       alert.c
//
//--------------------------------------------------------------------------

//
// This file contains the source for RaiseAlert. RaiseAlert takes a 
// character string , builds the necessary buffers and calls NetRaiseAlertEx
// to raise an alert. This is in a separate file because this api is unicode
// only. In order for the alert to be raised the ALERTE service has to be
// running on the derver machine. In order for the alert to be received, the 
// messenger service has to be running on the receiving machine
//

#include <NTDSpch.h>
#pragma  hdrstop


#ifndef UNICODE
#define UNICODE
#endif
#include <windows.h>
#include	<lm.h>
#include	<lmalert.h>
#include <fileno.h>
#define  FILENO FILENO_ALERT

DWORD
RaiseAlert(char *szMsg)
{

	UINT  			CodePage = CP_ACP;
	DWORD 			dwFlags  = MB_PRECOMPOSED;
	int   			cchMultiByte = -1;
	size_t 			cbBuffer;
	size_t			cbMsg;
	BYTE  			*pbBuffer;
	PADMIN_OTHER_INFO	pAdminOtherInfo;
	WCHAR 			*szMergeString;
	DWORD			dwErr;


	cbMsg = strlen(szMsg) + 1;
	cbBuffer = sizeof(ADMIN_OTHER_INFO) + 	(sizeof(WCHAR) * cbMsg);
        pbBuffer = malloc(cbBuffer);

	if (!pbBuffer)
	    return GetLastError();

	pAdminOtherInfo = (PADMIN_OTHER_INFO) pbBuffer;
	szMergeString   = (WCHAR *) (pbBuffer + sizeof(ADMIN_OTHER_INFO));

	// convert multi byte string to unicode

	if (!MultiByteToWideChar(
		CodePage,
		dwFlags,
		szMsg,
		cchMultiByte,
		szMergeString,
		cbMsg))
	{
		dwErr = GetLastError();
		goto CommonExit;
	}

	pAdminOtherInfo->alrtad_errcode		=	(DWORD) -1;
	pAdminOtherInfo->alrtad_numstrings	=	1;

	dwErr = NetAlertRaiseEx(
		ALERT_ADMIN_EVENT,
		(LPVOID) pbBuffer,
		cbBuffer,
		L"Directory Service");

CommonExit:

	free(pbBuffer);
	return dwErr;
}

DWORD
RaiseAlertW(WCHAR *szMsg)
{

    int             cchMultiByte = -1;
    size_t          cbBuffer;
    size_t          cbMsg;
    BYTE            *pbBuffer;
    PADMIN_OTHER_INFO   pAdminOtherInfo;
    WCHAR           *szMergeString;
    DWORD           dwErr;


    cbMsg = wcslen(szMsg) + 1;
    cbBuffer = sizeof(ADMIN_OTHER_INFO) +   (sizeof(WCHAR) * cbMsg);
    pbBuffer = malloc(cbBuffer);

    if (!pbBuffer)
        return GetLastError();

    pAdminOtherInfo = (PADMIN_OTHER_INFO) pbBuffer;
    szMergeString   = (WCHAR *) (pbBuffer + sizeof(ADMIN_OTHER_INFO));
    wcscpy(szMergeString, szMsg);

    pAdminOtherInfo->alrtad_errcode     =   (DWORD) -1;
    pAdminOtherInfo->alrtad_numstrings  =   1;

    dwErr = NetAlertRaiseEx(
        ALERT_ADMIN_EVENT,
        (LPVOID) pbBuffer,
        cbBuffer,
        L"Directory Service");

    free(pbBuffer);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dscommon\checkacl.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       checkacl.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>             // alloca()
#include <rpc.h>                // RPC defines
#include <rpcdce.h>             // RPC_AUTH_IDENTITY_HANDLE
#include <sddl.h>               // ConvertSidToStringSid
#include <ntdsapi.h>            // DS APIs
#include <permit.h>             // DS_GENERIC_MAPPING
#include <checkacl.h>           // CheckAclInheritance()

//
// Define some SIDs for later use.
//

static UCHAR    S_1_3_0[] = { 1, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0 };
static SID      *pCreatorOwnerSid = (SID *) S_1_3_0;

static UCHAR    S_1_3_1[] = { 1, 1, 0, 0, 0, 0, 0, 3, 1, 0, 0, 0 };
static SID      *pCreatorGroupSid = (SID *) S_1_3_1;

// 
// Define some ACCESS_MASK masks
//

#define GENERIC_BITS_MASK ((ACCESS_MASK) (   GENERIC_READ \
                                           | GENERIC_WRITE \
                                           | GENERIC_EXECUTE \
                                           | GENERIC_ALL))

//
// Extract the ACCESS_MASK from an ACE.
//

ACCESS_MASK
MaskFromAce(
    ACE_HEADER  *p,                 // IN
    BOOL        fMapGenericBits     // IN
    )
{
    ACCESS_MASK     mask;
    GENERIC_MAPPING genericMapping = DS_GENERIC_MAPPING;


    // depending on the type of the ace extract mask from the related structure
    //
    if ( p->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {
        // we are using a standard ACE (not object based)
        mask = ((ACCESS_ALLOWED_ACE *) p)->Mask;
    }
    else
    {
        // we are using an object ACE (supports inheritance)
        mask = ((ACCESS_ALLOWED_OBJECT_ACE *) p)->Mask;
    }

    if ( fMapGenericBits )
    {
        // map the generic access rights used by the DS
        // to the specific access mask and standard access rights
        mask &= GENERIC_BITS_MASK;
        RtlMapGenericMask(&mask, &genericMapping);
    }

    // SYNCHRONIZE is not inherited/supported on DS objects, so mask this out.
    return(mask & ~SYNCHRONIZE);
}

//
// Compare two ACEs for equality.  This is not binary equality but
// instead is based on the subset of fields in the ACE which must be
// the same when inherited from parent to child.  
//
// pChildOwnerSid and pChildGroupSid semantics are as follows:
//   If present, then if the parent ACE's SID is pCreatorOwnerSid 
//   or pCreatorGroupSid respectively, then the child ACE's SID 
//   should match the passed in value, not the value in the parent.  
//   See comments in CheckAclInheritance for how this is used when 
//   a single parent ACE is split into two child ACEs.
//

BOOL
IsEqualAce(
    ACE_HEADER  *p1,                // IN - parent ACE
    ACE_HEADER  *p2,                // IN - child ACE
    ACCESS_MASK maskToMatch,        // IN - ACCESS_MASK bits to match on
    SID         *pChildOwnerSid,    // IN - child owner SID - OPTIONAL
    SID         *pChildGroupSid,    // IN - child group SID - OPTIONAL
    BOOL        fChildClassMatch,   // IN - child class matches parent ACE's inherited object type
    BOOL        fMapMaskOfParent,   // IN
    BOOL        *pfSubstMatch       // OUT
    )
{
    ACCESS_ALLOWED_ACE          *paaAce1, *paaAce2;
    ACCESS_ALLOWED_OBJECT_ACE   *paaoAce1, *paaoAce2;
    GUID                        *pGuid1, *pGuid2;
    PBYTE                       ptr1, ptr2;
    ACCESS_MASK                 mask1, mask2;

    *pfSubstMatch = TRUE;

    // ACEs should be at least of the same type
    if ( p1->AceType != p2->AceType )
        return(FALSE);

    mask1 = MaskFromAce(p1, fMapMaskOfParent) & maskToMatch;
    mask2 = MaskFromAce(p2, FALSE) & maskToMatch;

    if ( mask1 != mask2 )
        return(FALSE);


    // we are using a standard ACE (not object based)
    //
    if ( p1->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {
        paaAce1 = (ACCESS_ALLOWED_ACE *) p1;
        paaAce2 = (ACCESS_ALLOWED_ACE *) p2;

        if (    pChildOwnerSid
             && RtlEqualSid((PSID) &paaAce1->SidStart, pCreatorOwnerSid) )
        {
            return(RtlEqualSid((PSID) &paaAce2->SidStart, pChildOwnerSid));
        }
        else if (    pChildGroupSid
                  && RtlEqualSid((PSID) &paaAce1->SidStart, pCreatorGroupSid) )
        {
            return(RtlEqualSid((PSID) &paaAce2->SidStart, pChildGroupSid));
        }

        *pfSubstMatch = FALSE;
        return(RtlEqualSid((PSID) &paaAce1->SidStart, 
                           (PSID) &paaAce2->SidStart));
    }

    // we are using an object ACE (supports inheritance)
    //
    paaoAce1 = (ACCESS_ALLOWED_OBJECT_ACE *) p1;
    paaoAce2 = (ACCESS_ALLOWED_OBJECT_ACE *) p2;


    // if ACE_OBJECT_TYPE_PRESENT is set, we are protecting an
    // object, property set, or property identified by the specific GUID.
    // check that we are protecting the same object - property
    //
    if (paaoAce1->Flags & ACE_OBJECT_TYPE_PRESENT) {
        // parent has an object type. Child must also have it
        if (!(paaoAce2->Flags & ACE_OBJECT_TYPE_PRESENT) ||
            memcmp(&paaoAce1->ObjectType, &paaoAce2->ObjectType, sizeof(GUID)) != 0) 
        {
            return(FALSE);
        }
    }
    else {
        // Parent does not have object type. Make sure child does not have it either
        if (paaoAce2->Flags & ACE_OBJECT_TYPE_PRESENT) {
            return FALSE;
        }
    }

    if ( paaoAce1->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) 
    {
        pGuid1 = &paaoAce1->ObjectType;
        // compute the inherited object type guid offset
        if (paaoAce1->Flags & ACE_OBJECT_TYPE_PRESENT) {
            pGuid1++;
        }
        // the child ACE matches only if:
        if (paaoAce2->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            // ...child ACE has inherited type, that is the same as in parent ACE.
            // Compute the inherited object type guid offset
            pGuid2 = &paaoAce2->ObjectType;
            if (paaoAce2->Flags & ACE_OBJECT_TYPE_PRESENT) {
                pGuid2++;
            }
            if (memcmp(pGuid1, pGuid2, sizeof(GUID)) != 0) {
                // inherited object types don't match
                return FALSE;
            }
        }
        else {
            // Child ACE does not have inherited object type.
            // It can only possibly match parent ACE if child's class
            // is the same as the inherited object type in the parent
            // (i.e. this child ACE was inherited from parent ACE for
            // this particular child class).
            if (!fChildClassMatch) {
                // no, they don't match
                return FALSE;
            }
        }
    }
    else {
        // Parent does not have inherited object type. Make sure child does not have it either
        if (paaoAce2->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            return FALSE;
        }
    }


    // compute the SID ptrs
    ptr1 = (PBYTE) &paaoAce1->ObjectType;
    ptr2 = (PBYTE) &paaoAce2->ObjectType;

    if (paaoAce1->Flags & ACE_OBJECT_TYPE_PRESENT) 
    {
        ptr1 += sizeof(GUID);
        // at this point we know that child also has an object type
        ptr2 += sizeof(GUID);
    }

    if ( paaoAce1->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) 
    {
        ptr1 += sizeof(GUID);
        // at this point child would not have an inherited object type if parent did not have it
        if ( paaoAce2->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) {
            ptr2 += sizeof(GUID);
        }
    }
    

    // compare the SID part of the ACE
    //
    if (    pChildOwnerSid
         && RtlEqualSid((PSID) ptr1, pCreatorOwnerSid) )
    {
        return(RtlEqualSid((PSID) ptr2, pChildOwnerSid));
    }
    else if (    pChildGroupSid
              && RtlEqualSid((PSID) ptr1, pCreatorGroupSid) )
    {
        return(RtlEqualSid((PSID) ptr2, pChildGroupSid));
    }

    *pfSubstMatch = FALSE;
    return(RtlEqualSid((PSID) ptr1, (PSID) ptr2));
}

// 
// Determine if an ACE is class specific and if so, return the GUID.
//

BOOL
IsAceClassSpecific(
    ACE_HEADER  *pAce,      // IN
    GUID        *pGuid      // IN
    )
{
    ACCESS_ALLOWED_OBJECT_ACE   *paaoAce;
    GUID                        *p;

    // this is not an object based ACE, so it does not have a class
    if ( pAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
        return(FALSE);

    // object ACE
    paaoAce = (ACCESS_ALLOWED_OBJECT_ACE *) pAce;

    // if ACE_INHERITED_OBJECT_TYPE_PRESENT is set, we are inheriting an
    // object, property set, or property identified by the specific GUID.
    // so it is class specific.
    if ( paaoAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) 
    {
        p = (GUID *) &paaoAce->ObjectType;
        if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
            p++;

        *pGuid = *p;                    
        return(TRUE);
    }

    return(FALSE);
}

//
// Find an ACE in an ACL.  Intended use is to verify that inheritable ace 
// on a parent object is present on a child object.  The merge SD code does
// not guarantee that only one ACE in the child matches the ACE in the
// parent, so we check against all ACEs in the parent and return all matches.
//

VOID
FindAce(
    PACL            pAclChild,          // IN
    ACE_HEADER      *pAceParent,        // IN
    ACCESS_MASK     maskToMatch,        // IN - ACCESS_MASK bits to match on
    SID             *pChildOwner,       // IN - child owner SID
    SID             *pChildGroup,       // IN - child group SID
    BOOL            fChildClassMatch,   // IN - child class matches the inherited object type in AceParent
    DWORD           *pcAcesFound,       // OUT
    DWORD           **ppiAceChild,      // OUT
    AclPrintFunc    pfn,                // IN - OPTIONAL
    UCHAR           flagsRequired,      // IN
    UCHAR           flagsDisallowed,    // IN
    BOOL            fMapMaskOfParent,   // IN
    BOOL            *pfSubstMatch       // OUT
    )
{
    DWORD           i, dwErr;
    ACE_HEADER      *pAceChild;

    *pcAcesFound = 0;
    *ppiAceChild = (DWORD *) LocalAlloc(LPTR, 
                                        pAclChild->AceCount * sizeof(DWORD));

    if ( NULL == *ppiAceChild )
    {
        if ( pfn )
        {
            (*pfn)("*** Error: LocalAlloc failed, analysis incomplete\n");
        }

        return;
    }
        
    // iterate all ACEs and look for equal
    //
    for ( i = 0; i < pAclChild->AceCount; i++ )
    {
        // mariosz: so pAceChild is an OUT variable
        if ( !GetAce(pAclChild, i, &pAceChild) )
        {
            if ( pfn )
            {
                dwErr = GetLastError();
                (*pfn)("*** Error: GetAce ==> 0x%x - analysis incomplete\n",
                       dwErr);
            }

            LocalFree(*ppiAceChild);
            *ppiAceChild = NULL;
            *pcAcesFound = 0;
            return;
        }

        // add to array of equal ACEs
        //
        if (   (flagsRequired == (flagsRequired & pAceChild->AceFlags))
            && (0 == (flagsDisallowed & pAceChild->AceFlags))
            && IsEqualAce(pAceParent, pAceChild, maskToMatch,
                          pChildOwner, pChildGroup, fChildClassMatch, fMapMaskOfParent, 
                          pfSubstMatch) )
        {
            (*ppiAceChild)[*pcAcesFound] = i;
            *pcAcesFound += 1;
        }
    }

    if ( 0 == *pcAcesFound )
    {
        LocalFree(*ppiAceChild);
        *ppiAceChild = NULL;
    }
}

// 
// Perform various inheritance checks on the ACLs of an object and its child.
//

DWORD
CheckAclInheritance(
    PSECURITY_DESCRIPTOR pParentSD,             // IN
    PSECURITY_DESCRIPTOR pChildSD,              // IN
    GUID                **pChildClassGuids,     // IN
    DWORD               cChildClassGuids,       // IN
    AclPrintFunc        pfn,                    // IN - OPTIONAL
    BOOL                fContinueOnError,       // IN
    BOOL                fVerbose,               // IN
    DWORD               *pdwLastError           // OUT
    )
{   
    DWORD           iAceParent;     // index ace parent
    DWORD           iAceChild;      // index ace child
    DWORD           cAceParent;     // parent ace count
    DWORD           cAceChild;      // child ace count
    PACL            pAclParent;     // parent ACL
    PACL            pAclChild;      // child ACL
    ACE_HEADER      *pAceParent;    // parent ACE
    ACE_HEADER      *pAceChild;     // child ACE
    BOOL            present;
    BOOL            defaulted;
    ACCESS_MASK     *rInheritedChildMasks = NULL;
    GUID            guid;
    UCHAR           flagsRequired, flagsDisallowed, parentObjContFlags;
    DWORD           cAce1, cAce2, cAce2_5, cAce3;
    DWORD           *riAce1, *riAce2, *riAce2_5, *riAce3;
    DWORD           i1, i2, i3;
    BOOL            fClassSpecific;
    BOOL            fClassMatch;
    DWORD           dwErr;
    PSID            pChildOwner = NULL;
    PSID            pChildGroup = NULL;
    DWORD           iMask, iTmp;
    ACCESS_MASK     bitToMatch, maskToMatch;
    BOOL            fMatchedOnCreatorSubstitution;
    BOOL            fCase2_5;
    SECURITY_DESCRIPTOR_CONTROL Control = 0;
    DWORD           revision = 0;

    if ( !pParentSD || !pChildSD || !pChildClassGuids || !cChildClassGuids || !pdwLastError )
    {
        return(AclErrorNone);
    }

    *pdwLastError = 0;

    if (!GetSecurityDescriptorControl  (pChildSD, &Control, &revision)) {
        dwErr = GetLastError();

        if ( pfn )
        {
            (*pfn)("*** Warning: GetSecurityDescriptorControl ==> 0x%x - analysis may be incomplete\n", dwErr);
        }
    }

    // check to see if the childSD cannot inherit the DACL from his parent
    //
    if ( SE_DACL_PROTECTED & Control )
    {
        if ( pfn && fVerbose )
        {
            (*pfn)("*** Warning: Child has SE_DACL_PROTECTED set, therefore doesn't inherit - skipping test\n");
        }

        return(AclErrorNone);
    }

    // retrieve the owner information from the security descriptor of the child
    //
    if ( !GetSecurityDescriptorOwner(pChildSD, &pChildOwner, &defaulted) )
    {
        dwErr = GetLastError();
        pChildOwner = NULL;

        if ( pfn )
        {
            (*pfn)("*** Warning: GetSecurityDescriptorOwner ==> 0x%x - analysis may be incomplete\n", dwErr);
        }
    }

    // retrieve the primary group information from the security descriptor of the child
    //
    if ( !GetSecurityDescriptorGroup(pChildSD, &pChildGroup, &defaulted) )
    {
        dwErr = GetLastError();
        pChildGroup = NULL;

        if ( pfn )
        {
            (*pfn)("*** Warning: GetSecurityDescriptorGroup ==> 0x%x - analysis may be incomplete\n", dwErr);
        }
    }

    // retrieve pointers to the discretionary access-control list (DACL) 
    // in the security descriptor of the parent and child
    //
    pAclParent = pAclChild = NULL;
    if (    !GetSecurityDescriptorDacl(pParentSD, &present, 
                                       &pAclParent, &defaulted) 
         || !GetSecurityDescriptorDacl(pChildSD, &present, 
                                       &pAclChild, &defaulted) )
    {
        *pdwLastError = GetLastError();

        if ( pfn )
        {
            (*pfn)("*** Error: GetSecurityDescriptorDacl ==> 0x%x - analysis incomplete\n", *pdwLastError);
        }

        return(AclErrorGetSecurityDescriptorDacl);
    }

    if (pAclParent == NULL || pAclChild == NULL) {
        *pdwLastError = ERROR_INVALID_SECURITY_DESCR;

        if ( pfn )
        {
            (*pfn)("*** Error: DACL on parent and/or child is not present  - analysis incomplete\n");
        }

        return(AclErrorGetSecurityDescriptorDacl);
    }

    cAceParent = pAclParent->AceCount;
    cAceChild = pAclChild->AceCount;

    // Record ACCESS_MASKs of ACEs in child which have the INHERITED_ACE bit so
    // we can verify later that the child doesn't have mask bits
    // which are not present on (i.e. inherited from) the parent.

    // alloca may throw an exception. Catch it and fail.
    __try {
        rInheritedChildMasks = (ACCESS_MASK *) 
                                        alloca(cAceChild * sizeof(ACCESS_MASK));
    }
    __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        return AclErrorAlgorithmError;
    }
    
    for ( iAceChild = 0; iAceChild < cAceChild; iAceChild++ )
    {
        rInheritedChildMasks[iAceChild] = 0;

        if ( !GetAce(pAclChild, iAceChild, &pAceChild) )
        {
            *pdwLastError = GetLastError();

            if ( pfn )
            {
                (*pfn)("*** Error: GetAce ==> 0x%x - analysis incomplete\n", *pdwLastError);
            }

            return(AclErrorGetAce);
        }
        
        // INHERITED_ACE Indicates that the ACE was inherited from parent
        if ( pAceChild->AceFlags & INHERITED_ACE )
        {
            rInheritedChildMasks[iAceChild] = MaskFromAce(pAceChild, FALSE);
        }
    }

    // Iterate over parent's ACEs and check the child.

    for ( iAceParent = 0; iAceParent < cAceParent; iAceParent++ )
    {
        if ( !GetAce(pAclParent, iAceParent, &pAceParent) )
        {
            *pdwLastError = GetLastError();

            if ( pfn )
            {
                (*pfn)("*** Error: GetAce ==> 0x%x - analysis incomplete\n", *pdwLastError);
            }

            return(AclErrorGetAce);
        }

        // This is for Noncontainer child objects, which is not supported in the DS
        if ( pAceParent->AceFlags & OBJECT_INHERIT_ACE )
        {
            if ( pfn )
            {
                (*pfn)("*** Warning: Parent ACE [%d] is OBJECT_INHERIT_ACE but DS objects should be CONTAINER_INHERIT_ACE\n", iAceParent);
            }
        }

        // skip ACLs that are not inheritable
        if (    !(pAceParent->AceFlags & OBJECT_INHERIT_ACE)
             && !(pAceParent->AceFlags & CONTAINER_INHERIT_ACE) )
        {
            continue;
        }

        parentObjContFlags = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
        parentObjContFlags &= pAceParent->AceFlags;

        // check to see if the inheritable descriptor is class specific and
        // the child is of the same class
        //
        if ( (fClassSpecific = IsAceClassSpecific(pAceParent, &guid)) )
        {
            // ACE matches if its Class guid matches one of the child class guids
            DWORD i;
            fClassMatch = FALSE;
            for (i = 0; i < cChildClassGuids; i++) {
                if (0 == memcmp(pChildClassGuids[i], &guid, sizeof(GUID))) {
                    fClassMatch = TRUE;
                    break;
                }
            }
        }
        else
        {
            fClassMatch = FALSE;
        }

        // Iterate over parent ACE's inheritable ACCESS_MASK bits and 
        // check the child.  The access mask can be considered to have
        // three (potential) components:
        //
        // 1) Generic rights identified as GENERIC_* in ntseapi.h.
        // 2) Specific rights identified in ntseapi.h and accctrl.h.
        // 3) Implied rights which are obtained by mapping the generic rights.
        //
        // If there exists an inheritable ACE on the parent, then there
        // should exist child ACEs which cumulatively represent the generic
        // and specific rights.  The implied rights may also be represented,
        // but need not be.
        //
        // If there exists an inheritable ACE on the parent which is effective
        // on the child, then there should exist child ACEs which cumulatively
        // represent the specific rights and implied rights, but do NOT
        // represent the generic rights.
        //
        // Since the specific bits are a common case, we do that first.

        maskToMatch = MaskFromAce(pAceParent, FALSE) & ~GENERIC_BITS_MASK;

        for ( bitToMatch = 0x1, iMask = 0; 
              iMask < (sizeof(ACCESS_MASK) * 8); 
              bitToMatch = (bitToMatch << 1), iMask++ )
        {
            if ( !(bitToMatch & maskToMatch) )
            {
                // Current bitToMatch not present on parent.
                continue;
            }

            if (    (!fClassSpecific || (fClassSpecific && fClassMatch))
                 && !(pAceParent->AceFlags & NO_PROPAGATE_INHERIT_ACE) )
            {
                // Parent ACE applies to the child.  In this case we can have 
                // combinations of ACEs on the child as follows.  See CliffV!
                //
                // ACE 1: INHERIT_ONLY  + INHERITED + parentObjContFlags
                // ACE 2: !INHERIT_ONLY + INHERITED + !parentObjContFlags
                //
                // If the SID in the parent ACE is either Creator Owner or
                // Creator Group, (call this Creator XXX) then we must have 
                // the split case as this is the only way to end up with 
                // something which is both inheritable for Creator XXX and 
                // at the same time applicable on the child object for the 
                // owner/group in the child object SD.  So we disallow
                // matching on pChildOwner/pChildGroup when looking for ACE 1
                // and require it when looking for ACE 2.
                //
                // But there is an exception to this rule.  It could be that
                // the child has the following:
                //
                // ACE 2_5: !INHERIT_ONLY + INHERITED + parentObjContFlags
                //
                // This will occur if the child ACE is of the Creator XXX form
                // and the parent additionally has an inheritable ACE whose
                // SID happens to be the child's creator XXX SID.  In this case
                // ACE 2_5 is just like ACE 2 except that the parentObjContFlags
                // are carried forward in the child ACE as a result of the 
                // additional ACE in the parent.
                //
                //                    --- OR ---
                //
                // ACE 3: !INHERIT_ONLY + INHERITED + parentObjContFlags
                // 
                // In this case child ACE must have the same SID as the parent
                // ACE thus we disallow matching on pChildOwner/pChildGroup
                // when looking for the ACE.
                // 
                // N.B. It is legitimate to have both the ACE 1+2 case AND the
                // ACE 3 case concurrently in the child.  It is inefficient in
                // that the child has more ACEs than it needs, but it is valid.
    
                // ACE 1:
                flagsRequired = (   INHERIT_ONLY_ACE 
                                  | INHERITED_ACE 
                                  | parentObjContFlags);
                flagsDisallowed = 0;
                FindAce(pAclChild, pAceParent, bitToMatch,
                        NULL, NULL, fClassMatch, &cAce1, &riAce1, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);

                // ACE 2:
                flagsRequired = INHERITED_ACE;
                flagsDisallowed = (INHERIT_ONLY_ACE | parentObjContFlags);
                FindAce(pAclChild, pAceParent, bitToMatch,
                        pChildOwner, pChildGroup, fClassMatch, &cAce2, &riAce2, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);

                // ACE 2_5:
                flagsRequired = (INHERITED_ACE | parentObjContFlags);
                flagsDisallowed = INHERIT_ONLY_ACE;
                FindAce(pAclChild, pAceParent, bitToMatch,
                        pChildOwner, pChildGroup, fClassMatch, &cAce2_5, &riAce2_5, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);

                fCase2_5 = ( cAce2_5 && fMatchedOnCreatorSubstitution);
    
                // ACE 3:
                flagsRequired = (INHERITED_ACE | parentObjContFlags);
                flagsDisallowed = INHERIT_ONLY_ACE;
                FindAce(pAclChild, pAceParent, bitToMatch,
                        NULL, NULL, fClassMatch, &cAce3, &riAce3, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);
    
                if ( cAce1 && cAce2 )
                {
                    for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                        rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;
                    for ( iTmp = 0; iTmp < cAce2; iTmp++ )
                        rInheritedChildMasks[riAce2[iTmp]] &= ~bitToMatch;

                    if ( pfn && fVerbose )
                    {
                        (*pfn)("(Debug) Parent ACE [%d] specific Mask [0x%x] split into child ACEs [%d] and [%d] %s\n", iAceParent, bitToMatch, riAce1[0], riAce2[0], (((cAce1 > 1) || (cAce2 > 1)) ? "(and others)" : ""));
                    }

                    LocalFree(riAce1); riAce1 = NULL;
                    LocalFree(riAce2); riAce2 = NULL;
                }
                else if ( cAce1 && !cAce2 && fCase2_5 )
                {
                    for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                        rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;
                    for ( iTmp = 0; iTmp < cAce2_5; iTmp++ )
                        rInheritedChildMasks[riAce2_5[iTmp]] &= ~bitToMatch;
                    
                    if ( pfn && fVerbose )
                    {
                        (*pfn)("(Debug) Parent ACE [%d] specific Mask [0x%x] split1 into child ACEs [%d] and [%d] %s\n", iAceParent, bitToMatch, riAce1[0], riAce2_5[0], (((cAce1 > 1) || (cAce2_5 > 1)) ? "(and others)" : ""));
                    }

                    LocalFree(riAce1); riAce1 = NULL;
                    LocalFree(riAce2_5); riAce2_5 = NULL;
                }
                
                if ( cAce3 )
                {
                    for ( iTmp = 0; iTmp < cAce3; iTmp++ )
                        rInheritedChildMasks[riAce3[iTmp]] &= ~bitToMatch;

                    if ( pfn && fVerbose )
                    {
                        (*pfn)("(Debug) Parent ACE [%d] specific Mask [0x%x] found in child ACE [%d] %s\n", iAceParent, bitToMatch, riAce3[0], ((cAce3 > 1) ? "(and others)" : ""));
                    }

                    LocalFree(riAce3); riAce3 = NULL;
                }

                if ( riAce1 )   LocalFree(riAce1);
                if ( riAce2 )   LocalFree(riAce2);
                if ( riAce2_5 ) LocalFree(riAce2_5);
                if ( riAce3 )   LocalFree(riAce3);

                if (    !(    (cAce1 && cAce2) 
                           || (cAce1 && !cAce2 && fCase2_5) )
                     && !cAce3 )
                {
                    if ( pfn )
                    {
                        (*pfn)("*** Error: Parent ACE [%d] specific Mask [0x%x] not found1 in child\n", iAceParent, bitToMatch);
                    }
    
                    if ( fContinueOnError )
                    {
                        continue;
                    }
                    else
                    {
                        return(AclErrorParentAceNotFoundInChild);
                    }
                }
            }
            else if (    fClassSpecific 
                      && !fClassMatch
                      && !(pAceParent->AceFlags & NO_PROPAGATE_INHERIT_ACE) )
            {
                // All we should have on the child is an ACE with
                // INHERIT_ONLY + INHERITED + parentObjContFlags.
                // There should have been no mapping of Creator Owner
                // or Creator Group to the child's owner/group SID, 
                // thus we pass NULL for those parameters.
    
                flagsRequired = (   INHERIT_ONLY_ACE 
                                  | INHERITED_ACE 
                                  | parentObjContFlags);
                flagsDisallowed = 0;
                FindAce(pAclChild, pAceParent, bitToMatch,
                        NULL, NULL, fClassMatch, &cAce1, &riAce1, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);
    
                if ( cAce1 )
                {
                    for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                        rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;

                    if ( pfn && fVerbose )
                    {
                        (*pfn)("(Debug) Parent ACE [%d] specific Mask [0x%x] found in child ACE [%d] %s\n", iAceParent, bitToMatch, riAce1[0], ((cAce1 > 1) ? "(and others)" : ""));
                    }

                    LocalFree(riAce1);
                }
                else
                {
                    if ( pfn )
                    {
                        (*pfn)("*** Error: Parent ACE [%d] specific Mask [0x%x] not found2 in child\n", iAceParent, bitToMatch);
                    }
    
                    if ( fContinueOnError )
                    {
                        continue;
                    }
                    else
                    {
                        return(AclErrorParentAceNotFoundInChild);
                    }
                }
            }
            else if ( pAceParent->AceFlags & NO_PROPAGATE_INHERIT_ACE )
            {
                // Parent ACE applies to the child but should not inherit
                // past the child.  In this case all we require is an
                // effective ace on the child of the form:
                //
                // !INHERIT_ONLY + INHERITED + !parentObjContFlags
                //
                // The inherited ACE may show Creator XXX on the parent, thus
                // it needs to be mapped to the child's owner/group SID.

                flagsRequired = INHERITED_ACE;
                flagsDisallowed = (INHERIT_ONLY_ACE | parentObjContFlags);
                FindAce(pAclChild, pAceParent, bitToMatch,
                        pChildOwner, pChildGroup, fClassMatch, &cAce1, &riAce1, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);

                if ( cAce1 )
                {
                    for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                        rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;

                    if ( pfn && fVerbose )
                    {
                        (*pfn)("(Debug) Parent (NO_PROPAGATE_INHERIT) ACE [%d] specific Mask [0x%x] found in child ACE [%d] %s\n", iAceParent, bitToMatch, riAce1[0], ((cAce1 > 1) ? "(and others)" : ""));
                    }

                    LocalFree(riAce1); riAce1 = NULL;
                }
                else
                {
                    if ( pfn )
                    {
                        (*pfn)("*** Error: Parent ACE [%d] specific Mask [0x%x] not found1 in child\n", iAceParent, bitToMatch);
                    }
    
                    if ( fContinueOnError )
                    {
                        continue;
                    }
                    else
                    {
                        return(AclErrorParentAceNotFoundInChild);
                    }
                }
            }
            else
            {
                if ( pfn )
                {
                    (*pfn)("*** Error: Algorithm failure - unexpected condition!\n");
                }
    
                return(AclErrorAlgorithmError);
            }

        }   // for each bit in specific bits

        // Next verify that generic bits in the parent ACE are represented
        // in inheritable ACEs on the child.  Skip for NO_PROPAGATE_INHERIT_ACE
        // as in this case there is only an effective ACE on the child, not
        // an inheritable one.

        if ( pAceParent->AceFlags & NO_PROPAGATE_INHERIT_ACE )
        {
            goto SkipGenericTests;
        }

        maskToMatch = MaskFromAce(pAceParent, FALSE) & GENERIC_BITS_MASK;

        for ( bitToMatch = 0x1, iMask = 0; 
              iMask < (sizeof(ACCESS_MASK) * 8); 
              bitToMatch = (bitToMatch << 1), iMask++ )
        {
            if ( !(bitToMatch & maskToMatch) )
            {
                // Current bitToMatch not present on parent.
                continue;
            }

            // We wish to find an inheritable, non-effective ACE in the child 
            // with the corresponding bit set.  The reason it must be
            // non-effective is that effective ACEs can't have generic bits.
            // Since this is a non-effective ACE, there also isn't any
            // mapping of Creator Owner or Creator Group.
    
            flagsRequired = (   INHERIT_ONLY_ACE        // non-effective
                              | INHERITED_ACE           // inherited
                              | parentObjContFlags);    // inheritable
            flagsDisallowed = 0;
            FindAce(pAclChild, pAceParent, bitToMatch,
                    NULL, NULL, fClassMatch, &cAce1, &riAce1, pfn,
                    flagsRequired, flagsDisallowed, FALSE,
                    &fMatchedOnCreatorSubstitution);

            if ( cAce1 )
            {
                for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                    rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;

                if ( pfn && fVerbose )
                {
                    (*pfn)("(Debug) Parent ACE [%d] generic Mask [0x%x] found in child ACE [%d] %s\n", iAceParent, bitToMatch, riAce1[0], ((cAce1 > 1) ? "(and others)" : ""));
                }

                LocalFree(riAce1);
            }
            else
            {
                if ( pfn )
                {
                    (*pfn)("*** Error: Parent ACE [%d] generic Mask [0x%x] not found in child\n", iAceParent, bitToMatch);
                }

                if ( fContinueOnError )
                {
                    continue;
                }
                else
                {
                    return(AclErrorParentAceNotFoundInChild);
                }
            }
        }   // for each bit in generic bits

SkipGenericTests:

        // Next verify that implied bits in the parent ACE are represented 
        // in effective ACEs on the child.  So first check whether the
        // parent ACE is even effective for the child.

        if ( fClassSpecific && !fClassMatch )
        {
            goto SkipImpliedTests;
        }

        maskToMatch = MaskFromAce(pAceParent, TRUE);

        for ( bitToMatch = 0x1, iMask = 0; 
              iMask < (sizeof(ACCESS_MASK) * 8); 
              bitToMatch = (bitToMatch << 1), iMask++ )
        {
            if ( !(bitToMatch & maskToMatch) )
            {
                // Current bitToMatch not present on parent.
                continue;
            }

            // We wish to find an effective ACE in the child with the
            // corresponding bit set.  Since this is an effective ACE,
            // we need to map Creator Owner or Creator Group if present.
            // Since we don't really care whether the effective ACE
            // is inheritable or not, we don't ask for parentObjContFlags.

            flagsRequired = INHERITED_ACE;          // inherited
            flagsDisallowed = INHERIT_ONLY_ACE;     // effective
            FindAce(pAclChild, pAceParent, bitToMatch,
                    pChildOwner, pChildGroup, fClassMatch, &cAce1, &riAce1, pfn,
                    flagsRequired, flagsDisallowed, TRUE,
                    &fMatchedOnCreatorSubstitution);

            if ( cAce1 )
            {
                for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                    rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;

                if ( pfn && fVerbose )
                {
                    (*pfn)("(Debug) Parent ACE [%d] implied Mask [0x%x] found in child ACE [%d] %s\n", iAceParent, bitToMatch, riAce1[0], ((cAce1 > 1) ? "(and others)" : ""));
                }

                LocalFree(riAce1);
            }
            else
            {
                if ( pfn )
                {
                    (*pfn)("*** Error: Parent ACE [%d] implied Mask [0x%x] not found in child\n", iAceParent, bitToMatch);
                }

                if ( fContinueOnError )
                {
                    continue;
                }
                else
                {
                    return(AclErrorParentAceNotFoundInChild);
                }
            }
        }   // for each bit in implied bits

SkipImpliedTests:

        NULL;

    }   // for each ACE in parent

    // See if the child has any inherited ACCESS_MASKs which weren't on parent.

    for ( iAceChild = 0; iAceChild < cAceChild; iAceChild++ )
    {
        if ( rInheritedChildMasks[iAceChild] )
        {
            if ( pfn )
            {
                (*pfn)("*** Error: Child ACE [%d] Mask [0x%x] is INHERITED_ACE but there is no such inheritable ACE on parent\n", iAceChild, rInheritedChildMasks[iAceChild]);
            }

            if ( !fContinueOnError )
            {
                return(AclErrorInheritedAceOnChildNotOnParent);
            }
        }
    }

    return(AclErrorNone);
}

void DumpGUID (GUID *Guid, AclPrintFunc pfn)
{
    if ( Guid ) {

        (*pfn)( "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                     Guid->Data1, Guid->Data2, Guid->Data3, Guid->Data4[0],
                     Guid->Data4[1], Guid->Data4[2], Guid->Data4[3], Guid->Data4[4],
                     Guid->Data4[5], Guid->Data4[6], Guid->Data4[7] );
    }
}

void
DumpSID (PSID pSID, AclPrintFunc pfn)
{
    UNICODE_STRING StringSid;
    NTSTATUS status;
    
    status = RtlConvertSidToUnicodeString( &StringSid, pSID, TRUE );
    if (!NT_SUCCESS(status)) {
        (*pfn)( "(error converting SID to string %x)", status);
    }
    else {
        (*pfn)( "%wZ", &StringSid );
        RtlFreeUnicodeString( &StringSid );
    }
}

void
DumpAce(
    ACE_HEADER   *pAce,     // IN
    AclPrintFunc pfn,       // IN
    LookupGuidFunc pfnguid, // IN
    LookupSidFunc  pfnsid)  // IN
{
    ACCESS_ALLOWED_ACE          *paaAce = NULL;   //initialized to avoid C4701 
    ACCESS_ALLOWED_OBJECT_ACE   *paaoAce = NULL;  //initialized to avoid C4701
    GUID                        *pGuid;
    PBYTE                       ptr;
    ACCESS_MASK                 mask;
    CHAR                        *name;
    CHAR                        *label;
    BOOL                        fIsClass;

    (*pfn)("\t\tAce Type:  0x%x - ", pAce->AceType);
#define DOIT(flag) if (flag == pAce->AceType) (*pfn)("%hs\n", #flag)
    DOIT(ACCESS_ALLOWED_ACE_TYPE);
    DOIT(ACCESS_DENIED_ACE_TYPE);
    DOIT(SYSTEM_AUDIT_ACE_TYPE);
    DOIT(SYSTEM_ALARM_ACE_TYPE);
    DOIT(ACCESS_ALLOWED_COMPOUND_ACE_TYPE);
    DOIT(ACCESS_ALLOWED_OBJECT_ACE_TYPE);
    DOIT(ACCESS_DENIED_OBJECT_ACE_TYPE);
    DOIT(SYSTEM_AUDIT_OBJECT_ACE_TYPE);
    DOIT(SYSTEM_ALARM_OBJECT_ACE_TYPE);
#undef DOIT

    (*pfn)("\t\tAce Size:  %d bytes\n", pAce->AceSize);

    (*pfn)("\t\tAce Flags: 0x%x\n", pAce->AceFlags);
#define DOIT(flag) if (pAce->AceFlags & flag) (*pfn)("\t\t\t%hs\n", #flag)
    DOIT(OBJECT_INHERIT_ACE);
    DOIT(CONTAINER_INHERIT_ACE);
    DOIT(NO_PROPAGATE_INHERIT_ACE);
    DOIT(INHERIT_ONLY_ACE);
    DOIT(INHERITED_ACE);
#undef DOIT

    if ( pAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {
        paaAce = (ACCESS_ALLOWED_ACE *) pAce;
        mask = paaAce->Mask;
        (*pfn)("\t\tAce Mask:  0x%08x\n", mask);
    }
    else
    {
        // object ACE
        paaoAce = (ACCESS_ALLOWED_OBJECT_ACE *) pAce;
        mask = paaoAce->Mask;
        (*pfn)("\t\tObject Ace Mask:  0x%08x\n", mask);
    }

#define DOIT(flag) if (mask & flag) (*pfn)("\t\t\t%hs\n", #flag)
    DOIT(DELETE);
    DOIT(READ_CONTROL);
    DOIT(WRITE_DAC);
    DOIT(WRITE_OWNER);
    DOIT(SYNCHRONIZE);
    DOIT(ACCESS_SYSTEM_SECURITY);
    DOIT(MAXIMUM_ALLOWED);
    DOIT(GENERIC_READ);
    DOIT(GENERIC_WRITE);
    DOIT(GENERIC_EXECUTE);
    DOIT(GENERIC_ALL);
    DOIT(ACTRL_DS_CREATE_CHILD);
    DOIT(ACTRL_DS_DELETE_CHILD);
    DOIT(ACTRL_DS_LIST);
    DOIT(ACTRL_DS_SELF);
    DOIT(ACTRL_DS_READ_PROP);
    DOIT(ACTRL_DS_WRITE_PROP);
    DOIT(ACTRL_DS_DELETE_TREE);
    DOIT(ACTRL_DS_LIST_OBJECT);
    DOIT(ACTRL_DS_CONTROL_ACCESS);
#undef DOIT

    if ( pAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {

        if (pfnsid) {
            (*pfn)("\t\tAce Sid:   %hs\n",
               (*pfnsid)((PSID) &paaAce->SidStart));
        }
        else {
            (*pfn)("\t\tAce Sid:");
            DumpSID ((PSID) &paaAce->SidStart, pfn);
            (*pfn)("\n");
        }

    }
    else
    {
        // object ACE
        (*pfn)("\t\tObject Ace Flags: 0x%x\n" , paaoAce->Flags);

#define DOIT(flag) if (paaoAce->Flags & flag) (*pfn)("\t\t\t%hs\n", #flag)
        DOIT(ACE_OBJECT_TYPE_PRESENT);
        DOIT(ACE_INHERITED_OBJECT_TYPE_PRESENT);
#undef DOIT

        if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
        {
            (*pfn)("\t\tObject Ace Type: ");
            if (pfnguid) {
                (*pfnguid)((GUID *) &paaoAce->ObjectType, &name,
                       &label, &fIsClass);
                (*pfn)(" %hs - %hs\n", label, name);
            }
            else {
                DumpGUID ((GUID *)&paaoAce->ObjectType, pfn);
                (*pfn)("\n");
            }
        }

        if ( paaoAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT )
        {
            if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
                pGuid = &paaoAce->InheritedObjectType;
            else
                pGuid = &paaoAce->ObjectType;

            (*pfn)("\t\tInherited object type: ");
            if (pfnguid) {
                (*pfnguid)(pGuid, &name, &label, &fIsClass);
                (*pfn)("%hs - %hs\n", label, name);
            }
            else {
                DumpGUID (pGuid, pfn);
                (*pfn)("\n");
            }
        }

        ptr = (PBYTE) &paaoAce->ObjectType;

        if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
            ptr += sizeof(GUID);

        if ( paaoAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT )
            ptr += sizeof(GUID);

        if (pfnsid) {
            (*pfn)("\t\tObject Ace Sid:   %hs\n", (*pfnsid)((PSID) ptr));
        }
        else {
            (*pfn)("\t\tObject Ace Sid:");
            DumpSID ((PSID) ptr, pfn);
            (*pfn)("\n");
        }
    }
}


void
DumpAclHeader(
    PACL    pAcl,           // IN
    AclPrintFunc pfn)       // IN
{
    (*pfn)("\tRevision      %d\n", pAcl->AclRevision);
    (*pfn)("\tSize:         %d bytes\n", pAcl->AclSize);
    (*pfn)("\t# Aces:       %d\n", pAcl->AceCount);
}

//
// Dump an ACL to stdout in all its glory.
//

void
DumpAcl(
    PACL    pAcl,           // IN
    AclPrintFunc pfn,       // IN
    LookupGuidFunc pfnguid, //IN
    LookupSidFunc  pfnsid
    )
{
    DWORD                       dwErr;
    WORD                        i;
    ACE_HEADER                  *pAce;

    DumpAclHeader (pAcl, pfn);

    for ( i = 0; i < pAcl->AceCount; i++ )
    {
        (*pfn)("\tAce[%d]\n", i);

        if ( !GetAce(pAcl, i, (LPVOID *) &pAce) )
        {
            dwErr = GetLastError();
            (*pfn)("*** Error: GetAce ==> 0x%x - output incomplete\n",
                   dwErr);
        }
        else
        {
            DumpAce (pAce, pfn, pfnguid, pfnsid);
        }
    }
}


void DumpSDHeader (SECURITY_DESCRIPTOR *pSD,        // IN
                   AclPrintFunc        pfn)
{
    (*pfn)("SD Revision: %d\n", pSD->Revision);
    (*pfn)("SD Control:  0x%x\n", pSD->Control);
#define DOIT(flag) if (pSD->Control & flag) (*pfn)("\t\t%hs\n", #flag)
    DOIT(SE_OWNER_DEFAULTED);
    DOIT(SE_GROUP_DEFAULTED);
    DOIT(SE_DACL_PRESENT);
    DOIT(SE_DACL_DEFAULTED);
    DOIT(SE_SACL_PRESENT);
    DOIT(SE_SACL_DEFAULTED);
//  DOIT(SE_SE_DACL_UNTRUSTED);
//  DOIT(SE_SE_SERVER_SECURITY);
    DOIT(SE_DACL_AUTO_INHERIT_REQ);
    DOIT(SE_SACL_AUTO_INHERIT_REQ);
    DOIT(SE_DACL_AUTO_INHERITED);
    DOIT(SE_SACL_AUTO_INHERITED);
    DOIT(SE_DACL_PROTECTED);
    DOIT(SE_SACL_PROTECTED);
    DOIT(SE_SELF_RELATIVE);
#undef DOIT

}


//
// Dump a security descriptor to stdout in all its glory.
//

void
DumpSD(
    SECURITY_DESCRIPTOR *pSD,        // IN
    AclPrintFunc        pfn,         // IN 
    LookupGuidFunc      pfnguid,     // IN
    LookupSidFunc       pfnsid       // IN
    )
{
    DWORD   dwErr;
    PSID    owner, group;
    BOOL    present, defaulted;
    PACL    dacl, sacl;

    DumpSDHeader (pSD, pfn);

    if ( !GetSecurityDescriptorOwner(pSD, &owner, &defaulted) )
    {
        dwErr = GetLastError();
        (*pfn)("*** Error: GetSecurityDescriptorOwner ==> 0x%x - output incomplete\n", dwErr);
    }
    else
    {
        if (pfnsid) {
            (*pfn)("Owner%s: %hs\n",
               defaulted ? "(defaulted)" : "",
               (*pfnsid)(owner));
        }
        else {
            (*pfn)("Owner%hs:", defaulted ? "(defaulted)" : "");
            DumpSID (owner, pfn);
            (*pfn)("\n");
        }
    }

    if ( !GetSecurityDescriptorGroup(pSD, &group, &defaulted) )
    {
        dwErr = GetLastError();
        (*pfn)("*** Error: GetSecurityDescriptorGroup ==> 0x%x - output incomplete\n", dwErr);
    }
    else
    {
        if (pfnsid) {
            (*pfn)("Group%hs: %hs\n",
               defaulted ? "(defaulted)": "",
               (*pfnsid)(group));
        }
        else {
            (*pfn)("Group%hs", defaulted ? "(defaulted)" : "");
            DumpSID (group, pfn);
            (*pfn)("\n");
        }
    }

    if ( !GetSecurityDescriptorDacl(pSD, &present, &dacl, &defaulted) )
    {
        dwErr = GetLastError();
        (*pfn)("*** Error: GetSecurityDescriptorDacl ==> 0x%x - output incomplete\n", dwErr);
    }
    else if ( !present )
    {
        (*pfn)("DACL%hs not present\n", (defaulted ? "(defaulted)" : ""));
    }
    else if ( !dacl )
    {
        (*pfn)("DACL%hs is <NULL>\n", (defaulted ? "(defaulted)" : ""));
    }
    else
    {
        (*pfn)("DACL%hs:\n", (defaulted ? "(defaulted)" : ""));
        DumpAcl(dacl, pfn, pfnguid, pfnsid);
    }

    if ( !GetSecurityDescriptorSacl(pSD, &present, &sacl, &defaulted) )
    {
        dwErr = GetLastError();
        (*pfn)("*** Error: GetSecurityDescriptorSacl ==> 0x%x - output incomplete\n", dwErr);
    }
    else if ( !present )
    {
        (*pfn)("SACL%hs not present\n", (defaulted ? "(defaulted)" : ""));
    }
    else if ( !sacl )
    {
        (*pfn)("SACL%hs is <NULL>\n", (defaulted ? "(defaulted)" : ""));
    }
    else
    {
        (*pfn)("SACL%hs:\n", (defaulted ? "(defaulted)" : ""));
        DumpAcl(sacl, pfn, pfnguid, pfnsid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\atq\tracelog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG {

    //
    // Signature.
    //

    LONG Signature;

    //
    // The total number of entries available in the log.
    //

    LONG LogSize;

    //
    // The index of the next entry to use.
    //

    LONG NextEntry;

    //
    // The byte size of each entry.
    //

    LONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR LogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((DWORD)'gOlT')
#define TRACE_LOG_SIGNATURE_X ((DWORD)'golX')


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dscommon\dbopen.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dbopen.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains the subroutines that are related to opening
    the DS Jet database. These subroutines are used in two places:
        In the core DS and
        in the various utilities that want to open the DS database directly.

    A client application that wants to open the DS database, has to follow these steps:
        call DBSetRequiredDatabaseSystemParameters
        call DBInitializeJetDatabase

    In order to close the database it has to follow the standard Jet procedure.

Author:

    MariosZ 6-Feb-99

Environment:

    User Mode - Win32

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <errno.h>
#include <esent.h>
#include <dsconfig.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>

#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>


#include <mdcodes.h>
#include <dsevent.h>
#include <dsexcept.h>
#include <dbopen.h>
#include "anchor.h"
#include "objids.h"     /* Contains hard-coded Att-ids and Class-ids */
#include "usn.h"
#include "debug.h"      /* standard debugging header */
#define DEBSUB     "DBOPEN:"   /* define the subsystem for debugging */
#include <ntdsctr.h>
#include <dstaskq.h>
#include <fileno.h>
#define  FILENO FILENO_DBOPEN
#include "dbintrnl.h"


/*
 * Global variables
 */
BOOL  gFirstTimeThrough = TRUE;
BOOL  gfNeedJetShutdown = FALSE;
ULONG gulCircularLogging = TRUE;


/* put name and password definitions here for now.  At some point
   someone or something must enter these.
*/

// NOTICE-2002/03/07-andygo:  JET hard coded password
// REVIEW:  JET does not use this user/password because it does not support security
// REVIEW:  based on a user.  these are left over parameters from JET Red.

#define SZUSER          "admin"         /* JET user name */
#define SZPASSWORD      "password"      /* JET password */

/* Global variables for JET user name and password,
   JET database pathname, and column IDs for fixed columns.
   externals defined in dbjet.h
*/

char            szUser[] = SZUSER;
char            szPassword[] = SZPASSWORD;
char            szJetFilePath[MAX_PATH+1];
ULONG           gcMaxJetSessions;

//
// Used for detecting drive name change
//
DS_DRIVE_MAPPING DriveMappings[DS_MAX_DRIVES] = {0};


DWORD gcOpenDatabases = 0;

// if 1, then we allow disk write caching.
//
DWORD gulAllowWriteCaching = 0;


//  schema of "AttributeIndexRebuild" table, which enumerates all
//  attribute indices on the datatable in case Jet deletes some
//
CHAR                g_szIdxRebuildIndexKey[]        = "+" g_szIdxRebuildColumnIndexName "\0";

JET_COLUMNCREATE    g_rgcolumncreateIdxRebuild[]    =
    {
    {   sizeof(JET_COLUMNCREATE),
        g_szIdxRebuildColumnIndexName,
        JET_coltypText,
        JET_cbNameMost,
        JET_bitColumnNotNULL,
        NULL,           //  pvDefault
        0,              //  cbDefault
        CP_NON_UNICODE_FOR_JET,
        0,              //  columnid
        JET_errSuccess
    },
    {   sizeof(JET_COLUMNCREATE),
        g_szIdxRebuildColumnAttrName,
        JET_coltypText,
        JET_cbNameMost,
        JET_bitColumnNotNULL,
        NULL,           //  pvDefault
        0,              //  cbDefault
        CP_NON_UNICODE_FOR_JET,
        0,              //  columnid
        JET_errSuccess
    },
    {   sizeof(JET_COLUMNCREATE),
        g_szIdxRebuildColumnType,
        JET_coltypText,
        1,              //  cbMax
        NO_GRBIT,
        NULL,           //  pvDefault
        0,              //  cbDefault
        CP_NON_UNICODE_FOR_JET,              //  cp
        0,              //  columnid
        JET_errSuccess
    },
    };

#define g_ccolumncreateIdxRebuild   ( sizeof( g_rgcolumncreateIdxRebuild ) / sizeof( JET_COLUMNCREATE ) )
        
JET_INDEXCREATE     g_rgindexcreateIdxRebuild[]  =
    {
    {   sizeof(JET_INDEXCREATE),
        g_szIdxRebuildIndexName,
        g_szIdxRebuildIndexKey,
        sizeof(g_szIdxRebuildIndexKey),
        JET_bitIndexPrimary | JET_bitIndexUnique | JET_bitIndexDisallowNull,
        100,            //  density
        0,              //  lcid
        0,              //  cbVarSegMac
        NULL,           //  rgConditionalColumn
        0,              //  cConditionalColumn
        JET_errSuccess
    }
    };

#define g_cindexcreateIdxRebuild    ( sizeof( g_rgindexcreateIdxRebuild ) / sizeof( JET_INDEXCREATE ) )

JET_TABLECREATE     g_tablecreateIdxRebuild     =
    {
    sizeof(JET_TABLECREATE),
    g_szIdxRebuildTable,
    NULL,               //  template table
    1,                  //  pages
    100,                //  density
    g_rgcolumncreateIdxRebuild,
    g_ccolumncreateIdxRebuild,
    g_rgindexcreateIdxRebuild,
    g_cindexcreateIdxRebuild,
    JET_bitTableCreateFixedDDL,
    JET_tableidNil,
    0                   //  cCreated
    };


    extern int APIENTRY DBAddSess(JET_SESID sess, JET_DBID dbid);

BOOL
DsNormalizePathName(
    char * szPath
    )
/*++

Routine Description:

    This routine attempts to normalize the path provided and returns whether
    it had to normalize (modify) the path.  However, we don't actually change
    the meaning of the path, that's important.  I.e. these path names on the
    left should equal the same thing on the right as far as the OS is 
    concerned.

    Brief overview of expected behaviour

          returns TRUE (meaning it needed normalizing)
       C:\\ -> C:\
       C:\\ntds.dit -> C:\ntds.dit
       C:\ntds\\ntds.dit -> C:\ntds.dit
       C:\ntds\ -> C:\ntds
       C:\ntds\\\\\ntds.dit -> C:\ntds\ntds.dit

          returns FALSE (meaning already normalized)
       C:\ -> C:\
       C:\ntds -> C:\ntds
       C:\ntds\ntds.dit -> C:\ntds\ntds.dit

Arguments:

    szPath - Path to be normalized, this string will be modified/normalized, but 
        only in ways that take up less space than the original string.

Return Value:

    TRUE or FALSE depending on whether we had to normalize the path or not.

*/
{
    ULONG  i, c;
    BOOL   bRet = FALSE;

    c = strlen(szPath);

    if(szPath == NULL || c <= 2 || szPath[1] != ':' || szPath[2] != '\\'){
        Assert(!"This function encountered a path not starting with '<drive>:\'.");
        return(FALSE);
    }

    // Check for a bad path of any form with multiple backslashes "//"
    for (i = 1; szPath[i] != '\0'; i++){
        if(szPath[i] == '\\' && szPath[i-1] == '\\'){
            // Multiple backslashes in a row.
            memmove( &(szPath[i]), &(szPath[i+1]), strlen(&(szPath[i])) );
            bRet = TRUE;
            i--;
        }
    }

    c = strlen(szPath);
    if(c > 3 && szPath[c-1] == '\\'){
        // Trailing backslashes aren't supposed to be on directories, except of the root form "C:\"
        szPath[c-1] = '\0';
        bRet = TRUE;
    }


    return(bRet);
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function gets the path to the database files from the registry
*/
BOOL dbGetFilePath(UCHAR *pFilePath, DWORD dwSize)
{

   DPRINT(2,"dbGetFilePath entered\n");

   if (GetConfigParam(FILEPATH_KEY, pFilePath, dwSize)){
      DPRINT(1,"Missing FilePath configuration parameter\n");
      return !0;
   }

   if (DsNormalizePathName(pFilePath)){
       Assert(!"Only on a very rare win2k -> .NET upgrade case could this happen!?"); 
       SetConfigParam(FILEPATH_KEY, REG_SZ, pFilePath, strlen(pFilePath)+1);
   }

   return 0;

}/*dbGetFilePath*/


BOOL
DisableDiskWriteCache(
    IN PCHAR DriveName
    );

//
// points to the drive mapping array used to resolve drive letter/volume mappings
//

PDS_DRIVE_MAPPING   gDriveMapping = NULL;


INT
FindDriveFromVolume(
    IN LPCSTR VolumeName
    )
/*++

Routine Description:

    Searches for the drive letter corresponding to the given volume name.

Arguments:

    VolumeName - The volume name used to find the drive letter for

Return Value:

    the drive letter (zero indexed i.e. a=0,z=25) if successful
    -1 if not.

--*/
{

    CHAR volname[MAX_PATH];
    CHAR driveLetter;
    CHAR path[4];
    path[1] = ':';
    path[2] = '\\';
    path[3] = '\0';

    for (driveLetter = 'a'; driveLetter <= 'z'; driveLetter++ ) {

        path[0] = driveLetter;

        if (!GetVolumeNameForVolumeMountPointA(path,volname,MAX_PATH)) {
            continue;
        }


        if ( _stricmp(volname, VolumeName) == 0) {

            return (INT)(driveLetter - 'a');
        }
    }

    DPRINT1(0,"FindDriveFromVolume for %s not found.\n",VolumeName);
    return -1;

} // FindDriveFromVolume



VOID
DBInitializeDriveMapping(
    IN PDS_DRIVE_MAPPING DriveMapping
    )
/*++

Routine Description:

    Read the current registry setting for the mapping and detects if something
    has changed.

Arguments:

    DriveMapping - the drive mapping structure to record changes

Return Value:

    None.

--*/
{
    PCHAR p;
    HKEY hKey;
    CHAR tmpBuf[4 * MAX_PATH];
    DWORD nRead = sizeof(tmpBuf);
    DWORD err;
    DWORD type;

    gDriveMapping = DriveMapping;

    //
    // Write it down
    //

    // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
    // REVIEW:  we could ask for just KEY_READ
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       DSA_CONFIG_SECTION,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey);

    if ( err != ERROR_SUCCESS ) {
        DPRINT2(0,"RegOpenKeyEx[%s] failed with %d\n",DSA_CONFIG_SECTION,err);
        return;
    }

    err = RegQueryValueEx(hKey,
                          DSA_DRIVE_MAPPINGS,
                          NULL,
                          &type,
                          tmpBuf,
                          &nRead
                          );

	//	close key after use
	//
    RegCloseKey(hKey);

    // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
    // REVIEW:  should check that string from reg is double NULL terminated to avoid AV below
    if ( err != ERROR_SUCCESS ) {
        DPRINT2(0,"RegQueryValueEx[%s] failed with %d\n",
                DSA_DRIVE_MAPPINGS,err);
        goto cleanup;
    }

    p = tmpBuf;
    while (*p != '\0') {

        CHAR path[4];
        DWORD drive;
        CHAR volName[MAX_PATH];

        CopyMemory(path,p,3);
        path[3] = '\0';
        path[0] = (CHAR)tolower(path[0]);
        p += 3;

        //
        // Should be X:\=\\?\Volume{...}\
        //

        if ( isalpha(path[0]) &&
             (path[1] == ':') &&
             (path[2] == '\\') &&
             (*p == '=') ) {

            p++;
            drive = path[0] - 'a';

            //
            // Get the volume name for the listed path and see if it matches
            //

            gDriveMapping[drive].fListed = TRUE;
            if (GetVolumeNameForVolumeMountPointA(path,volName,sizeof(volName)) ) {

                //
                // if it matches, go on.
                //

                if ( _stricmp(p, volName) == 0 ) {
                    p += strlen(p) + 1;
                    continue;
                } else {
                    DPRINT3(0,"Drive path %s has changed[%s != %s]\n",path,p,volName);
                }
            } else {
                DPRINT2(0,"GetVolName[%s] failed with %d\n",path,GetLastError());
            }

            //
            // Either we could not get the volume info or it did not match.  Mark
            // it as changed.
            //

            gDriveMapping[drive].fChanged = TRUE;
            gDriveMapping[drive].NewDrive = FindDriveFromVolume(p);

            p += strlen(p) + 1;

        } else {
            DPRINT1(0,"Invalid path name [%s] found in mapping.\n", path);
            goto cleanup;
        }
    }

cleanup:
    return;

} // DBInitializeDriveMapping




VOID
DBRegSetDriveMapping(
    VOID
    )
/*++

Routine Description:

    Writes out the drive information to the registry

Arguments:

    None.

Return Value:

    None.

--*/
{

    DWORD i;
    DWORD err;

    CHAR tmpBuf[5 * MAX_PATH]; // we may have 5 paths in the worst case
    PCHAR p;

    HKEY hKey;
    BOOL  fOverwrite = FALSE;

    if ( gDriveMapping == NULL ) {
        return;
    }

    //
    // Go through the list to figure out if we need to change anything
    //

    for (i=0;i < DS_MAX_DRIVES;i++) {

        //
        // if anything has changed, we need to overwrite.
        //

        if ( gDriveMapping[i].fChanged ||
             (gDriveMapping[i].fUsed != gDriveMapping[i].fListed) ) {

            fOverwrite = TRUE;
            break;
        }
    }

    //
    // if the old regkeys are fine, we're done.
    //

    if ( !fOverwrite ) {
        return;
    }

    //
    // Write it down
    //

    // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
    // REVIEW:  we could ask for just KEY_WRITE
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       DSA_CONFIG_SECTION,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey);

    if ( err != ERROR_SUCCESS ) {
        DPRINT2(0,"RegOpenKeyEx[%s] failed with %d\n",DSA_CONFIG_SECTION,GetLastError());
        return;
    }

    //
    // Delete the old key
    //

    err = RegDeleteValue(hKey, DSA_DRIVE_MAPPINGS);

    if ( err != ERROR_SUCCESS ) {
        DPRINT2(0,"RegDeleteValue[%s] failed with %d\n",DSA_DRIVE_MAPPINGS,GetLastError());
        // ignore
    }

    //
    // Compose the new key
    //

    p = tmpBuf;
    for (i=0;i<DS_MAX_DRIVES;i++) {

        //
        // format of each entry is X:=\\?\Volume{...}
        //

        if ( gDriveMapping[i].fUsed ) {

            CHAR path[4];

            strcpy(path,"a:\\");
            path[0] = (CHAR)('a' + i);

            strcpy(p, path);
            p[3] = '=';
            p += 4;

            if (!GetVolumeNameForVolumeMountPointA(path,p,MAX_PATH)) {

                DPRINT2(0,"GetVolumeName[%s] failed with %d\n",path,GetLastError());
                p -= 4;
                break;
            }

            p += (strlen(p)+1);
        }
    }

    *p++ = '\0';

    //
    // Set the new key
    //

    if ( (DWORD)(p-tmpBuf) != 0 ) {

        err = RegSetValueEx(hKey,
                            DSA_DRIVE_MAPPINGS,
                            0,
                            REG_MULTI_SZ,
                            tmpBuf,
                            (DWORD)(p - tmpBuf)
                            );

        if ( err != ERROR_SUCCESS ) {
            DPRINT2(0,"RegSetValueEx[%s] failed with %d\n",
                    DSA_DRIVE_MAPPINGS,GetLastError());
        }
    }

    RegCloseKey(hKey);
    return;

} // DBRegSetDriveMapping




VOID
ValidateDsPath(
    IN LPSTR  Parameter,
    IN LPSTR  szPath,
    IN DWORD  Flags,
    IN PBOOL  fSwitched, OPTIONAL
    IN PBOOL  fDriveChanged OPTIONAL
    )
/*++

Routine Description:

    Takes a path and see if it is still valid.  If not, it detects whether a drive
    letter change happened and tries to use the old drive letter.

Arguments:

    Parameter - reg key used to store the path
    szPath - the current value for the path
    Flags - Flags to specify some options. Valid options are:
        VALDSPATH_DIRECTORY
        VALDSUSE_ALTERNATE
        VALDSUSE_ROOT_ONLY
    fSwitched - Did we change the value of szPath on exit?
    fDriveChanged - allows us to indicate whether there was a drive name change

Return Value:

    None.

--*/
{
    DWORD drive;
    DWORD flags;
    CHAR tmpPath[MAX_PATH+1];
    DWORD err;
    CHAR savedChar;

    DWORD expectedFlag =
        ((Flags & VALDSPATH_DIRECTORY) != 0) ? FILE_ATTRIBUTE_DIRECTORY:0;

    if (gDriveMapping == NULL) return;

    if ( fSwitched != NULL ) {
        *fSwitched = FALSE;
    }

    if ( fDriveChanged != NULL ) {
        *fDriveChanged = FALSE;
    }

    //
    // make sure the path starts with X:\\
    //

    if ( !isalpha(szPath[0]) || (szPath[1] != ':') || (szPath[2] != '\\') ) {
        return;
    }

    //
    // get the drive number a == 0, ..., z== 25
    //

    drive = tolower(szPath[0]) - 'a';

    //
    // if fChange is FALSE, that means that no rename happened.
    //

    if ( !gDriveMapping[drive].fChanged ) {

        //
        // indicate that we saw these
        //

        gDriveMapping[drive].fUsed = TRUE;
        return;
    }

    if ( fDriveChanged != NULL ) {
        *fDriveChanged = TRUE;
    }

    //
    // see if we're told to skip the first one
    //

    if ( (Flags & VALDSPATH_USE_ALTERNATE) != 0 ) {
        goto use_newdrive;
    }

    //
    // if we want to check the root only. terminate after the \\
    //

    savedChar = szPath[3];
    if ( (Flags & VALDSPATH_ROOT_ONLY) != 0 ) {
        szPath[3] = '\0';
    }

    //
    // there was a rename. See if the path is still valid.
    //

    flags = GetFileAttributes(szPath);
    szPath[3] = savedChar;

    //
    // if we failed or it is a directory or file (depending on what the user wanted),
    // then we're ok.
    //

    if ( (flags != 0xffffffff) && ((flags & FILE_ATTRIBUTE_DIRECTORY) == expectedFlag) ) {
        gDriveMapping[drive].fUsed = TRUE;
        return;
    }

use_newdrive:

    //
    // not a valid directory, try with the new drive letter
    //

    strcpy(tmpPath, szPath);
    tmpPath[0] = gDriveMapping[drive].NewDrive + 'a';

    //
    // if we want to check the root only. terminate after the \\
    //

    savedChar = tmpPath[3];
    if ( (Flags & VALDSPATH_ROOT_ONLY) != 0 ) {
        tmpPath[3] = '\0';
    }

    //
    // see if this is ok.  If not, return.
    //

    flags = GetFileAttributes(tmpPath);
    tmpPath[3] = savedChar;

    //
    // if it failed, then use the original one.
    //

    if ( (flags == 0xffffffff) || ((flags & FILE_ATTRIBUTE_DIRECTORY) != expectedFlag) ) {
        DPRINT3(0,"ValidateDsPath: GetFileAttribute [%s] failed with %d. Using %s.\n",
                tmpPath, GetLastError(),szPath);
        gDriveMapping[drive].fUsed = TRUE;
        return;
    }

    //
    // We are going out on a limb here and declare that because it failed
    // with the current path and succeeded with the old path, we are going to
    // change back to the old path.  Log an event and write back to registry
    //

    err = SetConfigParam(Parameter, REG_SZ, tmpPath, strlen(tmpPath)+1);
    if ( err != ERROR_SUCCESS ) {
        DPRINT3(0,"SetConfigParam[%s, %s] failed with %d\n",Parameter, szPath, err);
        gDriveMapping[drive].fUsed = TRUE;
        return;
    }

    // log an event

    DPRINT3(0,"Changing %s key from %s to %s\n",Parameter,szPath,tmpPath);

    LogEvent(DS_EVENT_CAT_STARTUP_SHUTDOWN,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_DB_REG_PATH_CHANGED,
             szInsertSz(Parameter),
             szInsertSz(szPath),
             szInsertSz(tmpPath));

    //
    // Mark this new drive as being used
    //

    gDriveMapping[gDriveMapping[drive].NewDrive].fUsed = TRUE;

    szPath[0] = tmpPath[0];
    if ( fSwitched != NULL ) {
        *fSwitched = TRUE;
    }

    return;

} // ValidateDsPath


VOID
DsaDetectAndDisableDiskWriteCache(
    IN PCHAR szPath
    )
/*++

Routine Description:

    Detect and disable disk write cache.

Arguments:

    szPath - Null terminated pathname on drive to disable.  Should start with X:\

Return Value:

   None.

--*/
{
    CHAR driveName[3];
    DWORD driveNum;

    //
    // see if we should do the check
    //

    if ( gulAllowWriteCaching == 1 ) {
        return;
    }

    //
    // Get and check path
    //

    if ( !isalpha(szPath[0]) || (szPath[1] != ':') ) {
        return;
    }

    driveName[0] = (CHAR)tolower(szPath[0]);
    driveName[1] = ':';
    driveName[2] = '\0';

    //
    // If disk write cache is enabled, log an event
    //

    if ( DisableDiskWriteCache( driveName ) ) {

        LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DISABLE_DISK_WRITE_CACHE,
                 szInsertSz(driveName),
                 NULL,
                 0);

    } else {

        //
        // If the disk did not respond properly to our disable attempts,
        // log an error
        //

        if ( GetLastError() == ERROR_IO_DEVICE) {
            LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_FAILED_TO_DISABLE_DISK_WRITE_CACHE,
                     szInsertSz(driveName),
                     NULL,
                     0);
        }
    }

    return;

} // DsaDetectDiskWriteCache


void
DBSetRequiredDatabaseSystemParameters (JET_INSTANCE *jInstance)
{
    ULONG ulPageSize = JET_PAGE_SIZE;               // jet page size
    const ULONG ulLogFileSize = JET_LOG_FILE_SIZE;  // Never, ever, change this.
    ULONG ulMaxTables;
    char  szSystemDBPath[MAX_PATH] = "";
    char  szTempDBPath[2 * MAX_PATH] = "";
    char  szRecovery[MAX_PATH] = "";
    JET_SESID sessid = (JET_SESID) 0;
    JET_UNICODEINDEX      unicodeIndexData;
    JET_ERR                 jErr;
    BOOL fDeleteOutOfRangeLogs = TRUE;


    //
    // Initialize Drive mapping to handle drive name changes
    //

    DBInitializeDriveMapping(DriveMappings);


    // Set the default info for unicode indices

    memset(&unicodeIndexData, 0, sizeof(unicodeIndexData));
    unicodeIndexData.lcid = DS_DEFAULT_LOCALE;
    unicodeIndexData.dwMapFlags = (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                   LCMAP_SORTKEY);
    JetSetSystemParameter(
            jInstance,
            sessid,
            JET_paramUnicodeIndexDefault,
            (ULONG_PTR)&unicodeIndexData,
            NULL);


    // Ask for 8K pages.

    JetSetSystemParameter(
                    jInstance,
                    sessid,
                    JET_paramDatabasePageSize,
                    ulPageSize,
                    NULL);

    // Indicate that Jet may nuke old, incompatible log files
    // if and only if there was a clean shut down.

    JetSetSystemParameter(jInstance,
                          sessid,
                          JET_paramDeleteOldLogs,
                          1,
                          NULL);

    // Tell Jet that it's ok for it to check for (and later delete) indices
    // that have been corrupted by NT upgrades.
    JetSetSystemParameter(jInstance,
                          sessid,
                          JET_paramEnableIndexChecking,
                          TRUE,
                          NULL);


    //
    // Get relevant DSA registry parameters
    //

    // system DB path
    // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
    // REVIEW:  need to check for or ensure this path is NULL terminated
    if (!GetConfigParam(
            JETSYSTEMPATH_KEY,
            szSystemDBPath,
            sizeof(szSystemDBPath)))
    {

        //
        // Handle the drive rename case
        //

        ValidateDsPath(JETSYSTEMPATH_KEY,
                       szSystemDBPath,
                       VALDSPATH_DIRECTORY,
                       NULL, NULL);

        //
        // Disable write caching to avoid jet corruption
        //

        DsaDetectAndDisableDiskWriteCache(szSystemDBPath);

        // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
        // REVIEW:  need to check for invalid parameter
        JetSetSystemParameter(jInstance,
                sessid,
                JET_paramSystemPath,
                0,
                szSystemDBPath);
        /* setup the temp file path, which is
         * the working directory path + "\temp.edb"
         */
        strcpy(szTempDBPath, szSystemDBPath);
        strcat(szTempDBPath, "\\temp.edb");
        if(DsNormalizePathName(szTempDBPath)){
            Assert(strlen(szSystemDBPath) == 3 && "Only on a very rare win2k -> .NET upgrade case could this happen!?"); 
        }

        // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
        // REVIEW:  need to check for invalid parameter
        JetSetSystemParameter(jInstance,
                sessid,
                JET_paramTempPath,
                0,
                szTempDBPath);
    }
    else
    {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(JETSYSTEMPATH_KEY),
            NULL,
            NULL);
    }


    // recovery
    // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
    // REVIEW:  need to check for or ensure this path is NULL terminated
    if (!GetConfigParam(
            RECOVERY_KEY,
            szRecovery,
            sizeof(szRecovery)))
    {
        JetSetSystemParameter(jInstance,
                sessid,
                JET_paramRecovery,
                0,
                szRecovery);
    }
    else
    {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(RECOVERY_KEY),
            NULL,
            NULL);
    }


    //
    // In order to get to the root of some of the suspected Jet problems,
    // force Jet asserts to break into the debugger. Note, you must use
    // a debug version of ese.dll for Jet asserts.

    // how to die
    JetSetSystemParameter(jInstance,
        sessid,
        JET_paramAssertAction,
        // gfRunningInsideLsa ? JET_AssertStop: JET_AssertMsgBox,
        JET_AssertBreak,
        NULL);



    // event logging parameters
    JetSetSystemParameter(jInstance,
        sessid,
        JET_paramEventSource,
        0,
        SERVICE_NAME);




    // log file size
    JetSetSystemParameter(jInstance,
                          sessid,
                          JET_paramLogFileSize,
                          ulLogFileSize,
                          NULL);


    // max tables - Currently no reason to expose this
    // In Jet600, JET_paramMaxOpenTableIndexes is removed. It is merged with
    // JET_paramMaxOpenTables. So if you used to set JET_paramMaxOpenIndexes
    // to be 2000 and and JET_paramMaxOpenTables to be 1000, then for new Jet,
    // you need to set JET_paramMaxOpenTables to 3000.

    // AndyGo 7/14/98: You need one for each open table index, plus one for
    // each open table with no indexes, plus one for each table with long
    // column data, plus a few more.
    
    // NOTE: the number of maxTables is calculated in scache.c
    // and stored in the registry setting, only if it exceeds the default 
    // number of 500

    if (GetConfigParam(
            DB_MAX_OPEN_TABLES,
            &ulMaxTables,
            sizeof(ulMaxTables)))
    {
        ulMaxTables = 500;

        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(DB_MAX_OPEN_TABLES),
            szInsertUL(ulMaxTables),
            NULL);
    }

    if (ulMaxTables < 500) {
        DPRINT1 (1, "Found MaxTables: %d. Too low. Using Default of 500.\n", ulMaxTables);
        ulMaxTables = 500;
    }
    
    // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
    // REVIEW:  we should probably put a ceiling on DB_MAX_OPEN_TABLES to prevent
    // REVIEW:  insane VA consumption by JET

    JetSetSystemParameter(jInstance,
        sessid,
        JET_paramMaxOpenTables,
        ulMaxTables * 2,
        NULL);

    // circular logging used to be exposed through a normal reg key, but
    // now only through a heuristic.  That heuristic should have altered
    // the global, if needed.
    JetSetSystemParameter(jInstance,
                          sessid,
                          JET_paramCircularLog,
                          gulCircularLogging,
                          NULL);

    // Assumed that we should delete out of range logs if the user didn't set 
    // the DWORD registry entry to zero.
    if (GetConfigParam(DELETE_OUTOFRANGE_LOGS, 
                       &fDeleteOutOfRangeLogs, 
                       sizeof(fDeleteOutOfRangeLogs)) != ERROR_SUCCESS ||
        fDeleteOutOfRangeLogs) {
        
        // We delete out of range log files by default, because snapshot restores 
        // won't by default clear the logs directory first, so we have to tell JET
        // to do it, so it doesn't get confused on a snapshot restore.
        jErr = JetSetSystemParameter(jInstance, sessid, JET_paramDeleteOutOfRangeLogs, 1, NULL);
        Assert(jErr == JET_errSuccess);
    }

} /* DBSetRequiredDatabaseSystemParameters */


//  build a list of all attribute indexes and store that list
//  in the AttributeIndexRebuild table
//
JET_ERR dbEnumerateAttrIndices(
    const JET_SESID     sesid,
    const JET_TABLEID   tableidIdxRebuild,
    const JET_COLUMNID  columnidIndexName,
    const JET_COLUMNID  columnidAttrName,
    const JET_COLUMNID  columnidType,
    JET_INDEXLIST *     pidxlist )
    {
    JET_ERR             err                     = JET_errSuccess;
    const DWORD         iretcolIndexName        = 0;
    const DWORD         iretcolAttrName         = 1;
    const DWORD         iretcoliColumn          = 2;
    const DWORD         iretcolcColumns         = 3;
    const DWORD         cretcol                 = 4;
    JET_RETRIEVECOLUMN  rgretcol[4];
    CHAR                szIndexName[JET_cbNameMost];
    CHAR                szAttrName[JET_cbNameMost+1];
    DWORD               iColumn                 = 0;
    DWORD               cColumns                = 0;
    CHAR                chType;
    const DWORD         cbAttIndexPrefix        = strlen( SZATTINDEXPREFIX );

    //  set up JET_RETRIEVECOLUMN structures for the info we'll
    //  be extracting from the index list
    //
    memset( rgretcol, 0, sizeof(rgretcol) );

    rgretcol[iretcolIndexName].columnid = pidxlist->columnidindexname;
    rgretcol[iretcolIndexName].pvData = szIndexName;
    rgretcol[iretcolIndexName].cbData = sizeof(szIndexName);
    rgretcol[iretcolIndexName].itagSequence = 1;

    rgretcol[iretcolAttrName].columnid = pidxlist->columnidcolumnname;
    rgretcol[iretcolAttrName].pvData = szAttrName;
    rgretcol[iretcolAttrName].cbData = sizeof(szAttrName);
    rgretcol[iretcolAttrName].itagSequence = 1;

    rgretcol[iretcoliColumn].columnid = pidxlist->columnidiColumn;
    rgretcol[iretcoliColumn].pvData = &iColumn;
    rgretcol[iretcoliColumn].cbData = sizeof(iColumn);
    rgretcol[iretcoliColumn].itagSequence = 1;

    rgretcol[iretcolcColumns].columnid = pidxlist->columnidcColumn;
    rgretcol[iretcolcColumns].pvData = &cColumns;
    rgretcol[iretcolcColumns].cbData = sizeof(cColumns);
    rgretcol[iretcolcColumns].itagSequence = 1;

    //  now spin through the index list and filter out all attribute indexes
    //
    err = JetMove( sesid, pidxlist->tableid, JET_MoveFirst, NO_GRBIT );
    while ( JET_errNoCurrentRecord != err )
        {
        BOOL    fAddEntry   = FALSE;

        //  process error returned from JetMove
        //
        CheckErr( err );

        //  retrieve index info for the current index in the index list
        //
        Call( JetRetrieveColumns( sesid, pidxlist->tableid, rgretcol, cretcol ) );

        //  see if this index is an attribute index
        //
        if ( rgretcol[iretcolIndexName].cbActual > cbAttIndexPrefix
            && 0 == _strnicmp( szIndexName, SZATTINDEXPREFIX, cbAttIndexPrefix ) )
            {
            //  determine type of attribute index
            //
            switch( *( szIndexName + cbAttIndexPrefix ) )
                {
                case CHPDNTATTINDEX_PREFIX:
                    //  this is a PDNT-attribute index
                    //  (attribute is the second key segment)
                    //
                    chType = CHPDNTATTINDEX_PREFIX;
                    fAddEntry = ( 1 == iColumn );
                    break;

                case CHTUPLEATTINDEX_PREFIX:
                    //  this is a tuple-attribute index
                    //  (attribute is the first key segment)
                    //
                    chType = CHTUPLEATTINDEX_PREFIX;
                    fAddEntry = ( 0 == iColumn );
                    break;

                default:
                    //  this is a plain attribute index
                    //  (attribute is the first key segment)
                    //
                    chType = 0;
                    fAddEntry = ( 0 == iColumn );
                    break;
                }
            }

        if ( fAddEntry )
            {
            //  some obsolete attribute indexes may have a DNT tacked onto the end
            //  of the index key
            //
            Assert( cColumns <= 2 );

            //  add an entry for this index into the AttributeIndexRebuild table
            //
            Call( JetPrepareUpdate( sesid, tableidIdxRebuild, JET_prepInsert ) );

            //  set name of attribute index
            //
            Call( JetSetColumn(
                        sesid,
                        tableidIdxRebuild,
                        columnidIndexName,
                        szIndexName,
                        rgretcol[iretcolIndexName].cbActual,
                        NO_GRBIT,
                        NULL ) );

            //  set name of attribute being indexed
            //
            Call( JetSetColumn(
                        sesid,
                        tableidIdxRebuild,
                        columnidAttrName,
                        szAttrName,
                        rgretcol[iretcolAttrName].cbActual,
                        NO_GRBIT,
                        NULL ) );

            //  set type of attribute index if it is not a plain attribute index
            //
            if ( 0 != chType )
                {
                Call( JetSetColumn(
                            sesid,
                            tableidIdxRebuild,
                            columnidType,
                            &chType,
                            sizeof(chType),
                            NO_GRBIT,
                            NULL ) );
                }

            err = JetUpdate( sesid, tableidIdxRebuild, NULL, 0, NULL );
            switch ( err )
                {
                case JET_errSuccess:
                    break;
                case JET_errKeyDuplicate:
                    //  entry may already be there if we are resuming after a crash
                    //
                    Call( JetPrepareUpdate( sesid, tableidIdxRebuild, JET_prepCancel ) );
                    break;
                default:
                    CheckErr( err );
                }
            }

        //  move to next index list entry
        //
        err = JetMove( sesid, pidxlist->tableid, JET_MoveNext, NO_GRBIT );
        }

    err = JET_errSuccess;

HandleError:
    return err;
    }


//  generate the AttributeIndexRebuild table
//
JET_ERR dbGenerateAttributeIndexRebuildTable(
    JET_INSTANCE *      pinst,
    const JET_SESID     sesid,
    const CHAR *        szDB )
    {
    JET_ERR             err;
    JET_DBID            dbid                = JET_dbidNil;
    JET_TABLEID         tableid             = JET_tableidNil;
    JET_TABLEID         tableidIdxRebuild   = JET_tableidNil;
    JET_INDEXLIST       idxlist;
    JET_COLUMNDEF       columndef;
    JET_COLUMNID        columnidIndexName;
    JET_COLUMNID        columnidAttrName;
    JET_COLUMNID        columnidType;
    BOOL                fRetrievedIdxList   = FALSE;

    //  first, disable index checking so that we can attach to the database
    //  even though it may be "at-risk"
    //
    Call( JetSetSystemParameter( pinst, sesid, JET_paramEnableIndexChecking, FALSE, NULL ) );
	Call( JetSetSystemParameter( pinst, sesid, JET_paramEnableIndexCleanup, FALSE, NULL ) );
	
    //  attach/open the database
    //
    Call( JetAttachDatabase( sesid, szDB, NO_GRBIT ) );
    Call( JetOpenDatabase( sesid, szDB, NULL, &dbid, NO_GRBIT ) );

    //  open the datatable
    //
    Call( JetOpenTable( sesid, dbid, SZDATATABLE, NULL, 0, JET_bitTableDenyRead, &tableid ) );

    //  query for all indexes on the datatable
    //
    Call( JetGetTableIndexInfo( sesid, tableid, NULL, &idxlist, sizeof(idxlist), JET_IdxInfoList ) );
    fRetrievedIdxList = TRUE;

    //  create the AttributeIndexRebuild table if not already there
    //
    err = JetOpenTable( sesid, dbid, g_szIdxRebuildTable, NULL, 0, JET_bitTableDenyRead, &tableidIdxRebuild );
    if ( JET_errObjectNotFound == err )
        {
        Call( JetCreateTableColumnIndex( sesid, dbid, &g_tablecreateIdxRebuild ) );
        tableidIdxRebuild = g_tablecreateIdxRebuild.tableid;
        }
    else
        {
        CheckErr( err );
        }

    //  retrieve columnids for the columns in the AttributeIndexRebuild table
    //
    Call( JetGetTableColumnInfo(
                sesid,
                tableidIdxRebuild,
                g_szIdxRebuildColumnIndexName, 
                &columndef,
                sizeof(columndef),
                JET_ColInfo ) );
    columnidIndexName = columndef.columnid;

    Call( JetGetTableColumnInfo(
                sesid,
                tableidIdxRebuild,
                g_szIdxRebuildColumnAttrName, 
                &columndef,
                sizeof(columndef),
                JET_ColInfo ) );
    columnidAttrName = columndef.columnid;

    Call( JetGetTableColumnInfo(
                sesid,
                tableidIdxRebuild,
                g_szIdxRebuildColumnType, 
                &columndef,
                sizeof(columndef),
                JET_ColInfo ) );
    columnidType = columndef.columnid;

    //  filter out attribute indexes and store them in the AttributeIndexRebuild table
    //
    err = dbEnumerateAttrIndices(
                        sesid,
                        tableidIdxRebuild,
                        columnidIndexName,
                        columnidAttrName,
                        columnidType,
                        &idxlist );
    if ( JET_errSuccess != err )
        {
        //  error already logged
        //
        goto HandleError;
        }

    //  verify table is not empty (it would mean something is
    //  gravely amiss because there are no attribute indices at all)
    //
    Call( JetMove( sesid, tableidIdxRebuild, JET_MoveFirst, NO_GRBIT ) );

    //  close AttributeIndexRebuild table
    //
    Call( JetCloseTable( sesid, tableidIdxRebuild ) );
    tableidIdxRebuild = JET_tableidNil;

    //  close index list
    //
    Call( JetCloseTable( sesid, idxlist.tableid ) );
    fRetrievedIdxList = FALSE;

    //  close datatable
    //
    Call( JetCloseTable( sesid, tableid ) );
    tableid = JET_tableidNil;

    //  close/detach database
    //
    Call( JetCloseDatabase( sesid, dbid, NO_GRBIT ) );
    Call( JetDetachDatabase( sesid, szDB ) );
    dbid = JET_dbidNil;

    //  re-enable index checking so subsequent attach can perform
    //  any necessary index cleanup
    //
    Call( JetSetSystemParameter( pinst, sesid, JET_paramEnableIndexChecking, TRUE, NULL ) );
	Call( JetSetSystemParameter( pinst, sesid, JET_paramEnableIndexCleanup, TRUE, NULL ) );

    return JET_errSuccess;

HandleError:
    //  try to close the AttributeIndexRebuild table
    //
    if ( JET_tableidNil != tableidIdxRebuild )
        {
        (VOID)JetCloseTable( sesid, tableidIdxRebuild );
        }

    //  try to close the index list
    //
    if ( fRetrievedIdxList )
        {
        (VOID)JetCloseTable( sesid, idxlist.tableid );
        }

    //  try to close the datatable
    //
    if ( JET_tableidNil != tableid )
        {
        (VOID)JetCloseTable( sesid, tableid );
        }

    //  try to close the database
    //
    if ( JET_dbidNil != dbid )
        {
        (VOID)JetCloseDatabase( sesid, dbid, NO_GRBIT );
        }

    //  try to detach the database
    //
    (VOID)JetDetachDatabase( sesid, szDB );

    //  try and re-enable index checking
    //
    (VOID)JetSetSystemParameter( pinst, sesid, JET_paramEnableIndexChecking, TRUE, NULL );

    return err;
    }

JET_ERR
dbDetectObsoleteUnicodeIndexes(
    const JET_SESID     sesid,
    const CHAR *        szDB,
    BOOL *              pfObsolete )
{
    JET_ERR         err;
    JET_DBID        dbid                = JET_dbidNil;
    JET_TABLEID     tableid             = JET_tableidNil;
    JET_INDEXLIST   idxlist             = { sizeof( idxlist ), JET_tableidNil };
    size_t          iRecord             = 0;

    // assume that the indices are OK until proven otherwise
    //
    *pfObsolete = FALSE;

    // open the database
    //
    Call( JetOpenDatabase( sesid, szDB, "", &dbid, NO_GRBIT ) );

    // open the datatable
    //
    Call( JetOpenTable( sesid, dbid, SZDATATABLE, NULL, 0, JET_bitTableDenyRead, &tableid ) );

    // get a list of all indices on the datatable
    //
    Call( JetGetTableIndexInfo( sesid, tableid, NULL, &idxlist, sizeof(idxlist), JET_IdxInfoList ) );

    // walk the list of all indices on the datatable
    //
    for ( iRecord = 0; iRecord < idxlist.cRecord; iRecord++ )
        {
        // fetch the current index segment description
        //
        size_t              iretcolName         = 0;
        size_t              iretcolCColumn      = 1;
        size_t              iretcolIColumn      = 2;
        size_t              iretcolColName      = 3;
        size_t              iretcolColtyp       = 4;
        size_t              iretcolCp           = 5;
        size_t              iretcolLCMapFlags   = 6;
        size_t              cretcol             = 7;
        JET_RETRIEVECOLUMN  rgretcol[7]         = { 0 };
        ULONG               cColumn             = 0;
        ULONG               iColumn             = 0;
        CHAR                szIndexName[JET_cbNameMost + 1]     = { 0 };
        CHAR                szColumnName[JET_cbNameMost + 1]    = { 0 };
        JET_COLTYP          coltyp              = 0;
        unsigned short      cp                  = 0;
        DWORD               dwLCMapFlags        = 0;

        rgretcol[iretcolName].columnid              = idxlist.columnidindexname;
        rgretcol[iretcolName].pvData                = szIndexName;
        rgretcol[iretcolName].cbData                = JET_cbNameMost;
        rgretcol[iretcolName].itagSequence          = 1;

        rgretcol[iretcolCColumn].columnid           = idxlist.columnidcColumn;
        rgretcol[iretcolCColumn].pvData             = &cColumn;
        rgretcol[iretcolCColumn].cbData             = sizeof(cColumn);
        rgretcol[iretcolCColumn].itagSequence       = 1;

        rgretcol[iretcolIColumn].columnid           = idxlist.columnidiColumn;
        rgretcol[iretcolIColumn].pvData             = &iColumn;
        rgretcol[iretcolIColumn].cbData             = sizeof(iColumn);
        rgretcol[iretcolIColumn].itagSequence       = 1;

        rgretcol[iretcolColName].columnid           = idxlist.columnidcolumnname;
        rgretcol[iretcolColName].pvData             = szColumnName;
        rgretcol[iretcolColName].cbData             = JET_cbNameMost;
        rgretcol[iretcolColName].itagSequence       = 1;

        rgretcol[iretcolColtyp].columnid            = idxlist.columnidcoltyp;
        rgretcol[iretcolColtyp].pvData              = &coltyp;
        rgretcol[iretcolColtyp].cbData              = sizeof( coltyp );
        rgretcol[iretcolColtyp].itagSequence        = 1;

        rgretcol[iretcolCp].columnid                = idxlist.columnidCp;
        rgretcol[iretcolCp].pvData                  = &cp;
        rgretcol[iretcolCp].cbData                  = sizeof( cp );
        rgretcol[iretcolCp].itagSequence            = 1;

        rgretcol[iretcolLCMapFlags].columnid        = idxlist.columnidLCMapFlags;
        rgretcol[iretcolLCMapFlags].pvData          = &dwLCMapFlags;
        rgretcol[iretcolLCMapFlags].cbData          = sizeof( dwLCMapFlags );
        rgretcol[iretcolLCMapFlags].itagSequence    = 1;

        Call( JetRetrieveColumns(sesid, idxlist.tableid, rgretcol, cretcol) );

        szIndexName[rgretcol[iretcolName].cbActual] = 0;
        szColumnName[rgretcol[iretcolColName].cbActual] = 0;

        DPRINT4( 2, "Inspecting table \"%s\", index \"%s\", key segment %d \"%s\"\n", SZDATATABLE, szIndexName, iColumn, szColumnName );

        // if this segment of the current index is over a Unicode column and it
        // has LCMapString flags that do not match the current default flags
        // then we will assume that every Unicode index has obsolete flags
        //
        // NOTE:  do not check AB indexes here.  we do this because they are
        // fixed up later.  we also do this because we changed just their flags
        // after we changed all indices' flags so we don't want to force
        // another global rebuild for those who upgrade from RC1
        //
        if (    ( coltyp == JET_coltypText || coltyp == JET_coltypLongText ) &&
                cp == CP_WINUNICODE &&
                strncmp( szIndexName, SZABVIEWINDEX, strlen( SZABVIEWINDEX ) ) != 0 &&
                dwLCMapFlags != ( DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY ) )
            {
            DPRINT5( 2, "Table \"%s\", index \"%s\", key segment %d \"%s\" has obsolete LCMapString flags 0x%08X\n", SZDATATABLE, szIndexName, iColumn, szColumnName, dwLCMapFlags );
            if ( !( *pfObsolete ) )
                {
                DPRINT( 0, "Unicode indices with obsolete LCMapString flags discovered!  All Unicode indices will be deleted and rebuilt.\n" );
                *pfObsolete = TRUE;
                }
            }

        // move on to the next index segment
        //
        if ( iRecord + 1 < idxlist.cRecord )
            {
            Call( JetMove(sesid, idxlist.tableid, JET_MoveNext, NO_GRBIT ) );
            }
        }

    // if we didn't find any obsolete Unicode indices but someone requested that
    // they be deleted anyway then we will do so
    //
    if ( !( *pfObsolete ) )
        {
        if ( !GetConfigParam( DB_DELETE_UNICODE_INDEXES, pfObsolete, sizeof( *pfObsolete ) ) )
            {
            *pfObsolete = !!( *pfObsolete );
            }
        else
            {
            *pfObsolete = FALSE;
            }
        if ( *pfObsolete )
            {
            DPRINT( 0, "All Unicode indices will be deleted and rebuilt by user request.\n" );
            }
        }
    
HandleError:
    if ( idxlist.tableid != JET_tableidNil )
        {
        JET_ERR errT;
        errT = JetCloseTable( sesid, idxlist.tableid );
        err = err ? err : errT;
        }
    if ( tableid != JET_tableidNil )
        {
        JET_ERR errT;
        errT = JetCloseTable( sesid, tableid );
        err = err ? err : errT;
        }
    if ( dbid != JET_dbidNil )
        {
        JET_ERR errT;
        errT = JetCloseDatabase( sesid, dbid, NO_GRBIT );
        err = err ? err : errT;
        }

    return err;
}

INT
DBInitializeJetDatabase(
    IN JET_INSTANCE* JetInst,
    IN JET_SESID* SesId,
    IN JET_DBID* DbId,
    IN const char *szDBPath,
    IN BOOL bLogSeverity
    )
/*++

Routine Description:

    Does the JetInitialization. Sets the log file path, calls JetInit,
    JetBeginSession, AttachDatabase, and OpenDatabase.  In addition, it
    tries to read the old volume location in case a drive renaming/replacement
    was done.

Arguments:

    SesId - pointer to the variable to receive the session id from BeginSession
    DbId - pointer to the variable to receive the db id from OpenDatabase
    szDBPath - pointer to the path of the database.
               if NULL the path is retrieved from the regisrty.
               
    bLogSeverity - TRUE/FALSE whether to log unhandled errors. 
               DS calls with TRUE, utilities with FALSE.

Return Value:

    The jet error code

--*/
{
    char  szLogPath[MAX_PATH+1] = "";
    char  szDitDrive[_MAX_DRIVE];
    char  szDitDir[_MAX_FNAME];
    char  szDitFullDir[_MAX_DRIVE + _MAX_FNAME + 1];
    JET_SESID sessid = (JET_SESID) 0;
    JET_DBID    dbid;
    JET_ERR err;
    PVOID dwEA;
    ULONG ulErrorCode, dwException, dsid;
    BOOL fGotLogFile = TRUE;
    BOOL fLogSwitched = FALSE, fLogDriveChanged = FALSE;
    BOOL fDbSwitched = FALSE, fDbDriveChanged = FALSE;
    BOOL fRetry = FALSE;
    CHAR szBackupPath[MAX_PATH+1];
    BOOL fObsolete = FALSE;
    JET_GRBIT grbitAttach = JET_bitDbDeleteCorruptIndexes;

    //
    // Get the backup file path and see if it is ok.
    //

    // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
    // REVIEW:  need to check for or ensure this path is NULL terminated
    if ( GetConfigParam(BACKUPPATH_KEY, szBackupPath, MAX_PATH) == ERROR_SUCCESS ) {

        //
        // Handle drive renames for the backup key. The backup dir usually does
        // not exist do just check for the root of the volume.
        //

        ValidateDsPath(BACKUPPATH_KEY,
                       szBackupPath,
                       VALDSPATH_ROOT_ONLY | VALDSPATH_DIRECTORY,
                       NULL, NULL);
    }

    //
    // Set The LogFile path
    //

    // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
    // REVIEW:  need to check for or ensure this path is NULL terminated
    if ( GetConfigParam(
            LOGPATH_KEY,
            szLogPath,
            sizeof(szLogPath)) != ERROR_SUCCESS ) {

        // indicate that we did not get a path from the registry so we don't retry
        fGotLogFile = FALSE;
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(LOGPATH_KEY),
            NULL,
            NULL);
    
    } else {

        //
        // Handle drive renames. This does not handle the case where
        // it gets set to the wrong directory.  This depends whether
        // jet was shutdown cleanly or not. If not, then jet needs those
        // log files to start up.
        //

        ValidateDsPath(LOGPATH_KEY,
                       szLogPath,
                       VALDSPATH_DIRECTORY,
                       &fLogSwitched, &fLogDriveChanged);

        //
        // Disable write caching to avoid jet corruption
        //

        DsaDetectAndDisableDiskWriteCache(szLogPath);

        // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
        // REVIEW:  need to check for invalid parameter
        JetSetSystemParameter(JetInst,
                sessid,
                JET_paramLogFilePath,
                0,
                szLogPath);

    }

    //
    // Get the szJetFilePath (typically C:\WINDOWS\NTDS\ntds.dit)
    //

    if ( szDBPath != NULL ) {
        strncpy (szJetFilePath, szDBPath, sizeof(szJetFilePath));
        // NULL-terminate the string just in case
        szJetFilePath[sizeof(szJetFilePath)-1] = '\0';
    }
    // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
    // REVIEW:  need to check for or ensure this path is NULL terminated
    else if (dbGetFilePath(szJetFilePath, sizeof(szJetFilePath))) {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_CONFIG_PARAM_MISSING,
                 szInsertSz(FILEPATH_KEY),
                 NULL,
                 NULL);
        return !0;
    }

    //
    // Make sure the database is valid
    //

    ValidateDsPath(FILEPATH_KEY,
                   szJetFilePath,
                   0,
                   &fDbSwitched,
                   &fDbDriveChanged);

    //
    // Disable write caching to avoid jet corruption
    //

    DsaDetectAndDisableDiskWriteCache(szJetFilePath);

    //
    // When we install via IFM from snapshot backed up media, the
    // database and log files just come out as a dirty database
    // such as from a crash.  Which means we didn't get a chance
    // to run a JetExternalRestore() on them with a certain restore
    // map.  However, during IFM we may have moved the DB/logs from
    // the path of thier original location on the IFM mastering 
    // machine.  This JET parameter we're setting allows us to tell
    // JET to look here for any dirty database it's needs to soft
    // recover during JetInit() or JetBeginSession().
    //
    //  changing  C:\winnt\ntds\ntds.dit  to  C:\winnt\ntds
    //
    _splitpath(szJetFilePath, szDitDrive, szDitDir, NULL, NULL);
    _makepath(szDitFullDir, szDitDrive, szDitDir, NULL, NULL);

    JetSetSystemParameter( JetInst, 
                           sessid,
                           JET_paramAlternateDatabaseRecoveryPath,
                           0,
                           szDitFullDir );
    
open_jet:

    /* Open JET session. */

    __try {
        err = JetInit(JetInst);
    }
    __except (GetExceptionData(GetExceptionInformation(), &dwException,
                               &dwEA, &ulErrorCode, &dsid)) {

        CHAR szScratch[24];
        _ultoa((FILENO << 16) | __LINE__, szScratch, 16);
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_JET_FAULTED,
                 szInsertHex(dwException),
                 szInsertPtr(dwEA),
                 szInsertUL(ulErrorCode));

        err = 1;
    }

    if (err != JET_errSuccess) {
        if (bLogSeverity) {
            LogUnhandledError(err);
        }
        DPRINT1(0, "JetInit error: %d\n", err);
        goto exit;
    }

    /* If we fail after here, our caller should go through full shutdown
    /* so JetTerm will be called to release any file locks               */
    gfNeedJetShutdown = TRUE;

    DPRINT(5, "JetInit complete\n");

    if ((err = JetBeginSession(*JetInst, &sessid, szUser, szPassword))
        != JET_errSuccess) {
        if (bLogSeverity) {
            LogUnhandledError(err);
        }
        DPRINT1(0, "JetBeginSession error: %d\n", err);
        goto exit;
    }

    DPRINT(5,"JetBeginSession complete\n");

    /* Attach the database */

    err = JetAttachDatabase( sessid, szJetFilePath, NO_GRBIT );
    switch (err) {
        case JET_wrnDatabaseAttached:
            //  Jet no longer persists attachments, so this should actually be impossible
            //
            DPRINT1( 0, "Detected persisted attachment to database '%s'.\n", szJetFilePath );
            Assert( FALSE );
            // fall through to JET_errSuccess case

        case JET_errSuccess:
            //  see if we have any obsolete Unicode indices in the DIT.  if so,
            //  then we will ask JET to delete all Unicode indices as if they
            //  were determined to be corrupt.  this will allow us to use our
            //  existing infrastructure to rebuild these indices
            //
            err = dbDetectObsoleteUnicodeIndexes( sessid, szJetFilePath, &fObsolete );
            if ( err != JET_errSuccess )
                {
                if ( bLogSeverity )
                    {
                    LogUnhandledError( err );
                    }
                goto exit;
                }
            if ( !fObsolete )
                {
                break;
                }
            err = JetDetachDatabase( sessid, szJetFilePath );
            if ( err != JET_errSuccess )
                {
                DPRINT1( 1, "Database detach failed with error %d.\n", err );
                if ( bLogSeverity )
                    {
                    LogUnhandledError( err );
                    }
                goto exit;
                }
            grbitAttach = JET_bitDbDeleteUnicodeIndexes;
            // fall through to JET_errSecondaryIndexCorrupted case

        case JET_errSecondaryIndexCorrupted:
            /* Well, we must have upgraded NT since the last time we started
             * and it's possible that a sort order change will result in
             * corrupt indices. What we're going to do is enumerate all
             * indices, then allow Jet to delete whichever ones it wants.
             * We'll then recreate any that are missing.
             */
            err = dbGenerateAttributeIndexRebuildTable( JetInst, sessid, szJetFilePath );
            if ( JET_errSuccess != err )
                {
                DPRINT1( 1,"Couldn't generate AttributeIndexRebuild table (error %d).\n", err );
                if ( bLogSeverity )
                    {
                    LogUnhandledError( err );
                    }
                goto exit;
                }
            
            //  we've enumerated all attribute indexes currently present on the database,
            //  so now re-attach and allow Jet to cleanup any indexes it needs to
            //
            err = JetAttachDatabase( sessid, szJetFilePath, grbitAttach );
            if ( JET_wrnCorruptIndexDeleted == err )
                {
                DPRINT(0,"Jet has detected and deleted potentially corrupt indices. The indices will be rebuilt\n");
                LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_CORRUPT_INDICES_DELETED,
                         NULL,
                         NULL,
                         NULL);

                // NOTICE-2002/02/21-andygo:  JET does not flush the db header until detach
                // (original date and alias unknown at time of comment cleanup)
                // Jet has a bug such that the updated (with new version no.)
                // database header at this point is not flushed until (1) a
                // JetDetachDatabse is done, or (2) the database is shut down
                // cleanly. So if the dc crashes after we rebuild the indices,
                // the header info is stale and Jet will again delete the indices
                // on the next boot. To avoid this, force a header flush by
                // detaching and attaching again at this point.

                err = JetDetachDatabase( sessid, szJetFilePath );
                if ( JET_errSuccess == err )
                    {
                    err = JetAttachDatabase( sessid, szJetFilePath, NO_GRBIT );
                    }
                if ( JET_errSuccess != err )
                    {
                    DPRINT1( 1, "Database reattachment failed with error %d.\n", err );
                    if ( bLogSeverity )
                        {
                        LogUnhandledError( err );
                        }
                    goto exit;
                    }
                }

            else if ( JET_errSuccess == err )
                {
                //  we will get here if we explicitly asked for all Unicode
                //  indices to be deleted
                //
                Assert( grbitAttach == JET_bitDbDeleteUnicodeIndexes );

                DPRINT(0,"Jet has deleted all Unicode indices. The indices will be rebuilt\n");
                LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_UNICODE_INDICES_DELETED,
                         NULL,
                         NULL,
                         NULL);
                }

            else
                {
                DPRINT1(1,"JetAttachDatabase returned %d\n", err);
                if (bLogSeverity)
                    {
                    LogUnhandledError(err);
                    }
                goto exit;
                }
            // if a manual delete of all unicode indexes was requested then we
            // have successfully done that
            //
            DeleteConfigParam( DB_DELETE_UNICODE_INDEXES );
            break;

        case JET_errFileNotFound:

            //
            // file not found!!! Nothing we can do at this point.
            // ValidatePath should have switched the path if it was possible.
            //

            if (bLogSeverity) {
                LogUnhandledError(err);
            }
            DPRINT1(0, "Ds database %s cannot be found\n",szJetFilePath);
            goto exit;

        case JET_errDatabaseInconsistent:

            //
            // We usually get this error if the log file path is not set to
            // the correct one and Jet tries to do a soft recovery.  We will
            // try to change the log path if 1) the drive letter has changed and
            // 2) we successfully got a path from the registry
            //

            if ( fGotLogFile && !fLogSwitched && fLogDriveChanged && !fRetry ) {

                //
                // uninitialize everything and try a different log file location
                //

                DPRINT2(0, "JetAttachDatabase failed with %d [log path %s].\n",
                        err,szLogPath);

                ValidateDsPath(LOGPATH_KEY,
                               szLogPath,
                               VALDSPATH_DIRECTORY | VALDSPATH_USE_ALTERNATE,
                               &fLogSwitched,
                               &fLogDriveChanged);

                //
                // if log file not switched, bail.
                //

                if ( fLogSwitched ) {

                    gfNeedJetShutdown = FALSE;
                    JetEndSession(sessid, JET_bitForceSessionClosed);
                    JetTerm(*JetInst);
                    *JetInst = 0;
                    sessid = 0;
                    fRetry = TRUE;

                    DPRINT1(0, "Retrying JetInit with logpath %s\n",szLogPath);
                    // NTRAID#NTRAID-550420-2002/02/21-andygo:  SECURITY:  need to validate registry data used by DBInitializeJetDatabase
                    // REVIEW:  need to check for invalid parameter
                    JetSetSystemParameter(JetInst,
                            sessid,
                            JET_paramLogFilePath,
                            0,
                            szLogPath);
                    goto open_jet;
                }
            }

            // fall through

        default:
            if (bLogSeverity) {
                LogUnhandledError(err);
            }
            DPRINT1(0, "JetAttachDatabase error: %d\n", err);
            /* The assert that this is a fatal error and not an assert
             * is here because we've been promised that there are only
             * two possible warnings (both handled above) from this call.
             */
            Assert(err < 0);
            goto exit;
    }

    //
    // add this session to the list of open sessions
    //

    DBAddSess(sessid, 0);

    /* Open database */

    if ((err = JetOpenDatabase(sessid, szJetFilePath, "", &dbid,
                               0)) != JET_errSuccess) {
        if (bLogSeverity) {
            LogUnhandledError(err);
        }
        DPRINT1(0, "JetOpenDatabase error: %d\n", err);
        goto exit;
    }
    DPRINT(5,"JetOpenDatabase complete\n");

    *DbId = dbid;
    *SesId = sessid;

    // set the open count to 1 for the initial open
    InterlockedExchange(&gcOpenDatabases, 1);
    DPRINT3(2,
            "DBInit - JetOpenDatabase. Session = %d. Dbid = %d.\n"
            "Open database count: %d\n",
            sessid, dbid,  gcOpenDatabases);

exit:

    //
    // Set the drive mapping reg key
    //

    DBRegSetDriveMapping( );
    return err;

} // DBInitializeJetDatabase
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dscommon\dsexcept.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsexcept.c
//
//--------------------------------------------------------------------------

//
// dsexcept.c - contains routines for raising, filtering, and handling exception generated by
// the Directory service
//

#include <NTDSpch.h>
#pragma  hdrstop

#include <esent.h>
#include   "debug.h"         /* standard debugging header */
#define DEBSUB              "DSEXCEPT:" /* define the subsystem for debugging */
#include "ntdsa.h"
#include "scache.h"
#include "dbglobal.h"
#include "mdglobal.h"      /* MD global definition header */
#include "mdlocal.h"      /* MD global definition header */
#include "dsatools.h"       /*needed for output allocation */
#include <dsevent.h>      /* header Audit\Alert logging (includes lanman)*/
#include "mdcodes.h"       /* header for error codes */
#include "drserr.h"
#include "draerror.h"
#include <dsexcept.h>
#include <fileno.h>
#define  FILENO FILENO_DSEXCEPT

#if DBG

// This is static because it easier to get to from the debugger
// We have to save these records indside the filter function. I've
// tried saving the exception_pointer pointer and it didn't work.

CONTEXT			gContextRecord;
EXCEPTION_RECORD 	gExceptionRecord;

#endif

// The v2 stubs raise the exceptions 43210000+errcode and 43220000+errcode
// These exceptions are searched for by checking the top 3 nibbles
// in the filter function.

#define V2_EXCEPTION_MASK 0xfff00000
#define V2_EXCEPTION_GENERIC 0x43200000

// Error routine that raises exception
// exceptions are logged with an internal identifier. This identifier should
// be parsed as follows:
//
// bits  012345678901234567890123456789012
//       |  dir || file ||    line       |
// where :
//     dir is the directory the source file is in (defined in filno.h)
//     file is the file where the exception occurred
//     line is the line at which the exception occurred
//

void RaiseDsaExcept (DWORD dwException, ULONG ulErrorCode, ULONG_PTR ul2,
    DWORD dwId ,  ULONG ulSeverity)
{
    ULONG_PTR lpArguments[NUM_DSA_EXCEPT_ARGS];

    // Always report internal errors
    if ( (ulErrorCode == ERROR_DS_INTERNAL_FAILURE) ||
         (ulErrorCode == ERROR_DS_DRA_INTERNAL_ERROR) ||
         (ulErrorCode == ERROR_INTERNAL_ERROR) ||
         (ulErrorCode == ERROR_INTERNAL_DB_ERROR) ||
         (ulErrorCode == ERROR_DS_DRA_INCONSISTENT_DIT) ||
         (ulErrorCode == RPC_S_INTERNAL_ERROR) ) {
        ulSeverity = DS_EVENT_SEV_ALWAYS;
    }

    if (ulSeverity != DS_EVENT_SEV_NO_LOGGING) {
        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                        ulSeverity,
		        DIRLOG_EXCEPTION,
		        szInsertHex(dwException),
		        szInsertInt(ulErrorCode),
		        szInsertPtr(ul2),
		        szInsertHex(dwId),
		        NULL,
		        NULL,
		        NULL,
		        NULL);
    }

    lpArguments[0] = ulErrorCode;
    lpArguments[1] = ul2;
    lpArguments[2] = dwId;

    RaiseException (dwException, 0, NUM_DSA_EXCEPT_ARGS, lpArguments);
}


// Error routine that raises exceptions for the DRA

void DraExcept (ULONG ulErrorCode, ULONG_PTR ul2, DWORD dwId,
                       ULONG ulSeverity)
{
    DWORD dwException =
	(ulErrorCode == DRAERR_OutOfMem) ? DSA_MEM_EXCEPTION : DRA_GEN_EXCEPTION;

    if ( (ulErrorCode == ERROR_DS_DRA_INTERNAL_ERROR) ||
         (ulErrorCode == ERROR_DS_INTERNAL_FAILURE) ||
         (ulErrorCode == ERROR_DS_DRA_INCONSISTENT_DIT) ||
         (ulErrorCode == ERROR_INTERNAL_ERROR) ) {
        Assert(!"Internal error");
    }
    else if (!ulErrorCode) {
        Assert(!"DRA exception without proper error code");
        ulErrorCode = ERROR_DS_DRA_GENERIC;
    }

    RaiseDsaExcept(dwException, ulErrorCode, ul2, dwId, ulSeverity);
}


// This is the generic filter expression called directly by the DSA
// exception handlers and by the DRA filter expression.

DWORD
GetExceptionData(EXCEPTION_POINTERS* pExceptPtrs,
                 DWORD *pdwException,
                 PVOID * pExceptionAddress,
                 ULONG *pulErrorCode,
                 ULONG *pdsid)
{
    ULONG_PTR * pExceptInfo;
    ULONG ul2Unused;

#if DBG

// Save information for debugger. Have to save here, can't just save pointer.

    memcpy (&gExceptionRecord, pExceptPtrs->ExceptionRecord,
                                        sizeof(EXCEPTION_RECORD));
    memcpy (&gContextRecord, pExceptPtrs->ContextRecord,
                                        sizeof (CONTEXT));
#endif

    /* Get the address the exception was caused at. */
    *pExceptionAddress = pExceptPtrs->ExceptionRecord->ExceptionAddress;


    switch (*pdwException = pExceptPtrs->ExceptionRecord->ExceptionCode) {
      case DSA_EXCEPTION:
      case DSA_BAD_ARG_EXCEPTION:
      case DRA_GEN_EXCEPTION:
      case DSA_DB_EXCEPTION:
      case DSA_CRYPTO_EXCEPTION:
        pExceptInfo = pExceptPtrs->ExceptionRecord->ExceptionInformation;
        *pulErrorCode = (ULONG)pExceptInfo[0];
        ul2Unused = (ULONG)pExceptInfo[1];
        *pdsid = (ULONG)pExceptInfo[2];
        break;

      case STATUS_NO_MEMORY:
        *pulErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;
      case DSA_MEM_EXCEPTION:
        *pulErrorCode = ERROR_DS_DRA_OUT_OF_MEM;
        break;

      default:
	    *pulErrorCode = 0;
        ul2Unused = 0;
        *pdsid = 0;
        break;
    }

    return DoHandleMostExceptions(pExceptPtrs, *pdwException, *pdsid);
}


// This is the generic filter expression for the top level DRA
// exception handlers.

DWORD GetDraException (EXCEPTION_POINTERS* pExceptPtrs, ULONG *pret)
{
    DWORD dwException;
    ULONG ulErrorCode;
    ULONG dsid;
    DWORD dwStatus;
    PVOID dwEA;

    dwStatus = GetExceptionData(pExceptPtrs, &dwException, &dwEA,
				&ulErrorCode, &dsid);

    switch (dwException) {

    case STATUS_NO_MEMORY:
    case DSA_MEM_EXCEPTION:
	LogEvent(DS_EVENT_CAT_REPLICATION,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_DRA_OUT_OF_MEMORY,
		NULL,
		NULL,
		NULL);
        *pret = DRAERR_OutOfMem;
        break;

    case DRA_GEN_EXCEPTION:
        Assert(ulErrorCode && "Missing error code in exception");
        *pret = ulErrorCode;
        break;

    case DSA_DB_EXCEPTION:
        Assert(ulErrorCode && "Missing error code in exception");
        switch (ulErrorCode) {

        case JET_errKeyDuplicate:
        case JET_errWriteConflict:
            *pret = DRAERR_Busy;
            break;

        case JET_errLogDiskFull:
        case JET_errDiskFull:
        case JET_errOutOfDatabaseSpace:
            *pret = ERROR_DISK_FULL;
            break;

        case JET_errVersionStoreOutOfMemory:
            *pret = ERROR_DS_OUT_OF_VERSION_STORE;
            break;

        case JET_errRecordTooBig:
            *pret = ERROR_DS_MAX_OBJ_SIZE_EXCEEDED;
            break;

        case JET_errRecordNotFound:
            *pret = ERROR_DS_OBJ_NOT_FOUND;
            break;

        case JET_errOutOfMemory:
        case JET_errOutOfCursors:
        case JET_errOutOfBuffers:
        case JET_errOutOfFileHandles:
        case JET_errOutOfSessions:
            *pret = ERROR_NO_SYSTEM_RESOURCES;
            break;

        case JET_errDiskIO:
        case JET_errReadVerifyFailure:
        case JET_errPageNotInitialized:
            // ERROR_DISK_CORRUPT?
            *pret = ERROR_DISK_OPERATION_FAILED;
            break;

        default:
            *pret = DRAERR_DBError;
            break;
        }
        break;

    case DSA_CRYPTO_EXCEPTION:
        Assert(ulErrorCode && "Missing error code in exception");
        Assert(!"crypto exception -- call Murli, not Will & Jeff");
        *pret = ulErrorCode;
        break;

    default:

        *pret = DRAERR_InternalError;
        Assert (!"Encountered unexpected DRA exception");
        break;
    }

    return dwStatus;
}


DWORD
DoHandleMostExceptions(EXCEPTION_POINTERS* pExceptPtrs,
                       DWORD dwException,
                       ULONG ulInternalId)
{
    switch (dwException) {
      case EXCEPTION_ACCESS_VIOLATION:	        // these exceptions are
      case EXCEPTION_BREAKPOINT:                // not handeled
      case EXCEPTION_DATATYPE_MISALIGNMENT:     // (added to trap JET problems)
      case STATUS_POSSIBLE_DEADLOCK:
      case EXCEPTION_SINGLE_STEP:
      case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
      case EXCEPTION_FLT_DENORMAL_OPERAND:
      case EXCEPTION_FLT_DIVIDE_BY_ZERO:
      case EXCEPTION_FLT_INEXACT_RESULT:
      case EXCEPTION_FLT_INVALID_OPERATION:
      case EXCEPTION_FLT_OVERFLOW:
      case EXCEPTION_FLT_STACK_CHECK:
      case EXCEPTION_FLT_UNDERFLOW:
      case EXCEPTION_INT_DIVIDE_BY_ZERO:
      case EXCEPTION_INT_OVERFLOW:
      case EXCEPTION_PRIV_INSTRUCTION:
      case EXCEPTION_IN_PAGE_ERROR:
      case EXCEPTION_ILLEGAL_INSTRUCTION:
      case EXCEPTION_NONCONTINUABLE_EXCEPTION:
      case EXCEPTION_INVALID_DISPOSITION:
      case EXCEPTION_GUARD_PAGE:
      case EXCEPTION_INVALID_HANDLE:
        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_EXCEPTION,
                  szInsertHex(dwException),
                  szInsertPtr(pExceptPtrs->ExceptionRecord->ExceptionAddress),
                  szInsertInt(0),
                  szInsertHex(ulInternalId),
                  NULL,
                  NULL,
                  NULL,
                  NULL);
        // fall through...

      case EXCEPTION_STACK_OVERFLOW: // Don't try to log when we have no stack
        return EXCEPTION_CONTINUE_SEARCH;

      default:                       // others, however, are
        return EXCEPTION_EXECUTE_HANDLER;
    }
}

DWORD
DoHandleAllExceptions(EXCEPTION_POINTERS* pExceptPtrs,
                       DWORD dwException,
                       ULONG ulInternalId)
{
    // we must always reset the stack if we handle a stack overflow exception
    if (dwException == EXCEPTION_STACK_OVERFLOW) {
        _resetstkoflw();
    }

    return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dscommon\ntutils.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       nttools.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module contains various tools from NT land. Made a separate file because of the
    use of various nt headers.

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <nt.h>
#include <ntdddisk.h>

BOOL
DisableDiskWriteCache(
    IN PCHAR DriveName
    )
/*++

Description:

    Determines if the disk has enabled write caching and disable it.
    
Arguments:

    DriveName - name of the drive.

Return value:

    TRUE if write cache was enabled and then disabled, FALSE otherwise.

--*/
{
    HANDLE              hDisk = INVALID_HANDLE_VALUE;
    DISK_CACHE_INFORMATION cacheInfo;
    UCHAR               driveBuffer[20];
    DWORD               len;
    DWORD               err = ERROR_SUCCESS;
    BOOL                fCacheWasEnabled = FALSE;
    BOOL                fCacheDisabled = FALSE;

    //
    // Open handle to the PhysicalDrive
    //

    strcpy(driveBuffer,"\\\\.\\");
    
    // check for buffer overrun
    if (DriveName == NULL || strlen(driveBuffer) + strlen(DriveName) + 1 > sizeof(driveBuffer)) {
        // invalid parameter
        err = ERROR_INVALID_PARAMETER;
        goto exit;
    }
    strcat(driveBuffer,DriveName);

    hDisk = CreateFile(driveBuffer,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hDisk == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    //
    // Get cache info - IOCTL_DISK_GET_CACHE_INFORMATION
    //

    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_GET_CACHE_INFORMATION,
                         NULL,
                         0,
                         &cacheInfo,
                         sizeof(DISK_CACHE_INFORMATION),
                         &len,
                         NULL))   {

        KdPrint(("DeviceIoControl[GET] on %s failed with %d\n",
                 driveBuffer,GetLastError()));
        goto exit;
    }

    //
    // If caching is turned on, turn it off.
    //

    fCacheWasEnabled = cacheInfo.WriteCacheEnabled;

    if ( !fCacheWasEnabled ) {
        goto exit;
    }

    cacheInfo.WriteCacheEnabled = FALSE;

    //
    // Set cache info - IOCTL_DISK_SET_CACHE_INFORMATION
    //

    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_SET_CACHE_INFORMATION,
                         &cacheInfo,
                         sizeof(DISK_CACHE_INFORMATION),
                         NULL,
                         0,
                         &len,
                         NULL))   {

        KdPrint(("DevIoControl[SET] on %s failed with %d\n",
                 driveBuffer,GetLastError()));

        err = ERROR_IO_DEVICE;
        goto exit;
    }

    //
    // See if it really got turned off!
    //

    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_GET_CACHE_INFORMATION,
                         NULL,
                         0,
                         &cacheInfo,
                         sizeof(DISK_CACHE_INFORMATION),
                         &len,
                         NULL))   {

        KdPrint(("DeviceIoControl[VERIFY] on %s failed with %d\n",
                 driveBuffer,GetLastError()));
        err = ERROR_IO_DEVICE;
        goto exit;
    }

    fCacheDisabled = (BOOL)(!cacheInfo.WriteCacheEnabled);
    if ( !fCacheDisabled ) {
        KdPrint(("DeviceIoControl failed to turn off disk write caching on %s\n",
                 driveBuffer));
        err = ERROR_IO_DEVICE;
        goto exit;
    }

exit:
    if ( hDisk != INVALID_HANDLE_VALUE ) {
        CloseHandle(hDisk );
    }

    //
    // return true if write caching was enabled and then disabled.
    //

    SetLastError(err);
    return (fCacheWasEnabled && fCacheDisabled);

} // DisableDiskWriteCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dscommon\qtcommon.c ===
#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>
#include <scache.h>					//	schema cache
#include <dbglobal.h>				//	The header for the directory database
#include <mdglobal.h>				//	MD global definition header
#include <mdlocal.h>				//	MD local definition header
#include <dsatools.h>				//	needed for output allocation

#include <objids.h>					//	Defines for selected atts
#include <dsjet.h>
#include <dbintrnl.h>
#include <dsevent.h>
#include <mdcodes.h>
#include <anchor.h>
#include <quota.h>

#include "debug.h"					//	standard debugging header
#define DEBSUB		"QUOTA:"		//	define the subsystem for debugging

#include <fileno.h>
#define FILENO		FILENO_QTCOMMON


//	Quota table
//
JET_COLUMNID	g_columnidQuotaNcdnt;
JET_COLUMNID	g_columnidQuotaSid;
JET_COLUMNID	g_columnidQuotaTombstoned;
JET_COLUMNID	g_columnidQuotaTotal;

//	Quota Rebuild Progress table
//
JET_COLUMNID	g_columnidQuotaRebuildDNTLast;
JET_COLUMNID	g_columnidQuotaRebuildDNTMax;
JET_COLUMNID	g_columnidQuotaRebuildDone;


const ULONG		g_ulQuotaRebuildBatchSize			= 5000;		//	on async rebuild of Quota table, max. objects to process at a time
const ULONG		g_cmsecQuotaRetryOnWriteConflict	= 100;		//	on async rebuild of Quota table, time to sleep before retrying due to write-conflict


//	update Quota count during Quota rebuild
//
JET_ERR ErrQuotaUpdateCountForRebuild_(
	JET_SESID		sesid,
	JET_TABLEID		tableidQuota,
	JET_COLUMNID	columnidCount,
	const BOOL		fCheckOnly )
	{
	JET_ERR			err;
	DWORD			dwCount;

	if ( fCheckOnly )
		{
		//	QUOTA_UNDONE: it's a shame Jet doesn't currently
		//	support escrow columns on temp tables, so we
		//	have to increment the count manually
		//
		Call( JetPrepareUpdate( sesid, tableidQuota, JET_prepReplace ) );
		Call( JetRetrieveColumn(
					sesid,
					tableidQuota,
					columnidCount,
					&dwCount,
					sizeof(dwCount),
					NULL,			//	pcbActual
					JET_bitRetrieveCopy,
					NULL ) );		//	pretinfo

		dwCount++;
		Call( JetSetColumn(
					sesid,
					tableidQuota,
					columnidCount,
					&dwCount,
					sizeof(dwCount),
					NO_GRBIT,
					NULL ) );	//	psetinfo

		Call( JetUpdate( sesid, tableidQuota, NULL, 0, NULL ) );
		}
	else
		{
		dwCount = 1;
		Call( JetEscrowUpdate(
					sesid,
					tableidQuota,
					columnidCount,
					&dwCount,
					sizeof(dwCount),
					NULL,			//	pvOld
					0,				//	cbOld
					NULL,			//	pcbOldActual
					NO_GRBIT ) );
		}

HandleError:
	return err;
	}


//	update quota for one object during Quota table rebuild
//
JET_ERR ErrQuotaAddObjectForRebuild_(
	JET_SESID			sesid,
	JET_DBID			dbid,
	const DWORD			dnt,
	JET_TABLEID			tableidQuota,
	DWORD				ncdnt,
	PSID				psidOwner,
	const ULONG			cbOwnerSid,
	const BOOL			fTombstoned,
	JET_COLUMNID		columnidQuotaNcdnt,
	JET_COLUMNID		columnidQuotaSid,
	JET_COLUMNID		columnidQuotaTombstoned,
	JET_COLUMNID		columnidQuotaTotal,
	const BOOL			fCheckOnly )
	{
	JET_ERR				err;
	BOOL				fAdding		= FALSE;

	Call( JetMakeKey( sesid, tableidQuota, &ncdnt, sizeof(ncdnt), JET_bitNewKey ) );
	Call( JetMakeKey( sesid, tableidQuota, psidOwner, cbOwnerSid, NO_GRBIT ) );
	err = JetSeek( sesid, tableidQuota, JET_bitSeekEQ );
	if ( JET_errRecordNotFound != err )
		{
		CheckErr( err );

		//	security principle already in Quota table,
		//	so just update counts
		//
		Call( ErrQuotaUpdateCountForRebuild_(
					sesid,
					tableidQuota,
					columnidQuotaTotal,
					fCheckOnly ) );
		if ( fTombstoned )
			{
			Call( ErrQuotaUpdateCountForRebuild_(
						sesid,
						tableidQuota,
						columnidQuotaTombstoned,
						fCheckOnly ) );
			}
		}
	else
		{
		JET_SETCOLUMN	rgsetcol[2];
		DWORD			dwCount;

		memset( rgsetcol, 0, sizeof(rgsetcol) );

		rgsetcol[0].columnid = columnidQuotaNcdnt;
		rgsetcol[0].pvData = &ncdnt;
		rgsetcol[0].cbData = sizeof(ncdnt);

		rgsetcol[1].columnid = columnidQuotaSid;
		rgsetcol[1].pvData = psidOwner;
		rgsetcol[1].cbData = cbOwnerSid;

		//	record not added yet, so add it
		//
		fAdding = TRUE;
		Call( JetPrepareUpdate( sesid, tableidQuota, JET_prepInsert ) );
		Call( JetSetColumns(
					sesid,
					tableidQuota,
					rgsetcol,
					sizeof(rgsetcol) / sizeof(rgsetcol[0]) ) );

		if ( fCheckOnly )
			{
			//	QUOTA_UNDONE: it's a shame Jet doesn't currently
			//	support escrow columns on temp tables, so we
			//	have to set the columns manually
			//
			dwCount = 1;
			Call( JetSetColumn(
						sesid,
						tableidQuota,
						columnidQuotaTotal,
						&dwCount,
						sizeof(dwCount),
						NO_GRBIT,
						NULL ) );	//	psetinfo

			dwCount = ( fTombstoned ? 1 : 0 );
			Call( JetSetColumn(
						sesid,
						tableidQuota,
						columnidQuotaTombstoned,
						&dwCount,
						sizeof(dwCount),
						NO_GRBIT,
						NULL ) );	//	psetinfo
			}
		else if ( fTombstoned )
			{
			//	tombstoned count is initialised by default to 0,
			//	so must set it to 1
			//
			dwCount = 1;
			Call( JetSetColumn(
						sesid,
						tableidQuota,
						columnidQuotaTombstoned,
						&dwCount,
						sizeof(dwCount),
						NO_GRBIT,
						NULL ) );	//	psetinfo
			}

		//	don't process KeyDuplicate errors because this
		//	may be during async rebuild of the Quota table
		//	and we are write-conflicting with some other
		//	session
		//
		err = JetUpdate( sesid, tableidQuota, NULL, 0, NULL );
		if ( JET_errKeyDuplicate != err )
			{
			CheckErr( err );
			}
		}

	if ( !fCheckOnly )
		{
		QuotaAudit_(
				sesid,
				dbid,
				dnt,
				ncdnt,
				psidOwner,
				cbOwnerSid,
				TRUE,			//	fUpdatedTotal
				fTombstoned,
				TRUE,			//	fIncrementing
				fAdding,
				TRUE );			//	fRebuild
		}

HandleError:
	return err;
	}


//	rebuild quota table
//
INT ErrQuotaRebuild_(
	JET_SESID			sesid,
	JET_DBID			dbid,
	JET_TABLEID			tableidQuota,
	JET_TABLEID			tableidQuotaRebuildProgress,
	ULONG				ulDNTLast,
	JET_COLUMNID		columnidQuotaNcdnt,
	JET_COLUMNID		columnidQuotaSid,
	JET_COLUMNID		columnidQuotaTombstoned,
	JET_COLUMNID		columnidQuotaTotal,
	const BOOL			fAsync,
	const BOOL			fCheckOnly )
	{
	JET_ERR				err;
	JET_TABLEID			tableidObj			= JET_tableidNil;
	JET_TABLEID			tableidSD			= JET_tableidNil;
	const ULONG			iretcolDnt			= 0;
	const ULONG			iretcolNcdnt		= 1;
	const ULONG			iretcolObjFlag		= 2;
	const ULONG			iretcolType			= 3;
	const ULONG			iretcolTombstoned	= 4;
	const ULONG			iretcolSD			= 5;
	const ULONG			cretcol				= 6;
	JET_RETRIEVECOLUMN	rgretcol[6];
	BOOL				fInTrx				= FALSE;
	DWORD				dnt					= ROOTTAG;
	DWORD				ncdnt;
	BYTE				bObjFlag;
	DWORD				insttype;
	BOOL				fTombstoned;
	BYTE *				rgbSD				= NULL;
	ULONG				cbSD				= 65536;	//	initial size of SD buffer
	SDID				sdid;
	PSID				psidOwner;
	ULONG				cbOwnerSid;
	BOOL				fUnused;
	JET_TABLEID			tableidRetrySD;
	JET_COLUMNID		columnidRetrySD;
	ULONG				cObjectsProcessed	= 0;
	CHAR				fDone				= FALSE;
	ULONG				ulMove				= JET_MoveNext;

	//	allocate initial buffer for SD's
	//
	rgbSD = malloc( cbSD );
	if ( NULL == rgbSD )
		{
		CheckErr( JET_errOutOfMemory );
		}

	//	open cursor on objects table
	//
	Call( JetOpenTable(
				sesid,
				dbid,
				SZDATATABLE,
				NULL,		//	pvParameters
				0,			//	cbParameters
				NO_GRBIT,
				&tableidObj ) );
	Assert( JET_tableidNil != tableidObj );

	//	open cursor on SD table
	//
	Call( JetOpenTable(
				sesid,
				dbid,
				SZSDTABLE,
				NULL,		//	pvParameters
				0,			//	cbParameters
				NO_GRBIT,
				&tableidSD ) );
	Assert( JET_tableidNil != tableidSD );

	//	initialise retrieval structures
	//
	memset( rgretcol, 0, sizeof(rgretcol) );

	rgretcol[iretcolDnt].columnid = dntid;
	rgretcol[iretcolDnt].pvData = &dnt;
	rgretcol[iretcolDnt].cbData = sizeof(dnt);
	rgretcol[iretcolDnt].itagSequence = 1;

	rgretcol[iretcolNcdnt].columnid = ncdntid;
	rgretcol[iretcolNcdnt].pvData = &ncdnt;
	rgretcol[iretcolNcdnt].cbData = sizeof(ncdnt);
	rgretcol[iretcolNcdnt].itagSequence = 1;

	rgretcol[iretcolObjFlag].columnid = objid;
	rgretcol[iretcolObjFlag].pvData = &bObjFlag;
	rgretcol[iretcolObjFlag].cbData = sizeof(bObjFlag);
	rgretcol[iretcolObjFlag].itagSequence = 1;

	rgretcol[iretcolType].columnid = insttypeid;
	rgretcol[iretcolType].pvData = &insttype;
	rgretcol[iretcolType].cbData = sizeof(insttype);
	rgretcol[iretcolType].itagSequence = 1;

	rgretcol[iretcolTombstoned].columnid = isdeletedid;
	rgretcol[iretcolTombstoned].pvData = &fTombstoned;
	rgretcol[iretcolTombstoned].cbData = sizeof(fTombstoned);
	rgretcol[iretcolTombstoned].itagSequence = 1;

	rgretcol[iretcolSD].columnid = ntsecdescid;
	rgretcol[iretcolSD].pvData = rgbSD;
	rgretcol[iretcolSD].cbData = cbSD;
	rgretcol[iretcolSD].itagSequence = 1;

	//	switch to primary index and specify sequential scan on objects table
	//
	Call( JetSetCurrentIndex( sesid, tableidObj, NULL ) );
	Call( JetSetTableSequential( sesid, tableidObj, NO_GRBIT ) );
	Call( JetSetCurrentIndex( sesid, tableidSD, NULL ) );

	Call( JetBeginTransaction( sesid ) );
	fInTrx = TRUE;

	//	start scanning from where we last left off
	//
	Call( JetMakeKey( sesid, tableidObj, &ulDNTLast, sizeof(ulDNTLast), JET_bitNewKey ) );
	err = JetSeek( sesid, tableidObj, JET_bitSeekGT );
	for ( err = ( JET_errRecordNotFound != err ? err : JET_errNoCurrentRecord );
		JET_errNoCurrentRecord != err && !eServiceShutdown;
		err = JetMove( sesid, tableidObj, ulMove, NO_GRBIT ) )
		{
		//	by default, on the next iteration, we'll move to the next record
		//
		ulMove = JET_MoveNext;

		//	validate error returned by record navigation
		//
		CheckErr( err );

		//	refresh in case buffer was reallocated
		//
		rgretcol[iretcolSD].pvData = rgbSD;
		rgretcol[iretcolSD].cbData = cbSD;

		//	retrieve columns and be prepared to accept warnings
		//	(in case some attributes are NULL or the retrieval
		//	buffer wasn't big enough)
		//
		err = JetRetrieveColumns( sesid, tableidObj, rgretcol, cretcol );
		if ( err < JET_errSuccess )
			{
			//	error detected, force to error-handler
			//
			CheckErr( err );
			}
		else
			{
			//	process any warnings individually
			//
			}

		//	DNT and ObjFlag should always be present
		//
		CheckErr( rgretcol[iretcolDnt].err );
		CheckErr( rgretcol[iretcolObjFlag].err );

		//	if async rebuild, ensure we haven't exceeded
		//	the maximum DNT we should be processing and
		//	that this task hasn't already processed a lot
		//	of objects
		//
		if ( fAsync )
			{
			if ( dnt > gAnchor.ulQuotaRebuildDNTMax )
				{
				fDone = TRUE;
				break;
				}
			else if ( cObjectsProcessed > g_ulQuotaRebuildBatchSize )
				{
				break;
				}
			}

		//	skip if not an object
		//
		if ( !bObjFlag )
			{
			continue;
			}

		//	in all other cases NCDNT and InstanceType must be present
		//
		CheckErr( rgretcol[iretcolNcdnt].err );
		CheckErr( rgretcol[iretcolType].err );

		// skip if not tracking quota for this object
		//
		if ( !FQuotaTrackObject( insttype ) )
			{
			continue;
			}

		//	see if object is flagged as tombstoned
		//
		if ( JET_wrnColumnNull == rgretcol[iretcolTombstoned].err )
			{
			fTombstoned = FALSE;
			}
		else
			{
			//	only expected warnings is if column is NULL
			//
			CheckErr( rgretcol[iretcolTombstoned].err );

			//	this flag should only ever be TRUE or NULL
			//
			Assert( fTombstoned );
			}

		//	SD may not have fit in our buffer
		//
		tableidRetrySD = JET_tableidNil;
		if ( JET_wrnBufferTruncated == rgretcol[iretcolSD].err )
			{
			tableidRetrySD = tableidObj;
			columnidRetrySD = ntsecdescid;
			}
		else
			{
			CheckErr( rgretcol[iretcolSD].err );

			//	see if SD is actually single-instanced
			//
			if ( sizeof(SDID) == rgretcol[iretcolSD].cbActual )
				{
				//	retrieve the SD from the SD Table
				//
				Call( JetMakeKey( sesid, tableidSD, rgbSD, sizeof(SDID), JET_bitNewKey ) );
				Call( JetSeek( sesid, tableidSD, JET_bitSeekEQ ) );
				err = JetRetrieveColumn(
							sesid,
							tableidSD,
							sdvalueid,
							rgbSD,
							cbSD,
							&rgretcol[iretcolSD].cbActual,
							NO_GRBIT,
							NULL );		//	pretinfo
				if ( JET_wrnBufferTruncated == err )
					{
					tableidRetrySD = tableidSD,
					columnidRetrySD = sdvalueid;
					}
				else
					{
					CheckErr( err );

					//	fall through below to process the retrieved SD
					}
				}
			else
				{
				//	fall through below to process the retrieved SD
				}
			}

		//	see if we need to retry SD retrieval because the
		//	original buffer was too small
		//
		if ( JET_tableidNil != tableidRetrySD )
			{
			//	resize buffer, rounding up to the nearest 1k
			//
			cbSD = ( ( rgretcol[iretcolSD].cbActual + 1023 ) / 1024 ) * 1024;
			rgretcol[iretcolSD].cbData = cbSD;
			rgretcol[iretcolSD].pvData = realloc( rgbSD, cbSD );
			if ( NULL == rgretcol[iretcolSD].pvData )
				{
				CheckErr( JET_errOutOfMemory );
				}
			rgbSD = rgretcol[iretcolSD].pvData;

			//	we've resized appropriately, so retrieve should
			//	now succeed without warnings
			//
			Call( JetRetrieveColumn(
						sesid,
						tableidRetrySD,
						columnidRetrySD,
						rgbSD,
						cbSD,
						NULL,		//	pcbActual
						NO_GRBIT,
						NULL ) );	//	pretinfo

			//	process the retrieved SD below
			//
			}


		//	successfully retrieved the SD, so now
		//	extract the owner SID from it
		//
		if ( !IsValidSecurityDescriptor( (PSECURITY_DESCRIPTOR)rgbSD )
			|| !GetSecurityDescriptorOwner( (PSID)rgbSD, &psidOwner, &fUnused ) )
			{
			err = GetLastError();
			DPRINT2( 0, "Error extracting owner SID.\n", err, err );
			LogUnhandledError( err );
			goto HandleError;
			}
		else if ( NULL == psidOwner )
			{
			Assert( !"An SD is missing an owner SID." );
			DPRINT( 0, "Error: owner SID was NULL.\n" );
			err = ERROR_INVALID_SID;
			LogUnhandledError( ERROR_INVALID_SID );
			goto HandleError;
			}
		else
			{
			//	since security descriptor is valid, sid should be valid
			//	(or am I just being naive?)
			//
			Assert( IsValidSid( psidOwner ) );
			cbOwnerSid = GetLengthSid( psidOwner );
			}

		//	if we're performing an async rebuild, write-lock the
		//	object to ensure no one else can modify the object from
		//	underneath us
		//	
		if ( fAsync )
			{
			err = JetGetLock( sesid, tableidObj, JET_bitWriteLock );
			if ( JET_errWriteConflict == err )
				{
				//	someone else has the record locked, so need to
				//	rollback our transaction and wait for them to finish
				//
				Call( JetRollback( sesid, NO_GRBIT ) );
				fInTrx = FALSE;

				//	give the other session time to complete its
				//	transaction
				//
				Sleep( g_cmsecQuotaRetryOnWriteConflict );

				//	start up another transaction in preparation
				//	to retry the object
				//
				Call( JetBeginTransaction( sesid ) );
				fInTrx = TRUE;

				//	don't move to the next object (ie. retry this object)
				//
				ulMove = 0;
				continue;
				}
			else
				{
				CheckErr( err );
				}
			}

		//	now go to the Quota table and update the quota record
		//	for this ncdnt+OwnerSID
		//
		err =  ErrQuotaAddObjectForRebuild_(
						sesid,
						dbid,
						dnt,
						tableidQuota,
						ncdnt,
						psidOwner,
						cbOwnerSid,
						fTombstoned,
						columnidQuotaNcdnt,
						columnidQuotaSid,
						columnidQuotaTombstoned,
						columnidQuotaTotal,
						fCheckOnly );

		//	if we had to add a new quota record and
		//	we're performing an async rebuild, it's possible
		//	someone beat us to it, in which case we need
		//	to abandon the transaction and try again
		//	NOTE: on insert, we actually get KeyDuplicate
		//	on a write-conflict
		//
		Assert( JET_errWriteConflict != err );
		if ( JET_errKeyDuplicate == err && fAsync )
			{
			//	someone else beat us to the quota record
			//	insertion, so need to wait for them to
			//	finish and then retry
			//
			Call( JetRollback( sesid, NO_GRBIT ) );
			fInTrx = FALSE;

			//	give the other session time to complete its
			//	transaction
			//
			Sleep( g_cmsecQuotaRetryOnWriteConflict );

			//	don't move to the next object (ie. retry this object)
			//
			ulMove = 0;
			}
		else
			{
			//	validate error returned from updating quota
			//	for the current object
			//
			CheckErr( err );

			if ( JET_tableidNil != tableidQuotaRebuildProgress )
				{
				//	upgrade rebuild progress for this object
				//
				Call( JetPrepareUpdate( sesid, tableidQuotaRebuildProgress, JET_prepReplace ) );
				Call( JetSetColumn(
							sesid,
							tableidQuotaRebuildProgress,
							g_columnidQuotaRebuildDNTLast,
							&dnt,
							sizeof(dnt),
							NO_GRBIT,
							NULL ) );	//	&setinfo
				Call( JetUpdate( sesid, tableidQuotaRebuildProgress, NULL, 0, NULL ) );
				}

			if ( fAsync )
				{
				//	update progress in anchor so other sessions will
				//	start updating quota if they try to modify this object
				//	(though until we commit, they will write-conflict)
				//
				gAnchor.ulQuotaRebuildDNTLast = dnt;
				}

			//	successfully updated, so commit
			//
			cObjectsProcessed++;
			err = JetCommitTransaction( sesid, JET_bitCommitLazyFlush );
			if ( JET_errSuccess != err )
				{
				if ( fAsync )
					{
					//	revert gAnchor progress update (we don't have to
					//	actually reinstate the previous value, we just need
					//	to make sure it's less than the DNT of the current
					//	object (note that committing the transaction failed,
					//	so we're still in the transaction and still own
					//	the write-lock on the object)
					//
		        	DPRINT1( 0, "Rolling back gAnchor Quota rebuild progress due to CommitTransaction error %d\n", err );
					gAnchor.ulQuotaRebuildDNTLast--;
					}

		        LogUnhandledError( err );
		        goto HandleError;
				}

			fInTrx = FALSE;
			}

		Call( JetBeginTransaction( sesid ) );
		fInTrx = TRUE;
		}

	//	should always exit the loop above while still in a transaction
	//
	Assert( fInTrx );

	//	see if we reached the end of the objects table
	//
	if ( JET_errNoCurrentRecord == err && JET_MoveNext == ulMove )
		{
		fDone = TRUE;
		}

	if ( fDone )
		{
		if ( JET_tableidNil != tableidQuotaRebuildProgress )
			{
			//	set fDone flag in Quota Rebuild Progress table
			//
			Call( JetPrepareUpdate( sesid, tableidQuotaRebuildProgress, JET_prepReplace ) );
			Call( JetSetColumn(
						sesid,
						tableidQuotaRebuildProgress,
						g_columnidQuotaRebuildDone,
						&fDone,
						sizeof(fDone),
						NO_GRBIT,
						NULL ) );	//	&setinfo
			Call( JetUpdate( sesid, tableidQuotaRebuildProgress, NULL, 0, NULL ) );
			}
		}
	else
		{
		//	didn't reach the end of the objects table, so
		//	the only other possibilities are that we
		//	retried to fetch the current record but it
		//	disappeared out from underneath us or we were
		//	forced to exit because we're shutting down or
		//	we already processed a lot of objects
		//
		Assert( ( fAsync && JET_errNoCurrentRecord == err && 0 == ulMove )
			|| eServiceShutdown
			|| ( fAsync && cObjectsProcessed > g_ulQuotaRebuildBatchSize ) );
		}

	Call( JetCommitTransaction( sesid, JET_bitCommitLazyFlush ) );
	fInTrx = FALSE;

	if ( fDone && fAsync )
		{
		//	set flag in anchor to indicate Quota table 
		//	is ready to be used
		//
		gAnchor.fQuotaTableReady = TRUE;

		//	generate an event indicating that the Quota table
		//	has been successfully rebuilt
		//
	    LogEvent(
			DS_EVENT_CAT_INTERNAL_PROCESSING,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_ASYNC_QUOTA_REBUILD_COMPLETED,
			NULL,
			NULL,
			NULL );
		}

HandleError:
	if ( fInTrx )
		{
		//	if still in transaction, then we must have already hit an error,
		//	so nothing we can do but assert if rollback fails
		//
		const JET_ERR	errT	= JetRollback( sesid, NO_GRBIT );
		Assert( JET_errSuccess == errT );
		Assert( JET_errSuccess != err );
		}

	if ( JET_tableidNil != tableidSD )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidSD, err );
		}

	if ( JET_tableidNil != tableidObj )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidObj, err );
		}

	if ( NULL != rgbSD )
		{
		free( rgbSD );
		}

	return err;
	}

	

//
//	EXTERNAL FUNCTIONS
//


//	verify the integrity of the Quota table by rebuilding it
//	in a temp. table then verifying that the two tables match
//	exactly
//
INT ErrQuotaIntegrityCheck(
	JET_SESID			sesid,
	JET_DBID			dbid,
	ULONG *				pcCorruptions )
	{
	JET_ERR				err;
	JET_TABLEID			tableidQuota		= JET_tableidNil;
	JET_TABLEID			tableidObj			= JET_tableidNil;
	JET_TABLEID			tableidSD			= JET_tableidNil;
	JET_TABLEID			tableidQuotaTemp	= JET_tableidNil;
	BOOL				fQuotaTableHitEOF	= FALSE;
	BOOL				fTempTableHitEOF	= FALSE;
	const ULONG			iretcolNcdnt		= 0;
	const ULONG			iretcolSid			= 1;
	const ULONG			iretcolTombstoned	= 2;
	const ULONG			iretcolTotal		= 3;
	JET_RETRIEVECOLUMN	rgretcolQuota[4];
	JET_RETRIEVECOLUMN	rgretcolQuotaTemp[4];
	DWORD				ncdnt;
	BYTE				rgbSid[255];
	ULONG				cTombstoned;
	ULONG				cTotal;
	DWORD				ncdntTemp;
	BYTE				rgbSidTemp[255];
	ULONG				cTombstonedTemp;
	ULONG				cTotalTemp;
	JET_COLUMNID		rgcolumnidQuotaTemp[4];
	JET_COLUMNDEF		rgcolumndefQuotaTemp[4]		= {
		{ sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnTTKey },		//	ncdnt
		{ sizeof( JET_COLUMNDEF ), 0, JET_coltypBinary, 0, 0, 0, 0, 0, JET_bitColumnTTKey },	//	owner sid
		{ sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, 0, NO_GRBIT },				//	tombstoned count
		{ sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, 0, NO_GRBIT } };				//	total count


	//	initialise count of corruptions encountered
	//
	*pcCorruptions = 0;

	//	open necessary cursors
	//
	Call( JetOpenTable(
				sesid,
				dbid,
				g_szQuotaTable,
				NULL,
				0,
				JET_bitTableDenyRead,	//	ensure no one else could be accessing the table while we're checking it
				&tableidQuota ) );
	Assert( JET_tableidNil != tableidQuota );

	Call( JetOpenTable(
				sesid,
				dbid,
				SZDATATABLE,
				NULL,
				0,
				NO_GRBIT,
				&tableidObj ) );
	Assert( JET_tableidNil != tableidObj );

	Call( JetOpenTable(
				sesid,
				dbid,
				SZSDTABLE,
				NULL,
				0,
				NO_GRBIT,
				&tableidSD ) );
	Assert( JET_tableidNil != tableidSD );

	//	we'll be seeking and updating this table constantly, which
	//	will cause Jet to materialise the sort to a full-fledged
	//	temp. table pretty quickly, so may as well just force
	//	materialisation right off the bat
	//
	Call( JetOpenTempTable(
				sesid,
				rgcolumndefQuotaTemp,
				sizeof(rgcolumndefQuotaTemp) / sizeof(rgcolumndefQuotaTemp[0]),
				JET_bitTTForceMaterialization,
				&tableidQuotaTemp,
				rgcolumnidQuotaTemp ) );
	Assert( JET_tableidNil != tableidQuotaTemp );

	//	build copy of the Quota table in a temp table
	//
	Call( ErrQuotaRebuild_(
				sesid,
				dbid,
				tableidQuotaTemp,
				JET_tableidNil,
				ROOTTAG,
				rgcolumnidQuotaTemp[iretcolNcdnt],
				rgcolumnidQuotaTemp[iretcolSid],
				rgcolumnidQuotaTemp[iretcolTombstoned],
				rgcolumnidQuotaTemp[iretcolTotal],
				FALSE,			//	fAsync
				TRUE )	);		//	fCheckOnly

	//	now compare the temp table
	//	to the existing table to verify they
	//	are identical
	//
	memset( rgretcolQuota, 0, sizeof(rgretcolQuota) );
	memset( rgretcolQuotaTemp, 0, sizeof(rgretcolQuotaTemp) );

	rgretcolQuota[iretcolNcdnt].columnid = g_columnidQuotaNcdnt;
	rgretcolQuota[iretcolNcdnt].pvData = &ncdnt;
	rgretcolQuota[iretcolNcdnt].cbData = sizeof(ncdnt);
	rgretcolQuota[iretcolNcdnt].itagSequence = 1;

	rgretcolQuota[iretcolSid].columnid = g_columnidQuotaSid;
	rgretcolQuota[iretcolSid].pvData = rgbSid;
	rgretcolQuota[iretcolSid].cbData = sizeof(rgbSid);
	rgretcolQuota[iretcolSid].itagSequence = 1;

	rgretcolQuota[iretcolTombstoned].columnid = g_columnidQuotaTombstoned;
	rgretcolQuota[iretcolTombstoned].pvData = &cTombstoned;
	rgretcolQuota[iretcolTombstoned].cbData = sizeof(cTombstoned);
	rgretcolQuota[iretcolTombstoned].itagSequence = 1;

	rgretcolQuota[iretcolTotal].columnid = g_columnidQuotaTotal;
	rgretcolQuota[iretcolTotal].pvData = &cTotal;
	rgretcolQuota[iretcolTotal].cbData = sizeof(cTotal);
	rgretcolQuota[iretcolTotal].itagSequence = 1;

	rgretcolQuotaTemp[iretcolNcdnt].columnid = rgcolumnidQuotaTemp[iretcolNcdnt];
	rgretcolQuotaTemp[iretcolNcdnt].pvData = &ncdntTemp;
	rgretcolQuotaTemp[iretcolNcdnt].cbData = sizeof(ncdntTemp);
	rgretcolQuotaTemp[iretcolNcdnt].itagSequence = 1;

	rgretcolQuotaTemp[iretcolSid].columnid = rgcolumnidQuotaTemp[iretcolSid];
	rgretcolQuotaTemp[iretcolSid].pvData = rgbSidTemp;
	rgretcolQuotaTemp[iretcolSid].cbData = sizeof(rgbSidTemp);
	rgretcolQuotaTemp[iretcolSid].itagSequence = 1;

	rgretcolQuotaTemp[iretcolTombstoned].columnid = rgcolumnidQuotaTemp[iretcolTombstoned];
	rgretcolQuotaTemp[iretcolTombstoned].pvData = &cTombstonedTemp;
	rgretcolQuotaTemp[iretcolTombstoned].cbData = sizeof(cTombstonedTemp);
	rgretcolQuotaTemp[iretcolTombstoned].itagSequence = 1;

	rgretcolQuotaTemp[iretcolTotal].columnid = rgcolumnidQuotaTemp[iretcolTotal];
	rgretcolQuotaTemp[iretcolTotal].pvData = &cTotalTemp;
	rgretcolQuotaTemp[iretcolTotal].cbData = sizeof(cTotalTemp);
	rgretcolQuotaTemp[iretcolTotal].itagSequence = 1;

	//	unfortunately, temp tables don't currently support
	//	JetSetTableSequential
	//
	Call( JetSetTableSequential( sesid, tableidQuota, NO_GRBIT ) );

	//	initialise both cursors
	//
	err = JetMove( sesid, tableidQuota, JET_MoveFirst, NO_GRBIT );
	if ( JET_errNoCurrentRecord == err )
		{
		fQuotaTableHitEOF = TRUE;
		}
	else
		{
		CheckErr( err );
		}

	err = JetMove( sesid, tableidQuotaTemp, JET_MoveFirst, NO_GRBIT );
	if ( JET_errNoCurrentRecord == err )
		{
		fTempTableHitEOF = TRUE;
		}
	else
		{
		CheckErr( err );
		}

	for ( ; ; )
		{
		//	these flags indicate whether the cursors should be moved on the
		//	next iteration of the loop (note that the only time you wouldn't
		//	want to move one of the cursors is if corruption was hit and
		//	we're now trying to re-sync the cursors to the same record)
		//
		BOOL	fSkipQuotaCursor	= FALSE;
		BOOL	fSkipTempCursor		= FALSE;

		//	must filter out records in the Quota table
		//	without any more object references
		//
		while ( !fQuotaTableHitEOF )
			{
			//	retrieve the current record for real cursor
			//
			Call( JetRetrieveColumns(
							sesid,
							tableidQuota,
							rgretcolQuota,
							sizeof(rgretcolQuota) / sizeof(rgretcolQuota[0]) ) );

			if ( 0 != cTotal )
				{
				break;
				}
			else
				{
				//	records with no more object references may
				//	not have gotten deleted by Jet yet, so
				//	just ignore such records and move to the next
				//
				err = JetMove( sesid, tableidQuota, JET_MoveNext, NO_GRBIT );
				if ( JET_errNoCurrentRecord == err )
					{
					fQuotaTableHitEOF = TRUE;
					}
				else
					{
					CheckErr( err );
					}
				}
			}

		if ( fQuotaTableHitEOF && fTempTableHitEOF )
			{
			//	hit end of both cursors at the same time,
			//	so everything is fine - just exit the loop
			//
			break;
			}
		else if ( !fQuotaTableHitEOF && !fTempTableHitEOF )
			{
			//	both cursors are on a valid record, continue
			//	on to retrieve the record from the temp
			//	table and compare it against the record from
			//	the Quota table
			}
		else
			{
			//	hit end of one cursor, but not the other,
			//	so something is amiss - just force failure
			//
			CheckErr( JET_errNoCurrentRecord );
			}

		//	retrieve the current record for the temp cursor
		//
		Call( JetRetrieveColumns(
						sesid,
						tableidQuotaTemp,
						rgretcolQuotaTemp,
						sizeof(rgretcolQuotaTemp) / sizeof(rgretcolQuotaTemp[0]) ) );

		//	verify they are identical
		//
		if ( ncdnt != ncdntTemp )
			{
			DPRINT2( 0, "Mismatched ncdnt: %d - %d\n", ncdnt, ncdntTemp );
			Assert( !"Mismatched ncdnt." );
			(*pcCorruptions)++;

			if ( ncdnt > ncdntTemp )
				{
				//	key of current record in Quota table is greater than
				//	key of current record in temp table, so just move the
				//	temp table cursor to try and get the cursors to sync up
				//	to the same key again
				//
				fSkipQuotaCursor = TRUE;
				}
			else
				{
				//	key of current record in Quota table is less than
				//	key of current record in temp table, so just move the
				//	Quota table cursor to try and get the cursors to sync up
				//	to the same key again
				//
				fSkipTempCursor = TRUE;
				}
			}
		else if ( !EqualSid( (PSID)rgbSid, (PSID)rgbSidTemp ) )
			{
			const ULONG	cbSid		= rgretcolQuota[iretcolSid].cbActual;
			const ULONG	cbSidTemp	= rgretcolQuotaTemp[iretcolSid].cbActual;
			const INT	db			= cbSid - cbSidTemp;
			INT			cmp			= memcmp( rgbSid, rgbSidTemp, db < 0 ? cbSid : cbSidTemp );

			if ( 0 == cmp )
				{
				//	can't be equal
				//
				Assert( 0 != db );
				cmp = db;
				}

			DPRINT2( 0, "Mismatched owner SID for ncdnt %d (0x%x).\n", ncdnt, ncdnt );
			Assert( !"Mismatched owner SID." );
			(*pcCorruptions)++;

			if ( cmp > 0 )
				{
				//	key of current record in Quota table is greater than
				//	key of current record in temp table, so just move the
				//	temp table cursor to try and get the cursors to sync up
				//	to the same key again
				//
				fSkipQuotaCursor = TRUE;
				}
			else
				{
				//	key of current record in Quota table is less than
				//	key of current record in temp table, so just move the
				//	Quota table cursor to try and get the cursors to sync up
				//	to the same key again
				//
				fSkipTempCursor = TRUE;
				}
			}
		else if ( cTotal != cTotalTemp )
			{
			DPRINT4( 0, "Mismatched quota total count for ncdnt %d (0x%x): %d - %d\n", ncdnt, ncdnt, cTotal, cTotalTemp );
			Assert( !"Mismatched quota total count." );
			(*pcCorruptions)++;
			}
		else if ( cTombstoned != cTombstonedTemp )
			{
			DPRINT4( 0, "Mismatched quota tombstoned count for ncdnt %d (0x%x): %d - %d\n", ncdnt, ncdnt, cTombstoned, cTombstonedTemp );
			Assert( !"Mismatched quota tombstoned count." );
			(*pcCorruptions)++;
			}

		//	navigate both cursors to the next record,
		//	tracking whether either hits EOF
		//
		Assert( !fSkipQuotaCursor || *pcCorruptions > 0 );
		if ( !fSkipQuotaCursor )
			{
			err = JetMove( sesid, tableidQuota, JET_MoveNext, NO_GRBIT );
			if ( JET_errNoCurrentRecord == err )
				{
				fQuotaTableHitEOF = TRUE;
				}
			else
				{
				CheckErr( err );
				}
			}

		Assert( !fSkipTempCursor || *pcCorruptions > 0 );
		if ( !fSkipTempCursor )
			{
			err = JetMove( sesid, tableidQuotaTemp, JET_MoveNext, NO_GRBIT );
			if ( JET_errNoCurrentRecord == err )
				{
				fTempTableHitEOF = TRUE;
				}
			else
				{
				CheckErr( err );
				}
			}
		}

	if ( *pcCorruptions > 0 )
		{
		DPRINT1( 0, "CORRUPTION detected in Quota table. There were a total of %d problems.\n", *pcCorruptions );
		Assert( !"CORRUPTION detected in Quota table." );
		}

	err = JET_errSuccess;

HandleError:
	if ( JET_tableidNil != tableidQuotaTemp )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidQuotaTemp, err );
		}

	if ( JET_tableidNil != tableidSD )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidSD, err );
		}

	if ( JET_tableidNil != tableidObj )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidObj, err );
		}

	if ( JET_tableidNil != tableidQuota )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidQuota, err );
		}

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dscommon\time.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    time.c

ABSTRACT:

DETAILS:

CREATED:

    01/13/97   Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <drs.h>

#include <fileno.h>
#define  FILENO FILENO_TASKQ_TIME


DSTIME
GetSecondsSince1601( void )
{
    FILETIME   fileTime;
    DSTIME     dsTime = 0, tempTime = 0;

    GetSystemTimeAsFileTime( &fileTime );
    dsTime = fileTime.dwLowDateTime;
    tempTime = fileTime.dwHighDateTime;
    dsTime |= (tempTime << 32);

    // Ok. now we have the no. of 100 ns intervals since 1601
    // in dsTime. Convert to seconds and return

    return(dsTime/(10*1000*1000L));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dscommon\dsconfig.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsconfig.c
//
//--------------------------------------------------------------------------

/*
 * GetConfigParam reads a configuration keyword from the registry
 */

#include <NTDSpch.h>
#pragma  hdrstop

#include <ctype.h>

#define  DEBSUB  "DSCONFIG:"
#include <debug.h>
#include <ntdsa.h>

#include <dsconfig.h>
#include <fileno.h>
#define  FILENO FILENO_DSCONFIG


DWORD
GetConfigParam(
    char * parameter,
    void * value,
    DWORD dwSize)
{

    DWORD herr, err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%s\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if ((herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) ||
        (err = RegQueryValueEx(hk, parameter, NULL, &dwType, (LPBYTE) value, &dwSize))) {

        DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

    } else if (dwType == REG_SZ || dwType == REG_MULTI_SZ || dwType == REG_EXPAND_SZ) {
        if (dwSize>=sizeof(TCHAR) 
            && ((TCHAR*)value)[(dwSize-1)/sizeof(TCHAR)] != 0 )
        {
            Assert(0&&"The string is not null-terminated");
            return ERROR_INVALID_DATA;
        }

        DPRINT3( 2, " ** [%s] \"%s\" param = \"%s\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }
    if (herr) {
        // we don't have a handle, so just return the error
        return herr;
    }

    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}

DWORD
GetConfigParamW(
    WCHAR * parameter,
    void * value,
    DWORD dwSize)
{

    DWORD herr, err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%S\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if ((herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) ||
        (err = RegQueryValueExW(hk, parameter, NULL, &dwType, (LPBYTE) value, &dwSize))) {

        DPRINT3( 1, " ** [%s] \"%S\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

    } else if (dwType == REG_SZ || dwType == REG_MULTI_SZ || dwType == REG_EXPAND_SZ) {

        if (dwSize >= sizeof(WCHAR) 
            && ((WCHAR*)value)[(dwSize-1)/sizeof(WCHAR)] != 0)
        {
            Assert(0&&"The string is not null-terminated");
            return ERROR_INVALID_DATA;
        }

        DPRINT3( 2, " ** [%s] \"%S\" param = \"%S\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%S\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }
    //  Close the handle if one was opened.
    if (!herr) {
        RegCloseKey(hk);
    }

    return herr?herr:err;
}

DWORD
GetConfigParamA(
    char * parameter,
    void * value,
    DWORD dwSize)
{

    DWORD herr, err = ERROR_FILE_NOT_FOUND, dwType;
    HKEY  hk;

    DPRINT2( 2,
             " ** attempt to read [%s] \"%s\" param\n",
         DSA_CONFIG_SECTION,
         parameter );

    if ((herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) ||
        (err = RegQueryValueExA(hk, parameter, NULL, &dwType, (LPBYTE) value, &dwSize))) {

        DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

    } else if (dwType == REG_SZ || dwType == REG_MULTI_SZ || dwType == REG_EXPAND_SZ) {

        if (dwSize >= sizeof(char) 
            && ((char*)value)[dwSize-1] != 0 )
        {
            Assert(0&&"The string is not null-terminated");
            return ERROR_INVALID_DATA;
        }
        DPRINT3( 2, " ** [%s] \"%s\" param = \"%s\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }
    //  Close the handle if one was opened.
    if (!herr) {
        RegCloseKey(hk);
    }

    return err;
}


DWORD
GetConfigParamAlloc(
    IN  PCHAR   parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize)
/*++

Routine Description:

    Reads a value out of the DSA_CONFIG_SECTION of the registry, and 
    returns a newly allocated buffer containing the value.
    
Parameters

    parameter - The name of the value to read.

    value     - Used to pass back a pointer to the newly allocated buffer 
                containing the value that was read.  The buffer must be freed
                with free().
                
    pdwSize   - Used to pass back the size of the buffer allocated.

Return values:

    0 if all went well, otherwise a Win32 error code.

++*/
{

    DWORD err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%s\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if (err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) {
         
        DPRINT2( 1, " ** [%s] key not found. Status = %d\n",
            DSA_CONFIG_SECTION, err );
        return err;
    }
        
    //
    // Find out how big the buffer needs to be.
    //
    if (err = RegQueryValueEx(hk, parameter, NULL, &dwType, (LPBYTE) NULL, pdwSize)) {

        DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

        goto cleanup;
    }
    
    *value = malloc(*pdwSize);
    if (!*value) {
        DPRINT1( 1, " ** GetConfigParamAlloc failed to allocate %d bytes.\n", *pdwSize );
        err = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    
    if (err = RegQueryValueEx(hk, parameter, NULL, &dwType, (LPBYTE) *value, pdwSize)) {

            DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
                DSA_CONFIG_SECTION, parameter, err );
            free(*value); *value = NULL;

    } else if (dwType == REG_SZ) {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"%s\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }

cleanup:
    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}

DWORD
GetConfigParamAllocW(
    IN  PWCHAR  parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize)
/*++

Routine Description:

    Reads a value out of the DSA_CONFIG_SECTION of the registry, and 
    returns a newly allocated buffer containing the value.
    
    This version of GetConfigParamAlloc uses the the wide character version
    of RegQueryValueExW.
    
Parameters

    parameter - The name of the value to read.

    value     - Used to pass back a pointer to the newly allocated buffer 
                containing the value that was read.  The buffer must be freed
                with free().
                
    pdwSize   - Used to pass back the size of the buffer allocated.

Return values:

    0 if all went well, otherwise a Win32 error code.

++*/
{

    DWORD err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%S\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if (err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) {
         
        DPRINT2( 1, " ** [%S] key not found. Status = %d\n",
            DSA_CONFIG_SECTION, err );
        return err;
    }
        
    //
    // Find out how big the buffer needs to be.
    //
    if (err = RegQueryValueExW(hk, parameter, NULL, &dwType, (LPBYTE) NULL, pdwSize)) {

        DPRINT3( 1, " ** [%s] \"%S\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

        goto cleanup;
    }
    
    *value = malloc(*pdwSize);
    if (!*value) {
        DPRINT1( 1, " ** GetConfigParamAlloc failed to allocate %d bytes.\n", *pdwSize );
        err = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    
    if (err = RegQueryValueExW(hk, parameter, NULL, &dwType, (LPBYTE) *value, pdwSize)) {

            DPRINT3( 1, " ** [%s] \"%S\" param not found. Status = %d\n",
                DSA_CONFIG_SECTION, parameter, err );
            free(*value); *value = NULL;

    } else if (dwType == REG_SZ) {

        DPRINT3( 2, " ** [%s] \"%S\" param = \"%S\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%S\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }

cleanup:
    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}

DWORD
GetConfigParamAllocA(
    IN  PCHAR   parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize)
/*++

Routine Description:

    Reads a value out of the DSA_CONFIG_SECTION of the registry, and 
    returns a newly allocated buffer containing the value.
    
    This version of GetConfigParamAlloc uses the ascii version of RegQueryValueEx.
    
Parameters

    parameter - The name of the value to read.

    value     - Used to pass back a pointer to the newly allocated buffer 
                containing the value that was read.  The buffer must be freed
                with free().
                
    pdwSize   - Used to pass back the size of the buffer allocated.

Return values:

    0 if all went well, otherwise a Win32 error code.

++*/
{

    DWORD err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%s\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if (err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) {
         
        DPRINT2( 1, " ** [%s] key not found. Status = %d\n",
            DSA_CONFIG_SECTION, err );
        return err;
    }
        
    //
    // Find out how big the buffer needs to be.
    //
    if (err = RegQueryValueExA(hk, parameter, NULL, &dwType, (LPBYTE) NULL, pdwSize)) {

        DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

        goto cleanup;
    }
    
    *value = malloc(*pdwSize);
    if (!*value) {
        DPRINT1( 1, " ** GetConfigParamAlloc failed to allocate %d bytes.\n", *pdwSize );
        err = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    
    if (err = RegQueryValueExA(hk, parameter, NULL, &dwType, (LPBYTE) *value, pdwSize)) {

            DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
                DSA_CONFIG_SECTION, parameter, err );
            free(*value); *value = NULL;

    } else if (dwType == REG_SZ) {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"%s\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }

cleanup:
    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}

DWORD
SetConfigParam(
    char * parameter,
    DWORD dwType,
    void * value,
    DWORD dwSize)
{

    DWORD herr = 0, err = 0;
    HKEY  hk;

    DPRINT2( 2,
             " ** attempt to write [%s] \"%s\" param\n",
         DSA_CONFIG_SECTION,
         parameter );

    herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk); 
    if (herr) {
        // we don't have a handle, so just return the error
        return herr;
    }

    err = RegSetValueEx(hk, parameter, 0, dwType, (LPBYTE) value, dwSize);

    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}

DWORD
DeleteConfigParam(
    char * parameter)
{
    DWORD herr = 0, err = 0;
    HKEY  hk;

    herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk);
    if (herr) {
        // we don't have a handle, so just return the error
        return herr;
    }

    err = RegDeleteValueA(hk, parameter);

    RegCloseKey(hk);
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dscommon\filelog.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tlog.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    File logging routines. A lot of them copied unshamefully from
    netlogon.

--*/

#include <NTDSpch.h>
#include "dststlog.h"

#define MAX_PRINTF_LEN  (16 * 1024)

HANDLE           hLogFile = INVALID_HANDLE_VALUE;
HANDLE           hChange = INVALID_HANDLE_VALUE;
HANDLE           hWait = INVALID_HANDLE_VALUE;

//
// tags used by our debug logs
// format is [PN=<process name>][CN=<computername>]
//

CHAR CnPnTag[MAX_COMPUTERNAME_LENGTH+1+64+MAX_PATH+1] = {0};
CHAR Windir[MAX_PATH+1] = {0};
CHAR ProcessName[MAX_PATH+1] = {0};
CHAR LogFileName[1024] = {0};

BOOL
GetProcName(
    IN PCHAR    ProcessName,
    IN DWORD    TaskId
    );

BOOL
GetLogFileName(
    IN PCHAR Name,
    IN PCHAR Prefix,
    IN PCHAR Middle,
    IN BOOL  fCheckDSLOGMarker
    );

VOID
DsCloseLogFile(
    VOID
    );

VOID
DsPrintRoutineV(
    IN DWORD Flags,
    IN LPSTR Format,
    va_list arglist
    )
// Must be called with DsGlobalLogFileCritSect locked

{
    static LPSTR DsGlobalLogFileOutputBuffer = NULL;
    ULONG length;
    DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    static LogProblemWarned = FALSE;

    if ( hLogFile == INVALID_HANDLE_VALUE ) {
        return;
    }

    //
    // Allocate a buffer to build the line in.
    //  If there isn't already one.
    //

    length = 0;

    if ( DsGlobalLogFileOutputBuffer == NULL ) {
        DsGlobalLogFileOutputBuffer = LocalAlloc( 0, MAX_PRINTF_LEN );

        if ( DsGlobalLogFileOutputBuffer == NULL ) {
            return;
        }
    }

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // Never print empty lines.
        //

        if ( Format[0] == '\n' && Format[1] == '\0' ) {
            return;
        }

        //
        // If we're writing to the debug terminal,
        //  indicate this is a Netlogon message.
        //

        //
        // Put the timestamp at the begining of the line.
        //

        if ( (Flags & DSLOG_FLAG_NOTIME) == 0) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &DsGlobalLogFileOutputBuffer[length],
                                  "%02u/%02u/%04u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wYear,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        } else {
            CopyMemory(&DsGlobalLogFileOutputBuffer[length], 
                       "               ", 
                       15);
            length += 15;
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    length += (ULONG) vsprintf(&DsGlobalLogFileOutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && DsGlobalLogFileOutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {
        DsGlobalLogFileOutputBuffer[length-1] = '\r';
        DsGlobalLogFileOutputBuffer[length] = '\n';
        DsGlobalLogFileOutputBuffer[length+1] = '\0';
        length++;
    } 

    //
    // Do we need to add tags
    //

    if ( (Flags & DSLOG_FLAG_TAG_CNPN) != 0 ) {

        strcat(DsGlobalLogFileOutputBuffer, CnPnTag);
        length = strlen(DsGlobalLogFileOutputBuffer);
    }

    //
    // Write the debug info to the log file.
    //

    if ( !WriteFile( hLogFile,
                     DsGlobalLogFileOutputBuffer,
                     length,
                     &BytesWritten,
                     NULL ) ) {

        if ( !LogProblemWarned ) {
            DbgPrint( "[DSLOGS] Cannot write to log file error %ld\n", 
                             GetLastError() );
            LogProblemWarned = TRUE;
        }
    }

} // DsPrintRoutineV

BOOL
DsPrintLog(
    IN LPSTR    Format,
    ...
    )

{
    va_list arglist;

    //
    // Simply change arguments to va_list form and call DsPrintRoutineV
    //

    va_start(arglist, Format);

    DsPrintRoutineV( 0, Format, arglist );

    va_end(arglist);
    return TRUE;
} // DsPrintRoutine


VOID
NotifyCallback(
    PVOID Context,
    BOOLEAN fTimeout
    )
{    
    CHAR fileName[MAX_PATH+1];
    BOOL fDelayedDeletion = FALSE;

    // check for buffer overrun
    if (Context == NULL || strlen(Windir) + 1 + strlen((PCHAR)Context) + 1 > sizeof(fileName)) {
        // invalid parameter, just return
        return;
    }
    strcpy(fileName,Windir);
    strcat(fileName,"\\");
    strcat(fileName, (PCHAR)Context);

    if ( !DeleteFile(fileName) ) {
        if ( GetLastError() == ERROR_SHARING_VIOLATION ) {
            fDelayedDeletion = TRUE;
            //KdPrint(("Failed to delete file %s. Err %d\n",fileName, GetLastError()));
        }
        goto exit;
    } else {
        //KdPrint(("Detected file %s. Rollover in progress\n",fileName));
    }

    //
    // we deleted the file name corresponding to our process. 
    // This is a signal for us to roll the logs over.
    //

    strcat(LogFileName,".0");
    CloseHandle(hLogFile);
    hLogFile = CreateFileA( LogFileName,
                            GENERIC_WRITE|GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    if ( hLogFile == INVALID_HANDLE_VALUE ) {
        DsCloseLogFile();
    }

exit:
    FindNextChangeNotification(hChange);
    UnregisterWaitEx(hWait,NULL);
    hWait = RegisterWaitForSingleObjectEx(hChange,
                                        NotifyCallback,
                                        ProcessName,
                                        fDelayedDeletion? 10*1000 : INFINITE,
                                        WT_EXECUTEONLYONCE  );
    return;
} // NotifyCallback


BOOL
DsOpenLogFile(
    IN PCHAR FilePrefix,
    IN PCHAR MiddleName,
    IN BOOL fCheckDSLOGMarker
    )
{
    BOOL ret = TRUE;
    static BOOL haveFailed = FALSE;
    CHAR computerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD nCN = sizeof(computerName);

    //
    // Open the file.
    //

    if ( (hLogFile != INVALID_HANDLE_VALUE) || haveFailed ) {
        goto exit;
    }

    //
    // Get Name to open
    //

    if (!GetLogFileName(LogFileName,FilePrefix,MiddleName,fCheckDSLOGMarker)) {
        ret = FALSE;
        goto exit;
    }

    hLogFile = CreateFileA( LogFileName,
                            GENERIC_WRITE|GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    if ( hLogFile == INVALID_HANDLE_VALUE ) {
        //KdPrint(("DSOpenLog: cannot open %s Error %d\n", LogFileName,GetLastError() ));
        ret=FALSE;
        haveFailed = TRUE;
        goto exit;
    } 

    //
    // Initialize CnPnTag
    //

    if ( GetProcName(ProcessName, GetCurrentProcessId()) &&
         GetComputerName(computerName, &nCN) ) {

        strcpy(CnPnTag, "[PN=");
        strcat(CnPnTag, ProcessName);
        strcat(CnPnTag, "][CN=");
        strcat(CnPnTag, computerName);
        strcat(CnPnTag, "]");

        //
        // Register a notification. If we see a file with the same name as
        // the process, we need to roll the log over
        //

        if ( fCheckDSLOGMarker ) {

            hChange = FindFirstChangeNotificationA(Windir,
                                                  FALSE,
                                                  FILE_NOTIFY_CHANGE_FILE_NAME);

            if ( hChange != INVALID_HANDLE_VALUE ) {

                hWait = RegisterWaitForSingleObjectEx(hChange,
                                                    NotifyCallback,
                                                    ProcessName,
                                                    INFINITE,
                                                    WT_EXECUTEONLYONCE );
            }
        }
    } else {
        strcpy(CnPnTag,"[PN=unknown][CN=unknown]");
    }

exit:

    return ret;

} // DsOpenFile



BOOL
GetProcName(
    IN PCHAR    ProcessName,
    IN DWORD    TaskId
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses internal NT apis and data structures.  This
    api is MUCH faster that the non-internal version that uses the registry.

Arguments:

    dwNumTasks       - maximum number of tasks that the pTask array can hold

Return Value:

    Number of tasks placed into the pTask array.

--*/

{
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo;
    NTSTATUS                     status;
    ANSI_STRING                  pname;
    PCHAR                        p;
    ULONG                        TotalOffset;
    BOOL    ret = FALSE;
    PCHAR   CommonLargeBuffer;
    DWORD   CommonLargeBufferSize = 8192;


retry:

    CommonLargeBuffer = VirtualAlloc (NULL,
                                      CommonLargeBufferSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE);
    if (CommonLargeBuffer == NULL) {
        return FALSE;
    }

    status = NtQuerySystemInformation(
                SystemProcessInformation,
                CommonLargeBuffer,
                CommonLargeBufferSize,
                NULL
                );

    if (status == STATUS_INFO_LENGTH_MISMATCH) {
        CommonLargeBufferSize += 8192;
        VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
        CommonLargeBuffer = NULL;
        goto retry;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) CommonLargeBuffer;
    TotalOffset = 0;
    while (TRUE) {
        DWORD dwProcessId;

        pname.Buffer = NULL;
        dwProcessId = (DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId;

        if ( dwProcessId == TaskId) {

            if ( ProcessInfo->ImageName.Buffer ) {
                status = RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
                if (!NT_SUCCESS(status)) {
                    VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
                    return FALSE;
                }
                p = strrchr(pname.Buffer,'\\');
                if ( p ) {
                    p++;
                }
                else {
                    p = pname.Buffer;
                }
            }
            else {
                p = "System Process";
            }

            strcpy( ProcessName, p );
            p=strrchr(ProcessName,'.');
            if ( p!=NULL) {
                *p = '\0';
            }
            ret=TRUE;
            break;
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CommonLargeBuffer[TotalOffset];
    }

    VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
    return ret;
}


BOOL
GetLogFileName(
    IN PCHAR Name,
    IN PCHAR Prefix,
    IN PCHAR MiddleName,
    IN BOOL  fCheckDSLOGMarker
    )
{
    CHAR FileName[MAX_PATH+1];
    DWORD err;
    DWORD i;
    DWORD   TaskId = GetCurrentProcessId();
    WIN32_FIND_DATA w32Data;
    HANDLE hFile;

    if ( GetWindowsDirectory(Windir,MAX_PATH+1) == 0 ) {
        strcpy(Windir, "C:\\");
    }

    strcat(Windir,"\\Debug");

    //
    // does the marker file exist? if not, don't log
    //

    if ( fCheckDSLOGMarker ) {
        sprintf(Name,"%s\\DSLOG", Windir);

        hFile = FindFirstFile(Name, &w32Data);
        if ( hFile == INVALID_HANDLE_VALUE ) {
            return FALSE;
        }
        FindClose(hFile);
    }

    if ( MiddleName == NULL ) {
        if (!GetProcName(FileName,TaskId)) {
            // check for buffer overrun
            if (Prefix == NULL || strlen(Prefix) + 1 > sizeof(FileName)) {
                return FALSE;
            }
            strcpy(FileName, Prefix);
        }
    } else {
        // check for buffer overrun
        if (MiddleName == NULL || strlen(MiddleName) + 1 > sizeof(FileName)) {
            return FALSE;
        }
        strcpy(FileName, MiddleName);
    }

    //
    // ok, add a suffix
    //

    (VOID)CreateDirectory(Windir,NULL);

    for (i=0;i<500000;i++) {

        sprintf(Name,"%s\\%s.%s.%u",Windir,Prefix,FileName,i);

        hFile = FindFirstFile(Name, &w32Data);
        if ( hFile == INVALID_HANDLE_VALUE ) {
            if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
                break;
            }
            break;
        } else {
            FindClose(hFile);
        }
    }

    return TRUE;
} // GetLogFileName


VOID
DsCloseLogFile(
    VOID
    )
{
    if ( hWait != INVALID_HANDLE_VALUE ) {
        UnregisterWait(hWait);
        hWait = INVALID_HANDLE_VALUE;
    }

    if ( hChange != INVALID_HANDLE_VALUE ) {
        FindCloseChangeNotification(hChange);
        hChange = INVALID_HANDLE_VALUE;
    }

    if ( hLogFile != INVALID_HANDLE_VALUE ) {
        CloseHandle(hLogFile);
        hLogFile = INVALID_HANDLE_VALUE;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dscommon\dsutil.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dsutil.c
//
//  Contents:  Common Utility Routines
//
//  Functions:
//
//----------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsa.h>
#include <drs.h>
#include <issperr.h>        // Security package errors
#include <crt\limits.h>     // ULONG_MAX
#include <debug.h>          // Assert
#include <winsvc.h>
#include <strsafe.h>

#include <fileno.h>
#define FILENO  FILENO_DSUTIL

#define TIME_TICK_HALF_RANGE (ULONG_MAX >> 2)

#if DBG
#define DSUTIL_STR_TOO_SHORT(sz, cch)   Assert(!"Not enough buffer"); \
                                        if((cch)>5){ \
                                            StringCchCopy((sz), (cch), "#err#"); \
                                        } else if ((cch) > 0){ \
                                            (sz)[0] = '\0'; \
                                        }
#else                                        
#define DSUTIL_STR_TOO_SHORT(sz, cch)   if((cch)>0){ \
                                            (sz)[0] = '\0'; \
                                        }
#endif

//Parameters to control wait for service start

// This was value was chosen because of long delays seen on the first reboot
// following DC promotion
#define DEMAND_START_RETRIES 18

#define WAIT_BETWEEN_RETRIES_MS (10 * 1000)


LARGE_INTEGER
atoli
(
    char* Num
)
{
    LONG base=10;
    int  sign=1;

    LARGE_INTEGER ret;
    char* next=Num;

    ret.QuadPart = 0;

    switch (*next)
    {
        case '-': sign = -sign; next++; break;
        case '+':               next++; break;
        case '\\':
        {
            next++;
            switch (toupper(*next))
            {
                case 'X': base=16; next++;break;
                case '0': base= 8; next++;break;
            }
        }
        break;
    }

    for (;*next!='\0';next++)
    {
        int nextnum = 0;

        if (*next>='0' && *next<='9')
        {
             nextnum= *next - '0';
        }
        else if ( toupper(*next)>='A' && toupper(*next)<='F' )
        {
             nextnum= 10 + toupper(*next) - 'A';
        }


        if ( nextnum < base)
        {
            ret = RtlLargeIntegerAdd
            (
                RtlConvertLongToLargeInteger(nextnum),
                RtlExtendedIntegerMultiply(ret, base)
            );
        }
        else
        {
            break;
        }
    }

    return RtlExtendedIntegerMultiply(ret, sign);
}


char *litoa
(
    LARGE_INTEGER value,
    char *string,
    int radix
)
{

    RtlLargeIntegerToChar(&value,radix,64,string);

    return string;
}



UUID gNullUuid = {0,0,0,{0,0,0,0,0,0,0,0}};

// Return TRUE if the ptr to the UUID is NULL, or the uuid is all zeroes

BOOL fNullUuid (const UUID *pUuid)
{
    if (!pUuid) {
        return TRUE;
    }

    if (memcmp (pUuid, &gNullUuid, sizeof (UUID))) {
        return FALSE;
    }
    return TRUE;
}

UCHAR * UuidToStr(
    const UUID* pUuid, 
    UCHAR *szOutUuid,
    ULONG cchOutUuid
    )
/*++

Routine Description:

    This function converts a UUID to a hex string. The UUID is actually a
    structure with a ULONG, 2 USHORTS, and a 8 byte array, but for logging
    we construct the string as if it were a 16 byte array. This is so that
    it matches the view from the DIT browser. We special case the case where
    the pUUID is a NULL UUID.
    
    If Uuid Cahcing is enabled, we put the server name on the end if we can
    find it.
    
Arguments:

    pUuid (IN) - Pointer to a UUID/GUID.
    szOutUuid (OUT) - pointer to a buffer.  Buffer should be long enough.
        If there is no UUID caching enabled, then the buffer needs to only
        be 33 chars long.  If there is UUID caching, then not sure, but
        the function is safe in that it will print what it's supposed to
        if it can.  On errors you'll get back a NULL terminated zero length
        string if there is at least 1 char for the string.
    cchOutUuid (IN) - length of the output buffer.

Return Values:

    Returns a ptr to the string.  Would prefer to return NULL on error, but
    current useage suggests it wouldn't be safe.

--*/
{
    int i;
    unsigned char * pchar;
    HRESULT hr;

    if (!fNullUuid (pUuid)) {
        pchar = (char*) pUuid;

        for (i=0;i < sizeof(UUID);i++) {
             hr = StringCchPrintf(&(szOutUuid[i*2]),
                                  cchOutUuid - (i*2),
                                  "%.2x", 
                                  (*(pchar++)) );
             if (hr) {
                 DSUTIL_STR_TOO_SHORT(szOutUuid, cchOutUuid);
                 return(szOutUuid);
             }
        }
#ifdef CACHE_UUID
        if (pchar = FindUuid (pUuid)) {
            hr = StringCchCat(pOutUuid, cchOutUuid, " ");
            if (hr) {
                Assert(!"Buffer to short!");
                // shorten the buffer to the length of just the GUID
                szOutUuid[sizeof(UUID)*2] = '\0';
                return(szOutUuid);
            }
            hr = StringCchCat(pOutUuid, cchOutUuid, pchar);
            if (hr) {
                Assert(!"Buffer to short!");
                // shorten the buffer to the length of just the GUID
                szOutUuid[sizeof(UUID)*2] = '\0';
                return(szOutUuid);
            }
        }
#endif
    } else {
        if (sizeof(UUID)*2+1 > cchOutUuid) {
            DSUTIL_STR_TOO_SHORT(szOutUuid, cchOutUuid);
            return(szOutUuid);
        }   
        memset (szOutUuid, '0', sizeof(UUID)*2);
        szOutUuid[sizeof(UUID)*2] = '\0';
    }
    return szOutUuid;
}

ULONG
SidToStr(
    const PUCHAR  pSid,
    DWORD   SidLen,
    PUCHAR  pOutSid,
    ULONG   cchOutSid
    )
/*++

Routine Description:

    Format a SID as a hex string

Arguments:

    pSid - pointer to Sid
    SidLen - Length of the Sid
    pOutSid - Output buffer to contain data.  Must be at least SidLen*2 +1
    cchOutSid - Length in characters of output buffer.

Return Value:

    How many chars we used up, NOT including the NULL termination we wrote.
    The string will always be NULL terminated!  If we can't write the whole
    desired output, we just write a NULL to pOutSid[0] and return zero.

--*/
{
    int i;
    unsigned char * pchar;
    HRESULT hr;

    for (i=0;i < (INT)SidLen;i++) {
        hr = StringCchPrintf(&(pOutSid[i*2]),
                             cchOutSid - (i*2),
                             "%.2x", 
                             pSid[i]);
        if (hr) {
            DSUTIL_STR_TOO_SHORT(pOutSid, cchOutSid);
            return(0);
        }
    }
    if (cchOutSid < (SidLen*2+1)) {
        DSUTIL_STR_TOO_SHORT(pOutSid, cchOutSid);
        return(0);
    }
    pOutSid[SidLen*2] = '\0';
    return(SidLen*2);
} // SidToStr


LPSTR
DsUuidToStructuredStringCch(
    const UUID * pUuid,
    LPSTR pszUuidBuffer,
    ULONG cchUuidBuffer
    )

/*++

Routine Description:

    Format a UUID as a string with separated subfields

Arguments:

    pUuid - pointer to uuid
    pszUuidBuffer - Storage to hold the ascii representation. Should be atleast
                    40 characters.
    cchUuidBuffer - Size of pszUuidBuffer.  Should be at least 40 characters.

Return Value:

    LPSTR - Returned pszUuidBuffer.  Would prefer to return NULL on error, but
    current useage suggests this isn't safe.  Instead on failure if the buffer
    is big enough we write a NULL to the first position, this seems safest.

--*/

{
    HRESULT hr;

    hr = StringCchPrintf(pszUuidBuffer,
                         cchUuidBuffer,
                         "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                         pUuid->Data1,
                         pUuid->Data2,
                         pUuid->Data3,
                         pUuid->Data4[0],
                         pUuid->Data4[1],
                         pUuid->Data4[2],
                         pUuid->Data4[3],
                         pUuid->Data4[4],
                         pUuid->Data4[5],
                         pUuid->Data4[6],
                         pUuid->Data4[7] );
    if (hr) {
        DSUTIL_STR_TOO_SHORT(pszUuidBuffer, cchUuidBuffer);
    }

    return pszUuidBuffer;

} /* DsUuidToStructuredString */

LPWSTR
DsUuidToStructuredStringCchW(
    const UUID * pUuid,
    LPWSTR pszUuidBuffer,
    ULONG cchUuidBuffer
    )

/*++

Routine Description:

    Format a UUID as a string with separated subfields

Arguments:

    pUuid - pointer to uuid
    pszUuidBuffer - Storage to hold the wide-char representation. 
                    Should be atleast 40 characters.
    cchUuidBuffer - Size of pszUuidBuffer.  Should be at least 40 characters.

Return Value:

    LPWSTR - Returned pszUuidBuffer.  Would prefer to return NULL on error, but
    current useage suggests it wouldn't be safe.  Instead on failure if the buffer
    is big enough we write a NULL to the first position, this seems safest.

--*/

{
    HRESULT hr;

    hr = StringCchPrintfW(pszUuidBuffer,
                          cchUuidBuffer,
                          L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                          pUuid->Data1,
                          pUuid->Data2,
                          pUuid->Data3,
                          pUuid->Data4[0],
                          pUuid->Data4[1],
                          pUuid->Data4[2],
                          pUuid->Data4[3],
                          pUuid->Data4[4],
                          pUuid->Data4[5],
                          pUuid->Data4[6],
                          pUuid->Data4[7] );
    if (hr) {
        Assert(!"Not enough buffer");
        if (cchUuidBuffer > 0) {
            pszUuidBuffer[0] = 0;
        }
    }

    return pszUuidBuffer;

} /* DsUuidToStructuredString */

void
DSTimeToUtcSystemTime(
    IN  DSTIME          dstime,
    OUT SYSTEMTIME *    psystime
    )
/*++

Routine Description:

    Converts DSTIME to UTC SYSTEMTIME.
    
Arguments:

    dstime (IN) - DSTIME to convert.
    
    psystime (OUT) - On return, holds the corresponding UTC SYSTEMTIME.

Return Values:

    None.

--*/
{
    ULONGLONG   ull;
    FILETIME    filetime;
    BOOL        ok;
    
    Assert(sizeof(DSTIME) == sizeof(ULONGLONG));

    // Convert DSTIME to FILETIME.
    ull = (LONGLONG) dstime * 10*1000*1000L;
    filetime.dwLowDateTime  = (DWORD) (ull & 0xFFFFFFFF);
    filetime.dwHighDateTime = (DWORD) (ull >> 32);

    // Convert FILETIME to SYSTEMTIME,
    ok = FileTimeToSystemTime(&filetime, psystime);
    Assert(ok);
}

void
FileTimeToDSTime(
    IN  FILETIME        Filetime,
    OUT DSTIME *        pDstime
    )
/*++

Routine Description:

    Converts DSTIME to UTC SYSTEMTIME.
    
Arguments:

    dstime (IN) - DSTIME to convert.
    
    psystime (OUT) - On return, holds the corresponding FILETIME.

Return Values:

    None.

--*/
{
    ULONGLONG   ull;
    
    Assert(sizeof(DSTIME) == sizeof(ULONGLONG));

    // Convert FILETIME To DSTIME.
    ull = Filetime.dwHighDateTime;
    ull <<= 32;
    ull |= Filetime.dwLowDateTime;

    *pDstime = ull / (10 * 1000 * 1000);
}
void
DSTimeToFileTime(
    IN  DSTIME          dstime,
    OUT FILETIME *      pFiletime
    )
/*++

Routine Description:

    Converts DSTIME to FILETIME
    
Arguments:

    dstime (IN) - DSTIME to convert.
    
    pFiletime (OUT) - On return, holds the corresponding FILETIME.

Return Values:

    None.

--*/
{
    ULONGLONG   ull;
    
    Assert(sizeof(DSTIME) == sizeof(ULONGLONG));

    // Convert DSTIME to FILETIME.
    ull = (LONGLONG) dstime * 10*1000*1000L;
    pFiletime->dwLowDateTime  = (DWORD) (ull & 0xFFFFFFFF);
    pFiletime->dwHighDateTime = (DWORD) (ull >> 32);
}


void
DSTimeToLocalSystemTime(
    IN  DSTIME          dstime,
    OUT SYSTEMTIME *    psystime
    )
/*++

Routine Description:

    Converts DSTIME to local SYSTEMTIME.
    
Arguments:

    dstime (IN) - DSTIME to convert.
    
    psystime (OUT) - On return, holds the corresponding local SYSTEMTIME.

Return Values:

    None.

--*/
{
    SYSTEMTIME  utcsystime;
    BOOL        ok;
    
    DSTimeToUtcSystemTime(dstime, &utcsystime);

    // For those cases where the local time call fails (usually because dstime
    // was something like 3)
    *psystime = utcsystime;

    ok = SystemTimeToTzSpecificLocalTime(NULL, &utcsystime, psystime);
    Assert(ok || dstime < 20);
}

LPSTR
DSTimeToDisplayStringCch(
    IN  DSTIME  dstime,
    OUT LPSTR   pszTime,
    IN  ULONG   cchTime
    )
/*++

Routine Description:

    Converts DSTIME to display string; e.g., "1998-04-19 12:29.53" for April
    19, 1998 at 12:29 pm and 53 seconds.
    
Arguments:

    dstime (IN) - DSTIME to convert.
    
    pszTime (OUT) - On return, holds the corresponding time display string.
        This buffer should be allocated to hold at least SZDSTIME_LEN
        characters.
        
    cchTime (IN) - Length of the buffer.

Return Values:

    The pszTime input parameter.

--*/
{
    HRESULT hr;

    if (0 == dstime) {
        hr = StringCchCopy(pszTime, cchTime, "(never)");
        if (hr) {
            DSUTIL_STR_TOO_SHORT(pszTime, cchTime);
        }
    }
    else {
        SYSTEMTIME systime;

        DSTimeToLocalSystemTime(dstime, &systime);

        hr = StringCchPrintf(pszTime,
                        cchTime,
                        "%04d-%02d-%02d %02d:%02d:%02d",
                        systime.wYear % 10000,
                        systime.wMonth,
                        systime.wDay,
                        systime.wHour,
                        systime.wMinute,
                        systime.wSecond);
        if (hr) {
            DSUTIL_STR_TOO_SHORT(pszTime, cchTime);
        }
    }
    
    return pszTime;
}


DWORD
MapRpcExtendedHResultToWin32(
    HRESULT hrCode
    )
/*++

Routine Description:

    This routine attempts to map HRESULT errors returned from
    I_RpcGetExtendedError in win32 values.

    The SEC_E_XXX errors get generated in the following
    File: security\lsa\security\dll\support.cxx
    Function: SspNtStatusToSecStatus

Arguments:

    hrCode - HResult code to be mapped

Return Value:

    DWORD - Corresponding Win32 value

--*/
{
    DWORD status;

    switch (hrCode) {

        // Errors with straight-forward translations

    case SEC_E_INSUFFICIENT_MEMORY:
        status = ERROR_NOT_ENOUGH_MEMORY;
        break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        status = ERROR_BAD_USERNAME;
        break;
    case SEC_E_INVALID_TOKEN:
        status = ERROR_INVALID_PASSWORD;
        break;
    case SEC_E_NOT_OWNER:
        status = ERROR_PRIVILEGE_NOT_HELD;
        break;
    case SEC_E_INVALID_HANDLE:
        status = ERROR_INVALID_HANDLE;
        break;
    case SEC_E_BUFFER_TOO_SMALL:
        status = ERROR_INSUFFICIENT_BUFFER;
        break;
    case SEC_E_UNSUPPORTED_FUNCTION:
        status = ERROR_NOT_SUPPORTED;
        break;
    case SEC_E_INTERNAL_ERROR:
        status = ERROR_INTERNAL_ERROR;
        break;

        // These are the important security specific codes

    case SEC_E_TIME_SKEW:
        status = ERROR_TIME_SKEW;
        break;

        //STATUS_LOGON_FAILURE:
        //STATUS_NO_SUCH_USER:
        //STATUS_ACCOUNT_DISABLED:
        //STATUS_ACCOUNT_RESTRICTION:
        //STATUS_ACCOUNT_LOCKED_OUT:
        //STATUS_WRONG_PASSWORD:
        //STATUS_ACCOUNT_EXPIRED:
        //STATUS_PASSWORD_EXPIRED:
        //STATUS_PASSWORD_MUST_CHANGE:
    case SEC_E_LOGON_DENIED:
        status = ERROR_LOGON_FAILURE;
        break;

        //STATUS_OBJECT_NAME_NOT_FOUND:
        //STATUS_NO_TRUST_SAM_ACCOUNT:
        //SPN not found
        // talking to wrong system
        // mutual authentication failure
    case SEC_E_TARGET_UNKNOWN:
        status = ERROR_WRONG_TARGET_NAME;
        break;

        //STATUS_NETLOGON_NOT_STARTED:
        //STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
        //STATUS_NO_LOGON_SERVERS:
        //STATUS_NO_SUCH_DOMAIN:
        //STATUS_BAD_NETWORK_PATH:
        //STATUS_TRUST_FAILURE:
        //STATUS_TRUSTED_RELATIONSHIP_FAILURE:
    case SEC_E_NO_AUTHENTICATING_AUTHORITY:
        status = ERROR_DOMAIN_CONTROLLER_NOT_FOUND;
        break;

    default:
        // We don't recognize the code: just return it
        status = hrCode;
        break;
    }

    return status;

} /* MapRpcExtendedHResultToWin32 */


DWORD
AdvanceTickTime(
    DWORD BaseTick,
    DWORD Delay
    )

/*++

Routine Description:

Add an offset to a base time expressed in ticks.  The offset must fall within
half of the range of a tick count.

Jeffparh wrote:
By the same argument, is it possible that AdvanceTickTime(BaseTick, Delay)
should just be BaseTick + Delay?  That's what's returned if the tick count
won't wrap before then.  If it will wrap, it returns:
Delay - timeToWrap
= Delay - (ULONG_MAX - BaseTick)
= Delay + BaseTick - ULONG_MAX
= BaseTick + Delay + 1 (and the +1 seems wrong)

[wlees] I think we do it this way to avoid a hardware overflow, which should
be harmless

Arguments:

    BaseTick - Starting time
    Delay - Offset to add, must be within half of range

Return Value:

    DWORD - Resulting tick time, maybe wrapped

--*/

{
    DWORD timeToWrap, when;

    timeToWrap = ULONG_MAX - BaseTick;

    Assert( Delay <= TIME_TICK_HALF_RANGE );

    if ( timeToWrap < Delay ) {
        when = Delay - timeToWrap;
    } else {
        when = BaseTick + Delay;
    }

    return when;
} /* AdvanceTickTime */


DWORD
CalculateFutureTickTime(
    IN DWORD Delay
    )

/*++

Routine Description:

Calculate a future time by adding a delay in milliseconds to the
current tick count.  Handles wrap around.

Taken from Davestr's code in rpccancel.c

Tick counts are in milliseconds.

Arguments:

    Delay - time in milliseconds to delay, must be less than HALF RANGE

Return Value:

    DWORD - future time

--*/

{
    return AdvanceTickTime( GetTickCount(), Delay );

} /* CalculateFutureTickTime */


DWORD
DifferenceTickTime(
    DWORD GreaterTick,
    DWORD LesserTick
    )

/*++

Routine Description:

Return the difference between the two tick times.

Note, this is not a general purpose subtraction routine.  It assumes that
the first time is greater than the second time.  Greater as determined by the
CompareTickTime routine, not strictly by numerical ordering because of wrap
around considerations.

Jeffparh wrote:
DifferenceTickTime() is unnecessary.  If you know Tick1 is "later" than Tick2,
and you assume that ULONG_MAX+1 ticks have not transpired since Tick1, then the
tick difference is *always* Tick2 - Tick1, regardless of signs, etc.

Arguments:

    Tick1 - Greater tick time
    Tick2 - Lesser tick time to be subtracted

Return Value:

    DWORD - difference time in milliseconds

--*/

{
    DWORD diff;

    if (GreaterTick == LesserTick) {
        return 0;
    }

    if (GreaterTick > LesserTick) {
        diff = GreaterTick - LesserTick;
    } else {
        diff = ULONG_MAX - LesserTick + GreaterTick;
    }

    Assert( diff < TIME_TICK_HALF_RANGE );

    return diff;
} /* DifferenceTickTime */



int
CompareTickTime(
    DWORD Tick1,
    DWORD Tick2
    )

/*++

Routine Description:

Compare two tick counts. Return <, = or >.  Tick counts can wrap.

It is implicit in this algorithm that this test will be evaluated atleast
every HALF_RANGE, so that the test has a chance to trigger accurately.

Davestr wrote in the original code, rpccancel.c, by way of explanation:

We handle wrap of GetTickCount based on the fact that we
disallow delays of more than 1/2 the GetTickCount wrap
period.  So if timeNow is less than 1/2 the wrap period
later than whenToCancel, cancellation should happen.

Arguments:

    Time1 - 
    Time2 - 

Return Value:

    int - -1 for less t1 < t2, 0 for t1 == t2, +1 for t1 > t2

--*/

{
    if (Tick1 == Tick2) {
        return 0;
    }

    if ( ((Tick1 > Tick2) && ((Tick1 - Tick2) < TIME_TICK_HALF_RANGE)) ||
         ((Tick1 < Tick2) && (((ULONG_MAX - Tick2) + Tick1) < TIME_TICK_HALF_RANGE)) ) {
        return 1;
    }

    return -1;

} /* CompareTickTime */


BOOLEAN
DsaWaitUntilServiceIsRunning(
    CHAR *ServiceName
    )

/*++

Routine Description:

    This routine determines if the specified NT service is in a running
    state or not. It does this by opening the SC manager, then opening the
    specified service, and finally checking its status (for SERVICE_RUNNING).
    When all of these conditions are met, the routine returns, else loops.
    If the service is not configured to be autostarted and it has not been
    started then this function returns immediately with FALSE.

Arguments:

    ServiceName - Pointer, string name of the NT service to interrogate.

Return Value:

    This routine returns a boolean, TRUE meaning that the service is in a
    running state, FALSE meaning that an error occurred and the service
    state cannot be determined.  Use GetLastError() for extended information.


--*/

{
    DWORD   WinError = ERROR_SUCCESS;
    BOOLEAN ServiceStarted = FALSE;
    BOOLEAN AutoStart = FALSE, DemandStart = FALSE;

    SERVICE_STATUS ServiceStatus;
    SC_HANDLE      SCMHandle = NULL;
    SC_HANDLE      ServiceHandle = NULL;
    ULONG          Count = 1;

    LPQUERY_SERVICE_CONFIG AllocServiceConfig = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    QUERY_SERVICE_CONFIG   DummyServiceConfig;
    DWORD                  ServiceConfigSize;

    RtlZeroMemory(&ServiceStatus, sizeof(SERVICE_STATUS));
    RtlZeroMemory(&DummyServiceConfig, sizeof(QUERY_SERVICE_CONFIG));

    __try
    {

        // Attempt to contact the SC manager.

        SCMHandle = OpenSCManager(NULL,   // Computer Name - defaults to local
                                  NULL,   // Database Name - defaults to ServicesActive
                                  SC_MANAGER_CONNECT);

        if (NULL == SCMHandle) {

            // If SCM or the service cannot be contacted, the system
            // is in bad shape, so abort initialization of the service-
            // pieces and return.

            WinError = GetLastError();
            KdPrint(("DS: Cannot open the Service Control Manager, error %lu\n",
                     WinError));
            __leave;
        }

        // KdPrint(("DS: Opened the Service Control Manager\n"));

        // Contact the service.

        ServiceHandle = OpenService(SCMHandle,
                                    ServiceName,
                                    SERVICE_QUERY_STATUS |
                                    SERVICE_INTERROGATE  |
                                    SERVICE_QUERY_CONFIG);

        if (NULL == ServiceHandle) {

            // If SCM or the service cannot be contacted, the system
            // is in bad shape, so abort initialization of the service-
            // pieces and return.

            WinError = GetLastError();
            KdPrint(("DS: Cannot open the %s service, error %lu\n",
                     ServiceName, WinError));
            __leave;
        }

        // KdPrint(("DS: Opened the %s Service\n", ServiceName));

        // Check to see if the service is configured to be autostarted

        if ( QueryServiceConfig(ServiceHandle,
                                &DummyServiceConfig,
                                sizeof(DummyServiceConfig),
                                &ServiceConfigSize )) {

            ServiceConfig = &DummyServiceConfig;

        } else {

            WinError = GetLastError();
            if ( WinError != ERROR_INSUFFICIENT_BUFFER ) {
                KdPrint(("DS: DsaWaitUntilServiceIsRunning - QueryServiceConfig"
                          "failed: %lu\n", WinError));
                __leave;
            }

            AllocServiceConfig = (LPQUERY_SERVICE_CONFIG)
                                 malloc( ServiceConfigSize );

            ServiceConfig = AllocServiceConfig;

            if ( AllocServiceConfig == NULL ) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }

            if ( !QueryServiceConfig(
                    ServiceHandle,
                    ServiceConfig,
                    ServiceConfigSize,
                    &ServiceConfigSize )) {

                WinError = GetLastError();
                KdPrint(("DS: DsaWaitUntilServiceIsRunning: QueryServiceConfig "
                          "failed again: %lu\n", WinError));
                __leave;
            }
            WinError = ERROR_SUCCESS;
        }

        switch ( ServiceConfig->dwStartType ) {
        case SERVICE_AUTO_START :
            AutoStart = TRUE;
            break;
        case SERVICE_DEMAND_START:
            DemandStart = TRUE;
            break;
        }


        // Since the service may not be running at this
        // point of system startup, continue to poll it
        // to find out if it is running.

        do
        {

            if (!QueryServiceStatus(ServiceHandle,
                                   &ServiceStatus))
            {
                WinError = GetLastError();
                KdPrint(("DS: DsaWaitUntilServiceIsRunning: ControlService "
                          "failed: %lu\n", WinError));
                __leave;
            }


            switch (ServiceStatus.dwCurrentState)
            {

                case SERVICE_RUNNING:

                    KdPrint(("%s is running.\n", ServiceName));
                    ServiceStarted = TRUE;
                    break;

                case SERVICE_STOPPED:

                    if ( ServiceStatus.dwWin32ExitCode !=
                         ERROR_SERVICE_NEVER_STARTED ){

                        //
                        // If service failed to start, error out now.
                        //

                        KdPrint(("DS: %s service didn't start: %lu %lx\n",
                                  ServiceName,
                                  ServiceStatus.dwWin32ExitCode,
                                  ServiceStatus.dwWin32ExitCode ));
                        WinError = ServiceStatus.dwWin32ExitCode;

                        if ( ServiceStatus.dwWin32ExitCode ==
                             ERROR_SERVICE_SPECIFIC_ERROR ) {
                            KdPrint((
                                  "DS:\tService specific error code: %lu %lx\n",
                                   ServiceStatus.dwServiceSpecificExitCode,
                                   ServiceStatus.dwServiceSpecificExitCode ));

                            WinError = ServiceStatus.dwServiceSpecificExitCode;
                        }

                        //
                        // If the error code was "SUCCESS", we still want the
                        // caller of this routine to know that the service
                        // is not running.
                        //
                        if ( ERROR_SUCCESS == WinError ) {
                            WinError = ERROR_SERVICE_NOT_ACTIVE;
                        }

                        __leave;

                    }

                    //
                    // At this point the service has not been started for
                    // this boot sequence

                    if ( !(AutoStart || DemandStart) ) {
                        //
                        // Since the service is not auto-start, don't bother
                        // waiting
                        //
                        KdPrint(("DS: %s is not configured to start.\n", ServiceName));
                        WinError = ERROR_SERVICE_NOT_ACTIVE;
                        __leave;
                    }

                    //
                    // If service has never been started on this boot,
                    // and is auto-boot, continue to wait.
                    //

                    break;


                case SERVICE_START_PENDING:

                    //
                    // If service is trying to start up now,
                    // query the service directly to make sure it
                    // is not ready
                    //
                    if (ControlService(ServiceHandle,
                                       SERVICE_CONTROL_INTERROGATE,
                                       &ServiceStatus)
                       && ServiceStatus.dwCurrentState == SERVICE_RUNNING)
                    {
                        ServiceStarted = TRUE;
                    }


                    break;

                default:

                    //
                    // Any other state is bogus during boot time.
                    //
                    KdPrint(("DS: Invalid service state: %lu\n",
                              ServiceStatus.dwCurrentState ));
                    WinError = ERROR_SERVICE_NOT_ACTIVE;
                    __leave;

            } // switch

            // Retry.

            if (ServiceStarted) {
                //
                // This is it! The service has been identified as
                // up and running.
                //
                break;
            }

            if (DemandStart && (Count > DEMAND_START_RETRIES)) {
                // Give up
                KdPrint(("DS: manual start service %s did not start.\n", ServiceName));
                WinError = ERROR_SERVICE_NOT_ACTIVE;
                __leave;
            }

            if (1 == Count)
            {
                KdPrint(("DS: ControlService retrying...\n"));
            }
            else
            {
                KdPrint(("DS: Interrogating the %s service\n", ServiceName));
            }

            Count++;
            Sleep(WAIT_BETWEEN_RETRIES_MS);

        } while(1);

        // KdPrint(("\n"));

    }
    __finally
    {
        if ( SCMHandle != NULL ) {
            (VOID) CloseServiceHandle(SCMHandle);
        }

        if ( ServiceHandle != NULL ) {
            (VOID) CloseServiceHandle(ServiceHandle);
        }

        if ( AllocServiceConfig != NULL ) {
            free( AllocServiceConfig );
        }
    }

    SetLastError(WinError);
    return(ServiceStarted);

}

static const char c_szSysSetupKey[]       ="System\\Setup";
static const char c_szSysSetupValue[]     ="SystemSetupInProgress";

BOOL IsSetupRunning()
{
    LONG    err, cbAnswer;
    HKEY    hKey ;
    DWORD   dwAnswer = 0 ;  // assume setup is not running

    //
    // Open the registry Key and read the setup running value
    //

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       c_szSysSetupKey,
                       0,
                       KEY_READ,
                       &hKey);

    if (ERROR_SUCCESS == err) {
        LONG lSize = sizeof(dwAnswer);
        DWORD dwType;

        err = RegQueryValueEx(hKey,
                              c_szSysSetupValue,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwAnswer,
                              &lSize);
        RegCloseKey(hKey);

        if (ERROR_SUCCESS == err) {

            return(dwAnswer != 0);
        }
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dsevent\dsevent.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsevent.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>
#include <dsevent.h>
#include <dsconfig.h>
#include <mdcodes.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <fileno.h>
#include <drserr.h>
#include <dstrace.h>
#include <debug.h>
#include <dsatools.h>
#include <dsutil.h>
#include <esent.h>

#define  FILENO FILENO_DSEVENT
#define DEBSUB "DSEVENT:"

// Buffer size required to hold an arbitrary stringized base-10 USN value.
// 0xFFFF FFFF FFFF FFFF = 18446744073709551615 = 20 chars + '\0'
#define SZUSN_LEN (24)

// Convenient macro to get array size from bytecount
#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))

DWORD  RaiseAlert(char *szMsg);
DWORD  RaiseAlertW(WCHAR *szMsg);

HANDLE ghMsgFile = NULL;

// Dummy string to insert when the proposed insertion string cannot be
// determined (e.g., failed to read from message file) or represented (e.g.,
// a NULL string).
// ISSUE: Might be good if these were in mdcodes so different dummy strings
// could be used for different languages.
WCHAR gwszDummyString[] = L"[]";
CHAR  gaszDummyString[] =  "[]";

// Maximum length of a DN StringName before we truncate
#define EVENT_MAX_DN_LENGTH 128

// Note, if you update this table, please also update the table of registry
// keys which gets written during installation.  This is found at
// ds\src\ntdsetup\config.c

DS_EVENT_CONFIG DsEventConfig = {
    FALSE,          // fTraceEvents
    FALSE,          // fLogOverride

    // rgEventCategories
    {
        {KCC_CATEGORY,                      0, KCC_KEY},                    // 0
        {SECURITY_CATEGORY,                 0, SECURITY_KEY},               // 1
        {XDS_INTERFACE_CATEGORY,            0, XDS_INTERFACE_KEY},          // 2
        {MAPI_CATEGORY,                     0, MAPI_KEY},                   // 3
        {REPLICATION_CATEGORY,              0, REPLICATION_KEY},            // 4
        {GARBAGE_COLLECTION_CATEGORY,       0, GARBAGE_COLLECTION_KEY},     // 5
        {INTERNAL_CONFIGURATION_CATEGORY,   0, INTERNAL_CONFIGURATION_KEY}, // 6
        {DIRECTORY_ACCESS_CATEGORY,         0, DIRECTORY_ACCESS_KEY},       // 7
        {INTERNAL_PROCESSING_CATEGORY,      0, INTERNAL_PROCESSING_KEY},    // 8
        {PERFORMANCE_CATEGORY,              0, PERFORMANCE_KEY},            // 9
        {STARTUP_SHUTDOWN_CATEGORY,         0, STARTUP_SHUTDOWN_KEY},       // 10
        {SERVICE_CONTROL_CATEGORY,          0, SERVICE_CONTROL_KEY},        // 11
        {NAME_RESOLUTION_CATEGORY,          0, NAME_RESOLUTION_KEY},        // 12
        {BACKUP_CATEGORY,                   0, BACKUP_KEY},                 // 13
        {FIELD_ENGINEERING_CATEGORY,        0, FIELD_ENGINEERING_KEY},      // 14
        {LDAP_INTERFACE_CATEGORY ,          0, LDAP_INTERFACE_KEY },        // 15
        {SETUP_CATEGORY ,                   0, SETUP_KEY },                 // 16
        {GC_CATEGORY ,                      0, GC_KEY },                    // 17
        {ISM_CATEGORY,                      0, ISM_KEY },                   // 18
        {GROUP_CACHING_CATEGORY,            0, GROUP_CACHING_KEY },         // 19
        {LVR_CATEGORY,                      0, LVR_KEY },                   // 20
        {DS_RPC_CLIENT_CATEGORY,            0, DS_RPC_CLIENT_KEY },         // 21
        {DS_RPC_SERVER_CATEGORY,            0, DS_RPC_SERVER_KEY },         // 22
        {DS_SCHEMA_CATEGORY,                0, DS_SCHEMA_KEY }              // 23
    },
    0,
    0,
    0,
    0,
    0
};

DS_EVENT_CONFIG * gpDsEventConfig = &DsEventConfig;

EventSourceMapping rEventSourceMappings[] =
{
    // Any DIRNO_* not listed here will map to NTDS_SOURCE_GENERAL.
    // See pszEventSourceFromFileNo().  NTDS_SOURCE_* are not
    // internationalized.

    //DIRNO_COMMON
    DIRNO_DRA,      pszNtdsSourceReplication,
    DIRNO_DBLAYER,  pszNtdsSourceDatabase,
    DIRNO_SRC,      pszNtdsSourceGeneral,
    DIRNO_NSPIS,    pszNtdsSourceMapi,
    DIRNO_DRS,      pszNtdsSourceReplication,
    DIRNO_XDS,      pszNtdsSourceXds,
    //DIRNO_BOOT
    DIRNO_PERMIT,   pszNtdsSourceSecurity,
    DIRNO_LIBXDS,   pszNtdsSourceXds,
    DIRNO_SAM,      pszNtdsSourceSam,
    DIRNO_LDAP,     pszNtdsSourceLdap,
    DIRNO_SDPROP,   pszNtdsSourceSdprop,
    //DIRNO_TASKQ
    DIRNO_KCC,      pszNtdsSourceKcc,
    DIRNO_ISAM,     pszNtdsSourceIsam,
    DIRNO_ISMSERV,  pszNtdsSourceIsm,
    //DIRNO_PEK
    DIRNO_NTDSETUP, pszNtdsSourceSetup,
    DIRNO_NTDSAPI,  pszNtdsSourceNtdsapi,
    DIRNO_NTDSCRIPT,pszNtdsSourceNtdsScript,
    DIRNO_JETBACK,  pszNtdsSourceJetBack
    // DIRNO_KCCSIM
    // DIRNO_UTIL
    // DIRNO_TEST
    // DIRNO_NETEVENT is handled special in the code
};

DWORD cEventSourceMappings = sizeof(rEventSourceMappings) /
                                        sizeof(rEventSourceMappings[0]);
DWORD iDefaultEventSource = 2;  // DIRNO_SRC / NTDS_SOURCE_GENERAL

DWORD *pdwLogOverrides = NULL;
DWORD cdwLogOverrides = 0;
#define MAX_LOG_OVERRIDES 128

// compute event hash, pHash should point to a 16-byte buffer
VOID
computeEventHash(
    DWORD midEvent,
    DWORD cInserts,
    WCHAR **pwszInserts,
    BYTE* pHash,
    DWORD cbHash)
{
    MD5_CTX md5Ctx;
    DWORD i;
    Assert(cbHash == MD5DIGESTLEN);

    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, (BYTE *) &midEvent, sizeof(midEvent));
    for( i = 0; i < cInserts; i++ ) {
        MD5Update(&md5Ctx, (BYTE *) pwszInserts[i], wcslen(pwszInserts[i]) * sizeof(WCHAR));
    }
    MD5Final(&md5Ctx);

    memcpy(pHash, md5Ctx.digest, MD5DIGESTLEN);
}

CHAR *
pszEventSourceFromFileNo(
    DWORD   fileNo)
{
    DWORD       i, dirNo;
    static  CHAR netEventSource[] = "EventLog";

    // rEventSourceMappings contains DIRNO_*'s which are already left shifted
    // by 8, so we can just mask out the noise bits from the FILENO_*.

    dirNo = fileNo & 0x0000ff00;

    //
    // If we get this, this means that eventlogging is hosed.
    //

    if ( dirNo == DIRNO_NETEVENT ) {
        return netEventSource;
    }

    for ( i = 0; i < cEventSourceMappings; i++ )
    {
        if ( dirNo == rEventSourceMappings[i].dirNo )
        {
            return(rEventSourceMappings[i].pszEventSource);
        }
    }

    return(rEventSourceMappings[iDefaultEventSource].pszEventSource);
}

void __fastcall DoLogUnhandledError(unsigned long ulID, int iErr, int iIncludeName)
{
    char szErr[12];
    char szHexErr[12];
    char szID[9];

    DPRINT3(0,"Unhandled error %d (0x%X) with DSID %X\n", iErr, iErr, ulID);

    _itoa(iErr, szErr, 10);
    _itoa(iErr, szHexErr, 16);
    _ultoa(ulID, szID, 16);
    DoLogEvent(ulID >> 16,
           DsEventConfig.rgEventCategories[DS_EVENT_CAT_INTERNAL_PROCESSING].midCategory,
           DS_EVENT_SEV_ALWAYS,
           DIRLOG_INTERNAL_FAILURE,
           iIncludeName,
           szErr, szHexErr, szID, NULL, NULL, NULL,
           NULL, NULL, 0, NULL);
}

BOOL
DoLogOverride(
        DWORD fileno,
        ULONG sev
        )
{
    DWORD dwTemp, i;
    Assert(DsEventConfig.fLogOverride);

    // make the fileno look like a DSID number, which is the format stored in
    // the overrides.
    fileno = (fileno << 16);

    // Look through our list of overrides.
    for(i=0;i<cdwLogOverrides;i++) {
        Assert(cdwLogOverrides <= MAX_LOG_OVERRIDES);
        Assert(pdwLogOverrides);
        // First, get the directory of the file passed in.
        if((pdwLogOverrides[i] & 0xFF000000) != (fileno & 0xFF000000)) {
            // Not the same directory.
            return FALSE;
        }

        if(((pdwLogOverrides[i] & 0x00FF0000) != 0x00FF0000) &&
           ((pdwLogOverrides[i] & 0x00FF0000) != (fileno & 0x00FF0000))) {
            // Not doing all files and not the correct file
            return FALSE;
        }

        // OK, this file qualifies

        return (sev <= (pdwLogOverrides[i] & 0x0000FFFF));
    }

    return FALSE;
}

BOOL
DoLogEvent(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, int iIncludeName,
    char *arg1, char *arg2, char *arg3, char *arg4,
    char *arg5, char *arg6, char *arg7, char *arg8,
    DWORD cbData, VOID * pvData)
{
    char        *rgszInserts[8] = {NULL, NULL, NULL, NULL, NULL,
                                            NULL, NULL, NULL};
    WORD        cInserts =  0;
    HANDLE      hEventSource;
    BYTE        *pbSid = NULL;
    BOOL        fStatus = FALSE;
    WORD        eventType;

    if (ulSeverity > 5) { /* only five levels of severity */
        return FALSE;
    }

    // set up inserts

    if (arg1) rgszInserts[cInserts++] = arg1;
    if (arg2) rgszInserts[cInserts++] = arg2;
    if (arg3) rgszInserts[cInserts++] = arg3;
    if (arg4) rgszInserts[cInserts++] = arg4;
    if (arg5) rgszInserts[cInserts++] = arg5;
    if (arg6) rgszInserts[cInserts++] = arg6;
    if (arg7) rgszInserts[cInserts++] = arg7;
    if (arg8) rgszInserts[cInserts++] = arg8;

    switch((midEvent >> 30) & 0xFF) {
    case DIR_ETYPE_SECURITY:
        eventType = EVENTLOG_AUDIT_FAILURE;
        break;

    case DIR_ETYPE_WARNING:
        eventType = EVENTLOG_WARNING_TYPE;
        break;

    case DIR_ETYPE_INFORMATIONAL:
        eventType = EVENTLOG_INFORMATION_TYPE;
        break;

    case DIR_ETYPE_ERROR:
    default:
        eventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    //
    // Log the event
    //

    hEventSource = RegisterEventSource(NULL,
                                       pszEventSourceFromFileNo(fileNo));

    if ( hEventSource != NULL ) {

         if (!ReportEvent(
                        hEventSource,
                        eventType,
                        (WORD) midCategory,
                        (DWORD) midEvent,
                        (pbSid = (iIncludeName)?GetCurrentUserSid():0),
                        cInserts,
                        cbData,
                        rgszInserts,
                        pvData) ) {

            DPRINT1(0,"Error %d in ReportEvent\n",GetLastError());

        } else {
            fStatus = TRUE;
        }

        DeregisterEventSource(hEventSource);
    } else {
        DPRINT1(0,"Error %d in RegisterEventSource\n",GetLastError());
    }

    if (pbSid) {
        free(pbSid);
    }

    return fStatus;
}

BOOL
DoLogEventW(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, int iIncludeName,
    WCHAR *arg1, WCHAR *arg2, WCHAR *arg3, WCHAR *arg4,
    WCHAR *arg5, WCHAR *arg6, WCHAR *arg7, WCHAR *arg8,
    DWORD cbData, VOID * pvData)
{
    WCHAR        *rgszInserts[8] = {NULL, NULL, NULL, NULL, NULL,
                                            NULL, NULL, NULL};
    WORD        cInserts =  0;
    HANDLE      hEventSource;
    BYTE        *pbSid = NULL;
    BOOL        fStatus = FALSE;
    WORD        eventType;
    BYTE        rgbEventHash[MD5DIGESTLEN];
    BOOL        fDuplicate;

    if (ulSeverity > 5) { /* only five levels of severity */
        return FALSE;
    }

    // set up inserts

    if (arg1) rgszInserts[cInserts++] = arg1;
    if (arg2) rgszInserts[cInserts++] = arg2;
    if (arg3) rgszInserts[cInserts++] = arg3;
    if (arg4) rgszInserts[cInserts++] = arg4;
    if (arg5) rgszInserts[cInserts++] = arg5;
    if (arg6) rgszInserts[cInserts++] = arg6;
    if (arg7) rgszInserts[cInserts++] = arg7;
    if (arg8) rgszInserts[cInserts++] = arg8;

    switch((midEvent >> 30) & 0xFF) {
    case DIR_ETYPE_SECURITY:
        eventType = EVENTLOG_AUDIT_FAILURE;
        break;

    case DIR_ETYPE_WARNING:
        eventType = EVENTLOG_WARNING_TYPE;
        break;

    case DIR_ETYPE_INFORMATIONAL:
        eventType = EVENTLOG_INFORMATION_TYPE;
        break;

    case DIR_ETYPE_ERROR:
    default:
        eventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    //
    // Duplicate Message Suppression
    //

    computeEventHash( midEvent, cInserts, rgszInserts, rgbEventHash, sizeof(rgbEventHash));

    Assert(DsEventConfig.fCriticalSectionInitialized);

    // Make all calculations and changes to the suppression state atomic
    EnterCriticalSection(&DsEventConfig.csLogEvent);
    __try {
        fDuplicate =
            (0 == memcmp( DsEventConfig.rgbLastEventHash, rgbEventHash, sizeof(rgbEventHash) ));
        if (fDuplicate) {
            DsEventConfig.cSuppressedEvents++;
        } else {
            // The message is not a duplicate. See if there were suppressed messages that
            // need to be summarized.
            if (DsEventConfig.cSuppressedEvents) {
                char szEventId[12];
                char szCount[12];
                // Write the summary event
                // We write this event inside the CS so that no other messages can be
                // logged between it and the preceeding message it refers to.
                _itoa(DsEventConfig.dwSuppressedEventId, szEventId, 16);
                _itoa(DsEventConfig.cSuppressedEvents, szCount, 10);
                DoLogEvent(FILENO_DSEVENT,
                           DsEventConfig.rgEventCategories[DS_EVENT_CAT_INTERNAL_PROCESSING].midCategory,
                           DS_EVENT_SEV_ALWAYS,
                           DIRLOG_DUPLICATE_EVENTS,
                           FALSE, // iIncludeName
                           szEventId, szCount, NULL, NULL, NULL, NULL, NULL, NULL,
                           0, NULL);
                DsEventConfig.cSuppressedEvents = 0;
            }
            // Record the hash for this message
            memcpy( DsEventConfig.rgbLastEventHash, rgbEventHash, sizeof(rgbEventHash) );
            DsEventConfig.dwSuppressedEventId = midEvent;
            Assert( DsEventConfig.cSuppressedEvents == 0 );
        }
    } __finally {
        LeaveCriticalSection(&DsEventConfig.csLogEvent);
    }

    if (fDuplicate) {
        // A duplicate, suppress it. 
        return TRUE;
    }

    //
    // Log the event
    //

    hEventSource = RegisterEventSource(NULL,
                                       pszEventSourceFromFileNo(fileNo));

    if ( hEventSource != NULL ) {

         if (!ReportEventW(
                        hEventSource,
                        eventType,
                        (WORD) midCategory,
                        (DWORD) midEvent,
                        (pbSid = (iIncludeName)?GetCurrentUserSid():0),
                        cInserts,
                        cbData,
                        rgszInserts,
                        pvData) ) {

            DPRINT1(0,"Error %d in ReportEvent\n",GetLastError());

        } else {
            fStatus = TRUE;
        }

        DeregisterEventSource(hEventSource);
    } else {
        DPRINT1(0,"Error %d in RegisterEventSource\n",GetLastError());
    }

    if (pbSid) {
        free(pbSid);
    }

    return fStatus;
}

#if DBG
void
DoDPrintEvent(
    IN  DWORD       fileNo,
    IN  MessageId   midCategory,
    IN  ULONG       ulSeverity,
    IN  MessageId   midEvent,
    IN  int         iIncludeName,
    IN  LPWSTR      arg1,
    IN  LPWSTR      arg2,
    IN  LPWSTR      arg3,
    IN  LPWSTR      arg4,
    IN  LPWSTR      arg5,
    IN  LPWSTR      arg6,
    IN  LPWSTR      arg7,
    IN  LPWSTR      arg8
    )
{
    LPWSTR  rgszInserts[8] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
    DWORD   cInserts =  0;
    DWORD   eventType;
    DWORD   cch, cchMessage = 4096;
    LPWSTR  pszMessage = NULL;
    LPSTR   pszSeverity = NULL;
    LPWSTR  pszCategory = NULL;

    // set up inserts

    if (arg1) rgszInserts[cInserts++] = arg1;
    if (arg2) rgszInserts[cInserts++] = arg2;
    if (arg3) rgszInserts[cInserts++] = arg3;
    if (arg4) rgszInserts[cInserts++] = arg4;
    if (arg5) rgszInserts[cInserts++] = arg5;
    if (arg6) rgszInserts[cInserts++] = arg6;
    if (arg7) rgszInserts[cInserts++] = arg7;
    if (arg8) rgszInserts[cInserts++] = arg8;

    switch((midEvent >> 30) & 0xFF) {
    case DIR_ETYPE_SECURITY:
        pszSeverity = "Audit Failure";
        break;

    case DIR_ETYPE_WARNING:
        pszSeverity = "Warning";
        break;

    case DIR_ETYPE_INFORMATIONAL:
        pszSeverity = "Informational";
        break;

    case DIR_ETYPE_ERROR:
    default:
        pszSeverity = "Error";
        break;
    }

    // Get category name.
    cch = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE
                          | FORMAT_MESSAGE_ALLOCATE_BUFFER
                          | FORMAT_MESSAGE_IGNORE_INSERTS,
                         ghMsgFile,
                         midCategory,
                         0,
                         (LPWSTR) &pszCategory,
                         0,
                         NULL);
    if (0 == cch) {
        DPRINT1(0, "Failed to read category, error %d.\n", GetLastError());
        Assert(NULL == pszCategory);
    } else {
        cch = wcslen(pszCategory);
        if ((cch > 2)
            && (L'\r' == pszCategory[cch-2])
            && (L'\n' == pszCategory[cch-1])) {
            pszCategory[cch-2] = L'\0';
        }
    }
    
    // Get message text (w/ inserts).
    // The bottom line seems to be that ALLOCATE_BUFFER and large strings are incompatible
    // with applications run under the debugger.
/* Neill Clift writes:
FORMAT_MESSAGE_ALLOCATE_BUFFER. doesn't allow arbitrarily large buffers. You have to give it a hint via the size parameter if its over something like 64K.
The code will always raise exceptions internaly. Thats how its coded to work.
Yes I know its crap but thats what the original guys that wrote this did.
I seem to be explaining this over and over again.
The person who coded this probably thought he was being the smartest guy in the world. The code reserves a 64K buffer (or one specified in the size parameter). Only the first part of this buffer is commited.
The code then calls the c run time to put the string into the buffer. This call has a try/except block that looks to see if the exception was an AV for the first uncommitted page in the huge buffer. If it was it commits extra pages and restarts the faulting instruction. This continues until the buffer is exceeded or the string format finishes.
*/

    pszMessage = LocalAlloc(LPTR, cchMessage * sizeof(WCHAR));
    if (pszMessage) {
        cch = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE
                             | FORMAT_MESSAGE_ARGUMENT_ARRAY
                             | 80,   // line width
                             ghMsgFile,
                             midEvent,
                             0,
                             pszMessage,
                             cchMessage,
                             (va_list *) rgszInserts);
        if (0 == cch) {
            DPRINT1(0, "Failed to read message, error %d.\n", GetLastError());
            LocalFree(pszMessage);
            pszMessage = NULL;
        }
    }

    DPRINT4(0, "EVENTLOG (%s): %s / %ls:\n%ls\n\n",
            pszSeverity,
            pszEventSourceFromFileNo(fileNo),
            pszCategory ? pszCategory : L"(Failed to read event category.)",
            pszMessage ? pszMessage : L"Failed to read event text.\n");

    if (pszCategory) {
        LocalFree(pszCategory);
    }

    if (pszMessage) {
        LocalFree(pszMessage);
    }
}
#endif

BOOL
DoAlertEvent(MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, ...)
{
    va_list     args;
    WORD    cMessageInserts =  0;
    char    szMessage[256];
    char    szCategory[256];
    char    szAlertText[1024];
    char    szSeverity[12];

    char    *rgszAlertInserts[3] = {szSeverity, szCategory, szMessage};

    // set up inserts

    va_start(args, midEvent);

    _ultoa(ulSeverity, szSeverity, 10);

    if (FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        (LPVOID) ghMsgFile,
        (DWORD) midEvent,
            0,
        szMessage,
        sizeof(szMessage),
        &args)      &&
    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        (LPVOID) ghMsgFile,
        (DWORD) midCategory,
            0,
        szCategory,
        sizeof(szCategory),
        NULL)           &&
    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        (LPVOID) ghMsgFile,
        (DWORD) ALERT_TEMPLATE,
            0,
        szAlertText,
        sizeof(szAlertText),
        (va_list *)rgszAlertInserts))
    {
        va_end(args);
        RaiseAlert(szAlertText);
        return TRUE;
    }

    va_end(args);
    return FALSE;
}

BOOL
DoAlertEventW(MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, ...)
{
    va_list     args;
    WORD    cMessageInserts =  0;
    WCHAR    szMessage[256];
    WCHAR    szCategory[256];
    WCHAR    szAlertText[1024];
    WCHAR    szSeverity[10];

    WCHAR    *rgszAlertInserts[3] = {szSeverity, szCategory, szMessage};

    // set up inserts

    va_start(args, midEvent);

    _ultow(ulSeverity, szSeverity, 10);

    if (FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE,
        (LPVOID) ghMsgFile,
        (DWORD) midEvent,
            0,
        szMessage,
        ARRAY_SIZE(szMessage),
        &args)      &&
    FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE,
        (LPVOID) ghMsgFile,
        (DWORD) midCategory,
            0,
        szCategory,
        ARRAY_SIZE(szCategory),
        NULL)           &&
    FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        (LPVOID) ghMsgFile,
        (DWORD) ALERT_TEMPLATE,
            0,
        szAlertText,
        ARRAY_SIZE(szAlertText),
        (va_list *)rgszAlertInserts))
    {
        va_end(args);
        RaiseAlertW(szAlertText);
        return TRUE;
    }

    va_end(args);
    return FALSE;
}

HKEY   ghkLoggingKey = NULL;
HANDLE ghevLoggingChange = NULL;

VOID
RegisterLogOverrides (

        )
{
    DWORD index;
    DWORD err;
    ULONG cDsidsList = MAX_LOG_OVERRIDES;
    DWORD * pDsidsList = NULL;

    Assert(ghkLoggingKey);

    // Free up any log overrides we have.
    cdwLogOverrides = 0;
    DsEventConfig.fLogOverride = FALSE;

    pDsidsList = ReadDsidsFromRegistry(ghkLoggingKey,
                                       LOGGING_OVERRIDE_KEY,
                                       TRUE,
                                       &cDsidsList);
    if(pDsidsList == NULL){
        // Note that ReadDsidsFromRegistry() has already logged an
        // event and/or printed out to the debugger.
        return;
    }

    // Parse the buffer for log overrides.
    Assert(!cdwLogOverrides);
    if(!pdwLogOverrides) {
        pdwLogOverrides = malloc(MAX_LOG_OVERRIDES * sizeof(DWORD));
        if(!pdwLogOverrides) {
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_NO_MEMORY_FOR_LOG_OVERRIDES,
                     szInsertUL(MAX_LOG_OVERRIDES * sizeof(DWORD)),
                     NULL,
                     NULL);
            free(pDsidsList);
            return;
        }
    }

    // Copy the DSIDs list into the real array used by the logging mechanism.
    for(index = 0; index < cDsidsList; index++){
        pdwLogOverrides[index] = pDsidsList[index];
    }
    
    free(pDsidsList);

    Assert(pdwLogOverrides);
    // OK, correctly parsed through everything.
    cdwLogOverrides = index;
    DsEventConfig.fLogOverride = TRUE;
    return;
}

void
UnloadEventTable(void)
{
    // Dump out suppressed events, if any
    if (DsEventConfig.cSuppressedEvents) {
        char szEventId[12];
        char szCount[12];
        // Write the summary event
        // We write this event inside the CS so that no other messages can be
        // logged between it and the preceed message it refers to.
        _itoa(DsEventConfig.dwSuppressedEventId, szEventId, 16);
        _itoa(DsEventConfig.cSuppressedEvents, szCount, 10);
        DoLogEvent(FILENO_DSEVENT,
                   DsEventConfig.rgEventCategories[DS_EVENT_CAT_INTERNAL_PROCESSING].midCategory,
                   DS_EVENT_SEV_ALWAYS,
                   DIRLOG_DUPLICATE_EVENTS,
                   FALSE, // iIncludeName
                   szEventId, szCount, NULL, NULL, NULL, NULL, NULL, NULL,
                   0, NULL);
        DsEventConfig.cSuppressedEvents = 0;
    }

    if (ghkLoggingKey) {
        RegCloseKey(ghkLoggingKey);
        ghkLoggingKey = NULL;
    }
    if (ghevLoggingChange) {
        CloseHandle(ghevLoggingChange);
        ghevLoggingChange = NULL;
    }
    if (DsEventConfig.fCriticalSectionInitialized) {
        DeleteCriticalSection(&DsEventConfig.csLogEvent);
        DsEventConfig.fCriticalSectionInitialized = FALSE;
    }
}

HANDLE
LoadEventTable(void)
{
    DWORD dwType, dwSize;
    ULONG i;
    LONG lErr;

    // Do this first. This is needed for LogEventW even if the rest fails.
    if (!DsEventConfig.fCriticalSectionInitialized) {
        __try {
            InitializeCriticalSection(&DsEventConfig.csLogEvent);
            DsEventConfig.fCriticalSectionInitialized = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }
    }
    if (!DsEventConfig.fCriticalSectionInitialized) {
        Assert( !"InitializeCriticalSection failed" );
        return NULL;
    }

    if ( !ghMsgFile ) {
        ghMsgFile = LoadLibrary(DSA_MESSAGE_DLL);

        if ( !ghMsgFile ) {
            DPRINT2(0,"LoadLibrary %s failed with %d\n", DSA_MESSAGE_DLL, GetLastError());
            return(NULL);
        }
    }

    if (!ghkLoggingKey
        && (lErr = RegOpenKey(HKEY_LOCAL_MACHINE,
                              DSA_EVENT_SECTION,
                              &ghkLoggingKey))) {
        DPRINT2(0,"Cannot open %s. Error %d\n", DSA_EVENT_SECTION, lErr);
    }

    if (NULL != ghkLoggingKey) {
        for (i=0; i<DS_EVENT_MAX_CATEGORIES; i++) {
            if ( DsEventConfig.rgEventCategories[i].szRegistryKey ) {
                dwSize = sizeof(DsEventConfig.rgEventCategories[i].ulLevel);
    
                lErr = RegQueryValueEx(
                            ghkLoggingKey,
                            DsEventConfig.rgEventCategories[i].szRegistryKey,
                            NULL,
                            &dwType,
                            (LPBYTE) &(DsEventConfig.rgEventCategories[i].ulLevel),
                            &dwSize);
                if ( lErr != ERROR_SUCCESS ) {
                    //
                    // Maybe it isn't there at all.
                    // Lets try to create it.
                    //
                    DWORD dwVal = 0;
                    (void)RegSetValueEx(
                            ghkLoggingKey,
                            DsEventConfig.rgEventCategories[i].szRegistryKey,
                            0,          // reserved
                            REG_DWORD,
                            (CONST BYTE*) &dwVal,
                            sizeof(dwVal));
                }
            }
        }
    
        // Now, the logging overrides.
        RegisterLogOverrides();
    
#if DBG
        // Now, the assert overrides.
        ReadRegDisabledAsserts(ghkLoggingKey);
#endif

        if (!ghevLoggingChange) {
            ghevLoggingChange = CreateEvent( NULL, TRUE, FALSE, NULL );
            if ( ghevLoggingChange == NULL ) {
                DPRINT1(0,"CreateEvent failed with %d\n",GetLastError());
            }
        }
    
        RegNotifyChangeKeyValue(ghkLoggingKey,
                                TRUE,
                                (   REG_NOTIFY_CHANGE_NAME
                                 | REG_NOTIFY_CHANGE_ATTRIBUTES
                                 | REG_NOTIFY_CHANGE_LAST_SET
                                 ),
                                ghevLoggingChange,
                                TRUE
                                );
    }

    return ghevLoggingChange;
}


LoadParametersCallbackFn pLoadParamFn = NULL;
HKEY   ghkParameterKey = NULL;
HANDLE ghevParameterChange = NULL;

void SetLoadParametersCallback (LoadParametersCallbackFn pFn)
{
    pLoadParamFn = pFn;
}

void UnloadParametersTable(void)
{
    if (ghkLoggingKey) {
        RegCloseKey(ghkLoggingKey);
        ghkLoggingKey = NULL;
    }
    if (ghevParameterChange) {
        CloseHandle(ghevParameterChange);
        ghevParameterChange = NULL;
    }
}


HANDLE LoadParametersTable(void)
{
    DWORD dwType, dwSize;
    ULONG i;
    LONG lErr;

    if (!ghkParameterKey
        && RegOpenKey(HKEY_LOCAL_MACHINE,
                      DSA_CONFIG_SECTION,
                      &ghkParameterKey)) {
        DPRINT2(0,"Cannot open %s. Error %d\n", DSA_EVENT_SECTION, GetLastError());
        return NULL;
    }

    if (pLoadParamFn) {
        (pLoadParamFn)();
    }

    if (!ghevParameterChange) {
        ghevParameterChange = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( ghevParameterChange == NULL ) {
            DPRINT1(0,"CreateEvent failed with %d\n",GetLastError());
        }
    }

    RegNotifyChangeKeyValue(ghkParameterKey,
                            TRUE,
                            (   REG_NOTIFY_CHANGE_NAME
                             | REG_NOTIFY_CHANGE_ATTRIBUTES
                             | REG_NOTIFY_CHANGE_LAST_SET
                             ),
                            ghevParameterChange,
                            TRUE
                            );

    return ghevParameterChange;
}


PSID GetCurrentUserSid()
{
    TOKEN_USER      *ptoken_user = NULL;
    DWORD       dwSize;
    HANDLE      hClientToken = INVALID_HANDLE_VALUE;
    PSID        pSid = NULL;
    DWORD       dwError;

    dwError = ImpersonateAnyClient();

    if (dwError)
        return NULL;

    if (OpenThreadToken(            // Get thread token
        GetCurrentThread(),
        TOKEN_READ,
        TRUE,
        &hClientToken)      &&
    !GetTokenInformation(           // Get size of buffer
        hClientToken,
        TokenUser,
        (LPVOID) NULL,
        0,
        &dwSize)        &&
    (ptoken_user =
        (TOKEN_USER *) LocalAlloc(LPTR,dwSize))     &&
    GetTokenInformation(            // Get user sid
        hClientToken,
        TokenUser,
        (LPVOID) (ptoken_user),
        dwSize,
        &dwSize))
    {
        dwSize = GetLengthSid(ptoken_user->User.Sid);
        if (pSid = (PSID) malloc(dwSize))
            memcpy(pSid, ptoken_user->User.Sid, dwSize);

    }

    if ( INVALID_HANDLE_VALUE != hClientToken )
    {
        CloseHandle(hClientToken);
    }

    UnImpersonateAnyClient();

    if ( ptoken_user != NULL ) {
        LocalFree(ptoken_user);
    }

    return pSid;
}


#define MAX_DS_MSG_STRING   128
#define DSEVENT_MAX_ALLOCS_TO_FREE (8)

typedef LPSTR FN_TH_GET_ERROR_STRING();
typedef void FN_TH_FREE(void *);

VOID
InsertThStateError(
    IN OUT  LPWSTR *    ppszPreAllocatedBuffer,
    IN OUT  DWORD *     pcNumPointersToLocalFree,
    OUT     VOID **     ppPointersToLocalFree,
    OUT     LPWSTR *    ppszInsertionString
    )
/*++

Routine Description:

    Insert the error associated with the current thread state as an insertion
    parameter in an event log entry.

Arguments:

    ppszPreAllocatedBuffer (IN/OUT) - Pointer to pre-allocated buffer to hold
        insertion string.  Buffer must be at least MAX_DS_MSG_STRING
        *characters* long.
    
    pcNumPointersToLocalFree (IN/OUT) - If retrieved message is longer than
        MAX_DS_MSG_STRING (i.e., is too long to fit into pre-allocated buffer),
        on return is incremented.  Otherwise unchanged.
    
    ppPointersToLocalFree (OUT) - If retrieved message is longer than
        MAX_DS_MSG_STRING (i.e., is too long to fit into pre-allocated buffer),
        on return holds a pointer to the message string that must be
        LocalFree()'d when the message is no longer needed.  Otherwise
        unchanged.
    
    ppszInsertionString (OUT) - On return, holds a pointer to the corresponding
        message string (or the dummy string, if the message text could not be
        retrieved).

Return Values:

    None.

--*/
{
    static FN_TH_GET_ERROR_STRING *s_pfnTHGetErrorString = NULL;
    static FN_TH_FREE *s_pfnTHFree = NULL;
    
    LPSTR pszError;
    DWORD cch = 0;

    if ((NULL == s_pfnTHGetErrorString)
        || (NULL == s_pfnTHFree)) {
        // We assume that ntdsa.dll is already loaded by this process, and
        // that we simply need to get a handle to the existing image of the
        // DLL in our address space.  This frees us from having to perform
        // the ref-counted LoadLibrary() and calling FreeLibrary() later.
        HMODULE hNtDsaDll = GetModuleHandle("ntdsa.dll");
        Assert((NULL != hNtDsaDll)
               && "Must statically link to ntdsa.dll to szInsertThStateErrMsg()!");
        
        s_pfnTHGetErrorString
            = (FN_TH_GET_ERROR_STRING *)
                    GetProcAddress(hNtDsaDll, "THGetErrorString");
        s_pfnTHFree
            = (FN_TH_FREE *)
                    GetProcAddress(hNtDsaDll, "THFree");
    }

    if ((NULL != s_pfnTHGetErrorString)
        && (NULL != s_pfnTHFree)) {
        
        pszError = (*s_pfnTHGetErrorString)();

        if (NULL != pszError) {
            cch = MultiByteToWideChar(CP_ACP,
                                      0,
                                      pszError,
                                      -1,
                                      NULL,
                                      0);
            if (cch <= MAX_DS_MSG_STRING) {
                // String will fit in pre-allocated buffer.
                cch = MultiByteToWideChar(CP_ACP,
                                          0,
                                          pszError,
                                          -1,
                                          *ppszPreAllocatedBuffer,
                                          MAX_DS_MSG_STRING);
                
                if (0 != cch) {
                    // Success -- error string placed in pre-allocated buffer.
                    *ppszInsertionString = *ppszPreAllocatedBuffer;
                    *ppszPreAllocatedBuffer += 1 + wcslen(*ppszPreAllocatedBuffer);
                }
            } else {
                LPWSTR pszLocalAllocedBuffer;

                pszLocalAllocedBuffer = LocalAlloc(LPTR, cch * sizeof(WCHAR));
                if (NULL == pszLocalAllocedBuffer) {
                    // No memory.
                    cch = 0;
                } else {
                    cch = MultiByteToWideChar(CP_ACP,
                                              0,
                                              pszError,
                                              -1,
                                              pszLocalAllocedBuffer,
                                              cch);
    
                    if (0 != cch) {
                        // Success -- error string placed in LocalAlloc()'ed buffer.
                        *ppszInsertionString = pszLocalAllocedBuffer;
            
                        Assert(*pcNumPointersToLocalFree < DSEVENT_MAX_ALLOCS_TO_FREE);
                        ppPointersToLocalFree[(*pcNumPointersToLocalFree)++] = pszLocalAllocedBuffer;
                    } else {
                        // Failed to convert string -- why?
                        DPRINT2(0, "Failed to convert TH error string \"%s\", error %d.\n",
                                pszError, GetLastError());
                        Assert(!"Failed to convert TH error string!");
                        LocalFree(pszLocalAllocedBuffer);
                    }
                }
            }

            (*s_pfnTHFree)(pszError);
        }
    }
    
    if (0 == cch) {
        // Failed to read/convert error string.  Insert dummy string.
        *ppszInsertionString = gwszDummyString;
    }
}

VOID
InsertMsgString(
    IN      HMODULE     hMsgFile        OPTIONAL,
    IN      DWORD       dwMsgNum,
    IN OUT  LPWSTR *    ppszPreAllocatedBuffer,
    IN OUT  DWORD *     pcNumPointersToLocalFree,
    OUT     VOID **     ppPointersToLocalFree,
    OUT     LPWSTR *    ppszInsertionString
    )
/*++

Routine Description:

    Reads a message string (correpsonding to e.g. a Win32 error or DS DIRLOG
    code) to be used as an insertion parameter in an event log entry.

Arguments:

    hMsgFile (IN, OPTIONAL) - A handle to the binary containing the message
        resources, or NULL if the system is to be used.
    
    dwMsgNum (IN) - Message number to retrieve.
    
    ppszPreAllocatedBuffer (IN/OUT) - Pointer to pre-allocated buffer to hold
        insertion string.  Buffer must be at least MAX_DS_MSG_STRING
        *characters* long.
    
    pcNumPointersToLocalFree (IN/OUT) - If retrieved message is longer than
        MAX_DS_MSG_STRING (i.e., is too long to fit into pre-allocated buffer),
        on return is incremented.  Otherwise unchanged.
    
    ppPointersToLocalFree (OUT) - If retrieved message is longer than
        MAX_DS_MSG_STRING (i.e., is too long to fit into pre-allocated buffer),
        on return holds a pointer to the message string that must be
        LocalFree()'d when the message is no longer needed.  Otherwise
        unchanged.
    
    ppszInsertionString (OUT) - On return, holds a pointer to the corresponding
        message string (or the dummy string, if the message text could not be
        retrieved).

Return Values:

    None.

--*/
{
    DWORD cch = 0;
    DWORD dwFormatFlags = hMsgFile ? FORMAT_MESSAGE_FROM_HMODULE
                                   : FORMAT_MESSAGE_FROM_SYSTEM;
    
    dwFormatFlags |= FORMAT_MESSAGE_IGNORE_INSERTS;

    cch = FormatMessageW(dwFormatFlags,
                         hMsgFile,
                         dwMsgNum,
                         0,
                         *ppszPreAllocatedBuffer,
                         MAX_DS_MSG_STRING,
                         NULL);
    if (0 != cch) {
        // Success -- message read and placed in pre-allocated buffer.
        *ppszInsertionString = *ppszPreAllocatedBuffer;
        *ppszPreAllocatedBuffer += 1 + wcslen(*ppszPreAllocatedBuffer);
    } else if (ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
        // The pre-allocated buffer wasn't big enough to hold this message;
        // let FormatMessage() allocate a buffer of the appropriate size.
        PWCHAR pBuffer = NULL;

        cch = FormatMessageW(dwFormatFlags | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                             hMsgFile,
                             dwMsgNum,
                             0,
                             (LPWSTR) &pBuffer,
                             0,
                             NULL);

        if (0 != cch) {
            // Success -- message read and placed in LocalAlloc()'ed buffer.
            Assert(NULL != pBuffer);
            *ppszInsertionString = pBuffer;

            Assert(*pcNumPointersToLocalFree < DSEVENT_MAX_ALLOCS_TO_FREE);
            ppPointersToLocalFree[(*pcNumPointersToLocalFree)++] = pBuffer;
        }
    }

    if (0 == cch) {
        // Failed to read message.  Insert dummy string.
        *ppszInsertionString = gwszDummyString;
    } else {
        LPWSTR pwzMsg = *ppszInsertionString;
        Assert( pwzMsg[cch] == L'\0' );
        // Remove trailing control characters, if any
        if (iswcntrl(pwzMsg[cch - 1])) {
            pwzMsg[--cch] = L'\0';
        }
        if (iswcntrl(pwzMsg[cch - 1])) {
            pwzMsg[--cch] = L'\0';
        }
    }
}


typedef JET_ERR (JET_API FN_JET_GET_SYSTEM_PARAMETER)(
    JET_INSTANCE    instance,
    JET_SESID       sesid,
    unsigned long   paramid,
    JET_API_PTR *   plParam,
    char *          sz,
    unsigned long   cbMax
    );

VOID
InsertJetString(
    IN      JET_ERR     jetErrToInsert,
    IN OUT  LPWSTR *    ppszPreAllocatedBuffer,
    OUT     LPWSTR *    ppszInsertionString
    )
/*++

Routine Description:

    Reads a Jet error message string to be used as an insertion parameter in an
    event log entry.

Arguments:

    jetErrToInsert (IN) - Message number to retrieve.
    
    ppszPreAllocatedBuffer (IN/OUT) - Pointer to pre-allocated buffer to hold
        insertion string.  Buffer must be at least MAX_DS_MSG_STRING
        *characters* long.
    
    ppszInsertionString (OUT) - On return, holds a pointer to the corresponding
        message string (or the dummy string, if the message text could not be
        retrieved).

Return Values:

    None.

--*/
{
    static FN_JET_GET_SYSTEM_PARAMETER *s_pfnJetGetSystemParameter = NULL;
    
    DWORD cch = 0;
    CHAR szJetError[MAX_DS_MSG_STRING];

    if (NULL == s_pfnJetGetSystemParameter) {
        // We assume that esent.dll is already loaded by this process, and
        // that we simply need to get a handle to the existing image of the
        // DLL in our address space.  This frees us from having to perform
        // the ref-counted LoadLibrary() and calling FreeLibrary() later.
        HMODULE hEseNtDll = GetModuleHandle("esent.dll");
        Assert((NULL != hEseNtDll)
               && "Must statically link to esent.dll to szInsertJetErrMsg()!");
        
        s_pfnJetGetSystemParameter
            = (FN_JET_GET_SYSTEM_PARAMETER *)
                    GetProcAddress(hEseNtDll, "JetGetSystemParameter");
    }

    if (NULL != s_pfnJetGetSystemParameter) {
        JET_ERR jetErr = (*s_pfnJetGetSystemParameter)(0,
                                                       0,
                                                       JET_paramErrorToString,
                                                       (JET_API_PTR *) &jetErrToInsert,
                                                       szJetError,
                                                       ARRAY_SIZE(szJetError));
        if (JET_errSuccess == jetErr) {
            cch = MultiByteToWideChar(CP_ACP,
                                      0,
                                      szJetError,
                                      -1,
                                      *ppszPreAllocatedBuffer,
                                      MAX_DS_MSG_STRING);
            if (0 != cch) {
                // Success!
                *ppszInsertionString = *ppszPreAllocatedBuffer;
                *ppszPreAllocatedBuffer += 1 + wcslen(*ppszPreAllocatedBuffer);
            }
        }
    }

    if (0 == cch) {
        // Failed to read Jet error text.  Insert dummy string.
        *ppszInsertionString = gwszDummyString;
    }
}


VOID
DoLogEventAndTrace(
    IN PLOG_PARAM_BLOCK LogBlock
    )
{
    const GUID NullGuid = {0};

    PWCHAR   args[8];
    PWCHAR   tofree[DSEVENT_MAX_ALLOCS_TO_FREE];
    DWORD   nAllocs = 0;
    DWORD   len = 0; // This is a count of wchars, not bytes.
    DWORD   i;
    PWCHAR   p;
    PWCHAR   pTmp = NULL;

    ZeroMemory(args, sizeof(args));

    //
    // Get total length of inserts
    //

    for ( i=0; i< LogBlock->nInsert; i++) {

        PINSERT_PARAMS  pParams;
        pParams = &LogBlock->params[i];

        switch (pParams->InsertType) {
        case inSz:
            if (pParams->pInsert) {
                pParams->InsertLen = strlen(pParams->pInsert)+1;
            } else {
                pParams->InsertLen = ARRAY_SIZE(gaszDummyString);
                pParams->pInsert = gaszDummyString;
            }
            len += pParams->InsertLen;
            break;

        case inWCCounted:
            // Note that inSz and inWC assume InsertLen includes the length of the
            // terminator, while this type does not
            len += pParams->InsertLen + 1;
            break;

        case inInt:
            Assert(sizeof(INT) <= 4);
            len += 16;
            break;

        case inHex:
            Assert(sizeof(INT) <= 4);
            len += 10;
            break;

        case inHex64:
            len += 20;
            break;

        case inUL:
            len += 16;
            break;

        case inUSN:
            len += SZUSN_LEN;
            break;

        case inDN: {
            DSNAME *ds;
            ds = (DSNAME*)pParams->pInsert;
            if (ds == NULL) {
                pParams->InsertLen = ARRAY_SIZE(gwszDummyString);
                pParams->pInsert = gwszDummyString;
                pParams->InsertType = inWC;
                len += pParams->InsertLen;
            } else if ( ds->NameLen != 0 ) {
                if (ds->NameLen <= EVENT_MAX_DN_LENGTH) {
                    pParams->InsertLen = ds->NameLen + 1;
                    pParams->InsertType = inWC;
                    len += pParams->InsertLen;
                } else {
                    pParams->InsertLen = EVENT_MAX_DN_LENGTH;
                    pParams->InsertType = inWCCounted;
                    len += pParams->InsertLen + 1;
                }
                pParams->pInsert = ds->StringName;
            } else if (ds->SidLen != 0) {

                pParams->pInsert = (PVOID)ds->Sid.Data;
                pParams->InsertType = inNT4SID;
                len += 128;

            } else if (0 != memcmp(&ds->Guid, &NullGuid, sizeof(GUID))) {

                pParams->pInsert = &ds->Guid;
                pParams->InsertType = inUUID;
                len += 40;

            } else {
                pParams->InsertLen = ARRAY_SIZE(gwszDummyString);
                pParams->pInsert = gwszDummyString;
                pParams->InsertType = inWC;
                len += pParams->InsertLen;
            }
        }
            break;

        case inUUID:
            len += 40;
            break;

        case inDsMsg:
        case inWin32Msg:
        case inJetErrMsg:
        case inDbErrMsg:
        case inThStateErrMsg:
            len += MAX_DS_MSG_STRING;
            break;

        default:
        case inNT4SID:
            Assert(FALSE);
        
        case inWC:
            break;
        }
    }

    pTmp = LocalAlloc(LPTR,len*sizeof(WCHAR));
    if ( pTmp == NULL ) {
        goto exit;
    }

    p = pTmp;
    for ( i=0; i< LogBlock->nInsert; i++) {

        PINSERT_PARAMS  pParams;
        pParams = &LogBlock->params[i];

        switch (pParams->InsertType) {
        case inWC:
            if (pParams->pInsert) {
               args[i] = pParams->pInsert;
               // No space in the temporary array (p) needed
               // Note, InsertLen not read either
            }
            else {
               args[i] = gwszDummyString;
            }
            break;

        case inWCCounted:
            if (pParams->pInsert) {
               args[i] = p;
               memcpy(p, pParams->pInsert, (pParams->InsertLen)*sizeof(WCHAR));
               p += pParams->InsertLen;
               *p++ = L'\0';
            }
            else {
               args[i] = gwszDummyString;
            }
            break;

        case inNT4SID: {

            NTSTATUS    status;
            WCHAR    wzSid[128];
            PSID    sid = (PSID)pParams->pInsert;
            UNICODE_STRING  uniString;

            uniString.MaximumLength = sizeof(wzSid) - sizeof (WCHAR);
            uniString.Length = 0;
            uniString.Buffer = wzSid;

            status = RtlConvertSidToUnicodeString(
                                         &uniString,
                                         sid,
                                         FALSE
                                         );

            if ( status != STATUS_SUCCESS ) {
                args[i] = gwszDummyString;
                break;
            } else {

                int cb = uniString.Length / sizeof (WCHAR);

                wcsncpy(p, uniString.Buffer, cb);
                p[cb] = 0;
                args[i] = p;
                p += (cb + 1);
            
            }
            break;
        }
        case inSz: {

            DWORD cch;
            cch = MultiByteToWideChar(CP_ACP,
                                      0,
                                      (PCHAR)pParams->pInsert,
                                      pParams->InsertLen,
                                      p,
                                      pParams->InsertLen);

            if ( cch == 0 ) {
                args[i] = gwszDummyString;
            } else {
                args[i] = p;
                p += cch;
            }
            break;
        }
        case inInt: {
            INT num = (INT)pParams->tmpDword;
            _itow(num, p, 10);
            args[i] = p;
            p += (wcslen(p)+1);
            break;
        }

        case inHex: {
            INT num = (INT)pParams->tmpDword;
            _itow(num, p, 16);
            args[i] = p;
            p += (wcslen(p)+1);
            break;
        }

        case inHex64: {
            DWORD_PTR num = pParams->tmpDword;
            Assert(sizeof(DWORD_PTR) == sizeof(ULONGLONG));
            _i64tow(num, p, 16);
            args[i] = p;
            p += (wcslen(p)+1);
            break;
        }

        case inUL: {
            DWORD num = (ULONG)pParams->tmpDword;
            _ultow(num, p, 10);
            args[i] = p;
            p += (wcslen(p)+1);
            break;
        }

        case inUSN: {
            LARGE_INTEGER *pli = (LARGE_INTEGER *) pParams->pInsert;
            char pszTemp[SZUSN_LEN];
            DWORD cch;

            // Unfortunately, ntdll.dll doesn't export RtlLargeIntergerToUnicode

            RtlLargeIntegerToChar( pli, 10, SZUSN_LEN, pszTemp);
            cch = MultiByteToWideChar(CP_ACP,
                                      0,
                                      (PCHAR)pszTemp,
                                      strlen(pszTemp) + 1,
                                      p,
                                      SZUSN_LEN);

            if ( cch == 0 ) {
                args[i] = L"0";
            } else {
                args[i] = p;
                p += cch;
            }
            break;
        }

        case inUUID: {
            UUID * pUuid = (UUID*)pParams->pInsert;
            args[i] = DsUuidToStructuredStringCchW(pUuid,p, len - (((ULONG)((BYTE *)p - (BYTE *)pTmp))/sizeof(WCHAR)) );
            p += (wcslen(p)+1);
            break;
        }
        break;

        case inThStateErrMsg:
            InsertThStateError(&p,
                               &nAllocs,
                               tofree,
                               &args[i]);
            break;

        case inDsMsg:
            InsertMsgString(ghMsgFile,
                            (DWORD) pParams->tmpDword,
                            &p,
                            &nAllocs,
                            tofree,
                            &args[i]);
            break;

        case inDbErrMsg:
            InsertMsgString(ghMsgFile,
                            (DWORD) pParams->tmpDword + DIRMSG_DB_success,
                            &p,
                            &nAllocs,
                            tofree,
                            &args[i]);
            break;

        case inWin32Msg:
            InsertMsgString(NULL,
                            (DWORD) pParams->tmpDword,
                            &p,
                            &nAllocs,
                            tofree,
                            &args[i]);
            break;

        case inJetErrMsg:
            InsertJetString((JET_ERR) pParams->tmpDword,
                            &p,
                            &args[i]);
            break;

        default:
            Assert(FALSE);
        }
    }

    if ( LogBlock->fLog ) {

        DoLogEventW(
            LogBlock->fileNo,
            LogBlock->category,
            LogBlock->severity,
            LogBlock->mid,
            LogBlock->fIncludeName,
            args[0],
            args[1],
            args[2],
            args[3],
            args[4],
            args[5],
            args[6],
            args[7],
            LogBlock->cData,
            LogBlock->pData);

#if DBG
        if (DS_EVENT_SEV_ALWAYS == LogBlock->severity) {
            DoDPrintEvent(
                LogBlock->fileNo,
                LogBlock->category,
                LogBlock->severity,
                LogBlock->mid,
                LogBlock->fIncludeName,
                args[0],
                args[1],
                args[2],
                args[3],
                args[4],
                args[5],
                args[6],
                args[7]);
        }
#endif
    }

    if ( LogBlock->traceFlag != 0 ) {
        LogBlock->TraceEvent(
            LogBlock->mid,
            LogBlock->event,
            LogBlock->TraceGuid,
            LogBlock->TraceHeader,
            LogBlock->ClientID,
            args[0],
            args[1],
            args[2],
            args[3],
            args[4],
            args[5],
            args[6],
            args[7]);
    }

    if ( LogBlock->fAlert ) {
        DoAlertEventW(
            LogBlock->category,
            LogBlock->severity,
            LogBlock->mid,
            args[0],
            args[1],
            args[2]
            );
    }

exit:

    //
    // free all allocated buffers
    //

    for (i=0;i<nAllocs;i++) {
        LocalFree(tofree[i]);
    }

    if ( pTmp != NULL ) {
        LocalFree(pTmp);
    }
    return;

} // DoLogEventAndTrace


DS_EVENT_CONFIG *
DsGetEventConfig(void)
// May be exported to in-process, ex-module clients to allow the event logging
// infrastructure to be shared between modules.
{
    return gpDsEventConfig;
}



#define OLDEVENTLOG \
    "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"
#define NEWEVENTLOGPREFIX \
    "SYSTEM\\CurrentControlSet\\Services\\EventLog\\"

#define LOGFILE                         "File"
#define LOGMAXSIZE                      "MaxSize"
#define LOGRETENTION                    "Retention"
#define SOURCECATEGORYCOUNT             "CategoryCount"
#define SOURCECATEGORYMSGFILE           "CategoryMessageFile"
#define SOURCEEVENTMSGFILE              "EventMessageFile"

#define DISPLAYNAMEFILE                 "DisplayNameFile"
#define DISPLAYNAMEFILEVALUE            "%SystemRoot%\\system32\\els.dll"
#define DISPLAYNAMEID                   "DisplayNameID"
#define DISPLAYNAMEIDVALUE              0x00000104

// CustomSD that is used to protect the DS log. It is essentially the default SD
// that is used to protect the custom logs, with "restrict guest access" option.
// The following permission bits are in use:
//      READ=0x1, WRITE=0x2, CLEAR=0x4, BACKUP=0x20
//
// The SD is as follows:     
//  Owner/Group = Local system
//  DACL:
//   Deny:  Full control,       Anonymous
//   Deny:  Full control,       Domain Guests
//   Allow: Full control,       Local system
//   Allow: Read|Clear,         Builtin Admins
//   Allow: Backup,             Backup operators
//   Allow: Read|Clear,         System operators
//   Allow: Read,               Everyone
//   Allow: Write,              Local service
//   Allow: Write,              Network service

#define CUSTOMSD            "CustomSD"
#define CUSTOMSDVALUE       "O:SYG:SYD:(D;;0x27;;;AN)(D;;0x27;;;DG)(A;;0x27;;;SY)(A;;0x5;;;BA)(A;;0x20;;;BO)(A;;0x5;;;SO)(A;;0x1;;;WD)(A;;0x2;;;LS)(A;;0x2;;;NS)"

#define LOGFILEPATH             "%SystemRoot%\\system32\\config\\NTDS.Evt"
#define MESSAGEFILEPATH         "%SystemRoot%\\system32\\" DSA_MESSAGE_DLL
#define MESSAGEFILEPATHESE      "%SystemRoot%\\system32\\" ESE_MESSAGE_DLL

DWORD
InitializeEventLogging()
/*
Description:

    We used to initialize the registry keys for event logging during
    DC installation.  Now we do it (if required) on every startup.  This
    is so that new executables can add new event sources dynamically
    and so that we can nuke the old "NTDS" event source on existing
    systems.

    In the past, all directory service log entries went into the
    "Application Log" under the "NTDS" source.  This code implements
    the DS-specific log "Directory Service" and maps various DIRNO_*
    values to unique event sources so that one can scan the log for
    specific kinds of entries easily - eg: NTDS_Replication.

Arguments:

    None

Return Value:

    ERROR_SUCCESS on success, WIN32 error code otherwise.
*/

{
    LONG    err = ERROR_SUCCESS;
    HKEY    hkey = INVALID_HANDLE_VALUE;
    ULONG   cBytes;
    DWORD   tmpDWORD;
    DWORD   i;
    DWORD   dwType;
    CHAR    *pszTmp=NULL;
    CHAR    *pszNewEventLogName;
    DWORD   dirNo, category;

    pszNewEventLogName = (CHAR *) LocalAlloc(NONZEROLPTR,
                                             1 +
                                             strlen(NEWEVENTLOGPREFIX) +
                                             strlen(pszNtdsEventLogName));
    if (!pszNewEventLogName) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    strcpy(pszNewEventLogName, NEWEVENTLOGPREFIX);
    strcat(pszNewEventLogName, pszNtdsEventLogName);

    // Use do/while/break instead of goto.

    do
    {
        //
        // Add key for new log if required.
        //

        err = RegOpenKey(HKEY_LOCAL_MACHINE, pszNewEventLogName, &hkey);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            err = RegCreateKey(HKEY_LOCAL_MACHINE, pszNewEventLogName, &hkey);
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot create key %s\n",pszNewEventLogName);
            break;
        }

        //
        // Add required values for the new log if they are missing.
        //

        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              LOGFILE,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            err = RegSetValueEx(hkey,
                                LOGFILE,
                                0,
                                REG_EXPAND_SZ,
                                LOGFILEPATH,
                                strlen(LOGFILEPATH) + 1);
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n",LOGFILE);
            break;
        }

        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              LOGMAXSIZE,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            tmpDWORD = 0x80000;

            err = RegSetValueEx(hkey,
                                LOGMAXSIZE,
                                0,
                                REG_DWORD,
                                (PBYTE) &tmpDWORD,
                                sizeof(tmpDWORD));
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n", LOGMAXSIZE);
            break;
        }

        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              LOGRETENTION,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            tmpDWORD = 0;

            err = RegSetValueEx(hkey,
                                LOGRETENTION,
                                0,
                                REG_DWORD,
                                (PBYTE) &tmpDWORD,
                                sizeof(tmpDWORD));
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n",LOGRETENTION);
            break;
        }


        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              DISPLAYNAMEFILE,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            err = RegSetValueEx(hkey,
                                DISPLAYNAMEFILE,
                                0,
                                REG_EXPAND_SZ,
                                DISPLAYNAMEFILEVALUE,
                                strlen(DISPLAYNAMEFILEVALUE) + 1);
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n",DISPLAYNAMEFILE);
            break;
        }

        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              DISPLAYNAMEID,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            tmpDWORD = DISPLAYNAMEIDVALUE;

            err = RegSetValueEx(hkey,
                                DISPLAYNAMEID,
                                0,
                                REG_DWORD,
                                (PBYTE) &tmpDWORD,
                                sizeof(tmpDWORD));
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n",DISPLAYNAMEID);
            break;
        }

        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              CUSTOMSD,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            err = RegSetValueEx(hkey,
                                CUSTOMSD,
                                0,
                                REG_EXPAND_SZ,
                                CUSTOMSDVALUE,
                                strlen(CUSTOMSDVALUE) + 1);
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n",CUSTOMSD);
            break;
        }


        RegCloseKey(hkey);
        hkey = INVALID_HANDLE_VALUE;

        //
        // Determine maximum buffer size required to hold the event source
        // subkey names, then allocate buffer.
        //

        cBytes = 0;

        for ( i = 0; i < cEventSourceMappings; i++ )
        {
            if ( strlen(rEventSourceMappings[i].pszEventSource) > cBytes )
            {
                cBytes = strlen(rEventSourceMappings[i].pszEventSource);
            }
        }

        cBytes += (2 +                              // NULL terminator + '\'
                   strlen(pszNewEventLogName));     // event log key name

        pszTmp = (CHAR *) LocalAlloc(NONZEROLPTR,cBytes);
        
        if (!pszTmp) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Add subkeys for each source and the associated values.
        //

        for ( i = 0; i < cEventSourceMappings; i++ )
        {
            dirNo = rEventSourceMappings[i].dirNo;
            
            strcpy(pszTmp, pszNewEventLogName);
            strcat(pszTmp, "\\");
            strcat(pszTmp, rEventSourceMappings[i].pszEventSource);

            err = RegOpenKey(HKEY_LOCAL_MACHINE, pszTmp, &hkey);

            if ( ERROR_FILE_NOT_FOUND == err )
            {
                err = RegCreateKey(HKEY_LOCAL_MACHINE, pszTmp, &hkey);
            }

            if ( ERROR_SUCCESS != err )
            {
                DPRINT1(0,"Cannot create key %s\n",pszTmp);
                break;
            }

            //
            // Add required values for the event source if they are missing.
            //


            category = (DIRNO_ISAM == dirNo)
                         ? ESE_EVENT_MAX_CATEGORIES
                         : DS_EVENT_MAX_CATEGORIES;

            cBytes = sizeof(tmpDWORD);
            
            err = RegQueryValueEx(hkey,
                                  SOURCECATEGORYCOUNT,
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&tmpDWORD,
                                  &cBytes);

            if (    ERROR_FILE_NOT_FOUND == err
                 || tmpDWORD != category   )
            {
                
                err = RegSetValueEx(hkey,
                                    SOURCECATEGORYCOUNT,
                                    0,
                                    REG_DWORD,
                                    (PBYTE) &category,
                                    sizeof(category));
            }

            if ( ERROR_SUCCESS != err )
            {
                DPRINT1(0,"Cannot set value %s\n",SOURCECATEGORYCOUNT);
                break;
            }

            cBytes = 0;
            err = RegQueryValueEx(hkey,
                                  SOURCECATEGORYMSGFILE,
                                  NULL,
                                  &dwType,
                                  NULL,
                                  &cBytes);

            if ( ERROR_FILE_NOT_FOUND == err )
            {
                err = RegSetValueEx(hkey,
                                    SOURCECATEGORYMSGFILE,
                                    0,
                                    REG_EXPAND_SZ,
                                    (DIRNO_ISAM == dirNo)
                                        ? MESSAGEFILEPATHESE
                                        : MESSAGEFILEPATH,
                                    (DIRNO_ISAM == dirNo)
                                        ? strlen(MESSAGEFILEPATHESE) + 1
                                        : strlen(MESSAGEFILEPATH) + 1);
            }

            if ( ERROR_SUCCESS != err )
            {
                DPRINT1(0,"Cannot set value %s\n",SOURCECATEGORYMSGFILE);
                break;
            }

            cBytes = 0;
            err = RegQueryValueEx(hkey,
                                  SOURCEEVENTMSGFILE,
                                  NULL,
                                  &dwType,
                                  NULL,
                                  &cBytes);

            if ( ERROR_FILE_NOT_FOUND == err )
            {
                err = RegSetValueEx(hkey,
                                    SOURCEEVENTMSGFILE,
                                    0,
                                    REG_EXPAND_SZ,
                                    (DIRNO_ISAM == dirNo)
                                        ? MESSAGEFILEPATHESE
                                        : MESSAGEFILEPATH,
                                    (DIRNO_ISAM == dirNo)
                                        ? strlen(MESSAGEFILEPATHESE) + 1
                                        : strlen(MESSAGEFILEPATH) + 1);
            }

            if ( ERROR_SUCCESS != err )
            {
                DPRINT1(0,"Cannot set value %s\n",SOURCEEVENTMSGFILE);
                break;
            }

            RegCloseKey(hkey);
            hkey = INVALID_HANDLE_VALUE;

        } // for i in cEventSourceMappings

        if ( ERROR_SUCCESS != err )
        {
            break;
        }

        //
        // Remove old NTDS source under Application log if present.
        //

        err = RegOpenKey(HKEY_LOCAL_MACHINE, OLDEVENTLOG, &hkey);

        if ( ERROR_SUCCESS != err )
        {
            DPRINT2(0,"RegOpenKey %s failed with %d\n",OLDEVENTLOG,err);
            break;
        }

        err = RegDeleteKey(hkey, SERVICE_NAME);

        //
        // Ignore delete errors.
        //

        err = ERROR_SUCCESS;

    }
    while ( FALSE );

    if ( INVALID_HANDLE_VALUE != hkey )
    {
        RegCloseKey(hkey);
    }

    if (pszTmp) {
        LocalFree(pszTmp);
    }

    LocalFree(pszNewEventLogName);
        
    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\iislib\pudebug.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

    Module  Name :
        pudebug.c

    Abstract:

        This module defines functions required for
         Debugging and logging messages for a dynamic program.

    Author:
         Murali R. Krishnan ( MuraliK )    10-Sept-1994
         Modified to be moved to common dll in 22-Dec-1994.

    Revisions:
         MuraliK  16-May-1995  Code to load and save debug flags from registry
         MuraliK  16-Nov-1995  Remove DbgPrint (undoc api)
--*/


/************************************************************
 * Include Headers
 ************************************************************/

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
# include <stdio.h>
# include <stdlib.h>
# include <stdarg.h>
# include <string.h>

# include "pudebug.h"


/*************************************************************
 * Global Variables and Default Values
 *************************************************************/

# define MAX_PRINTF_OUTPUT  ( 10240)

# define DEFAULT_DEBUG_FLAGS_VALUE  ( 0)
# define DEBUG_FLAGS_REGISTRY_LOCATION_A   "DebugFlags"


/*************************************************************
 *   Functions
 *************************************************************/

LPDEBUG_PRINTS
  PuCreateDebugPrintsObject(
    IN const char *         pszPrintLabel,
    IN DWORD                dwOutputFlags)
/*++
   This function creates a new DEBUG_PRINTS object for the required
     program.

   Arguments:
      pszPrintLabel     pointer to null-terminated string containing
                         the label for program's debugging output
      dwOutputFlags     DWORD containing the output flags to be used.

   Returns:
       pointer to a new DEBUG_PRINTS object on success.
       Returns NULL on failure.
--*/
{

   LPDEBUG_PRINTS   pDebugPrints;

   pDebugPrints = GlobalAlloc( GPTR, sizeof( DEBUG_PRINTS));

   if ( pDebugPrints != NULL) {

        if ( strlen( pszPrintLabel) < MAX_LABEL_LENGTH) {

            strcpy( pDebugPrints->m_rgchLabel, pszPrintLabel);
        } else {
            strncpy( pDebugPrints->m_rgchLabel,
                     pszPrintLabel, MAX_LABEL_LENGTH - 1);
            pDebugPrints->m_rgchLabel[MAX_LABEL_LENGTH-1] = '\0';
                // terminate string
        }

        memset( pDebugPrints->m_rgchLogFilePath, 0, MAX_PATH);
        memset( pDebugPrints->m_rgchLogFileName, 0, MAX_PATH);

        pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;

        pDebugPrints->m_dwOutputFlags = dwOutputFlags;
        pDebugPrints->m_StdErrHandle  = GetStdHandle( STD_ERROR_HANDLE);
        pDebugPrints->m_fInitialized = TRUE;
    }


   return ( pDebugPrints);
} // PuCreateDebugPrintsObject()




LPDEBUG_PRINTS
  PuDeleteDebugPrintsObject(
    IN OUT LPDEBUG_PRINTS pDebugPrints)
/*++
    This function cleans up the pDebugPrints object and
      frees the allocated memory.

    Arguments:
       pDebugPrints     poitner to the DEBUG_PRINTS object.

    Returns:
        NULL  on  success.
        pDebugPrints() if the deallocation failed.

--*/
{
    if ( pDebugPrints != NULL) {

        DWORD dwError = PuCloseDbgPrintFile( pDebugPrints);

        if ( dwError != NO_ERROR) {

            SetLastError( dwError);
        } else {

            pDebugPrints = GlobalFree( pDebugPrints);
        }
    }

    return ( pDebugPrints);

} // PuDeleteDebugPrintsObject()




VOID
PuSetDbgOutputFlags(
    IN OUT LPDEBUG_PRINTS   pDebugPrints,
    IN DWORD                dwFlags)
{

    if ( pDebugPrints == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
    } else {

        pDebugPrints->m_dwOutputFlags = dwFlags;
    }

    return;
} // PuSetDbgOutputFlags()



DWORD
PuGetDbgOutputFlags(
    IN const LPDEBUG_PRINTS      pDebugPrints)
{
    return ( pDebugPrints != NULL) ? pDebugPrints->m_dwOutputFlags : 0;

} // PuGetDbgOutputFlags()


static DWORD
PuOpenDbgFileLocal(
   IN OUT LPDEBUG_PRINTS pDebugPrints)
{

    if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

        //
        // Silently return as a file handle exists.
        //
        return ( NO_ERROR);
    }

    pDebugPrints->m_LogFileHandle =
                      CreateFile( pDebugPrints->m_rgchLogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

    if ( pDebugPrints->m_LogFileHandle == INVALID_HANDLE_VALUE) {

        CHAR  pchBuffer[1024];
        DWORD dwError = GetLastError();

        _snprintf( pchBuffer,
                   1023,
                  " Critical Error: Unable to Open File %s. Error = %d\n",
                  pDebugPrints->m_rgchLogFileName, dwError);
        pchBuffer[1023] = '\0';
        OutputDebugString( pchBuffer);

        return ( dwError);
    }

    return ( NO_ERROR);
} // PuOpenDbgFileLocal()





DWORD
PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFileName,
   IN const char *            pszPathForFile)
/*++

  Opens a Debugging log file. This function can be called to set path
  and name of the debugging file.

  Arguments:
     pszFileName           pointer to null-terminated string containing
                            the name of the file.

     pszPathForFile        pointer to null-terminated string containing the
                            path for the given file.
                           If NULL, then the old place where dbg files were
                           stored is used or if none,
                           default windows directory will be used.

   Returns:
       Win32 error codes. NO_ERROR on success.

--*/
{

    if ( pszFileName == NULL || pDebugPrints == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }

    //
    //  Setup the Path information. if necessary.
    //

    if ( pszPathForFile != NULL) {

        // Path is being changed.

        if ( strlen( pszPathForFile) < MAX_PATH) {

            strcpy( pDebugPrints->m_rgchLogFilePath, pszPathForFile);
        } else {

            return ( ERROR_INVALID_PARAMETER);
        }
    } else {

        if ( pDebugPrints->m_rgchLogFilePath[0] == '\0' &&  // no old path
            !GetWindowsDirectory( pDebugPrints->m_rgchLogFilePath, MAX_PATH)) {

            //
            //  Unable to get the windows default directory. Use current dir
            //

            strcpy( pDebugPrints->m_rgchLogFilePath, ".");
        }
    }

    //
    // Should need be, we need to create this directory for storing file
    //


    //
    // Form the complete Log File name and open the file.
    //
    if ( (strlen( pszFileName) + strlen( pDebugPrints->m_rgchLogFilePath) + 1)
         >= MAX_PATH) {

        return ( ERROR_NOT_ENOUGH_MEMORY);
    }

    //  form the complete path
    strcpy( pDebugPrints->m_rgchLogFileName, pDebugPrints->m_rgchLogFilePath);

    if ( pDebugPrints->m_rgchLogFileName[ strlen(pDebugPrints->m_rgchLogFileName) - 1]
        != '\\') {
        // Append a \ if necessary
        strcat( pDebugPrints->m_rgchLogFileName, "\\");
    };
    strcat( pDebugPrints->m_rgchLogFileName, pszFileName);

    return  PuOpenDbgFileLocal( pDebugPrints);

} // PuOpenDbgPrintFile()




DWORD
PuReOpenDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
/*++

  This function closes any open log file and reopens a new copy.
  If necessary. It makes a backup copy of the file.

--*/
{

    PuCloseDbgPrintFile( pDebugPrints);      // close any existing file.

    if ( pDebugPrints->m_dwOutputFlags & DbgOutputBackup) {

        // MakeBkupCopy();

        OutputDebugString( " Error: MakeBkupCopy() Not Yet Implemented\n");
    }

    return PuOpenDbgFileLocal( pDebugPrints);

} // PuReOpenDbgPrintFile()




DWORD
PuCloseDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
{
    DWORD dwError = NO_ERROR;

    if ( pDebugPrints == NULL ) {
        dwError = ERROR_INVALID_PARAMETER;
    } else {

        if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

            FlushFileBuffers( pDebugPrints->m_LogFileHandle);

            if ( !CloseHandle( pDebugPrints->m_LogFileHandle)) {

                CHAR pchBuffer[1024];

                dwError = GetLastError();

                _snprintf( pchBuffer,
                           1023,
                           "CloseDbgPrintFile() : CloseHandle( %p) failed."
                           " Error = %d\n",
                           pDebugPrints->m_LogFileHandle,
                           dwError);
                pchBuffer[1023] = '\0';
                OutputDebugString( pchBuffer);
            }

            pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;
        }
    }

    return ( dwError);
} // DEBUG_PRINTS::CloseDbgPrintFile()


VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFilePath,
   IN int                     nLineNum,
   IN const char *            pszFormat,
   ...)
/*++

   Main function that examines the incoming message and prints out a header
    and the message.

--*/
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   char pszOutput[ MAX_PRINTF_OUTPUT + 2];
   LPCSTR pszMsg = "";
   INT  cchOutput;
   INT  cchPrologue;
   va_list argsList;
   DWORD dwErr;


   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      pszFileName = pszFilePath;  // if skipping \\ yields nothing use whole path.
   }

# ifdef _PRINT_REASONS_INCLUDED_

  switch (pr) {

     case PrintError:
        pszMsg = "ERROR: ";
        break;

     case PrintWarning:
        pszMsg = "WARNING: ";
        break;

     case PrintCritical:
        pszMsg = "FATAL ERROR ";
        break;

     case PrintAssertion:
        pszMsg = "ASSERTION Failed ";
        break;

     case PrintLog:
        pfnPrintFunction = &DEBUG_PRINTS::DebugPrintNone;
     default:
        break;

  } /* switch */

# endif // _PRINT_REASONS_INClUDED_

  dwErr = GetLastError();

  // Format the message header

  cchPrologue = _snprintf( pszOutput,
                           MAX_PRINTF_OUTPUT + 1,
                           "%s (%lu)[ %12s : %05d]",
                           pDebugPrints->m_rgchLabel,
                           GetCurrentThreadId(),
                           pszFileName, nLineNum);
  if (-1 == cchPrologue) {
      pszOutput[MAX_PRINTF_OUTPUT+1] = '\0';
      cchPrologue = MAX_PRINTF_OUTPUT;
  }

  // Format the incoming message using vsnprintf() so that the overflows are
  //  captured

  va_start( argsList, pszFormat);

  cchOutput = _vsnprintf( pszOutput + cchPrologue,
                          MAX_PRINTF_OUTPUT - cchPrologue - 1,
                          pszFormat, argsList);
  va_end( argsList);

  //
  // The string length is long, we get back -1.
  //   so we get the string length for partial data.
  //

  if ( cchOutput == -1 ) {

      //
      // terminate the string properly,
      //   since _vsnprintf() does not terminate properly on failure.
      //
      cchOutput = MAX_PRINTF_OUTPUT;
      pszOutput[ cchOutput] = '\0';
  }

  //
  // Send the outputs to respective files.
  //

  if ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) {

      DWORD nBytesWritten;

      ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                         pszOutput,
                         strlen( pszOutput),
                         &nBytesWritten,
                         NULL);
  }

  if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
       pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

      DWORD nBytesWritten;

      //
      // Truncation of log files. Not yet implemented.

      ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                         pszOutput,
                         strlen( pszOutput),
                         &nBytesWritten,
                         NULL);

  }


  if ( pDebugPrints->m_dwOutputFlags & DbgOutputKdb) {

      OutputDebugString( pszOutput);
   }

  SetLastError( dwErr );

  return;

} // PuDbgPrint()



VOID
 PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   )
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   LPCSTR pszMsg = "";
   DWORD dwErr;
   DWORD cbDump;


   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      pszFileName = pszFilePath;
   }

   dwErr = GetLastError();

   // No message header for this dump
   cbDump = strlen( pszDump);

   //
   // Send the outputs to respective files.
   //

   if ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) {

       DWORD nBytesWritten;

       ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                          pszDump,
                          cbDump,
                          &nBytesWritten,
                          NULL);
   }

   if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
        pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

       DWORD nBytesWritten;

       //
       // Truncation of log files. Not yet implemented.

       ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                          pszDump,
                          cbDump,
                          &nBytesWritten,
                          NULL);

   }

   if ( pDebugPrints->m_dwOutputFlags & DbgOutputKdb) {

       OutputDebugString( pszDump);
   }

   SetLastError( dwErr );

  return;
} // PuDbgDump()

//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)
VOID
__cdecl
PuDbgAssertFailed(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum,
    IN const char *               pszExpression,
    IN const char *               pszMessage)
/*++
    This function calls assertion failure and records assertion failure
     in log file.

--*/
{
    CONTEXT context;

    PuDbgCaptureContext( &context );

    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum,
                " Assertion (%s) Failed: %s\n"
                " use !cxr %lx to dump context\n",
                pszExpression,
                pszMessage,
                &context);

    DebugBreak();

    return;
} // PuDbgAssertFailed()
#pragma optimize( "", on )      // restore frame pointer omission (FPO)



VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    )
/*++
  This function generates the current time and prints it out to debugger
   for tracing out the path traversed, if need be.

  Arguments:
      pszFile    pointer to string containing the name of the file
      lineNum    line number within the file where this function is called.

  Returns:
      NO_ERROR always.
--*/
{
    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum,
                " TickCount = %u\n",
                GetTickCount()
                );

    return;
} // PrintOutCurrentTime()




DWORD
PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault)
/*++
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key.
  If there is any error the default value is returned.
--*/
{
    DWORD err;
    DWORD dwDebug = dwDefault;
    DWORD  dwBuffer;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL )
    {
        err = RegQueryValueExA( hkey,
                               DEBUG_FLAGS_REGISTRY_LOCATION_A,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDebug = dwBuffer;
        }
    }

    return dwDebug;
} // PuLoadDebugFlagsFromReg()




DWORD
PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault)
/*++
Description:
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key location in registry.
  If there is any error the default value is returned.

Arguments:
  pszRegKey - pointer to registry key location from where to read the key from
  dwDefault - default values in case the read from registry fails

Returns:
   Newly read value on success
   If there is any error the dwDefault is returned.
--*/
{
    HKEY        hkey = NULL;

    DWORD dwVal = dwDefault;

    DWORD dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  pszRegKey,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hkey);
    if ( dwError == NO_ERROR) {
        dwVal = PuLoadDebugFlagsFromReg( hkey, dwDefault);
        RegCloseKey( hkey);
        hkey = NULL;
    }

    return ( dwVal);
} // PuLoadDebugFlagsFromRegStr()





DWORD
PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg)
/*++
  Saves the debug flags in registry. On failure returns the error code for
   the operation that failed.

--*/
{
    DWORD err;

    if( hkey == NULL ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        err = RegSetValueExA(hkey,
                             DEBUG_FLAGS_REGISTRY_LOCATION_A,
                             0,
                             REG_DWORD,
                             (LPBYTE)&dwDbg,
                             sizeof(dwDbg) );
    }

    return (err);
} // PuSaveDebugFlagsInReg()


//
// Dummy PuDbgCaptureContext(), only used if we're ever built for
// a target processor other than x86 or alpha.
//

VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    )
{
    //
    // This space intentionally left blank.
    //

}   // PuDbgCaptureContext


/****************************** End of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dsdebug\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       debug.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop


#include <nminsert.h>

DWORD  RaiseAlert(char *szMsg);


#include "debug.h"
#define DEBSUB "DEBUG:"

#include <dsconfig.h>
#include <mdcodes.h>
#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <dsevent.h>
#include <ntrtl.h>
#include <dsexcept.h>
#include <fileno.h>
#define  FILENO FILENO_DEBUG

DWORD DbgPageSize=0x1000;

#if DBG

DWORD * pDebugThreadId;

UCHAR     _dbPrintBuf[ 512 ];
UCHAR     _dbOutBuf[512];


BOOL     fProfiling;
BOOL     fEarlyXDS;
BOOL     gfIsConsoleApp = TRUE;
BOOL     fLogOpen = FALSE;

extern  DWORD  * pDebugThreadId;    /*Current thread id  */
#define DEBTH  GetCurrentThreadId() /*The actual thread value*/

// This flag is set to TRUE when we take a normal exit.The atexit routine
// checks this flag and asserts if it isn't set.

DEBUGARG DebugInfo;
BOOL     fProfiling;
BOOL     fEarlyXDS;

//
// from filelog.c in dscommon.lib
//

VOID
DsCloseLogFile(
    VOID
    );

BOOL
DsOpenLogFile(
    IN PCHAR FilePrefix,
    IN PCHAR MiddleName,
    IN BOOL fCheckDSLOGMarker
    );

BOOL
DsPrintLog(
    IN LPSTR    Format,
    ...
    );

static int initialized = 0;

//
// forward references
//

VOID
NonMaskableDprint(
    PCHAR szMsg
    );

VOID
DoAssertToDebugger(
    IN PVOID FailedAssertion,
    IN DWORD dwDSID,
    IN PVOID FileName,
    IN PCHAR Message OPTIONAL
    );

DWORD
InitRegDisabledAsserts(    
    );

DWORD *
ReadDsidsFromRegistry (
    IN      HKEY    hKey,
    IN      PCSTR   pValue,
    IN      BOOL    fLogging,
    IN OUT  ULONG * pnMaxCount
    );

ULONG
GetAssertEntry(
    ASSERT_TABLE   aAssertTable,
    DWORD          dwDSID,
    BOOL           bUseWildcards
    );

ULONG
GetBlankAssertEntry(
    ASSERT_TABLE   aAssertTable,
    DWORD          dwDSID
    );


/*  Debug initialization routine
    This routine reads input from STDIN and initializes the debug structure.
    It reads a list of subsystems to debug and a severity level.
*/

VOID
Debug(
    int argc, 
    char *argv[], 
    PCHAR Module
    )
{

    SYSTEM_INFO SystemInfo;
    CHAR logList[MAX_PATH];
    
    /* Ensure that this function is only visited once */
    if (initialized != 0) {
        // Note: This can happen if Dcpromo aborts and runs again without a reboot
        NonMaskableDprint( "Error! Debugging library initialized more than once\n" );
        return;
    }

    __try {
        InitializeCriticalSection(&DebugInfo.sem);
        initialized = 1;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        initialized = 0;
    }

    if(!initialized) {
        DsaExcept(DSA_MEM_EXCEPTION, 0, 0);
    }

    GetSystemInfo(&SystemInfo);
    DbgPageSize=SystemInfo.dwPageSize;

    /* Setup a pointer to the current thread id */


    // Anticipate no debugging

    fProfiling = FALSE;
    fEarlyXDS = FALSE;
    DebugInfo.severity = 0;
    DebugInfo.threadId = 0;
    strcpy(DebugInfo.DebSubSystems, "*");

    if (argc <= 2) {

        //
        //   Attempt to load debuginfo from registry.
        //

        GetConfigParam(DEBUG_SYSTEMS, DebugInfo.DebSubSystems, sizeof(DebugInfo.DebSubSystems));
        GetConfigParam(DEBUG_SEVERITY, &DebugInfo.severity, sizeof(DebugInfo.severity));
    }

    //
    // See if logging is turned on
    //

    if ( GetConfigParam(DEBUG_LOGGING, logList, sizeof(logList) ) == ERROR_SUCCESS ) {

        //
        // see if this module is in the list
        //

        if ( strstr(logList, Module) != NULL ) {

            EnterCriticalSection(&DebugInfo.sem);
            fLogOpen = DsOpenLogFile("dsprint", Module, FALSE);
            LeaveCriticalSection(&DebugInfo.sem);

            if ( !fLogOpen ) {
                KdPrint(("Unable to open debug log file\n"));
            }
        }
    }

    InitRegDisabledAsserts();

    // If user passed -d, prompt for input.

    while (argc > 1) {
        argc--;
        if(_stricmp(argv[argc], "-p") == 0) {
            /* Profile flag.  Means to stop on a carriage return in the
             * DSA window.
             */
            printf("Profiling flag on.  DSA will shutdown after carriage return in this window.\n");
            fProfiling = TRUE;
        }
        else if(_stricmp(argv[argc], "-x") == 0) {
            /* Early XDS flag.  Means to load the XDS interface at start up,
             * before full installation of the system.  Useful for loading
             * the initial schema.
             */
            printf("Early XDS initialization on.\n");
            fEarlyXDS = TRUE;
        }
        else if (!(_stricmp(argv[argc], "-noconsole"))) {
            gfIsConsoleApp = FALSE;
        }
        else if (!(_stricmp(argv[argc], "-d"))){
            /* A bad result prints all */
            /* prompt and get subsystem list */

            printf("Enter one of the following:  \n"
            "  A list of subsystems to debug (e.g. Sub1: Sub2:).\n"
            "  An asterisk (*) to debug all subsystems.\n"
            "  A (cr) for no debugging.\n");

            DebugInfo.DebSubSystems[0] ='\0';
            if ( gets(DebugInfo.DebSubSystems) == NULL ||
                    strlen( DebugInfo.DebSubSystems ) == 0 )
                    strcpy(DebugInfo.DebSubSystems, "*");

            if (strlen(DebugInfo.DebSubSystems) == 0)     /* default (cr) */
            strcpy(DebugInfo.DebSubSystems, ":");

            /* prompt and get severity level */

            printf("Enter the debug severity level 1 - 5 (low - high).\n"
            "  (A severity of 0 specifies no debugging.)\n");

            /* read the severity level (1 - 5) */

            if (1 != scanf("%hu", &DebugInfo.severity))
            DebugInfo.severity = 5;

            /* Read a thread Id to trace */

            printf("Enter a specific thread to debug.\n"
            "  (A thread ID of 0 specifies DEBUG ALL THREADS.)\n");

            /* read the thread ID to debug */

            if (1 != scanf("%u", &DebugInfo.threadId))
            DebugInfo.threadId = 0;

            /*  to make this thing work with stdin */
            getchar();

            break;
        }
    }

}/*debug*/





/*
**      returns TRUE if a debug message should be printed, false if not.
*/
USHORT DebugTest(USHORT sev, CHAR *debsub)
{
    if( ! initialized ) {
        NonMaskableDprint( "DebugTest called but library is not initialized\n" );
        return FALSE;
    }

    /* level 0 prints should always happen */
    if (sev == 0) {
        return TRUE;
    }

    /* don't print if it's not severe enough */
    if (DebugInfo.severity < sev) {
        return FALSE;
    }

    /* if a subsystem has been specified and this isn't it, quit */
    if (debsub && 
        (0 == strstr(DebugInfo.DebSubSystems, debsub)) &&
        (0 == strstr(DebugInfo.DebSubSystems, "*"))) {
        return FALSE;
    }

    /* if we're only debugging a specific thread and this isn't it, quit */
    if (DebugInfo.threadId != 0 &&
        DebugInfo.threadId != (DEBTH)) {
        return FALSE;
    }

    return TRUE;
}

/*
**      Actual function that does the printf
*/
void
DebPrint(USHORT sev,
     UCHAR * str,
     CHAR * debsub,
     unsigned uLineNo,
     ... )
{
    va_list   argptr;
    DWORD tid = DEBTH;

    // Test for whether output should be printed is now done by the caller
    // using DebugTest()

    if( ! initialized ) {
        NonMaskableDprint( "DebPrint called but library is not initialized\n" );
        return;
    }

    EnterCriticalSection(&DebugInfo.sem);
    __try
    {
        char buffer[512];
        DWORD cchBufferSize = sizeof(buffer);
        char *pBuffer = buffer;
        char *pNewBuffer;
        DWORD cchBufferUsed = 0;
        DWORD cchBufferUsed2;
        BOOL fTryAgainWithLargerBuffer;

        va_start( argptr, uLineNo );

        do {
            if (debsub) {
                _snprintf(pBuffer, cchBufferSize, "<%s%u:%u> ", debsub, tid,
                          uLineNo);
                pBuffer[ cchBufferSize/sizeof(*pBuffer) - 1 ] = 0;
                cchBufferUsed = lstrlenA(pBuffer);
            }
            cchBufferUsed2 = _vsnprintf(pBuffer + cchBufferUsed,
                                        cchBufferSize - cchBufferUsed,
                                        str,
                                        argptr);

            fTryAgainWithLargerBuffer = FALSE;
            if (((DWORD) -1 == cchBufferUsed2) && (cchBufferSize < 64*1024)) {
                // Buffer too small -- try again with bigger buffer.
                if (pBuffer == buffer) {
                    pNewBuffer = malloc(cchBufferSize * 2);
                } else {
                    pNewBuffer = realloc(pBuffer, cchBufferSize * 2);
                }

                if (NULL != pNewBuffer) {
                    cchBufferSize *= 2;
                    pBuffer = pNewBuffer;
                    fTryAgainWithLargerBuffer = TRUE;
                } else {
                    // Deal with what we have.
                    pBuffer[cchBufferSize-2] = '\n';
                    pBuffer[cchBufferSize-1] = '\0';
                }
            }
        } while (fTryAgainWithLargerBuffer);
        
        va_end( argptr );

        if (gfIsConsoleApp) {
            printf("%s", pBuffer);
        }

        if ( fLogOpen ) {

            DsPrintLog("%s", pBuffer);

        } else {
            DbgPrint(pBuffer);
        }

        if (pBuffer != buffer) {
            free(pBuffer);
        }
    }
    __finally
    {
        LeaveCriticalSection(&DebugInfo.sem);
    }

    return;

} // DebPrint

VOID
TerminateDebug(
    VOID
    )
{
    // This function must only be called once
    if( ! initialized ) {
        NonMaskableDprint( "Error! TerminateDebug called multiple times\n" );
        return;
    }
    initialized = 0;

    DsCloseLogFile( );
    DeleteCriticalSection(&(DebugInfo.sem));
} // TerminateDebug

char gDebugAsciiz[256];

char *asciiz(char *var, USHORT len)
{
   if (len < 256){
      memcpy(gDebugAsciiz, var, len);
      gDebugAsciiz[len] = '\0';
      return gDebugAsciiz;
   }
   else{
      strcpy(gDebugAsciiz, "**VAR TOO BIG**");
      return gDebugAsciiz;
   }
}

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// Assert Handling Section
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------

// Psuedo Functions, from the other primary functions below these functions
// can be derived, by setting certain parameters constant.

// Check if the given DSID is a disabled assert.  TRUE for disabled, FALSE 
// otherwise.
#define IsDisabledAssert(dsid)     (ASSERT_DISABLED & GetAssertFlags(DebugInfo.aAssertTable, dsid))

// Returns the flags of the required entry.
#define GetAssertFlags(at, dsid)   (at[GetAssertEntry(at, dsid, TRUE)].dwFlags)



DWORD
DisableAssert(
    DWORD          dwDSID,
    DWORD          dwFlags
    )
/*++

Routine Description:

    This function disables an assert.

Arguments:

    dwDSID - The DSID of the entry to set the flags for.
    dwFlags - The flags to set in the entry.  Note we always set
              the ASSERT_DISABLED flag.

Return Value:

    DWORD - TRUE if successfully added to table, FALSE if not.

--*/
{
    ULONG          i;
    BOOL           bIsPresent;

    // Default disabled flag, always the assert is at least "disabled".
    dwFlags |= ASSERT_DISABLED;

    i = GetBlankAssertEntry(DebugInfo.aAssertTable, dwDSID);

    if(i == ASSERT_TABLE_SIZE){
        DbgPrint( "Disable Assert FAILED!  Maximum number of %d disabled assertions has been reached!\n",
                  ASSERT_TABLE_SIZE );
        return(FALSE);
    }

    DebugInfo.aAssertTable[i].dwDSID = dwDSID;
    DebugInfo.aAssertTable[i].dwFlags = dwFlags;
    DbgPrint( "Disabled Assert at DSID %08x\n", dwDSID);

    return(TRUE);
}


DWORD
ReadRegDisabledAsserts(
    HKEY            hKey
    )
/*++

Routine Description:

    ReadRegDisabledAsserts() takes the kKey of the LOGGING/EVENT section
    of the DSA's registry, and fills the list of disabled asserts from
    there.

Arguments:

    hKey - An open registry key to the LOGGING/EVENT section.

Return Value:

    DWORD - returns 0 if failed, 1 if succeeded.

--*/
{
    ULONG           i;
    DWORD *         pDsids = NULL;
    ULONG           cDsids = ASSERT_TABLE_SIZE;

    DbgPrint( "Loading disabled asserts from registry.\n");

    // First read the DSIDs from the registry.
    pDsids = ReadDsidsFromRegistry(hKey, ASSERT_OVERRIDE_KEY, FALSE, &cDsids);
    if(pDsids == NULL){
        // The error was already printed out by ReadDsidsFromRegistry()
        return(0);
    }

    // Second wipe out all entries in the Assert table that were put there
    // from reading the registry..
    for(i = 0; i < ASSERT_TABLE_SIZE; i++){
        if(DebugInfo.aAssertTable[i].dwFlags & ASSERT_FROM_REGISTRY){
            DbgPrint( "Re-Enabled Assert at DSID %08x (will be redisabled if in registry)\n", 
                      DebugInfo.aAssertTable[i].dwDSID);
            DebugInfo.aAssertTable[i].dwFlags = 0;
        }
    }

    // Finally, insert the new DSIDs into the AssertTable ...
    for (i = 0; i < cDsids; i++) {
        DisableAssert(pDsids[i], ASSERT_FROM_REGISTRY | ASSERT_PRINT);
    }
    
    DbgPrint( "Finished updating disabled asserts from registry.\n");

    if(pDsids) {
        free(pDsids);
    }
    return(1);
}

DWORD
InitRegDisabledAsserts(
    )
/*++

Routine Description:

    This is for other binaries like ism*.dll|exe which don't
    have a watcher on the DSA_EVENT_SECTION like ntdsa does.

Arguments:

Return Value:

    DWORD - returns 0 if failed, 1 if succeeded.

--*/
{
    HKEY      hkDsaEventSec = NULL;
    DWORD     dwRet = 0;

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE,
                      DSA_EVENT_SECTION,
                      &hkDsaEventSec);
    if(dwRet){
        DbgPrint("Cannot open %s.  Error %d\n", DSA_EVENT_SECTION, dwRet);
    } else {
        if(hkDsaEventSec){
            dwRet = ReadRegDisabledAsserts(hkDsaEventSec);
        }
    }
           
    if (hkDsaEventSec) {
        RegCloseKey(hkDsaEventSec);
    }

    return(dwRet);    
}


/*  NonMaskableDprint
    This function can be used to print a message even if the
    debug library itself has not been initialized.
*/
VOID
NonMaskableDprint(
    PCHAR szMsg
    )
{
    if (!gfIsConsoleApp) {
        DbgPrint( szMsg );
    } else {
        __try {
            RaiseAlert( szMsg );
        } __except(1) {
            /* not a major concern */
        };
    }
}


void DoAssert(
    char *           szExp,
    DWORD            dwDSID, 
    char *           szFile
    )
{
    DWORD            i;

    if( ! initialized ) {
        NonMaskableDprint( "DoAssert called but library is not initialized\n" );
        return;
    }

    if (!gfIsConsoleApp) {
        //
        // For the DLL case Assert to Kernel Debugger,
        // as a looping assert will effectively freeze
        // the security system and no debugger can attach
        // either
        //
        DoAssertToDebugger( szExp, dwDSID, szFile, NULL );
    }
    else {

        char szMessage[1024];

        if(IsDisabledAssert(dwDSID)){
            // Just return, no way to print and continue, like we do in
            // the kernel debugger.
            return;
        }

        _snprintf(szMessage, sizeof(szMessage), "DSA assertion failure: \"%s\"\n"
        "File %s line %d\nFor bug reporting purposes, please enter the "
        "debugger (Retry) and record the current call stack.  Also, please "
        "record the last messages in the Application Event Log.\n"
        "Thank you for your support.",
        szExp, szFile, (dwDSID & DSID_MASK_LINE));
        szMessage[ sizeof(szMessage)/sizeof(*szMessage) - 1] = 0;

        __try {
            RaiseAlert(szMessage);
        } __except(1) {
            /* bummer */
        };

        switch(MessageBox(NULL, szMessage, "DSA assertion failure",
            MB_TASKMODAL | MB_ICONSTOP | MB_ABORTRETRYIGNORE | MB_DEFBUTTON2 |
            MB_SETFOREGROUND))
        {
        case IDABORT:
            exit(1);
            break;
        case IDRETRY:
            DebugBreak();
            break;
        case IDIGNORE:
            /* best of luck, you're gonna need it */
            break;
            // case DISABLE:
            // The ToDebugger case has the ability to disable assertions.
            // Call addDisabledAssertion()
            // There is no way to express that at present via the MessageBox.
        }
    }
}


VOID
DoAssertToDebugger(
    IN PVOID FailedAssertion,
    IN DWORD dwDSID,
    IN PVOID FileName,
    IN PCHAR Message OPTIONAL
    )
/*++

Routine Description:

    This is a copy of RtlAssert() from ntos\rtl\assert.c.  This is
    unforntunately required if we want the ability to generate assertions
    from checked DS binaries on a free NT base.  (RtlAssert() is a no-op on
    a free NT base.)

Arguments:

    Same as RtlAssert(), except it takes dwDSID instead of a Line number,
    and the order is a little changed.

Return Values:

    None.

--*/
{
    char Response[ 2 ];
    CONTEXT Context;

    DWORD dwAssertFlags = GetAssertFlags(DebugInfo.aAssertTable, dwDSID);

    while (TRUE) {

        // assert enabled || disabled but printing assert
        if( dwAssertFlags == 0  || dwAssertFlags & ASSERT_PRINT ){
            
            DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: (DSID %08x) %s, line %ld\n",
                      Message ? Message : "",
                      FailedAssertion,
                      dwDSID,
                      FileName,
                      (dwDSID & DSID_MASK_LINE)
                    );
            if( dwAssertFlags & ASSERT_DISABLED ){
                // Assert is disabled, print this is the fact.
                DbgPrint( "***   THIS ASSERT DISABLED\n\n");
            }
        }

        if( dwAssertFlags & ASSERT_DISABLED ){
            // Assert is disabled, just return w/o breaking.
            return;
        }
        
        // There used to be an option to terminate the thread here. It was removed because
        // terminating a thread does not give the thread any opportunity to clean up
        // any resources. Terminating a thread leaves the process in an uncertain state, which
        // can cause later problems which are difficult to debug.  If a thread needs to be
        // stopped, the user can freeze the thread in the debugger.

        DbgPrompt( "\nBreak, Ignore, Disable, or Terminate Process (bidp)? ",
                   Response,
                   sizeof( Response )
                 );
        switch (Response[0]) {
            case 'B':
            case 'b':
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'D':
            case 'd':

                // Disable assert, but continue to print it out.
                if(DisableAssert(dwDSID, ASSERT_PRINT)){
                    // Automatically ignore after disable
                    return;
                }
                // Failed to disable, reprompt
                break;

            case 'P':
            case 'p':
                NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
                break;
            }
        }

    DbgBreakPoint();
    NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
}

#else

#define STUB_STRING  \
    "In order to benefit from having debugging functionality in the " \
    "checked binary you are executing, you must ensure the primary " \
    "debugging binary (ntdsa.dll, or ismserv.exe) is also checked.\n"

//
// Stubs needed for these functions so FREE will build.
//
void DebPrint(USHORT sev, UCHAR * str, CHAR * debsub, unsigned uLineNo, ... )
{ 
    DbgPrint(STUB_STRING);
}
VOID Debug(int argc, char *argv[], PCHAR Module)
{ 
    DbgPrint(STUB_STRING);
}
USHORT DebugTest(USHORT sev, CHAR *debsub)
{ 
    DbgPrint(STUB_STRING);
    return(0);
}
void DoAssert(char * szExp, DWORD dwDSID, char * szFile)
{ 
    DbgPrint(STUB_STRING);
}
DWORD ReadRegDisabledAsserts(HKEY hKey)
{ 
    DbgPrint(STUB_STRING);
    return(1);
}
VOID TerminateDebug(VOID)
{ 
    DbgPrint(STUB_STRING);
}

#endif

DWORD *
ReadDsidsFromRegistry (
    IN      HKEY    hKey,
    IN      PCSTR   pValue,
    IN      BOOL    fLogging,
    IN OUT  ULONG * pnMaxCount
    )
/*++

Routine Description:

    Reads a list of DSIDs from the registry key/value specified.  Must be in the
    non-DBG section, because in addition to telling us what Assert()s not to fire
    it is also used by the dsevent.lib for reading it's list of DSIDs on which
    events not to log.

Arguments:

    hKey - The KEY you want to read from
    pValue - The REG_MULTI_SZ value you want to read, must conform to specific
             format of multiple DSIDs.
    fLogging - To specify whether you just want to DbgPrint() errors or just
               Log and print errors.
    nMaxCount - On the way in, this is the maximum number of DSIDs the caller will
        accept.  On the way out, it's the number of DSIDs we entered into the array
        we returned.

Return Values:

    Returns a malloc'd pointer to an array of DSIDs read out of this key/value.        

--*/
{
    LPBYTE pDsidsBuff = NULL;
    DWORD i, j, index;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    DWORD err;
    DWORD * pdwArrayOfDsids = NULL;


    Assert(hKey);

    if(RegQueryValueEx(hKey,
                       pValue,
                       NULL,
                       &dwType,
                       pDsidsBuff,
                       &dwSize)) {
        // No overrides in the registry.
        return(NULL);
    }

    // The value for this key should be repeated groups of 9 bytes, with bytes
    // 1-8 being hex characters and byte 9 being a NULL (at least one group must
    // be present).  Also, there should be a final NULL.  Verify this.

    if(((dwSize - 1) % 9) ||
       (dwSize < 9)          )        {
        // Size is wrong.  This isn't going to work.
        if(fLogging){
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BAD_CHAR_COUNT_FOR_LOG_OVERRIDES,
                     szInsertSz(DSA_EVENT_SECTION "\\" LOGGING_OVERRIDE_KEY),
                     NULL,
                     NULL);
        } else {
            DbgPrint("Incorrectly formatted DSID list for %s\\%s\n", 
                     DSA_EVENT_SECTION, pValue);
        }
        return(NULL);
    }

    if(dwType != REG_MULTI_SZ) {
        // Uh, this isn't going to work either.
        if(fLogging){
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BAD_CHAR_COUNT_FOR_LOG_OVERRIDES,
                     szInsertSz(DSA_EVENT_SECTION "\\" LOGGING_OVERRIDE_KEY),
                     NULL,
                     NULL);
        } else {
            DbgPrint("Incorrect type (should be REG_MULTI_SZ) for DSID list for %s\\%s\n",
                     DSA_EVENT_SECTION, pValue);
        }
        return(NULL);
    }

    // OK, get the value.
    pDsidsBuff = malloc(dwSize);
    if(!pDsidsBuff) {
        // Oops.
        if(fLogging){
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_NO_MEMORY_FOR_LOG_OVERRIDES,
                     szInsertUL(dwSize),
                     NULL,
                     NULL);
        } else {
            DbgPrint("Out of memory to complete DSID list read operation. Requested %d bytes",
                     dwSize);
        }
        
        return(NULL);
    }

    err = RegQueryValueEx(hKey,
                          pValue,
                          NULL,
                          &dwType,
                          pDsidsBuff,
                          &dwSize);
    if(err) {
        if(fLogging){
            LogUnhandledError(err);
        } else {
            DbgPrint("RegQueryValueEx() returned %d\n", err);
        }
        free(pDsidsBuff);
        return(NULL);
    }

    Assert(dwType == REG_MULTI_SZ);
    Assert((dwSize > 9) && !((dwSize - 1) % 9));
    Assert(!pDsidsBuff[dwSize - 1]);

    // Ignore the NULL on the very end of the string.
    dwSize--;


    // Parse the buffer for log overrides.
    pdwArrayOfDsids = malloc(sizeof(DWORD) * (*pnMaxCount));
    if(pdwArrayOfDsids == NULL){
        // Oops.
        if(fLogging){
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_NO_MEMORY_FOR_LOG_OVERRIDES,
                     szInsertUL(sizeof(DWORD) * (*pnMaxCount)),
                     NULL,
                     NULL);
        } else {
            DbgPrint("Out of memory to complete DSID list read operation. Requested %d bytes",
                     sizeof(DWORD) * (*pnMaxCount));
        }
        
        free(pDsidsBuff);
        return(NULL);
    }

    index = 0;
    for(i=0;i<dwSize;(i += 9)) {
        PCHAR pTemp = &pDsidsBuff[i];

        if(index >= (*pnMaxCount)) {
            // We've done as many as we will do, but there's more buffer.
            if(fLogging){
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_TOO_MANY_OVERRIDES,
                         szInsertUL((*pnMaxCount)),
                         NULL,
                         NULL);
            } else {
                DbgPrint("More than requested max number of DSIDS in DSIDs registry list.\n");
            }

            i = dwSize;
            continue;
        }

        for(j=0;j<8;j++) {
            if(!isxdigit(pTemp[j])) {
                // Invalidly formatted string.  Bail
                free(pDsidsBuff);
                if(fLogging){
                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_BAD_CHAR_FOR_LOG_OVERRIDES,
                             szInsertUL(j),
                             szInsertUL(index),
                             NULL);
                } else {
                    DbgPrint("Invalidly formatted DSIDs, DSIDs are all numeric.\n");
                }
                free(pdwArrayOfDsids);
                return(NULL);
            }
        }
        if(pTemp[8]) {
            free(pDsidsBuff);
            if(fLogging){
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_BAD_CHAR_FOR_LOG_OVERRIDES,
                         szInsertUL(8),
                         szInsertUL(index),
                         NULL);
            } else {
                DbgPrint("Invalidly formatted DSIDs, last DSID char must be NULL.\n");
            }
            free(pdwArrayOfDsids);
            return(NULL);
        }

        pdwArrayOfDsids[index] = strtoul(&pDsidsBuff[i], NULL, 16);
        index++;
    }

    free(pDsidsBuff);

    // OK, correctly parsed through everything.
    (*pnMaxCount) = index;
    return(pdwArrayOfDsids);
}


ULONG
GetAssertEntry(
    ASSERT_TABLE   aAssertTable,
    DWORD          dwDSID,
    BOOL           bUseWildcards
    )
/*++

Routine Description:

    Get the flags relevant to the DSID.  Will use wildcards if bUseWildcards
    is specified, so 01030122 and 01030001 both match 0103FFFF.
    Note: Function is used by both dsexts and ntdsa, must not print.
    
Arguments:

    aAssertTable - Table of DSIDs and Flag pairs.
    dsid - The DSID of the entry to return the index of.

Return Value:

    DWORD - The index of the entry found.  Returns ASSERT_TABLE_SIZE if
            no entry was found.

--*/
{
    ULONG     i;

    // NOTE: This function must have no asserts, because if it did
    // you could go into endless recursion upon an Assert().
    // BAD: Assert(aAssertTable);
    if(aAssertTable == NULL){
        return(0);
    }

    for(i = 0; aAssertTable[i].dwDSID ; i++){

        if(aAssertTable[i].dwFlags == 0){
            // This is a blank entry. skip it.
            continue;
        }

        // An outright match is always a match with or without wildcards.
        if(dwDSID == aAssertTable[i].dwDSID){
            return(i);
        }

        if(bUseWildcards){
            // We want to match wild cards so a DSID of 0403FFFF matchs
            // a DSID of 04030022 and a DSID of 04030154
            
            // If there is DIRNO wildcard, then everything matchs this one.
            if(DSID_MASK_DIRNO == (aAssertTable[i].dwDSID & DSID_MASK_DIRNO)){
                return(i);
            }

            // If there is a FILENO wildcard, only the DIRNO portion need match.
            if( (DSID_MASK_FILENO == (aAssertTable[i].dwDSID & DSID_MASK_FILENO))
                && ( (DSID_MASK_DIRNO & dwDSID) 
                     == (DSID_MASK_DIRNO & aAssertTable[i].dwDSID))
               ){
                return(i);
            }

            // If there is only a LINE wildcard, then the DIRNO and FILENO must match.
            if( (DSID_MASK_LINE == (aAssertTable[i].dwDSID & DSID_MASK_LINE))
                && ( ((DSID_MASK_DIRNO | DSID_MASK_FILENO) & dwDSID)
                     == ((DSID_MASK_DIRNO | DSID_MASK_FILENO) & aAssertTable[i].dwDSID) ) ){
                return(i);
            }
        }

    }

    // No such assert DSID is in the table, we must return the invalid 
    // slough entry.
    return(ASSERT_TABLE_SIZE);
}



ULONG
GetBlankAssertEntry(
    ASSERT_TABLE   aAssertTable,
    DWORD          dwDSID
    )
/*++

Routine Description:

    This get's a blank entry in the aAssertTable.  If a DSID is passed in
    we try to find that entry so we end up with no duplicates.
    Note: Function is used by both dsexts and ntdsa, must not print.

Arguments:

    aAssertTable - the assert table to use so we can support both dsexts/ntdsa
    dsid - The DSID of the entry to return the index of.
           If this parameter is NULL, get the first blank assert entry is returned.

Return Value:

    DWORD - The index of the entry found.  Returns ASSERT_TABLE_SIZE if no blank
            entries were found, because the table was full.
            
--*/
{
    ULONG          i;
    DWORD          dwFlags;
    DWORD          bIsPresent;

    if(aAssertTable == NULL){
        return(ASSERT_TABLE_SIZE);
    }
    
    // First, walk once to see if this DSID is in the table already.
    i = GetAssertEntry(aAssertTable, dwDSID, FALSE);
    if (i != ASSERT_TABLE_SIZE && 
        aAssertTable[i].dwFlags) {
        // This assert/DSID is already disabled in the table, hand
        // back this index so we won't end up with duplicates.
        return(i);
    }
    
    for(i = 0; i < ASSERT_TABLE_SIZE ; i++){
        if(aAssertTable[i].dwDSID == 0 || 
           aAssertTable[i].dwFlags == 0){
            // This is a blank entry
            return(i);
        }
    }

    // return the slough slot, which is an invalid entry (though this space is
    // actually allocated, just in case).
    return(ASSERT_TABLE_SIZE);
}

BOOL
IsValidReadPointer(
        IN PVOID pv,
        IN DWORD cb
        )
{
    BOOL fReturn = TRUE;
    DWORD i;
    UCHAR *pTemp, cTemp;

    if(!cb) {
        // We define a check of 0 bytes to always succeed
        return TRUE;
    }
    
    if(!pv) {
        // We define a check of a NULL pointer to fail unless we were checking
        // for 0 bytes.
        return FALSE;
    }
        
    __try {
        pTemp = (PUCHAR)pv;

        // Check out the last byte.
        cTemp = pTemp[cb - 1];
        
        for(i=0;i<cb;i+=DbgPageSize) {
            cTemp = pTemp[i];
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        fReturn = FALSE;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\dsevent\dslogevt.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

Abstract:

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <winldap.h>
#include <locale.h>

#include <ntdsa.h>
#include <dsevent.h>
#include <dsconfig.h>
#include <dsutil.h>
#include <mdcodes.h>
#include <debug.h>
#include <fileno.h>
#define  FILENO FILENO_DSLOGEVT

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(*(x)))

#define MAX_BUFFERS_TO_FREE (16)

typedef enum {
    INSERT_MACRO_SZ,
    INSERT_MACRO_WC,
    INSERT_MACRO_WC2,
    INSERT_MACRO_INT,
    INSERT_MACRO_HEX,
    INSERT_MACRO_PTR,
    INSERT_MACRO_UL,
    INSERT_MACRO_USN,
    INSERT_MACRO_DN,
    INSERT_MACRO_MTX,
    INSERT_MACRO_UUID,
    INSERT_MACRO_DSMSG,
    INSERT_MACRO_WIN32MSG,
    INSERT_MACRO_JETERRMSG,
    INSERT_MACRO_DBERRMSG,
    INSERT_MACRO_THSTATEERRMSG,
    INSERT_MACRO_LDAPERRMSG,
    INSERT_MACRO_ATTRTYPE,
    INSERT_MACRO_DSTIME,
} INSERT_MACRO_TYPE;

// Needed by dsevent.lib.
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }

HMODULE g_hmodNtdsMsg = NULL;

LPWSTR
Win32ErrToString(
    IN  ULONG   dwMsgId
    )
{
    static WCHAR szError[1024];

    DWORD       cch;

    cch = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
                          | FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         dwMsgId,
                         GetSystemDefaultLangID(),
                         szError,
                         ARRAY_SIZE(szError),
                         NULL);
    if (0 != cch && wcslen(szError) > 2) {
        // Chop off trailing \r\n.
        Assert(L'\r' == szError[wcslen(szError)-2]);
        Assert(L'\n' == szError[wcslen(szError)-1]);
        szError[wcslen(szError)-2] = L'\0';
    }
    else {
        Assert(0 == cch && "Hmmm, we got a win32 error, that was less than 3 chars long!");
        swprintf(szError, L"Can't retrieve message string %d (0x%x), error %d.",
                 dwMsgId, dwMsgId, GetLastError());
    }

    return szError;
}

DWORD
AddHighBitsToNtdsMsgNum(
    IN OUT  DWORD * pdwMsgNum
    )
{
    DWORD err = 0;
    DWORD iTry;
    DWORD cch;

    // Determine actual message number, which includes the severity encoded
    // in the high bits.
    for (iTry = 0; iTry < 4; iTry++) {
        DWORD dwTmpMsgNum = *pdwMsgNum;
        LPWSTR pszMessage;
    
        switch (iTry) {
        case 0:
            dwTmpMsgNum = (dwTmpMsgNum & 0x3FFFFFFF);
            break;
    
        case 1:
            dwTmpMsgNum = (dwTmpMsgNum & 0x3FFFFFFF) | 0x40000000;
            break;
    
        case 2:
            dwTmpMsgNum = (dwTmpMsgNum & 0x3FFFFFFF) | 0x80000000;
            break;
    
        case 3:
            dwTmpMsgNum = (dwTmpMsgNum & 0x3FFFFFFF) | 0xC0000000;
            break;
        }
    
        cch = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE
                              | FORMAT_MESSAGE_ALLOCATE_BUFFER
                              | FORMAT_MESSAGE_IGNORE_INSERTS,
                             g_hmodNtdsMsg,
                             dwTmpMsgNum,
                             GetSystemDefaultLangID(),
                             (LPWSTR) &pszMessage,
                             -1,
                             NULL);
        if (0 != cch) {
            LocalFree(pszMessage);
            *pdwMsgNum = dwTmpMsgNum;
            break;
        } else {
            err = GetLastError();
        }
    }
    
    if (0 == cch) {
        Assert(0 != err);
        printf("Can't retrieve message %d (0x%x), error %d:\n\t%ls\n",
               *pdwMsgNum, *pdwMsgNum, err, Win32ErrToString(err));
    } else {
        err = 0;
    }

    return err;
}

DWORD
InsertParamFromString(
    IN      INSERT_MACRO_TYPE   eInsertMacro,
    IN      LPWSTR              pszValue,
    IN OUT  void ***            pppBuffersToFree,
    OUT     INSERT_PARAMS *     pParam
    )
{
    DWORD err = 0;
    LPWSTR pszNext;

    pParam->InsertType = eInsertMacro;

    switch (eInsertMacro) {
    case INSERT_MACRO_INT:
    case INSERT_MACRO_JETERRMSG:
        // Signed 32-bit int.
        pParam->tmpDword = (ULONG_PTR) wcstol(pszValue, &pszNext, 0);
        if ((pszNext == pszValue) || (L'\0' != *pszNext)) {
            printf("Failed to parse value \"%ls\"; signed 32-bit integer expected.\n",
                   pszValue);
            err = ERROR_INVALID_PARAMETER;
        }
        break;

#ifndef _WIN64
    case INSERT_MACRO_PTR:
#endif
    case INSERT_MACRO_HEX:
    case INSERT_MACRO_UL:
    case INSERT_MACRO_WIN32MSG:
    case INSERT_MACRO_DBERRMSG:
    case INSERT_MACRO_LDAPERRMSG:
        // Unsigned 32-bit int.
        pParam->tmpDword = (ULONG_PTR) wcstoul(pszValue, &pszNext, 0);
        if ((pszNext == pszValue) || (L'\0' != *pszNext)) {
            printf("Failed to parse value \"%ls\"; unsigned 32-bit integer expected.\n",
                   pszValue);
            err = ERROR_INVALID_PARAMETER;
        }
        break;

    case INSERT_MACRO_USN:
        // Signed 64-bit int.
        pParam->tmpDword = (DWORD_PTR) malloc(sizeof(LONGLONG));
        if (NULL == pParam->tmpDword) {
            printf("No memory.\n");
            err = ERROR_OUTOFMEMORY;
        } else {
            DWORD cNumConverted;

            *((*pppBuffersToFree)++) = (void *) pParam->tmpDword;

            if ((pszValue[0] == L'0') && (tolower(pszValue[1]) == L'x')) {
                cNumConverted = swscanf(&pszValue[2], L"%I64x", pParam->tmpDword);
            }
            else {
                cNumConverted = swscanf(pszValue, L"%I64d", pParam->tmpDword);
            }

            if (1 != cNumConverted) {
                printf("Failed to parse value \"%ls\"; signed 64-bit integer expected.\n",
                       pszValue);
                err = ERROR_INVALID_PARAMETER;
            }
        }
        break;

#ifdef _WIN64
    case INSERT_MACRO_PTR:
#endif
    case INSERT_MACRO_DSTIME:
        // Unsigned 64-bit int.
        pParam->tmpDword = (DWORD_PTR) malloc(sizeof(ULONGLONG));
        if (NULL == pParam->tmpDword) {
            printf("No memory.\n");
            err = ERROR_OUTOFMEMORY;
        } else {
            DWORD cNumConverted;

            *((*pppBuffersToFree)++) = (void *) pParam->tmpDword;
            
            if ((pszValue[0] == L'0') && (tolower(pszValue[1]) == L'x')) {
                cNumConverted = swscanf(&pszValue[2], L"%I64x", pParam->tmpDword);
            }
            else {
                cNumConverted = swscanf(pszValue, L"%I64u", pParam->tmpDword);
            }

            if (1 != cNumConverted) {
                printf("Failed to parse value \"%ls\"; unsigned 64-bit integer expected.\n",
                       pszValue);
                err = ERROR_INVALID_PARAMETER;
            }
        }
        break;

    case INSERT_MACRO_DSMSG:
        {
            DWORD dwMsgNum;
            
            dwMsgNum = wcstoul(pszValue, &pszNext, 0);
            if ((pszNext == pszValue) || (L'\0' != *pszNext)) {
                printf("Failed to parse value \"%ls\"; unsigned 32-bit integer expected.\n",
                       pszValue);
                err = ERROR_INVALID_PARAMETER;
            } else {
                err = AddHighBitsToNtdsMsgNum(&dwMsgNum);
                if (0 == err) {
                    pParam->tmpDword = (ULONG_PTR) dwMsgNum;
                }
            }
        }
        break;

    case INSERT_MACRO_WC:
        pParam->tmpDword = (ULONG_PTR) pszValue;
        break;

    case INSERT_MACRO_SZ:
    case INSERT_MACRO_WC2:
    case INSERT_MACRO_DN:
    case INSERT_MACRO_MTX:
    case INSERT_MACRO_UUID:
    case INSERT_MACRO_THSTATEERRMSG:
    case INSERT_MACRO_ATTRTYPE:
    default:
        printf("This tool does not yet support this insertion type.\n");
        err = ERROR_INVALID_PARAMETER;
        break;
    }

    return err;
}

void
InsertType(
    IN      INSERT_PARAMS *     pParam,
    IN OUT  LOG_PARAM_BLOCK &   logBlock,
    IN OUT  void ***            pppBuffersToFree
    )
{
    switch (pParam->InsertType) {
    case INSERT_MACRO_SZ:             szInsertSz((LPSTR) pParam->tmpDword);                             break;
    case INSERT_MACRO_WC:             szInsertWC((LPWSTR) pParam->tmpDword);                            break;
    case INSERT_MACRO_WC2:            szInsertWC2((LPWSTR) pParam->tmpDword, pParam->InsertLen);        break;
    case INSERT_MACRO_INT:            szInsertInt((int) pParam->tmpDword);                              break;
    case INSERT_MACRO_HEX:            szInsertHex((int) pParam->tmpDword);                              break;
    case INSERT_MACRO_PTR:            szInsertPtr(pParam->tmpDword);                                    break;
    case INSERT_MACRO_UL:             szInsertUL((ULONG) pParam->tmpDword);                             break;
    case INSERT_MACRO_USN:            szInsertUSN(*((USN *) pParam->tmpDword));                         break;
    case INSERT_MACRO_DN:             szInsertDN((DSNAME *) pParam->tmpDword);                          break;
    case INSERT_MACRO_MTX:            szInsertMTX((MTX_ADDR *) pParam->tmpDword);                       break;
    case INSERT_MACRO_UUID:           szInsertUUID((UUID *) pParam->tmpDword);                          break;
    case INSERT_MACRO_DSMSG:          szInsertDsMsg((DWORD) pParam->tmpDword);                          break;
    case INSERT_MACRO_WIN32MSG:       szInsertWin32Msg((DWORD) pParam->tmpDword);                       break;
    case INSERT_MACRO_JETERRMSG:      szInsertJetErrMsg((DWORD) pParam->tmpDword);                      break;
    case INSERT_MACRO_DBERRMSG:       szInsertDbErrMsg((DWORD) pParam->tmpDword);                       break;
    case INSERT_MACRO_THSTATEERRMSG:  Assert(!"szInsertThStateErrMsg() not supported by this tool!");   break;
    case INSERT_MACRO_LDAPERRMSG:     szInsertLdapErrMsg((DWORD) pParam->tmpDword);                     break;
    case INSERT_MACRO_ATTRTYPE:       Assert(!"szInsertAttrType() not supported by this tool!");        break;
    case INSERT_MACRO_DSTIME:
        {
            LPSTR pszTime = (LPSTR) malloc(SZDSTIME_LEN);
    
            if (NULL == pszTime) {
                printf("No memory.\n");
                exit(ERROR_OUTOFMEMORY);
            }
            
            *((*pppBuffersToFree)++) = (void *) pszTime;
            
            DSTimeToDisplayStringCch(*((DSTIME *) pParam->tmpDword), pszTime, SZDSTIME_LEN);
        }
        break;
    default:                          Assert(!"Unknown insertion type!");                               break;
    }
}

#define szInsertType(x) InsertType((x), logBlock, &ppBuffersToFree)

int
__cdecl wmain(
    IN  int     argc,
    IN  LPWSTR  argv[]
    )
{
    static struct {
        LPWSTR pszKey;
        LPWSTR pszDescription;
        INSERT_MACRO_TYPE eInsertMacro;
    } rgInsertTypes[] = {
        { L"SZ:",             L"ANSI string.",                          INSERT_MACRO_SZ },
        { L"WC:",             L"Unicode string.",                       INSERT_MACRO_WC },
        { L"WC2:",            L"Counted Unicode string.",               INSERT_MACRO_WC2 },
        { L"INT:",            L"32-bit signed integer.",                INSERT_MACRO_INT },
        { L"HEX:",            L"32-bit unsigned hexadecimal integer.",  INSERT_MACRO_HEX },
        { L"PTR:",            L"Memory pointer.",                       INSERT_MACRO_PTR },
        { L"UL:",             L"32-bit unsigned integer.",              INSERT_MACRO_UL },
        { L"USN:",            L"64-bit signed integer.",                INSERT_MACRO_USN },
        { L"DN:",             L"DSNAME structure.",                     INSERT_MACRO_DN },
        { L"MTX:",            L"MTX_ADDR structure.",                   INSERT_MACRO_MTX },
        { L"UUID:",           L"UUID (aka GUID) structure.",            INSERT_MACRO_UUID },
        { L"DSMSG:",          L"NTDSMSG.DLL message string.",           INSERT_MACRO_DSMSG },
        { L"WIN32MSG:",       L"Win32 error message.",                  INSERT_MACRO_WIN32MSG },
        { L"JETERRMSG:",      L"ESE error message.",                    INSERT_MACRO_JETERRMSG },
        { L"DBERRMSG:",       L"DS database error (DB_ERR) message.",   INSERT_MACRO_DBERRMSG },
        { L"THSTATEERRMSG:",  L"DS thread state error message.",        INSERT_MACRO_THSTATEERRMSG },
        { L"LDAPERRMSG:",     L"LDAP error message.",                   INSERT_MACRO_LDAPERRMSG },
        { L"ATTRTYPE:",       L"DS attribute name.",                    INSERT_MACRO_ATTRTYPE },
        { L"DSTIME:",         L"DSTIME structure.",                     INSERT_MACRO_DSTIME },
    };

    static struct {
        LPWSTR  pszCategory;
        DWORD   dwCategory;
    } rgCategories[] = {
        { L"Knowledge Consistency Checker", DS_EVENT_CAT_KCC },
        { L"Security",                      DS_EVENT_CAT_SECURITY },
        { L"ExDS Interface",                DS_EVENT_CAT_XDS_INTERFACE },
        { L"MAPI Interface",                DS_EVENT_CAT_MAPI },
        { L"Replication",                   DS_EVENT_CAT_REPLICATION },
        { L"Garbage Collection",            DS_EVENT_CAT_GARBAGE_COLLECTION },
        { L"Internal Configuration",        DS_EVENT_CAT_INTERNAL_CONFIGURATION },
        { L"Directory Access",              DS_EVENT_CAT_DIRECTORY_ACCESS },
        { L"Internal Processing",           DS_EVENT_CAT_INTERNAL_PROCESSING },
        { L"Performance",                   DS_EVENT_CAT_PERFORMANCE_MONITOR },
        { L"Initialization/Termination",    DS_EVENT_CAT_STARTUP_SHUTDOWN },
        { L"Service Control",               DS_EVENT_CAT_SERVICE_CONTROL },
        { L"Name Resolution",               DS_EVENT_CAT_NAME_RESOLUTION },
        { L"Backup",                        DS_EVENT_CAT_BACKUP },
        { L"Field Engineering",             DS_EVENT_CAT_FIELD_ENGINEERING },
        { L"LDAP Interface",                DS_EVENT_CAT_LDAP_INTERFACE },
        { L"Setup",                         DS_EVENT_CAT_SETUP },
        { L"Global Catalog",                DS_EVENT_CAT_GLOBAL_CATALOG },
        { L"Inter-Site Messaging",          DS_EVENT_CAT_ISM },
        { L"Group Caching",                 DS_EVENT_CAT_GROUP_CACHING },
        { L"Linked-Value Replication",      DS_EVENT_CAT_LVR },
        { L"DS RPC Client",                 DS_EVENT_CAT_RPC_CLIENT },
        { L"DS RPC Server",                 DS_EVENT_CAT_RPC_SERVER },
    };

    static struct {
        LPWSTR  pszSource;
        DWORD   dwDirNo;
    } rgSources[] = {
        { MAKE_WIDE(pszNtdsSourceReplication),  DIRNO_DRA },
        { MAKE_WIDE(pszNtdsSourceDatabase),     DIRNO_DBLAYER },
        { MAKE_WIDE(pszNtdsSourceGeneral),      DIRNO_SRC },
        { MAKE_WIDE(pszNtdsSourceMapi),         DIRNO_NSPIS },
        { MAKE_WIDE(pszNtdsSourceReplication),  DIRNO_DRS },
        { MAKE_WIDE(pszNtdsSourceXds),          DIRNO_XDS },
        { MAKE_WIDE(pszNtdsSourceSecurity),     DIRNO_PERMIT },
        { MAKE_WIDE(pszNtdsSourceXds),          DIRNO_LIBXDS },
        { MAKE_WIDE(pszNtdsSourceSam),          DIRNO_SAM },
        { MAKE_WIDE(pszNtdsSourceLdap),         DIRNO_LDAP },
        { MAKE_WIDE(pszNtdsSourceSdprop),       DIRNO_SDPROP },
        { MAKE_WIDE(pszNtdsSourceKcc),          DIRNO_KCC },
        { MAKE_WIDE(pszNtdsSourceIsam),         DIRNO_ISAM },
        { MAKE_WIDE(pszNtdsSourceIsm),          DIRNO_ISMSERV },
        { MAKE_WIDE(pszNtdsSourceSetup),        DIRNO_NTDSETUP },
    };

    INSERT_PARAMS rgInsertParams[8] = {
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst1]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst2]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst3]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst4]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst5]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst6]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst7]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst8]" },
    };

    UINT    Codepage;
    char    achCodepage[12] = ".OCP";
    DWORD   err = 0;
    DWORD   dwMsgNum = 0;
    BOOL    fPrintUsage = FALSE;
    DWORD   cNumExplicitSubstStrings = 0;
    int     iArg;
    DWORD   iTry;
    DWORD   iCat;
    DWORD   iSrc;
    DWORD   iInsertType;
    DWORD   cch;
    HANDLE  hevtLoggingLevelChange = NULL;
    DWORD   dwCategory = DS_EVENT_CAT_DIRECTORY_ACCESS;
    DWORD   dwFileNo = FILENO_DSAMAIN;
    void *  rgpBuffersToFree[MAX_BUFFERS_TO_FREE] = {NULL};
    void ** ppBuffersToFree = rgpBuffersToFree;
    DWORD   iBuffer;
    
    // Set locale to the default
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    // Initialize debug library.
    DEBUGINIT(0, NULL, "repadmin");

    __try {
        g_hmodNtdsMsg = LoadLibrary("ntdsmsg.dll");
        if (NULL == g_hmodNtdsMsg) {
            err = GetLastError();
            printf("Can't load ntdsmsg.dll, error %d:\n\t%ls\n.",
                   err, Win32ErrToString(err));
            __leave;
        }
    
        for (iArg = 1; iArg < argc; iArg++) {
            if ((L'/' == argv[iArg][0]) || (L'-' == argv[iArg][0])) {
                // Process command-line option.
                WCHAR *pchColon = wcschr(&argv[iArg][1], L':');
    
                if (NULL == pchColon) {
                    if ((0 == _wcsicmp(&argv[iArg][1], L"?"))
                        || (0 == _wcsicmp(&argv[iArg][1], L"h"))
                        || (0 == _wcsicmp(&argv[iArg][1], L"help"))) {
                        fPrintUsage = TRUE;
                        break;
                    } else {
                        printf("Unknown option, \"%ls\".\n", argv[iArg]);
                        err = ERROR_INVALID_PARAMETER;
                        __leave;
                    }
                } else {
                    DWORD cchKey = (DWORD) (pchColon - argv[iArg]);
                    LPWSTR pszValue = pchColon + 1;
    
                    if ((0 == _wcsnicmp(&argv[iArg][1], L"c:", cchKey))
                        || (0 == _wcsnicmp(&argv[iArg][1], L"cat:", cchKey))
                        || (0 == _wcsnicmp(&argv[iArg][1], L"category:", cchKey))) {
                        
                        for (iCat = 0; iCat < ARRAY_SIZE(rgCategories); iCat++) {
                            if (0 == _wcsicmp(rgCategories[iCat].pszCategory, pszValue)) {
                                dwCategory = rgCategories[iCat].dwCategory;
                                break;
                            }
                        }

                        if (iCat == ARRAY_SIZE(rgCategories)) {
                            printf("Unknown category, \"%ls\".\n", pszValue);
                            err = ERROR_INVALID_PARAMETER;
                            __leave;
                        }
                    } else if ((0 == _wcsnicmp(&argv[iArg][1], L"s:", cchKey))
                               || (0 == _wcsnicmp(&argv[iArg][1], L"src:", cchKey))
                               || (0 == _wcsnicmp(&argv[iArg][1], L"source:", cchKey))) {
                        
                        for (iSrc = 0; iSrc < ARRAY_SIZE(rgSources); iSrc++) {
                            if (0 == _wcsicmp(rgSources[iSrc].pszSource, pszValue)) {
                                dwFileNo = rgSources[iSrc].dwDirNo;
                                break;
                            }
                        }

                        if (iSrc == ARRAY_SIZE(rgSources)) {
                            printf("Unknown source, \"%ls\".\n", pszValue);
                            err = ERROR_INVALID_PARAMETER;
                            __leave;
                        }
                    } else if (cNumExplicitSubstStrings < ARRAY_SIZE(rgInsertParams)) {
                        for (iInsertType = 0;
                             iInsertType < ARRAY_SIZE(rgInsertTypes);
                             iInsertType++) {
                            if (0 == _wcsnicmp(rgInsertTypes[iInsertType].pszKey, &argv[iArg][1], cchKey)) {
                                err = InsertParamFromString(rgInsertTypes[iInsertType].eInsertMacro,
                                                            pszValue,
                                                            &ppBuffersToFree,
                                                            &rgInsertParams[cNumExplicitSubstStrings++]);
                                break;
                            }
                        }

                        if (iInsertType == ARRAY_SIZE(rgInsertTypes)) {
                            printf("Unknown option, \"%ls\".\n", argv[iArg]);
                            err = ERROR_INVALID_PARAMETER;
                        }

                        if (err) {
                            __leave;
                        }
                    } else {
                        printf("Unknown option, \"%ls\".\n", argv[iArg]);
                        err = ERROR_INVALID_PARAMETER;
                        __leave;
                    }
                }
            } else if (0 == dwMsgNum) {
                dwMsgNum = wcstoul(argv[iArg], NULL, 0);
                
                if (0 == dwMsgNum) {
                    printf("Invalid message ID, \"%ls\".\n", argv[iArg]);
                    err = ERROR_INVALID_PARAMETER;
                    __leave;
                }
            } else if (cNumExplicitSubstStrings < ARRAY_SIZE(rgInsertParams)) {
                Assert(INSERT_MACRO_WC == rgInsertParams[cNumExplicitSubstStrings].InsertType);
                rgInsertParams[cNumExplicitSubstStrings++].tmpDword = (ULONG_PTR) argv[iArg];
            } else {
                printf("Unknown argument, \"%ls\".\n", argv[iArg]);
                err = ERROR_INVALID_PARAMETER;
                __leave;
            }
        }
        
        Assert(0 == err);

        if (fPrintUsage) {
            printf("Generates DS event to event log and the console.\n"
                   "\n"
                   "Usage: %ls [/cat:category] [/src:source] msgnum\n"
                   "       [[/syntax:]subst1 [[/syntax:]subst2 [...]]]\n"
                   "\n"
                   "/cat    Specifies a category under which to log the event; defaults to\n"
                   "        Directory Access.\n"
                   "\n"
                   "/src    Specifies a source under which to log the event; defaults to\n"
                   "        NTDS General.\n"
                   "\n"
                   "msgnum  Event number in decimal or hex (if prefixed with \"0x\").\n"
                   "\n"
                   "substN  Substitution string for event; defaults to \"[SubstN]\".\n"
                   "        May be prefixed by one of the syntaxes below, which will be decoded\n"
                   "        from its string representation and then re-encoded using the DS event\n"
                   "        logging infrastructure.  E.g., /Win32Msg:5 would be logged as\n"
                   "        \"Access denied.\"  If no syntax is specified, /WC: is assumed.\n",
                   argv[0]);

            printf("\nValid categories are:\n");
            for (iCat = 0; iCat < ARRAY_SIZE(rgCategories); iCat++) {
                printf("\t%ls\n", rgCategories[iCat].pszCategory);
            }

            printf("\nValid sources are:\n");
            for (iSrc = 0; iSrc < ARRAY_SIZE(rgSources); iSrc++) {
                printf("\t%ls\n", rgSources[iSrc].pszSource);
            }
            
            printf("\nValid syntaxes are:\n");
            for (iInsertType = 0;
                 iInsertType < ARRAY_SIZE(rgInsertTypes);
                 iInsertType++) {
                printf("\t/%-15ls  %ls\n",
                       rgInsertTypes[iInsertType].pszKey,
                       rgInsertTypes[iInsertType].pszDescription);
            }

            printf("\n");
            __leave;
        }

        if (0 == dwMsgNum) {
            printf("No message number given.\n");
            err = ERROR_INVALID_PARAMETER;
            __leave;
        }

        err = AddHighBitsToNtdsMsgNum(&dwMsgNum);
        if (err) {
            __leave;
        }

        hevtLoggingLevelChange = LoadEventTable();

        LogEvent8WithFileNo(dwCategory,
                            DS_EVENT_SEV_ALWAYS,
                            dwMsgNum,
                            szInsertType(&rgInsertParams[0]),
                            szInsertType(&rgInsertParams[1]),
                            szInsertType(&rgInsertParams[2]),
                            szInsertType(&rgInsertParams[3]),
                            szInsertType(&rgInsertParams[4]),
                            szInsertType(&rgInsertParams[5]),
                            szInsertType(&rgInsertParams[6]),
                            szInsertType(&rgInsertParams[7]),
                            dwFileNo);
        printf("\n");
    } __finally {
        for (iBuffer = 0; &rgpBuffersToFree[iBuffer] < ppBuffersToFree; iBuffer++) {
            free(rgpBuffersToFree[iBuffer]);
        }

        if (NULL != hevtLoggingLevelChange) {
            // Event closed by UnloadEventTable() (along with other cleanup).
            UnloadEventTable();
        }

        if (NULL != g_hmodNtdsMsg) {
            FreeLibrary(g_hmodNtdsMsg);
        }

        DEBUGTERM();
    }
    
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\iislib\isplat.cxx ===
/*++

    Copyright (c) 1996  Microsoft Corporation

    Module  Name :
        isplat.cxx

    Abstract:

        This module defines functions for determining platform types

    Author:

        Johnson Apacible    (johnsona)      19-Nov-1996

        Murali Krishnan     (MuraliK)       17-Apr-1997
                   Added CriticalSectionWith SpinCount stuff
--*/

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>

}   // extern "C"


#if DBG
#define IIS_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define IIS_PRINTF( x )
#endif

DECLARE_PLATFORM_TYPE();

typedef
BOOLEAN
(NTAPI *GET_PRODUCT_TYPE)(
            PNT_PRODUCT_TYPE
            );

extern "C"
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        )
/*++

  This function consults the registry and determines the platform type
   for this machine.

  Arguments:

    None

  Returns:
    Platform type

--*/
{
    PLATFORM_TYPE pt;
    LONG result;
    HKEY keyHandle;
    WCHAR productType[30];
    DWORD type;
    BOOL isNt = TRUE;

    OSVERSIONINFO osInfo;

    //
    // See if the platform type has already been discovered.
    //

    if ( g_PlatformType != PtInvalid ) {
        return(g_PlatformType);
    }

    //
    // see if this is win95
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        IIS_PRINTF((buff,"GetVersionEx failed with %d\n",
                    GetLastError()));
    }

    if ( isNt ) {

        HINSTANCE hNtdll;
        NT_PRODUCT_TYPE ntType;
        GET_PRODUCT_TYPE pfnGetProductType;

        //
        // Get the product type from the system
        //

        pt = PtNtWorkstation;
        hNtdll = LoadLibrary("ntdll.dll");
        if ( hNtdll != NULL ) {

            pfnGetProductType = (GET_PRODUCT_TYPE)
                GetProcAddress(hNtdll, "RtlGetNtProductType");

            if ( (pfnGetProductType != NULL) &&
                  pfnGetProductType( &ntType ) ) {

                if ( (ntType == NtProductLanManNt) ||
                     (ntType == NtProductServer) ) {

                    pt = PtNtServer;
                }
            }

            FreeLibrary( hNtdll );
        }

    } else {
        pt = PtWindows95;
    }

    g_PlatformType = pt;
    return(pt);

} // IISGetPlatformType



/************************************************************
 *  Critical Section With Spin Count thunks
 ************************************************************/

typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;


DWORD
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   )
/*++
Description:
  This function fakes setting critical section spin count.
  See IISSetCriticalSectionSpinCount() for details

Returns:
   0 - since we are faking the set of cs with spin count
--*/
{
    UNREFERENCED_PARAMETER( lpCriticalSection);
    UNREFERENCED_PARAMETER( dwSpinCount);

    // For faked critical sections, the previous spin count is just ZERO!
    return (0);
} // FakeSetCriticalSectionSpinCount()


static VOID
LoadNtFunctionPointers(VOID)
/*++
Description:
  This function loads the entry point for SetCriticalSectionSpinCount()
  API from Kernel32.dll. If the entry point is missing, the function
  pointer will point to a fake routine which does nothing. Otherwise,
  it will point to the real function.

  It dynamically loads the kernel32.dll to find the entry ponit and then
  unloads it after getting the address. For the resulting function
  pointer to work correctly one has to ensure that the kernel32.dll is
  linked with the dll/exe which links to this file.
--*/
{
    if ( g_pfnSetCSSpinCount == NULL ) {

        HINSTANCE tmpInstance;

        //
        // load kernel32 and get NT specific entry points
        //

        tmpInstance = LoadLibrary("kernel32.dll");
        if ( tmpInstance != NULL ) {

            g_pfnSetCSSpinCount = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT )
                GetProcAddress( tmpInstance, "SetCriticalSectionSpinCount");

            //
            // We can free this because we are statically linked to it
            //

            FreeLibrary(tmpInstance);
        }
        
        if ( g_pfnSetCSSpinCount == NULL ) {
            // the set CS Spincount function is not availble.
            //  Just thunk it.
            g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;
        }
    }

    return;
} // LoadNtFunctionPointers()


extern "C"
DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   )
/*++
Description:
  This function is used to call the appropriate underlying functions to
   set the spin count for the supplied critical section.
  The original function is supposed to be exported out of kernel32.dll from NT
  4.0 SP3. If the func is not available from the dll, we will use a fake
  function.

Arguments:
  lpCriticalSection
      Points to the critical section object.

  dwSpinCount
      Supplies the spin count for the critical section object. For UP systems,
      the spin count is ignored and the critical section spin
      count is set to 0. For MP systems, if contention occurs, instead of
      waiting on a semaphore associated with the critical section,
      the calling thread will spin for spin count iterations before doing the
      hard wait. If the critical section becomes free during the spin,
      a wait is avoided.

Returns:
   The previous spin count for the critical section is returned.
--*/
{
    return ( SetCriticalSectionSpinCount( lpCriticalSection, dwSpinCount));

} // IISSetCriticalSectionSpinCount()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\iislib\stktrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.h

Abstract:

    This module contains public declarations and definitions for capturing
    stack back traces.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _STKTRACE_H_
#define _STKTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _STKTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\iislib\reftrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.c

Abstract:

    This module implements a reference count tracing facility.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>
#include <reftrace.h>
#include <stktrace.h>



PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
/*++

Routine Description:

    Creates a new (empty) ref count trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    return CreateTraceLog(
               LogSize,
               ExtraBytesInHeader,
               sizeof(REF_TRACE_LOG_ENTRY)
               );

}   // CreateRefTraceLog


VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a ref count trace log buffer created with CreateRefTraceLog().

Arguments:

    Log - The ref count trace log buffer to destroy.

Return Value:

    None.

--*/
{

    DestroyTraceLog( Log );

}   // DestroyRefTraceLog


//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

VOID
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    )
/*++

Routine Description:

    Writes a new entry to the specified ref count trace log. The entry
    written contains the updated reference count and a stack backtrace
    leading up to the current caller.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context - An uninterpreted context to associate with the log entry.

Return Value:

    None.

--*/
{

    WriteRefTraceLogEx(
        Log,
        NewRefCount,
        Context,
        (PVOID) -1, // suppress use of optional extra contexts
        (PVOID) -1,
        (PVOID) -1
        );

}   // WriteRefTraceLog




VOID
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1, // optional extra context
    IN PVOID Context2, // optional extra context
    IN PVOID Context3  // optional extra context
    )
/*++

Routine Description:

    Writes a new "extended" entry to the specified ref count trace log.
    The entry written contains the updated reference count, stack backtrace
    leading up to the current caller and extra context information.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context  - An uninterpreted context to associate with the log entry.
    Context1 - An uninterpreted context to associate with the log entry.
    Context2 - An uninterpreted context to associate with the log entry.
    Context3 - An uninterpreted context to associate with the log entry.

    NOTE Context1/2/3 are "optional" in that the caller may suppress
    debug display of these values by passing -1 for each of them.

Return Value:

    None

--*/
{

    REF_TRACE_LOG_ENTRY entry;
    ULONG hash;
    DWORD cStackFramesSkipped;

    //
    // Initialize the entry.
    //

    RtlZeroMemory(
        &entry,
        sizeof(entry)
        );

    //
    //  Set log entry members.
    //

    entry.NewRefCount = NewRefCount;
    entry.Context = Context;
    entry.Thread = GetCurrentThreadId();
    entry.Context1 = Context1;
    entry.Context2 = Context2;
    entry.Context3 = Context3;

    //
    // Capture the stack backtrace. Normally, we skip two stack frames:
    // one for this routine, and one for IISCaptureStackBackTrace() itself.
    // For non-Ex callers who come in via WriteRefTraceLog,
    // we skip three stack frames.
    //

    if (    entry.Context1 == (PVOID) -1 
         && entry.Context2 == (PVOID) -1
         && entry.Context3 == (PVOID) -1
         ) {

         cStackFramesSkipped = 3;

    } else {
    
         cStackFramesSkipped = 2;

    }

    IISCaptureStackBackTrace(
        cStackFramesSkipped,
        REF_TRACE_LOG_STACK_DEPTH,
        entry.Stack,
        &hash
        );

    //
    // Write it to the log.
    //

    WriteTraceLog(
        Log,
        &entry
        );

}   // WriteRefTraceLogEx
#pragma optimize( "", on )      // restore frame pointer omission (FPO)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\iislib\stktrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.c

Abstract:

    Implements IISCaptureStackBackTrace().

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>
#include <stktrace.h>


typedef
USHORT
(NTAPI * PFN_RTL_CAPTURE_STACK_BACK_TRACE)(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );

PFN_RTL_CAPTURE_STACK_BACK_TRACE g_pfnRtlCaptureStackBackTrace = NULL;



USHORT
NTAPI
DummyCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    Dummy implementation of RtlCaptureStackBackTrace() for Win9x.

Arguments:

    See IISCaptureStackBackTrace() below.

Return Value:

    USHORT - Always 0.

--*/
{

    return 0;

}   // DummyRtlCaptureStackBackTrace


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    Wrapper around RtlCaptureStackBackTrace(). Attempts to capture the
    stack backtrace leading up to the current instruction counter.
    Doesn't work very well on RISC platforms, and is often confused on
    X86 when FPO is enabled.

Arguments:

    FramesToSkip - The number of stack frames to skip before capturing.

    FramesToCapture - The number of stack frames to capture.

    BackTrace - Receives the captured frames.

    BackTraceHash - Some kind of hash thingie.

Return Value:

    USHORT - The number of frames captured.

--*/
{

    //
    // Initialize if necessary.
    //

    if( g_pfnRtlCaptureStackBackTrace == NULL ) {

        HMODULE mod;
        PFN_RTL_CAPTURE_STACK_BACK_TRACE proc = NULL;

        //
        // Note that it is perfectly safe to use GetModuleHandle() here
        // rather than LoadLibrary(), for the following reasons:
        //
        //     1. Under NT, NTDLL.DLL is a "well known" DLL that *never*
        //        gets detached from the process. It's very special.
        //
        //     2. Under Win95, NTDLL.DLL doesn't export the
        //        RtlCaptureStackBackTrace() function, so we will not be
        //        referencing any routines within the DLL.
        //
        // Also note that we retrieve the function pointer into a local
        // variable, not directly into the global. This prevents a nasty
        // race condition that can occur when two threads try to
        // initialize g_pfnRtlCaptureStackBackTrace simultaneously.
        //

        mod = GetModuleHandle( "ntdll.dll" );

        if( mod != NULL ) {
            proc = (PFN_RTL_CAPTURE_STACK_BACK_TRACE)
                GetProcAddress( mod, "RtlCaptureStackBackTrace" );
        }

        if( proc == NULL ) {
            g_pfnRtlCaptureStackBackTrace = &DummyCaptureStackBackTrace;
        } else {
            g_pfnRtlCaptureStackBackTrace = proc;
        }

    }

    return (g_pfnRtlCaptureStackBackTrace)(
               FramesToSkip,
               FramesToCapture,
               BackTrace,
               BackTraceHash
               );

}   // IISCaptureStackBackTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\iislib\win32obj.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    win32obj.c

Abstract:

    This module contains helper functions for creating debug-specific
    named Win32 objects. Functions are included for named events,
    semaphores, and mutexes.

    Object names created by these routines have the following format:

        filename.ext:line_number member:address PID:pid

    Where:

        filename.ext = The file name where the object was created.

        line_number = The line number within the file.

        member = The member/global variable name where the handle is
            stored. This name is provided by the caller, but is usually
            of the form "g_Global" for globals and "CLASS::m_Member" for
            class members.

        address = An address, used to guarantee uniqueness of the objects
            created. This is provided by the caller. For global variables,
            this is typically the address of the global. For class members,
            this is typically the address of the containing class.

        pid = The current process ID. This ensures uniqueness across all
            processes.

    Here are a couple of examples:

        main.cxx:796 g_hShutdownEvent:683a42bc PID:373

        resource.cxx:136 RTL_RESOURCE::SharedSemaphore:00250970 PID:373

Author:

    Keith Moore (keithmo)        23-Sep-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>


#define MAX_OBJECT_NAME 256 // chars


LONG g_PuDbgEventsCreated = 0;
LONG g_PuDbgSemaphoresCreated = 0;
LONG g_PuDbgMutexesCreated = 0;



LPSTR
PuDbgpBuildObjectName(
    IN LPSTR ObjectNameBuffer,
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address
    )

/*++

Routine Description:

    Internal routine that builds an appropriate object name based on
    the file name, line number, member name, address, and process ID.

Arguments:

    ObjectNameBuffer - Pointer to the target buffer for the name.

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

Return Value:

    LPSTR - Pointer to ObjectNameBuffer if successful, NULL otherwise.

    N.B. This routine always returns NULL when running under Win9x.

--*/

{

    PLATFORM_TYPE platformType;
    LPSTR fileNamePart;
    LPSTR result;

    //
    // We have no convenient way to dump objects w/ names from
    // Win9x, so we'll only enable this functionality under NT.
    //

    platformType = IISGetPlatformType();
    result = NULL;

    if( platformType == PtNtServer ||
        platformType == PtNtWorkstation ) {

        //
        // Find the filename part of the incoming source file name.
        //

        fileNamePart = strrchr( FileName, '\\' );

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, '/' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, ':' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = FileName;
        } else {
            fileNamePart++;
        }

        //
        // Ensure we don't overwrite our object name buffer.
        //

        if( ( sizeof(":1234567890 :12345678 PID:1234567890") +
              strlen( fileNamePart ) +
              strlen( MemberName ) ) < MAX_OBJECT_NAME ) {

            wsprintfA(
                ObjectNameBuffer,
                "%s:%lu %s:%p PID:%lu",
                fileNamePart,
                LineNumber,
                MemberName,
                Address,
                GetCurrentProcessId()
                );

            result = ObjectNameBuffer;

        }

    }

    return result;

}   // PuDbgpBuildObjectName


HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    )

/*++

Routine Description:

    Creates a new event object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    ManualReset - TRUE to create a manual reset event, FALSE to create
        an automatic reset event.

    InitialState - The intitial state of the event object.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateEventA(
                    NULL,                       // lpEventAttributes
                    ManualReset,                // bManualReset
                    InitialState,               // bInitialState
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgEventsCreated );
    }

    return objHandle;

}   // PuDbgCreateEvent


HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    )

/*++

Routine Description:

    Creates a new semaphore object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialCount - The initial count of the semaphore.

    MaximumCount - The maximum count of the semaphore.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateSemaphoreA(
                    NULL,                       // lpSemaphoreAttributes
                    InitialCount,               // lInitialCount
                    MaximumCount,               // lMaximumCount
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgSemaphoresCreated );
    }

    return objHandle;

}   // PuDbgCreateSemaphore


HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    )

/*++

Routine Description:

    Creates a new mutex object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialOwner - TRUE if the mutex should be created "owned".

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateMutexA(
                    NULL,                       // lpMutexAttributes
                    InitialOwner,               // bInitialOwner,
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgMutexesCreated );
    }

    return objHandle;

}   // PuDbgCreateMutex
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\iislib\tracelog.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    This module implements a trace log.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>
#include <tracelog.h>


#define ALLOC_MEM(cb) (PVOID)LocalAlloc( LPTR, (cb) )
#define FREE_MEM(ptr) (VOID)LocalFree( (HLOCAL)(ptr) )



PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    )
/*++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

    EntrySize - The size (in bytes) of each entry.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    LONG totalSize;
    PTRACE_LOG log;

    //
    // Sanity check the parameters.
    //

    DBG_ASSERT( LogSize > 0 );
    DBG_ASSERT( EntrySize > 0 );
    DBG_ASSERT( ( EntrySize & 3 ) == 0 );

    //
    // Allocate & initialize the log structure.
    //

    totalSize = sizeof(*log) + ( LogSize * EntrySize ) + ExtraBytesInHeader;
    DBG_ASSERT( totalSize > 0 );

    log = (PTRACE_LOG)ALLOC_MEM( totalSize );

    //
    // Initialize it.
    //

    if( log != NULL ) {

        RtlZeroMemory( log, totalSize );

        log->Signature = TRACE_LOG_SIGNATURE;
        log->LogSize = LogSize;
        log->NextEntry = -1;
        log->EntrySize = EntrySize;
        log->LogBuffer = (PUCHAR)( log + 1 ) + ExtraBytesInHeader;
    }

    return log;

}   // CreateTraceLog


VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a trace log buffer created with CreateTraceLog().

Arguments:

    Log - The trace log buffer to destroy.

Return Value:

    None.

--*/
{
	if ( Log != NULL ) {
        DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

        Log->Signature = TRACE_LOG_SIGNATURE_X;
        FREE_MEM( Log );
    }

}   // DestroyTraceLog


VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    )
/*++

Routine Description:

    Writes a new entry to the specified trace log.

Arguments:

    Log - The log to write to.

    Entry - Pointer to the data to write. This buffer is assumed to be
        Log->EntrySize bytes long.

Return Value:

    None

--*/
{

    PUCHAR target;
    LONG index;

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );
    DBG_ASSERT( Entry != NULL );

    //
    // Find the next slot, copy the entry to the slot.
    //

    index = InterlockedIncrement( &Log->NextEntry ) % Log->LogSize;
    target = Log->LogBuffer + ( index * Log->EntrySize );

    RtlCopyMemory(
        target,
        Entry,
        Log->EntrySize
        );

}   // WriteTraceLog


VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    )
{

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

    RtlZeroMemory(
        ( Log + 1 ),
        Log->LogSize * Log->EntrySize
        );

    Log->NextEntry = -1;

}   // ResetTraceLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\dynarray.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    dynarray.c

Abstract:

    This file contains the definition of a dynamic array data type.

Author:

    Colin Brace ColinBr
    
Revision History

    3-12-97   ColinBr    Created
    
--*/


#include <nt.h>
#include <ntrtl.h>

typedef unsigned long DWORD;


#include <w32topl.h>
#include <w32toplp.h>

#include <dynarray.h>

VOID
DynamicArrayInit(
    IN PDYNAMIC_ARRAY a
    )
/*++                                                                           

Routine Description:

Parameters:

--*/
{
    ASSERT(a);

    memset(a, 0, sizeof(DYNAMIC_ARRAY));

    return;
}

VOID
DynamicArrayDestroy(
    IN PDYNAMIC_ARRAY a
    )
{
    ASSERT(a);

    if (a->Array) {
        ToplFree(a->Array);
    }
}

DWORD
DynamicArrayGetCount(
    IN PDYNAMIC_ARRAY a
    )
/*++                                                                           

Routine Description:

Parameters:

--*/
{
    ASSERT(a);

    return a->Count;
}

VOID
DynamicArrayAdd(
    IN PDYNAMIC_ARRAY a,
    IN VOID*          pElement
    )
/*++                                                                           

Routine Description:

Parameters:

--*/
{
    ASSERT(a);

    if (a->Count >= a->ElementsAllocated) {
        //
        // Realloc more space!
        //
        #define CHUNK_SIZE               100  // this is the number of elements

        a->ElementsAllocated += CHUNK_SIZE;
        if (a->Array) {
            a->Array = (PEDGE*) ToplReAlloc(a->Array, a->ElementsAllocated * sizeof(PVOID));
        } else {
            a->Array = (PEDGE*) ToplAlloc(a->ElementsAllocated * sizeof(PVOID));
        }
        ASSERT(a->Array);

    }

    a->Array[a->Count] = pElement;
    a->Count++;

    return;
}

VOID*
DynamicArrayRetrieve(
    IN PDYNAMIC_ARRAY a,
    IN ULONG          Index
    )
/*++                                                                           

Routine Description:

    This routine returns the element at Index of a

Parameters:


--*/
{
    ASSERT(a);
    ASSERT(Index < a->Count);

    return a->Array[Index];
}

VOID
DynamicArrayRemove(
    IN PDYNAMIC_ARRAY a,
    IN VOID*          pElement, 
    IN ULONG          Index
    )
/*++                                                                           

Routine Description:

    This routine removes pElement from a if the element
    exists

Parameters:

    a : the dynamic array
    
    pElement : the element to remove
    
    Index : currently unused

--*/
{
    ULONG i, j;

    ASSERT(a);
    ASSERT(pElement);

    for (i = 0; i < a->Count; i++) {

        if ( a->Array[i] == pElement ) {

            if ( a->Count > 1 )
            {
                for (j = i; j < (a->Count - 1); j++) {
                    a->Array[j] = a->Array[j+1];
                }
            }

            //
            // We wouldn't have gotten in this loop if a->Count <= 0
            // 
            ASSERT( a->Count > 0 );

            a->Array[a->Count-1] = 0;
            a->Count--;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\taskq\tqutest.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    tqutest.c

ABSTRACT:

    Unit test for task scheduler functions.

DETAILS:

CREATED:

    01/13/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop
#include <drs.h>
#include <taskq.h>

BOOL    fFailed = FALSE;
BOOL    rgfExecuted[ 8 ];

// Stuff needed by DSCOMMON.LIB
DWORD ImpersonateAnyClient() { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient() { ; }

void SetFlag( void * pv, void ** ppv, DWORD * pSecsUntilNext )
{
    DWORD   iMyFlag = (DWORD) pv;
    DWORD   iFlag;

    // Make sure previous flags have been set.
    for ( iFlag = 0; iFlag < iMyFlag; iFlag++ )
    {
        if ( !rgfExecuted[ iFlag ] )
        {
            printf( "Function %d was not executed before function %d!\n", iFlag, iMyFlag );
            fFailed = TRUE;
        }
    }

    if ( rgfExecuted[ iMyFlag ] )
    {
        printf( "Function %d was executed twice!\n", iMyFlag );
        fFailed = TRUE;
    }

    rgfExecuted[ iMyFlag ] = TRUE;
    
    *pSecsUntilNext = TASKQ_DONT_RESCHEDULE;
}

    

int
__cdecl
main(
    int     argc,
    char *  argv[]
    )
{
    printf( "TQUTEST.EXE\n"
            "Unit test for task scheduler functions.\n"
            "Jeff Parham (JeffParh), 97/01/13\n"
            "\n" );

    InitTaskScheduler(0, NULL, TRUE);

    ZeroMemory( rgfExecuted, sizeof( rgfExecuted ) );
    InsertInTaskQueue( SetFlag, (void *) ( 5 - 1 ), 5 );
    InsertInTaskQueue( SetFlag, (void *) ( 1 - 1 ), 1 );
    InsertInTaskQueue( SetFlag, (void *) ( 7 - 1 ), 7 );
    InsertInTaskQueue( SetFlag, (void *) ( 4 - 1 ), 4 );
    InsertInTaskQueue( SetFlag, (void *) ( 6 - 1 ), 6 );
    InsertInTaskQueue( SetFlag, (void *) ( 2 - 1 ), 2 );
    InsertInTaskQueue( SetFlag, (void *) ( 8 - 1 ), 8 );
    InsertInTaskQueue( SetFlag, (void *) ( 3 - 1 ), 3 );

    Sleep( 10000 );

    if ( !fFailed )
    {
        DWORD   iFlag;

        for ( iFlag = 0; iFlag < sizeof( rgfExecuted ) / sizeof( rgfExecuted[ 0 ] ); iFlag++ )
        {
            if ( !rgfExecuted[ iFlag ] )
            {
                printf( "Function %d was not executed!\n", iFlag );
                fFailed = TRUE;
            }
        }

        if ( !fFailed )
        {
            ShutdownTaskSchedulerTrigger();
            fFailed = !ShutdownTaskSchedulerWait( 1000 );

            if ( fFailed )
            {
                printf( "Task scheduler failed to shut down!\n" );
            }
        }
    }

    printf( fFailed ? "Test failed!\n" : "Test passed!\n" );

    return fFailed;
}


void
DebPrint(
    USHORT      sev,
    UCHAR *     str,
    CHAR *      debsub,
    unsigned    uLineNo,
    ...
    )
{
    DWORD tid = GetCurrentThreadId();

    va_list   argptr;
    va_start( argptr, uLineNo );

    if (debsub)
    {
        printf("<%s%u:%u> ", debsub, tid, uLineNo);
    }
    vprintf( str, argptr );

    va_end( argptr );
}


void DoAssert(char *szExp, DWORD dwDSID, char *szFile)
{
    char szMessage[1024];

    _snprintf(
        szMessage,
        sizeof( szMessage ),
        "DSA assertion failure: \"%s\"\n"
             "File %s line %d\n"
             "For bug reporting purposes, please enter the "
             "debugger (Retry) and record the current call stack.  Also, please "
             "record the last messages in the Application Event Log.\n"
             "Thank you for your support.",
        szExp,
        szFile,
        (dwDSID & DSID_MASK_LINE)
        );

    switch (
        MessageBox(
            NULL,
            szMessage,
            "DSA assertion failure",
            (   MB_TASKMODAL
              | MB_ICONSTOP
              | MB_ABORTRETRYIGNORE
              | MB_DEFBUTTON2
              | MB_SETFOREGROUND
            )
        )
    )
    {
    case IDABORT:
        exit(1);
        break;
    case IDRETRY:
        DebugBreak();
        break;
    case IDIGNORE:
        /* best of luck, you're gonna need it */
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\taskq\taskq.c ===
#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes
#include "dstrace.h"

// Assorted DSA headers.
#include "dsexcept.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB "TASKQ:"                 // define the subsystem for debugging

#include <taskq.h>

#include <fileno.h>
#define  FILENO FILENO_TASKQ_TASKQ
#define  WAIT_OBJECT_1 (WAIT_OBJECT_0 + 1)

// Maximum delay until execution of the task.
//
// Tick counts wrap around after 
// 2^32 / (1000 msec/sec * 60 sec/min * 60 min/hr * 24 hr/day) = 49.7 days.  
// So with the current implementation the max taskq delay must be < 25 days
//
#define MAX_TASKQ_DELAY_SECS (7*24*60*60 + 1)


BOOL                gfIsTqRunning = FALSE;  // is the scheduler running?
BOOL                gfIsTqSuspended = FALSE;// was the scheduled created in suspended 
                                            // state and is still suspended?
CRITICAL_SECTION    gcsTaskQueue;           // acquired before modifying queue
HANDLE              ghTaskSchedulerThread;  // signalled when shutdown is complete
HANDLE              ghTqWakeUp;             // signalled to wake up scheduling thread
PTASKQFN            gpfnTqCurrentTask;      // current task being performed
BOOL                gfTqShutdownRequested;  // set when we're supposed to shut down
DWORD               gTaskSchedulerTID = 0;  // task scheduler thread id
                                            // init here because its exported
RTL_AVL_TABLE       gTaskQueue;             // task queue

// The array of handles to events that the task scheduler waits on, and the
// corresponding array of functions it calls when each event is triggered.
// The only "unique" event/function pair is at index 0 -- the event signals an
// event has been added to the queue, and the associated function is NULL.
PSPAREFN            grgFns[MAXIMUM_WAIT_OBJECTS];
HANDLE              grgWaitHandles[MAXIMUM_WAIT_OBJECTS];
DWORD               gcWaitHandles = 0;

unsigned __stdcall TaskScheduler( void * pv );
void RemoveFromTaskQueueInternal( pTQEntry pTQOld );
void TriggerCallback(void*, void**, DWORD*);

#if DBG
VOID debugPrintTaskQueue();
#endif

DWORD MsecUntilExecutionTime(
    IN  TQEntry *   ptqe,
    IN  DWORD       cTickNow
    );


RTL_GENERIC_COMPARE_RESULTS
TQCompareTime(
    RTL_AVL_TABLE       *Table,
    PVOID               FirstStruct,
    PVOID               SecondStruct)
{
    DWORD time1, time2;
    pTQEntry pTQ1,pTQ2;
    int res;

    pTQ1 = (pTQEntry)FirstStruct;
    pTQ2 = (pTQEntry)SecondStruct;

    time1 =  pTQ1->cTickDelay + pTQ1->cTickRegistered;
    time2 =  pTQ2->cTickDelay + pTQ2->cTickRegistered;

    // The tick count wraps about every 47 days.
    // The maximum delay a task is allowed to have is 7 days,
    // So the largest difference between two times won't exceed
    // 7 days in ideal situation.  Therefore, it is safe to use
    // a window of 0x7fffffff (23 days) for comparison.

    if (time1 != time2 ) {
        if ( time2-time1 < 0x7fffffff )
        {
            return(GenericLessThan);
        }
        return(GenericGreaterThan);
    }

    // the AVL table data structure requires a strict order.
    // two objects can be equal if and only if they are the
    // same object.  So here, do more test to decide the exact order.

    // (time1 == time2) is true here

    res= memcmp(FirstStruct, SecondStruct,sizeof(TQEntry));

    if ( 0 == res ) {
        return(GenericEqual);
    }
    else if (res < 0) {
        return(GenericLessThan);
    }

    return(GenericGreaterThan);

}

typedef union _TQAllocEntry {
    union _TQAllocEntry* pNextFreeEntry;
    struct {
        RTL_BALANCED_LINKS rtlBase;
        TQEntry entry;
    } data;
} TQAllocEntry;

TQAllocEntry tqEmergencyPool[] = {
    { &tqEmergencyPool[1] },
    { &tqEmergencyPool[2] },
    { &tqEmergencyPool[3] },
    { &tqEmergencyPool[4] },
    { &tqEmergencyPool[5] },
    { &tqEmergencyPool[6] },
    { &tqEmergencyPool[7] },
    { &tqEmergencyPool[8] },
    { &tqEmergencyPool[9] },
    { &tqEmergencyPool[10] },
    { &tqEmergencyPool[11] },
    { &tqEmergencyPool[12] },
    { &tqEmergencyPool[13] },
    { &tqEmergencyPool[14] },
    { &tqEmergencyPool[15] },
    { NULL }
};

TQAllocEntry *pTQEmergencyPool = &tqEmergencyPool[0];

PVOID
TQAlloc(
    RTL_AVL_TABLE       *Table,
    CLONG               ByteSize)
{
    PVOID res;
    res = malloc(ByteSize);
    if (res == NULL) {
        // We are out of memory.
        LogUnhandledError(ERROR_OUTOFMEMORY);
        if (ByteSize <= sizeof(TQAllocEntry) && pTQEmergencyPool != NULL) {
            // Grab an entry from the emergency pool.
            res = (PVOID)pTQEmergencyPool;
            pTQEmergencyPool = pTQEmergencyPool->pNextFreeEntry;
        }
    }
    if (res == NULL) {
        // We are going to lose some tasks.
        // Log an event recommending DC restart.
        MemoryPanic(ByteSize);
    }
    return res;
}

VOID
TQFree(
    RTL_AVL_TABLE       *Table,
    PVOID               Buffer)
{
    // check if this buffer was allocated from the emergency pool
    if ((PBYTE)&tqEmergencyPool <= (PBYTE)Buffer && 
        (PBYTE)Buffer < (PBYTE)&tqEmergencyPool + sizeof(tqEmergencyPool)) 
    {
        // the alignment should be correct
        Assert(((PBYTE)Buffer - (PBYTE)&tqEmergencyPool) % sizeof(TQAllocEntry) == 0);
        // push the entry onto the free list
        ((TQAllocEntry*)Buffer)->pNextFreeEntry = pTQEmergencyPool;
        pTQEmergencyPool = (TQAllocEntry*)Buffer;
    }
    else {
        // normal allocation
        free(Buffer);
    }
}


DWORD
MsecUntilExecutionTime(
    IN  TQEntry *   ptqe,
    IN  DWORD       cTickNow
    )
{
    DWORD cTicksSinceRegistration = cTickNow - ptqe->cTickRegistered;

    if (ptqe->cTickDelay > cTicksSinceRegistration) {
        return ptqe->cTickDelay - cTicksSinceRegistration;
    }
    else {
        return 0;
    }
}

// Start scheduler that has been initialized with fRunImmediately == FALSE
void StartTaskScheduler() {
    if (!gfIsTqRunning) {
        Assert(!"Attempt to wake up TaskScheduler before it got initialized");
        return;
    }
    gfIsTqSuspended = FALSE;
    Assert(ghTaskSchedulerThread);
    ResumeThread(ghTaskSchedulerThread);
}


BOOL
InitTaskScheduler(
    DWORD           cSpareFns,
    SPAREFN_INFO *  pSpareFnInfo,
    BOOL            fRunImmediately
    )
{
    DWORD i;
    BOOL fInitCS = FALSE;

    if ( gfIsTqRunning )
    {
        Assert( !"Attempt to reinitialize task scheduler while it's running!" );
    }
    else
    {
        Assert(cSpareFns < MAXIMUM_WAIT_OBJECTS-1);

        //init the Avl table

        RtlInitializeGenericTableAvl( &gTaskQueue,
                                      TQCompareTime,
                                      TQAlloc,
                                      TQFree,
                                      NULL );


        // initialize global state.

        gfTqShutdownRequested = FALSE;
        gpfnTqCurrentTask     = NULL;
        ghTqWakeUp            = NULL;
        ghTaskSchedulerThread = NULL;
        gTaskSchedulerTID     = 0;

        if ( InitializeCriticalSectionAndSpinCount( &gcsTaskQueue, 400 ) ) {

            fInitCS = TRUE;
            ghTqWakeUp = CreateEvent(
                            NULL,   // security descriptor
                            FALSE,  // manual reset
                            TRUE,   // initial state signalled?
                            NULL    // event name
                            );
        }

        if ( NULL == ghTqWakeUp )
        {
            LogUnhandledError( GetLastError() );
        }
        else
        {
            // Construct the array of wait handles and corresponding functions
            // to call to be used by the TaskScheduler() thread.
            grgFns[0] = NULL;
            grgWaitHandles[0] = ghTqWakeUp;
            gcWaitHandles = 1;

            for (i = 0; i < cSpareFns; i++) {
                if ((NULL != pSpareFnInfo[i].hevSpare)
                    && (NULL != pSpareFnInfo[i].pfSpare)) {
                    grgFns[gcWaitHandles] = pSpareFnInfo[i].pfSpare;
                    grgWaitHandles[gcWaitHandles] = pSpareFnInfo[i].hevSpare;
                    gcWaitHandles++;
                }
            }

            ghTaskSchedulerThread =
                (HANDLE) _beginthreadex(
                    NULL,
                    0,                  // stack size: use process default
                    TaskScheduler,
                    NULL,
                    fRunImmediately ? 0 : CREATE_SUSPENDED,
                    &gTaskSchedulerTID
                    );

            if ( NULL == ghTaskSchedulerThread )
            {
                LogUnhandledError( GetLastError() );
                LogUnhandledError( errno );
            }
            else
            {
                gfIsTqRunning = TRUE;
                gfIsTqSuspended = !fRunImmediately;

                DPRINT( 1, "Synchronous task queue installed\n" );
            }
        }

        if ( !gfIsTqRunning )
        {
            // Unsuccessful startup attempt; free any resources we
            // managed to acquire.

            if ( NULL != ghTqWakeUp )
            {
                CloseHandle( ghTqWakeUp );
            }

            if ( fInitCS ) {
                DeleteCriticalSection(&gcsTaskQueue);
            }
        }
    }

    return gfIsTqRunning;
}

void
ShutdownTaskSchedulerTrigger()
{
    if ( gfIsTqRunning ) {

        gfTqShutdownRequested = TRUE;
        SetEvent( ghTqWakeUp );
    }
}



BOOL
ShutdownTaskSchedulerWait(
    DWORD   dwWaitTimeInMilliseconds
    )
{
    if ( gfIsTqRunning )
    {
        DWORD dwWaitStatus;

        Assert(gfTqShutdownRequested);

        if (gfIsTqSuspended) {
            // The TQ thread has not been awaken yet. There's no
            // use in waiting for it to exit, it there? So, wake 
            // it up now and let it exit gracefully.
            StartTaskScheduler();
        }

        dwWaitStatus = WaitForSingleObject(
                            ghTaskSchedulerThread,
                            dwWaitTimeInMilliseconds
                            );

        gfIsTqRunning = ( WAIT_OBJECT_0 != dwWaitStatus );

        if ( !gfIsTqRunning )
        {
            DeleteCriticalSection( &gcsTaskQueue );

            CloseHandle( ghTaskSchedulerThread );
            CloseHandle( ghTqWakeUp );

            DPRINT( 1, "Synchronous task queue shut down\n" );
        }
    }

    return !gfIsTqRunning;
}

PCHAR getCurrentTime(PCHAR pb)
// get current time in format hh:mm:ss.ddd and put it into the buffer. The buffer should be at least 13 chars long.
{
    SYSTEMTIME stNow;
    Assert(pb);
    GetLocalTime(&stNow);
    sprintf(pb, "%02d:%02d:%02d.%03d", stNow.wHour, stNow.wMinute, stNow.wSecond, stNow.wMilliseconds);
    return pb;
}


BOOL
InsertInTaskQueueHelper(
    pTQEntry    pTQNew
    )
{
    BOOLEAN fNewElement = TRUE;
    PVOID   pNewElement = NULL;
    // gain access to queue
    EnterCriticalSection(&gcsTaskQueue);
    __try
    {

        pNewElement = RtlInsertElementGenericTableAvl( &gTaskQueue,
                                                       pTQNew,
                                                       sizeof(TQEntry),
                                                       &fNewElement );

    }
    __finally
    {
        LeaveCriticalSection(&gcsTaskQueue);
    }
    return pNewElement != NULL;
}


BOOL
InsertInTaskQueueHelperDamped(
    pTQEntry    pTQNew,
    DWORD       cSecsDamped,
    PISMATCHED  pfnIsMatched,
    void*       pContext
    )
/*
 * Iterate through the queue looking for a task that is scheduled to execute
 * within cSecsDamped seconds from now that matches the new task's parameters.
 * If none exists, the new task is scheduled.
 *
 * Returns TRUE if the task was sucessfully scheduled, FALSE if it was damped.
 *
 */
{
    BOOL        fFoundMatch=FALSE, fTaskScheduled=FALSE;
    BOOLEAN     fNewElement=TRUE;
    DWORD       tickNow, cTicksDamped, cTicksUntilExecute;
    PVOID       Restart = NULL, pNewElement;
    pTQEntry    ptqe;

    // tickLimit specifies how far into the future we will look
    // for a matching task.
    tickNow = GetTickCount();
    cTicksDamped = 1000 * cSecsDamped;
    
    // gain access to queue
    EnterCriticalSection(&gcsTaskQueue);
    __try
    {
        //
        // Traverse table looking for our entry
        //
        for ( ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart);
             (NULL != ptqe) && !gfTqShutdownRequested;
              ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart))
        {

            // Compute how many ticks until this task will run
            cTicksUntilExecute = MsecUntilExecutionTime( ptqe, tickNow );
            Assert( cTicksUntilExecute < 0x7FFFFFFF );

            if( cTicksUntilExecute > cTicksDamped ) {
                // No matching task was found and we've exceeded the
                // limit of how far into the queue to look.
                DPRINT(1, "Dampening: No matching task found\n");
                break;
            }

            fFoundMatch = pfnIsMatched(pTQNew->pfnName, pTQNew->pvTaskParm,
                ptqe->pfnName, ptqe->pvTaskParm, pContext);
            if( fFoundMatch ) {
                // Matching task was found that is scheduled to execute
                // within cTicksDamped ticks from now.
                DPRINT1(1, "Dampening: Found matching task executing in %d ticks\n",
                cTicksUntilExecute);
                break;
            }
        }

        if( !fFoundMatch ) {
            // No matching task was found -- insert our task
            pNewElement = RtlInsertElementGenericTableAvl(
                &gTaskQueue,
                pTQNew,
                sizeof(TQEntry),
                &fNewElement );
            fTaskScheduled = ( NULL != pNewElement );
        }

    }
    __finally
    {
        LeaveCriticalSection(&gcsTaskQueue);
    }

    return fTaskScheduled;
}


BOOL
DoInsertInTaskQueueDamped(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    DWORD       cSecsFromNow,
    BOOL        fReschedule,
    PCHAR       pfnName,
    DWORD       cSecsDamped,
    PISMATCHED  pfnIsMatched,
    void *      pContext
    )
/*
 * Insert a task into the task queue.  This version of the routine will return false
 * if the task queue is not running.  It is useful when the code you are calling this
 * from is in a race condition with shutdown.
 *
 * If fReschedule then, it will first attempt to reschedule the task, although this
 * is not an atomic operation.
 *
 * This function supports task dampening. This means that if a task with matching
 * parameters in scheduled to run within cSecsDamped seconds from now, the new
 * task will not be enqueued. The pfnIsMatched function is used to determine if
 * two tasks have matching parameters for the purpose of dampening. pContext is a
 * pointer to arbitrary data that will be passed to pfnIsMatched.
 *
 * If damped behavior is not desired, then you can either set cSecsDamped to
 * TASKQ_NOT_DAMPED or call DoInsertInTaskQueue() instead.
 *
 * If the task is successfully enqueued, TRUE is returned.
 * If the a matching task is found and the task is not enqueued, FALSE is returned.
 *
 */
{
    BOOL       fResult=TRUE;
    TQEntry    TQNew;
    CHAR       timeStr[13];

    Assert(cSecsFromNow < MAX_TASKQ_DELAY_SECS);
    Assert(cSecsDamped<MAX_TASKQ_DELAY_SECS || cSecsDamped==TASKQ_NOT_DAMPED);

    DPRINT6(1, "%s insert %s, param=%p, secs=%d, dampedSecs=%d%s,\n", 
            getCurrentTime(timeStr), pfnName, pvParm, cSecsFromNow,
            cSecsDamped, fReschedule ? ", reschedule" : "");

    if ( gfIsTqRunning )
    {
        // initialize new entry
        TQNew.pvTaskParm      = pvParm;
        TQNew.pfnTaskFn       = pfnTaskQFn;
        TQNew.cTickRegistered = GetTickCount();
        TQNew.cTickDelay      = cSecsFromNow * 1000;
        TQNew.pfnName         = pfnName;

        if ( fReschedule ) {
            // Remove previously set tasks (if they're there)
            // and then insert a new one.
            // This is more expensive, don't use if don't have to.
            (void)DoCancelTask( pfnTaskQFn, pvParm, pfnName );
        }

        if ( TASKQ_NOT_DAMPED == cSecsDamped ) {
            // Duplicate *identical* entries already queued will be removed
            // (note: duplicate entries are only those that are identical
            // in all fields (extremely unlikely) ).
            // Note: In the future we could use the pfnIsMatched function
            // as an improved method of finding duplicate entries.
            fResult = InsertInTaskQueueHelper( &TQNew );
        } else {
            fResult = InsertInTaskQueueHelperDamped( &TQNew,
                cSecsDamped, pfnIsMatched, pContext );
        }

#if DBG
        if (DebugTest(5, DEBSUB)) {
            debugPrintTaskQueue();
        }
#endif

        // awaken the task scheduler by posting its event
        SetEvent( ghTqWakeUp );
    }

    return fResult;
}


BOOL
DoInsertInTaskQueue(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    DWORD       cSecsFromNow,
    BOOL        fReschedule,
    PCHAR       pfnName
    )
/*
 * Insert a task into the task queue.  This version of the routine will return false
 * if the task queue is not running.  It is useful when the code you are calling this
 * from is in a race condition with shutdown.
 * if fReschedule then, it will first attempt to reschedule the task
 *
 */
{
    return DoInsertInTaskQueueDamped(
            pfnTaskQFn,
            pvParm,
            cSecsFromNow,
            fReschedule,
            pfnName,
            TASKQ_NOT_DAMPED,
            NULL, NULL );
}


BOOL
DoCancelTask(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    PCHAR       pfnName
    )
/*++

Routine Description:

    Lookup task entry (ignoring time) & remove from task queue.

Arguments:

    pfnTaskQFn - task function
    pvParm - context paramter

Return Value:

    TRUE: Removed.
    FALSE: Wasn't removed

Remarks:
    This is an expensive operation. It traverses the AVL table,
    acquire locks, remove entry, re-insert, & unlocks.
    Don't use if you don't have to.

    This function determines if two tasks are equal by checking
    if the pointer to the parameters is the same. This is typically
    not a very useful comparison. 

--*/
{
    TQEntry    TQNew;
    PVOID Restart = NULL;
    pTQEntry    ptqe;
    BOOL fFound = FALSE;
    CHAR timeStr[13];

    Assert(pfnTaskQFn);

    DPRINT3(1, "%s cancel %s, param=%p\n", getCurrentTime(timeStr), pfnName, pvParm);
    
    if ( !gfIsTqRunning )
    {
        Assert( !"CancelTask() called before InitTaskScheduler()!" );
        return FALSE;
    }

    // lock held during entire traversal
    EnterCriticalSection( &gcsTaskQueue );

    __try
    {
        //
        // Traverse table looking for our entry
        //
        for ( ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart);
             (NULL != ptqe) && !gfTqShutdownRequested;
              ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart))
        {

            if (ptqe->pfnTaskFn == pfnTaskQFn &&
                ptqe->pvTaskParm == pvParm) {
                // This is the same task (ignore time values)
                fFound = TRUE;
                break;
            }
        }

        if (fFound) {
            // remove old one
            RemoveFromTaskQueueInternal( ptqe );
        }

#if DBG
        if (DebugTest(5, DEBSUB)) {
            debugPrintTaskQueue();
        }
#endif
    
    }
    __finally
    {
        // why would we ever fail?
        // make sure we see it in case we do.
        Assert(!AbnormalTermination());

        // regardless, release
        LeaveCriticalSection( &gcsTaskQueue );
    }

    return fFound;
}





void
RemoveFromTaskQueueInternal(
    pTQEntry    pTQOld
    )
{
    BOOL res;
    // Critical section already held

    res = RtlDeleteElementGenericTableAvl( &gTaskQueue, (PVOID)pTQOld );

    //make sure the deletion always succeed
    Assert(res);

}

void
RemoveFromTaskQueue(
    pTQEntry    pTQOld
    )
{
    if ( !gfIsTqRunning )
    {
        Assert( !"RemoveFromTaskQueue() called before InitTaskScheduler()!" );
    }
    else
    {
        // gain access to queue
        EnterCriticalSection(&gcsTaskQueue);
        __try
        {
            RemoveFromTaskQueueInternal( pTQOld );
        }
        __finally
        {
            LeaveCriticalSection(&gcsTaskQueue);
        }
    }
}


pTQEntry
GetNextReadyTaskAndRemove( void )
{
    pTQEntry    ptqe, pTemp = NULL;
    PVOID Restart = NULL;

    EnterCriticalSection( &gcsTaskQueue );

    __try
    {
        ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart);
        if (ptqe) {
            if ( 0 == MsecUntilExecutionTime(ptqe, GetTickCount()) ) {

                //make a copy before deletion
                pTemp = malloc(sizeof(TQEntry));
                if (NULL==pTemp) {
                    __leave;
                }
                memcpy(pTemp,ptqe,sizeof(TQEntry));

                RemoveFromTaskQueueInternal( pTemp );
            }
        }
    }
    __finally
    {
        LeaveCriticalSection( &gcsTaskQueue );
    }

    // Note that this routine does not set the event that there is a new
    // task at the head of the queue. The caller is expected to do that.

    return pTemp;
}

pTQEntry
GetNextTask( void )
{
    pTQEntry    ptqe;
    PVOID Restart = NULL;

    EnterCriticalSection( &gcsTaskQueue );

    __try
    {
        ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart);
    }
    __finally
    {
        LeaveCriticalSection( &gcsTaskQueue );
    }

    return ptqe;
}

unsigned __stdcall
TaskScheduler(
    void *  pv
    )
{
    DWORD       cMSecUntilNextTask = 0;
    pTQEntry    ptqe;
    DWORD       err;
    DWORD       dwExcept;
    CHAR        timeStr[13];

    // tracing event buffer and ClientID
    CHAR traceHeaderBuffer[sizeof(EVENT_TRACE_HEADER)+sizeof(MOF_FIELD)];
    PEVENT_TRACE_HEADER traceHeader = (PEVENT_TRACE_HEADER)traceHeaderBuffer;
    PWNODE_HEADER wnode = (PWNODE_HEADER)traceHeader;
    DWORD clientID;
    
    // initialize tracing vars
    ZeroMemory(traceHeader, sizeof(EVENT_TRACE_HEADER)+sizeof(MOF_FIELD));
    wnode->Flags = WNODE_FLAG_USE_GUID_PTR | // Use a guid ptr instead of copying
                   WNODE_FLAG_USE_MOF_PTR  | // Data is not contiguous to header
                   WNODE_FLAG_TRACED_GUID;

    // Task queue does not have a ClientContext. We will create a fake one for tracing.
    // To distinguish between different modules and their task queues lets use a
    // global ptr (any one available, really). Hopefully, different modules will not
    // have it at exactly the same address.
    // If this approach is changed, don't forget to change the matching block of code in TriggerCallback
#if defined(_WIN64)
    {
        ULARGE_INTEGER lu;
        lu.QuadPart = (ULONGLONG)&gTaskQueue;
        clientID = lu.LowPart;
    }
#else
    clientID = (DWORD)&gTaskQueue;
#endif

    while ( !gfTqShutdownRequested )
    {
        // wait until time for next task, shutdown, or a new task
        err = WaitForMultipleObjects(gcWaitHandles,
                                     grgWaitHandles,
                                     FALSE,
                                     cMSecUntilNextTask);

        if (gfTqShutdownRequested) {
            continue;
        }
        if ((WAIT_OBJECT_0 < err)
            && (err < WAIT_OBJECT_0 + gcWaitHandles)) {
            // The event for one of the "spare" funtions has been signalled --
            // execute it.
            __try {
                (grgFns[err - WAIT_OBJECT_0])();
            }
            __except (HandleMostExceptions(dwExcept=GetExceptionCode())) {
                // Spare function generated a non-critical exception -- ignore
                // it.
                DPRINT2(0, "Spare fn %p generated exception %d!",
                        grgFns[err - WAIT_OBJECT_0], dwExcept);
            }
        }
        else {
            if ((WAIT_OBJECT_0 != err) && (WAIT_TIMEOUT != err)) {
                DWORD gle = GetLastError();
                DPRINT2(0, "TASK SCHEDULER WAIT FAILED! -- err = 0x%x, gle = %d\n",
                        err, gle);
                Assert(!"TASK SCHEDULER WAIT FAILED!");
                Sleep(30 * 1000);
            }

            // Rather than reference counting or marking an entry that is in use, the
            // task is removed from the queue during execution so other threads will not
            // disturb it.

            for ( ptqe = GetNextReadyTaskAndRemove() ;
                  ( !gfTqShutdownRequested
                    && ( NULL != ptqe ) ) ;
                  ptqe = GetNextReadyTaskAndRemove()
                )
            {
                void *  pvParamNext = NULL;
                DWORD   cSecsFromNow = TASKQ_DONT_RESCHEDULE;

                if (ptqe->pfnTaskFn != TriggerCallback) {
                    // don't log trigger callback calls -- those are logged inside the callback!
#if DBG
                    DPRINT3(1, "%s exec %s, param=%p\n", getCurrentTime(timeStr), ptqe->pfnName, ptqe->pvTaskParm);
                    if (DebugTest(5, DEBSUB)) {
                        debugPrintTaskQueue();
                    }
#endif
    
                    LogAndTraceEventWithHeader(FALSE,
                                               DS_EVENT_CAT_DIRECTORY_ACCESS,
                                               DS_EVENT_SEV_VERBOSE,
                                               DIRLOG_TASK_QUEUE_BEGIN_EXECUTE,
                                               EVENT_TRACE_TYPE_START,
                                               DsGuidTaskQueueExecute,
                                               traceHeader,
                                               clientID,
                                               szInsertSz(ptqe->pfnName),
                                               szInsertPtr(ptqe->pvTaskParm),
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL);
                }
                dwExcept = 0;
                
                __try {
                    // execute task
                    gpfnTqCurrentTask = ptqe->pfnTaskFn;
                    (*ptqe->pfnTaskFn)( ptqe->pvTaskParm,
                                       &pvParamNext,
                                       &cSecsFromNow );
                    gpfnTqCurrentTask = NULL;
                }
                __except ( HandleMostExceptions( dwExcept = GetExceptionCode() ) ) {
                    // a non-critical exception was generated in the bowels
                    // of the queued function; this clause ensures the
                    // scheduler thread continues unabated
                    ;
                }

                if (ptqe->pfnTaskFn != TriggerCallback) {
                    LogAndTraceEventWithHeader(FALSE,
                                               DS_EVENT_CAT_DIRECTORY_ACCESS,
                                               DS_EVENT_SEV_VERBOSE,
                                               DIRLOG_TASK_QUEUE_END_EXECUTE,
                                               EVENT_TRACE_TYPE_END,
                                               DsGuidTaskQueueExecute,
                                               traceHeader,
                                               clientID,
                                               szInsertSz(ptqe->pfnName),
                                               szInsertPtr(ptqe->pvTaskParm),
                                               szInsertHex(dwExcept),                                   
                                               szInsertInt(cSecsFromNow == TASKQ_DONT_RESCHEDULE ? -1 : cSecsFromNow),
                                               szInsertPtr(pvParamNext),
                                               NULL,
                                               NULL,
                                               NULL);
                }
                
                // Task has already been removed by this point

                if ( TASKQ_DONT_RESCHEDULE == cSecsFromNow ) {
                    // task is not to be rescheduled
                    free( ptqe );
                }
                else {
                    Assert(cSecsFromNow < MAX_TASKQ_DELAY_SECS);

                    // reschedule this task with new parameter and time
                    ptqe->pvTaskParm      = pvParamNext;
                    ptqe->cTickRegistered = GetTickCount();
                    ptqe->cTickDelay      = cSecsFromNow * 1000;

                    // Note that there is a window here where another thread could
                    // have inserted the same task already. We don't worry about this.
                    // At the worst, it results in an extra execution.
                    InsertInTaskQueueHelper( ptqe );

#if DBG
                    DPRINT4(1, "%s reschedule %s, param=%p, secs=%d\n", getCurrentTime(timeStr), ptqe->pfnName, pvParamNext, cSecsFromNow);
                    if (DebugTest(5, DEBSUB)) {
                        debugPrintTaskQueue();
                    }
#endif

                    // the rtl function will create another copy,
                    // so free the user copy.
                    free( ptqe );
                }
            }
        }

        // how much time until the next task?
        if ( NULL == (ptqe = GetNextTask())) {
            cMSecUntilNextTask = INFINITE;
        }
        else {
            cMSecUntilNextTask = MsecUntilExecutionTime(ptqe, GetTickCount());

            // look at comment on definition of MAX_TASKQ_DELAY_SECS
            Assert(cMSecUntilNextTask < 1000*MAX_TASKQ_DELAY_SECS);
        }
    }

    return 0;

    (void *) pv;    // unused
}

// This code shamelessly copied from the task triggering functionality in
// kcctask.cxx by Jeffparh.

typedef struct {
    PTASKQFN    pfnTaskQFn;
    void *      pvParm;
    PCHAR       pfnName;
    HANDLE      hevDone;
} TASK_TRIGGER_INFO;

void
TriggerCallback(
    IN  void *  pvTriggerInfo,
    OUT void ** ppvNextParam,
    OUT DWORD * pcSecsUntilNext
    )
//
// TaskQueue callback for triggered execution.  Wraps task execution.
//
{
    TASK_TRIGGER_INFO * pTriggerInfo;
    void *  pvParamNext = NULL;
    DWORD   cSecsFromNow = TASKQ_DONT_RESCHEDULE;
    CHAR    timeStr[13];
    DWORD   dwExcept = 0;

    // tracing event buffer and ClientID
    CHAR traceHeaderBuffer[sizeof(EVENT_TRACE_HEADER)+sizeof(MOF_FIELD)];
    PEVENT_TRACE_HEADER traceHeader = (PEVENT_TRACE_HEADER)traceHeaderBuffer;
    PWNODE_HEADER wnode = (PWNODE_HEADER)traceHeader;
    DWORD clientID;
    
    // initialize tracing vars
    ZeroMemory(traceHeader, sizeof(EVENT_TRACE_HEADER)+sizeof(MOF_FIELD));
    wnode->Flags = WNODE_FLAG_USE_GUID_PTR | // Use a guid ptr instead of copying
                   WNODE_FLAG_USE_MOF_PTR  | // Data is not contiguous to header
                   WNODE_FLAG_TRACED_GUID;

    // Task queue does not have a ClientContext. We will create a fake one for tracing.
    // To distinguish between different modules and their task queues lets use a
    // global ptr (any one available, really). Hopefully, different modules will not
    // have it at exactly the same address.
#if defined(_WIN64)
    {
        ULARGE_INTEGER lu;
        lu.QuadPart = (ULONGLONG)&gTaskQueue;
        clientID = lu.LowPart;
    }
#else
    clientID = (DWORD)&gTaskQueue;
#endif

    pTriggerInfo = (TASK_TRIGGER_INFO *) pvTriggerInfo;

#if DBG
    DPRINT3(1, "%s exec %s, param=%p\n", getCurrentTime(timeStr), pTriggerInfo->pfnName, pTriggerInfo->pvParm);
    if (DebugTest(5, DEBSUB)) {
        debugPrintTaskQueue();
    }
#endif
    
    LogAndTraceEventWithHeader(FALSE,
                               DS_EVENT_CAT_DIRECTORY_ACCESS,
                               DS_EVENT_SEV_VERBOSE,
                               DIRLOG_TASK_QUEUE_BEGIN_EXECUTE,
                               EVENT_TRACE_TYPE_START,
                               DsGuidTaskQueueExecute,
                               traceHeader,
                               clientID,
                               szInsertSz(pTriggerInfo->pfnName),
                               szInsertPtr(pTriggerInfo->pvParm),
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
    
    // Execute our task.
    __try {
        (*pTriggerInfo->pfnTaskQFn)(
            pTriggerInfo->pvParm,
            &pvParamNext,
            &cSecsFromNow );
    }
    __except ( HandleMostExceptions( dwExcept = GetExceptionCode() ) ) {
        // a non-critical exception was generated in the bowels
        // of the queued function; this clause ensures the
        // scheduler thread continues unabated
        ;
    }

    LogAndTraceEventWithHeader(FALSE,
                               DS_EVENT_CAT_DIRECTORY_ACCESS,
                               DS_EVENT_SEV_VERBOSE,
                               DIRLOG_TASK_QUEUE_END_EXECUTE,
                               EVENT_TRACE_TYPE_END,
                               DsGuidTaskQueueExecute,
                               traceHeader,
                               clientID,
                               szInsertSz(pTriggerInfo->pfnName),
                               szInsertPtr(pTriggerInfo->pvParm),
                               szInsertHex(dwExcept),
                               szInsertInt(-1), // triggered tasks are not allowed to reschedule
                               szInsertPtr(NULL),
                               NULL,
                               NULL,
                               NULL);
    
    // This is a one-shot execution; don't reschedule.
    *pcSecsUntilNext = TASKQ_DONT_RESCHEDULE;

    SetEvent(pTriggerInfo->hevDone);

    free(pTriggerInfo);
}


DWORD
DoTriggerTaskSynchronously(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    PCHAR       pfnName
    )

/*++

Routine Description:

    Cause the given task queue function to be executed synchonously with respect
    to other tasks in the task queue.  The task is executed as soon as possible.
    The task is not automatically rescheduled.

    Execution of the task in this manner does not interfere with other
    scheduled instances of this task already in the queue.

Arguments:

    pfnTaskQFn -
    pvParm -

Return Value:

    DWORD -

--*/

{
    HANDLE                  hevDone = NULL;
    HANDLE                  rgWaitHandles[2];
    DWORD                   waitStatus;
    TASK_TRIGGER_INFO * pTriggerInfo = NULL;
    DWORD                   ret = 0;
    CHAR                    timeStr[13];

#if DBG
    DPRINT3(1, "%s trigger %s, param=%p\n", getCurrentTime(timeStr), pfnName, pvParm);
    if (DebugTest(5, DEBSUB)) {
        debugPrintTaskQueue();
    }
#endif

    pTriggerInfo = (TASK_TRIGGER_INFO *) malloc(sizeof(*pTriggerInfo));
    if (NULL == pTriggerInfo) {
        return ERROR_OUTOFMEMORY;
    }

    // Waiting for completion; create synchronization event.
    hevDone = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == hevDone) {
        free(pTriggerInfo);
        return GetLastError();
    }

    pTriggerInfo->hevDone    = hevDone;
    pTriggerInfo->pfnTaskQFn = pfnTaskQFn;
    pTriggerInfo->pvParm     = pvParm;
    pTriggerInfo->pfnName    = pfnName;

    if (!DoInsertInTaskQueue(&TriggerCallback, pTriggerInfo, 0, FALSE, "TriggerCallback")) {
        free(pTriggerInfo);
        CloseHandle(hevDone);
        return ERROR_OUTOFMEMORY;
    }

    // Wait for completion.
    // The reason we wait on the task scheduler thread is that this code is in
    // a standalone library and cannot rely on any external shutdown event.
    rgWaitHandles[0] = ghTaskSchedulerThread;
    rgWaitHandles[1] = hevDone;

    waitStatus = WaitForMultipleObjects(2,
                                        rgWaitHandles,
                                        FALSE,
                                        INFINITE);
    switch (waitStatus) {
    case WAIT_OBJECT_0:
        // Shutdown.
        ret = ERROR_DS_SHUTTING_DOWN;
        break;
    case WAIT_OBJECT_0 + 1:
        // Task completed!
        ret = ERROR_SUCCESS;
        break;
    case WAIT_FAILED:
        // There may be a race condition where the task thread handle gets closed
        // by the shutdown task scheduler wait routine.
        if (gfTqShutdownRequested) {
            ret = ERROR_DS_SHUTTING_DOWN;
        } else {
            ret = GetLastError();
        }
        break;
    default:
        ret = ERROR_DS_INTERNAL_FAILURE;
        break;
    }

    CloseHandle(hevDone);

    return ret;

} /* TriggerTask */


#if DBG

// maximum number of entries to print
DWORD gDebugPrintTaskQueueMaxEntries = 100;

VOID debugPrintTaskQueue()
/*
  Description:
  
    Prints the current state of the task queue.
    Only for debugging purposes
    
*/
{
    PVOID Restart = NULL;
    pTQEntry    ptqe;
    CHAR execTime[13], schedTime[13];
    DWORD count;
    SYSTEMTIME  st, stNow;
    FILETIME    ft, ftNow;
    DWORD       cTickNow, cTickDiff;
    ULARGE_INTEGER uliTime;
    
    // note: the width of param column (ptr) is different for 32- and 64-bit
#if defined(_WIN64)
    DebPrint(0, "%-12s %-30s %-17s %6s %-12s\n", NULL, 0, "ExecTime", "Function", "Param", "Delay", "SchedTime");
#else
    DebPrint(0, "%-12s %-30s %-8s %6s %-12s\n", NULL, 0, "ExecTime", "Function", "Param", "Delay", "SchedTime");
#endif

    //get current time and tick count
    //use it to calculate the rigistered time later
    cTickNow = GetTickCount();
    GetLocalTime( &stNow );
    SystemTimeToFileTime( &stNow, &ftNow );
    
    // lock held during entire traversal
    EnterCriticalSection( &gcsTaskQueue );
    
    __try
    {
        //
        // Traverse table
        //
        for (ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart), count = 0;
             (NULL != ptqe) && !gfTqShutdownRequested;
             ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart), count++)
        {
            if (count >= gDebugPrintTaskQueueMaxEntries) {
                // don't print more than max entries
                DebPrint(0, "more entries...\n", NULL, 0);
                break;
            }

            //calculate registered time = current time - tick difference
            cTickDiff = cTickNow - ptqe->cTickRegistered;

            //copy FILETIME to ULARGE_INTEGER
            uliTime.LowPart =  ftNow.dwLowDateTime;
            uliTime.HighPart = ftNow.dwHighDateTime;

            //64-bit substraction, 1 tick = 1 ms = 10000 100-nanosec
            uliTime.QuadPart -= (ULONGLONG)cTickDiff * 10000;

            //copy ULARGE_INTEGER back to FILETIME
            ft.dwLowDateTime = uliTime.LowPart;
            ft.dwHighDateTime = uliTime.HighPart;

            //convert the file time to system time
            FileTimeToSystemTime( &ft, &st );

            sprintf(schedTime, "%02d:%02d:%02d.%03d", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

            // compute exec time
            //64-bit addition, 1 tick = 1 ms = 1000 100-nanosec
            uliTime.QuadPart += (ULONGLONG)ptqe->cTickDelay * 10000;

            //copy ULARGE_INTEGER back to FILETIME
            ft.dwLowDateTime = uliTime.LowPart;
            ft.dwHighDateTime = uliTime.HighPart;

            //convert the file time to system time
            FileTimeToSystemTime( &ft, &st );

            sprintf(execTime, "%02d:%02d:%02d.%03d", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

            // now can print
            DebPrint(0, "%12s %-30s %p %6d %12s\n", NULL, 0, 
                     execTime, ptqe->pfnName, ptqe->pvTaskParm, ptqe->cTickDelay/1000, schedTime);
        }
    }
    __finally
    {
        // regardless, release
        LeaveCriticalSection( &gcsTaskQueue );
    }
}
#endif

// Default compare function to match TQ entries by name and param
BOOL TaskQueueNameMatched(
    IN  PCHAR  pParam1Name,
    IN  void  *pParam1,
    IN  PCHAR  pParam2Name,
    IN  void  *pParam2,
    IN  void  *pContext
    )
{
    Assert(pParam1Name && pParam2Name);
    // in most cases, pParamName is a constant string. We assume the compiler
    // will reuse the string constants in most cases.
    return (pParam1Name == pParam2Name || strcmp(pParam1Name, pParam2Name) == 0) && pParam1 == pParam2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\stubs\stubs.c ===
/* Copyright 1998-2000, Microsoft Corp.  All Rights Reserved */
/*
   This file contains stubbed out versions of routines that exist in
   ntdsa.dll, but that we do not want to link to and/or properly initialize
   in mkdit and mkhdr.  For every set of routines added into this file, one
   library should be omitted from the UMLIBS section of the boot\sources file.
 */
#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                   // schema cache
#include <dbglobal.h>                 // The header for the directory database
#include <mdglobal.h>                 // MD global definition header
#include <dsatools.h>                 // needed for output allocation
#include "dsevent.h"                  // header Audit\Alert logging
#include "mdcodes.h"                  // header for error codes
#include "dsexcept.h"
#include "debug.h"                    // standard debugging header

DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }
int DBAddSess(JET_SESID sess, JET_DBID dbid) { return 0; }


//
// Stubs for event logging functions from dsevent.lib.
//

DS_EVENT_CONFIG DsEventConfig = {0};
DS_EVENT_CONFIG * gpDsEventConfig = &DsEventConfig;

void __fastcall DoLogUnhandledError(unsigned long ulID, int iErr, int iIncludeName)
{ ; }

BOOL DoLogOverride(DWORD fileno, ULONG sev)
{ return FALSE; }

BOOL DoLogEvent(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, int iIncludeName,
    char *arg1, char *arg2, char *arg3, char *arg4,
    char *arg5, char *arg6, char *arg7, char *arg8,
    DWORD cbData, VOID * pvData)
{ return TRUE; }

BOOL DoLogEventW(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, int iIncludeName,
    WCHAR *arg1, WCHAR *arg2, WCHAR *arg3, WCHAR *arg4,
    WCHAR *arg5, WCHAR *arg6, WCHAR *arg7, WCHAR *arg8,
    DWORD cbData, VOID * pvData)
{ return TRUE; }

BOOL DoAlertEvent(MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, ...)
{ return FALSE; }

BOOL DoAlertEventW(MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, ...)
{ return FALSE; }

VOID RegisterLogOverrides(void)
{ ; }

void UnloadEventTable(void)
{ ; }

HANDLE LoadEventTable(void)
{ return NULL; }

PSID GetCurrentUserSid(void)
{ return NULL; }

VOID DoLogEventAndTrace(IN PLOG_PARAM_BLOCK LogBlock)
{ ; }

DS_EVENT_CONFIG * DsGetEventConfig(void)
{ return gpDsEventConfig; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\dynarray.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    dynarray.h

Abstract:

    This file contains the definition of a dynamic array data type.

Author:

    Colin Brace ColinBr
    
Revision History

    3-12-97   ColinBr    Created
    
--*/

#ifndef __DYNARRAY_H
#define __DYNARRAY_H

VOID
DynamicArrayInit(
    IN PDYNAMIC_ARRAY a
    );

VOID
DynamicArrayDestroy(
    IN PDYNAMIC_ARRAY a
    );

DWORD
DynamicArrayGetCount(
    IN PDYNAMIC_ARRAY a
    );

VOID
DynamicArrayAdd(
    IN PDYNAMIC_ARRAY a,
    IN VOID*          pElement
    );

VOID*
DynamicArrayRetrieve(
    IN PDYNAMIC_ARRAY a,
    IN ULONG          Index
    );

VOID
DynamicArrayRemove(
    IN PDYNAMIC_ARRAY a,
    IN VOID*          pElement, OPTIONAL
    IN ULONG          Index
    );

#endif // __DYNARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\schedman.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    schedman.h

Abstract:

    This file contains the definition of various structures used for the schedule
    cache.  These structures should be considered totally opaque -- the user
    cannot see their internal structure.

    These structures could be defined inside schedman.c, except we want them to
    be visible to 'dsexts.dll', the debugger extension.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    14-7-2000   NickHar   Created

--*/


/***** Header Files *****/
#include <ntrtl.h>


/***** Constants *****/
/* Magic numbers to ensure consistency of the Topl structures */
#define MAGIC_START 0xDEADBEEF
#define MAGIC_END   0x5EAC1C9
#define TOPL_ALWAYS_SCHEDULE         NULL


/***** ToplSched *****/
/* The internal definition of a schedule object */
typedef struct {
    LONG32      magicStart;
    PSCHEDULE   s;
    DWORD       duration;               /* Calculated when schedule is created */
    LONG32      magicEnd;
} ToplSched;


/***** ToplSchedCache *****/
/* The internal definition of a schedule cache */
typedef struct {
    LONG32              magicStart;
    RTL_GENERIC_TABLE   table;
    DWORD               numEntries;
    BOOLEAN             deletionPhase;      /* True if the schedule cache is being deleted */
    PSCHEDULE           pAlwaysSchedule;    /* A cached copy of the always Pschedule. This is
                                             * needed as a special case because the always
                                             * schedule is the only one not actually stored
                                             * in the cache. */
    LONG32              magicEnd;
} ToplSchedCache;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\stalg.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stalg.h

Abstract:

    This file contains the definition of various structures used in W32TOPL's
    new spanning tree algorithms. These structures should be considered totally
    opaque -- the user cannot see their internal structure.

    These structures could be defined inside stalg.c, except we want them to
    be visible to 'dsexts.dll', the debugger extension.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    10-7-2000   NickHar   Created

--*/


/***** Header Files *****/
#include <w32topl.h>
#include "stda.h"

#ifndef STALG_H
#define STALG_H

/***** ToplVertex *****/
/* Contains basic information about a vertex: id, name, edge list.
 * Also stores some data used by the internal algorithms. */
struct ToplVertex {
    /* Unchanging vertex data */
    DWORD                   vtxId;          /* Always equal to the vertex index in g's
                                             * array of vertices */
    PVOID                   vertexName;     /* Pointer to name provided by user */

    /* Graph data */
    DynArray                edgeList;       /* Unordered PTOPL_MULTI_EDGE list */
    TOPL_VERTEX_COLOR       color;
    DWORD                   acceptRedRed;   /* Edge restrictions for colored vertices */
    DWORD                   acceptBlack;
    
    TOPL_REPL_INFO          ri;             /* Replication-type data */

    /* Dijkstra data */
    int                     heapLocn;
    struct ToplVertex*      root;           /* The closest colored vertex */
    BOOL                    demoted;

    /* Kruskal data */
    int                     componentId;    /* The id of the graph component we live in.
                                               -1 <= componentId < n, where n = |V|   */
    DWORD                   componentIndex; /* The index of the graph component.
                                                0 <= componentIndex < numComponents   */

    /* DFS data (for finding one-way black-black edges */
    DWORD                   distToRed;      /* What is the distance in the spanning tree from
                                             * this vertex to the nearest red vertex. */
    struct ToplVertex*      parent;         /* The parent of this vertex in the spanning-tree */
    DWORD                   nextChild;      /* The next child to check in the DFS */
};
typedef struct ToplVertex ToplVertex;
typedef ToplVertex *PToplVertex;


/***** ToplGraphState *****/
/* An opaque structure -- visible externally, but internals are not visible.
 * This structure stores the entire state of a topology graph and its
 * related structures. */
typedef struct {
    LONG32                  magicStart;
    PVOID*                  vertexNames;    /* Names, as passed in by the user */
    ToplVertex*             vertices;       /* For each vtx we have an internal structure */
    DWORD                   numVertices;
    BOOLEAN                 melSorted;      /* Has the master edge list been sorted yet? */
    DynArray                masterEdgeList; /* Unordered list of edges */
    DynArray                edgeSets;       /* List of all edge sets */
    TOPL_COMPARISON_FUNC    vnCompFunc;     /* User's function to compare vertex names */
    TOPL_SCHEDULE_CACHE     schedCache;     /* Schedule cache, provided by user */ 
    LONG32                  magicEnd;
} ToplGraphState;
typedef ToplGraphState *PToplGraphState;


/***** ToplInternalEdge *****/
/* This structure represents a path which we found in the graph from v1 to v2.
 * Both v1 and v2 are colored vertices. We represent this path by an edge, which we
 * pass as input to Kruskal's alg. */
typedef struct {
    PToplVertex             v1, v2;         /* The endpoints of the path */
    BOOLEAN                 redRed;         /* True if both endpoints are red */
    TOPL_REPL_INFO          ri;             /* Combined replication info for the v1-v2 path */
    DWORD                   edgeType;       /* All path edges must have same type. Range: 0-31 */
} ToplInternalEdge;
typedef ToplInternalEdge *PToplInternalEdge;


#endif /* STALG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\schedman.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    schedman.c

Abstract:

    This file implements a schedule cache, and several 'helper' function to
    manipulate them. The cache is implemented using an efficient dictionary,
    provided by ntrtl.h.

Notes:
    
    'Always schedules' (schedules whose bits are all 1) are represented by
    a NULL pointer. (This is so that that site links without schedules default
    to an always schedule). Always schedules are never stored in the cache.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    13-6-2000   NickHar   Created
    
--*/

/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <minmax.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "schedman.h"


/***** Constants *****/
/* Constants for the ToplScheduleCreate() function */
#define DEFAULT_INTERVAL 12          /* Three hours */
#define STARTING_INTERVAL 0          /* Default schedules start at 12am Sun morning */
#define SCHED_NUMBER_INTERVALS_DAY   (4 * 24)
#define SCHED_NUMBER_INTERVALS_WEEK  (7 * SCHED_NUMBER_INTERVALS_DAY)
#define TOPL_ALWAYS_DURATION         (15*SCHED_NUMBER_INTERVALS_WEEK)


/***** CalculateDuration *****/
/* Given a schedule, determine for how many minutes this schedule is available.
 * We do this by counting bits in the schedule data.
 * The format of this schedule should have been checked already. */
DWORD
CalculateDuration(
    IN PSCHEDULE schedule
    )
{
    /* Quick way to count the number of 1 bits in a nibble: use a table */
    const int BitCount[16] = { 
        /* 0000 */  0,       /* 0001 */  1,
        /* 0010 */  1,       /* 0011 */  2,
        /* 0100 */  1,       /* 0101 */  2,
        /* 0110 */  2,       /* 0111 */  3,
        /* 1000 */  1,       /* 1001 */  2,
        /* 1010 */  2,       /* 1011 */  3,
        /* 1100 */  2,       /* 1101 */  3,
        /* 1110 */  3,       /* 1111 */  4
    };
    DWORD cbSchedData, iByte, count;
    const unsigned char DataBitMask = 0xF;
    PBYTE pb;

    cbSchedData = SCHEDULE_DATA_ENTRIES;
    pb = ((unsigned char*) schedule) + schedule->Schedules[0].Offset;

    count = 0;
    for( iByte=0; iByte<cbSchedData; iByte++ ) {
        count += BitCount[ pb[iByte]&DataBitMask ];
    }

    return 15*count;
}


/***** CheckPSchedule *****/
/* Checks that a PSchedule has the format that we expect:
 * there is exactly one schedule header, of type SCHEDULE_INTERVAL,
 * and the structure has the proper size. If the pschedule is NULL
 * or in an unsupported format, we throw an exception. */
VOID
CheckPSchedule(
    IN PSCHEDULE s
    )
{
    if( s==NULL ) {
        ToplRaiseException( TOPL_EX_SCHEDULE_ERROR );
    }

    /* We only support schedules in the exact format that the KCC creates. */
    if( s->Size != sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES
        || s->NumberOfSchedules != 1
        || s->Schedules[0].Type != SCHEDULE_INTERVAL
        || s->Schedules[0].Offset != sizeof(SCHEDULE) )
    {
        ToplRaiseException( TOPL_EX_SCHEDULE_ERROR );
    }
}


/***** CheckSchedule *****/
/* This function is used to check schedules before use. We throw an exception
 * if the schedule is not valid. If the schedule is okay, it is cast to the
 * internal representation.
 * The Schedule passed in should not be NULL. NULL schedules, which represent
 * the always schedule, should be handled as a special case by the caller. */
ToplSched*
CheckSchedule(
    IN TOPL_SCHEDULE Schedule
    )
{
    ToplSched *schedule = (ToplSched*) Schedule;
    PSCHEDULE s;

    ASSERT( Schedule!=NULL );
    if( schedule->magicStart!=MAGIC_START || schedule->magicEnd!=MAGIC_END ) {
        ToplRaiseException( TOPL_EX_SCHEDULE_ERROR );
    }

    CheckPSchedule( schedule->s );
    return schedule;
}


#if DBG

/***** CheckAlwaysSchedule *****/
/* Check that the always schedule is intact. DBG builds only. */
void
CheckAlwaysSchedule(
    IN ToplSchedCache *scheduleCache
    )
{
    const unsigned char OpenHour=0x0F;
    PSCHEDULE s;
    DWORD iByte;
    unsigned char *pb;

    s = scheduleCache->pAlwaysSchedule;
    
    pb = ((unsigned char*) s) + s->Schedules[0].Offset;
    for( iByte=0; iByte<SCHEDULE_DATA_ENTRIES; iByte++ ) {
        ASSERT( pb[iByte] == OpenHour );
    }
}

#endif


/***** CheckScheduleCache *****/
/* This function is used to schedule a schedule cache before use. We throw
 * an exception if the schedule cache is not valid. If the schedule is okay,
 * it is cast to the internal representation. */
ToplSchedCache*
CheckScheduleCache(
    IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    ToplSchedCache *scheduleCache = (ToplSchedCache*) ScheduleCache;

    if( scheduleCache==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    if( scheduleCache->magicStart!=MAGIC_START
     || scheduleCache->magicEnd!=MAGIC_END ) {
        ToplRaiseException( TOPL_EX_CACHE_ERROR );
    }
    CheckPSchedule(scheduleCache->pAlwaysSchedule);

    #if DBG
        CheckAlwaysSchedule(scheduleCache);
    #endif

    return scheduleCache;
}


/***** TableCompare *****/
/* This function checks the actual bitmaps of two schedules to see if
 * they represent the same schedule. Both schedules are in the internal
 * representation, a ToplSched structure. This function is used by the
 * RTL table functions.
 *
 * Preconditions:
 *
 *      Both schedules have successfully passed the CheckSchedule()
 *      function. We don't check that in here for efficiency reasons,
 *      except on DBG builds.
 */
RTL_GENERIC_COMPARE_RESULTS
NTAPI TableCompare(
    RTL_GENERIC_TABLE *Table,
    PVOID Item1, PVOID Item2
	)
{
    ToplSchedCache      *scheduleCache;
	ToplSched           *Schedule1 = (ToplSched*) Item1,
                        *Schedule2 = (ToplSched*) Item2;
    PSCHEDULE           s1, s2;
    unsigned char       *pb1, *pb2;
    const unsigned char DataBitMask = 0x0F;
    DWORD               iByte, cbSchedData;

    /* The always schedule cannot be stored in the cache */
    ASSERT( Item1 != TOPL_ALWAYS_SCHEDULE );
    ASSERT( Item2 != TOPL_ALWAYS_SCHEDULE );

    #ifdef DBG
        scheduleCache = CheckScheduleCache( Table->TableContext );
        if( ! scheduleCache->deletionPhase ) {
            __try {
                CheckSchedule( Schedule1 );
                CheckSchedule( Schedule2 );
            } __except( EXCEPTION_EXECUTE_HANDLER ) {
                /* If the above checks don't pass, it's a bug. */
                ASSERT(0);  
            }
        }
    #endif
    
    s1 = Schedule1->s;
    s2 = Schedule2->s;
    cbSchedData = SCHEDULE_DATA_ENTRIES;

    pb1 = ((unsigned char*) s1) + s1->Schedules[0].Offset;
    pb2 = ((unsigned char*) s2) + s2->Schedules[0].Offset;
    
    for( iByte=0; iByte<cbSchedData; iByte++ ) {
        if( (pb1[iByte] & DataBitMask) < (pb2[iByte] & DataBitMask) ) {
            return GenericLessThan;
        } else if( (pb1[iByte] & DataBitMask) > (pb2[iByte] & DataBitMask) ) {
            return GenericGreaterThan;
        }
    }

    return GenericEqual;
}


/***** TableAlloc *****/
/* This function is used as the allocator for the RTL table */
static PVOID
NTAPI TableAlloc( RTL_GENERIC_TABLE *Table, CLONG ByteSize )
{
    return ToplAlloc( ByteSize );
}


/***** TableFree *****/
/* This function is used as the deallocator for the RTL table */
static VOID
NTAPI TableFree( RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
    ToplFree( Buffer );
}


/***** CreateAlwaysSchedule *****/
/* Allocate and initialize a PSCHEDULE which is always available. */
PSCHEDULE
CreateAlwaysSchedule(
    VOID
    )
{
    const unsigned char OpenHour=0x0F;
    DWORD iByte, cbSchedule, cbSchedData;
    unsigned char *pb;
    PSCHEDULE s;

    /* Create a new schedule */
    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    cbSchedData = SCHEDULE_DATA_ENTRIES;
    s = (SCHEDULE*) ToplAlloc( cbSchedule );

    /* Set up the header for s */
    s->Size = cbSchedule;
    s->NumberOfSchedules = 1;
    s->Schedules[0].Type = SCHEDULE_INTERVAL;
    s->Schedules[0].Offset = sizeof(SCHEDULE);

    /* Set the schedule data to be all open */
    pb = ((unsigned char*) s) + s->Schedules[0].Offset;
    for( iByte=0; iByte<cbSchedData; iByte++ ) {
        pb[iByte] = OpenHour;
    }

    return s;
}


/***** ToplScheduleCacheCreate *****/
/* Create a cache, and create the RTL table to store cache entries */
TOPL_SCHEDULE_CACHE
ToplScheduleCacheCreate(
    VOID
    )
{
    ToplSchedCache*     scheduleCache;

    scheduleCache = ToplAlloc( sizeof(ToplSchedCache) );

    /* Create the RTL table we will use to store the cache elements */
    RtlInitializeGenericTable( &scheduleCache->table, TableCompare,
        TableAlloc, TableFree, scheduleCache );

    /* Set up the main cache entries. We store a single copy of an
     * 'always available' PSchedule so that it can be passed as a
     * return value from ToplScheduleExportReadonly(). */
    scheduleCache->numEntries = 0;
    scheduleCache->deletionPhase = FALSE;
    scheduleCache->pAlwaysSchedule = CreateAlwaysSchedule();

    /* Set up the magic numbers */
    scheduleCache->magicStart = MAGIC_START;
    scheduleCache->magicEnd = MAGIC_END;

    CheckScheduleCache( scheduleCache );

    return scheduleCache;
}


/***** ToplScheduleCacheDestroy *****/
/* Destroy the cache Frees all storage occupied by the cache and any handles in
 * the cache. The TOPL_SCHEDULE objects are also freed, and should not be used
 * after destroying the cache that they live in.
 *
 * This is not elegant, but we manually enumerate through all table entries in
 * order to delete them. (It appears that we also have to search for an entry
 * in order to delete it). We must clear the entry's magic numbers before
 * deleting it (to catch illegal reuse of an object after the cache has been
 * destroyed). However, if we clear the magic numbers, the search function will
 * be unhappy, so we set a flag 'deletionPhase'. The search function will not
 * check magic numbers if this flag is true.
 */
VOID
ToplScheduleCacheDestroy(
    IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    ToplSchedCache* scheduleCache = CheckScheduleCache( ScheduleCache );
    ToplSched* schedule;
    PSCHEDULE s;
    
    scheduleCache->deletionPhase = TRUE;

    while( ! RtlIsGenericTableEmpty(&scheduleCache->table) ) {

        schedule = (ToplSched*) RtlGetElementGenericTable( &scheduleCache->table, 0 );
        if( TOPL_ALWAYS_SCHEDULE==schedule ) {
            ASSERT(!"RtlGetElementGenericTable() returned NULL but table was not empty");
            break;
        }
        CheckSchedule( schedule );
        s = schedule->s;

        schedule->magicStart = 0;
        schedule->magicEnd = 0;
        RtlDeleteElementGenericTable( &scheduleCache->table, schedule );

        ToplFree(s);
    }
    
    ToplFree( scheduleCache->pAlwaysSchedule );
    scheduleCache->pAlwaysSchedule = NULL;
    scheduleCache->numEntries = 0;
    scheduleCache->magicStart = scheduleCache->magicEnd = 0;
    ToplFree( scheduleCache );
}


/***** ToplScheduleImport *****/
/* Store a schedule in the cache, either by creating a new entry, or
 * reusing an identical entry which is already in the cache. The
 * pExternalSchedule parameter is copied into the cache, and may be
 * immediately freed by the caller.
 * 
 * Note: If pExternalSchedule is NULL, this is interpreted as the 
 * always schedule and TOPL_ALWAYS_SCHEDULE is returned as a result. */
TOPL_SCHEDULE
ToplScheduleImport(
    IN TOPL_SCHEDULE_CACHE ScheduleCache,
    IN PSCHEDULE pExternalSchedule
    )
{
    ToplSchedCache* scheduleCache = CheckScheduleCache( ScheduleCache );
    ToplSched searchKey, *cachedSched;
    PSCHEDULE newSchedule=NULL;
    BOOLEAN newElement=FALSE;
    DWORD cbSchedule, duration;
    
    /* NULL schedules are a special case -- they are the always schedule */
    if( pExternalSchedule==NULL ) {
        return TOPL_ALWAYS_SCHEDULE;
    }
    CheckPSchedule( pExternalSchedule );

    /* Check for an all-ones schedule */
    duration = CalculateDuration( pExternalSchedule );
    if( duration==TOPL_ALWAYS_DURATION ) {
        return TOPL_ALWAYS_SCHEDULE;
    }
    
    /* Create a copy of the external schedule, assuming we need to store
     * it in the cache */
    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    newSchedule = (PSCHEDULE) ToplAlloc( cbSchedule );
    RtlCopyMemory( newSchedule, pExternalSchedule, cbSchedule );
    
    /* Create a search key containing the copy of the new schedule. This search
     * key is just a dummy. Its contents will be copied into the table. */
    searchKey.magicStart = MAGIC_START;
    searchKey.s = newSchedule;
    searchKey.duration = duration;
    searchKey.magicEnd = MAGIC_END;
    
    __try {
        
        /* Search our cache table for a schedule which matches this one */
        cachedSched = (ToplSched*) RtlInsertElementGenericTable(
            &scheduleCache->table, &searchKey, sizeof(ToplSched), &newElement );
        
        if( newElement ) {
            /* No cached copy existed, so a new copy has been added to the cache */
            scheduleCache->numEntries++;
        }
    }
    __finally {
        /* If RtlInsertElementGenericTable() throws an exception, or if the
         * schedule was already in the cache, we must free the memory used by
         * the new schedule allocated above. */
        if( AbnormalTermination() || newElement==FALSE ) {
            ToplFree( newSchedule );
        }
    }
    
    return cachedSched;
}


/***** ToplScheduleNumEntries *****/
/* Returns a count of how many unique schedules are stored in the cache.
 * Note: this count does not include any always schedules that were
 * imported into the cache. */
DWORD
ToplScheduleNumEntries(
    IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    ToplSchedCache* scheduleCache = CheckScheduleCache( ScheduleCache );
    return scheduleCache->numEntries;
}


/***** ToplScheduleExportReadonly *****/
/* This function is used to grab the PSCHEDULE structure from a
 * TOPL_SCHEDULE. The structure should be considered readonly by
 * the user, and should _not_ be deallocated by him (or her).
 * Note: If the input is TOPL_ALWAYS_SCHEDULE, a properly constructed
 * PSCHEDULE _will_ be returned. */
PSCHEDULE
ToplScheduleExportReadonly(
    IN TOPL_SCHEDULE_CACHE ScheduleCache,
    IN TOPL_SCHEDULE Schedule
    )
{
    ToplSchedCache *scheduleCache = CheckScheduleCache( ScheduleCache );
    ToplSched* schedule;
    PSCHEDULE pExportSchedule;

    if( Schedule==TOPL_ALWAYS_SCHEDULE ) {
        pExportSchedule = scheduleCache->pAlwaysSchedule;
    } else {
        schedule = CheckSchedule( Schedule );
        pExportSchedule = schedule->s;
    }

    ASSERT( NULL!=pExportSchedule );
    return pExportSchedule;
}


/***** ToplScheduleMerge *****/
/* Return a new cached schedule which is the intersection of the two provided 
 * schedules. If the two schedules do not intersect, the fIsNever flag is set
 * to true. */
TOPL_SCHEDULE
ToplScheduleMerge(
    IN TOPL_SCHEDULE_CACHE ScheduleCache,
    IN TOPL_SCHEDULE Schedule1,
    IN TOPL_SCHEDULE Schedule2,
    OUT PBOOLEAN fIsNever
	)
{
    TOPL_SCHEDULE result=NULL;
    DWORD iByte, cbSchedule, cbSchedData;
    const unsigned char DataBitMask=0xF, HighBitMask=0xF0;
    unsigned char *pb1, *pb2, *pb3, dataAnd, nonEmpty;
    PSCHEDULE s1=NULL, s2=NULL, s3=NULL;

    /* Check parameters */
    CheckScheduleCache( ScheduleCache );
    if( Schedule1!=TOPL_ALWAYS_SCHEDULE ) {
        s1 = CheckSchedule( Schedule1 )->s;
    }
    if( Schedule2!=TOPL_ALWAYS_SCHEDULE ) {
        s2 = CheckSchedule( Schedule2 )->s;
    }
    if( fIsNever==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }

    /* If either schedule is the always schedule, we can just return the
     * other schedule straight away. */ 
    if( Schedule1==TOPL_ALWAYS_SCHEDULE ) {
        *fIsNever=FALSE;
        return Schedule2;
    }
    if( Schedule2==TOPL_ALWAYS_SCHEDULE ) {
        *fIsNever=FALSE;
        return Schedule1;
    }

    /* Create a new schedule to store the AND of s1 and s2 */
    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    cbSchedData = SCHEDULE_DATA_ENTRIES;
    s3 = (PSCHEDULE) ToplAlloc( cbSchedule );
    RtlCopyMemory( s3, s1, sizeof(SCHEDULE) );

    pb1 = ((unsigned char*) s1) + s1->Schedules[0].Offset;
    pb2 = ((unsigned char*) s2) + s2->Schedules[0].Offset;
    pb3 = ((unsigned char*) s3) + s3->Schedules[0].Offset;

    nonEmpty = 0;
    for( iByte=0; iByte<cbSchedData; iByte++ ) {
        /* Just take the high nibble from the first schedule. The ISM does the
         * same thing. AND together the low nibble from Schedule1 and Schedule2 */
        dataAnd = (pb1[iByte]&DataBitMask) & (pb2[iByte]&DataBitMask);
        pb3[iByte] = dataAnd | ( pb1[iByte] & HighBitMask );
        nonEmpty |= dataAnd;
    }

    /* Convert the schedule to the Topl format, store it in
     * the cache, and return it to the caller. */
    __try {
        result = ToplScheduleImport( ScheduleCache, s3 );
    } __finally {
        ToplFree( s3 );
    }

    *fIsNever= !nonEmpty;
    return result;
}


#if DBG
/***** CreateDefaultSchedule *****/
/* Create a new schedule in the cache according to the replication interval. 
 *
 * We start with a fully available schedule.
 * Our algorithm is for the cost to represent the separation between the
 * polling intervals.
 *
 * We calculate out the polling intervals for the entire week and don't
 * guarantee that there always is a polling interval each day.  A sufficiently
 * large cost could skip a day.
 *
 * Where it makes sense, we start at 1am just like Exchange does.
 *
 * ReplInterval is in minutes.  It is converted to 15 min chunks as follows:
 * 0 - default, 12 chunks, or 3 hours
 * 1 - 15, 1
 * 16 - 30, 2
 * etc
 *
 * Note: This code was taken from the KCC's original schedule handling code.
 */
TOPL_SCHEDULE
CreateDefaultSchedule(
    IN TOPL_SCHEDULE_CACHE ScheduleCache,
    IN DWORD IntervalInMinutes
    )
{
    TOPL_SCHEDULE result=NULL;
    ToplSched  *internalSched;
    PSCHEDULE  schedule = NULL;
    int        Number15MinChunkToSkip = (IntervalInMinutes + 14) / 15;
    int        startingInterval, cbSchedule, i, hour, subinterval;
    PBYTE      pbSchedule;

    // A skip of 0 means to take the default, every 3 hours
    if (0 == Number15MinChunkToSkip) {
        Number15MinChunkToSkip = DEFAULT_INTERVAL;
    }

    // Always start immediately (Sunday morning, 12am)
    startingInterval = STARTING_INTERVAL;

    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    schedule = (SCHEDULE*) ToplAlloc( cbSchedule );

    // Zero the buffer
    RtlZeroMemory( schedule, cbSchedule );

    schedule->Size = cbSchedule;
    schedule->NumberOfSchedules = 1;
    schedule->Schedules[0].Type = SCHEDULE_INTERVAL;
    schedule->Schedules[0].Offset = sizeof(SCHEDULE);

    pbSchedule = ((PBYTE) schedule) + schedule->Schedules[0].Offset;

    // Initialize a new schedule with a repeating poll every n intervals
    for (i = startingInterval;
         i < SCHED_NUMBER_INTERVALS_WEEK;
         i += Number15MinChunkToSkip )
    {
        hour = i / 4;
        subinterval = i % 4;
        pbSchedule[hour] |= (1 << subinterval);
    }

    /* Convert the schedule to our internal format, store it in
     * the cache, and return it to the caller. */
    __try {
        result = ToplScheduleImport( ScheduleCache, schedule );
    } __finally {
        ToplFree( schedule );
    }

    return result;
}


/***** OldScheduleCreate *****/
/* This is the old function that was used to make replication schedules
 * from availability schedules. For now, let's keep this around so we can
 * verify that the new function has the same behavior. */
TOPL_SCHEDULE
OldScheduleCreate(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN DWORD IntervalInMinutes,
	IN TOPL_SCHEDULE TemplateSchedule OPTIONAL
	)
{
    TOPL_SCHEDULE result=NULL;
    ToplSched *tempSchedule;
    PSCHEDULE  schedule = NULL;
    int        Number15MinChunkToSkip = (IntervalInMinutes + 14) / 15;
    int        startingInterval, cbSchedule, i, hour, subinterval, mask;
    PBYTE      pbOldSchedule, pbNewSchedule;

    if( TemplateSchedule!=NULL && TemplateSchedule!=TOPL_ALWAYS_SCHEDULE ) {
        tempSchedule = CheckSchedule( TemplateSchedule );
    } else {
        return CreateDefaultSchedule( ScheduleCache, IntervalInMinutes );
    }

    // A skip of 0 means to take the default, every 3 hours
    if (0 == Number15MinChunkToSkip) {
        Number15MinChunkToSkip = DEFAULT_INTERVAL;
    }

    // If the interval is 1, just take the old schedule unaltered
    if (Number15MinChunkToSkip <= 1) {
        return TemplateSchedule;
    }

    // Allocate a new schedule
    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    schedule = (SCHEDULE*) ToplAlloc( cbSchedule );

    // Transform the schedule according to the replication interval
    RtlCopyMemory( schedule, tempSchedule->s, sizeof( SCHEDULE ) );

    pbOldSchedule = ((PBYTE) tempSchedule->s) + tempSchedule->s->Schedules[0].Offset;
    pbNewSchedule = ((PBYTE) schedule) + schedule->Schedules[0].Offset;
    
    // Initialize; preserve high order nybble for control info
    for( hour = 0; hour < SCHEDULE_DATA_ENTRIES; hour++ ) {
        pbNewSchedule[hour] = pbOldSchedule[hour] & 0xf0;
    }

    
    // Look for an open slot. Mark the next one we come to. Skip
    // forward n slots. Repeat.
    i = 0;
    while (i < SCHED_NUMBER_INTERVALS_WEEK)
    {
        hour = i / 4;
        subinterval = i % 4;
        mask = (1 << subinterval);

        if (pbOldSchedule[hour] & mask) {
            pbNewSchedule[hour] |= mask;
            i += Number15MinChunkToSkip;
        } else {
            i++;
        }
    }

    /* Convert the schedule to our internal format, store it in
     * the cache, and return it to the caller. */
    __try {
        result = ToplScheduleImport( ScheduleCache, schedule );
    } __finally {
        ToplFree( schedule );
    }


    return result;
}
#endif


// Note on bit-ordering:
//
// Although I haven't seen this clearly defined anywhere,  I believe
// that the least-significant-bit in each byte corresponds to the first
// 15-minute interval of the hour.
//
// Example: Consider the following schedule data: 0F 00 01 0F...
// This example schedule contains a 1 hour period of unavailability
// and a separate 45 min period of unavailability.


/***** GetBit *****/
/* Get a single bit in the schedule data pointed to by 'pb'.
 * Chunk denotes the index of the 15-bit interval to change. */
char __forceinline GetBit(PBYTE pb, int chunk) {
    DWORD hour, subinterval, bitMask;
    const DWORD dataMask = 0xF;

    ASSERT( chunk<SCHED_NUMBER_INTERVALS_WEEK );

    hour = chunk >> 2;
    subinterval = chunk & 0x3;
    bitMask = 1 << subinterval;

    return !! ( pb[hour] & dataMask & bitMask );
}


/***** SetBit *****/
/* Set a single bit to true in the schedule data pointed to by 'pb'.
 * Chunk denotes the index of the 15-bit interval to change. */
void __forceinline SetBit(PBYTE pb, int chunk) {
    DWORD hour, subinterval, mask;

    ASSERT( chunk<SCHED_NUMBER_INTERVALS_WEEK );

    hour = chunk >> 2;
    subinterval = chunk & 0x3;
    mask = 1 << subinterval;

    ASSERT( hour<SCHEDULE_DATA_ENTRIES );
    
    pb[hour] |= mask;
}


/***** ConvertAvailSchedToReplSched *****/
/* This function walks through the template schedule, dividing it into
 * 'segments'. Recall that a 'chunk' is a 15-minute period in the schedule.
 *
 * Segments are disjoint intervals satisfying the following conditions:
 *   - The first chunk in each segment is marked as available in the
 *     availability schedule.
 *   - The number of chunks in every segment (except for possibly the last one)
 *     is segLengthMax. 
 * Note that there may be gaps between segments. 
 *
 * In each segment, we count the number of available chunks and select one
 * chunk in which replication will occur. */
void ConvertAvailSchedToReplSched(
    PBYTE pbAvailSchedule,
    PBYTE pbReplSchedule,
    DWORD maxSegLength,
    DWORD StaggeringNumber )
{
    int segStart, segEnd, segLength;
    int iChunk, numAvailChunks, iAvailChunk, replChunk;

    // We don't do much validation of input here -- all input should be verified
    // by ToplScheduleCreate. The most important parameter to check is maxSegLength
    // because if it is 0, we will loop forever.
    ASSERT( maxSegLength>0 );

    segStart = 0;
    for(;;) {
        // Search for the start of a segment
        while( segStart<SCHED_NUMBER_INTERVALS_WEEK
            && GetBit(pbAvailSchedule,segStart)==0 ) {
            segStart++;
        }
        if( segStart>=SCHED_NUMBER_INTERVALS_WEEK ) {
            return;     // No more segments could be found
        } else {
            // Schedule must be available at start of segment
            ASSERT( GetBit(pbAvailSchedule,segStart) );
        }

        // Compute the end of the segment
        segEnd = min(segStart+maxSegLength, SCHED_NUMBER_INTERVALS_WEEK)-1;
        ASSERT( segEnd>=segStart );

        // Count the number of available chunks in the segment
        numAvailChunks=0;
        for( iChunk=segStart; iChunk<=segEnd; iChunk++ ) {
            if( GetBit(pbAvailSchedule,iChunk) ) {
                numAvailChunks++;
            }
        }
        ASSERT( numAvailChunks>=1 );

        // Choose a time to replicate in the current segment
        replChunk = StaggeringNumber % numAvailChunks;

        // Set the n'th available chunk in the repl schedule where n=
        iAvailChunk=0;
        for( iChunk=segStart; iChunk<=segEnd; iChunk++ ) {
            if( GetBit(pbAvailSchedule,iChunk) ) {
                if( iAvailChunk==replChunk ) {
                    SetBit( pbReplSchedule, iChunk );
                    break;
                }
                iAvailChunk++;
            }
        }
        ASSERT( iChunk<=segEnd );

        // The next segment doesn't start until maxSegLength intervals after the
        // start of the current segment.
        segStart += maxSegLength; 
        ASSERT( segStart>segEnd );
    }
}


/***** ToplScheduleCreate *****/
/* Create a new replication schedule in the cache according to the criteria.
 * If the template schedule is given, it is treated as an availability schedule
 * and used as the basis for the replication schedule. If the template schedule
 * is not given, we assume that replication is available all the time. We
 * convert the basis schedule from a range of availability to a schedule of
 * replication times.
 *
 * If IntervalInMinutes > # minutes in schedule, only one will be set in
 * the new schedule.
 *
 * Since the schedule granularity is 15-minutes, the 'IntervalInMinutes'
 * parameter must be converted to into the number of 15-minute chunks to skip.
 * It is converted by rounding upwards. 0-minutes does not make sense, so it is
 * treated as the default value, which is 3 hours.
 */
TOPL_SCHEDULE
ToplScheduleCreate(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN DWORD IntervalInMinutes,
	IN TOPL_SCHEDULE TemplateSchedule OPTIONAL,
	IN DWORD StaggeringNumber
	)
{
    ToplSchedCache* scheduleCache = CheckScheduleCache( ScheduleCache );
    PSCHEDULE       tempPSched=NULL, newPSched=NULL;
    TOPL_SCHEDULE   newToplSched=NULL;
    ToplSched*      tempToplSched;
    int             Number15MinChunkToSkip;
    int             cbSchedule, hour;
    PBYTE           pbTempSchedule, pbNewSchedule;

    // IntervalInMinutes gives the replication interval in minutes. Convert
    // it to the number of 15-minute chunks to skip.
    if( 0==IntervalInMinutes ) {
        // A skip of 0 means to take the default, every 3 hours
        Number15MinChunkToSkip = DEFAULT_INTERVAL;
    } else {
        // Divide by 15 and round up
        Number15MinChunkToSkip = (IntervalInMinutes + 14) / 15;
    }

    // If the Number15MinChunk to skip is 1, we replicate all the time. In other words,
    // the replication schedule is identical to the availability schedule. We can just
    // return the template schedule here.
    if( Number15MinChunkToSkip <= 1 ) {
        return TemplateSchedule;
    }

    // If the template schedule is the 'always' schedule, grab the 'always'
    // PSCHEDULE from the cache and use it as a template.
    if( TemplateSchedule==TOPL_ALWAYS_SCHEDULE ) {
        tempPSched = scheduleCache->pAlwaysSchedule;
    } else {
        tempToplSched = CheckSchedule( TemplateSchedule );
        ASSERT( NULL!=tempToplSched );
        tempPSched = tempToplSched->s;
    }

    // Allocate a new schedule and initialize the header (exception is raised on failure)
    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    newPSched = (SCHEDULE*) ToplAlloc( cbSchedule );
    RtlCopyMemory( newPSched, tempPSched, sizeof( SCHEDULE ) );

    // Grab pointers to the schedules' data areas.
    pbTempSchedule = ((PBYTE) tempPSched) + tempPSched->Schedules[0].Offset;
    pbNewSchedule = ((PBYTE) newPSched) + newPSched->Schedules[0].Offset;
    
    // Preserve the template schedule's high-order nybble.
    for( hour=0; hour<SCHEDULE_DATA_ENTRIES; hour++ ) {
        pbNewSchedule[hour] = pbTempSchedule[hour] & 0xf0;
    }

    // Invoke ConvertAvailSchedToReplSched to do all the bit-mangling.
    ConvertAvailSchedToReplSched( pbTempSchedule, pbNewSchedule,
        Number15MinChunkToSkip, StaggeringNumber );

    // Convert the schedule to our internal format, store it in
    // the cache, and return it to the caller.
    __try {
        newToplSched = ToplScheduleImport( ScheduleCache, newPSched );
    } __finally {
        ToplFree( newPSched );
    }

    #if DBG
        // If the staggering number is 0, this function should return the same schedule
        // as the old code did.
        if( 0==StaggeringNumber ) {
            TOPL_SCHEDULE oldToplSched;
            oldToplSched = OldScheduleCreate(
                ScheduleCache,
                IntervalInMinutes,
                TemplateSchedule );
            ASSERT( newToplSched == oldToplSched );
        }
    #endif
    return newToplSched;
}


/***** ToplScheduleIsEqual *****/
/* This function indicates whether two schedule pointers refer to the same
 * schedule. */
BOOLEAN
ToplScheduleIsEqual(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN TOPL_SCHEDULE Schedule1,
	IN TOPL_SCHEDULE Schedule2
	)
{
    /* Check parameters */
    CheckScheduleCache( ScheduleCache );
    if( Schedule1 ) {
        CheckSchedule( Schedule1 );
    }
    if( Schedule2 ) {
        CheckSchedule( Schedule2 );
    }

    return (Schedule1 == Schedule2);
}


/***** ToplScheduleDuration *****/
/* Finds the duration of a schedule by simply checking the stored value.
 * This saves many potentially expensive calculations. The duration can
 * be easily calculated when the schedule is created. Duration is in minutes. */
DWORD
ToplScheduleDuration(
	IN TOPL_SCHEDULE Schedule
	)
{
    ToplSched *schedule;
    
    if( Schedule==TOPL_ALWAYS_SCHEDULE ) {
        return TOPL_ALWAYS_DURATION;
    } else {
        schedule = CheckSchedule( Schedule );
        return schedule->duration;
    }
}


/***** ToplScheduleMaxUnavailable *****/
/* Return the length in minutes of the longest contiguous period
 * of time for which the schedule is unavailable. */
DWORD
ToplScheduleMaxUnavailable(
	IN TOPL_SCHEDULE Schedule
	)
{
    const DWORD cBits = SCHED_NUMBER_INTERVALS_WEEK;

    ToplSched *schedule;
    PSCHEDULE pSchedule;
    PBYTE pb;
    DWORD iBit, endBit, maxLen=0;
    DWORD runStart, runLen, infLoopCheck=0;
    BOOL  inRun, finished;
    char bit;

    // If this is the always schedule, return the answer immediately.
    if( Schedule==TOPL_ALWAYS_SCHEDULE ) {
        return 0;
    }

    schedule = CheckSchedule( Schedule );
    pSchedule = schedule->s;
    pb = ((unsigned char*) pSchedule) + pSchedule->Schedules[0].Offset;

    // Look for a time when the schedule is available (if any)
    for( iBit=0; iBit<cBits; iBit++ ) {
        if(GetBit(pb,iBit)) break;
    }

    // We didn't find a period of availability. This means the schedule
    // is always unavailable.
    if( iBit==cBits ) {
        ASSERT( 0==ToplScheduleDuration(Schedule) );
        return TOPL_ALWAYS_DURATION;
    }

    // Walk through the bits, starting at this available bit we found,
    // wrapping around at the end, looking for unavailability periods.
    endBit = iBit++;
    inRun = finished = FALSE;
    do {
        ASSERT( infLoopCheck++ < 3*cBits );

        bit = GetBit(pb,iBit);
        if( inRun && bit ) {
            // The end of a run. Check the run's length.
            runLen = (iBit + cBits - runStart) % cBits;
            if(runLen>maxLen) maxLen=runLen;
            inRun = FALSE;
        } else if( !inRun && !bit ) {
            // The start of a run. Remember the starting bit.
            runStart = iBit;
            inRun = TRUE;
        }
        
        // Check to see if we're finished, and advance to the next bit
        if( iBit==endBit ) {
            finished = TRUE;
        }
        iBit=(iBit+1)%cBits;
    } while( !finished );

    return 15*maxLen;
}


/***** ToplGetAlwaysSchedule *****/
/* Return the 'always schedule' */
TOPL_SCHEDULE
ToplGetAlwaysSchedule(
	IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    return TOPL_ALWAYS_SCHEDULE;
}


/***** ToplScheduleValid *****/
/* Returns true if a topl schedule appears to be valid, false otherwise.
 * NULL schedules are accepted -- they are interpreted to mean the
 * 'always schedule'. */
BOOLEAN
ToplScheduleValid(
    IN TOPL_SCHEDULE Schedule
    )
{
    BOOLEAN result=FALSE;

    __try {
        if( Schedule!=TOPL_ALWAYS_SCHEDULE ) {
            CheckSchedule( Schedule );
        }
        result = TRUE;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = FALSE;
    }

    return result;
}


/***** ToplPScheduleValid *****/
/* Returns true if a pschedule is in a supported format, false otherwise. */
BOOLEAN
ToplPScheduleValid(
    IN PSCHEDULE Schedule
    )
{
    BOOLEAN result;

    __try {
        CheckPSchedule( Schedule );
        if( CalculateDuration(Schedule)==0 ) {
            result=FALSE;
        } else {
            result=TRUE;
        }
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = FALSE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\stda.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stda.h

Abstract:

    This file provides the interfaces for using dynamic arrays. A 'DynArray' is
    similar to a DYNAMIC_ARRAY, but differs in that objects can be stored, instead
    of pointers to objects. This can reduce the number of allocations we have to
    make.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    19-6-2000   NickHar   Created
    
--*/

#ifndef DYNARRAY_H
#define DYNARRAY_H

/***** Constants *****/
#define DYN_ARRAY_NOT_FOUND             (-1)

/***** DynArray *****/
typedef struct {
    DWORD       elementSize;            /* Size of a single element in bytes */
    DWORD       logicalElements;        /* The number of elements stored in the array */
    DWORD       physicalElements;       /* The number of elements we have allocated space for */
    PBYTE       data;                   /* Pointer to array data */
    BOOLEAN     fSorted;                /* Is this array in sorted order? */
} DynArray;
typedef DynArray *PDynArray;

typedef int (__cdecl *DynArrayCompFunc)(const void*, const void*);

/***** DynArrayInit *****/
/* Initialize a dynamic array. The 'allocationChunk' indicates how many new elements will
 * be allocated at a time when we allocate new memory. If this parameter is 0, a default
 * value will be used. */
VOID
DynArrayInit(
    DynArray    *d,
    DWORD       elementSize
    );

/***** DynArrayClear *****/
/* Clear all the entries from an array. The array must have been
 * initialized before calling this function. */
VOID
DynArrayClear(
    DynArray    *d
    );

/***** DynArrayDestroy *****/
VOID
DynArrayDestroy(
    DynArray    *d
    );

/***** DynArrayGetCount *****/
DWORD
DynArrayGetCount(
    DynArray    *d
    );

/***** DynArrayAppend *****/
/* Increase the size of the array, making room for (at least) one new element.
 * If newElementData is non-NULL, copy this data into the new spot.
 * Return a pointer to the memory for the newly allocated element. */
PVOID
DynArrayAppend(
    DynArray    *d,
    PVOID       newElementData
    );

/***** DynArrayRetrieve *****/
/* Retrieve the element at location index in array d. index _must_ be
 * between 0 and logicalSize-1.
 * Note: This function returns a pointer to the item which was inserted
 * into the array, and will never return NULL. */
PVOID
DynArrayRetrieve(
    DynArray    *d,
    DWORD       index
    );

/***** DynArraySort *****/
VOID
DynArraySort(
    DynArray    *d,
    DynArrayCompFunc cmp
    );

/***** DynArraySearch *****/
/* Search an array for an element. If the element is not found, returns
 * DYN_ARRAY_NOT_FOUND, otherwise returns the index of the element in
 * the array. The array must be in sorted order for this to work. */
int
DynArraySearch(
    DynArray    *d,
    PVOID       key,
    DynArrayCompFunc cmp
    );

#endif  /* DYNARRAY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\stalg.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stalg.c

Abstract:

    This file implements w32topl's new graph algorithm, which are used for
    calculating network topologies. The main function of interest here is
    ToplGetSpanningTreeEdgesForVtx(), which runs the algorithm and returns
    its output. The rest of the functions are concerned with setting up and
    freeing the algorithm's input.

    At a theoretical level, the problem that this algorithm solves is
    "Given a graph G, calculate a minimum-cost spanning tree of shortest-
    path between a subset of the vertices of G". The algorithm we employ
    here is a hybrid of Dijkstra's algorithm and Kruskal's algorithm.

    The algorithm also has extra functionality to handle specific details
    of the KCC problem. These include: edge sets, three different colors of
    vertices, edge types, and the ability for a vertex to reject certain types
    of edges.

    It is difficult to give an expression describing the performance of
    ToplGetSpanningTreeEdgesForVtx(), since the performance depends heavily
    on the input network topology. Assuming a constant bound on the number of
    vertices contained in an edge, an rough upper bound is:

        O( (s+1) * ( m + n*log(n) + m*log(m)*logStar(m) ) )
    
    where

        m = the number of multi-edges
        n = the number of vertices
        s = the number of edge sets

    For most cases, O( s*m*log(m) ) is a good estimate.


File Map:

    Headers
    Constants
    Macros

    Functions                          Externally
                                        Visible?

      CheckGraphState
      CheckMultiEdge
      CheckMultiEdgeSet
      InitializeVertex
      ToplMakeGraphState                  Yes 
      FindVertex                                          
      CreateMultiEdge                                          
      FreeMultiEdge                                          
      CopyReplInfo                                          
      ToplAddEdgeToGraph                  Yes 
      ToplEdgeSetVtx                    Yes 
      EdgePtrCmp                                          
      ToplAddEdgeSetToGraph               Yes
      VertexComp                                          
      VertexGetLocn                                          
      VertexSetLocn                                          
      InitColoredVertices                                          
      TableAlloc                                          
      TableFree                                          
      EdgeGetVertex                                          
      ClearEdgeLists
      SetupEdges                                          
      SetupVertices                                          
      SetupDijkstra                                          
      AddDWORDSat
      CombineReplInfo
      RaiseNonIntersectingException
      TryNewPath                                          
      Dijkstra
      AddIntEdge                                          
      ColorComp
      ProcessEdge                                          
      ProcessEdgeSet                                          
      GetComponent                                          
      EdgeCompare                                          
      AddOutEdge                                          
      Kruskal                                          
      DepthFirstSearch
      CalculateDistToRed
      CountComponents
      ScanVertices
      SwapFilterVertexToFront
      ConstructComponents
      CopyOutputEdges                                          
      ClearInternalEdges                                          
      CheckAllMultiEdges                                          
      ToplGetSpanningTreeEdgesForVtx      Yes                                 
      ToplDeleteSpanningTreeEdges         Yes                              
      ToplDeleteComponents                Yes
      ToplDeleteGraphState                Yes                       


Author:

    Nick Harvey    (NickHar)
    
Revision History

    19-06-2000   NickHar   Development Started
    14-07-2000   NickHar   Initial development complete, submit to source control
    02-10-2000   NickHar   Add support for one-way black-black edges
    12-15-2000   NickHar   Add support for component reporting


Notes:
    W32TOPL's allocator (which can be set by the user) is used for memory allocation
    
--*/


/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "stheap.h"
#include "stda.h"
#include "stalg.h"


/***** Constants *****/
/* Magic numbers to ensure consistency of the Topl structures */
#define MAGIC_START 0x98052639
#define MAGIC_END   0xADD15ABA

/* Various constants used throughout the code in this file */
const DWORD ACCEPT_ALL=0xFFFFFFFF;
const DWORD INFINITY=0xFFFFFFFF;
const DWORD VTX_DEFAULT_INTERVAL=0;
const DWORD VTX_DEFAULT_OPTIONS=0xFFFFFFFF;
const int UNCONNECTED_COMPONENT=-1;
const DWORD MAX_EDGE_TYPE=31;            /* Maximum edge type */
const int EMPTY_EDGE_SET=-1;             /* Dummy Index for implicit empty edge set */
const BOOLEAN NON_INTERSECTING=FALSE;    /* Return values when combining schedules */
const BOOLEAN INTERSECTING=TRUE;  


/***** Macros *****/
#define MAX(a,b) (((a)>(b))?(a):(b))


/***** CheckGraphState *****/
/* Check that the PTOPL_GRAPH_STATE parameter we were passed is valid.
 * If it is invalid, we throw an exception */
PToplGraphState
CheckGraphState(
    PTOPL_GRAPH_STATE G
    )
{
    PToplGraphState g;

    if( G==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    g = (PToplGraphState) G;

    if( g->magicStart != MAGIC_START
     || g->magicEnd != MAGIC_END ) {
        ToplRaiseException( TOPL_EX_GRAPH_STATE_ERROR );
    }
    if( g->vertices==NULL || g->vertexNames==NULL
     || g->vnCompFunc==NULL || g->schedCache==NULL) {
        ToplRaiseException( TOPL_EX_GRAPH_STATE_ERROR );
    }
    
    return g;
}


/***** CheckMultiEdge *****/
/* Check that the PTOPL_MULTI_EDGE parameter we were passed is valid.
 * If it is invalid, we throw an exception.
 * We only check a few things here -- more substantial checks are done
 * when the edge set is added to the graph state.
 * Note: Edges must have at least 2 vertices. */
VOID
CheckMultiEdge(
    PTOPL_MULTI_EDGE e
    )
{
    if( e==NULL || e->vertexNames==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    if( e->numVertices < 2 ) {
        ToplRaiseException( TOPL_EX_TOO_FEW_VTX );
    }
    if( e->edgeType > MAX_EDGE_TYPE ) {
        ToplRaiseException( TOPL_EX_INVALID_EDGE_TYPE );
    }
    if( ToplScheduleValid(e->ri.schedule)==FALSE ) {
        ToplRaiseException( TOPL_EX_SCHEDULE_ERROR );
    }
}


/***** CheckMultiEdgeSet *****/
/* Check that the PTOPL_MULTI_EDGE_SET parameter we were passed is valid.
 * If it is invalid, we throw an exception. The checks performed here
 * are somewhat cursory, but at least we catch null pointers.
 * More substantial checks are done when the edge set is added to the
 * graph state.
 * Note: An edge set with less than 2 edges is useless, but valid. */
VOID
CheckMultiEdgeSet(
    PTOPL_MULTI_EDGE_SET s
    )
{
    if( s==NULL || s->multiEdgeList==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
}


/***** InitializeVertex *****/
/* Initialize graph g's vertex i to all the default values.
 * Vertices are by default in an unconnected component and have no edges.
 *
 * Warning:
 * An edge list is allocated here, and memory will be orphaned if this
 * function is called twice on the same vertex. This memory is freed when
 * the graph is destroyed in ToplDeleteGraphState(). */
VOID
InitializeVertex(
    PToplGraphState g,
    DWORD i
    )
{
    PToplVertex v;

    /* Check parameters */
    ASSERT( g && g->vertices && g->vertexNames );
    ASSERT( i<g->numVertices );
    v = &g->vertices[i];

    v->vtxId = i;
    v->vertexName = g->vertexNames[i];

    /* Graph data */
    DynArrayInit( &v->edgeList, sizeof(PTOPL_MULTI_EDGE) );
    v->color = COLOR_WHITE;
    v->acceptRedRed = 0;
    v->acceptBlack = 0;
    
    /* Default replication data */
    v->ri.cost = INFINITY;
    v->ri.repIntvl = VTX_DEFAULT_INTERVAL;
    v->ri.options = VTX_DEFAULT_OPTIONS;
    v->ri.schedule = ToplGetAlwaysSchedule( g->schedCache );

    /* Dijkstra data */
    v->heapLocn = STHEAP_NOT_IN_HEAP;
    v->root = NULL;
    v->demoted = FALSE;

    /* Kruskal data */
    v->componentId = UNCONNECTED_COMPONENT;
    v->componentIndex = 0;

    /* DFS data */
    v->distToRed = 0;
    v->parent = NULL;
    v->nextChild = 0;
}


/***** ToplMakeGraphState *****/
/* Create a GraphState object. The vertices are added at creation time; the
 * multi-edges are added later by calling 'ToplAddEdgeToGraph'. Edge sets should be
 * added later to specify edge transitivity.
 * Warning: Contents of 'vertexNames' will be reordered after calling this function */
PTOPL_GRAPH_STATE
ToplMakeGraphState(
    IN PVOID* vertexNames,
    IN DWORD numVertices, 
    IN TOPL_COMPARISON_FUNC vnCompFunc,
    IN TOPL_SCHEDULE_CACHE schedCache
    )
{
    PToplGraphState  g=NULL;
    ToplVertex* v;
    DWORD iVtx;

    /* Check parameters for invalid pointers */
    if( vertexNames==NULL || vnCompFunc==NULL || schedCache==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    for( iVtx=0; iVtx<numVertices; iVtx++ ) {
        if( vertexNames[iVtx]==NULL ) {
            ToplRaiseException( TOPL_EX_NULL_POINTER );
        }
    }

    __try {

        g = (PToplGraphState) ToplAlloc( sizeof(ToplGraphState) );
        g->vertices = NULL;

        /* Store the list of vertex names in g. Sort it, for efficient searches later */
        g->vertexNames = vertexNames;
        g->numVertices = numVertices;
        qsort( vertexNames, numVertices, sizeof(PVOID), vnCompFunc );

        /* Initialize vertex objects */
        g->vertices = (ToplVertex*) ToplAlloc( sizeof(ToplVertex)*numVertices );
        for( iVtx=0; iVtx<numVertices; iVtx++ ) {
            InitializeVertex( g, iVtx );
        }
        
        /* Initialize the rest of the members of the graph state */
        DynArrayInit( &g->masterEdgeList, sizeof(PTOPL_MULTI_EDGE) );
        g->melSorted = FALSE;       /* The master edge list is not sorted yet */
        DynArrayInit( &g->edgeSets, sizeof(PTOPL_MULTI_EDGE_SET) );
        g->vnCompFunc = vnCompFunc;
        g->schedCache = schedCache;

    } __finally {

        if( AbnormalTermination() ) {

            /* An exception occurred -- free memory */
            if( g ) {
                if( g->vertices ) {
                    ToplFree( g->vertices );
                }
                ToplFree( g );
            }
        }

    }

    g->magicStart = MAGIC_START;
    g->magicEnd = MAGIC_END;
    return g;
}


/***** FindVertex *****/
/* Search the list of vertex names in g for a name that matches 'vtxName'.
 * Return the corresponding vertex structure. If no such vertex was found,
 * we return NULL. */
PToplVertex
FindVertex(
    ToplGraphState* g,
    PVOID vtxName )
{
    PVOID *vn;
    DWORD index;

    /* We can check if the name is null, but cannot do much more checking */
    if( vtxName==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }

    /* Use bsearch to find this vertex name in the list of all vertex names */
    vn = (PVOID*) bsearch( &vtxName, g->vertexNames,
        g->numVertices, sizeof(PVOID), g->vnCompFunc );

    /* If this name was not found, then it was an invalid name. Let the
     * caller handle it */
    if(vn==NULL) {
        return NULL;
    }

    /* Determine the index of the vertex name that we found */
    index = (int) (vn - g->vertexNames);
    ASSERT( index<g->numVertices );

    /* Return the appropriate ToplVertex pointer */
    return &g->vertices[index];
}


/***** CreateMultiEdge *****/
/* This function allocates the memory required for a multi-edge object which
 * contains 'numVtx' vertices. It does not initialize any of the fields of the
 * edge except for the vertex names, which are set to NULL. This memory should
 * be deallocated by calling FreeMultiEdge(). */
PTOPL_MULTI_EDGE
CreateMultiEdge(
    IN DWORD numVtx
    )
{
    PTOPL_MULTI_EDGE e;
    DWORD iVtx;

    e = (PTOPL_MULTI_EDGE) ToplAlloc( sizeof(TOPL_MULTI_EDGE)
        + (numVtx-1) * sizeof( TOPL_NAME_STRUCT ) );
    e->numVertices = numVtx;
    e->edgeType = 0;
    e->fDirectedEdge = FALSE;
    for( iVtx=0; iVtx<numVtx; iVtx++ ) {
        e->vertexNames[iVtx].name = NULL;
        e->vertexNames[iVtx].reserved = 0;
    }

    return e;
}


/***** FreeMultiEdge *****/
/* This function frees the memory used by a multi-edge object. It does not
 * free the memory used by the vertices. */
VOID
FreeMultiEdge(
    PTOPL_MULTI_EDGE e
    )
{
    DWORD iVtx;

    ASSERT( e );
    for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
        e->vertexNames[iVtx].name = NULL;
        e->vertexNames[iVtx].reserved = 0;
    }
    e->numVertices = 0;

    ToplFree( e );
}


/***** CopyReplInfo *****/
/* Copy the replication info FROM ri1 TO ri2.
 * Note: The order is different from memcpy(), memmove(), etc. */
VOID
CopyReplInfo(
    TOPL_REPL_INFO *ri1,
    TOPL_REPL_INFO *ri2
    )
{
    ASSERT( ri1!=NULL && ri2!=NULL );
    memcpy( ri2, ri1, sizeof(TOPL_REPL_INFO) );
}


/***** ToplAddEdgeToGraph *****/
/* Allocate a multi-edge object, and add it to the graph G.
 * The number of vertices that this edge will contain must be specified
 * in the 'numVtx' parameter, so that the appropriate amount of memory
 * can be allocated. The names of the vertices contained in this edge
 * are not yet specified -- they are NULL. The names must be specified
 * later, by calling the function ToplEdgeSetVtx(). All names must be
 * set before adding this edge to an edge set, and before calling
 * ToplGetSpanningTreeEdgesForVtx().
 * 
 * Note: All edges should be added to the graph before starting to add
 * edge sets. This is for performance reasons. */
PTOPL_MULTI_EDGE
ToplAddEdgeToGraph(
    IN PTOPL_GRAPH_STATE G,
    IN DWORD numVtx,
    IN DWORD edgeType,
    IN PTOPL_REPL_INFO ri
    )
{
    PToplGraphState g;
    PTOPL_MULTI_EDGE e;
    DWORD iVtx;
    
    /* Check parameters */
    g = CheckGraphState( G );
    if( numVtx<2 ) {
        ToplRaiseException( TOPL_EX_TOO_FEW_VTX );
    }
    if( edgeType>MAX_EDGE_TYPE ) {
        ToplRaiseException( TOPL_EX_INVALID_EDGE_TYPE );
    }
    if( ri==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    if( ! ToplScheduleValid( ri->schedule ) ) {
        ToplRaiseException( TOPL_EX_SCHEDULE_ERROR );
    }
    
    g->melSorted = FALSE; /* The master edge list is now unsorted */

    e = CreateMultiEdge( numVtx );
    e->edgeType = edgeType;
    CopyReplInfo( ri, &e->ri );

    __try {
        DynArrayAppend( &g->masterEdgeList, &e );
    } __finally {
        if( AbnormalTermination() ) {
            ToplFree(e);
            e=NULL;
        }
    }

    return e;
}


/***** ToplEdgeSetVtx *****/
/* This function is used to set the name of a vertex in an edge.
 * If edge e has n vertices, 'whichVtx' should be in the range
 * [0..n-1]. */
VOID
ToplEdgeSetVtx(
    IN PTOPL_GRAPH_STATE G,
    IN PTOPL_MULTI_EDGE e,
    IN DWORD whichVtx,
    IN PVOID vtxName
    )
{
    PToplGraphState g;
    PToplVertex v;
    
    /* Check parameters */
    g = CheckGraphState( G );
    CheckMultiEdge( e );
    if( whichVtx>=e->numVertices ) {
        ToplRaiseException( TOPL_EX_INVALID_VERTEX );
    }
    
    /* Optimization: To describe which vertices this edge contains, the user
     * passes us a list of vertex names. Since using a vertex names requires
     * a binary search, we store an index in the 'reserved' field to help us
     * the vertices even faster.
     *
     * This may seem unnecessary, since the performance of bsearch is usually
     * quite acceptable. However, for very large graphs, comparing two integers
     * can be significantly faster than bsearching. */

    if( vtxName == NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    v = FindVertex( g, vtxName );
    if( v==NULL ) {
        ToplRaiseException( TOPL_EX_INVALID_VERTEX );
    }
    e->vertexNames[whichVtx].name = vtxName;
    e->vertexNames[whichVtx].reserved = v->vtxId;
}


/***** EdgePtrCmp *****/
/* Compare two edge pointers by their _pointer_ value. This is used for
 * sorting the master edge list. */
int
__cdecl EdgePtrCmp(
    const void* p1,
    const void* p2
    )
{
    PTOPL_MULTI_EDGE a=*((PTOPL_MULTI_EDGE*)p1), b=*((PTOPL_MULTI_EDGE*)p2);

    if( a<b ) {
        return -1;
    } else if( a>b ) {
        return 1;
    }
    return 0;
}


/***** ToplAddEdgeSetToGraph *****/
/* Adds a single edge-set to the graph state. Edge sets define transitivity
 * for paths through the graph. When the spanning-tree algorithm searches for
 * paths between vertices, it will only allow paths for which all edges are in
 * an edge set. A given edge can appear in more than one edge set.
 *
 * Note: all edges must be added to the graph before adding edge sets,
 * otherwise performance will suffer.
 */
VOID
ToplAddEdgeSetToGraph(
    IN PTOPL_GRAPH_STATE G,
    IN PTOPL_MULTI_EDGE_SET s
    )
{
    PTOPL_MULTI_EDGE e;
    PToplGraphState g;
    DWORD iEdge;
    int edgeIndex;
    
    g = CheckGraphState( G );
    CheckMultiEdgeSet( s );

    /* Sort the edge list so that we can quickly search for edges */
    if( g->melSorted==FALSE ) {
        DynArraySort( &g->masterEdgeList, EdgePtrCmp );
        g->melSorted = TRUE;
    }

    /* Check the edges */
    for( iEdge=0; iEdge<s->numMultiEdges; iEdge++ ) {
        e = s->multiEdgeList[iEdge];
        if( e == NULL ) {
            ToplRaiseException( TOPL_EX_NULL_POINTER );
        }
        
        /* Check that all edges in this set have the same type */
        if( iEdge>0 && s->multiEdgeList[iEdge-1]->edgeType!=e->edgeType ) {
            ToplRaiseException( TOPL_EX_INVALID_EDGE_SET );
        }

        /* Check that this edge has been added to the graph state */
        edgeIndex = DynArraySearch(&g->masterEdgeList, &e, EdgePtrCmp);
        if( edgeIndex==DYN_ARRAY_NOT_FOUND ) {
            ToplRaiseException( TOPL_EX_INVALID_EDGE_SET );
        }
    }
    
    /* If an edge sets contains fewer than two edges it is useless. We only
     * store edge sets with two or more edges. */
    if( s->numMultiEdges>1 ) {
        DynArrayAppend( &g->edgeSets, &s );
    }
}


/***** VertexComp *****/
/* Compare vertices using the key (cost,VertexName) */
int
VertexComp(
    PToplVertex v1,
    PToplVertex v2,
    PTOPL_GRAPH_STATE G )
{
    PToplGraphState g;
    int result;

    ASSERT( v1!=NULL && v2!=NULL );
    ASSERT( v1->vertexName!=NULL && v2->vertexName!=NULL );
    g = CheckGraphState( G );

    if(v1->ri.cost==v2->ri.cost) {
        /* Comparing vtxId's is equivalent to comparing the vertex names */
        if( v1->vtxId < v2->vtxId ) {
            result = -1;
            ASSERT( g->vnCompFunc(&v1->vertexName,&v2->vertexName)<0 );
        } else if( v1->vtxId > v2->vtxId ) {
            result = 1;
            ASSERT( g->vnCompFunc(&v1->vertexName,&v2->vertexName)>0 );
        } else {
            result = 0;
            ASSERT( g->vnCompFunc(&v1->vertexName,&v2->vertexName)==0 );
        }
        return result;
    }

    /* Subtraction could lead to overflow, so we compare the numbers
     * the old-fashioned way. */
    if( v1->ri.cost > v2->ri.cost ) {
        return 1;
    } else if( v1->ri.cost < v2->ri.cost ) {
        return -1;
    }

    return 0;
}


/***** VertexGetLocn *****/
/* Get the location of this vertex in the heap. This function is
 * only called internally by the stheap code */
int
VertexGetLocn(
    PToplVertex v,
    PVOID extra
    )
{
    ASSERT( v );
    return v->heapLocn;
}


/***** VertexSetLocn *****/
/* Set the location of this vertex in the heap. This function is
 * only called internally by the stheap code */
VOID
VertexSetLocn(
    PToplVertex v,
    int locn,
    PVOID extra
    )
{
    ASSERT( v );
    v->heapLocn = locn;
}


/***** InitColoredVertices *****/
VOID
InitColoredVertices(
    PToplGraphState g,
    TOPL_COLOR_VERTEX *colorVtx,
    DWORD numColorVtx,
    PToplVertex whichVtx
    )
{
    TOPL_VERTEX_COLOR color;
    PToplVertex v;
    DWORD iVtx;

    if( colorVtx==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }

    /* Clear the coloring for all vertices */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        g->vertices[iVtx].color = COLOR_WHITE;
    }

    /* Go through the list of colored vertices, coloring them */
    for( iVtx=0; iVtx<numColorVtx; iVtx++ ) {

        /* Find the vertex with this name */
        if( colorVtx[iVtx].name==NULL ) {
            ToplRaiseException( TOPL_EX_NULL_POINTER );
        }
        v = FindVertex( g, colorVtx[iVtx].name );
        if(v==NULL) {
            ToplRaiseException( TOPL_EX_COLOR_VTX_ERROR );
        }

        /* Ensure that each vertex is colored at most once */
        if( v->color!=COLOR_WHITE ) {
            ToplRaiseException( TOPL_EX_COLOR_VTX_ERROR );
        }

        /* Ensure that each vertex is colored either red or black */
        color = colorVtx[iVtx].color;
        if( color!=COLOR_RED && color!=COLOR_BLACK ) {
            ToplRaiseException( TOPL_EX_COLOR_VTX_ERROR );
        }
        v->color = color;

        v->acceptRedRed = colorVtx[iVtx].acceptRedRed;
        v->acceptBlack = colorVtx[iVtx].acceptBlack;
    }

    /* Ensure that 'whichVtx' is colored */
    if( whichVtx!=NULL && whichVtx->color==COLOR_WHITE ) {
        ToplRaiseException( TOPL_EX_INVALID_VERTEX );
    }
}


/***** TableAlloc *****/
/* This function is used as the allocator for the RTL table */
PVOID
NTAPI TableAlloc( RTL_GENERIC_TABLE *Table, CLONG ByteSize )
{
    return ToplAlloc( ByteSize );
}


/***** TableFree *****/
/* This function is used as the deallocator for the RTL table */
VOID
NTAPI TableFree( RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
    ToplFree( Buffer );
}


/***** EdgeGetVertex *****/
/* When the user passes in edges, they contain the name of the vertices
 * that the edge is incident with. Finding the vertices based on name
 * can be slow, so we cheat and use the 'reserved' field. */
PToplVertex
EdgeGetVertex(
    PToplGraphState g,
    PTOPL_MULTI_EDGE e,
    DWORD iVtx )
{
    DWORD vtxId;

    ASSERT( g );
    ASSERT( e );
    ASSERT( iVtx < e->numVertices );

    vtxId = e->vertexNames[iVtx].reserved;
    ASSERT( vtxId<g->numVertices );

    return &g->vertices[ vtxId ];
}


/***** ClearEdgeLists *****/
/* Clear the edges from all vertices' edge lists. */
VOID
ClearEdgeLists(
    IN PToplGraphState g
    )
{
    DWORD iVtx;

    /* First clear the vertices' edge lists */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        DynArrayClear( &g->vertices[iVtx].edgeList );
    }
}

 
/***** SetupEdges *****/
/* Clear all the edges from the graph. Not from the master edge list,
 * just from the vertices' edge lists. Then, add the edges from
 * edge set 'whichEdgeSet' into the graph. Returns the edge type of
 * the edges in the edge set. */
DWORD
SetupEdges(
    PToplGraphState g,
    DWORD whichEdgeSet )
{
    PTOPL_MULTI_EDGE e;
    PTOPL_MULTI_EDGE_SET s;
    DWORD iVtx, iEdge, edgeType=0;
    ToplVertex* v;

    ClearEdgeLists( g );

    ASSERT( whichEdgeSet < DynArrayGetCount(&g->edgeSets) );
    s = *((PTOPL_MULTI_EDGE_SET*) DynArrayRetrieve( &g->edgeSets, whichEdgeSet ));
    CheckMultiEdgeSet( s );

    /* Add edges from edge set s into the graph.
     * Note: ToplAddEdgeSetToGraph only allows edge sets with at least one edge. */
    ASSERT( s->numMultiEdges>0 );
    for( iEdge=0; iEdge<s->numMultiEdges; iEdge++ ) {
        e = s->multiEdgeList[iEdge];
        CheckMultiEdge( e );
        edgeType = e->edgeType;

        /* For every vertex in edge e, add e to its edge list */
        for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
            v = EdgeGetVertex( g, e, iVtx );
            DynArrayAppend( &v->edgeList, &e );
        }
    }

    return edgeType;
}


/***** SetupVertices *****/
/* Setup the fields of the vertices that are relevant to Phase 1
 * (Dijkstra's Algorithm).  For each vertex we set up its cost, root
 * vertex, and component. This defines the shortest-path forest structures.
 */
VOID
SetupVertices(
    PToplGraphState g
    )
{
    PToplVertex v;
    DWORD iVtx;

    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {

        v = &g->vertices[ iVtx ];

        if( v->color==COLOR_RED || v->color==COLOR_BLACK ) {
            /* Since we reinitialize the vertex every time we set up the graph,
             * we have to reset the important fields of the colored vertices. */
            v->ri.cost = 0;
            v->root = v;
            v->componentId = (int) v->vtxId;
        } else {
            ASSERT( v->color==COLOR_WHITE );
            v->ri.cost = INFINITY;
            v->root = NULL;
            v->componentId = UNCONNECTED_COMPONENT;
        }

        v->ri.repIntvl = VTX_DEFAULT_INTERVAL;
        v->ri.options = VTX_DEFAULT_OPTIONS;
        v->ri.schedule = ToplGetAlwaysSchedule( g->schedCache );
        v->heapLocn = STHEAP_NOT_IN_HEAP;
        v->demoted = FALSE;
    }
}


/***** SetupDijkstra *****/
/* Build the initial heap for use with Dijkstra's algorithm. The heap
 * will contain the red and black vertices as root vertices, unless these
 * vertices accept no edges of the current edgeType, or unless we're
 * not including black vertices. */
PSTHEAP
SetupDijkstra(
    IN PToplGraphState g,
    IN DWORD edgeType,
    IN BOOL fIncludeBlack
    )
{
    PToplVertex v;
    PSTHEAP heap;
    DWORD iVtx, mask;

    ASSERT( edgeType <= MAX_EDGE_TYPE );
    mask = 1 << edgeType;

    SetupVertices( g );
    heap = ToplSTHeapInit( g->numVertices, VertexComp, VertexGetLocn, VertexSetLocn, g );

    __try {
        for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
            v = &g->vertices[ iVtx ];

            if( v->color==COLOR_WHITE ) {
                continue;
            }

            if(   (v->color==COLOR_BLACK && !fIncludeBlack)
               || (   FALSE==(v->acceptBlack&mask)
                   && FALSE==(v->acceptRedRed&mask) ) )
            {
                /* If we're not allowing black vertices, or if this vertex accepts
                 * neither red-red nor black edges, then we 'demote' it to an uncolored
                 * vertex for the purposes of Phase I. Note that the 'color' member of
                 * the vertex structure is not changed. */
                v->ri.cost = INFINITY;
                v->root = NULL;
                v->demoted = TRUE;
            } else {
                /* The vertex is colored and it will accept either red-red or black
                 * edges. Add it to the heap used for Dijkstra's algorithm. */
                ToplSTHeapAdd( heap, v );
            }
        }
    } __finally {
        if( AbnormalTermination() ) {
            ToplSTHeapDestroy( heap );
        }
    }

    return heap;
}

/***** CheckDemoteOneVertex *****/
/* Demote one vertex if necessary */
VOID
CheckDemoteOneVertex(
    IN PToplVertex v,
    IN DWORD edgeType
    )
{
    DWORD mask;

    ASSERT( edgeType <= MAX_EDGE_TYPE );
    mask = 1 << edgeType;

    if( v->color==COLOR_WHITE ) {
        return;
    }

    if ( FALSE==(v->acceptBlack&mask)
         && FALSE==(v->acceptRedRed&mask) ) {
        /* If this vertex accepts
         * neither red-red nor black edges, then we 'demote' it to an uncolored
         * vertex for the purposes of Phase I. Note that the 'color' member of
         * the vertex structure is not changed. */
        v->ri.cost = INFINITY;
        v->root = NULL;
        v->demoted = TRUE;
    }
}

/**** UndemoteOneVertex ******/
/* Clear the demoted state of a vertex */
VOID
UndemoteOneVertex(
    IN PToplVertex v
    )
{
    if( v->color==COLOR_WHITE ) {
        return;
    }

    v->ri.cost = 0;
    v->root = v;
    v->demoted = FALSE;

}

/***** AddDWORDSat *****/
/* Add two DWORDs and saturate the sum at INFINITY. This prevents
 * overflow. */
DWORD
AddDWORDSat(
    IN DWORD a,
    IN DWORD b
    )
{
    DWORD c;
    
    c = a + b;
    if( c<a || c<b || c>INFINITY ) {
        c = INFINITY;
    }
    return c;
}


/***** CombineReplInfo *****/
/* Merge schedules, replication intervals, options and costs.
 * c = Combine( a, b ). Returns NON_INTERSECTING if combined schedule is
 * empty, INTERSECTING otherwise. If the schedules don't intersect,
 * replication info is not disturbed */
BOOLEAN
CombineReplInfo(
    PToplGraphState g,
    TOPL_REPL_INFO *a,
    TOPL_REPL_INFO *b,
    TOPL_REPL_INFO *c
    )
{
    TOPL_SCHEDULE s=NULL;
    BOOLEAN fIsNever;

    s = ToplScheduleMerge( g->schedCache, a->schedule, b->schedule, &fIsNever );
    if( fIsNever ) {
        return NON_INTERSECTING;
    }

    /* Add costs, avoiding overflow */
    c->cost = AddDWORDSat( a->cost, b->cost );
    c->repIntvl = MAX( a->repIntvl, b->repIntvl );

    /* AND the options together -- that's what ISM does */
    c->options = a->options & b->options;        
    c->schedule = s;

    return INTERSECTING;
}


/***** RaiseNonIntersectingException *****/
/* This function is called when non-intersecting schedules are discovered
 * along a path. An exception is raised, and the vertex names describing
 * the erroneous path are passed back to the user. The user can choose to
 * resume processing after catching the exception. */
VOID
RaiseNonIntersectingException(
    IN PToplVertex a,
    IN PToplVertex b,
    IN PToplVertex c
    )
{
    ULONG_PTR       exceptionInfo[3];

    /* Schedules didn't intersect. Throw an exception to let the user
     * know. We allow the user to resume the exceution, which is why
     * we don't call ToplRaiseException. */
    ASSERT( sizeof(PVOID)==sizeof(ULONG_PTR) );
     
    ( (PVOID*) exceptionInfo )[0] = a->vertexName;
    ( (PVOID*) exceptionInfo )[1] = b->vertexName;
    ( (PVOID*) exceptionInfo )[2] = c->vertexName;

    RaiseException( TOPL_EX_NONINTERSECTING_SCHEDULES, 0,
        3, exceptionInfo );
}


/***** TryNewPath *****/
/* Helper function for Dijkstra's algorithm. We have found a new path from a
 * root vertex to vertex v. This path is (u->root, ..., u, v). Edge e is the
 * edge connecting u and v. If this new path is better (in our case cheaper,
 * or has a longer schedule), we update v to use the new path. */
VOID
TryNewPath(
    PToplGraphState g,
    PSTHEAP heap,
    PToplVertex u,
    PTOPL_MULTI_EDGE e,
    PToplVertex v
    )
{
    TOPL_REPL_INFO  newRI;
    DWORD           newDuration, oldDuration;
    BOOLEAN         fIntersect;

    fIntersect = CombineReplInfo( g, &u->ri, &e->ri, &newRI );

    /* If the new path to vertex v has greater cost than an existing
     * path, we can ignore the new path. */
    if( newRI.cost > v->ri.cost ) {
        return;
    }

    /* We know that the new path's cost is <= the existing path's cost */

    if( (newRI.cost<v->ri.cost) && fIntersect==NON_INTERSECTING )
    {
        RaiseNonIntersectingException( u->root, u, v );
        return;
    }

    newDuration = ToplScheduleDuration(newRI.schedule);
    oldDuration = ToplScheduleDuration(v->ri.schedule);

    if( (newRI.cost<v->ri.cost) || (newDuration>oldDuration) ) {

        /* The new path to v is either cheaper or has a longer schedule.
         * We update v with its new root vertex, cost, and replication
         * info. Since its cost has changed, we must reorder the heap a bit. */
        v->root = u->root;
        v->componentId = u->componentId;
        ASSERT( u->componentId == u->root->componentId );
        CopyReplInfo( &newRI, &v->ri  );

        if( v->heapLocn==STHEAP_NOT_IN_HEAP ) {
            ToplSTHeapAdd( heap, v );
        } else {
            ToplSTHeapCostReduced( heap, v );
        }

    }
    
}


/***** Dijkstra *****/
/* Run Dijkstra's algorithm with the red (and possibly black) vertices as
 * the root vertices, and build up a shortest-path forest. To determine the
 * next vertex to add to the forest, we use a variation on a binary heap. This
 * heap supports an additional operation, which efficiently fixes up the
 * heap's ordering if we decrease the cost of an element.
 *
 * Parameters:
 * 'edgeType'           This is the type of the edges in the current edge set.
 * 'fIncludeBlackVtx'   If this is true, black vertices are also used as roots.
 */
VOID
Dijkstra(
    IN PToplGraphState g,
    IN DWORD edgeType,
    IN BOOL fIncludeBlack
    )
{
    PTOPL_MULTI_EDGE e;
    PToplVertex u, v;
    DWORD iEdge, iVtx, cEdge;
    PSTHEAP heap;

    ASSERT( g!=NULL );
    heap = SetupDijkstra( g, edgeType, fIncludeBlack );
    
    __try {

        while( (u=(PToplVertex) ToplSTHeapExtractMin(heap)) ) {

            cEdge = DynArrayGetCount( &u->edgeList );
            for( iEdge=0; iEdge<cEdge; iEdge++ ) {

                e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( &u->edgeList, iEdge ));
                CheckMultiEdge( e );
                
                /* Todo: Potential Optimization: Don't check multi-edges
                 * which have already been checked. This would only really
                 * be advantageous if edges contain many vertices. */

                for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
                    v = EdgeGetVertex( g, e, iVtx );
                    TryNewPath( g, heap, u, e, v );
                } 
            }
        }

    } __finally {
        ToplSTHeapDestroy( heap );
    }
}


/***** AddIntEdge *****/
/* Add an edge to the list of edges we will process with Kruskal's.
 * The endpoints are in fact the roots of the vertices we pass in, so
 * the endpoints are always colored vertices */
VOID
AddIntEdge(
    PToplGraphState g,
    RTL_GENERIC_TABLE *internalEdges,
    PTOPL_MULTI_EDGE e,
    PToplVertex v1,
    PToplVertex v2
    )
{
    ToplInternalEdge newIntEdge;
    TOPL_REPL_INFO ri, ri2;
    PToplVertex root1, root2, temp;
    char redRed;
    DWORD mask;

    /* Check parameters */
    ASSERT( v1!=NULL && v2!=NULL );
    ASSERT( e->edgeType<=MAX_EDGE_TYPE );

    /* The edge we pass on to Kruskal's algorithm actually goes between
     * the roots of the two shortest-path trees. */
    root1 = v1->root;
    root2 = v2->root;
    ASSERT( root1!=NULL && root2!=NULL );
    ASSERT( root1->color!=COLOR_WHITE && root2->color!=COLOR_WHITE );

    /* Check if both endpoints will allow this type of edge */
    redRed = (root1->color==COLOR_RED) && (root2->color==COLOR_RED);
    mask = 1 << e->edgeType;
    if( redRed ) {
        if( (root1->acceptRedRed&mask)==0 || (root2->acceptRedRed&mask)==0 ) {
            return;   /* root1/root2 will not accept this type of red-red edge */
        }
    } else {
        if( (root1->acceptBlack&mask)==0 || (root2->acceptBlack&mask)==0 ) {
            return;   /* root1/root2 will not accept this type of black edge */
        }
    }

    /* Combine the schedules of the path from root1 to v1, root2 to v2, and edge e */
    if( CombineReplInfo(g,&v1->ri,&v2->ri,&ri)==NON_INTERSECTING
     || CombineReplInfo(g,&ri,&e->ri,&ri2)==NON_INTERSECTING )
    {
        RaiseNonIntersectingException( root1, v1, v2 );
        return;
    }

    /* Set up the internal simple edge from root1 to root2 */
    newIntEdge.v1 = root1;
    newIntEdge.v2 = root2;
    newIntEdge.redRed = redRed;
    CopyReplInfo( &ri2, &newIntEdge.ri );
    newIntEdge.edgeType = e->edgeType;

    /* Sort newIntEdge's vertices based on vertexName */
    if( newIntEdge.v1->vtxId > newIntEdge.v2->vtxId ) {
        temp = newIntEdge.v1;
        newIntEdge.v1 = newIntEdge.v2;
        newIntEdge.v2 = temp;
    }

    /* Insert this edge into our table of internal edges. If an identical edge 
     * already exists in the table, newIntEdge will not be inserted. */
    RtlInsertElementGenericTable( internalEdges, &newIntEdge,
        sizeof(ToplInternalEdge), NULL );
}


/***** ColorComp *****/
/* Determine which vertex has better color. Demotion is also taken into account.
 * Return values:
 *  -1  - v1 is better
 *   0  - color-wise, they are the same
 *   1  - v2 is better. */
int
ColorComp(
    IN PToplVertex v1,
    IN PToplVertex v2 )
{
    DWORD color1=v1->color, color2=v2->color;

    if( v1->demoted ) {
        color1 = COLOR_WHITE;
    }
    if( v2->demoted ) {
        color2 = COLOR_WHITE;
    }
    
    switch(color1) {
        case COLOR_RED:
            return (COLOR_RED==color2) ? 0 : -1;
        case COLOR_BLACK:
            switch(color2) {
                case COLOR_RED:
                    return 1;
                case COLOR_BLACK:
                    return 0;
                case COLOR_WHITE:
                    return -1;
                default:
                    ASSERT( !"Invalid Color!" );
                    return 0;
            }
        case COLOR_WHITE:
            return (COLOR_WHITE==color2) ? 0 : 1;
        default:
            ASSERT( !"Invalid Color!" );
            return 0;
    }
}


/***** ProcessEdge *****/
/* After running Dijkstra's algorithm, this function examines a multi-edge
 * and adds internal edges between every tree connected by this edge. */
VOID
ProcessEdge(
    IN ToplGraphState *g,
    IN PTOPL_MULTI_EDGE e,
    IN OUT RTL_GENERIC_TABLE *internalEdges
    )
{
    PToplVertex bestV, v;
    DWORD iVtx;
    int cmp;

    CheckMultiEdge( e );
    ASSERT( e->numVertices>=2 );

    /* Find the best vertex to be the 'root' of this multi-edge.
     * Color is most important (red is best), then cost. */
    bestV = EdgeGetVertex( g, e, 0 );
    for( iVtx=1; iVtx<e->numVertices; iVtx++ ) {
        v = EdgeGetVertex( g, e, iVtx );
        cmp = ColorComp(v,bestV);
        if(   (cmp<0)
           || (cmp==0 && VertexComp(v,bestV,g)<0) )
        {
            bestV = v;
        }
    }

    /* Add to internalEdges an edge from every colored vertex to the best vertex */
    for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
        v = EdgeGetVertex( g, e, iVtx );

        /* Demoted vertices can have a valid component ID but no root. */
        if( v->componentId!=UNCONNECTED_COMPONENT && v->root==NULL ) {
            ASSERT( v->demoted );
            continue;
        }

        /* Only add this edge if it is a valid inter-tree edge.
         * (The two vertices must be reachable from the root vertices,
         * and in different components.) */
        if(  (bestV->componentId!=UNCONNECTED_COMPONENT) && (NULL!=bestV->root)
          && (v->componentId    !=UNCONNECTED_COMPONENT) && (NULL!=v->root)
          && (bestV->componentId!=v->componentId)
        ) {
            AddIntEdge( g, internalEdges, e, bestV, v ); 
        }

    }
}


/***** ProcessEdgeSet *****/
/* After running Dijkstra's algorithm to determine the shortest-path forest,
 * examine all edges in this edge set. We find all inter-tree edges, from
 * which we build the list of 'internal edges', which we will later pass
 * on to Kruskal's algorithm.
 * This function doesn't do much except call ProcessEdge() for every edge. */
VOID
ProcessEdgeSet(
    ToplGraphState *g,
    int whichEdgeSet,
    RTL_GENERIC_TABLE *internalEdges
    )
{
    PTOPL_MULTI_EDGE_SET s;
    PTOPL_MULTI_EDGE e;
    PToplVertex v;
    DWORD iEdge, cEdge, iVtx;

    if( whichEdgeSet==EMPTY_EDGE_SET ) {

        /* Handle the implicit edge set, consisting of no edges */
        cEdge = DynArrayGetCount( &g->masterEdgeList );
        for( iEdge=0; iEdge<cEdge; iEdge++ ) {
            e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( &g->masterEdgeList, iEdge ));
            CheckMultiEdge(e);
            for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
                v = EdgeGetVertex( g, e, iVtx );
                CheckDemoteOneVertex( v, e->edgeType );
            }
            ProcessEdge( g, e, internalEdges );
            for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
                v = EdgeGetVertex( g, e, iVtx );
                UndemoteOneVertex( v );
            }
        }

    } else {

        ASSERT( whichEdgeSet < (int) DynArrayGetCount(&g->edgeSets) );
        s = *((PTOPL_MULTI_EDGE_SET*) DynArrayRetrieve( &g->edgeSets, whichEdgeSet ) );
        CheckMultiEdgeSet(s);

        for( iEdge=0; iEdge<s->numMultiEdges; iEdge++ ) {
            e = s->multiEdgeList[iEdge];
            CheckMultiEdge(e);
            ProcessEdge( g, e, internalEdges );
        }

    }
}


/***** GetComponent *****/
/* Returns the id of the component containing vertex v by traversing
 * the up-tree implied by the component pointers. After finding the root,
 * we do path compression, which makes this operation very efficient. */
DWORD
GetComponent(
    ToplGraphState *g,
    PToplVertex v
    )
{
    PToplVertex u, w;
    DWORD root, cmp;

    /* Find root of the up-tree created by component pointers */
    u=v;
    while( u->componentId!=(int) u->vtxId ) {

        ASSERT( u->componentId != UNCONNECTED_COMPONENT );
        ASSERT( u->componentId >= 0 );
        cmp = (DWORD) u->componentId;
        ASSERT( cmp < g->numVertices ); 

        u = &g->vertices[ cmp ];
        ASSERT( (DWORD) u->vtxId == cmp );
    }
    root = u->vtxId;
    
    /* Compress the path to the root */
    u=v;
    while( u->componentId!=(int) u->vtxId ) {

        ASSERT( u->componentId != UNCONNECTED_COMPONENT );
        ASSERT( u->componentId >= 0 );
        cmp = (DWORD) u->componentId;
        ASSERT( cmp < g->numVertices ); 

        w = &g->vertices[cmp];
        ASSERT( (DWORD) w->vtxId == cmp );
        u->componentId = root;
        u = w;
    }

    return root;
}


/***** EdgeCompare *****/
/* Sort the internal edges by key (redRed,cost,scheduleDuration,Vtx1Name,Vtx2Name).
 * Note: We consider edges with longer duration to be better.
 */
RTL_GENERIC_COMPARE_RESULTS
NTAPI EdgeCompare(
    RTL_GENERIC_TABLE *Table,
    PVOID p1, PVOID p2
    )
{
    PToplInternalEdge e1 = (PToplInternalEdge) p1;
    PToplInternalEdge e2 = (PToplInternalEdge) p2;
    DWORD d1, d2;

    ASSERT( e1!=NULL && e2!=NULL );

    /* Give priority to edges connecting two red vertices */
    if( e1->redRed && !e2->redRed ) {
        return GenericLessThan;
    } else if( !e1->redRed && e2->redRed ) {
        return GenericGreaterThan;
    }

    /* Sort based on cost */
    if( e1->ri.cost < e2->ri.cost ) {
        return GenericLessThan;
    } else if( e1->ri.cost > e2->ri.cost ) {
        return GenericGreaterThan;
    }

    /* Sort based on schedule duration */
    d1 = ToplScheduleDuration( e1->ri.schedule );
    d2 = ToplScheduleDuration( e2->ri.schedule );
    if( d1 > d2 ) {         /* Note: These comparisons are intentionally reversed */
        return GenericLessThan;
    } else if( d1 < d2 ) {
        return GenericGreaterThan;
    }

    /* Sort based on vertex1Name */
    if( e1->v1->vtxId < e2->v1->vtxId ) {
        return GenericLessThan;
    } else if( e1->v1->vtxId > e2->v1->vtxId ) {
        return GenericGreaterThan;
    }

    /* Sort based on vertex2Name */
    if( e1->v2->vtxId < e2->v2->vtxId ) {
        return GenericLessThan;
    } else if( e1->v2->vtxId > e2->v2->vtxId ) {
        return GenericGreaterThan;
    } 

    /* Sort based on edge type. It is possible that the edge types are equal,
     * but in that case we consider the edges to be identical. */
    if( e1->edgeType < e2->edgeType ) {
        return GenericLessThan;
    } else if( e1->edgeType > e2->edgeType ) {
        return GenericGreaterThan;
    }

    return GenericEqual;
}


/***** AddOutEdge *****/
/* We have found a new edge, e, for our spanning tree edge. Add this
 * edge to our list of output edges. */
VOID
AddOutEdge(
    PDynArray outputEdges, 
    PToplInternalEdge e
    )
{
    PTOPL_MULTI_EDGE ee;
    PToplVertex v1, v2;

    v1 = e->v1;
    v2 = e->v2;

    ASSERT( v1->root == v1 );           /* Both v1 and v2 should be root vertices */
    ASSERT( v2->root == v2 );
    ASSERT( v1->color != COLOR_WHITE );  /* ... which means they are colored */
    ASSERT( v2->color != COLOR_WHITE );

    /* Create an output multi edge */
    ee = CreateMultiEdge( 2 );
    ee->vertexNames[0].name = v1->vertexName;
    ee->vertexNames[0].reserved = v1->vtxId;
    ee->vertexNames[1].name = v2->vertexName;
    ee->vertexNames[1].reserved = v2->vtxId;
    ee->edgeType = e->edgeType;
    CopyReplInfo( &e->ri, &ee->ri );
    DynArrayAppend( outputEdges, &ee );

    /* We also add this new spanning-tree edge to the edge lists of its endpoints. */
    CheckMultiEdge( ee );
    DynArrayAppend( &v1->edgeList, &ee );
    DynArrayAppend( &v2->edgeList, &ee );
}


/***** Kruskal *****/
/* Run Kruskal's minimum-cost spanning tree algorithm on the internal edges
 * (which represent shortest paths in the original graph between colored
 * vertices). 
 * */
VOID
Kruskal(
    IN PToplGraphState g,
    IN RTL_GENERIC_TABLE *internalEdges,
    IN DWORD numExpectedTreeEdges,
    OUT PDynArray outputEdges
    )
{
    PToplInternalEdge e;
    DWORD comp1, comp2, cSTEdges;

    ClearEdgeLists( g );
    
    /* Counts the total number of spanning tree edges that we have found. This
     * count includes edges which are not incident with 'whichVtx'. This is done
     * so that we can stop building the spanning tree when we have enough edges. */
    cSTEdges=0;             
    
    /* Process every edge in the priority queue */
    while( ! RtlIsGenericTableEmpty(internalEdges) ) {

        e = (PToplInternalEdge) RtlEnumerateGenericTable( internalEdges, TRUE );
        ASSERT( e );

        /* We must prevent cycles in the spanning tree. If we are to add
         * edge e, we must ensure its endpoints are in different components */
        comp1 = GetComponent( g, e->v1 );
        comp2 = GetComponent( g, e->v2 );
        if( comp1!=comp2 ) {

            /* This internal edge connects two components, so it is a valid
             * spanning tree edge. */
            cSTEdges++;
             
            /* Add this edge to our list of output edges */
            AddOutEdge( outputEdges, e );

            /* Combine the two connected components */
            ASSERT( comp1<g->numVertices );
            ASSERT( g->vertices[comp1].componentId==(int) comp1 );
            g->vertices[comp1].componentId = comp2;

        }

        RtlDeleteElementGenericTable( internalEdges, e );
        if( cSTEdges==numExpectedTreeEdges ) {
            break;
        }
    }
}


/***** DepthFirstSearch *****/
/* Do a non-recursive depth-first-search from node v. To avoid recursion we
 * store a 'parent' pointer in each vertex, and to avoid rescanning the edge-lists
 * unnecessarily, we store a 'nextChild' index in each vertex. */
VOID
DepthFirstSearch(
    IN PToplGraphState g,
    IN PToplVertex rootVtx
    )
{
    PToplVertex v, w;
    PTOPL_MULTI_EDGE e;
    DWORD cEdge;

    rootVtx->distToRed = 0;
    ASSERT( 0==rootVtx->nextChild );
    ASSERT( NULL==rootVtx->parent );
    ASSERT( COLOR_RED==rootVtx->color );
    
    /* DFS through the tree until we reach the root again. */
    for( v=rootVtx; NULL!=v; ) {
        
        /* Examine every edge in v's edge list */
        cEdge = DynArrayGetCount( &v->edgeList );
        if( v->nextChild>=cEdge ) {
            v = v->parent;
            continue;
        }
        
        /* Retrieve the edge from the edge list */
        e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( &v->edgeList, v->nextChild ));
        CheckMultiEdge( e );
        ASSERT( 2==e->numVertices );
        ASSERT( e->vertexNames[0].reserved<g->numVertices );
        ASSERT( e->vertexNames[1].reserved<g->numVertices );
        v->nextChild++;
        
        /* Find the endpoint of the edge which is not v */
        w = &g->vertices[ e->vertexNames[0].reserved ];
        if( v==w ) {
            w = &g->vertices[ e->vertexNames[1].reserved ];
        }
        ASSERT( w!=NULL );
        
        /* Ignore this edge if w has already been processed */
        if( INFINITY!=w->distToRed ) {
            /* Note: No guarantee that w is in the same tree as v, because
             * of directed edges */
            continue;
        }
        
        /* Compute distToRed value for w */
        ASSERT( 0==w->nextChild );
        ASSERT( NULL==w->parent );
        ASSERT( INFINITY==w->distToRed );
        w->parent = v;
        if( COLOR_RED==w->color ) {
            w->distToRed = 0;
            ASSERT( COLOR_RED==v->color );
        } else {
            w->distToRed = v->distToRed+1;
        }
        v = w;
    }
}


/***** CalculateDistToRed *****/
/* Do a DFS on the spanning tree in order to calculate distToRed for all vtx. */
VOID
CalculateDistToRed(
    IN PToplGraphState g,
    IN PDynArray outputEdges
    )
{
    PToplVertex v;
    DWORD iVtx;

    /* Initialize the vertices */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        v = &g->vertices[iVtx];
        ASSERT( NULL!=v );

        v->nextChild = 0;
        v->parent = NULL;
        v->distToRed = INFINITY;
    }
        
    /* Start a DFS from all red vertices */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        v = &g->vertices[iVtx];
        ASSERT( NULL!=v );
        if( COLOR_RED!=v->color || INFINITY!=v->distToRed ) {
            continue;
        }

        DepthFirstSearch( g, v );
    }
}


/***** CountComponents *****/
/* Count the number of components. A component is considered to be a bunch
 * colered vertices which are connected by the spanning tree. Vertices whose
 * component id is the same as their vertex id are the root of a connected
 * component.
 *
 * When we find a root of a component, we record its 'component index'. The
 * component indices are a contiguous sequence of numbers which uniquely
 * identify a component. */
DWORD
CountComponents(
    IN PToplGraphState      g
    )
{
    PToplVertex     v;
    DWORD           iVtx, numComponents=0, compId;

    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        v = &g->vertices[iVtx];
        if( COLOR_WHITE==v->color ) {
            /* It's a non-colored vertex. Ignore it. */
            continue;
        }
        ASSERT( v->color==COLOR_RED || v->color==COLOR_BLACK );
        ASSERT( v->componentId != UNCONNECTED_COMPONENT );

        compId = GetComponent(g, v);
        if( compId == (int) iVtx ) {        /* It's a component root */
            v->componentIndex = numComponents;
            numComponents++;
        }
    }

    return numComponents;
}


/***** ScanVertices *****/
/* Iterate over all vertices in the graph. Accumulate a count of the number
 * of (red or black) vertices in each graph component.
 *
 * If the parameter 'fWriteToList' is TRUE, we also add each vertex's name
 * into the list of vertices which are in that component. This assumes that
 * memory for the list has already been allocated.
 */
VOID
ScanVertices(
    IN PToplGraphState      g,
    IN BOOL                 fWriteToList,
    IN OUT PTOPL_COMPONENTS pComponents
    )
{
    PToplVertex     v;
    TOPL_COMPONENT *pComp;
    DWORD           i, iVtx, compIndex, numVtx;
    int             compId;

    /* Check the parameters */
    ASSERT( NULL!=pComponents );
    ASSERT( NULL!=pComponents->pComponent );

    /* Clear the vertex counts on all the components */
    for( i=0; i<pComponents->numComponents; i++ ) {
        pComponents->pComponent[i].numVertices = 0;
    }

    /* Scan the vertices, counting the number of vertices per component */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        v = &g->vertices[iVtx];
        if( COLOR_WHITE==v->color ) {
            continue;
        }

        /* Find out the component index */
        ASSERT( v->componentId != UNCONNECTED_COMPONENT );
        compId = GetComponent( g, v );
        ASSERT( 0<=compId && compId<(int)g->numVertices );
        ASSERT( g->vertices[compId].componentId == compId );
        compIndex = g->vertices[compId].componentIndex;

        ASSERT( compIndex<pComponents->numComponents );
        pComp = &pComponents->pComponent[compIndex];
        
        /* Add this vertex to the list of vertices in this component */
        if( fWriteToList ) {
            numVtx = pComp->numVertices;
            ASSERT( NULL!=pComp->vertexNames );
            pComp->vertexNames[numVtx] = v->vertexName;
        }

        /* Increment the count of vertices */
        pComp->numVertices++;
    }
}


/***** SwapFilterVertexToFront *****/
/* The caller of ToplGetSpanningTreeEdgesForVtx() probably wants to know which
 * component the filter vertex (i.e. 'whichVertex') is in. We ensure that 
 * the first component in the list contains the filter vertex. */
VOID
SwapFilterVertexToFront(
    IN PToplGraphState      g,
    IN PToplVertex          whichVertex,
    IN OUT PTOPL_COMPONENTS pComponents
    )
{
    TOPL_COMPONENT      tempComp, *pComp1, *pComp2;
    DWORD               iVtx, whichCompId, whichCompIndex, compSize;

    /* If there is no filter vertex, there is no work to be done. */
    if( NULL==whichVertex ) {
        return;
    }

    /* We want the component containing the filter vertex (i.e. 'whichVertex') to
     * be the first one in the list. */
    whichCompId = GetComponent( g, whichVertex );
    ASSERT( -1!=whichCompId );
    ASSERT( g->vertices[whichCompId].componentId == whichCompId );
    whichCompIndex = g->vertices[ whichCompId ].componentIndex;
    ASSERT( whichCompIndex < pComponents->numComponents );

    /* Swap the component containing the filter vertex with the first component */
    pComp1 = &pComponents->pComponent[0];
    pComp2 = &pComponents->pComponent[whichCompIndex];
    compSize = sizeof(TOPL_COMPONENT);
    memcpy( &tempComp, pComp1, compSize );
    memcpy( pComp1, pComp2, compSize );
    memcpy( pComp2, &tempComp, compSize );

    /* The component index fields are now invalid. We don't actually need
     * them any more so we clear them out. */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        g->vertices[iVtx].componentIndex = 0;
    }
}


/***** ConstructComponents *****/
/* Build a structure containing a list of components. For each component we
 * store a list of vertices in that component. If 'whichVertex' is non-NULL,
 * the component containing it will be the first one in the list.
 *
 * Note: We only care about the red/black vertices here. We're not interested
 * in which component the white vertices are in. */
VOID
ConstructComponents(
    IN PToplGraphState      g,
    IN PToplVertex          whichVertex,
    IN OUT PTOPL_COMPONENTS pComponents
    )
{
    DWORD           iComp, numComponents, numVtx;
    
    /* Check if the caller actually wants component info */
    if( NULL==pComponents ) {
        return;
    }

    numComponents = CountComponents( g );

    /* Allocate and initialize the structure which will describe the components */
    pComponents->pComponent = ToplAlloc( numComponents * sizeof(TOPL_COMPONENT) );
    pComponents->numComponents = numComponents;
    for( iComp=0; iComp<numComponents; iComp++ ) {
        pComponents->pComponent[iComp].numVertices = 0;
        pComponents->pComponent[iComp].vertexNames = NULL;
    }

    /* Scan the vertices, counting the number of vertices in each component */
    ScanVertices( g, FALSE, pComponents );

    /* Now that we know how many vertices are in each component, allocate memory for
     * each component's list of vertices */
    for( iComp=0; iComp<numComponents; iComp++ ) {
        numVtx = pComponents->pComponent[iComp].numVertices;
        ASSERT( numVtx>0 );
        pComponents->pComponent[iComp].vertexNames =
            (PVOID*) ToplAlloc( numVtx * sizeof(PVOID) );
    }

    /* Scan the vertices again, this time storing each vertex's name in its
     * component's list. */
    ScanVertices( g, TRUE, pComponents );

    SwapFilterVertexToFront( g, whichVertex, pComponents );
}


/***** CopyOutputEdges *****/
/* All spanning-tree edges are stored in the Dynamic Array 'outputEdges'.
 * We extract all edges which contain 'whichVtx' as an endpoint and copy
 * them to a new TOPL_MULTI_EDGE array. If 'whichVtx' is NULL, we extract
 * all edges. */
PTOPL_MULTI_EDGE*
CopyOutputEdges(
    IN PToplGraphState g,
    IN PDynArray outputEdges,
    IN PToplVertex whichVtx,
    OUT DWORD *numEdges
    )
{
    DWORD iEdge, cEdge, iOutputEdge, cOutputEdge=0;
    PToplVertex v, w;
    PTOPL_MULTI_EDGE e;
    PTOPL_MULTI_EDGE *list;
    TOPL_NAME_STRUCT tempVtxName;

    cEdge = DynArrayGetCount( outputEdges );
    /* Count the number of edges which are incident with 'whichVtx' */
    for( iEdge=0; iEdge<cEdge; iEdge++ ) {

        /* Retrieve the next edge */
        e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( outputEdges, iEdge ));
        CheckMultiEdge( e );
        ASSERT( 2==e->numVertices );
        ASSERT( e->vertexNames[0].reserved<g->numVertices );
        ASSERT( e->vertexNames[1].reserved<g->numVertices );

        if(  whichVtx==NULL
          || e->vertexNames[0].reserved==whichVtx->vtxId
          || e->vertexNames[1].reserved==whichVtx->vtxId )
        {
            cOutputEdge++;
        }
    }

    /* Allocate an array to hold the filtered output edges */
    list = (PTOPL_MULTI_EDGE*) ToplAlloc( cOutputEdge*sizeof(PTOPL_MULTI_EDGE) );

    /* Examine every edge in the dynamic array and copy it to the filtered
     * array if necessary. */
    for( iEdge=iOutputEdge=0; iEdge<cEdge; iEdge++ ) {

        /* Retrieve the next edge */
        e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( outputEdges, iEdge ));
        CheckMultiEdge( e );
        ASSERT( 2==e->numVertices );
        ASSERT( e->vertexNames[0].reserved<g->numVertices );
        ASSERT( e->vertexNames[1].reserved<g->numVertices );

        v = &g->vertices[ e->vertexNames[0].reserved ];
        w = &g->vertices[ e->vertexNames[1].reserved ];

        if( whichVtx==NULL || v==whichVtx || w==whichVtx ) {
            ASSERT( iOutputEdge<cOutputEdge );
            list[iOutputEdge++] = e;

            /* Check if this edge meets the criteria of a 'directed edge'. */
            if(  (COLOR_BLACK==v->color || COLOR_BLACK==w->color)
              && INFINITY!=v->distToRed )
            {
                ASSERT( INFINITY!=w->distToRed );
                ASSERT( v->distToRed!=w->distToRed );
                e->fDirectedEdge = TRUE;

                /* Swap the vertices so that e->vertexNames[0] is closer to a
                 * red vertex than e->vertexNames[1]. */
                if( w->distToRed<v->distToRed ) {
                    memcpy( &tempVtxName, &e->vertexNames[0], sizeof(TOPL_NAME_STRUCT) );
                    memcpy( &e->vertexNames[0], &e->vertexNames[1], sizeof(TOPL_NAME_STRUCT) );
                    memcpy( &e->vertexNames[1], &tempVtxName, sizeof(TOPL_NAME_STRUCT) );
                }
            }
        }
    }

    ASSERT( iOutputEdge==cOutputEdge );
    *numEdges = cOutputEdge;
    return list;
}


/***** ClearInternalEdges *****/
/* After the spanning-tree algorithm has completed, we free all edges from
 * the 'internalEdges' list. */
VOID
ClearInternalEdges(
    IN RTL_GENERIC_TABLE *internalEdges
    )
{
    PToplInternalEdge e;

    while( ! RtlIsGenericTableEmpty(internalEdges) ) {
        e = (PToplInternalEdge) RtlEnumerateGenericTable( internalEdges, TRUE );
        RtlDeleteElementGenericTable( internalEdges, e );
    }
}


/***** CheckAllMultiEdges *****/
/* This function is used to check that all multi-edges have been properly
 * setup before running the spanning-tree algorithm. This ensures that
 * all edges have all of their vertices setup properly. */
VOID
CheckAllMultiEdges(
    IN PToplGraphState g
    )
{
    PTOPL_MULTI_EDGE e;
    DWORD iEdge, cEdge, iVtx;

    cEdge = DynArrayGetCount( &g->masterEdgeList );
    for( iEdge=0; iEdge<cEdge; iEdge++ ) {
        e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( &g->masterEdgeList, iEdge ));
        CheckMultiEdge(e);
        for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
            if( e->vertexNames[iVtx].name==NULL ) {
                ToplRaiseException( TOPL_EX_INVALID_VERTEX );
            }
        }
    }
}


/***** ToplGetSpanningTreeEdgesForVtx *****/
/* This function is the heart of the spanning-tree generation algorithm.
 * Its behavior is fairly complicated, but briefly it generates a minimum
 * cost spanning tree connecting the red and black vertices. It uses
 * edge sets and other (non-colored) vertices in the graph to determine how
 * the colored vertices can be connected. This function returns all tree edges
 * containing 'whichVtx'. */
PTOPL_MULTI_EDGE*
ToplGetSpanningTreeEdgesForVtx(
    IN PTOPL_GRAPH_STATE G,
    IN PVOID whichVtxName,
    IN TOPL_COLOR_VERTEX *colorVtx,
    IN DWORD numColorVtx,
    OUT DWORD *numStEdges,
    OUT PTOPL_COMPONENTS pComponents
    )
{
    PToplGraphState g;
    RTL_GENERIC_TABLE internalEdges;
    PTOPL_MULTI_EDGE *stEdgeList;
    PToplVertex whichVtx=NULL;
    DynArray outputEdges;
    DWORD iEdgeSet, cEdgeSet, edgeType, numTreeEdges=numColorVtx-1;


    /* Check parameters */
    g = CheckGraphState( G );
    if( numStEdges==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    if( whichVtxName!=NULL ) {
        whichVtx = FindVertex( g, whichVtxName );
        if( whichVtx==NULL ) {
            ToplRaiseException( TOPL_EX_INVALID_VERTEX );
        }
    }
    if( numColorVtx<2 ) {
        ToplRaiseException( TOPL_EX_COLOR_VTX_ERROR );
    }
    CheckAllMultiEdges( g );

    InitColoredVertices( g, colorVtx, numColorVtx, whichVtx );


    /******************************************************************************
     * Phase I: Run Dijkstra's algorithm, and build up a list of internal edges,
     * which are just really shortest-paths connecting colored vertices. 
     ******************************************************************************/
    RtlInitializeGenericTable( &internalEdges, EdgeCompare, TableAlloc, TableFree, NULL );

    /* Process all edge sets */
    cEdgeSet = DynArrayGetCount( &g->edgeSets );
    for( iEdgeSet=0; iEdgeSet<cEdgeSet; iEdgeSet++ ) {

        /* Setup the graph to use the edges from edge set iEdgeSet */
        edgeType = SetupEdges( g, iEdgeSet );
        
        /* Run Dijkstra's algorithm with just the red vertices as the roots */
        Dijkstra( g, edgeType, FALSE );
        
        /* Process the minimum-spanning forest built by Dijkstra, and add any
         * inter-tree edges to our list of internal edges */
        ProcessEdgeSet( g, (int) iEdgeSet, &internalEdges );
        
        /* Run Dijkstra's algorithm with Union(redVtx,blackVtx) as the root vertices */
        Dijkstra( g, edgeType, TRUE );
        
        /* Process the minimum-spanning forest built by Dijkstra, and add any
         * inter-tree edges to our list of internal edges */
        ProcessEdgeSet( g, (int) iEdgeSet, &internalEdges );
    }

    /* Process the implicit empty edge set */
    SetupVertices( g );
    ProcessEdgeSet( g, EMPTY_EDGE_SET, &internalEdges );


    /******************************************************************************
     * Phase II: Run Kruskal's Algorithm on the internal edges. 
     ******************************************************************************/
    DynArrayInit( &outputEdges, sizeof(PTOPL_MULTI_EDGE) );
    Kruskal( g, &internalEdges, numTreeEdges, &outputEdges );


    /******************************************************************************
     * Phase III: Post-process the output.
     *  - Traverse tree structure to find one-way black-black edges
     *  - Determine the component structure
     ******************************************************************************/
    CalculateDistToRed( g, &outputEdges );
    ConstructComponents( g, whichVtx, pComponents );
    stEdgeList = CopyOutputEdges( g, &outputEdges, whichVtx, numStEdges );

    /* Clean up */
    ClearInternalEdges( &internalEdges );
    DynArrayDestroy( &outputEdges );

    return stEdgeList;
}


/***** ToplDeleteSpanningTreeEdges *****/
/* After finding the spanning-tree edges, this function should be used to
 * free their memory. */
VOID
ToplDeleteSpanningTreeEdges(
    PTOPL_MULTI_EDGE *stEdgeList,
    DWORD numStEdges )
{
    DWORD i;

    if( stEdgeList==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }

    for( i=0; i<numStEdges; i++ ) {
        if( stEdgeList[i]==NULL ) {
            ToplRaiseException( TOPL_EX_NULL_POINTER );
        }
        /* Todo: Could check that the number of vertices is 2 */
        FreeMultiEdge( stEdgeList[i] );
    }
    ToplFree( stEdgeList );
}


/***** ToplDeleteComponents *****/
/* After finding the spanning-tree edges, this function should be used to
 * free the data about the components */
VOID
ToplDeleteComponents(
    PTOPL_COMPONENTS pComponents
    )
{
    DWORD iComp, cComp;

    if( NULL==pComponents || NULL==pComponents->pComponent ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }

    cComp = pComponents->numComponents;
    for( iComp=0; iComp<cComp; iComp++ ) {
        ASSERT( NULL!=pComponents->pComponent[iComp].vertexNames );
        ToplFree( pComponents->pComponent[iComp].vertexNames );
        pComponents->pComponent[iComp].vertexNames = NULL;
        pComponents->pComponent[iComp].numVertices = 0; 
    }

    ToplFree( pComponents->pComponent );
    pComponents->pComponent = NULL;
    pComponents->numComponents = 0;
}


/***** ToplDeleteGraphState *****/
/* After the ToplGraphState object is not needed any more, this function
 * should be used to free its memory. */
VOID
ToplDeleteGraphState(
    PTOPL_GRAPH_STATE G
    )
{
    ToplGraphState *g;
    PTOPL_MULTI_EDGE e;
    DWORD i, cEdge;

    g = CheckGraphState( G );
    g->vertexNames = NULL;              /* Should be freed by user */

    /* Destroy vertices */
    for( i=0; i<g->numVertices; i++ ) {
        DynArrayDestroy( &g->vertices[i].edgeList );
    }
    ToplFree( g->vertices );
    g->vertices = NULL;

    /* Destroy the edges */
    cEdge = DynArrayGetCount( &g->masterEdgeList );
    for( i=0; i<cEdge; i++ ) {
        e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( &g->masterEdgeList, i ));
        CheckMultiEdge(e);
        FreeMultiEdge(e);
    }

    /* The edges and the edge sets should be freed by user */
    DynArrayDestroy( &g->masterEdgeList );
    DynArrayDestroy( &g->edgeSets );

    ToplFree( g );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\stheap.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stheap.h

Abstract:

    This file implements a binary heap. This heap supports the
    'cost reduced' operation, as required by Dijkstra's algorithm.

Notes:
    The first element in the heap is at index 1. Index 0 is not used.
    The nextFreeSpot gives the index of where the next element would
    be inserted in the heap. This should always be <= maxSize+1. The
    heap is full when nextFreeSpot == maxSize+1.
    The number of empty spots is thus maxSize-nextFreeSpot+1.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    20-6-2000   NickHar   Created
    
--*/

/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "stheap.h"


/***** Macros *****/
#define ELEMENT_MOVED(x)    heap->SetLocn(heap->data[x],x,heap->extra);


/***** ToplSTHeapInit *****/
PSTHEAP
ToplSTHeapInit(
    DWORD                   maxSize,
    STHEAP_COMPARE_FUNC     Compare,
    STHEAP_GET_LOCN_FUNC    GetLocn,
    STHEAP_SET_LOCN_FUNC    SetLocn,
    PVOID                   extra
    )
{
    PSTHEAP heap;
    DWORD size;

    /* Check parameters */
    ASSERT( maxSize>0 );
    ASSERT( Compare!=NULL && GetLocn!=NULL && SetLocn!=NULL );

    heap = ToplAlloc( sizeof(STHEAP) );
    heap->nextFreeSpot = 1;
    heap->maxSize=maxSize;
    heap->Comp=Compare;
    heap->GetLocn=GetLocn;
    heap->SetLocn=SetLocn;
    heap->extra = extra;

    __try {
        size = sizeof(PVOID)*(maxSize+2);
        heap->data = ToplAlloc( size );
        RtlZeroMemory( heap->data, size );
    } __finally {
        if( AbnormalTermination() ) {
            ToplFree( heap );
        }
    }

    ASSERT( heap && heap->data );
    return heap;
}


/***** HeapNumEmptySpots *****/
int
static HeapNumEmptySpots(
    PSTHEAP heap
    )
{
    int empty = heap->maxSize-heap->nextFreeSpot+1;
    ASSERT( 1<=heap->nextFreeSpot );
    ASSERT( empty>=0 );
    return empty;
}


/***** ToplSTHeapDestroy *****/
/* Destroy a heap after it is no longer needed */
VOID
ToplSTHeapDestroy(
    PSTHEAP heap
    )
{
    ASSERT( heap && heap->data );
    ASSERT( HeapNumEmptySpots(heap)>=0 );
    ToplFree( heap->data );
    RtlZeroMemory( heap, sizeof(STHEAP) );
    ToplFree( heap );
}


/***** HeapBubbleUp *****/
/* Bubble an element up to its appropriate spot */
static VOID
HeapBubbleUp(
    PSTHEAP heap,
    DWORD bubbleFrom
    )
{
    int cmp;
    DWORD currentSpot, parent;
    PVOID temp;

    ASSERT( 1<=bubbleFrom && bubbleFrom<heap->nextFreeSpot );

    currentSpot = bubbleFrom;
    while( currentSpot>1 ) {
        parent = currentSpot / 2;
        ASSERT( 1<=parent && parent<bubbleFrom );

        ASSERT( heap->data[parent] );
        ASSERT( heap->data[currentSpot] );
        cmp = heap->Comp( heap->data[parent], heap->data[currentSpot], heap->extra );
        if( cmp<=0 ) {
            /* Parent is less or equal: new element is in the right spot */
            break;
        }

        /* Parent is smaller -- must move 'currentSpot' up */
        temp = heap->data[parent];
        heap->data[parent] = heap->data[currentSpot];
        heap->data[currentSpot] = temp;
        ELEMENT_MOVED( parent );
        ELEMENT_MOVED( currentSpot );

        currentSpot = parent;
    }
}


/***** HeapBubbleDown *****/
/* Bubble an element down to its appropriate spot */
static VOID
HeapBubbleDown(
    PSTHEAP heap,
    DWORD bubbleFrom
    )
{
    DWORD currentSpot, newSpot, left, right;
    int cmp;
    PVOID temp;

    currentSpot = bubbleFrom; 
    for(;;) {
        newSpot = currentSpot;
        left = 2*currentSpot;
        right = left+1;
        ASSERT( heap->GetLocn(heap->data[currentSpot],heap->extra)==(int)currentSpot );

        /* Check to see if the left child is less than the current spot */
        if( left<heap->nextFreeSpot ) {
            ASSERT( heap->data[left] );
            cmp = heap->Comp( heap->data[left], heap->data[currentSpot], heap->extra );
            if( cmp<0 ) {
                newSpot = left;
            }
        }

        /* Check to see if the right child is less than the new spot */
        if( right<heap->nextFreeSpot ) {
            ASSERT( heap->data[right] );
            cmp = heap->Comp( heap->data[right], heap->data[newSpot], heap->extra );
            if( cmp<0 ) {
                newSpot = right;
            }
        }

        /* newSpot is element with minimum cost in the set
         *  { heap[currentSpot], heap[left], heap[right] } */
        if( newSpot!=currentSpot ) {
            /* newSpot is smaller -- must move currentSpot down */
            temp = heap->data[newSpot];
            heap->data[newSpot] = heap->data[currentSpot];
            heap->data[currentSpot] = temp;
            ELEMENT_MOVED( newSpot );
            ELEMENT_MOVED( currentSpot );
        } else {
            /* The element is now in place */
            break;
        }

        ASSERT( newSpot>=currentSpot );
        currentSpot = newSpot;
    }

}


/***** ToplSTHeapAdd *****/
/* Add an element to the heap. The element must not be null, and
 * must be able to support the functions GetCost, etc. */
VOID
ToplSTHeapAdd(
    PSTHEAP heap,
    PVOID element
    )
{
    DWORD insertionPoint;
    
    /* Check that pointers are okay */
    ASSERT( heap && heap->data );
    ASSERT( element );
    /* Ensure element is not already in the heap */
    ASSERT( heap->GetLocn(element,heap->extra)==STHEAP_NOT_IN_HEAP );
    /* Ensure at least one spot is free */
    ASSERT( HeapNumEmptySpots(heap)>=1 );

    /* Find the insertion point and put the new element there */
    insertionPoint = heap->nextFreeSpot;
    heap->data[insertionPoint] = element;
    ELEMENT_MOVED( insertionPoint );

    heap->nextFreeSpot++;
    ASSERT( 1<heap->nextFreeSpot && HeapNumEmptySpots(heap)>=0 );

    HeapBubbleUp( heap, insertionPoint );
}


/***** ToplSTHeapExtractMin *****/
/* Extract the object with minimum cost from the heap. When the heap
 * is empty, returns NULL. */
PVOID
ToplSTHeapExtractMin(
    PSTHEAP heap
    )
{
    PVOID result;

    /* Check that pointers are okay */
    ASSERT( heap && heap->data );
    ASSERT( (DWORD)HeapNumEmptySpots(heap)<=heap->maxSize );

    /* If the heap is empty, just return NULL */
    if( heap->nextFreeSpot==1 ) {
        return NULL;
    }

    /* Grab the top element and reduce the heap size */
    result = heap->data[1];
    ASSERT( result );
    heap->SetLocn( result, STHEAP_NOT_IN_HEAP, heap->extra );

    /* Decrease the heap size */
    heap->nextFreeSpot--;
    if( heap->nextFreeSpot==1 ) {
        /* The heap is now empty -- we can return immediately */
        return result;
    }
    
    /* Move the last element in the heap to the top */
    heap->data[1] = heap->data[ heap->nextFreeSpot ];
    ASSERT( heap->data[1] );
    ASSERT( heap->GetLocn(heap->data[1],heap->extra)==(int)heap->nextFreeSpot );
    ELEMENT_MOVED( 1 );
    HeapBubbleDown( heap, 1 );

    return result;
}


/***** ToplSTHeapCostReduced *****/
/* Notify the heap that an element's cost has just been reduced.
 * The heap will be (efficiently) shuffled so that the heap property
 * is maintained */
VOID
ToplSTHeapCostReduced(
    PSTHEAP heap,
    PVOID element
    )
{
    DWORD child;
    int locn;

    /* Check that pointers are okay */
    ASSERT( heap && heap->data );
    ASSERT( element );
    /* Ensure element is already in the heap */
    locn = heap->GetLocn( element, heap->extra );
    ASSERT( 1<=locn && locn<(int)heap->nextFreeSpot );
    /* Ensure at least one spot is in use */
    ASSERT( (DWORD)HeapNumEmptySpots(heap)<heap->maxSize );
    
    /* Check that the heap property is still okay between this element
     * and its children (if they exist) */
    child = 2*locn;
    if( child<heap->nextFreeSpot ) {
        ASSERT( heap->Comp(heap->data[locn],heap->data[child],heap->extra) <= 0 );
    }
    child++;
    if( child<heap->nextFreeSpot ) {
        ASSERT( heap->Comp(heap->data[locn],heap->data[child],heap->extra) <= 0 );
    }

    HeapBubbleUp( heap, locn );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\stda.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stda.c

Abstract:

    Implements a dynamic array, for use by the new spanning-tree algorithm.
    Differs from DYNAMIC_ARRAY in that objects can be stored in the array
    instead of pointers to objects.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    19-6-2000   NickHar   Created

Notes:
    W32TOPL's allocator (which can be set by the user) is used for memory allocation
    
--*/

/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "stda.h"


/***** Constants *****/
#define MIN_CHUNK_GROW_SIZE 10


/***** DynArrayInit *****/
/* Initialize a dynamic array. The 'allocationChunk' indicates how many new elements will
 * be allocated at a time when we allocate new memory. If this parameter is 0, a default
 * value will be used. */
VOID
DynArrayInit(
    DynArray    *d,
    DWORD       elementSize
    )
{
    ASSERT(d);

    /* Initialize array members */
    d->elementSize = elementSize;
    d->logicalElements = d->physicalElements = 0;
    d->data = NULL;
    d->fSorted = FALSE;
}


/***** DynArrayClear *****/
/* Clear all the entries from an array. The array must have been
 * initialized before calling this function. */
VOID
DynArrayClear(
    DynArray    *d
    )
{
    ASSERT(d);
    if( d->data ) {
        ToplFree( d->data );
    }
    d->logicalElements = d->physicalElements = 0;
    d->data = NULL;
}


/***** DynArrayDestroy *****/
VOID
DynArrayDestroy(
    DynArray    *d
    )
{
    DynArrayClear(d);
}


/***** DynArrayGetCount *****/
DWORD
DynArrayGetCount(
    DynArray    *d
    )
{
    ASSERT(d);
    return d->logicalElements;
}


/***** DynArrayRetrieve *****/
PVOID
DynArrayRetrieve(
    DynArray    *d,
    DWORD       index
    )
{
    PVOID newMem;

    ASSERT( d );
    ASSERT( index < d->logicalElements );

    return &d->data[ index * d->elementSize ];
}


/***** DynArrayAppend *****/
/* Increase the size of the array, making room for (at least) one new element.
 * If newElementData is non-NULL, copy this data into the new spot.
 * Return a pointer to the memory for the newly allocated element. */
PVOID
DynArrayAppend(
    DynArray    *d,
    PVOID       newElementData
    )
{
    DWORD newIndex;
    PVOID newMem;

    ASSERT(d);
    newIndex = d->logicalElements;

    /* Increase the size of the array and allocate new space */
    d->logicalElements++;
    if( d->logicalElements > d->physicalElements ) {
        /* The array grows exponentially */
        d->physicalElements = 2*(d->physicalElements+MIN_CHUNK_GROW_SIZE);
        if( d->data ) {
            d->data = ToplReAlloc( d->data, d->elementSize * d->physicalElements );
        } else {
            d->data = ToplAlloc( d->elementSize * d->physicalElements );
        }
    }

    /* Get the address of where the new element will go */
    newMem = DynArrayRetrieve( d, newIndex );

    /* Copy in the new data, if we were given some */
    if( newElementData ) {
        RtlCopyMemory( newMem, newElementData, d->elementSize );
    }

    d->fSorted = FALSE;

    /* Return a pointer to the memory for the new element */
    return newMem;
}

/***** DynArraySort *****/
VOID
DynArraySort(
    DynArray    *d,
    DynArrayCompFunc cmp
    )
{
    ASSERT(d);
    if( d->logicalElements>1 ) {
        ASSERT(d->data);
        qsort( d->data, d->logicalElements, d->elementSize, cmp );
    }
    d->fSorted = TRUE;
}


/***** DynArraySearch *****/
/* Search an array for an element. If the element is not found, returns
 * DYN_ARRAY_NOT_FOUND, otherwise returns the index of the element in
 * the array. The array must be in sorted order for this to work. */
int
DynArraySearch(
    DynArray    *d,
    PVOID       key,
    DynArrayCompFunc cmp
    )
{
    PVOID result;
    int index;

    ASSERT(d);
    ASSERT(d->data);
    ASSERT(d->fSorted);

    result = bsearch( key, d->data, d->logicalElements, d->elementSize, cmp );
    if( result==NULL ) {
        return DYN_ARRAY_NOT_FOUND;
    }

    index = (int) ( ((unsigned char*) result)-d->data ) / d->elementSize;
    ASSERT( 0<=index && index< (int) d->logicalElements );

    return index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\toplgrph.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplgrph.h

Abstract:

    This file define the basic graph functions

Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#ifndef __TOPLGRPH_H
#define __TOPLGRPH_H

//
// Used a sentinel for the edge weight in mst functions
//
#define DWORD_INFINITY  ((DWORD)~0)

PEDGE
ToplpEdgeCreate(
    PEDGE Edge OPTIONAL
    );

VOID
ToplpEdgeDestroy(
    PEDGE    Edge,
    BOOLEAN  fFree
    );

VOID
ToplpEdgeSetToVertex(
    PEDGE   Edge,
    PVERTEX ToVertex
    );

PVERTEX
ToplpEdgeGetToVertex(
    PEDGE   Edge
    );

VOID
ToplpEdgeSetFromVertex(
    PEDGE   Edge,
    PVERTEX FromVertex
    );

PVERTEX
ToplpEdgeGetFromVertex(
    PEDGE pEdge
    );

VOID
ToplpEdgeSetWeight(
    PEDGE   Edge,
    DWORD   Weight
    );

DWORD
ToplpEdgeGetWeight(
    PEDGE pEdge
    );

VOID
ToplpEdgeAssociate(
    PEDGE pEdge
    );

VOID
ToplpEdgeDisassociate(
    PEDGE pEdge
    );

PVERTEX
ToplpVertexCreate(
    PVERTEX Vertex OPTIONAL
    );

VOID
ToplpVertexDestroy(
    PVERTEX    pVertex,
    BOOLEAN    fFree
    );

VOID
ToplpVertexSetId(
    PVERTEX   pVertex,
    DWORD     Id
    );

DWORD
ToplpVertexGetId(
    PVERTEX pVertex
    );

VOID
ToplpVertexSetParent(
    PVERTEX   pVertex,
    PVERTEX   pParent
    );

PVERTEX
ToplpVertexGetParent(
    PVERTEX pVertex
    );

VOID
ToplpVertexAddEdge(
    PVERTEX Vertex,
    PEDGE   pEdge
    );

VOID
ToplpVertexRemoveEdge(
    PVERTEX pVertex,
    PEDGE   pEdge
    );

DWORD
ToplpVertexNumberOfInEdges(
    PVERTEX   pVertex
    );

PEDGE
ToplpVertexGetInEdge(
    PVERTEX   pVertex,
    DWORD     Index
    );

DWORD
ToplpVertexNumberOfOutEdges(
    PVERTEX   pVertex
    );

PEDGE
ToplpVertexGetOutEdge(
    PVERTEX   pVertex,
    DWORD     Index
    );

PGRAPH
ToplpGraphCreate(
    PGRAPH Graph OPTIONAL
    );

VOID
ToplpGraphDestroy(
    PGRAPH   Graph,
    BOOLEAN  fFree,
    BOOLEAN  fRecursive
    );

VOID
ToplpGraphAddVertex(
    PGRAPH  pGraph,
    PVERTEX pVertex
    );

PVERTEX
ToplpGraphRemoveVertex(
    PGRAPH  pGraph,
    PVERTEX pVertex
    );
      
VOID
ToplpGraphSetVertexIter(
    PGRAPH    pGraph,
    PITERATOR pIter
    );


DWORD
ToplpGraphNumberOfVertices(
    PGRAPH    pGraph
    );


TOPL_COMPONENTS*
ToplpGraphFindEdgesForMST(
    IN  PGRAPH  Graph,
    IN  PVERTEX RootVertex,
    IN  PVERTEX VertexOfInterest,
    OUT PEDGE**  pEdges,
    OUT ULONG*  cEdges
    );

#endif // __TOPLGRPH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\toplgrph.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplgrph.c

Abstract:

    This routine defines the private edge, list and graph routines.  

Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>

typedef unsigned long DWORD;


#include <w32topl.h>
#include <w32toplp.h>

#include <dynarray.h>
#include <topllist.h>
#include <toplgrph.h>

PEDGE
ToplpEdgeCreate(
    PEDGE Edge OPTIONAL
    )        

/*++                                                                           

Routine Description:

    This routine creates an edge object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{    
    PEDGE pEdge = Edge;

    if (!pEdge) {
        pEdge = ToplAlloc(sizeof(EDGE));
    }

    memset(pEdge, 0, sizeof(EDGE));

    pEdge->ObjectType = eEdge;

    return pEdge;
}

VOID
ToplpEdgeDestroy(
    PEDGE   pEdge,
    BOOLEAN fFree
    )
/*++                                                                           

Routine Description:

    This routine frees a PEDGE object.

Parameters:

    Edge  : a non-NULL PEDGE object
    
    fFree : this free the object if TRUE

--*/
{    


    //
    // Mark the object to prevent accidental reuse
    //
    pEdge->ObjectType = eInvalidObject;

    if (fFree) {
        ToplFree(pEdge);
    }

    return;
}

VOID
ToplpEdgeSetToVertex(
    PEDGE   pEdge,
    PVERTEX ToVertex
    )

/*++                                                                           

Routine Description:

    This routine sets the ToVertex field of the edge.

Parameters:
    
    pEdge     : a non-NULL PEDGE object
    ToVertex : if non-NULL points to a PVERTEX object
    
--*/
{    

    pEdge->EdgeData.To = ToVertex;

    return;
}

PVERTEX
ToplpEdgeGetToVertex(
    PEDGE   pEdge
    )
/*++                                                                           

Routine Description:

    This routine returns the ToVertex field

Parameters:
                                      
    pEdge     : a non-NULL PEDGE object

--*/
{    
    return pEdge->EdgeData.To;
}

VOID
ToplpEdgeSetFromVertex(
    PEDGE   pEdge,
    PVERTEX FromVertex
    )
/*++                                                                           

Routine Description:

    This routine sets the FromVertex of the Edge. 

Parameters:

    pEdge       : a non-NULL PEDGE object
    FromVertex : if non-NULL should refer to a PVERTEX object
    

--*/
{    
    pEdge->EdgeData.From = FromVertex;

    return;
}


PVERTEX
ToplpEdgeGetFromVertex(
    PEDGE pEdge
    )
/*++                                                                           

Routine Description:

    This routine returns the from vertex associated with Edge.

Parameters:

    pEdge should refer to a PEDGE object
    
Return Values:

    A PVERTEX object or NULL

--*/
{    
    return pEdge->EdgeData.From;
}

DWORD
ToplpEdgeGetWeight(
    PEDGE pEdge
    )
/*++                                                                           

Routine Description:

    This routine returns the weight associated with Edge.

Parameters:

    pEdge should refer to a PEDGE object
    
Return Values:
    
    DWORD

--*/
{    
    return pEdge->EdgeData.Weight;
}

VOID
ToplpEdgeSetWeight(
    PEDGE pEdge,
    DWORD Weight
    )
/*++                                                                           

Routine Description:

    This routine sets the weight associated with Edge.

Parameters:

    pEdge should refer to a PEDGE object
    
Return Values:
    
    None

--*/
{    
    pEdge->EdgeData.Weight = Weight;
}


VOID
ToplpEdgeAssociate(
    PEDGE pEdge
    )
/*++                                                                           

Routine Description:

    This routines adds the edges in question to edge lists of the 
    To and From vertices.

Parameters:

    Edge should refer to a PEDGE object

Return Values:

    None.
    
Throws:

    TOPL_EX_INVALID_VERTEX if either of the vertices don't point to valid
    vertices


--*/
{    
    if (!ToplpIsVertex(pEdge->EdgeData.To)) {
        ToplRaiseException(TOPL_EX_INVALID_VERTEX);
    }

    if (!ToplpIsVertex(pEdge->EdgeData.From)) {
        ToplRaiseException(TOPL_EX_INVALID_VERTEX);
    }

    ToplpVertexAddEdge(pEdge->EdgeData.To, pEdge);
    ToplpVertexAddEdge(pEdge->EdgeData.From, pEdge);

    return;
}

VOID
ToplpEdgeDisassociate(
    PEDGE pEdge
    )
/*++                                                                           

Routine Description:

    This routine sets the FromVertex of the Edge. 

Parameters:

    pEdge       : a non-NULL PEDGE object

--*/
{    

    if (!ToplpIsVertex(pEdge->EdgeData.To)) {
        ToplRaiseException(TOPL_EX_INVALID_VERTEX);
    }

    if (!ToplpIsVertex(pEdge->EdgeData.From)) {
        ToplRaiseException(TOPL_EX_INVALID_VERTEX);
    }

    ToplpVertexRemoveEdge(pEdge->EdgeData.To, pEdge);
    ToplpVertexRemoveEdge(pEdge->EdgeData.From, pEdge);

    return;
}

//
// Vertex object routines
//

PVERTEX
ToplpVertexCreate(
    PVERTEX Vertex OPTIONAL
    )
/*++                                                                           

Routine Description:

    This routine creates a vertex object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{    
    PVERTEX pVertex = Vertex;

    if (!pVertex) {
        pVertex = ToplAlloc(sizeof(VERTEX));
    }

    memset(pVertex, 0, sizeof(VERTEX));

    pVertex->ObjectType = eVertex;

    DynamicArrayInit(&pVertex->VertexData.InEdges);
    DynamicArrayInit(&pVertex->VertexData.OutEdges);

    return pVertex;

}

VOID
ToplpVertexDestroy(
    PVERTEX pVertex,
    BOOLEAN fFree
    )

/*++                                                                           

Routine Description:

    This routine releases the resources of a vertex object.

Parameters:

    pVertex    : a non-NULL PVERTEX object
    fFree      : this free the object if TRUE

--*/
{    

    //
    // Mark the object to prevent accidental reuse
    //
    DynamicArrayDestroy(&pVertex->VertexData.InEdges);
    DynamicArrayDestroy(&pVertex->VertexData.OutEdges);

    pVertex->ObjectType = eInvalidObject;

    if (fFree) {
        ToplFree(pVertex);
    }

    return;
}

//
// Property manipulation routines
//
VOID
ToplpVertexSetId(
    PVERTEX   pVertex,
    DWORD     Id
    )
/*++                                                                           

Routine Description:

    This routine sets the Id of Vertex

Parameters:

    pVertex : a non-NULL PVERTEX object

--*/
{   
    pVertex->VertexData.Id = Id;

    return;
}

DWORD
ToplpVertexGetId(
    PVERTEX pVertex
    )

/*++                                                                           

Routine Description:

    This routine returns the Id associated with this vertex.

Parameters:

    pVertex : a non-NULL PVERTEX object
    
    
Returns:

    The id of the vertex
    
--*/
{  
    return pVertex->VertexData.Id;
}

VOID
ToplpVertexSetParent(
    PVERTEX   pVertex,
    PVERTEX   pParent
    )
/*++                                                                           

Routine Description:

    This routine sets the parent of Vertex

Parameters:

    pVertex : a non-NULL PVERTEX object
    
    pParent : a PVERTEX object

--*/
{   
    pVertex->VertexData.Parent = pParent;

    return;
}

PVERTEX
ToplpVertexGetParent(
    PVERTEX pVertex
    )

/*++                                                                           

Routine Description:

    This routine returns the parent associated with this vertex.

Parameters:

    pVertex : a non-NULL PVERTEX object
    
    
Returns:

    The parent of the vertex
    
--*/
{  
    return pVertex->VertexData.Parent;
}
//
// Edge manipulation routines
//


DWORD
ToplpVertexNumberOfInEdges(
    PVERTEX   pVertex
    )
/*++                                                                           

Routine Description:


Parameters:

    pVertex : a non-NULL PVERTEX object

Raises:

    TOPL_EX_INVALID_EDGE
    
--*/
{
    return DynamicArrayGetCount(&pVertex->VertexData.InEdges);
}

PEDGE
ToplpVertexGetInEdge(
    PVERTEX   pVertex,
    DWORD     Index
    )
/*++                                                                           

Routine Description:


Parameters:

    pVertex : a non-NULL PVERTEX object

Raises:

    TOPL_EX_INVALID_EDGE
    
--*/
{
    if (((signed)Index < 0) || Index >= DynamicArrayGetCount(&pVertex->VertexData.InEdges)) {
        ToplRaiseException(TOPL_EX_INVALID_INDEX);
    }

    return DynamicArrayRetrieve(&pVertex->VertexData.InEdges, Index);
}

DWORD
ToplpVertexNumberOfOutEdges(
    PVERTEX   pVertex
    )

/*++                                                                           

Routine Description:


Parameters:

    pVertex : a non-NULL PVERTEX object

Raises:

--*/
{
    return DynamicArrayGetCount(&pVertex->VertexData.OutEdges);
}

PEDGE
ToplpVertexGetOutEdge(
    PVERTEX   pVertex,
    DWORD     Index
    )

/*++                                                                           

Routine Description:


Parameters:

    pVertex : a non-NULL PVERTEX object

Raises:

    TOPL_EX_INVALID_EDGE
    
--*/
{

    if (((signed)Index < 0) || Index >= DynamicArrayGetCount(&pVertex->VertexData.OutEdges)) {
        ToplRaiseException(TOPL_EX_INVALID_INDEX);
    }

    return DynamicArrayRetrieve(&pVertex->VertexData.OutEdges, Index);

}

VOID
ToplpVertexAddEdge(
    PVERTEX pVertex,
    PEDGE   pEdge
    )

/*++                                                                           

Routine Description:

    This routine adds Edge to the edge list associated with Vertex.  EdgeToAdd
    must have its FromVertex or ToVertex set to Vertex.

Parameters:

    pVertex : a non-NULL PVERTEX object
    pEdge   : a non-NULL PEDGE object

Raises:

    TOPL_EX_INVALID_EDGE
    
--*/
{   


    if (ToplpEdgeGetFromVertex(pEdge) == pVertex) {

        DynamicArrayAdd(&pVertex->VertexData.OutEdges, pEdge);
         
    } else if (ToplpEdgeGetToVertex(pEdge)  == pVertex) {

        DynamicArrayAdd(&pVertex->VertexData.InEdges, pEdge);

    } else {

        //
        // Adding an edge whose from vertex is not the vertex
        // that is passed in
        //
        ToplRaiseException(TOPL_EX_INVALID_EDGE);

    }

    return;
}

VOID
ToplpVertexRemoveEdge(
    PVERTEX pVertex,
    PEDGE   pEdge
    )
/*++                                                                           

Routine Description:

    This routine removes EdgeToRemove from Vertex's edge list.
Parameters:

    pVertex : a non-NULL PVERTEX object
    pEdge   : if non-NULL, a PEDGE object

Returns:

    PEDGE object if found
    
Raises:

    TOPL_EX_INVALID_EDGE if the edge to be deleted does not have a from vertex
    of the vertex begin acted on.    

--*/
{   

    ASSERT(pVertex);
    ASSERT(pEdge);

    if (ToplpEdgeGetFromVertex(pEdge) == pVertex) {

        DynamicArrayRemove(&pVertex->VertexData.OutEdges, pEdge, 0);
         
    } else if (ToplpEdgeGetToVertex(pEdge)  == pVertex) {

        DynamicArrayRemove(&pVertex->VertexData.InEdges, pEdge, 0);

    } else {

        //
        // Adding an edge whose from vertex is not the vertex
        // that is passed in
        //
        ToplRaiseException(TOPL_EX_INVALID_EDGE);

    }
}

//
// Graph object routines
//

PGRAPH
ToplpGraphCreate(
    PGRAPH Graph OPTIONAL
    )
/*++                                                                           

Routine Description:

    This routine creates a graph object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.

--*/
{    

    PGRAPH pGraph = Graph;

    if (!pGraph) {
        pGraph = ToplAlloc(sizeof(GRAPH));
    }

    memset(pGraph, 0, sizeof(GRAPH));

    pGraph->ObjectType = eGraph;
    pGraph->VertexList.ObjectType = eList;
    return pGraph;

}

VOID
ToplpGraphDestroy(
    PGRAPH   pGraph,
    BOOLEAN  fFree,
    BOOLEAN  fRecursive
    )
/*++                                                                           

Routine Description:

    This routine frees a graph object.

Parameters:

    pGraph  : a non-NULL PGRAPH object
    fFree   : this frees the objects if TRUE
    fRecursive : TRUE implies to free all edges and vertices associated with
                 the graph

--*/
{   

    if (fRecursive) {
    
        PVERTEX pVertex;
    
        while (pVertex = ToplpListRemoveElem(&(pGraph->VertexList), NULL)) {
            //
            // Recursive delete the vertices, too
            // 
            ToplpVertexDestroy(pVertex, fFree);
        }

    }

    //
    // Mark the object to prevent accidental reuse
    //
    pGraph->ObjectType = eInvalidObject;

    if (fFree) {
        ToplFree(pGraph);
    }

    return;
}

VOID
ToplpGraphAddVertex(
    PGRAPH  pGraph,
    PVERTEX pVertex
    )
/*++                                                                           

Routine Description:

    This routine adds VertexToAdd to Graph.

Parameters:

    pGraph  : a non-NULL PGRAPH object
    pVertex : a non-NULL PVERTEX object

Return Values:

--*/
{    
    ToplpListAddElem(&(pGraph->VertexList), pVertex);
    
    return;
}

PVERTEX
ToplpGraphRemoveVertex(
    PGRAPH  pGraph,
    PVERTEX pVertex
    )
/*++                                                                           

Routine Description:

    This routine removes and returns VertexToRemove from Graph if VertexToRemove
    is in Graph; returns NULL otherwise.
    If VertexToRemove is NULL, the first vertex in Graph's vertex list is
    removed.

Parameters:
    
    pGraph  : a non-NULL PGRAPH object
    pVertex : should be NULL or refer to a PVERTEX object

--*/
{   
    return ToplpListRemoveElem(&(pGraph->VertexList), pVertex);
}
      
VOID
ToplpGraphSetVertexIter(
    PGRAPH    pGraph,
    PITERATOR pIter
    )
/*++                                                                           

Routine Description:

    This routine sets Iter to point to the beginning of Graph's vertex list.

Parameters:

    pGraph  : a non-NULL PGRAPH object
    pIter   : a non-NULL PTIERATOR object

--*/
{   
    ToplpListSetIter(&(pGraph->VertexList), pIter);

    return;
}


DWORD
ToplpGraphNumberOfVertices(
    PGRAPH    pGraph
)
/*++                                                                           

Routine Description:

    This routine returns the number of vertices in Graph's vertex list.

Parameters:

    pGraph  : a non-NULL PGRAPH object

--*/
{   
    return  ToplpListNumberOfElements(&pGraph->VertexList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\stheap.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stheap.h

Abstract:

    This file provides an interface to a binary heap. This heap supports the
    'cost reduced' operation, as required by Dijkstra's algorithm. Elements
    which can be inserted must support three operations:
        - Comparing two elements
        - Getting an integer value called 'location'
        - Setting the value of 'location'
    The location value is used to find elements in the heap. This value must
    be initialized to STHEAP_NOT_IN_HEAP.
    The 'extra' parameter is not used by the heap code -- it is just
    passed back to the comparison/location functions.
    For 'deterministic' behavior, no elements should have equal keys.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    20-6-2000   NickHar   Created
    
--*/

#ifndef STHEAP_H
#define STHEAP_H

/***** Constants *****/
#define STHEAP_NOT_IN_HEAP  -1


/***** Function Type Definitions *****/
typedef int (*STHEAP_COMPARE_FUNC)( PVOID el1, PVOID el2, PVOID extra );
typedef int (*STHEAP_GET_LOCN_FUNC)( PVOID el1, PVOID extra );
typedef VOID (*STHEAP_SET_LOCN_FUNC)( PVOID el1, int l, PVOID extra ); 


/***** Heap *****/
typedef struct {
    DWORD                   nextFreeSpot, maxSize;
    PVOID                   *data;
    STHEAP_COMPARE_FUNC     Comp;
    STHEAP_GET_LOCN_FUNC    GetLocn;
    STHEAP_SET_LOCN_FUNC    SetLocn;
    PVOID                   extra;
} STHEAP;
typedef STHEAP *PSTHEAP;


/***** ToplSTHeapInit *****/
/* Allocate and initialize a heap object. This object should be destroyed
 * using the STHeapDestroy() function after it is no longer needed.
 * Throws an exception if any error occurs.
 * Parameters:
 *   maxSize        Maximum number of elements that will be stored in heap
 *   Comp           Pointer to a comparison function to compare heap elements
 *   GetLocn        Pointer to a function to get the 'location' field, as
 *                  described above
 *   SetLocn        Pointer to a function which sets the field 'location', as
 *                  described above
 *   extra          An extra parameter which is passed to the comparison
 *                  function, for the sake of convenience. Use is optional.
 */
PSTHEAP
ToplSTHeapInit(
    DWORD                   maxSize,
    STHEAP_COMPARE_FUNC     Comp,
    STHEAP_GET_LOCN_FUNC    GetLocn,
    STHEAP_SET_LOCN_FUNC    SetLocn,
    PVOID                   extra
    );

/***** ToplSTHeapDestroy *****/
/* Destroy a heap after it is no longer needed */
VOID
ToplSTHeapDestroy(
    PSTHEAP heap
    );

/***** ToplSTHeapAdd *****/
/* Add an element to the heap. The element must not be null, and
 * must be able to support the functions GetCost, etc. You must not
 * insert more elements than the maximum size.
 * The element must not already be in the heap, and it must have its
 * heap location set to STHEAP_NOT_IN_HEAP. */
VOID
ToplSTHeapAdd(
    PSTHEAP heap,
    PVOID element
    );

/***** ToplSTHeapExtractMin *****/
/* Extract the object with minimum cost from the heap. When the heap
 * is empty, returns NULL. */
PVOID
ToplSTHeapExtractMin(
    PSTHEAP heap
    );

/***** ToplSTHeapCostReduced *****/
/* Notify the heap that an element's cost has just been reduced.
 * The heap will be (efficiently) shuffled so that the heap property
 * is maintained */
VOID
ToplSTHeapCostReduced(
    PSTHEAP heap,
    PVOID element
    );


#endif /* STHEAP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\toplheap.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplheap.h

Abstract:

    This files exports the simple ADT of a heap.
               
Author:

    Colin Brace  (ColinBr)
    
Revision History

    12-5-97   ColinBr    Created
    
--*/

#ifndef __TOPLHEAP_H
#define __TOPLHEAP_H

typedef struct _TOPL_HEAP_INFO
{       
    PVOID* Array;
    ULONG cArray;
    DWORD (*pfnKey)( VOID *p ); 
    ULONG MaxElements;

} TOPL_HEAP_INFO, *PTOPL_HEAP_INFO;


BOOLEAN
ToplHeapCreate(
    OUT PTOPL_HEAP_INFO Heap,
    IN  ULONG           cArray,
    IN  DWORD          (*pfnKey)( VOID *p )
    );

VOID
ToplHeapDestroy(
    IN OUT PTOPL_HEAP_INFO Heap
    );

PVOID
ToplHeapExtractMin(
    IN PTOPL_HEAP_INFO Heap
    );

VOID
ToplHeapInsert(
    IN PTOPL_HEAP_INFO Heap,
    IN PVOID           Element
    );

BOOLEAN
ToplHeapIsEmpty(
    IN PTOPL_HEAP_INFO Heap
    );

BOOLEAN
ToplHeapIsElementOf(
    IN PTOPL_HEAP_INFO Heap,
    IN PVOID           Element
    );

#endif // __TOPLHEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\topllist.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    topllist.c

Abstract:
    
    This files contains the routines to manipulate the list and iterator
    object.

Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>
#include <stddef.h>

typedef unsigned long DWORD;

#include <w32topl.h>
#include <w32toplp.h>
#include <topllist.h>
#include <toplgrph.h>

PLIST
ToplpListCreate(
    VOID
    )
/*++                                                                           

Routine Description:

    This routine creates a List object and returns a pointer to it.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{   

    PLIST pList;

    pList = ToplAlloc(sizeof(LIST));
    memset(pList, 0, sizeof(LIST));

    pList->ObjectType = eList;

    return pList;

}

VOID 
ToplpListFree(
    PLIST     pList,
    BOOLEAN   fRecursive
    )
/*++                                                                           

Routine Description:

    This routine frees a list object

Parameters:

    pList      - non-NULL PLIST object
    fRecursive - TRUE implies that elements in the list will be freed, too
    
Throws:

    TOPL_EX_WRONG_OBJECT    

--*/
{   
    if (fRecursive) {

        PLIST_ELEMENT pElement;
    
        while (pElement = ToplpListRemoveElem(pList, NULL)) {
            ToplpListFreeElem(pElement);
        }
    }

    //
    // Mark the object to prevent accidental reuse
    //
    pList->ObjectType = eInvalidObject;
    ToplFree(pList);

    return;
}

VOID
ToplpListFreeElem(
    PLIST_ELEMENT pElem
    )
/*++                                                                           

Routine Description:

    This routine frees an element that was containing in a list. 

Parameters:

    pElem  - non-NULL pointer to either a VERTEX or PEDGE object

Return Values:

--*/
{
    switch (pElem->ObjectType) {
        
        case eVertex:
            ToplpVertexDestroy((PVERTEX)pElem, TRUE);
            break;

        case eEdge:
            ToplpEdgeDestroy((PEDGE)pElem, TRUE);
            break;

        default:
            ASSERT(FALSE);
    }

}

VOID
ToplpListSetIter(
    PLIST     pList,
    PITERATOR pIter
    )
/*++                                                                           

Routine Description:

    This routine sets Iterator to point to the head of List.

Parameters:

    pList      - non-NULL PLIST object
    pIter      - non-NULL PITERATOR object
    
--*/
{   
    pIter->pLink = pList->Head.Next;

    return;
}


PLIST_ELEMENT
ToplpListRemoveElem(
    PLIST         pList,
    PLIST_ELEMENT pElem
    )
/*++                                                                           

Routine Description:

    This routine removes Elem from List if it exists in the list; NULL otherwise.
    If Elem is NULL then the first element in the list, if any, is returned.

Parameters:

    pList      - non-NULL PLIST object
    pElem      - if non-NULL, a PLIST_ELEMENT object

Returns:

    PLIST_ELEMENT if found; NULL otherwise
    
--*/
{

    PLIST_ELEMENT       ReturnedObject = NULL;
    PSINGLE_LIST_ENTRY  Curr, Prev;
 
    if (pElem) {
        //
        // Search linked list for object
        // 
        Prev = &(pList->Head);
        Curr = pList->Head.Next;
        while (Curr 
            && Curr != &(pElem->Link) ) {
            Prev = Curr;
            Curr = Curr->Next;
        }
        if (Curr) {
            //
            // Found it !
            //
            Prev->Next = Curr->Next;
            Curr->Next = NULL;
        }

        ReturnedObject = CAST_TO_LIST_ELEMENT(Curr);

    } else {
        //
        // Take the first element off
        //
        Curr = PopEntryList(&(pList->Head));
        if (Curr) {
            Curr->Next = NULL;
        }
        
        ReturnedObject = CAST_TO_LIST_ELEMENT(Curr);
        
    }

    if (ReturnedObject) {
        pList->NumberOfElements--;
    }
    ASSERT((signed)(pList->NumberOfElements) >= 0);
    
    return ReturnedObject;

}


VOID
ToplpListAddElem(
    PLIST         pList,
    PLIST_ELEMENT pElem
    )
/*++                                                                           

Routine Description:

    This routine adds Elem to List.  Elem should not be part of another list -
    currently there is no checking for this.

Parameters:

    pList is a PLIST object
    pElem is a PLIST_ELEMENT


--*/
{

    PushEntryList(&(pList->Head), &(pElem->Link));
    pList->NumberOfElements++;

    return;
}

DWORD
ToplpListNumberOfElements(
    PLIST        pList
    )
/*++                                                                           

Routine Description:

    This routine returns the number of elements in List

Parameters:

    List : a non-NULL PLIST object

--*/
{
    return pList->NumberOfElements;
}

//
// Iterator object routines
//
PITERATOR
ToplpIterCreate(
    VOID
    )
/*++                                                                           

Routine Description:

    This creates an iterator object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.

--*/
{    

    PITERATOR pIter;

    pIter = ToplAlloc(sizeof(ITERATOR));
    memset(pIter, 0, sizeof(ITERATOR));

    pIter->ObjectType = eIterator;

    return pIter;
    
}

VOID 
ToplpIterFree(
    PITERATOR pIter
    )

/*++                                                                           

Routine Description:

    This routine free an iterator object.

Parameters:

    pIter : a non-NULL PITERATOR object

--*/
{   

    //
    // Mark the object to prevent accidental reuse
    //
    pIter->ObjectType = eInvalidObject;
    ToplFree(pIter);

    return;
}

PLIST_ELEMENT
ToplpIterGetObject(
    PITERATOR pIter
    )

/*++                                                                           

Routine Description:

    This routine returns the current object pointer to by the iterator.

Parameters:

    pIter : a non-NULL PITERATOR object
    
Return Values:

    A pointer to the current object - NULL if there are no more objects

--*/
{    
    return CAST_TO_LIST_ELEMENT(pIter->pLink);
}

VOID
ToplpIterAdvance(
    PITERATOR pIter
    )
/*++                                                                           

Routine Description:

    This routine advances the iterator by one object if it is not at the
    end.

Parameters:

    pIter : a non-NULL PITERATOR object

--*/
{   

    if (pIter->pLink) {
        pIter->pLink = pIter->pLink->Next;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\toplmst.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplmst.c

Abstract:

    This file contains the definition for ToplGraphFindMST

    This implementation is based on Prim's algorithm presented in
    
    _Introduction To Algorithms_ by Cormen, Leiserson, Rivest 1993.
    
    Chapter 24.
    
    
Author:

    Colin Brace    (ColinBr)
    
Revision History

    12-5-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <search.h>
#include <stdio.h>

typedef unsigned long DWORD;


#include <w32topl.h>
#include <w32toplp.h>
#include <topllist.h>
#include <toplgrph.h>

#include <toplheap.h>


//
// These two functions help build a dynamically growing list
// of PEDGE's and are defined in toplring.c
//
extern void EdgeArrayInit(
    PEDGE **array,
    ULONG *count
    );

extern void EdgeArrayAdd(
    PEDGE **array,
    ULONG *count,
    PEDGE edge
    );

TOPL_COMPONENTS* 
ToplMST_Prim(
    PGRAPH  Graph,
    PVERTEX RootVertex
    );


TOPL_COMPONENTS*
InitComponents(VOID)
//
// Initialize a set of components. This set initially contains no components.
//
{
    TOPL_COMPONENTS *pComponents;
    pComponents = (TOPL_COMPONENTS*) ToplAlloc( sizeof(TOPL_COMPONENTS) );
    pComponents->numComponents = 0;
    pComponents->pComponent = NULL;
    return pComponents;
}

TOPL_COMPONENT*
AddNewComponent(
    TOPL_COMPONENTS *pComponents
    )
//
// Add a new component to the set of components and return a pointer to it.
//
{
    TOPL_COMPONENT *pComponent;
    DWORD newComponentID;

    ASSERT( pComponents );
    newComponentID = pComponents->numComponents;
    
    // Increase the size of the component array
    pComponents->numComponents++;
    if( pComponents->pComponent ) {
        pComponents->pComponent = (TOPL_COMPONENT*) ToplReAlloc(
            pComponents->pComponent,
            pComponents->numComponents * sizeof(TOPL_COMPONENT) );
    } else {
        pComponents->pComponent = (TOPL_COMPONENT*) ToplAlloc(
            pComponents->numComponents * sizeof(TOPL_COMPONENT) );
    }

    // Add a new empty component to the array
    pComponent = &(pComponents->pComponent[newComponentID]);
    pComponent->numVertices = 0;
    pComponent->vertexNames = NULL;

    return pComponent;
}

VOID
AddVertexToComponent(
    TOPL_COMPONENT* pComponent,
    PVERTEX u
    )
//
// Add vertex u to pComponent. It is not the PVERTEX pointer itself but
// rather u's "vertex name" that is stored in the component.
//
{
    DWORD newVtxID;

    ASSERT( pComponent );
    newVtxID = pComponent->numVertices;

    // Increase the size of the vertex array
    pComponent->numVertices++;
    if( pComponent->vertexNames ) {
        pComponent->vertexNames = (PVOID*) ToplReAlloc(
            pComponent->vertexNames,
            pComponent->numVertices * sizeof(PVOID) );
    } else {
        pComponent->vertexNames = (PVOID*) ToplAlloc(
            pComponent->numVertices * sizeof(PVOID) );
    }

    // Add the vertex name to the array
    pComponent->vertexNames[newVtxID] = u->VertexData.VertexName;
}

VOID
MoveInterestingComponentToFront(
    TOPL_COMPONENTS *pComponents,
    PVERTEX VertexOfInterest
    )
//
// Swaps the components in pComponents such that the component
// containing VertexOfInterest is the first component.
//
// Precondition:
// pComponents must be non-NULL and must contain at least one component.
// VertexOfInterest must also be non-NULL.
//
{
    TOPL_COMPONENT *pComponent, temp;
    DWORD i,j,ComponentOfInterest=0;
    PVOID VtxNameOfInterest;
    BOOLEAN foundIt=FALSE;

    ASSERT(VertexOfInterest);
    VtxNameOfInterest = VertexOfInterest->VertexData.VertexName;

    // Search for the component which contains 'VertexOfInterest'
    ASSERT(NULL!=pComponents && pComponents->numComponents>0);
    for( i=0; i<pComponents->numComponents; i++ ) {
        pComponent = &(pComponents->pComponent[i]);
        ASSERT( pComponent->numVertices>0 );
        ASSERT( NULL!=pComponent->vertexNames );
        for( j=0; j<pComponent->numVertices; j++ ) {
            if( pComponent->vertexNames[j]==VtxNameOfInterest ) {
                ComponentOfInterest = i;
                foundIt=TRUE;
                break;
            }
        }
        if(foundIt) break;
    }
    ASSERT(foundIt);

    // Swap component 0 and component ComponentOfInterest if necessary
    if(ComponentOfInterest>0) {
        temp = pComponents->pComponent[0];
        pComponents->pComponent[0] = pComponents->pComponent[ComponentOfInterest];
        pComponents->pComponent[ComponentOfInterest] = temp;
    }
}

TOPL_COMPONENTS*
ToplpGraphFindEdgesForMST(
    IN  PGRAPH  Graph,
    IN  PVERTEX RootVertex,
    IN  PVERTEX VertexOfInterest,
    OUT PEDGE**  pEdges,
    OUT ULONG*  cEdges
    )
/*++

Routine Description:

    This function finds the least cost tree of connecting
    the nodes in Graph.  It is assumed that graph contains some vertices
    and some edges already.
    
    In addition, this function will then return the edges that
    contain VertexOfInterest.
        

Parameters:

    Graph: a valid graph object
    
    RootVertex: an arbitrary vertex at which to start the tree
    
    VertexOfInterest: the vertex that returned edges should contain
    
    pEdges: an array of edges that contain VertexOfInterest in the determined 
            tree
            
    cEdge: the number of elements in pEdges            
                                                                                    
Returns:

    TRUE if all the nodes in Graph could be connected in a tree; FALSE otherwise

--*/
{
    TOPL_COMPONENTS *pComponents;
    BOOLEAN   fStatus;
    PITERATOR VertexIterator;
    PVERTEX   Vertex, Parent;
    ULONG     iEdge, cEdge;
    PEDGE     e;


    ASSERT( Graph );
    ASSERT( RootVertex );
    ASSERT( VertexOfInterest );
    ASSERT( pEdges );
    ASSERT( cEdges );

    EdgeArrayInit(pEdges, cEdges);


    //
    // Make the best effort at find a spanning tree
    //
    pComponents = ToplMST_Prim( Graph, RootVertex );
    ASSERT( NULL!=pComponents && pComponents->numComponents>0 );
    MoveInterestingComponentToFront( pComponents, VertexOfInterest );

    //
    // Now determine if a spanning tree was really possible
    // and find which edges we need for VertexOfOfInterest
    //
    VertexIterator = ToplpIterCreate();
    for ( ToplpGraphSetVertexIter(Graph, VertexIterator);
            Vertex = (PVERTEX) ToplpIterGetObject(VertexIterator);
                ToplpIterAdvance(VertexIterator) ) {

        //
        //
        // Since we only want the edges that contain VertexOfInterest
        // we are only interested in vertices whose parent is VertexOfInterest
        // and VertexOfInterest itself.  
        //

        ASSERT( ToplpIsVertex( Vertex ) );

        Parent = ToplpVertexGetParent( Vertex );

        if ( Vertex == VertexOfInterest )
        {
            //
            // Get the edge from this vertex up to its parent
            //
            for ( iEdge = 0, cEdge = ToplpVertexNumberOfInEdges( Vertex ); 
                    iEdge < cEdge; 
                        iEdge++) {
    
                e = ToplpVertexGetInEdge( Vertex, iEdge );
    
                ASSERT( ToplpIsEdge( e ) );
                ASSERT( ToplpEdgeGetToVertex( e ) == Vertex );

                if ( ToplpEdgeGetFromVertex( e ) == Parent )
                {
                    EdgeArrayAdd(pEdges, cEdges, e);
                }

            }
        }

        if ( Parent == VertexOfInterest )
        {
            //
            // Get the edge's to sites that are children
            //
            for ( iEdge = 0, cEdge = ToplpVertexNumberOfInEdges( VertexOfInterest ); 
                    iEdge < cEdge; 
                        iEdge++) {
    
                e = ToplpVertexGetInEdge( VertexOfInterest, iEdge );
    
                ASSERT( ToplpIsEdge( e ) );
                ASSERT( ToplpEdgeGetToVertex( e ) == VertexOfInterest );

                if ( ToplpEdgeGetFromVertex( e ) == Vertex )
                {
                    EdgeArrayAdd( pEdges, cEdges, e );
                }
            }
        }
    }
    ToplpIterFree( VertexIterator );

    return pComponents;
}

DWORD
GetVertexKey(
    VOID *p
    )
{
    PVERTEX pv = (PVERTEX)p;

    ASSERT( pv );

    return ToplpVertexGetId( pv );
}

TOPL_COMPONENTS*
ToplMST_Prim( 
    IN PGRAPH  Graph,
    IN PVERTEX RootVertex
    )
{

    TOPL_HEAP_INFO Q;
    PITERATOR      VertexIterator;
    ULONG          cVertices;
    PVERTEX        Vertex;
    TOPL_COMPONENTS *pComponents;
    TOPL_COMPONENT *curComponent;

    ASSERT( Graph );
    ASSERT( RootVertex );

    //
    // Set up the priority queue
    //
    cVertices = ToplpGraphNumberOfVertices( Graph );

    ToplHeapCreate( &Q,
                    cVertices,
                    GetVertexKey );


    VertexIterator = ToplIterCreate();
    for ( ToplpGraphSetVertexIter(Graph, VertexIterator);
            Vertex = (PVERTEX) ToplpIterGetObject(VertexIterator);
                ToplpIterAdvance(VertexIterator) ) {

        ASSERT( ToplpIsVertex( Vertex ) );

        if ( Vertex == RootVertex )
        {
            ToplpVertexSetId( RootVertex, 0 );
        }
        else
        {
            ToplpVertexSetId( Vertex, DWORD_INFINITY );
        }

        ToplpVertexSetParent( Vertex, NULL );

        ToplHeapInsert( &Q, Vertex );

    }
    ToplpIterFree( VertexIterator );

    //
    // Set up the components structure
    //
    pComponents = InitComponents();
    curComponent = AddNewComponent( pComponents );

    //
    // Find the minimum spanning tree
    //
    while ( !ToplHeapIsEmpty( &Q ) )
    {
        PVERTEX     u, v;
        PEDGE       e;
        DWORD       w;
        ULONG       iEdge, cEdge;
        
        u = ToplHeapExtractMin( &Q );
        ASSERT( u );

        if( ToplpVertexGetId(u)==DWORD_INFINITY ) {
            // u has infinite cost, indicating that it could not be connected to
            // any existing components. Start a new component
            curComponent = AddNewComponent( pComponents );
        }
        AddVertexToComponent( curComponent, u );

        for ( iEdge = 0, cEdge = ToplpVertexNumberOfOutEdges( u ); 
                iEdge < cEdge; 
                    iEdge++) {

            e = ToplpVertexGetOutEdge( u, iEdge );

            ASSERT( ToplpIsEdge( e ) );
            ASSERT( ToplpEdgeGetFromVertex( e ) == u );
    
            v = ToplpEdgeGetToVertex( e );
            w = ToplpEdgeGetWeight( e );

            if ( ToplHeapIsElementOf( &Q, v )
              && w < ToplpVertexGetId( v )  )
            {
                ToplpVertexSetParent( v, u );

                ToplpVertexSetId( v, w );
            }
        }
    }

    ToplHeapDestroy( &Q );

    return pComponents;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\topllist.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    topllist.h

Abstract:

    This file contains the routines for the list and iterator.

Author:

    Colin Brace  (ColinBr)
    
Revision History

    3-12-97   ColinBr    Created
    
--*/

#ifndef __TOPLLIST_H
#define __TOPLLIST_H

//
// List routines
//

PLIST
ToplpListCreate(
    VOID
    );

VOID 
ToplpListFree(
    PLIST pList,
    BOOLEAN   fRecursive   // TRUE implies free the elements contained 
                           // in the list
    );

VOID
ToplpListFreeElem(
    PLIST_ELEMENT pElem
    );

VOID
ToplpListSetIter(
    PLIST     pList,
    PITERATOR pIterator
    );

PLIST_ELEMENT
ToplpListRemoveElem(
    PLIST         pList,
    PLIST_ELEMENT Elem
    );

VOID
ToplpListAddElem(
    PLIST         pList,
    PLIST_ELEMENT Elem
    );

DWORD
ToplpListNumberOfElements(
    PLIST         pList
    );

//
// Iterator object routines
//
PITERATOR
ToplpIterCreate(
    VOID
    );

VOID 
ToplpIterFree(
    PITERATOR pIterator
    );

PLIST_ELEMENT
ToplpIterGetObject(
    PITERATOR pIterator
    );

VOID
ToplpIterAdvance(
    PITERATOR pIterator
    );

#endif // __TOPLLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\toplheap.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplheap.c

Abstract:

    This files exports the simple ADT of a heap.
    
    This implementation is based on the heap definition in 
    
    _Introduction To Algorithms_ by Cormen, Leiserson, Rivest 1993.
    
    Chapter 7.
    
    The implmentation in the book is a heap for extracting maximum values; 
    the implementation in this module is for extracting minimum values.

Author:

    Colin Brace    (ColinBr)
    
Revision History

    12-5-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>

typedef unsigned long DWORD;

#include <w32topl.h>
#include <w32toplp.h>

#include <toplheap.h>


#define PARENT(i)  ((i) >> 1)           // floor (i/2)
#define LEFT(i)    ((i) << 1)           // i * 2
#define RIGHT(i)   (((i) << 1) | 0x1)   // (i * 2) + 1


BOOLEAN
ToplHeapIsValid(
    IN PTOPL_HEAP_INFO Heap
    )
//
// This tests the heap property invariant
//
//
// N.B. Only call this routine when the heap has been heapified
//      It is possible to change the "key" values on the nodes
//      with callling heapify, thus breaking the heap invariant.
//      The corollary of this is to heapify before doing any 
//      heap operations.
//
{

#define KEY_VALUE(x)  ( Heap->pfnKey( Heap->Array[(x)] ) )

    ULONG i;

    if ( !Heap )
    {
        return FALSE;
    }

    for ( i = 0; i < Heap->cArray; i++)
    {
        if ( !( KEY_VALUE( PARENT(i) ) <= KEY_VALUE( i ) ) ) 
        {
            return FALSE;
        }
    }

    return TRUE;

}

VOID
Heapify(
    IN PTOPL_HEAP_INFO Heap,
    IN ULONG           Index
    )
//
// Used to create a heap; places Index in the correct place
// in the heap.
//
{

#define KEY_VALUE(x)  ( Heap->pfnKey( Heap->Array[(x)] ) )

    ULONG Left, Right, Smallest;

    ASSERT( Heap );

    Left = LEFT( Index );
    Right = RIGHT( Index );

    if ( Left < Heap->cArray && KEY_VALUE(Left) < KEY_VALUE(Index) ) 
        Smallest = Left;
    else
        Smallest = Index;

    if ( Right < Heap->cArray && KEY_VALUE(Right) < KEY_VALUE(Smallest) ) 
        Smallest = Right;

    if ( Smallest != Index )
    {
        PVOID Temp;

        Temp = Heap->Array[Smallest];
        Heap->Array[Smallest] = Heap->Array[Index];
        Heap->Array[Index] = Temp;

        Heapify( Heap, Smallest );
    }

}

BOOLEAN
ToplHeapCreate(
    OUT PTOPL_HEAP_INFO Heap,
    IN  ULONG           MaxElements,
    IN  DWORD          (*pfnKey)( VOID *p )
    )
/*++                                                                           

Routine Description:

    This routine prepares a heap structure.

Parameters:

    Heap        - pointer to be used in subsequent operations
    
    MaxElements - number of elements in Array
    
    Key         - a function that associates a value with an element from Array

Returns:

    TRUE if function succeeded; FALSE otherwise

--*/
{

    ASSERT( Heap );
    ASSERT( pfnKey );

    if ( MaxElements > 0 )
    {
        //
        // ToplAlloc will throw an exception on failure
        //
        Heap->Array = (PVOID*) ToplAlloc( MaxElements * sizeof(PVOID) );
    }
    else
    {
        Heap->Array = NULL;
    }

    Heap->MaxElements = MaxElements;
    Heap->cArray = 0;
    Heap->pfnKey = pfnKey;


    ASSERT( ToplHeapIsValid( Heap ) );

    return TRUE;
}

VOID
Build_Heap(
    IN PTOPL_HEAP_INFO Heap
    )
//
// Builds a heap
//
{

    int i;

    ASSERT( Heap );

    for ( i = ( (Heap->cArray-1) / 2); i >= 0; i-- )
    {
        Heapify( Heap, i );
    }

    ASSERT( ToplHeapIsValid( Heap ) );

}

PVOID
ToplHeapExtractMin(
    IN PTOPL_HEAP_INFO Heap
    )
//
// Removes the smallest element in the heap
//
{
    PVOID Min;

    ASSERT( Heap );
    ASSERT( Heap->pfnKey );

    if ( Heap->cArray < 1 )
    {
        return NULL;
    }

    //
    // This call to Build_Heap denegrates our performance but is nessecary
    // since clients could have changed the values of the heap keys between
    // heap operations.  This call ensures the heap is valid before removing
    // the minimim value
    //
    // [nickhar] Calling Build_Heap here makes the heap completely useless.
    // With this implementation:
    //  - Inserting the elements takes O(n log n)
    //  - ExtractMin takes O(n)
    // Therefore this heap is worse than an unsorted array. The correct solution
    // is to use a heap which supports the 'decrease key' operation, like the
    // one in 'stheap.c'.
    //
    Build_Heap( Heap );

    ASSERT( ToplHeapIsValid( Heap ) );

    Min = Heap->Array[0];
    Heap->Array[0] = Heap->Array[Heap->cArray - 1];
    Heap->cArray--;

    Heapify( Heap, 0 );

    ASSERT( ToplHeapIsValid( Heap ) );

    return Min;

}


VOID
ToplHeapInsert(
    IN PTOPL_HEAP_INFO Heap,
    IN PVOID           Element
    )
//
// Inserts an element into the heap - space should already be allocated
// for it
//
{

    ULONG i;

    ASSERT( ToplHeapIsValid( Heap ) );

    Heap->cArray++;

    if ( Heap->cArray > Heap->MaxElements )
    {
        ASSERT( !"W32TOPL: Heap Overflow" );
        return;
    }

    i = Heap->cArray - 1;
    while ( i > 0 && Heap->pfnKey(Heap->Array[PARENT(i)]) > Heap->pfnKey( Element ) )
    {
        Heap->Array[i] = Heap->Array[PARENT(i)];
        i = PARENT(i); 
    }

    Heap->Array[i] = Element;


    ASSERT( ToplHeapIsValid( Heap ) );

    return;
}

BOOLEAN
ToplHeapIsEmpty(
    IN PTOPL_HEAP_INFO Heap
    )
{
    return ( Heap->cArray == 0 );
}


BOOLEAN
ToplHeapIsElementOf(
    IN PTOPL_HEAP_INFO Heap,
    IN PVOID           Element
    )
{
    ULONG   i;

    ASSERT( Element );

    for ( i = 0; i < Heap->cArray; i++ )
    {
        if ( Heap->Array[i] == Element )
        {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
ToplHeapDestroy(
    IN OUT PTOPL_HEAP_INFO Heap
    )
{

    if ( Heap )
    {
        if ( Heap->Array )
        {
            RtlZeroMemory( Heap->Array, Heap->MaxElements*sizeof(PVOID) );
            ToplFree( Heap->Array );
        }

        RtlZeroMemory( Heap, sizeof(TOPL_HEAP_INFO) );

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\toplring.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplring.h

Abstract:

    This file contains the function declaration for the ring manipulation
    routines.

Author:

    Colin Brace   (ColinBr)
    
Revision History

    3-12-97   ColinBr    Created
    
--*/

#ifndef __TOPLRING_H
#define __TOPLRING_H

VOID
ToplpGraphMakeRing(
    PGRAPH     pGraph,
    DWORD      Flags,
    PLIST      VerticesToAdd,
    PEDGE      **EdgesToKeep,
    PULONG     cEdgesToKeep
    );


#endif // __TOPLRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\toplring.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplring.c

Abstract:

    This file contains the definition for ToplGraphMakeRing            
    
Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <search.h>
#include <stdio.h>

typedef unsigned long DWORD;


#include <w32topl.h>
#include <w32toplp.h>
#include <topllist.h>
#include <toplgrph.h>

int 
__cdecl compareVertices( const void *arg1, const void *arg2 )
{
    PVERTEX pV1  = *((PVERTEX*)arg1);
    PVERTEX pV2  = *((PVERTEX*)arg2);

    ASSERT(ToplpIsVertex(pV1));
    ASSERT(ToplpIsVertex(pV2));

    if ( ToplpVertexGetId(pV1) < ToplpVertexGetId(pV2) ) {
        return -1;
    } else if ( ToplpVertexGetId(pV1) > ToplpVertexGetId(pV2)) {
        return 1;
    } else {
        return 0;
    }
}

//
// These two functions help build a dynamically growing list
// of PEDGE's
//
static ULONG ElementsAllocated;

void EdgeArrayInit(
    PEDGE **array,
    ULONG *count
    )
/*++                                                                           

Routine Description:

    This routine inits array, count, and ElementsAllocated so 
    they can be used in EdgeArrayAdd.

Parameters:

    array : is a pointer to an array of PEDGES
    count : the number of elements in the array

--*/
{
    *array  = NULL;
    *count  = 0;
    ElementsAllocated = 0;
}

void
EdgeArrayAdd(
    PEDGE **array,
    ULONG *count,
    PEDGE edge
    )
/*++                                                                           

Routine Description:

    This routine adds edge to array and increments count.  If there is not
    enough space in array more space is allocated.  If there is no more
    memory, an exception is raised.

Parameters:

    array : is a pointer to an array of PEDGES
    count : the number of elements in the array
    edge  : the new element to add

--*/
{
    #define CHUNK_SIZE               100  // this is the number of elements

    if (*count >= ElementsAllocated) {
        ElementsAllocated += CHUNK_SIZE;
        if ((*array)) {
            (*array) = (PEDGE*) ToplReAlloc(*array, ElementsAllocated * sizeof(PEDGE));
        } else {
            (*array) = (PEDGE*) ToplAlloc(ElementsAllocated * sizeof(PEDGE));
        }
    }
    (*array)[(*count)] = edge;
    (*count)++;

}


VOID
ToplpGraphMakeRing(
    PGRAPH     Graph,
    DWORD      Flags,
    PLIST      EdgesToAdd,
    PEDGE**    EdgesToKeep,
    ULONG*     cEdgesToKeep
    )
/*++                                                                           

Routine Description:

    This routine take Graph and determines what edges are necessary to 
    be created to make Graph into a ring, where vertices are connected in 
    ascending order, according to thier id.  In addition, existing edges
    necessary for the ring are recorded.

Parameters:

    Graph           should refer to a PGRAPH object
    
    Flags           can indicate whether the ring should be one-way or two way
    
    EdgesToAdd      should refer to a PLIST object.  All edges that need to 
                    be added will be placed in this list
                    
    EdgesToKeep     is an array of edges that exist in Graph. Edges that
                    that are needed to make a ring will be recorded in this
                    array. The caller must free this array with ToplFree. Note
                    that the edges object themselves still are contained within
                    the vertices they belong to and should be removed from there
                    before deleting.
                    
    cEdgesToKeep    is the number of elements in EdgesToKeep

Raises:

    TOPL_OUT_OF_MEMORY, TOPL_WRONG_OBJECT
        
--*/
{

    PVERTEX    Vertex;
    PEDGE      Edge;
    ULONG      VertexCount, Index, EdgeIndex;
    BOOLEAN    fMakeTwoWay = (BOOLEAN)(Flags & TOPL_RING_TWO_WAY);
    BOOLEAN    fSuccess   = FALSE;

    //
    // These resources must be released before exited
    //
    PVERTEX   *VertexArray = NULL;
    PITERATOR  VertexIterator = NULL;
    PITERATOR  EdgeIterator = NULL;
    
    __try
    {
        //
        // If the caller has specified that they want an array of vertices
        // to keep, init the array
        //
        if (EdgesToKeep) {
            EdgeArrayInit(EdgesToKeep, cEdgesToKeep);
        }
    
        //
        // Create an array of pointers to the vertices in graph so
        // they can be sorted
        //
        VertexArray = (PVERTEX*)ToplAlloc(ToplGraphNumberOfVertices(Graph) * sizeof(PVERTEX));
    
        VertexIterator = ToplpIterCreate();
        for ( ToplpGraphSetVertexIter(Graph, VertexIterator), VertexCount = 0; 
                Vertex = (PVERTEX) ToplpIterGetObject(VertexIterator);
                    ToplpIterAdvance(VertexIterator), VertexCount++) {
    
            ASSERT(ToplpIsVertex(Vertex));
    
            VertexArray[VertexCount] = Vertex;
    
        }
    
        qsort(VertexArray, VertexCount, sizeof(PVERTEX), compareVertices);
        
        //
        // Now iterate through each the vertices 1) creating edges that are
        // are needed to make a ring and 2) recording which edges are not
        // needed.
        //
        for (Index = 0; Index < VertexCount; Index++) {
    
            ULONG   ForwardVertexIndex, BackwardVertexIndex;
            BOOLEAN fFoundForwardEdge, fFoundBackwardEdge;
            PEDGE   Edge;
    
            fFoundForwardEdge = FALSE;
            fFoundBackwardEdge = FALSE;
    
            ForwardVertexIndex = Index + 1;
            BackwardVertexIndex = Index - 1;
            if (Index == 0) {
                BackwardVertexIndex =  VertexCount - 1;
            }
    
            if (Index == (VertexCount - 1)) {
                ForwardVertexIndex =  0;
            } 
    
            for (EdgeIndex = 0; 
                    EdgeIndex < ToplVertexNumberOfOutEdges(VertexArray[Index]); 
                        EdgeIndex++) {

                Edge = ToplVertexGetOutEdge(VertexArray[Index], EdgeIndex);

                ASSERT(ToplpIsEdge(Edge));
                ASSERT(ToplpEdgeGetFromVertex(Edge) == VertexArray[Index]);
    
                if (ToplpEdgeGetToVertex(Edge) == VertexArray[ForwardVertexIndex]) {
    
                    if(EdgesToKeep)
                        EdgeArrayAdd(EdgesToKeep, cEdgesToKeep, Edge);
                    fFoundForwardEdge = TRUE;
    
                } else if (ToplpEdgeGetToVertex(Edge) == VertexArray[BackwardVertexIndex]) {
    
                    if (fMakeTwoWay) {
    
                        if(EdgesToKeep)
                            EdgeArrayAdd(EdgesToKeep, cEdgesToKeep, Edge);
                        fFoundBackwardEdge = TRUE;
    
                    }
                }

            }


            //
            // Now create the edges as needed
            //
            if (Index == ForwardVertexIndex) {
                ASSERT(Index == BackwardVertexIndex);
                // There is just one vertex
                break;
            }
    
            if (!fFoundForwardEdge) {
    
                Edge = ToplpEdgeCreate(NULL);
    
                ToplpEdgeSetFromVertex(Edge, VertexArray[Index]);
                ToplpEdgeSetToVertex(Edge, VertexArray[ForwardVertexIndex]);
    
                ToplpListAddElem(EdgesToAdd, Edge);
    
            }
    
            if (  fMakeTwoWay
               && VertexArray[BackwardVertexIndex] != VertexArray[ForwardVertexIndex]
               && !fFoundBackwardEdge) {
    
                //
                // The caller wanted a two way ring & there is more than 2 vertices
                // and no backward edge was found
                //
    
                Edge = ToplpEdgeCreate(NULL);
    
                ToplpEdgeSetFromVertex(Edge, VertexArray[Index]);
                ToplpEdgeSetToVertex(Edge, VertexArray[BackwardVertexIndex]);
    
                ToplpListAddElem(EdgesToAdd, Edge);
            }
    
        }

        fSuccess = TRUE;
    }
    __finally
    {
        if (VertexArray) {
            ToplFree(VertexArray);
        }

        if (VertexIterator) {
            ToplIterFree(VertexIterator);
        }

        if (EdgeIterator) {
            ToplIterFree(EdgeIterator);
        }

        if (!fSuccess) {
            //
            // We must have bailed due to an exception - release resources
            // that normally the user would have freed
            //
            if (EdgesToKeep && *EdgesToKeep) {
                ToplFree(*EdgesToKeep);
                *EdgesToKeep = NULL;
            }

            while( (Edge=ToplpListRemoveElem(EdgesToAdd, NULL)) ) {
                ToplpEdgeDestroy(Edge, TRUE);
            }
        }
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\w32topl.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    w32topl.c

Abstract:

    This routine contains the dll entrypoint definitions for the w32topl.dll

Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <w32topl.h>
#include <w32toplp.h>

#include <topllist.h>
#include <toplgrph.h>
#include <toplring.h>
#include <dynarray.h>

// Index to be used for thread local storage.
DWORD gdwTlsIndex = 0;

//
// Entrypoint definitions
//

ULONG
NTAPI
DllMain(
    HANDLE Module,
    ULONG Reason,
    PVOID Context
    )
{
    if (DLL_PROCESS_ATTACH == Reason) {
        // Prepare for thread local storage (see toplutil.c).
        gdwTlsIndex = TlsAlloc();
        if (0xFFFFFFFF == gdwTlsIndex) {
            ASSERT(!"TlsAlloc() failed!");
            return FALSE;
        }

        DisableThreadLibraryCalls(Module);
    }

    return TRUE ;
}

    


//
// List manipulation routines
//

TOPL_LIST
ToplListCreate(
    VOID
    )

/*++                                                                           

Routine Description:

    This routine creates a List object and returns a pointer to it.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{    
    return ToplpListCreate();
}


VOID 
ToplListFree(
    TOPL_LIST List,
    BOOLEAN   fRecursive   // TRUE implies free the elements contained 
                           // in the list
    )
/*++                                                                           

Routine Description:

    This routine frees a list object

Parameters:

    List       - should refer to PLIST object
    fRecursive - TRUE implies that elements in the list will be freed, too
    
Throws:

    TOPL_EX_WRONG_OBJECT    

--*/
{    
    PLIST pList = (PLIST)List;

    if (!ToplpIsList(pList)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpListFree(pList, fRecursive);

    return;
}


VOID
ToplListSetIter(
    TOPL_LIST     List,
    TOPL_ITERATOR Iterator
    )
/*++                                                                           

Routine Description:

    This routine sets Iterator to point to the head of List.

Parameters:

    List     should refer to a PLIST object
    Iterator should refer to a PITERATOR object
    
--*/
{    

    PLIST pList     = (PLIST)List;
    PITERATOR pIter = (PITERATOR)Iterator;

    if (!ToplpIsList(pList) || !ToplpIsIterator(pIter)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpListSetIter(pList, pIter);

    return;
}


TOPL_LIST_ELEMENT
ToplListRemoveElem(
    TOPL_LIST         List,
    TOPL_LIST_ELEMENT Elem
    )
/*++                                                                           

Routine Description:

    This routine removes Elem from List if it exists in the list; NULL otherwise.
    If Elem is NULL then the first element in the list, if any, is returned.

Parameters:

    List should refer to a PLIST object
    Elem if non-NULL should refer to a PLIST_ELEMENT
    
Returns:

    TOPL_LIST_ELEMENT if found; NULL otherwise

--*/
{    

    PLIST pList         = (PLIST)List;
    PLIST_ELEMENT pElem = (PLIST_ELEMENT)Elem;


    if (!ToplpIsList(pList)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    if (pElem) {
        if (!ToplpIsListElement(pElem)) {
            ToplRaiseException(TOPL_EX_WRONG_OBJECT);
        }
    }

    return ToplpListRemoveElem(pList, pElem);

}


VOID
ToplListAddElem(
    TOPL_LIST         List,
    TOPL_LIST_ELEMENT Elem
    )
/*++                                                                           

Routine Description:

    This routine adds Elem to List.  Elem should not be part of another list -
    currently there is no checking for this.

Parameters:

    List should refer to a PLIST object
    Elem should refer to a PLIST_ELEMENT


--*/
{    

    PLIST pList     = (PLIST)List;
    PLIST_ELEMENT pElem = (PLIST_ELEMENT)Elem;

    if (!ToplpIsList(pList) || !ToplpIsListElement(pElem)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpListAddElem(pList, pElem);

    return;
}



DWORD
ToplListNumberOfElements(
    TOPL_LIST         List
    )
/*++                                                                           

Routine Description:

    This routine returns the number of elements in List

Parameters:

    List should refer to a PLIST object

--*/
{    

    PLIST pList     = (PLIST)List;

    if (!ToplpIsList(pList)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpListNumberOfElements(pList);

}


//
// Iterator object routines
//
TOPL_ITERATOR
ToplIterCreate(
    VOID
    )
/*++                                                                           

Routine Description:

    This creates an iterator object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.

--*/
{    
    return ToplpIterCreate();
}


VOID 
ToplIterFree(
    TOPL_ITERATOR Iterator
    )
/*++                                                                           

Routine Description:

    This routine free an iterator object.

Parameters:

    Iterator should refer to a PITERATOR object

--*/
{    

    PITERATOR pIter = (PITERATOR)Iterator;

    if (!ToplpIsIterator(pIter)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpIterFree(pIter);

    return;
}


TOPL_LIST_ELEMENT
ToplIterGetObject(
    TOPL_ITERATOR Iterator
    )
/*++                                                                           

Routine Description:

    This routine returns the current object pointer to by the iterator.

Parameters:

    Iterator should refer to a PITERATOR object
    
Return Values:

    A pointer to the current object - NULL if there are no more objects

--*/
{    

    PITERATOR pIter = (PITERATOR)Iterator;

    if (!ToplpIsIterator(pIter)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpIterGetObject(pIter);
    
}

VOID
ToplIterAdvance(
    TOPL_ITERATOR Iterator
    )
/*++                                                                           

Routine Description:

    This routine advances the iterator by one object if it is not at the
    end.

Parameters:

    Iterator should refer to a PITERATOR object
    
--*/
{   

    PITERATOR pIter = (PITERATOR)Iterator;

    if (!ToplpIsIterator(pIter)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpIterAdvance(pIter);

    return;
}

TOPL_EDGE
ToplEdgeCreate(
    VOID
    )        
/*++                                                                           

Routine Description:

    This routine creates an edge object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{    
    return ToplpEdgeCreate(NULL);
}

VOID
ToplEdgeFree(
    TOPL_EDGE Edge
    )
/*++                                                                           

Routine Description:

    This routine frees an edge object.

Parameters:

    Edge should refer to a PEDGE object

--*/
{    

    PEDGE pEdge = (PEDGE)Edge;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpEdgeDestroy(pEdge, 
                     TRUE);  // free the Edge

    return;
}


VOID
ToplEdgeInit(
    PEDGE E
    )
/*++                                                                           

Routine Description:

    This routine initializes an already allocated piece of memory to 
    be an edge structure.  This is used by the c++ classes.

Parameters:

    E  : a pointer to an uninitialized edge object

--*/
{

    if (!E) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpEdgeCreate(E);

}

VOID
ToplEdgeDestroy(
    PEDGE  E
    )
/*++                                                                           

Routine Description:

    This routine cleans up any resources kept by E but does not free
    E.

Parameters:

    E  : a pointer to an edge object

--*/
{

    if (!ToplpIsEdge(E)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpEdgeDestroy(E, FALSE); // Don't free the object
}

VOID
ToplEdgeSetToVertex(
    TOPL_EDGE   Edge,
    TOPL_VERTEX ToVertex
    )
/*++                                                                           

Routine Description:

    This routine sets the ToVertex field of the edge.

Parameters:
    
    Edge should refer to a PEDGE object
    ToVertex if non-NULL should refer to a PVERTEX object

--*/
{    

    PEDGE   pEdge = (PEDGE)Edge;
    PVERTEX pVertex = (PVERTEX)ToVertex;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    if (pVertex) {
        if (!ToplpIsVertex(pVertex)) {
            ToplRaiseException(TOPL_EX_WRONG_OBJECT);
        }
    }

    ToplpEdgeSetToVertex(pEdge, pVertex);
    
    return;
}

TOPL_VERTEX
ToplEdgeGetToVertex(
    TOPL_EDGE   Edge
    )
/*++                                                                           

Routine Description:

    This routine returns the ToVertex

Parameters:
    
    Edge should refer to a PDGE object.

--*/
{    
    PEDGE pEdge = (PEDGE)Edge;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpEdgeGetToVertex(pEdge);
}

VOID
ToplEdgeSetFromVertex(
    TOPL_EDGE   Edge,
    TOPL_VERTEX FromVertex
    )
/*++                                                                           

Routine Description:

    This routine sets the FromVertex of the Edge. 

Parameters:


    Edge should refer to a PEDGE object
    FromVertex if non-NULL should refer to a PVERTEX object
    

--*/
{    
    PEDGE   pEdge =   (PEDGE)Edge;
    PVERTEX pVertex = (PVERTEX)FromVertex;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    if (pVertex) {
        if (!ToplpIsVertex(pVertex)) {
            ToplRaiseException(TOPL_EX_WRONG_OBJECT);
        }
    }

    ToplpEdgeSetFromVertex(pEdge, pVertex);

    return;
}


TOPL_VERTEX
ToplEdgeGetFromVertex(
    TOPL_EDGE Edge
    )
/*++                                                                           

Routine Description:

    This routine returns the from vertex associated with Edge.

Parameters:

    Edge should refer to a PEDGE object

Return Values:

    A vertex object or NULL

--*/
{    
    PEDGE pEdge = (PEDGE)Edge;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpEdgeGetFromVertex(pEdge);
}


VOID
ToplEdgeAssociate(
    IN TOPL_EDGE Edge
    )
/*++                                                                           

Routine Description:

    This routines adds the edges in question to edge lists of the 
    To and From vertices.

Parameters:

    Edge should refer to a PEDGE object

Return Values:

    None.
    
Throws:

    TOPL_EX_INVALID_VERTEX if either of the vertices don't point to valid
    vertices


--*/
{

    PEDGE pEdge = (PEDGE)Edge;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpEdgeAssociate(pEdge);

    return;

}

VOID
ToplEdgeDisassociate(
    IN TOPL_EDGE Edge
    )
/*++                                                                           

Routine Description:

    This routine removes the edge from the To and From vertex's edge list.

Parameters:

    Edge should refer to a PEDGE object

Return Values:

Throws:

    TOPL_EX_INVALID_VERTEX if either of the vertices don't point to valid
    vertices

--*/
{

    PEDGE pEdge = (PEDGE)Edge;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpEdgeDisassociate(pEdge);

    return;

}



VOID
ToplEdgeSetWeight(
    TOPL_EDGE   Edge,
    DWORD       Weight
    )
/*++                                                                           

Routine Description:

    This routine sets the weight field of the edge.

Parameters:
    
    Edge should refer to a PEDGE object

--*/
{    

    PEDGE   pEdge = (PEDGE)Edge;
    DWORD   ValidWeight = Weight;

    if ( !ToplpIsEdge(pEdge) )
    {
        ToplRaiseException( TOPL_EX_WRONG_OBJECT );
    }

    //
    // The minimum spanning tree algorithm needs to use DWORD_INFINITY
    // as a sentinel
    //
    if ( ValidWeight == DWORD_INFINITY )
    {
        ValidWeight--;
    }

    ToplpEdgeSetWeight( pEdge, ValidWeight );
    
    return;
}

DWORD
ToplEdgeGetWeight(
    TOPL_EDGE   Edge
    )
/*++                                                                           

Routine Description:

    This routine returns the weight field of the edge.

Parameters:
    
    Edge should refer to a PEDGE object

--*/
{    

    PEDGE   pEdge = (PEDGE)Edge;

    if ( !ToplpIsEdge(pEdge) )
    {
        ToplRaiseException( TOPL_EX_WRONG_OBJECT );
    }

    return ToplpEdgeGetWeight( pEdge );

}

//
// Vertex object routines
//
TOPL_VERTEX
ToplVertexCreate(
    VOID
    )
/*++                                                                           

Routine Description:

    This routine creates a vertex object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{    
    return ToplpVertexCreate(NULL);
}

VOID
ToplVertexFree(
    TOPL_VERTEX Vertex
    )
/*++                                                                           

Routine Description:

    This routine releases the resources of a vertex object.

Parameters:

    Vertex should refer to a PVERTEX object

--*/
{    

    PVERTEX   pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpVertexDestroy(pVertex,
                       TRUE);  // free the vertex

    return;
}


VOID
ToplVertexInit(
    PVERTEX V
    )
/*++                                                                           

Routine Description:

    This routine initializes an already allocated piece of memory to 
    be a vertex structure.  This is used by the c++ classes.

Parameters:

    V  : a pointer to an uninitialized vertex object

--*/
{

    if (!V) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpVertexCreate(V);

}

VOID
ToplVertexDestroy(
    PVERTEX  V
    )
/*++                                                                           

Routine Description:

    This routine cleans up any resources kept by V but does not free
    V

Parameters:

    V  : a pointer to  vertex object

--*/
{

    if (!ToplpIsVertex(V)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpVertexDestroy(V, FALSE); // Don't free the object
}

VOID
ToplVertexSetId(
    TOPL_VERTEX Vertex,
    DWORD       Id
    )
/*++                                                                           

Routine Description:

    This routine sets the Id of Vertex

Parameters:

    Vertex should refer to a PVERTEX object

--*/
{   

    PVERTEX   pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpVertexSetId(pVertex, Id);

    return;
}

DWORD
ToplVertexGetId(
    TOPL_VERTEX Vertex
    )
/*++                                                                           

Routine Description:

    This routine returns the Id associated with this vertex.

Parameters:

    Vertex should refer to a PVERTEX object

Returns:

    The id of the vertex

--*/
{  

    PVERTEX   pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpVertexGetId(pVertex);
}

DWORD
ToplVertexNumberOfInEdges(
    IN TOPL_VERTEX Vertex
    )
/*++                                                                           

Routine Description:


Parameters:

    Vertex       should refer to a PVERTEX object

Returns:

Raises:

--*/
{

    PVERTEX pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }
    
    return ToplpVertexNumberOfInEdges(pVertex);
}

TOPL_EDGE
ToplVertexGetInEdge(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Index
    )
/*++                                                                           

Routine Description:


Parameters:

    Vertex       should refer to a PVERTEX object

Returns:

Raises:

--*/
{

    PVERTEX pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpVertexGetInEdge(pVertex, Index);
}

DWORD
ToplVertexNumberOfOutEdges(
    IN TOPL_VERTEX Vertex
    )
/*++                                                                           

Routine Description:


Parameters:

    Vertex       should refer to a PVERTEX object

Returns:

Raises:

--*/
{

    PVERTEX pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpVertexNumberOfOutEdges(pVertex);
}

TOPL_EDGE
ToplVertexGetOutEdge(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Index
    )
/*++                                                                           

Routine Description:


Parameters:

    Vertex       should refer to a PVERTEX object

Returns:

Raises:

--*/
{

    PVERTEX pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpVertexGetOutEdge(pVertex, Index);
}

VOID
ToplVertexSetParent(
    TOPL_VERTEX Vertex,
    TOPL_VERTEX Parent
    )
/*++                                                                           

Routine Description:

    This routine sets the parent of Vertex

Parameters:

    Vertex should refer to a PVERTEX object
    Parent should refer to a PVERTEX object

--*/
{   

    PVERTEX   pVertex = (PVERTEX)Vertex;
    PVERTEX   pParent  = (PVERTEX)Parent;

    if (!ToplpIsVertex(pVertex))
    {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    if ( Parent && !ToplpIsVertex(pVertex) )
    {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpVertexSetParent( pVertex, pParent );

    return;
}

TOPL_VERTEX
ToplVertexGetParent(
    TOPL_VERTEX Vertex
    )
/*++                                                                           

Routine Description:

    This routine returns the parent associated with this vertex.

Parameters:

    Vertex should refer to a PVERTEX object

Returns:

    The parent of the vertex

--*/
{  

    PVERTEX   pVertex = (PVERTEX) Vertex;

    if ( !ToplpIsVertex( pVertex ) )
    {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpVertexGetParent( pVertex );
}


//
// Graph object routines
//

TOPL_GRAPH
ToplGraphCreate(
    VOID
    )
/*++                                                                           

Routine Description:

    This routine creates a graph object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.

--*/
{    
    return ToplpGraphCreate(NULL);
}

VOID
ToplGraphFree(
    TOPL_GRAPH Graph,
    BOOLEAN    fRecursive
    )
/*++                                                                           

Routine Description:

    This routine frees a graph object.

Parameters:

    Graph should refer to a PGRAPH object
    fRecursive : TRUE implies to free all edges and vertices associated with
                 the graph

--*/
{   

    PGRAPH   pGraph = (PGRAPH)Graph;

    if (!ToplpIsGraph(pGraph)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpGraphDestroy(pGraph, 
                      TRUE,   //  free the objects
                      fRecursive);

    return;
}


VOID
ToplGraphInit(
    PGRAPH G
    )
/*++                                                                           

Routine Description:

    This routine initializes an already allocated piece of memory to 
    be an graph structure.  This is used by the c++ classes.

Parameters:

    G  : a pointer to an uninitialized graph object

--*/
{

    if (!G) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpGraphCreate(G);

}

VOID
ToplGraphDestroy(
    PGRAPH  G
    )
/*++                                                                           

Routine Description:

    This routine cleans up any resources kept by G but does not free
    G.

Parameters:

    G  : a pointer to an graph object

--*/
{

    if (!ToplpIsGraph(G)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpGraphDestroy(G, 
                      FALSE,  // Don't recursivly delete the vertices
                      FALSE); // Don't free the object
}

VOID
ToplGraphAddVertex(
    TOPL_GRAPH  Graph,
    TOPL_VERTEX VertexToAdd,
    PVOID       VertexName
    )
/*++                                                                           

Routine Description:

    This routine adds VertexToAdd to Graph.

Parameters:

    Graph should refer to a PGRAPH object
    VertexToAdd should refer to a PVERTEX object

Return Values:

--*/
{    

    PGRAPH   pGraph = (PGRAPH)Graph;
    PVERTEX  pVertex = (PVERTEX)VertexToAdd;

    if (!ToplpIsGraph(pGraph) || !ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    pVertex->VertexData.VertexName = VertexName;
    ToplpGraphAddVertex(pGraph, pVertex);
    
    return;
}

TOPL_VERTEX
ToplGraphRemoveVertex(
    TOPL_GRAPH  Graph,
    TOPL_VERTEX VertexToRemove
    )
/*++                                                                           

Routine Description:

    This routine removes and returns VertexToRemove from Graph if VertexToRemove
    is in Graph; returns NULL otherwise.
    If VertexToRemove is NULL, the first vertex in Graph's vertex list is
    removed.

Parameters:

    Graph should refer to a PGRAPH object
    VertexToRemove should be NULL or refer to a PVERTEX object

--*/
{   

    PGRAPH   pGraph = (PGRAPH)Graph;
    PVERTEX  pVertex = (PVERTEX)VertexToRemove;

    if (!ToplpIsGraph(pGraph)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    if (pVertex) {
        if (!ToplpIsVertex(pVertex)) {
            ToplRaiseException(TOPL_EX_WRONG_OBJECT);
        }
    }

    return ToplpGraphRemoveVertex(pGraph, pVertex);

}
      
VOID
ToplGraphSetVertexIter(
    TOPL_GRAPH    Graph,
    TOPL_ITERATOR Iter
    )
/*++                                                                           

Routine Description:

    This routine sets Iter to point to the beginning of Graph's vertex list.

Parameters:

    Graph should refer to a PGRAPH object
    Iter  should refer to a PITERATOR object

--*/
{   

    PGRAPH     pGraph = (PGRAPH)Graph;
    PITERATOR  pIter  = (PITERATOR)Iter;

    if (!ToplpIsGraph(pGraph) || !ToplpIsIterator(pIter)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpGraphSetVertexIter(pGraph, pIter);

    return;
}


DWORD
ToplGraphNumberOfVertices(
    TOPL_GRAPH    Graph
)
/*++                                                                           

Routine Description:

    This routine returns the number of vertices in Graph's vertex list.

Parameters:

    Graph should refer to a PGRAPH object

--*/
{   

    PGRAPH     pGraph = (PGRAPH)Graph;
    
    if (!ToplpIsGraph(pGraph)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return  ToplpGraphNumberOfVertices(pGraph);
}


VOID
ToplGraphMakeRing(
    IN TOPL_GRAPH Graph,
    IN DWORD      Flags,
    OUT TOPL_LIST  EdgesToAdd,
    OUT TOPL_EDGE  **EdgesToKeep,
    OUT PULONG     cEdgesToKeep
    )
/*++                                                                           

Routine Description:

    This routine take Graph and determines what edges are necessary to 
    be created to make Graph into a ring, where vertices are connected in 
    ascending order, according to thier id.  In addition, edges superfluous
    to this ring are recorded.


Parameters:

    Graph           should refer to a PGRAPH object
    
    Flags           can indicate whether the ring should be one-way or two way
    
    EdgesToAdd      should refer to a PLIST object.  All edges that need to 
                    be added will be placed in this list
                    
    EdgesToKeep     is an array of edges that exist in Graph. Edges that
                    that are needed to make a ring will be recorded in this
                    array. The caller must free this array with ToplFree. Note
                    that the edges object themselves still are contained within
                    the vertices they belong to and should be removed from there
                    before deleting.
                    
    cEdgesToKeep  is the number of elements in EdgesToKeep

Raises:

    TOPL_EX_OUT_OF_MEMORY, TOPL_EX_WRONG_OBJECT
        
--*/
{
    PGRAPH pGraph = (PGRAPH)Graph;
    PLIST  pEdgesToAdd = (PLIST)EdgesToAdd;
    PEDGE  **pEdgesToKeep = (PEDGE**)EdgesToKeep;

    if (!ToplpIsGraph(pGraph) || !ToplpIsList(pEdgesToAdd) ) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ASSERT(Flags & TOPL_RING_ONE_WAY
        || Flags & TOPL_RING_TWO_WAY);

    ToplpGraphMakeRing(pGraph, 
                       Flags, 
                       pEdgesToAdd, 
                       pEdgesToKeep, 
                       cEdgesToKeep);

    return;

}

TOPL_COMPONENTS*
ToplGraphFindEdgesForMST(
    IN  TOPL_GRAPH  Graph,
    IN  TOPL_VERTEX RootVertex,
    IN  TOPL_VERTEX VertexOfInterest,
    OUT TOPL_EDGE  **EdgesNeeded,
    OUT ULONG*      cEdgesNeeded
    )
/*++                                                                           

Routine Description:

    This routine makes a minimum cost spanning tree out of the edges and
    vertices in Graph and the determines what edges are connected to
    VertexOfInterest.

Parameters:

    Graph : an initialized graph object
    
    RootVertex : the vertex to start the mst from
    
    VertexOfInterest : the vertex to based EdgesNeeded on
    
    EdgesNeeded: the edges needed to be created by VertexOfInterest
                 to make the mst
                 
    cEdgesNeeded: the nummber of EdgesNeeded                 

Raises:

    TOPL_EX_OUT_OF_MEMORY, TOPL_EX_WRONG_OBJECT
        
--*/
{

    TOPL_COMPONENTS *pComponents;
    PGRAPH  pGraph = (PGRAPH)Graph;
    PVERTEX pRootVertex = (PVERTEX) RootVertex;
    PVERTEX pVertexOfInterest = (PVERTEX) VertexOfInterest;
    PEDGE  **pEdgesNeeded = (PEDGE**)EdgesNeeded;

    if ( !ToplpIsGraph( pGraph ) 
     ||  !ToplpIsVertex( pRootVertex )
     ||  !ToplpIsVertex( pVertexOfInterest ) ) {

        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ASSERT( EdgesNeeded );
    ASSERT( cEdgesNeeded );

    pComponents = ToplpGraphFindEdgesForMST( pGraph, 
                                         pRootVertex,
                                         pVertexOfInterest,
                                         pEdgesNeeded,
                                         cEdgesNeeded );

    ASSERT( pComponents!=NULL );
    return pComponents;

}

int
ToplIsToplException(
    DWORD ErrorCode
    )
/*++                                                                           

Routine Description:

    This routine is to be used in an exception filter to determine if the
    exception that was raised was generated by w32topl.dll

Parameters:

    ErrorCode   : the error code of the exception - ususually the value
                  returned from GetExceptionCode

Returns:

    EXCEPTION_EXECUTE_HANDLER, EXCEPTION_CONTINUE_SEARCH
        
--*/
{

    switch (ErrorCode) {
        
        case TOPL_EX_OUT_OF_MEMORY:
        case TOPL_EX_WRONG_OBJECT:
        case TOPL_EX_INVALID_EDGE:
        case TOPL_EX_INVALID_VERTEX:
        case TOPL_EX_INVALID_INDEX:
        case TOPL_EX_NULL_POINTER:
        case TOPL_EX_SCHEDULE_ERROR:
        case TOPL_EX_CACHE_ERROR:
        case TOPL_EX_NEVER_SCHEDULE:
        case TOPL_EX_GRAPH_STATE_ERROR:
        case TOPL_EX_INVALID_EDGE_TYPE:
        case TOPL_EX_INVALID_EDGE_SET:
        case TOPL_EX_COLOR_VTX_ERROR:
        case TOPL_EX_ADD_EDGE_AFTER_SET:
        case TOPL_EX_TOO_FEW_VTX:
        case TOPL_EX_TOO_FEW_EDGES:
        case TOPL_EX_NONINTERSECTING_SCHEDULES:

            return EXCEPTION_EXECUTE_HANDLER;

        default:

            return EXCEPTION_CONTINUE_SEARCH;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\toplutil.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplutil.c

Abstract:

    This file contains helper routines for w32topl.dll

Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <search.h>
#include <stddef.h>           // for offsetof()

#include <windows.h>
#include <winerror.h>


typedef unsigned long DWORD;


#include <w32topl.h>
#include <w32toplp.h>

//
// For the CAST_TO_LIST_ELEMENT macro
//
LIST_ELEMENT DummyListElement;

//
// Allocator routines
//
DWORD
ToplSetAllocator(
    IN  TOPL_ALLOC *    pfAlloc     OPTIONAL,
    IN  TOPL_REALLOC *  pfReAlloc   OPTIONAL,
    IN  TOPL_FREE *     pfFree      OPTIONAL
    )
/*++                                                                           

Routine Description:

    Sets the memory allocate/free routines to those specified.  If NULL, the
    default routines will be used.
    
    These routines are set on a per-thread basis.

Parameters:

    pfAlloc (IN) - Pointer to memory allocation function.
    
    pfReAlloc (IN) - Pointer to memory re-allocation function.
    
    pfFree (IN) - Pointer to memory free function.

Return Values:

    Win32 error.

--*/
{
    TOPL_TLS * pTLS;
    BOOL ok;
    
    // If one is NULL, all must be NULL.
    if ((!!pfAlloc != !!pfFree) || (!!pfAlloc != !!pfReAlloc)) {
        return ERROR_INVALID_PARAMETER;
    }

    pTLS = (TOPL_TLS *) TlsGetValue(gdwTlsIndex);
    
    if (NULL == pfAlloc) {
        // Reset to default allocator.
        if (NULL != pTLS) {
            // Free the allocator info in thread local storage.
            (*pTLS->pfFree)(pTLS);
            
            ok = TlsSetValue(gdwTlsIndex, NULL);
            ASSERT(ok);
            if (!ok) {
                return GetLastError();
            }
        }
    }
    else {
        if (NULL == pTLS) {
            // Thread local storage block not yet allocated -- do so.
            pTLS = (*pfAlloc)(sizeof(*pTLS));
            if (NULL == pTLS) {
                return ERROR_OUTOFMEMORY;
            }

            ok = TlsSetValue(gdwTlsIndex, pTLS);
            ASSERT(ok);
            if (!ok) {
                (*pfFree)(pTLS);
                return GetLastError();
            }
        }

        // Save new non-default allocator info.
        pTLS->pfAlloc   = pfAlloc;
        pTLS->pfReAlloc = pfReAlloc;
        pTLS->pfFree    = pfFree;
    }

    return 0;
}


VOID*
ToplAlloc(
    ULONG size
    )
/*++                                                                           

Routine Description:

    This function allocates size bytes and returns a pointer to that chunk
    of memory.

Parameters:

    size : the number of bytes to be allocates

Return Values:

    A pointer to a block of memory; this function never returns NULL
    since an exception is raised if the allocation fails.

--*/
{
    TOPL_TLS * pTLS = (TOPL_TLS *) TlsGetValue(gdwTlsIndex);
    PVOID ret;

    if (NULL == pTLS) {
        ret = RtlAllocateHeap(RtlProcessHeap(), 0, size);
    }
    else {
        ret = (*pTLS->pfAlloc)(size);
    }

    if (!ret) {
        ToplRaiseException(TOPL_EX_OUT_OF_MEMORY);
    }

    return ret;
}


VOID*
ToplReAlloc(
    PVOID p,
    ULONG size
    )
/*++                                                                           

Routine Description:

    This function reallocates a chunk of memory allocated from 
    ToplAlloc

Parameters:

    p    the block of memory to reallocate
    size the new size of the block

Return Values:

    A pointer to a block of memory; this function never returns NULL
    since an exception is raised if the allocation fails.

--*/
{
    TOPL_TLS * pTLS = (TOPL_TLS *) TlsGetValue(gdwTlsIndex);
    PVOID ret;

    ASSERT(p);

    if (NULL == pTLS) {
        ret = RtlReAllocateHeap(RtlProcessHeap(), 0, p, size);
    }
    else {
        ret = (*pTLS->pfReAlloc)(p, size);
    }

    if (!ret) {
        ToplRaiseException(TOPL_EX_OUT_OF_MEMORY);
    }

    return ret;
}


VOID
ToplFree(
    VOID *p
    )
/*++                                                                           

Routine Description:

    This routine frees a block of memory allocated by a Topl*Alloc routine.

Parameters:

    p : a pointer to the block to release

Return Values:

--*/
{
    TOPL_TLS * pTLS = (TOPL_TLS *) TlsGetValue(gdwTlsIndex);

    ASSERT(p);

    if (NULL == pTLS) {
        RtlFreeHeap(RtlProcessHeap(), 0, p);
    }
    else {
        (*pTLS->pfFree)(p);
    }
}

//
// Exception handling routines
//

void 
ToplRaiseException(
    DWORD ErrorCode
    )
/*++                                                                           

Routine Description:

    This routine is a small wrapper for the RaiseException() function

Parameters:

    ErrorCode to throw.

Return Values:

    Does not return.

--*/
{
    RaiseException(ErrorCode, 
                   EXCEPTION_NONCONTINUABLE,
                   0,
                   NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\w32toplp.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    w32toplp.h

Abstract:

    This file contains the private definitions of the core data structures
    and functions for w32topl.dll

Author:

    Colin Brace ColinBr
    
Revision History

    3-12-97   ColinBr    Created
    
--*/

#ifndef __W32TOPLP_H
#define __W32TOPLP_H

#define ToplpIsListElement(Elem)  ((Elem)   ? ( ((PLIST_ELEMENT)(Elem))->ObjectType == eEdge || \
                                                ((PLIST_ELEMENT)(Elem))->ObjectType == eVertex) : 0)
#define ToplpIsList(List)         ((List)   ? (((PLIST)(List))->ObjectType == eList) : 0)
#define ToplpIsIterator(Iter)     ((Iter)   ? (((PITERATOR)(Iter))->ObjectType == eIterator) :0)
#define ToplpIsEdge(Edge)         ((Edge)   ? (((PEDGE)(Edge))->ObjectType == eEdge) : 0)
#define ToplpIsVertex(Vertex)     ((Vertex) ? (((PVERTEX)(Vertex))->ObjectType == eVertex) : 0)
#define ToplpIsGraph(Graph)       ((Graph)  ? (((PGRAPH)(Graph))->ObjectType == eGraph) : 0)

#define CAST_TO_LIST_ELEMENT(pLink) (pLink ? (PLIST_ELEMENT) ((UCHAR*)(pLink) - offsetof(LIST_ELEMENT, Link)) : 0)

// Thread-local storage for memory allocation functions.
typedef struct _TOPL_TLS {
    TOPL_ALLOC *    pfAlloc;
    TOPL_REALLOC *  pfReAlloc;
    TOPL_FREE *     pfFree;
} TOPL_TLS;

extern DWORD gdwTlsIndex;

//
// Memory Routines
//
VOID*
ToplAlloc(
    ULONG size
    );

VOID*
ToplReAlloc(
    PVOID p,
    ULONG size
    );

//
// ToplFree is exported and can be found in w32topl.h
//

//
// Exception routines
//
void 
ToplRaiseException(
    DWORD ErrorCode
    );

#endif // __W32TOPLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\exe\apitest.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    apitest.c

Abstract:

    This file contains a function that methodically tests every api in 
    w32topl
    
Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>

typedef unsigned long DWORD;

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include <w32topl.h>

//
// Small utilities
//
extern BOOLEAN fVerbose;

#define Output(x)          if (fVerbose) printf x;
#define NELEMENTS(x)        (sizeof(x)/sizeof(x[0]))


int
TestAPI(
    VOID
    )
//
// This function methodically calls every api in w32topl.dll
// 0 is returned on success; !0 otherwise
//
{
    int               ret;
    DWORD             ErrorCode;
    TOPL_LIST         List = NULL;
    TOPL_ITERATOR     Iter = NULL;
    TOPL_EDGE         Edge = NULL;
    TOPL_VERTEX       Vertex = NULL, Vertex2 = NULL;
    TOPL_GRAPH        Graph = NULL;
    TOPL_LIST_ELEMENT Elem = NULL;
    

    __try
    {
        //
        // First list and iterator routines
        //
        List  =  ToplListCreate();
        Edge  =  ToplEdgeCreate();
        Vertex = ToplVertexCreate();
    
        if (ToplListNumberOfElements(List) != 0) {
            Output(("ToplList api broken\n"));
            return !0;
        }
    
        ToplListAddElem(List, Edge);
        ToplListAddElem(List, Vertex);
    
        if (ToplListNumberOfElements(List) != 2) {
            Output(("ToplList api broken\n"));
            return !0;
        }
        //
        // Iterator routines
        //
        Iter = ToplIterCreate();
    
        ToplListSetIter(List, Iter);
    
        Elem = ToplIterGetObject(Iter);
        if (Elem != Vertex && Elem != Edge) {
            Output(("ToplIterGetObject failed\n"));
            return !0;
        }
        ToplIterAdvance(Iter);
    
        Elem = ToplIterGetObject(Iter);
        if (Elem != Vertex && Elem != Edge) {
            Output(("ToplIterGetObject failed\n"));
            return !0;
        }
    
        ToplIterAdvance(Iter);
    
        Elem = ToplIterGetObject(Iter);
        if (Elem) {
            Output(("ToplIterGetObject failed\n"));
            return !0;
        }
    
        ToplIterFree(Iter);
    
        //
        // Iterator is done, continue with list routines
        //
        if (Edge != ToplListRemoveElem(List, Edge)) {
            Output(("ToplListRemove failed\n"));
            return !0;
        }
    
        //
        // There is only one element left now
        //
        if (Vertex != ToplListRemoveElem(List, NULL)) {
            Output(("ToplListRemove failed\n"));
            return !0;
        }
    

        //
        // Test the non-recursive delete
        //
        ToplListFree(List, FALSE);
    
        //
        // Test the recursive delete
        //
        List = ToplListCreate();
    
        ToplListAddElem(List, Edge);
        ToplListAddElem(List, Vertex);
    
        ToplListFree(List, TRUE);
    
        //
        // Now test the vertex and edge api
        //
        Edge     = ToplEdgeCreate();
        Vertex   = ToplVertexCreate();
        Vertex2  = ToplVertexCreate();
    
        ToplEdgeSetFromVertex(Edge, Vertex);
        if (Vertex != ToplEdgeGetFromVertex(Edge)) {
            Output(("ToplEdge api broken.\n"));
            return !0;
        }
    
        ToplEdgeSetToVertex(Edge, Vertex2);
        if (Vertex2 != ToplEdgeGetToVertex(Edge)) {
            Output(("ToplEdge api broken.\n"));
            return !0;
        }
    
        ToplVertexSetId(Vertex, 123);
        if (123 != ToplVertexGetId(Vertex)) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }
    
        if (ToplVertexNumberOfOutEdges(Vertex) != 0) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        if (ToplVertexNumberOfInEdges(Vertex2) != 0) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        ToplEdgeAssociate(Edge);
    
        if (ToplVertexNumberOfOutEdges(Vertex) != 1) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }
    
        if (ToplVertexGetOutEdge(Vertex, 0) != Edge) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        if (ToplVertexNumberOfInEdges(Vertex2) != 1) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        if (ToplVertexGetInEdge(Vertex2, 0) != Edge) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        ToplEdgeDisassociate(Edge);

        if (ToplVertexNumberOfOutEdges(Vertex) != 0) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }
    
        if (ToplVertexNumberOfInEdges(Vertex2) != 0) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        ToplVertexFree(Vertex);
        ToplVertexFree(Vertex2);
        ToplEdgeFree(Edge);
    

        //
        // Edges and vertices done, move on to graph
        //
        Graph = ToplGraphCreate();
        Vertex = ToplVertexCreate();
    
    
        if (ToplGraphNumberOfVertices(Graph) != 0) {
            Output(("ToplGraph api broken.\n"));
            return !0;
        }
    
        ToplGraphAddVertex(Graph, Vertex, Vertex);
    
        if (ToplGraphNumberOfVertices(Graph) != 1) {
            Output(("ToplGraph api broken.\n"));
            return !0;
        }
    
        Iter = ToplIterCreate();
    
        ToplGraphSetVertexIter(Graph, Iter);
    
        if (Vertex != ToplIterGetObject(Iter)) {
            Output(("ToplGraph api broken.\n"));
            return !0;
        }
    
        ToplIterFree(Iter);
    
        if (Vertex != ToplGraphRemoveVertex(Graph, NULL)) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }
    
        if (ToplGraphNumberOfVertices(Graph) != 0) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }
    
        //
        // Test single free
        //
        ToplGraphFree(Graph, FALSE);
        ToplVertexFree(Vertex);
    
        //
        // Test recursive free
        //
        Graph = ToplGraphCreate();
        Vertex = ToplVertexCreate();

        ToplGraphAddVertex(Graph, Vertex, Vertex);
        ToplGraphFree(Graph, TRUE);
    
        //
        // ToplFree and ToplGraphMakeRing are tested more effectively
        // elsewhere
        //
        ret = 0;

    }
    __except( ToplIsToplException((ErrorCode=GetExceptionCode())) )
    {
        fprintf(stderr, "Topl exception 0x%x occured\n", ErrorCode);
        ret = !0;

    }

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\exe\heaptest.c ===
/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "..\stheap.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


/********************************************************************************
 Heap Stress:

 Randomly attack stheap.c. We mimick a heap using RTL's AVL tree. This begs
 the question: Why did we write stheap in the first place -- we could have just
 used RTL?

 ********************************************************************************/

typedef struct {
    int     d, uniq;
    int     locn;
} Node;

static int NodeCmp( Node* a, Node* b, void* v ) {
    if( a->d<b->d ) return -1;
    if( a->d>b->d ) return 1;
    return a->uniq-b->uniq;
}
static int GetLocn( Node* a, void* v ) { return a->locn; }
static void SetLocn( Node* a, int l, void* v ) { a->locn=l; }

/***** TableCmp *****/
RTL_GENERIC_COMPARE_RESULTS
NTAPI TableCmp( RTL_GENERIC_TABLE *Table, PVOID a, PVOID b ) {
    int r = NodeCmp( (Node*) a, (Node*) b, NULL );
    if(r<0) return GenericLessThan;
    if(r>0) return GenericGreaterThan;
    return GenericEqual;
}

/***** TableAlloc *****/
PVOID
NTAPI TableAlloc( RTL_GENERIC_TABLE *Table, CLONG ByteSize ) {
    return malloc( ByteSize );
}

/***** TableFree *****/
VOID
NTAPI TableFree( RTL_GENERIC_TABLE *Table, PVOID Buffer ) {
    free( Buffer );
}

#define Rand(x) (((rand()<<16)|(rand()&0xFFFF))%x)
#define Error   { DebugBreak(); return -1; }

#define NOPRINT

/***** TestRandHeap *****/
int TestRandHeap( int size )
{
    RTL_GENERIC_TABLE table;
    PSTHEAP heap;
    Node *nodes, temp, *n, *n2;
    BOOLEAN newElement;
    int i, j, next, r, r2, r3, beta, nextAdd, nextRemove;

    /* Create a randomized permutation of {0,..,size-1} */
    nodes = (Node*) malloc( size*sizeof(Node) );
    for( i=0; i<size; i++) {
        nodes[i].d=i+1000000;
        nodes[i].uniq=i;
        nodes[i].locn=STHEAP_NOT_IN_HEAP;
    }
    for( i=0; i<size-1; i++ ) {
        j=i+Rand(size-i);
        memcpy(&temp,&nodes[i],sizeof(Node));
        memcpy(&nodes[i],&nodes[j],sizeof(Node));
        memcpy(&nodes[j],&temp,sizeof(Node));
    }
    heap = ToplSTHeapInit( size, NodeCmp, GetLocn, SetLocn, NULL );
    RtlInitializeGenericTable( &table, TableCmp, TableAlloc, TableFree, NULL );

    /* Try inserting an element, then removing an element with probability beta */
    for( beta=0; beta<500; beta+=50 ) {
        #ifndef NOPRINT
            printf("add/remove test: beta=%d\n",beta);
        #endif
        nextAdd=nextRemove=0;
        while( nextRemove<size ) {
            r=Rand(1000);
            if( (nextAdd==nextRemove||r>beta) && (nextAdd<size) ) {
                ToplSTHeapAdd( heap, &nodes[nextAdd] );
                RtlInsertElementGenericTable(&table,&nodes[nextAdd],sizeof(Node),&newElement);
                if(!newElement) {
                    printf("Err: element already in table\n");
                    Error;
                }
                #ifndef NOPRINT
                    printf("%4d add=%d\n",r,nodes[nextAdd].d);
                #endif
                nextAdd++;
            }
            else if( nextAdd==size || r<=beta ) {
                n=ToplSTHeapExtractMin(heap);
                n2=(Node*) RtlEnumerateGenericTable(&table,TRUE);
                if(n==NULL||n2==NULL) {
                    printf("Err: got null pointer\n");
                    Error;
                }
                if(n->locn!=STHEAP_NOT_IN_HEAP) {
                    printf("Err: location value not reset\n");
                    Error;
                }
                #ifndef NOPRINT
                    printf("%4d remove=%d %d\n",r,n->d,n2->d);
                #endif
                if(n->d!=n2->d) {
                    printf("Err: heap doesn't match AVL (beta=%d)\n", beta);
                    Error;
                }
                nextRemove++;
                RtlDeleteElementGenericTable( &table, n2 );
            }
        }
        if(ToplSTHeapExtractMin(heap)!=NULL) {
            printf("Err: heap not fully emptied\n");
            Error
        }
    }

    /* Try inserting an element, then decreasing the key with probability beta */
    for( beta=0; beta<500; beta+=50 ) {
        #ifndef NOPRINT
            printf("decrease key test: beta=%d\n",beta);
        #endif
        nextAdd=0;
        for(i=0;i<size;) {
            r=Rand(1000); 
            if( r>beta && nextAdd<size ) {
                ToplSTHeapAdd( heap, &nodes[nextAdd] );
                RtlInsertElementGenericTable(&table,&nodes[nextAdd],sizeof(Node),&newElement);
                if(!newElement) {
                    printf("Err: element already in table\n");
                    Error;
                }
                #ifndef NOPRINT
                    printf("%4d add=%d\n",r,nodes[nextAdd].d);
                #endif
                nextAdd++;
            } else {
                if( nextAdd>0 ) {
                    /* Decrease key */
                    r2=Rand(nextAdd);       /* How much to decrease key by */
                    r3=Rand(nextAdd);       /* Which key */
                    #ifndef NOPRINT
                        printf("%4d reduce key %d by %d\n",r,r3,r2);
                    #endif
                    if( RtlDeleteElementGenericTable(&table, &nodes[r3])==FALSE ) {
                        printf("Err: Couldn't delete from RTL\n");
                        Error;
                    }
                    nodes[r3].d-=r2;
                    RtlInsertElementGenericTable(&table,&nodes[r3],sizeof(Node),&newElement);
                    if(!newElement) {
                        printf("Err: element already in table\n");
                        Error;
                    }
                    ToplSTHeapCostReduced(heap,&nodes[r3]);
                }
            }
            if( nextAdd==size ) i++;
        }
        /* Remove elements */
        for(i=0;i<size;i++) {
            n=ToplSTHeapExtractMin(heap);
            n2=(Node*) RtlEnumerateGenericTable(&table,TRUE);
            if(n==NULL||n2==NULL) {
                printf("Err: got null pointer\n");
                Error;
            }
            if(n->locn!=STHEAP_NOT_IN_HEAP) {
                printf("Err: location value not reset\n");
                Error;
            }
            #ifndef NOPRINT
                printf("%4d remove=%d %d\n",r,n->d,n2->d);
            #endif
            if(n->d!=n2->d || n->uniq!=n2->uniq) {
                printf("Err: heap doesn't match AVL (beta=%d)\n", beta);
                Error;
            }
            RtlDeleteElementGenericTable( &table, n2 );
        }
        if(ToplSTHeapExtractMin(heap)!=NULL) {
            printf("Err: heap not fully emptied\n");
            Error
        }
    }

    ToplSTHeapDestroy( heap );
    free( nodes );
    return 0;
}

/***** TestNewHeap *****/
int TestNewHeap( void )
{
    unsigned seed;


    seed = (unsigned) time(NULL);
    srand(seed);
    printf("Starting heap stress... seed=%d\n",seed);

    __try {
        int  i, j;

        if(TestRandHeap(1)) return -1;
        for( i=3; i<=10; i++) {
            printf("Testing a heap with %d entries\n",i);
            for(j=0;j<40*i;j++) {
                if(TestRandHeap(i)) {
                    printf("Iteration %d failed\n",j);
                    return -1;
                }
            }
        }
        for( i=10; i<=200000; i=(int)(((float)i)*1.5) ) {
            printf("Testing a heap with %d entries\n",i);
            for(j=0;j<100;j++) {
                if(TestRandHeap(i)) {
                    printf("Iteration %d failed\n",j);
                    return -1;
                }
            }
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        printf("Caught unhandled exception\n");
        return -1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\exe\schedtest.c ===
/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <w32topl.h>
#include "w32toplp.h"
#include <stdio.h>
#include <stdlib.h>


/********************************************************************************
 Schedule Manager Tests:

 Test 1: Create and destroy a cache
 Test 2: Pass a NULL pointer to the destroy cache function
 Test 3: Insert one schedule into cache, retrieve it, and see if its the same
 Test 4: Insert two copies of same schedule, see if exported schedules are same
 Test 5: Insert two copies of same schedule, see if memory is shared
 Test 6: Pass null and caches, null and invalid schedules to ToplScheduleExportReadonly()
 Test 7: Pass unsupported schedules and invalid cache to ToplScheduleImport()
 Test 8: Load same schedule into cache 100000 times to ensure schedules are shared
 Test 9: Load 10000 different schedules into cache 10 times each, then check
         that the schedules are correct and the number of unique schedules is also correct
 Test 10: Use ToplScheduleIsEqual() function to ensure schedules are equal
 Test 11: Test ToplScheduleNumEntries
 Test 12: Test various invalid parameters to ToplScheduleIsEqual()
 Test 13: Test ToplScheduleDuration()  (with a manually created schedule)
 Test 14: ToplScheduleMerge() test -- typical schedules
 Test 15: ToplScheduleMerge() test -- non-intersecting schedules returns NULL
 Test 16: ToplScheduleMaxUnavailable() test
 
 ********************************************************************************/


/***** AcceptNullPointer *****/
LONG AcceptNullPointer( PEXCEPTION_POINTERS pep )
{
    EXCEPTION_RECORD *per=pep->ExceptionRecord;

    if( per->ExceptionCode==TOPL_EX_NULL_POINTER )
        return EXCEPTION_EXECUTE_HANDLER;
    return EXCEPTION_CONTINUE_SEARCH;
}


/***** AcceptCacheError *****/
LONG AcceptCacheError( PEXCEPTION_POINTERS pep )
{
    EXCEPTION_RECORD *per=pep->ExceptionRecord;

    if( per->ExceptionCode==TOPL_EX_CACHE_ERROR )
        return EXCEPTION_EXECUTE_HANDLER;
    return EXCEPTION_CONTINUE_SEARCH;
}


/***** AcceptScheduleError *****/
LONG AcceptScheduleError( PEXCEPTION_POINTERS pep )
{
    EXCEPTION_RECORD *per=pep->ExceptionRecord;

    if( per->ExceptionCode==TOPL_EX_SCHEDULE_ERROR )
        return EXCEPTION_EXECUTE_HANDLER;
    return EXCEPTION_CONTINUE_SEARCH;
}


/***** Error *****/
#define TEST_ERROR Error(__LINE__);
static void Error(int lineNum) {
    printf("Error on line %d\n",lineNum);
    DebugBreak();
    exit(-1);
}


/***** EqualPschedule *****/
char EqualPschedule( PSCHEDULE p1, PSCHEDULE p2 )
{
    if(0==memcmp(p1,p2,sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES))
        return 1;
    return 0;
}

#define NUM_UNIQ    10000
#define NUM_SCHED    100000
PSCHEDULE  uniqSched[NUM_UNIQ];
TOPL_SCHEDULE toplSched[NUM_SCHED];


/***** Test17 *****/
static void Test17( void ) {
    TOPL_SCHEDULE_CACHE cache;
    PSCHEDULE  psched1, psched2;
    unsigned char* dataPtr;
    int i,j,cbSched,numSched=0;

    // Repl Interval = 4 hours = 240 minutes
    char data1[] = {

         // (Hour 0) 15-minute segments.
         1, 0, 0, 0, 0,         // at beginning
         2, 0, 0, 0, 0,         // 15 minutes late 
         8, 0, 0, 0, 0,         // 45 minutes later
      0xF8, 0, 0, 0, 0,         // 45 minutes again, must ignore high bits

         // (Hour 20) 30-minute segments.
         3, 0, 0, 0, 0,         // at beginning
         6, 0, 0, 0, 0,         // 15 minutes later
         8, 1, 0, 0, 0,         // span bytes
         5, 0, 0, 0, 0,         // non-contiguous
         1, 0, 0, 8,0xE0,       // very non-contiguous
        
         // (Hour 45) 60-minute segments.
       0xF, 0, 0, 0, 0,         // simple, at beginning
         1, 2, 4, 8, 0,         // one every 75 minutes
         9, 3, 0, 0, 0,         // mind the gap
         8, 8, 8, 8, 0,         // crazy eights

         // (Hour 65) Full segments, empty space
        0xF,0xF,0xF,0xF,
        0xF,0xF,  0,  0,
        0xF,0xF,0xF,0xF,
        0xF,0xF,  0,  0,  0,
        0xF,0xF,0xF,0xF,
        0xF,0xF,  0,  0,  0,  0,
        0xF,0xF,0xF,0xF,
        0xF,0xF,  0,  0,  0,  0,  0,
        0xF,0xF,0xF,0xF,

        // (Hour 107) Not available
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0
    };

    // StaggeringNumber = 0
    char answer0[] = {
         // 15-minute segments.
         1, 0, 0, 0, 0,         
         2, 0, 0, 0, 0,        
         8, 0, 0, 0, 0,       
      0xF8, 0, 0, 0, 0,      

         // 30-minute segments.
         1, 0, 0, 0, 0,         
         2, 0, 0, 0, 0,        
         8, 0, 0, 0, 0,       
         1, 0, 0, 0, 0,      
         1, 0, 0, 0,0xE0,   
        
         // 60-minute segments.
       0x1, 0, 0, 0, 0,         // simple, at beginning
         1, 0, 0, 0, 0,         // one every 75 minutes
         1, 0, 0, 0, 0,         // mind the gap
         8, 0, 0, 0, 0,         // crazy eights

         // (Hour 65) Full segments, empty space
        0x1,0x0,0x0,0x0,
        0x1,0x0,  0,  0,
        0x1,0x0,0x0,0x0,
        0x1,0x0,  0,  0,  0,
        0x1,0x0,0x0,0x0,
        0x1,0x0,  0,  0,  0,  0,
        0x1,0x0,0x0,0x0,
        0x1,0x0,  0,  0,  0,  0,  0,
        0x1,0x0,0x0,0x0,

        // (Hour 107) Not available
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0
    };

    // StaggeringNumber = 7 = 1 mod 2 = 3 mod 4 = 7 mod 8 = 7 mod 16
    char answer7[] = {
         // 15-minute segments.
         1, 0, 0, 0, 0,
         2, 0, 0, 0, 0,
         8, 0, 0, 0, 0,
      0xF8, 0, 0, 0, 0,

         // 30-minute segments.
         2, 0, 0, 0, 0,         // at beginning
         4, 0, 0, 0, 0,         // 15 minutes later
         0, 1, 0, 0, 0,         // span bytes
         4, 0, 0, 0, 0,         // non-contiguous
         0, 0, 0, 8,0xE0,       // very non-contiguous

         // 60-minute segments.
         8, 0, 0, 0, 0,         // simple, at beginning
         0, 0, 0, 8, 0,         // one every 75 minutes
         0, 2, 0, 0, 0,         // mind the gap
         0, 0, 0, 8, 0,         // crazy eights

         // (Hour 65) Full segments, empty space
        0x0,0x8,0x0,0x0,
        0x0,0x8,  0,  0,
        0x0,0x8,0x0,0x0,
        0x0,0x8,  0,  0,  0,
        0x0,0x8,0x0,0x0,
        0x0,0x8,  0,  0,  0,  0,
        0x0,0x8,0x0,0x0,
        0x0,0x8,  0,  0,  0,  0,  0,
        0x0,0x8,0x0,0x0,

        // (Hour 107) Not available
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0
    };

    DWORD uLen;
    cache = ToplScheduleCacheCreate();

    // Set up test schedule
    dataPtr = ((unsigned char*) uniqSched[0]) + sizeof(SCHEDULE);
    memcpy( dataPtr, data1, sizeof(data1) ); 
    toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);

    // Set up correct answer 0
    dataPtr = ((unsigned char*) uniqSched[1]) + sizeof(SCHEDULE);
    memcpy( dataPtr, answer0, sizeof(answer0) ); 
    toplSched[1] = ToplScheduleImport(cache,uniqSched[1]);

    // Compare to computed answer
    toplSched[2] = ToplScheduleCreate(cache,240,toplSched[0],0);
    if( ! ToplScheduleIsEqual(cache,toplSched[1],toplSched[2]) ) {
        TEST_ERROR;
    }

    // Set up correct answer 7
    dataPtr = ((unsigned char*) uniqSched[1]) + sizeof(SCHEDULE);
    memcpy( dataPtr, answer7, sizeof(answer7) ); 
    toplSched[1] = ToplScheduleImport(cache,uniqSched[1]);

    // Compare to computed answer
    toplSched[2] = ToplScheduleCreate(cache,240,toplSched[0],7);
    if( ! ToplScheduleIsEqual(cache,toplSched[1],toplSched[2]) ) {
        TEST_ERROR;
    }

    ToplScheduleCacheDestroy( cache );
    printf("Test 17 passed\n");
}

/***** TestSched *****/
int
TestSched( VOID )
{
    TOPL_SCHEDULE_CACHE cache;
    PSCHEDULE  psched1, psched2;
    unsigned char* dataPtr;
    int i,j,cbSched,numSched=0;


    __try {

        /* Test 1 */
        cache = ToplScheduleCacheCreate();
        ToplScheduleCacheDestroy( cache );
        printf("Test 1 passed\n");

        /* Test 2 */
        __try {
            ToplScheduleCacheDestroy( NULL );
            return -1;
        } __except( AcceptNullPointer(GetExceptionInformation()) )
        {}
        __try {
            ToplScheduleCacheDestroy( cache );
            return -1;
        } __except( AcceptCacheError(GetExceptionInformation()) )
        {}
        printf("Test 2 passed\n");

        /* First create a whole pile of random, hopefully unique, schedules */
        cbSched = sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES;
        for(i=0;i<NUM_UNIQ;i++) {
            uniqSched[i] = (PSCHEDULE) malloc(cbSched);
            uniqSched[i]->Size = cbSched;
            uniqSched[i]->NumberOfSchedules = 1;
            uniqSched[i]->Schedules[0].Type = SCHEDULE_INTERVAL;
            uniqSched[i]->Schedules[0].Offset = sizeof(SCHEDULE);
            dataPtr = ((unsigned char*) uniqSched[i]) + sizeof(SCHEDULE);
            for(j=0;j<SCHEDULE_DATA_ENTRIES;j++)
                dataPtr[j] = rand()%16;
        }

        /* Test 3 */
        cache = ToplScheduleCacheCreate();
        toplSched[0] = ToplScheduleImport( cache, uniqSched[0] );
        psched1 = ToplScheduleExportReadonly( cache, toplSched[0] );
        if( ! EqualPschedule(uniqSched[0],psched1) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 3 passed\n");

        /* Test 4 */
        cache = ToplScheduleCacheCreate();
        toplSched[0] = ToplScheduleImport( cache, uniqSched[1] );
        toplSched[1] = ToplScheduleImport( cache, uniqSched[1] );
        psched1 = ToplScheduleExportReadonly( cache, toplSched[0] );
        psched2 = ToplScheduleExportReadonly( cache, toplSched[1] );
        if( ! EqualPschedule(psched1,psched2) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 4 passed\n");

        /* Test 5 */
        cache = ToplScheduleCacheCreate();
        toplSched[0] = ToplScheduleImport( cache, uniqSched[2] );
        toplSched[1] = ToplScheduleImport( cache, uniqSched[2] );
        if( toplSched[0] != toplSched[1] )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 5 passed\n");

        /* Test 6 */
        __try {
            ToplScheduleExportReadonly( NULL, toplSched[1] );
            return -1;
        } __except( AcceptNullPointer(GetExceptionInformation()) )
        {}
        cache = ToplScheduleCacheCreate();
        __try {
            ToplScheduleExportReadonly( cache, NULL );
        } __except( EXCEPTION_EXECUTE_HANDLER )
        {
            return -1;
        }
        __try {
            ToplScheduleExportReadonly( cache, cache );
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        ToplScheduleCacheDestroy( cache );
        printf("Test 6 passed\n");

        /* Test 7 */
        __try {
            ToplScheduleImport( cache, uniqSched[0] );
            return -1;
        } __except( AcceptCacheError(GetExceptionInformation()) )
        {}
        __try {
            ToplScheduleImport( NULL, uniqSched[0] );
            return -1;
        } __except( AcceptNullPointer(GetExceptionInformation()) )
        {}
        cache = ToplScheduleCacheCreate();
        uniqSched[0]->Size--;
        __try {
            ToplScheduleImport( cache, uniqSched[0] );
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        uniqSched[0]->Size = cbSched;
        uniqSched[0]->NumberOfSchedules = 2;
        __try {
            ToplScheduleImport( cache, uniqSched[0] );
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        uniqSched[0]->NumberOfSchedules = 1;
        uniqSched[0]->Schedules[0].Type = SCHEDULE_BANDWIDTH;
        __try {
            ToplScheduleImport( cache, uniqSched[0] );
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        uniqSched[0]->Schedules[0].Type = SCHEDULE_INTERVAL;
        uniqSched[0]->Schedules[0].Offset++;
        __try {
            ToplScheduleImport( cache, uniqSched[0] );
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        uniqSched[0]->Schedules[0].Offset--;
        if( 0 != ToplScheduleNumEntries(cache) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 7 passed\n");


        /* Test 8 */
        cache = ToplScheduleCacheCreate();
        for( i=0; i<NUM_SCHED; i++) {
            ToplScheduleImport(cache,uniqSched[3]);
        }
        if( 1 != ToplScheduleNumEntries(cache) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 8 passed\n");

        /* Test 9 */
        cache = ToplScheduleCacheCreate();
        numSched=0;
        for(j=0;j<10;j++) {
            for(i=0;i<NUM_UNIQ;i++) {
                toplSched[numSched++] = ToplScheduleImport( cache, uniqSched[i] );
            }
        }
        for(i=0;i<10*NUM_UNIQ;i++) {
            psched1 = ToplScheduleExportReadonly( cache, toplSched[i] );
            if( ! EqualPschedule(uniqSched[i%NUM_UNIQ],psched1) )
                return -1;
        }
        if( NUM_UNIQ != ToplScheduleNumEntries(cache) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 9 passed\n");

        /* Test 10 */
        cache = ToplScheduleCacheCreate();
        for(i=0;i<NUM_UNIQ;i++) {
            toplSched[0] = ToplScheduleImport(cache,uniqSched[i]);
            for(j=0;j<10;j++) {
                toplSched[1] = ToplScheduleImport( cache, uniqSched[i] );
                if( ! ToplScheduleIsEqual(cache,toplSched[0],toplSched[1]) )
                    return -1;
            }
        }
        ToplScheduleCacheDestroy( cache );
        printf("Test 10 passed\n");

        /* Test 11 */
        __try {
            ToplScheduleNumEntries(cache);
            return -1;
        } __except( AcceptCacheError(GetExceptionInformation()) )
        {}
        __try {
            ToplScheduleNumEntries(NULL);
            return -1;
        } __except( AcceptNullPointer(GetExceptionInformation()) )
        {}
        cache = ToplScheduleCacheCreate();
        if( 0 != ToplScheduleNumEntries(cache) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 11 passed\n");

        /* Test 12 */
        cache = ToplScheduleCacheCreate();
        __try {
            /* Stale schedules from previous cache */
            ToplScheduleIsEqual(cache,toplSched[0],toplSched[0]);
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);
        __try {
            /* Stale schedules from previous cache */
            ToplScheduleIsEqual(NULL,toplSched[0],toplSched[0]);
            return -1;
        } __except( AcceptNullPointer(GetExceptionInformation()) )
        {}
        if( ToplScheduleIsEqual(cache,NULL,NULL) != TRUE ) {
            return -1;
        }
        ToplScheduleCacheDestroy( cache );
        printf("Test 12 passed\n");

        /* Test 13 */
        {
            char data[] = { 0x08, 0x03, 0x04, 0x00, 0x01, 0x0F, 0x00,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F };
            /* Number of 15-minute chunks should be:
                               1 +   2 +   1  +  0 +   1 +   4 + 0
               + 1    +  1   + 2  + 1  +  2  +   2  +  3  + 1  + 2
               + 2    +  3   + 2  + 3   +  3  + 4  =  9+15+17 = 41
               So that should be 615 minutes */
            int dur1, dur2;
            cache = ToplScheduleCacheCreate();
            dataPtr = ((unsigned char*) uniqSched[0]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data, sizeof(data) ); 
            toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);
            dur1 = ToplScheduleDuration(toplSched[0]);
            dur2 = ToplScheduleDuration(NULL);
            if( dur1!=615 || dur2!=10080 )
                return -1;
            ToplScheduleCacheDestroy( cache );
        }
        printf("Test 13 passed\n");

        /* Test 14 */
        {
            char data1[] = {
                0xDF, 0xE1, 0xAE, 0xD2, 0xBD, 0xE3, 0xEC, 0xF4 };
            char data2[] = {
                0x0A, 0x16, 0x29, 0x37, 0x48, 0x58, 0x6B, 0x75 };
            char data3[] = {
                0xDA, 0xE0, 0xA8, 0xD2, 0xB8, 0xE0, 0xE8, 0xF4 };
            char fIsNever;
            cache = ToplScheduleCacheCreate();
            dataPtr = ((unsigned char*) uniqSched[0]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data1, sizeof(data1) ); 
            dataPtr = ((unsigned char*) uniqSched[1]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data2, sizeof(data2) ); 
            toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);
            toplSched[1] = ToplScheduleImport(cache,uniqSched[1]);
            toplSched[2] = ToplScheduleMerge(cache,toplSched[0],toplSched[1],&fIsNever);
            if(fIsNever)
                return -1;
            psched1 = ToplScheduleExportReadonly(cache,toplSched[2]);
            dataPtr = ((unsigned char*) psched1) + sizeof(SCHEDULE);
            if( 0!=memcmp(data3,dataPtr,sizeof(data3)) )
                return -1;
            ToplScheduleCacheDestroy( cache );
        }
        printf("Test 14 passed\n");

        /* Test 15 */
        {
            char data1[] = {
                0xDF, 0xE1, 0xAE, 0xD2, 0xBD, 0xE3, 0xEC, 0xF4 };
            char data2[] = {
                0x00, 0x1E, 0x20, 0x3C, 0x42, 0x50, 0x63, 0x7B };
            char fIsNever;
            cache = ToplScheduleCacheCreate();
            dataPtr = ((unsigned char*) uniqSched[0]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data1, sizeof(data1) ); 
            dataPtr = ((unsigned char*) uniqSched[1]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data2, sizeof(data2) ); 
            toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);
            toplSched[1] = ToplScheduleImport(cache,uniqSched[1]);
            toplSched[2] = ToplScheduleMerge(cache,toplSched[0],toplSched[1],&fIsNever);
            if( !fIsNever )
                return -1;
            if( NULL==toplSched[2] )
                return -1;
            if( 3 != ToplScheduleNumEntries(cache) )
                return -1;
            ToplScheduleCacheDestroy( cache );
        }
        printf("Test 15 passed\n");

        /* Test 16 */
        {
            char data1[] = {
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15 };
            char data2[] = {
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15, 0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15 };
            char data3[] = {
                 0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15, 0,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15, 0 };
            char data4[] = {
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15, 7,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15 };
            char data5[] = {
                01,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15, 9,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15, 7,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00 };
            char data6[] = {
                 8,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15, 9,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15, 7,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00 };
            char data7[] = {
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
            DWORD uLen;
            cache = ToplScheduleCacheCreate();

            // Schedule 0
            dataPtr = ((unsigned char*) uniqSched[0]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);
            uLen = ToplScheduleMaxUnavailable(toplSched[0]);
            if( 60*24*7!=uLen ) TEST_ERROR;

            // Schedule 1
            dataPtr = ((unsigned char*) uniqSched[1]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data1, sizeof(data1) ); 
            toplSched[1] = ToplScheduleImport(cache,uniqSched[1]);
            uLen = ToplScheduleMaxUnavailable(toplSched[1]);
            if( 0!=uLen ) TEST_ERROR;

            // Schedule 2
            dataPtr = ((unsigned char*) uniqSched[2]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data2, sizeof(data2) ); 
            toplSched[2] = ToplScheduleImport(cache,uniqSched[2]);
            uLen = ToplScheduleMaxUnavailable(toplSched[2]);
            if( 60!=uLen ) TEST_ERROR;

            // Schedule 3
            dataPtr = ((unsigned char*) uniqSched[3]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data3, sizeof(data3) ); 
            toplSched[3] = ToplScheduleImport(cache,uniqSched[3]);
            uLen = ToplScheduleMaxUnavailable(toplSched[3]);
            if(120!=uLen ) TEST_ERROR;

            // Schedule 4
            dataPtr = ((unsigned char*) uniqSched[4]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data4, sizeof(data4) ); 
            toplSched[4] = ToplScheduleImport(cache,uniqSched[4]);
            uLen = ToplScheduleMaxUnavailable(toplSched[4]);
            if( 15!=uLen ) TEST_ERROR;

            // Schedule 5
            dataPtr = ((unsigned char*) uniqSched[5]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data5, sizeof(data5) ); 
            toplSched[5] = ToplScheduleImport(cache,uniqSched[5]);
            uLen = ToplScheduleMaxUnavailable(toplSched[5]);
            if( 60!=uLen ) TEST_ERROR;

            // Schedule 6
            dataPtr = ((unsigned char*) uniqSched[6]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data6, sizeof(data6) ); 
            toplSched[6] = ToplScheduleImport(cache,uniqSched[6]);
            uLen = ToplScheduleMaxUnavailable(toplSched[6]);
            if(105!=uLen ) TEST_ERROR;

            // Schedule 7
            dataPtr = ((unsigned char*) uniqSched[7]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data7, sizeof(data7) ); 
            toplSched[7] = ToplScheduleImport(cache,uniqSched[7]);
            uLen = ToplScheduleMaxUnavailable(toplSched[7]);
            if(45!=uLen ) TEST_ERROR;

            ToplScheduleCacheDestroy( cache );
        }
        printf("Test 16 passed\n");

        Test17();

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        /* Failure! */
        printf("Caught unhandled exception\n");
        return -1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\exe\main.c ===
/*++              

Copyright (C) 1997 Microsoft Corporation

Module Name:

    main.c

Abstract:

    This file contains unit test for the w32topl dll
    
    This program will return 0 if success; !0 otherwise
    
Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>

typedef unsigned long DWORD;

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include <w32topl.h>

//
// Small utilities
//
BOOLEAN fVerbose = FALSE;

#define Output(x)          if (fVerbose) printf x;
#define NELEMENTS(x)        (sizeof(x)/sizeof(x[0]))

// defined in apitest.c
int     
TestAPI(VOID);

// defined in heaptest.c
int
TestNewHeap(VOID);
        
// defined in sttest.c
int
TestNewSpanTree(VOID);
        
// defined in schedtest.c
int
TestSched(VOID);
        
void    
PrintGraph(TOPL_GRAPH Graph);
        
void    
HandleToplException(DWORD ErrorCode)
//      
// This routine prints out what error occured within the w32topl dll
//
{

    switch (ErrorCode)
    {
        
        case TOPL_EX_OUT_OF_MEMORY:
            printf("w32topl: out of memory exception.\n");
            break;

        case TOPL_EX_WRONG_OBJECT:

            printf("w32topl: wrong object.\n");
            break;

        case TOPL_EX_INVALID_EDGE:

            printf("w32topl: an invalid edge was added to a vertex.\n");
            break;

        default:

            printf("w32topl unknown exception.\n");

    }
}

int
TestExceptions()
//
// The basic premise here is to set the return code to 0 just before
// the exception should occur.
//
{
    
    TOPL_EDGE   Edge;
    TOPL_VERTEX Vertex1, Vertex2;

    DWORD ErrorCode;
    int   ret;

    //
    // Test passing in a wrong object
    //
    __try
    {
        ret = 1;
        Edge = ToplEdgeCreate();

        ret = 0;
        ToplVertexSetId(Edge, 0);
        ret = 1;
    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        if (ErrorCode != TOPL_EX_WRONG_OBJECT) {
            HandleToplException(ErrorCode);
            ret = 1;
        }
    }
    ToplEdgeFree(Edge);

    if (ret) {
        return ret;
    }

    //
    // Test passing in a deleted object
    // 
    __try
    {
        ret = 1;

        Edge = ToplEdgeCreate();

        // Should be able to set a NULL vertex 
        ToplEdgeSetToVertex(Edge, 0);
        ToplEdgeSetFromVertex(Edge, 0);

        ToplEdgeFree(Edge);

        ret = 0;
    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        if (ErrorCode != TOPL_EX_WRONG_OBJECT) {
            HandleToplException(ErrorCode);
            ret = 1;
        }
    }

    if (ret) {
        return ret;
    }



    return ret;

}


#include "..\toplheap.h"

DWORD
Key( VOID *p )
{
    DWORD *pdw = (DWORD*) p;

    return *pdw;
}

int
TestHeap(
    VOID
    )
{

    TOPL_HEAP_INFO H;
    DWORD          dw[1000];
    DWORD          Last = 0;
    int            i, ret = 0;

    ToplHeapCreate( &H,
                    1000,
                    Key );

    srand( (unsigned)time( NULL ) );

    for ( i = 0; i < 1000; i++ )
    {
        dw[i] = (DWORD) (rand());

        ToplHeapInsert( &H, &dw[i] );
    }

    for ( i = 0; i < 1000; i++ )
    {
        DWORD *pdw;

        pdw = ToplHeapExtractMin( &H );
        printf( "%d ", *pdw );

        if ( i > 0 )
        {
            if ( Last > *pdw )
            {
                ret = !0;
            }
        }
        Last = *pdw;
    }

    printf( "\n" );

    return ret;

}


int
TestNxNMST(
    int Value
    )
{

    TOPL_GRAPH     Graph = NULL;
    TOPL_VERTEX   *VertexArray = NULL;
    TOPL_EDGE      Edge = NULL;
    TOPL_LIST      EdgesToAdd = NULL;
    TOPL_ITERATOR  EdgeIterator = NULL;
    TOPL_EDGE      *EdgesNeeded = NULL;
    ULONG          cEdgesNeeded = 0;
    DWORD          ErrorCode;

    TOPL_COMPONENTS *pComponents;
    
    ULONG         i, j;
    int           ret = 0;
    ULONG         NumberOfVertices = Value;

    srand( (unsigned)time( NULL ) );


    __try {
    __try {

        //
        // Make a graph
        //
        Graph         = ToplGraphCreate();

        //
        // Insert the vertices
        //
        VertexArray = (TOPL_VERTEX*)malloc(NumberOfVertices * sizeof(TOPL_VERTEX));
        if (!VertexArray) {
            Output(("Out of memory.\n"));
            ret = !0;
            __leave;
        }
        
        for (i = 0; i < NumberOfVertices; i++) {
            VertexArray[i] = ToplVertexCreate();
            ToplGraphAddVertex(Graph, VertexArray[i], VertexArray[i]);
        }

        //
        // Add the edges, to make an NxN graph
        //
        for (i = 0; i < NumberOfVertices; i++) {
            for (j = 0; j < NumberOfVertices; j++) {
                if (i != j) {

                    Edge = ToplEdgeCreate();

                    ToplEdgeSetWeight( Edge, rand() );
                    ToplEdgeSetFromVertex( Edge, VertexArray[i] );
                    ToplEdgeSetToVertex( Edge, VertexArray[j] );
                    ToplEdgeAssociate( Edge);
                }
            }
        }

        Output(("Here is the NxN graph ...\n"));
        PrintGraph(Graph);

        //
        // Now make a ring and remove the edges
        //
        pComponents = ToplGraphFindEdgesForMST(Graph,
                                 VertexArray[0],
                                 VertexArray[0],
                                 &EdgesNeeded,
                                 &cEdgesNeeded
                                 );
        ToplDeleteComponents( pComponents );


        Output(("Here is the ring graph ...\n"));
        PrintGraph(Graph);

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        ret = !0;
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);
    }

    return ret;
}

int
TestExampleMST(
    VOID
    )
{

    TOPL_GRAPH     Graph = NULL;
    TOPL_VERTEX    a=NULL, b=NULL, c=NULL, d=NULL, e=NULL, f=NULL, g=NULL, h=NULL, i=NULL;
    TOPL_EDGE      ab, ah, bh, bc, cd, cf, ci, de, df, ef, fg, gh, gi, hi;
    TOPL_EDGE      ba, ha, hb, cb, dc, fc, ic, ed, fd, fe, gf, hg, ig, ih;

    TOPL_ITERATOR  VertexIterator;
    TOPL_VERTEX    Vertex;


    TOPL_VERTEX    VertexArray[] = { a, b, c, d, e, f, g, h, i };


    TOPL_EDGE      *EdgesNeeded;
    ULONG          cEdgesNeeded;

    TOPL_COMPONENTS *pComponents;

    int            ret, index1, index2;

    DWORD          ErrorCode;

    __try {
    __try {

        //
        // Make a graph
        //
        Graph = ToplGraphCreate();

        //
        // Create and insert the vertices
        //
        a = ToplVertexCreate();
        b = ToplVertexCreate();
        c = ToplVertexCreate();
        d = ToplVertexCreate();
        e = ToplVertexCreate();
        f = ToplVertexCreate();
        g = ToplVertexCreate();
        h = ToplVertexCreate();
        i = ToplVertexCreate();

        ToplGraphAddVertex( Graph, a , a );
        ToplGraphAddVertex( Graph, b , b );
        ToplGraphAddVertex( Graph, c , c );
        ToplGraphAddVertex( Graph, d , d );
        ToplGraphAddVertex( Graph, e , e );
        ToplGraphAddVertex( Graph, f , f );
        ToplGraphAddVertex( Graph, g , g );
        ToplGraphAddVertex( Graph, h , h );
        ToplGraphAddVertex( Graph, i , i );

        VertexArray[0] = a;
        VertexArray[1] = b;
        VertexArray[2] = c;
        VertexArray[3] = d;
        VertexArray[4] = e;
        VertexArray[5] = f;
        VertexArray[6] = g;
        VertexArray[7] = h;
        VertexArray[8] = i;

        //
        // With no edges we should not find a spanning tree
        //
        pComponents = ToplGraphFindEdgesForMST(Graph,
                                               a,
                                               a,
                                               &EdgesNeeded,
                                               &cEdgesNeeded
                                              );

        if ( pComponents->numComponents != 9 )
        {
            //
            // ToplGraphFindEdgesForMST did not work correctly
            //
            return !0;

        }

        ToplDeleteComponents( pComponents );


        //
        // Create the edges
        //
        ab = ToplEdgeCreate(); ToplEdgeSetToVertex(ab, b); ToplEdgeSetFromVertex(ab, a);
        ah = ToplEdgeCreate(); ToplEdgeSetToVertex(ah, h); ToplEdgeSetFromVertex(ah, a);
        bh = ToplEdgeCreate(); ToplEdgeSetToVertex(bh, h); ToplEdgeSetFromVertex(bh, b);
        bc = ToplEdgeCreate(); ToplEdgeSetToVertex(bc, c); ToplEdgeSetFromVertex(bc, b);
        cd = ToplEdgeCreate(); ToplEdgeSetToVertex(cd, d); ToplEdgeSetFromVertex(cd, c);
        cf = ToplEdgeCreate(); ToplEdgeSetToVertex(cf, f); ToplEdgeSetFromVertex(cf, c);
        ci = ToplEdgeCreate(); ToplEdgeSetToVertex(ci, i); ToplEdgeSetFromVertex(ci, c);
        de = ToplEdgeCreate(); ToplEdgeSetToVertex(de, e); ToplEdgeSetFromVertex(de, d);
        df = ToplEdgeCreate(); ToplEdgeSetToVertex(df, f); ToplEdgeSetFromVertex(df, d);
        ef = ToplEdgeCreate(); ToplEdgeSetToVertex(ef, f); ToplEdgeSetFromVertex(ef, e);
        fg = ToplEdgeCreate(); ToplEdgeSetToVertex(fg, g); ToplEdgeSetFromVertex(fg, f);
        gh = ToplEdgeCreate(); ToplEdgeSetToVertex(gh, h); ToplEdgeSetFromVertex(gh, g);
        gi = ToplEdgeCreate(); ToplEdgeSetToVertex(gi, i); ToplEdgeSetFromVertex(gi, g);
        hi = ToplEdgeCreate(); ToplEdgeSetToVertex(hi, i); ToplEdgeSetFromVertex(hi, h);

        ba = ToplEdgeCreate(); ToplEdgeSetToVertex(ba, a); ToplEdgeSetFromVertex(ba, b);
        ha = ToplEdgeCreate(); ToplEdgeSetToVertex(ha, a); ToplEdgeSetFromVertex(ha, h);
        hb = ToplEdgeCreate(); ToplEdgeSetToVertex(hb, b); ToplEdgeSetFromVertex(hb, h);
        cb = ToplEdgeCreate(); ToplEdgeSetToVertex(cb, b); ToplEdgeSetFromVertex(cb, c);
        dc = ToplEdgeCreate(); ToplEdgeSetToVertex(dc, c); ToplEdgeSetFromVertex(dc, d);
        fc = ToplEdgeCreate(); ToplEdgeSetToVertex(fc, c); ToplEdgeSetFromVertex(fc, f);
        ic = ToplEdgeCreate(); ToplEdgeSetToVertex(ic, c); ToplEdgeSetFromVertex(ic, i);
        ed = ToplEdgeCreate(); ToplEdgeSetToVertex(ed, d); ToplEdgeSetFromVertex(ed, e);
        fd = ToplEdgeCreate(); ToplEdgeSetToVertex(fd, d); ToplEdgeSetFromVertex(fd, f);
        fe = ToplEdgeCreate(); ToplEdgeSetToVertex(fe, e); ToplEdgeSetFromVertex(fe, f);
        gf = ToplEdgeCreate(); ToplEdgeSetToVertex(gf, f); ToplEdgeSetFromVertex(gf, g);
        hg = ToplEdgeCreate(); ToplEdgeSetToVertex(hg, g); ToplEdgeSetFromVertex(hg, h);
        ig = ToplEdgeCreate(); ToplEdgeSetToVertex(ig, g); ToplEdgeSetFromVertex(ig, i);
        ih = ToplEdgeCreate(); ToplEdgeSetToVertex(ih, h); ToplEdgeSetFromVertex(ih, i);

        //
        // Set the weights
        //
        ToplEdgeSetWeight( ab, 4 );
        ToplEdgeSetWeight( ah, 9 );
        ToplEdgeSetWeight( bh, 11 );
        ToplEdgeSetWeight( bc, 8 );
        ToplEdgeSetWeight( cd, 7 );
        ToplEdgeSetWeight( cf, 4 );
        ToplEdgeSetWeight( ci, 2 );
        ToplEdgeSetWeight( de, 9 );
        ToplEdgeSetWeight( df, 14 );
        ToplEdgeSetWeight( ef, 10 );
        ToplEdgeSetWeight( fg, 2 );
        ToplEdgeSetWeight( gh, 1 );
        ToplEdgeSetWeight( gi, 6 );
        ToplEdgeSetWeight( hi, 7 );


        ToplEdgeSetWeight( ba, 4 );
        ToplEdgeSetWeight( ha, 9 );
        ToplEdgeSetWeight( hb, 11 );
        ToplEdgeSetWeight( cb, 8 );
        ToplEdgeSetWeight( dc, 7 );
        ToplEdgeSetWeight( fc, 4 );
        ToplEdgeSetWeight( ic, 2 );
        ToplEdgeSetWeight( ed, 9 );
        ToplEdgeSetWeight( fd, 14 );
        ToplEdgeSetWeight( fe, 10 );
        ToplEdgeSetWeight( gf, 2 );
        ToplEdgeSetWeight( hg, 1 );
        ToplEdgeSetWeight( ig, 6 );
        ToplEdgeSetWeight( ih, 7 );

        //
        // Associate the edges with thier vertices
        //
        ToplEdgeAssociate( ab );
        ToplEdgeAssociate( ah );
        ToplEdgeAssociate( bh );
        ToplEdgeAssociate( bc );
        ToplEdgeAssociate( cd );
        ToplEdgeAssociate( cf );
        ToplEdgeAssociate( ci );
        ToplEdgeAssociate( de );
        ToplEdgeAssociate( df );
        ToplEdgeAssociate( ef );
        ToplEdgeAssociate( fg );
        ToplEdgeAssociate( gh );
        ToplEdgeAssociate( gi );
        ToplEdgeAssociate( hi );


        ToplEdgeAssociate( ba );
        ToplEdgeAssociate( ha );
        ToplEdgeAssociate( hb );
        ToplEdgeAssociate( cb );
        ToplEdgeAssociate( dc );
        ToplEdgeAssociate( fc );
        ToplEdgeAssociate( ic );
        ToplEdgeAssociate( ed );
        ToplEdgeAssociate( fd );
        ToplEdgeAssociate( fe );
        ToplEdgeAssociate( gf );
        ToplEdgeAssociate( hg );
        ToplEdgeAssociate( ig );
        ToplEdgeAssociate( ih );


        //
        // Now find a minimum spanning tree!
        //
        for ( index1 = 0; index1 < NELEMENTS(VertexArray); index1++)
        {
            for ( index2 = 0; index2 < NELEMENTS(VertexArray); index2++)
            {

                printf("New iteration\n\n");

                pComponents = ToplGraphFindEdgesForMST( Graph,
                                                      VertexArray[index1],
                                                      VertexArray[index2],
                                                      &EdgesNeeded,
                                                      &cEdgesNeeded );
        
                if ( pComponents->numComponents == 1 )
                {
                    CHAR c1;
                    CHAR c2;

                    ToplDeleteComponents( pComponents );
                    ret = 0;

                    VertexIterator = ToplIterCreate();
                    for ( ToplGraphSetVertexIter(Graph, VertexIterator);
                            Vertex = (TOPL_VERTEX) ToplIterGetObject(VertexIterator);
                                ToplIterAdvance(VertexIterator) ) {

                       c1 = '\0';
                       c2 = '\0';
                
                       if ( Vertex == VertexArray[0] ) c1 =  'a';
                       if ( Vertex == VertexArray[1] ) c1 =  'b';
                       if ( Vertex == VertexArray[2] ) c1 =  'c';
                       if ( Vertex == VertexArray[3] ) c1 =  'd';
                       if ( Vertex == VertexArray[4] ) c1 =  'e';
                       if ( Vertex == VertexArray[5] ) c1 =  'f';
                       if ( Vertex == VertexArray[6] ) c1 =  'g';
                       if ( Vertex == VertexArray[7] ) c1 =  'h';
                       if ( Vertex == VertexArray[8] ) c1 =  'i';

                       Vertex = ToplVertexGetParent( Vertex );


                       if ( Vertex == VertexArray[0] ) c2 =  'a';
                       if ( Vertex == VertexArray[1] ) c2 =  'b';
                       if ( Vertex == VertexArray[2] ) c2 =  'c';
                       if ( Vertex == VertexArray[3] ) c2 =  'd';
                       if ( Vertex == VertexArray[4] ) c2 =  'e';
                       if ( Vertex == VertexArray[5] ) c2 =  'f';
                       if ( Vertex == VertexArray[6] ) c2 =  'g';
                       if ( Vertex == VertexArray[7] ) c2 =  'h';
                       if ( Vertex == VertexArray[8] ) c2 =  'i';


                       if ( c1 && c2 )
                       {
                           if ( c1 < c2)
                           {
                               printf( "(%c,%c) \n", c1, c2 );
                           }
                           else 
                           {
                               printf( "(%c,%c) \n", c2, c1 );
                           }
                       }
                
                    }
                    ToplIterFree( VertexIterator );

                }
                else 
                {
                    ret  = !0;
                    break;
                }
            }

            if ( ret )
            {
                 break;
            }
        }

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        ret = !0;
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);
    }

    return ret;
}

int
TestComponents(
    VOID
    )
{

    TOPL_GRAPH     Graph = NULL;
    TOPL_VERTEX    A, B, C, D, E, F, G, H, I;
    const DWORD       NUM_VTX=9;
    TOPL_VERTEX     **VertexArray;
    char            *MarkArray, *MarkArray2;
    DWORD           cVtxArray=0;

    //
    // Graph looks like this:
    // A--G--B  C--H  F--E
    //          |  |
    //          D--I
    //
    // Root Vtx: D
    // Vtx of Interest: E
    // 

    TOPL_EDGE      AG, GB, CH, HI, ID, DC, FE;
    TOPL_EDGE      GA, BG, HC, IH, DI, CD, EF;

    TOPL_ITERATOR  VertexIterator;
    TOPL_VERTEX    Vertex;

    TOPL_EDGE      *EdgesNeeded;
    ULONG          cEdgesNeeded;

    TOPL_COMPONENTS *pComponents;
    TOPL_COMPONENT  *pComponent;

    DWORD           i, j, k, ret;
    DWORD          ErrorCode;

    __try {
    __try {

        VertexArray = calloc( NUM_VTX, sizeof(TOPL_VERTEX*) );
        MarkArray = calloc( NUM_VTX, sizeof(char) );
        MarkArray2 = calloc( NUM_VTX, sizeof(char) );

        //
        // Make a graph
        //
        Graph = ToplGraphCreate();

        //
        // Create and insert the vertices
        //
        #define MAKE_VTX(v) \
            v=ToplVertexCreate(); \
            ToplGraphAddVertex(Graph,v,v); \
            VertexArray[cVtxArray++]=v;
        MAKE_VTX(A)
        MAKE_VTX(B)
        MAKE_VTX(C)
        MAKE_VTX(D)
        MAKE_VTX(E)
        MAKE_VTX(F)
        MAKE_VTX(G)
        MAKE_VTX(H)
        MAKE_VTX(I)

#ifdef DBG
        #define RETURN_ERROR  {ASSERT(0); return !0;}
#else
        #define RETURN_ERROR  {return !0;}
#endif

        //
        // With no edges we should not find a spanning tree
        //
        pComponents = ToplGraphFindEdgesForMST(Graph,
                                               A,
                                               A,
                                               &EdgesNeeded,
                                               &cEdgesNeeded
                                              );

        if ( pComponents->numComponents != 9 )
        {
            //
            // ToplGraphFindEdgesForMST did not work correctly
            //
            RETURN_ERROR
        }

        // Check the components; mark each vertex in the components structure
        memset(MarkArray,0,NUM_VTX);
        for(i=0;i<pComponents->numComponents;i++) {
            for(j=0;j<NUM_VTX;j++) {
                if(pComponents->pComponent[i].numVertices!=1) {
                    RETURN_ERROR
                }
                if(pComponents->pComponent[i].vertexNames[0]==VertexArray[j]) {
                    MarkArray[j]=1;
                    break;
                }
            }
        }
        // Check that all vertices were marked
        for(i=0;i<NUM_VTX;i++) if(!MarkArray[i]) RETURN_ERROR
        // Clear the marks
        memset(MarkArray,0,NUM_VTX);
        
        ToplDeleteComponents( pComponents );

        //
        // Create the edges
        //
        #define MAKE_EDGE_HELP(u,v) \
            u##v=ToplEdgeCreate(); \
            ToplEdgeSetToVertex(u##v,v); \
            ToplEdgeSetFromVertex(u##v,u); \
            ToplEdgeSetWeight(u##v,NUM_VTX); \
            ToplEdgeAssociate(u##v);
        #define MAKE_EDGE(u,v) \
            MAKE_EDGE_HELP(u,v) \
            MAKE_EDGE_HELP(v,u)

        MAKE_EDGE(A,G)
        MAKE_EDGE(G,B)
        MAKE_EDGE(C,H)
        MAKE_EDGE(H,I)
        MAKE_EDGE(I,D)
        MAKE_EDGE(D,C)
        MAKE_EDGE(F,E)

        pComponents = ToplGraphFindEdgesForMST( Graph,
                                                VertexArray[3],
                                                VertexArray[4],
                                                &EdgesNeeded,
                                                &cEdgesNeeded );
        
        if( pComponents->numComponents != 3 )
            RETURN_ERROR

        for(i=0;i<pComponents->numComponents;i++) {
           pComponent = &pComponents->pComponent[i];
           if(pComponent->numVertices==0) RETURN_ERROR
           if(   A==pComponent->vertexNames[0]
              || G==pComponent->vertexNames[0]
              || B==pComponent->vertexNames[0]
           ) {
                if(pComponent->numVertices!=3) RETURN_ERROR
                memset(MarkArray2,0,NUM_VTX);
                for(j=0;j<pComponent->numVertices;j++) for(k=0;k<NUM_VTX;k++)
                    if(pComponent->vertexNames[j]==VertexArray[k]) {
                        MarkArray[k]=1;
                        MarkArray2[k]=1;
                    }
                if(!MarkArray2[0]) RETURN_ERROR
                if(!MarkArray2[1]) RETURN_ERROR
                if(!MarkArray2[6]) RETURN_ERROR
           }
           if(   C==pComponent->vertexNames[0]
              || D==pComponent->vertexNames[0]
              || H==pComponent->vertexNames[0]
              || I==pComponent->vertexNames[0]
           ) {
                if(pComponent->numVertices!=4) RETURN_ERROR
                memset(MarkArray2,0,NUM_VTX);
                for(j=0;j<pComponent->numVertices;j++) for(k=0;k<NUM_VTX;k++)
                    if(pComponent->vertexNames[j]==VertexArray[k]) {
                        MarkArray[k]=1;
                        MarkArray2[k]=1;
                    }
                if(!MarkArray2[2]) RETURN_ERROR
                if(!MarkArray2[3]) RETURN_ERROR
                if(!MarkArray2[7]) RETURN_ERROR
                if(!MarkArray2[8]) RETURN_ERROR
           }
           if(   E==pComponent->vertexNames[0]
              || F==pComponent->vertexNames[0]
           ) {
                if(pComponent->numVertices!=2) RETURN_ERROR
                memset(MarkArray2,0,NUM_VTX);
                for(j=0;j<pComponent->numVertices;j++) for(k=0;k<NUM_VTX;k++)
                    if(pComponent->vertexNames[j]==VertexArray[k]) {
                        MarkArray[k]=1;
                        MarkArray2[k]=1;
                    }
                if(!MarkArray2[4]) RETURN_ERROR
                if(!MarkArray2[5]) RETURN_ERROR
           }
        }
        for(i=0;i<NUM_VTX;i++) if(!MarkArray[i]) RETURN_ERROR

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        RETURN_ERROR
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);
    }

    return 0;
}


int
TestNxNIntoRing(Value)
//
// Create an nxn graph and turn it into a ring
//
{


    TOPL_GRAPH     Graph = NULL;
    TOPL_VERTEX   *VertexArray = NULL;
    TOPL_EDGE      Edge = NULL;
    TOPL_LIST      EdgesToAdd = NULL;
    TOPL_ITERATOR  EdgeIterator = NULL;
    TOPL_EDGE      *EdgesToRemove = NULL;
    ULONG          cEdgesToRemove = 0;
    DWORD          ErrorCode;
    
    ULONG         i, j;
    int           ret = 0;
    ULONG         NumberOfVertices = Value;

    srand( (unsigned)time( NULL ) );


    __try {
    __try {

        //
        // Make a graph
        //
        Graph         = ToplGraphCreate();

        //
        // Insert the vertices
        //
        VertexArray = (TOPL_VERTEX*)malloc(NumberOfVertices * sizeof(TOPL_VERTEX));
        if (!VertexArray) {
            Output(("Out of memory.\n"));
            ret = !0;
            __leave;
        }

        for (i = 0; i < NumberOfVertices; i++) {
            VertexArray[i] = ToplVertexCreate();

            //
            // Really, we should verify that each rand() is unique for
            // for this graph, too.
            //
            ToplVertexSetId(VertexArray[i], rand());
            ToplGraphAddVertex(Graph, VertexArray[i], VertexArray[i]);
        }

        //
        // Add the edges, to make an NxN graph
        //
        for (i = 0; i < NumberOfVertices; i++) {
            for (j = 0; j < NumberOfVertices; j++) {
                if (i != j) {
                    Edge = ToplEdgeCreate();
                    ToplEdgeSetFromVertex(Edge, VertexArray[i]);
                    ToplEdgeSetToVertex(Edge, VertexArray[j]);
                    ToplEdgeAssociate(Edge);
                }
            }
        }

        Output(("Here is the NxN graph ...\n"));
        PrintGraph(Graph);

        //
        // Now make a ring and remove the edges
        //

        EdgesToAdd = ToplListCreate();

        ToplGraphMakeRing(Graph, 
                          TOPL_RING_TWO_WAY, 
                          EdgesToAdd, 
                          &EdgesToRemove, 
                          &cEdgesToRemove);

        //
        // Remove the edges
        //
        for (i = 0; i < cEdgesToRemove; i++) {
            ToplEdgeDisassociate(EdgesToRemove[i]);
        }
        if (EdgesToRemove) {
            ToplFree(EdgesToRemove);
        }

        //
        // There should be no edges to add
        //
        ASSERT(ToplListRemoveElem(EdgesToAdd, NULL) == NULL);
        ToplListFree(EdgesToAdd, FALSE);

        Output(("Here is the ring graph ...\n"));
        PrintGraph(Graph);

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        ret = !0;
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);
    }

    return ret;
}

int
TestRing(int Value)
//
//  This routine makes a one-way ring from a graph with no vertices
//  then a two-ring, then a one-way ring
// 
{

    TOPL_GRAPH     Graph = NULL;
    TOPL_VERTEX    Vertex;
    TOPL_EDGE      Edge = NULL;
    TOPL_LIST      EdgesToAdd = NULL;
    TOPL_ITERATOR  EdgeIterator = NULL;
    TOPL_EDGE      *EdgesToRemove = NULL;
    ULONG          cEdgesToRemove = 0;
    DWORD          ErrorCode;
    
    ULONG         i;
    int           ret = 0;
    ULONG         NumberOfVertices = Value;

    srand( (unsigned)time( NULL ) );


    __try {
    __try {


        //
        // Create the graph and vertices to into the graph
        //
        Graph         = ToplGraphCreate();

        for (i = 0; i < NumberOfVertices; i++) {
            Vertex = ToplVertexCreate();
            ToplVertexSetId(Vertex, rand());
            ToplGraphAddVertex(Graph, Vertex, Vertex);
        }

        //
        // Create the list to hold the edges to add
        //
        EdgesToAdd    = ToplListCreate();

        //
        // Make a one-way ring
        //
        ToplGraphMakeRing(Graph, TOPL_RING_ONE_WAY, EdgesToAdd, NULL, NULL);

        //
        // Add the edges to the graph so we can print it out
        //
        while (Edge = ToplListRemoveElem(EdgesToAdd, NULL)) {
            ToplEdgeAssociate(Edge);
        }
        ToplListFree(EdgesToAdd, FALSE);
        EdgesToAdd = NULL;


        Output(("First graph ...\n"));
        PrintGraph(Graph);

        //
        // Now find the edges to make the graph a two-way ring
        //
        EdgesToAdd = ToplListCreate();

        ToplGraphMakeRing(Graph, TOPL_RING_TWO_WAY, EdgesToAdd, NULL, NULL);

        while (Edge = ToplListRemoveElem(EdgesToAdd, NULL)) {
            ToplEdgeAssociate(Edge);
        }
        ToplListFree(EdgesToAdd, FALSE);
        EdgesToAdd = NULL;

        Output(("Second graph ...\n"));
        PrintGraph(Graph);

        //
        // Now make the graph a one way ring and remove the edges
        //
        EdgesToAdd = ToplListCreate();

        ToplGraphMakeRing(Graph, 
                          TOPL_RING_ONE_WAY, 
                          EdgesToAdd, 
                          &EdgesToRemove, 
                          &cEdgesToRemove);

        //
        // Remove the edges
        //
        for (i = 0; i < cEdgesToRemove; i++) {
            ToplEdgeDisassociate(EdgesToRemove[i]);
        }

        Output(("Third graph ...\n"));
        PrintGraph(Graph);

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        ret = !0;
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);

        if (EdgesToRemove) {
            ToplFree(EdgesToRemove);
        }

        if (EdgesToAdd) {
            ToplListFree(EdgesToAdd, FALSE);
        }

    }

    return ret;

}

int
CreateAndPrintSimpleGraph()
//
// This function creates a number of vertices and edges and then 
// prints them out. Tests base functionality.
//
{
    TOPL_GRAPH    Graph = NULL;

    #define NUMBER_OF_VERTICES 100
    TOPL_VERTEX   VertexArray[NUMBER_OF_VERTICES];
    TOPL_EDGE     EdgeArray[NUMBER_OF_VERTICES*2];
    DWORD         ErrorCode;

    ULONG         VertexCount, EdgeCount;
    int           ret = 0;

    memset(VertexArray, 0, sizeof(VertexArray));
    memset(EdgeArray, 0, sizeof(EdgeArray));

    __try {
    __try {

        Graph = ToplGraphCreate();
    
        for (VertexCount = 0; 
                VertexCount < NELEMENTS(VertexArray);
                    VertexCount++) {

            VertexArray[VertexCount] = ToplVertexCreate();
            ToplVertexSetId(VertexArray[VertexCount], VertexCount);

            ToplGraphAddVertex(Graph, VertexArray[VertexCount], VertexArray[VertexCount]);

        }


        for (EdgeCount = 0, VertexCount = 0; 
                EdgeCount < (NELEMENTS(EdgeArray) - 1);
                    EdgeCount += 2, VertexCount++) {

            ULONG ForwardVertexIndex, BackwardVertexIndex;

            EdgeArray[EdgeCount] = ToplEdgeCreate();
            EdgeArray[EdgeCount+1] = ToplEdgeCreate();

            ForwardVertexIndex = VertexCount + 1;
            BackwardVertexIndex = VertexCount - 1;
            if (VertexCount == 0) {
                BackwardVertexIndex =  NELEMENTS(VertexArray) - 1;
            }
            if (VertexCount == NELEMENTS(VertexArray) - 1) {
                ForwardVertexIndex =  0;
            } 

            ToplEdgeSetFromVertex(EdgeArray[EdgeCount], VertexArray[VertexCount]);
            ToplEdgeSetToVertex(EdgeArray[EdgeCount], VertexArray[BackwardVertexIndex]);
            ToplEdgeAssociate(EdgeArray[EdgeCount]);

            ToplEdgeSetFromVertex(EdgeArray[EdgeCount+1], VertexArray[VertexCount]);
            ToplEdgeSetToVertex(EdgeArray[EdgeCount+1], VertexArray[ForwardVertexIndex]);
            ToplEdgeAssociate(EdgeArray[EdgeCount+1]);

        }

        PrintGraph(Graph);

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        ret = !0;
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);
    }

    return ret;

}

void 
PrintGraph(TOPL_GRAPH Graph)
{
    DWORD ErrorCode;
    TOPL_ITERATOR VertexIter = NULL;
    TOPL_VERTEX   Vertex;
    TOPL_EDGE     Edge;
    ULONG         EdgeIndex;

    __try 
    {
    __try
    {

        VertexIter = ToplIterCreate();
    
        for (Vertex = NULL, ToplGraphSetVertexIter(Graph, VertexIter);
                (Vertex = ToplIterGetObject(VertexIter)) != NULL;
                    ToplIterAdvance(VertexIter)) {


            Output(("Vertex %d:\n", ToplVertexGetId(Vertex)));

            for (EdgeIndex = 0; 
                    EdgeIndex < ToplVertexNumberOfOutEdges(Vertex); 
                        EdgeIndex++) {

                Edge = ToplVertexGetOutEdge(Vertex, EdgeIndex);

                Output(("Edge (%d -> %d)\n", ToplVertexGetId((ToplEdgeGetFromVertex(Edge))),
                                            ToplVertexGetId((ToplEdgeGetToVertex(Edge)))));
            }
        }

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
    }
    }
    __finally 
    {
        if (VertexIter) {
            ToplIterFree(VertexIter);
        }
    }

}

void
Usage(char *name)
{
    fprintf(stderr, "Usage: %s <options>\n\n", name);
    fprintf(stderr, "This executable returns 0 on success; !0 otherwise\n\n");
    fprintf(stderr, "/?      : this message\n");
    fprintf(stderr, "/a      : tests the api set\n");
    fprintf(stderr, "/c:<n>  : complex ring test with n vertices\n");
    fprintf(stderr, "/e      : test exception handling\n");
    fprintf(stderr, "/m:<n> : minimum spanning tree test. (Try n>0 and n<0).\n");
    fprintf(stderr, "/o      : new heap test\n");
    fprintf(stderr, "/p      : new spanning tree algorithm test\n");
    fprintf(stderr, "/q      : schedule manager test\n");
    fprintf(stderr, "/r:<n>  : simple ring test with n vertices\n");
    fprintf(stderr, "/s      : simple manipulation test\n");
    fprintf(stderr, "/t      : old heap test\n");
    fprintf(stderr, "/u      : test components\n");
    fprintf(stderr, "/v      : sets the verbose mode for options set after\n");


    return;
}

int 
__cdecl main(int argc, char *argv[])
{
    int count, index;
    int ret;

    if ( argc < 2) {
        Usage(argv[0]);
        exit(!0);
    }

    //
    // Loop through parameters
    //

    count = 1; // skip the program name
    while (count < argc) {

        index = 0;
        if (argv[count][index] != '/' && argv[count][index] != '-') {
            Usage(argv[0]);
            exit(!0);
        }
        index++;

        argv[count][index] = (CHAR)tolower(argv[count][index]);

        switch (argv[count][index]) {

            case 'a':

                ret = TestAPI();
                if (ret) {
                    printf("API Test: FAILED\n");
                    exit(!0);
                } else {
                    printf("API Test: PASSED\n");
                }
                    
                count++;
                break;

            case 'e':

                ret = TestExceptions();
                if (ret) {
                    printf("Exception Test: FAILED\n");
                    exit(!0);
                } else {
                    printf("Exception Test: PASSED\n");
                }
                    
                count++;
                break;


            case 's':

                ret = CreateAndPrintSimpleGraph();
                if (ret) {
                    printf("Simple Test: FAILED\n");
                    exit(!0);
                } else {
                    printf("Simple Test: PASSED\n");
                }
                    
                count++;
                break;

            case 'r':

                {
                    int Value;
                    index++;
    
                    if (argv[count][index] == ':') {
                        index++;
                    }
    
                    Value = atoi(&(argv[count][index]));
                    if (Value < 0 ) {
                        printf("Number of vertices must be positive\n");
                    }

                    ret = TestRing(Value);
                    if (ret) {
                        printf("Simple Ring Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Simple Ring Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;


            case 'c':

                {
                    int Value;
                    index++;
    
                    if (argv[count][index] == ':') {
                        index++;
                    }
    
                    Value = atoi(&(argv[count][index]));
                    if (Value < 0 ) {
                        printf("Number of vertices must be positive\n");
                        exit(!0);
                    }

                    ret = TestNxNIntoRing(Value);
                    if (ret) {
                        printf("Complex Ring Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Complex Ring Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 'm':

                {
                    int Value;
                    index++;
    
                    if (argv[count][index] == ':') {
                        index++;
                    }
    
                    Value = atoi(&(argv[count][index]));

                    if ( Value < 0 )
                    {
                        ret = TestExampleMST();
                    }
                    else 
                    {
                        ret = TestNxNMST(Value);

                    }

                    if (ret) {
                        printf("Minimum Spanning Tree Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Minimum Spanning Tree Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 't':

                {
                    ret = TestHeap();

                    if (ret) {
                        printf("Heap Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Heap Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 'o':
                {
                    ret = TestNewHeap();

                    if (ret) {
                        printf("New Heap Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("New Heap Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 'p':
                {
                    ret = TestNewSpanTree();

                    if (ret) {
                        printf("New Spanning Tree Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("New Spanning Tree Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 'q':
                {
                    ret = TestSched();

                    if (ret) {
                        printf("Schedule Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Schedule Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;
            
            case 'u':
                {
                    ret = TestComponents();
                    if (ret) {
                        printf("Components Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Components Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 'v':

                fVerbose = TRUE;
                count++;
                break;

            default:

                Usage(argv[0]);
                exit(!0);
        }

    }

    printf("%s PASSED\n", argv[0]);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\idl\abprops.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       abprops.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines MAPI prop types in a format that may be used by .idl
    files.  It is expected to be included by nspi.idl and msds.idl only.

Author:

    Tim Williams (timwi) 1990-1995

Revision History:
    
    9-May-1996 Pulled thse definitions out of nspi.idl for use by nspi.idl and
    msds.idl.
    
--*/

#define MV_FLAG         ((ULONG) 0x1000)// Multi-value flag
#define PT_UNSPECIFIED  ((ULONG)  0)    // Type doesn't matter to caller
#define PT_NULL         ((ULONG)  1)    // NULL property value
#define PT_I2           ((ULONG)  2)    // Signed 16-bit value
#define PT_LONG         ((ULONG)  3)    // Signed 32-bit value
#define PT_R4           ((ULONG)  4)    // 4-byte floating point
#define PT_DOUBLE       ((ULONG)  5)    // Floating point double
#define PT_CURRENCY     ((ULONG)  6)    // Signed 64-bit int (decimal w/4 digits
                                        // right of decimal) 
#define PT_APPTIME      ((ULONG)  7)    // Application time
#define PT_ERROR        ((ULONG) 10)    // 32-bit error value
#define PT_BOOLEAN      ((ULONG) 11)    // 16-bit boolean (non-zero true)
#define PT_OBJECT       ((ULONG) 13)    // Embedded object in a property
#define PT_I8           ((ULONG) 20)    // 8-byte signed integer
#define PT_STRING8      ((ULONG) 30)    // Null terminated 8-bit char string 
#define PT_UNICODE      ((ULONG) 31)    // Null terminated Unicode string
#define PT_SYSTIME      ((ULONG) 64)    // FILETIME 64-bit int w/number of 100ns
                                        // periods since Jan 1,1601
#define PT_CLSID        ((ULONG) 72)    // OLE GUID
#define PT_BINARY       ((ULONG) 258)   // Uninterpreted (counted byte array)

#define PT_MV_I2        ((ULONG) 4098)
#define PT_MV_LONG      ((ULONG) 4099)
#define PT_MV_R4        ((ULONG) 4100)
#define PT_MV_DOUBLE    ((ULONG) 4101)
#define PT_MV_CURRENCY  ((ULONG) 4102)
#define PT_MV_APPTIME   ((ULONG) 4103)
#define PT_MV_SYSTIME   ((ULONG) 4160)
#define PT_MV_STRING8   ((ULONG) 4126)
#define PT_MV_BINARY    ((ULONG) 4354)
#define PT_MV_UNICODE   ((ULONG) 4127)
#define PT_MV_CLSID     ((ULONG) 4168)
#define PT_MV_I8        ((ULONG) 4116)

#define PROP_TYPE_MASK  ((ULONG)0x0000FFFF)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#

!include $(NTMAKEENV)\makefile.plt
!CMDSWITCHES +D

UNICODE=1

INCS = -I..\inc -I$(DS_INC_PATH) -I$(SDK_INC_PATH) -I$(CRT_INC_PATH)

NET_C_DEFINES= -DINCL_32= -DNT -DRPC_NO_WINDOWS_H
CPP = -cpp_cmd "$(MIDL_CPP)" -cpp_opt "-nologo -E $(MIDL_FLAGS) $(INCS) $(C_DEFINES) $(NET_C_DEFINES)"

DRS_DEPENDS = .\drs.idl .\drs.acf .\ntdsimp.idl ..\inc\ntdsimp.h \
              $(NTDS_INC)\ntdsa.h ..\inc\draasync.h $(SDK_INC_PATH)\ntdsapi.h \
              $(EXTRN_DEPENDS)

#
# MIDL COMPILE
#

# nt ntdsa client stub -- uses -robust, alternate client stub prefix since
# server stubs are in the same binary, and the async acf

$(O)\drs_w.c : drsasync.acf $(DRS_DEPENDS)
    midl -Oicf -robust -oldnames -error all -ms_ext -c_ext $(CPP) -prefix client "_"  -server none -header drs_w.h -out .\$(O) -cstub drs_w.c -acf drsasync.acf $(INCS) .\drs.idl

# nt ntdsapi client and ntdsa server stubs -- use -robust

$(O)\drs.h $(O)\drs_c.c $(O)\drs_s.c : $(DRS_DEPENDS)
    midl -Oicf -robust -oldnames -error all -ms_ext -c_ext $(CPP) -out .\$(O) $(INCS) drs.idl


$(O)\nspi.h $(O)\nspi_s.c : nspi.idl nspi.acf $(EXTRN_DEPENDS)
    midl -Oicf -robust -error ref -ms_ext -c_ext $(CPP) -client none -out .\$(O) $(INCS) nspi.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\allocaln.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       allocaln.h
//
//--------------------------------------------------------------------------


#ifndef _ALLOCALN_H
#define _ALLOCALN_H

// This macro front ends alloca so that the stack is still properly
// aligned after the allocation.

#ifdef WIN32
#define allocalign(x) alloca((x+3)&(~3))
#else
#define allocalign(x) alloca((x+1)&(~1))
#endif

//
// 64 bit padding
//

#define ALIGN64_ADDR(_addr)     (((DWORD_PTR)(_addr) + 7) & ~7)
#define IS_ALIGNED64(_addr)     (((DWORD_PTR)(_addr) & 7) == 0)
#define PAD64(_size)            ((_size) + sizeof(ULONGLONG))

#endif // _ALLOCALN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\common\w32topl\exe\sttest.c ===
/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "..\stheap.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


/********************************************************************************
 Spanning-Tree Tests:

 Test 1: Try creating/deleting topl graph state many times. Can manually check
         for memory leaks.
 Test 2: Try adding a bunch of edges to a graph state one with a NULL vertex
         name. 
 Test 3: Try adding a bunch of edges to a graph state one with an invalid
         vertex name.
 Test 4: Try adding a bunch of edges to a graph state, one with an invalid
         number of vertices.
 Test 5: Try adding a bunch of edges to a graph state, one with an invalid
         edge type.
 Test 6: Create a graph state with a bunch of good edges. Try adding multi-edge
         sets and adding them to the graph state.
 Test 7: Create a small valid topology and build a spanning tree. See if the
         output edges are what we expect.
 Test 8: Create a small valid topology which uses lots of hyper-edges and a
         multi-edge. See if the output edge is what we expect.
 Test 9: Create a graph with no white vertices, a very large number of colored
         vertices, and one large hyper-edge connecting them. No edge set is
         used, since only one edge exists.
 Test 10: Test a graph with many edge sets.
 Test 11: Large Hub-spoke performance and accuracy test
 Test 12: Cost overflow testing by using a long chain. Also tests performance
          of deep shortest-path trees in Dijkstra. 
 Test 13: Test edge types and vertices' ability to deny certain types of edges
 Test 14: A very simple test which checks schedules, options and replication intervals
 Test 15: Longest schedule duration wins
 Test 16: Longest schedule duration wins 2; Self-loop test
 Test 17: Non-intersecting schedules along shortest path throws exception
 Test 18: Check for site-failover (routing through sites which don't accept edges)

 Please contact nickhar for some hand-drawn diagrams of these tests.

 ********************************************************************************/

int Test7( void );
int Test8( void );
int Test9( void );
int Test10( void );
int Test11( DWORD );
int Test12( DWORD );
int Test13( VOID );
int Test14( VOID );
int Test15( VOID );
int Test16( VOID );
int Test17( VOID );
int Test18( VOID );

/***** AcceptOnlyFunc *****/
static LONG AcceptOnlyFunc( PEXCEPTION_POINTERS pep, int code )
{
    EXCEPTION_RECORD *per=pep->ExceptionRecord;

    if( per->ExceptionCode==code )
        return EXCEPTION_EXECUTE_HANDLER;
    return EXCEPTION_CONTINUE_SEARCH;
}

#define AcceptOnly(x)       AcceptOnlyFunc(GetExceptionInformation(),x)

int __cdecl VtxNameCmpFunc( const VOID *aa, const VOID *bb )
{
    DWORD *a=*((DWORD**)aa), *b=*((DWORD**)bb);
    return *a-*b;
}

void Error() {
#ifdef DBG
    DebugBreak();
#endif
}

#define NUM_VTX     10000
#define NUM_EDGE    10000
#define NUM_EDGE_SET  100

/***** TestNewSpanTree *****/
int TestNewSpanTree( void )
{
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges;
    PTOPL_MULTI_EDGE_SET    *edgeSets;
    TOPL_REPL_INFO          ri;
    DWORD                   i, j, **names, dummy;

    printf("Starting spanning tree tests...\n");

    __try {
    
    names = (DWORD**) malloc( NUM_VTX * sizeof(DWORD*) );
    for( i=0; i<NUM_VTX; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }

    edges = (PTOPL_MULTI_EDGE*) malloc( NUM_EDGE * sizeof(PTOPL_MULTI_EDGE) );
    ri.cost = 100;
    ri.repIntvl = 30;
    ri.options = 0;
    ri.schedule = NULL;

    /* Test 1 */
    cache = ToplScheduleCacheCreate();
    for( i=0; i<100; i++ ) {
        g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
        ToplDeleteGraphState( g );
    }
    ToplScheduleCacheDestroy( cache );
    printf("Test 1 Passed\n");

    /* Test 2 */
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
    for( j=0; j<NUM_EDGE-1; j++ ) {
        edges[j] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[j], 0, names[j%NUM_VTX] );
        ToplEdgeSetVtx( g, edges[j], 1, names[(j+1)%NUM_VTX] );
    }
    __try {
        ToplEdgeSetVtx( g, edges[NUM_EDGE-1], 0, NULL );
        return -1;
    } __except( AcceptOnly(TOPL_EX_NULL_POINTER) )
    {}
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 2 Passed\n");

    /* Test 3 */
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
    for( j=0; j<NUM_EDGE; j++ ) {
        edges[j] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[j], 0, names[j%NUM_VTX] );
        ToplEdgeSetVtx( g, edges[j], 1, names[(j+1)%NUM_VTX] );
    }
    __try {
        ToplEdgeSetVtx( g, edges[NUM_EDGE-1], 1, &dummy );
        return -1;
    } __except( AcceptOnly(TOPL_EX_INVALID_VERTEX) )
    {}
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 3 Passed\n");

    /* Test 4 */
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
    for( j=0; j<NUM_EDGE-1; j++ ) {
        edges[j] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[j], 0, names[j%NUM_VTX] );
        ToplEdgeSetVtx( g, edges[j], 1, names[(j+1)%NUM_VTX] );
    }
    __try {
        edges[NUM_EDGE-1] = ToplAddEdgeToGraph( g, 0, 0, &ri );
        return -1;
    } __except( AcceptOnly(TOPL_EX_TOO_FEW_VTX) )
    {}
    __try {
        edges[NUM_EDGE-1] = ToplAddEdgeToGraph( g, 1, 0, &ri );
        return -1;
    } __except( AcceptOnly(TOPL_EX_TOO_FEW_VTX) )
    {}
    edges[NUM_EDGE-1] = ToplAddEdgeToGraph( g, 2, 0, &ri );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 4 Passed\n");

    /* Test 5 */
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
    for( j=0; j<NUM_EDGE-1; j++ ) {
        edges[j] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[j], 0, names[j%NUM_VTX] );
        ToplEdgeSetVtx( g, edges[j], 1, names[(j+1)%NUM_VTX] );
    }
    __try {
        edges[NUM_EDGE-1] = ToplAddEdgeToGraph( g, 2, 32, &ri );
        return -1;
    } __except( AcceptOnly(TOPL_EX_INVALID_EDGE_TYPE) )
    {}
    edges[NUM_EDGE-1] = ToplAddEdgeToGraph( g, 2, 31, &ri );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 5 Passed\n");

    /* Test 6 */
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
    for( j=0; j<NUM_EDGE; j++ ) {
        edges[j] = ToplAddEdgeToGraph( g, 2, 31, &ri );
        ToplEdgeSetVtx( g, edges[j], 0, names[j%NUM_VTX] );
        ToplEdgeSetVtx( g, edges[j], 1, names[(j+1)%NUM_VTX] );
    }
    edgeSets = (PTOPL_MULTI_EDGE_SET*) malloc( NUM_EDGE_SET*sizeof(PTOPL_MULTI_EDGE_SET));
    for(i=0;i<NUM_EDGE_SET;i++) {
        DWORD cnt;
        edgeSets[i] = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
        edgeSets[i]->numMultiEdges = cnt = (rand()%(NUM_EDGE/100)) + 2;
        edgeSets[i]->multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cnt*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cnt;j++) {
            edgeSets[i]->multiEdgeList[j] = edges[(j*cnt)%NUM_EDGE];
        }
        ToplAddEdgeSetToGraph( g, edgeSets[i] );
    }
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    for(i=0;i<NUM_EDGE_SET;i++)
        free( edgeSets[i] );
    free( edgeSets );
    printf("Test 6 Passed\n");


    if( Test7() ) return -1;
    if( Test8() ) return -1;
    if( Test9() ) return -1;
    if( Test10() ) return -1;
    if( Test11(100000) ) return -1;
    if( Test12(100000) ) return -1;
    if( Test13() ) return -1;
    if( Test14() ) return -1;
    if( Test15() ) return -1;
    if( Test16() ) return -1;
    if( Test17() ) return -1;
    if( Test18() ) return -1;

    printf("Now on to performance tests...\n");
    for(;;) {
        int size;
        printf("Enter size: ");
        scanf("%d",&size);
        if(size==0) break;
        if( Test11(size) ) return -1;
    }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        printf("Caught unhandled exception\n");
        return -1;
    }

    return 0;
}


/***** VtxNameStructCmpFunc *****/
int __cdecl VtxNameStructCmpFunc( const VOID *aa, const VOID *bb )
{
    TOPL_NAME_STRUCT *a=(TOPL_NAME_STRUCT*)aa, *b=(TOPL_NAME_STRUCT*)bb;
    return VtxNameCmpFunc( &a->name, &b->name );
}

/***** EdgeExists *****/
char EdgeExists( PTOPL_MULTI_EDGE e, PTOPL_MULTI_EDGE *edgeList,
    DWORD cEdge, TOPL_SCHEDULE_CACHE cache )
{
    DWORD iEdge,iVtx;

    if( !e->fDirectedEdge ) {
        qsort( &e->vertexNames[0], e->numVertices, sizeof(TOPL_NAME_STRUCT), VtxNameStructCmpFunc );
    }
    for( iEdge=0; iEdge<cEdge; iEdge++ ) {
        NextEdge:;
        if(edgeList[iEdge]->fDirectedEdge!=e->fDirectedEdge) continue;
        if(edgeList[iEdge]->numVertices!=e->numVertices) continue;
        if(edgeList[iEdge]->edgeType!=e->edgeType) continue;
        if(edgeList[iEdge]->ri.cost!=e->ri.cost) continue;
        if(edgeList[iEdge]->ri.repIntvl!=e->ri.repIntvl) continue;
        if(edgeList[iEdge]->ri.options!=e->ri.options) continue;
        if(!ToplScheduleIsEqual(cache,edgeList[iEdge]->ri.schedule,e->ri.schedule))
            continue;
        /* Match vertex names */
        if( !edgeList[iEdge]->fDirectedEdge ) {
            qsort( &edgeList[iEdge]->vertexNames[0], edgeList[iEdge]->numVertices,
                sizeof(TOPL_NAME_STRUCT), VtxNameStructCmpFunc );
        }
        for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
            if( VtxNameStructCmpFunc(
                    &e->vertexNames[iVtx],
                    &(edgeList[iEdge]->vertexNames[iVtx])
                ) != 0 )
            {
                goto NextEdge;
            }
        }
        return 1;
    }
    return 0;
}


/***** FixEdges *****/
int __cdecl EdgeCmp( const void *aa, const void *bb ) {
    PTOPL_MULTI_EDGE a=*((PTOPL_MULTI_EDGE*)aa);
    PTOPL_MULTI_EDGE b=*((PTOPL_MULTI_EDGE*)bb);
    DWORD i; int r;
    if( a->numVertices != b->numVertices )
        return ((int) a->numVertices) - ((int) b->numVertices);
    for(i=0;i<a->numVertices;i++) {
        r = VtxNameStructCmpFunc( &a->vertexNames[i], &b->vertexNames[i] );
        if(r!=0) return r;
    }
    return 0;
}
void FixEdges( PTOPL_MULTI_EDGE *edgeList, DWORD cEdge )
{
    DWORD iEdge;
    for( iEdge=0; iEdge<cEdge; iEdge++ ) {
        if( ! edgeList[iEdge]->fDirectedEdge ) {
            qsort( &edgeList[iEdge]->vertexNames[0], edgeList[iEdge]->numVertices,
                sizeof(TOPL_NAME_STRUCT), VtxNameStructCmpFunc );
        }
    }
    qsort( edgeList, cEdge, sizeof(PTOPL_MULTI_EDGE), EdgeCmp );
}


/***** EdgeExists2 *****/
char EdgeExists2( PTOPL_MULTI_EDGE e, PTOPL_MULTI_EDGE *edgeList,
    DWORD cEdge, TOPL_SCHEDULE_CACHE cache )
{
    PTOPL_MULTI_EDGE *foundE;
    DWORD iEdge,iVtx;

    if( ! e->fDirectedEdge ) {
        qsort( e->vertexNames, e->numVertices, sizeof(TOPL_NAME_STRUCT), VtxNameStructCmpFunc );
    }

    foundE = bsearch( &e, edgeList, cEdge, sizeof(PTOPL_MULTI_EDGE), EdgeCmp );
    if( foundE==NULL )
        return 0;

    if(foundE[0]->fDirectedEdge!=e->fDirectedEdge) return 0;
    if(foundE[0]->edgeType!=e->edgeType) return 0;
    if(foundE[0]->ri.cost!=e->ri.cost) return 0;
    if(foundE[0]->ri.repIntvl!=e->ri.repIntvl) return 0;
    if(foundE[0]->ri.options!=e->ri.options) return 0;
    if(!ToplScheduleIsEqual(cache,foundE[0]->ri.schedule,e->ri.schedule))
        return 0;

    return 1;
}


/***** Test7 *****/
int Test7( void ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    PTOPL_MULTI_EDGE_SET    edgeSet;
    DWORD                   i, j, **names, numVtx, numEdge;
    TOPL_COLOR_VERTEX       colorVtx[3];
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    DWORD                   numStEdges;
    TOPL_COMPONENTS         compInfo;

                            /* ID      0  1  2  3  4  5  6   7   8   9  10  11  12  13  14 */
    const DWORD             Vtx1[] = { 0, 0, 1, 2, 1, 1, 3,  4,  5,  6,  7,  8,  9,  4,  5 };
    const DWORD             Vtx2[] = { 2, 1, 2, 3, 3, 4, 4,  5,  6,  7,  8,  9, 10, 10, 10 };
    const DWORD             Cost[] = { 3, 4, 2, 6, 5,17, 6, 10, 14,  5,  2,  9, 28,200, 40 };

    numVtx = 11;
    numEdge = 15;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    ri.repIntvl = 30;
    ri.options = 0;
    ri.schedule = NULL;
    for( i=0; i<numEdge; i++ ) {
        ri.cost = Cost[i];
        edges[i] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
    edgeSet->numMultiEdges = numEdge;
    edgeSet->multiEdgeList =
        (PTOPL_MULTI_EDGE*) malloc( numEdge*sizeof(PTOPL_MULTI_EDGE) );
    for(j=0;j<numEdge;j++) {
        edgeSet->multiEdgeList[j] = edges[j];
    }
    ToplAddEdgeSetToGraph( g, edgeSet );

    /* Make color vertices */
    colorVtx[0].name = names[0];
    colorVtx[0].color = COLOR_RED;
    colorVtx[0].acceptRedRed = colorVtx[0].acceptBlack = 0xFFFFFFFF;
    colorVtx[1].name = names[6];
    colorVtx[1].color = COLOR_BLACK;
    colorVtx[1].acceptRedRed = colorVtx[1].acceptBlack = 0xFFFFFFFF;
    colorVtx[2].name = names[8];
    colorVtx[2].color = COLOR_RED;
    colorVtx[2].acceptRedRed = colorVtx[2].acceptBlack = 0xFFFFFFFF;

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, 3, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=2 || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    outEdge->vertexNames[0].name = names[0];
    outEdge->vertexNames[1].name = names[8];
    outEdge->edgeType = 0;
    outEdge->ri.cost = 46;
    outEdge->ri.repIntvl = 30;
    outEdge->ri.options = 0;
    outEdge->ri.schedule = NULL;
    outEdge->fDirectedEdge = FALSE;
    if(! EdgeExists(outEdge, stEdgeList, numStEdges, cache) ) {
        Error();
        return -1;
    }
    outEdge->vertexNames[0].name = names[8];
    outEdge->vertexNames[1].name = names[6];
    outEdge->ri.cost = 7;
    outEdge->fDirectedEdge = TRUE;
    if(! EdgeExists(outEdge, stEdgeList, numStEdges, cache) ) {
        Error();
        return -1;
    }

    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 7 (Simple) Passed\n");

    return 0;
}


/***** Test8 *****/
/* Test a graph with many hyper-edges and a couple multi-edges */
int Test8( void ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    PTOPL_MULTI_EDGE_SET    edgeSet;
    DWORD                   i, j, **names, numVtx, numEdge;
    TOPL_COLOR_VERTEX       colorVtx[2];
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;

    const DWORD 
    
    /* ID      0  1  2  3  4  5  6   7   8   9  10 */
    Vtx1[] = {18, 0, 0, 2, 4, 8, 8,  9, 10, 11,  4 },
    Vtx2[] = {14, 1, 3, 4, 8,15,12, 10, 12, 13,  8 },
    Vtx3[] = {-1, 2, 6, 5,-1,16,13, 11, 13, 14, -1 },
    Vtx4[] = {-1, 3, 7,-1,-1,17,15, -1, -1, -1, -1 },
    Vtx5[] = {-1,-1,-1,-1,-1,18,-1, -1, -1, -1, -1 },
    NumVtx[]={ 2, 4, 4, 3, 2, 5, 4,  3,  3,  3,  2 },
    Cost[] = {50, 6,10, 3, 8, 1,50,  1,  1,  1,  7 };

    numVtx = 19;
    numEdge = 11;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    ri.repIntvl = 30;
    ri.options = 0;
    ri.schedule = NULL;
    for( i=0; i<numEdge; i++ ) {
        ri.cost = Cost[i];
        edges[i] = ToplAddEdgeToGraph( g, NumVtx[i], 0, &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
        switch( NumVtx[i] ) {
            case 5: ToplEdgeSetVtx( g, edges[i], 4, names[Vtx5[i]] );
            case 4: ToplEdgeSetVtx( g, edges[i], 3, names[Vtx4[i]] );
            case 3: ToplEdgeSetVtx( g, edges[i], 2, names[Vtx3[i]] );
        }
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
    edgeSet->numMultiEdges = numEdge;
    edgeSet->multiEdgeList =
        (PTOPL_MULTI_EDGE*) malloc( numEdge*sizeof(PTOPL_MULTI_EDGE) );
    for(j=0;j<numEdge;j++) {
        edgeSet->multiEdgeList[j] = edges[j];
    }
    ToplAddEdgeSetToGraph( g, edgeSet );

    /* Make color vertices */
    colorVtx[0].name = names[0];
    colorVtx[0].color = COLOR_RED;
    colorVtx[0].acceptRedRed = colorVtx[0].acceptBlack = 0xFFFFFFFF;
    colorVtx[1].name = names[9];
    colorVtx[1].color = COLOR_BLACK;
    colorVtx[1].acceptRedRed = colorVtx[1].acceptBlack = 0xFFFFFFFF;

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, 2, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=1 || compInfo.numComponents!=1 )
        return -1;
    outEdge->vertexNames[0].name = names[0];
    outEdge->vertexNames[1].name = names[9];
    outEdge->edgeType = 0;
    outEdge->ri.cost = 68;
    outEdge->ri.repIntvl = 30;
    outEdge->ri.options = 0;
    outEdge->ri.schedule = NULL;
    outEdge->fDirectedEdge = TRUE;
    if(! EdgeExists(outEdge, stEdgeList, numStEdges, cache) )
        return -1;

    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 8 (Many Hyper-Edges) Passed\n");

    return 0;
}


/***** Test9 *****/
/* Test a graph with no white vertices, a large number of colored vertices,
 * and one large hyper-edge connecting them. */
int Test9( void ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges;
    DWORD                   i, j, **names, numVtx, numEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;
    char                    *inTree;

    numVtx = 10000;
    numEdge = 1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    ri.cost = 625;
    ri.repIntvl = 30;
    ri.options = 0;
    ri.schedule = NULL;
    edges[0] = ToplAddEdgeToGraph( g, numVtx, 17, &ri );
    for(i=0;i<numVtx;i++)
        ToplEdgeSetVtx( g, edges[0], i, names[i] );

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numVtx * sizeof(TOPL_COLOR_VERTEX) );
    for(i=0;i<numVtx;i++) {
        colorVtx[i].name = names[i];
        colorVtx[i].color = COLOR_BLACK;
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numVtx-1 || compInfo.numComponents!=1 )
        return -1;
    inTree = (char*) malloc( numVtx );
    for( i=0; i<numVtx; i++ )
        inTree[i]=0;
    for( i=0; i<numStEdges; i++ ) {
        if( stEdgeList[i]->numVertices!=2 )
            return -1;
        if( stEdgeList[i]->edgeType!=17 )
            return -1;
        if( stEdgeList[i]->ri.cost!=625 )
            return -1;
        if( stEdgeList[i]->fDirectedEdge )
            return -1;
        if( *((DWORD*) stEdgeList[i]->vertexNames[0].name) >= numVtx )
            return -1;
        inTree[ *((DWORD*) stEdgeList[i]->vertexNames[0].name) ] = 1;
        inTree[ *((DWORD*) stEdgeList[i]->vertexNames[1].name) ] = 1;
    }
    for( i=0; i<numVtx; i++ )
        if( inTree[i]==0 )
            return -1;
    
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 9 (Large Hyper-Edge) Passed\n");

    return 0;
}


/***** Test10 *****/
/* Test a graph with many edge-sets */
int Test10( void ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    PTOPL_MULTI_EDGE_SET    edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3  4  5  6   7   8   9  10  11  12  13  14  15  */
    Vtx1[] = { 2, 0, 2, 5, 3, 0, 1,  3,  6,  1,  5,  2,  2,  6,  9,  8 },
    Vtx2[] = { 9, 1, 3, 6, 5, 6, 5,  4,  8,  6,  9,  8,  5, 10, 10, 10 },
    Vtx3[] = {-1, 2, 4,-1,-1,-1,-1,  7, -1,  5, -1, -1, -1, -1, 11, -1 },
    Vtx4[] = {-1,-1,-1,-1,-1,-1,-1,  8, -1, -1, -1, -1, -1, -1, -1, -1 },
    NumVtx[]={ 2, 3, 3, 2, 2, 2, 2,  4,  2,  3,  2,  2,  2,  2,  3,  2 },
    Cost[] = { 1, 1, 1, 1, 1, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1 };

    const DWORD EdgeSet[][10] = { { 3, 1, 3, 8 },
                                  { 3, 2, 5, 4 },
                                  { 6, 7, 8, 9, 10, 11, 12 },
                                  { 4, 1, 6, 3, 13 } };

    const DWORD ColorVtx[] = { 0, 4, 9, 10 };

    const DWORD OutputEdge[][3] = { { 9, 10, 1 },
                                   { 4, 9, 4 },
                                   { 0, 10, 4 } };

    numVtx = 12;
    numEdge = 16;
    numEdgeSet = 4;
    numColorVtx = 4;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        ri.cost = Cost[i];
        ri.repIntvl = 30;
        ri.options = 0;
        ri.schedule = NULL;
        edges[i] = ToplAddEdgeToGraph( g, NumVtx[i], 0, &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
        switch( NumVtx[i] ) {
            case 4:     ToplEdgeSetVtx( g, edges[i], 3, names[Vtx4[i]] );
            case 3:     ToplEdgeSetVtx( g, edges[i], 2, names[Vtx3[i]] );
        }
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    for( i=0; i<numEdgeSet; i++ ) {
        edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
        edgeSet->numMultiEdges = EdgeSet[i][0];
        edgeSet->multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( EdgeSet[i][0]*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<EdgeSet[i][0];j++) {
            edgeSet->multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        }
        ToplAddEdgeSetToGraph( g, edgeSet );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].name = names[ ColorVtx[i] ];
        colorVtx[i].color = COLOR_RED;
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 )
        return -1;
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[ OutputEdge[i][0] ];
        outEdge->vertexNames[1].name = names[ OutputEdge[i][1] ];
        outEdge->edgeType = 0;
        outEdge->ri.cost = OutputEdge[i][2];
        outEdge->ri.repIntvl = 30;
        outEdge->ri.options = 0;
        outEdge->ri.schedule = NULL;
        outEdge->fDirectedEdge = FALSE;
        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) )
            return -1;
    }

    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 10 (Edge sets) Passed\n");

    return 0;
}


/***** Test11 *****/
/* Hub-spoke configuration test */
int Test11( DWORD numVtx ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    PTOPL_MULTI_EDGE_SET    edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;

    numEdge = numVtx-1;
    numEdgeSet = 1;
    numColorVtx = numVtx;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        ri.cost = 100;
        ri.repIntvl = 0;
        ri.options = 0;
        ri.schedule = NULL;
        edges[i] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[0] );
        ToplEdgeSetVtx( g, edges[i], 1, names[i+1] );
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
    edgeSet->numMultiEdges = numEdge;
    edgeSet->multiEdgeList =
        (PTOPL_MULTI_EDGE*) malloc( numEdge*sizeof(PTOPL_MULTI_EDGE) );
    for(j=0;j<numEdge;j++)
        edgeSet->multiEdgeList[j] = edges[j];
    ToplAddEdgeSetToGraph( g, edgeSet );

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].name = names[i];
        colorVtx[i].color = i==0 ? COLOR_RED : COLOR_BLACK;
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    {
        DWORD time1, time2;
        printf("Num Vtx: %d   Elapsed time: ", numVtx );
        time1 = (DWORD) time( NULL );
        stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );
        time2 = (DWORD) time( NULL );
        printf("%d\n", time2-time1);
    }


    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 )
        return -1;
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[0];
        outEdge->vertexNames[1].name = names[i+1];
        outEdge->edgeType = 0;
        outEdge->ri.cost = 100;
        outEdge->ri.repIntvl = 0;
        outEdge->ri.options = 0;
        outEdge->ri.schedule = NULL;
        outEdge->fDirectedEdge = TRUE;
        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) )
            return -1;
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 11 (Hub & Spoke) Passed\n");

    free( colorVtx );
    free( edgeSet->multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ ) {
        free( names[i] );
    }
    free( names );

    return 0;
}


/***** Test12 *****/
/* Cost overflow testing by using a long chain. Also tests performance of deep
 * shortest-path trees in Dijkstra (but the heap size is always small). */
int Test12( DWORD numVtx ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    PTOPL_MULTI_EDGE_SET    edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges, edgeCost;

    numEdge = numVtx-1;
    numEdgeSet = 1;
    numColorVtx = 2;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    edgeCost=0xFFFFFFFF/numEdge; edgeCost*=2;
    for( i=0; i<numEdge; i++ ) {
        ri.cost = edgeCost;
        ri.repIntvl = 0;
        ri.options = 0;
        ri.schedule = NULL;
        edges[i] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[i] );
        ToplEdgeSetVtx( g, edges[i], 1, names[i+1] );
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
    edgeSet->numMultiEdges = numEdge;
    edgeSet->multiEdgeList =
        (PTOPL_MULTI_EDGE*) malloc( numEdge*sizeof(PTOPL_MULTI_EDGE) );
    for(j=0;j<numEdge;j++)
        edgeSet->multiEdgeList[j] = edges[j];
    ToplAddEdgeSetToGraph( g, edgeSet );

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    colorVtx[0].name = names[0];
    colorVtx[0].color = COLOR_BLACK;
    colorVtx[0].acceptRedRed = colorVtx[0].acceptBlack = 0xFFFFFFFF;
    colorVtx[1].name = names[numVtx-1];
    colorVtx[1].color = COLOR_RED;
    colorVtx[1].acceptRedRed = colorVtx[1].acceptBlack = 0xFFFFFFFF;

    /* Run algorithm */
    {
        DWORD time1, time2;
        printf("Num Vtx: %d   Elapsed time: ", numVtx );
        time1 = (DWORD) time( NULL );
        stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );
        time2 = (DWORD) time( NULL );
        printf("%d\n", time2-time1);
    }


    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 )
        return -1;
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[numVtx-1];
        outEdge->vertexNames[1].name = names[0];
        outEdge->edgeType = 0;
        outEdge->ri.cost = 0xFFFFFFFF;
        outEdge->ri.repIntvl = 0;
        outEdge->ri.options = 0;
        outEdge->ri.schedule = NULL;
        outEdge->fDirectedEdge = TRUE;
        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) )
            return -1;
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 12 (Long Chain) Passed\n");

    free( colorVtx );
    free( edgeSet->multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ ) {
        free( names[i] );
    }
    free( names );

    return 0;
}


/***** Test13 *****/
/* Test the ability of vertices to reject edges of a certain type. */
int Test13( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3  4  5  6  7  8  9 10 */
    Vtx1[] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 1 },
    Vtx2[] = { 1, 1, 2, 3, 2, 2, 4, 4, 4, 4, 3 },
    Type[] = { 0, 1, 1, 3, 1, 0, 0, 1, 1, 0, 3 },
    Cost[] = { 5, 5, 6,99,10,20, 1, 1, 1, 1, 5 };

    const DWORD EdgeSet[][10] = { { 2, 6, 9 },
                                  { 2, 7, 8 } };

    const DWORD ColorVtx[] = { 0, 1, 2, 3 };

    const DWORD OutputEdge[][5] = { { 1, 0, 5, 0, 1 },
                                   { 1, 2, 20, 0, 0 },
                                   { 0, 3, 99, 3, 1 } };

    numVtx = 5;
    numEdge = 11;
    numEdgeSet = 2;
    numColorVtx = 4;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        ri.cost = Cost[i];
        ri.repIntvl = 0;
        ri.options = 0;
        ri.schedule = NULL;
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].name = names[i];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }
    colorVtx[0].color = COLOR_BLACK;
    colorVtx[1].color = COLOR_RED;
    colorVtx[1].acceptRedRed = 0x00000001;
    colorVtx[1].acceptBlack =  0x00000003;
    colorVtx[2].color = COLOR_RED;
    colorVtx[2].acceptRedRed = 0x00000001;
    colorVtx[2].acceptBlack =  0x00000000;
    colorVtx[3].color = COLOR_BLACK;

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[OutputEdge[i][0]];
        outEdge->vertexNames[1].name = names[OutputEdge[i][1]];
        outEdge->ri.cost = OutputEdge[i][2];
        outEdge->ri.repIntvl = 0;
        outEdge->ri.options = 0;
        outEdge->ri.schedule = NULL;
        outEdge->edgeType = OutputEdge[i][3];
        outEdge->fDirectedEdge = (BOOLEAN) OutputEdge[i][4];
        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) ) {
            Error();
            return -1;
        }
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 13 (Denying Edge Types) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}


/***** Test14 *****/
/* Simple Merge, Options, Interval Test */
int Test14( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    DWORD                   numStEdges;
    const int               cbSched = sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES;
    PSCHEDULE               s;
    TOPL_COMPONENTS         compInfo;
    unsigned char*          dataPtr;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1 */
    Vtx1[] = { 0, 1 },
    Vtx2[] = { 1, 2 },
    Type[] = { 0, 0 },
    Cost[] = { 1, 1 };

    const DWORD EdgeSet[][10] = { { 2, 0, 1 } };

    const DWORD ColorVtx[] = { 0, 2 };

    const DWORD OutputEdge[][4] = { { 0, 2, 2, 0 } };

    numVtx = 3;
    numEdge = 2;
    numEdgeSet = 1;
    numColorVtx = 2;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        s = (PSCHEDULE) malloc(cbSched);
        s->Size = cbSched;
        s->NumberOfSchedules = 1;
        s->Schedules[0].Type = SCHEDULE_INTERVAL;
        s->Schedules[0].Offset = sizeof(SCHEDULE);
        dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
        memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
        if( i==0 ) {
            ri.repIntvl = 4;
            ri.options = 3;
            for(j=0;j<112;j++) dataPtr[j] = 0x0F;
        } else {
            ri.repIntvl = 17;
            ri.options = 5;
            for(j=56;j<168;j++) dataPtr[j] = 0x0F;
        }
        ri.schedule = ToplScheduleImport( cache, s );
        ri.cost = Cost[i];
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    /* Used for comparing the output spanning-tree edges with what we expect */
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].color = COLOR_BLACK;
        colorVtx[i].name = names[ColorVtx[i]];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[OutputEdge[i][0]];
        outEdge->vertexNames[1].name = names[OutputEdge[i][1]];
        outEdge->ri.cost = OutputEdge[i][2];
        outEdge->edgeType = OutputEdge[i][3];
        outEdge->ri.repIntvl = 17;
        outEdge->ri.options = 1;
        outEdge->fDirectedEdge = FALSE;

        s = (PSCHEDULE) malloc(cbSched);
        s->Size = cbSched;
        s->NumberOfSchedules = 1;
        s->Schedules[0].Type = SCHEDULE_INTERVAL;
        s->Schedules[0].Offset = sizeof(SCHEDULE);
        dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
        memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
        for(j=56;j<112;j++) dataPtr[j] = 0x0F;
        outEdge->ri.schedule = ToplScheduleImport( cache, s );

        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) ) {
            Error();
            return -1;
        }
    }

    if( 3 != ToplScheduleNumEntries(cache) ) {
        Error();
        return -1;
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 14 (Simple Schedule,Options,ReplIntvl) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}


/***** Test15 *****/
/* Schedules: Longest Duration Wins */
int Test15( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    DWORD                   numStEdges;
    const int               cbSched = sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES;
    PSCHEDULE               s;
    TOPL_COMPONENTS         compInfo;
    unsigned char*          dataPtr;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3  4  5  6 */
    Vtx1[] = { 3, 0, 0, 1, 1, 4, 0 },
    Vtx2[] = { 4, 1, 4, 2, 4, 2, 3 },
    Type[] = { 0, 0, 0, 0, 0, 0, 0 },
    Cost[] = { 1, 1, 1, 1, 1, 1, 1 },
    Sched[]= { 0x000F000F,
               0x08000000,
               0x08000000,
               0x06000000,
               0x07000000,
               0xFFFFFFFF,
               0x0F0F0F0F };

    const DWORD EdgeSet[][10] = { {1} };
    const DWORD ColorVtx[] = { 0, 1, 2, 3, 4 };
    const DWORD OutputEdge[] = { 0, 4, 5, 6 };

    numVtx = 5;
    numEdge = 7;
    numEdgeSet = 0;
    numColorVtx = 5;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        s = (PSCHEDULE) malloc(cbSched);
        s->Size = cbSched;
        s->NumberOfSchedules = 1;
        s->Schedules[0].Type = SCHEDULE_INTERVAL;
        s->Schedules[0].Offset = sizeof(SCHEDULE);
        dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
        memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
        if( Sched[i]==0xFFFFFFFF ) {
            memset( dataPtr, 0x0F, SCHEDULE_DATA_ENTRIES );
        } else {
            memcpy( dataPtr, &Sched[i], sizeof(DWORD) );
        }
        ri.schedule = ToplScheduleImport( cache, s );
        ri.cost = Cost[i];
        ri.repIntvl = 0;
        ri.options = 0;
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    /* Used for comparing the output spanning-tree edges with what we expect */
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].color = COLOR_BLACK;
        colorVtx[i].name = names[ColorVtx[i]];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        edges[OutputEdge[i]]->fDirectedEdge = FALSE;
        if(! EdgeExists2(edges[OutputEdge[i]], stEdgeList, numStEdges, cache) ) {
            Error();
            return -1;
        }
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 15 (Longest Schedule Wins) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}


/***** Test16 *****/
/* Schedules: Longest Duration Wins 2 */
int Test16( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    DWORD                   numStEdges;
    const int               cbSched = sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES;
    PSCHEDULE               s;
    TOPL_COMPONENTS         compInfo;
    unsigned char*          dataPtr;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3  4  5  6  7  8  9*/
    Vtx1[] = { 0, 0, 0, 3, 4, 2, 3, 1, 1, 1 },
    Vtx2[] = { 2, 3, 4, 3, 4, 1, 1, 4, 1, 5 },
    Type[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    Cost[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1,20 },
    Sched[]= { 0x0F0F0000,  /*0*/
               0x0F0F0F0F,  /*1*/
               0x00070007,  /*2*/
               0xFFFFFFFF,  /*3*/
               0xFFFFFFFF,  /*4*/
               0xFFFFFFFF,  /*5*/
               0xFFFFFFFF,  /*6*/
               0x0F0F0F0F,  /*7*/
               0xFFFFFFFF,  /*8*/
               0xFFFFFFFF };/*9*/

    const DWORD EdgeSet[][20] = { {10,0,1,2,3,4,5,6,7,8,9} };
    const DWORD ColorVtx[] = { 0, 5 };
    const DWORD OutputEdge[][5] = { {0,5,22,0,0x0F0F0F0F} };

    numVtx = 6;
    numEdge = 10;
    numEdgeSet = 1;
    numColorVtx = 2;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        s = (PSCHEDULE) malloc(cbSched);
        s->Size = cbSched;
        s->NumberOfSchedules = 1;
        s->Schedules[0].Type = SCHEDULE_INTERVAL;
        s->Schedules[0].Offset = sizeof(SCHEDULE);
        dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
        memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
        if( Sched[i]==0xFFFFFFFF ) {
            memset( dataPtr, 0x0F, SCHEDULE_DATA_ENTRIES );
        } else {
            memcpy( dataPtr, &Sched[i], sizeof(DWORD) );
        }
        ri.schedule = ToplScheduleImport( cache, s );
        ri.cost = Cost[i];
        ri.repIntvl = 0;
        ri.options = 0;
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    /* Used for comparing the output spanning-tree edges with what we expect */
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].color = COLOR_BLACK;
        colorVtx[i].name = names[ColorVtx[i]];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    FixEdges( stEdgeList, numStEdges );
    outEdge->vertexNames[0].name = names[OutputEdge[0][0]];
    outEdge->vertexNames[1].name = names[OutputEdge[0][1]];
    outEdge->ri.cost = OutputEdge[0][2];
    outEdge->edgeType = OutputEdge[0][3];
    outEdge->ri.repIntvl = 0;
    outEdge->ri.options = 0;
    outEdge->fDirectedEdge = FALSE;

    s = (PSCHEDULE) malloc(cbSched);
    s->Size = cbSched;
    s->NumberOfSchedules = 1;
    s->Schedules[0].Type = SCHEDULE_INTERVAL;
    s->Schedules[0].Offset = sizeof(SCHEDULE);
    dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
    memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
    memcpy( dataPtr, &OutputEdge[0][4], sizeof(DWORD) );
    outEdge->ri.schedule = ToplScheduleImport( cache, s );

    if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) ) {
        Error();
        return -1;
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 16 (Longest Schedule Wins 2) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}


/***** Test17 *****/
/* Non-intersecting schedules */
int Test17( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    DWORD                   numStEdges;
    const int               cbSched = sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES;
    PSCHEDULE               s;
    TOPL_COMPONENTS         compInfo;
    unsigned char*          dataPtr;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3  */
    Vtx1[] = { 0, 0, 1, 2 },
    Vtx2[] = { 2, 1, 3, 3 },
    Type[] = { 0, 0, 0, 0 },
    Cost[] = { 1,99,99, 1 },
    Sched[]= { 0x07070707,  /*0*/
               0xFFFFFFFF,  /*1*/
               0xFFFFFFFF,  /*2*/
               0x08080808 };/*3*/

    const DWORD EdgeSet[][20] = { {4,0,1,2,3} };
    const DWORD ColorVtx[] = { 0, 3 };

    numVtx = 4;
    numEdge = 4;
    numEdgeSet = 1;
    numColorVtx = 2;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        s = (PSCHEDULE) malloc(cbSched);
        s->Size = cbSched;
        s->NumberOfSchedules = 1;
        s->Schedules[0].Type = SCHEDULE_INTERVAL;
        s->Schedules[0].Offset = sizeof(SCHEDULE);
        dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
        memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
        if( Sched[i]==0xFFFFFFFF ) {
            memset( dataPtr, 0x0F, SCHEDULE_DATA_ENTRIES );
        } else {
            memcpy( dataPtr, &Sched[i], sizeof(DWORD) );
        }
        ri.schedule = ToplScheduleImport( cache, s );
        ri.cost = Cost[i];
        ri.repIntvl = 0;
        ri.options = 0;
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    /* Used for comparing the output spanning-tree edges with what we expect */
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].color = COLOR_BLACK;
        colorVtx[i].name = names[ColorVtx[i]];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    __try {
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );
        return -1;
    } except( AcceptOnly(TOPL_EX_NONINTERSECTING_SCHEDULES) )
    { }


    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 17 (Non-intersecting schedules) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}


/***** Test18 *****/
/* Test the ability of vertices to reject edges of a certain type. */
int Test18( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3 */
    Vtx1[] = { 0, 0, 1, 1 },
    Vtx2[] = { 1, 1, 2, 2 },
    Type[] = { 0, 1, 0, 1 },
    Cost[] = {10, 5,10,99 };

    const DWORD EdgeSet[][10] = { { 2, 0, 2}, {2, 1, 3} };

    const DWORD ColorVtx[] = { 0, 1, 2 };

    const DWORD OutputEdge[][5] = { { 0, 1, 5, 1, 1 },
                                   { 0, 2, 20, 0, 1 } };

    numVtx = 3;
    numEdge = 4;
    numEdgeSet = 2;
    numColorVtx = 3;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        ri.cost = Cost[i];
        ri.repIntvl = 0;
        ri.options = 0;
        ri.schedule = NULL;
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].name = names[i];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }
    colorVtx[0].color = COLOR_RED;
    colorVtx[1].color = COLOR_BLACK;
    colorVtx[1].acceptRedRed = 0x00000000;
    colorVtx[1].acceptBlack =  0x00000002;
    colorVtx[2].color = COLOR_BLACK;

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[OutputEdge[i][0]];
        outEdge->vertexNames[1].name = names[OutputEdge[i][1]];
        outEdge->ri.cost = OutputEdge[i][2];
        outEdge->ri.repIntvl = 0;
        outEdge->ri.options = 0;
        outEdge->ri.schedule = NULL;
        outEdge->edgeType = OutputEdge[i][3];
        outEdge->fDirectedEdge = (BOOLEAN) OutputEdge[i][4];
        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) ) {
            Error();
            return -1;
        }
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 18 (Bridgehead Failover) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\attids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       attids.h
//
//--------------------------------------------------------------------------



/*++
 File:    ATTIDS.H
 Purpose: ATTRID & CLASSID DEFINITION .
 Creator: Automatically generated on
 Date:    Wed Jun 26 10:49:50 2002

 ** This is a Generated File From Schema.INI **

--*/
#ifndef _ATTIDS_
#define _ATTIDS_



//--------------------------------------
// ATTRIBUTE MAPPINGS
//--------------------------------------
#define  ATT_ACCOUNT_EXPIRES                0x9009f    // ATTq589983   (\x2A864886F7140104811F)
#define  ATT_ACCOUNT_NAME_HISTORY           0x9051b    // ATTm591131   (\x2A864886F71401048A1B)
#define  ATT_ACS_AGGREGATE_TOKEN_RATE_PER_USER 0x902f8    // ATTq590584   (\x2A864886F71401048578)
#define  ATT_ACS_ALLOCABLE_RSVP_BANDWIDTH   0x902fe    // ATTq590590   (\x2A864886F7140104857E)
#define  ATT_ACS_CACHE_TIMEOUT              0x9030b    // ATTj590603   (\x2A864886F7140104860B)
#define  ATT_ACS_DIRECTION                  0x902f5    // ATTj590581   (\x2A864886F71401048575)
#define  ATT_ACS_DSBM_DEADTIME              0x9030a    // ATTj590602   (\x2A864886F7140104860A)
#define  ATT_ACS_DSBM_PRIORITY              0x90308    // ATTj590600   (\x2A864886F71401048608)
#define  ATT_ACS_DSBM_REFRESH               0x90309    // ATTj590601   (\x2A864886F71401048609)
#define  ATT_ACS_ENABLE_ACS_SERVICE         0x90302    // ATTi590594   (\x2A864886F71401048602)
#define  ATT_ACS_ENABLE_RSVP_ACCOUNTING     0x90383    // ATTi590723   (\x2A864886F71401048703)
#define  ATT_ACS_ENABLE_RSVP_MESSAGE_LOGGING 0x90300    // ATTi590592   (\x2A864886F71401048600)
#define  ATT_ACS_EVENT_LOG_LEVEL            0x90301    // ATTj590593   (\x2A864886F71401048601)
#define  ATT_ACS_IDENTITY_NAME              0x90310    // ATTm590608   (\x2A864886F71401048610)
#define  ATT_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER 0x90381    // ATTq590721   (\x2A864886F71401048701)
#define  ATT_ACS_MAX_DURATION_PER_FLOW      0x902f9    // ATTj590585   (\x2A864886F71401048579)
#define  ATT_ACS_MAX_NO_OF_ACCOUNT_FILES    0x90385    // ATTj590725   (\x2A864886F71401048705)
#define  ATT_ACS_MAX_NO_OF_LOG_FILES        0x90306    // ATTj590598   (\x2A864886F71401048606)
#define  ATT_ACS_MAX_PEAK_BANDWIDTH         0x902ff    // ATTq590591   (\x2A864886F7140104857F)
#define  ATT_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW 0x902f7    // ATTq590583   (\x2A864886F71401048577)
#define  ATT_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE 0x90386    // ATTj590726   (\x2A864886F71401048706)
#define  ATT_ACS_MAX_SIZE_OF_RSVP_LOG_FILE  0x90307    // ATTj590599   (\x2A864886F71401048607)
#define  ATT_ACS_MAX_TOKEN_BUCKET_PER_FLOW  0x90521    // ATTq591137   (\x2A864886F71401048A21)
#define  ATT_ACS_MAX_TOKEN_RATE_PER_FLOW    0x902f6    // ATTq590582   (\x2A864886F71401048576)
#define  ATT_ACS_MAXIMUM_SDU_SIZE           0x90522    // ATTq591138   (\x2A864886F71401048A22)
#define  ATT_ACS_MINIMUM_DELAY_VARIATION    0x90525    // ATTq591141   (\x2A864886F71401048A25)
#define  ATT_ACS_MINIMUM_LATENCY            0x90524    // ATTq591140   (\x2A864886F71401048A24)
#define  ATT_ACS_MINIMUM_POLICED_SIZE       0x90523    // ATTq591139   (\x2A864886F71401048A23)
#define  ATT_ACS_NON_RESERVED_MAX_SDU_SIZE  0x90528    // ATTq591144   (\x2A864886F71401048A28)
#define  ATT_ACS_NON_RESERVED_MIN_POLICED_SIZE 0x90529    // ATTq591145   (\x2A864886F71401048A29)
#define  ATT_ACS_NON_RESERVED_PEAK_RATE     0x90526    // ATTq591142   (\x2A864886F71401048A26)
#define  ATT_ACS_NON_RESERVED_TOKEN_SIZE    0x90527    // ATTq591143   (\x2A864886F71401048A27)
#define  ATT_ACS_NON_RESERVED_TX_LIMIT      0x9030c    // ATTq590604   (\x2A864886F7140104860C)
#define  ATT_ACS_NON_RESERVED_TX_SIZE       0x90382    // ATTq590722   (\x2A864886F71401048702)
#define  ATT_ACS_PERMISSION_BITS            0x902fd    // ATTq590589   (\x2A864886F7140104857D)
#define  ATT_ACS_POLICY_NAME                0x90304    // ATTm590596   (\x2A864886F71401048604)
#define  ATT_ACS_PRIORITY                   0x902fc    // ATTj590588   (\x2A864886F7140104857C)
#define  ATT_ACS_RSVP_ACCOUNT_FILES_LOCATION 0x90384    // ATTm590724   (\x2A864886F71401048704)
#define  ATT_ACS_RSVP_LOG_FILES_LOCATION    0x90305    // ATTm590597   (\x2A864886F71401048605)
#define  ATT_ACS_SERVICE_TYPE               0x902fa    // ATTj590586   (\x2A864886F7140104857A)
#define  ATT_ACS_TIME_OF_DAY                0x902f4    // ATTm590580   (\x2A864886F71401048574)
#define  ATT_ACS_TOTAL_NO_OF_FLOWS          0x902fb    // ATTj590587   (\x2A864886F7140104857B)
#define  ATT_ACS_SERVER_LIST                0x90520    // ATTm591136   (\x2A864886F71401048A20)
#define  ATT_ADDITIONAL_INFORMATION         0x90109    // ATTm590089   (\x2A864886F71401048209)
#define  ATT_ADDITIONAL_TRUSTED_SERVICE_NAMES 0x90379    // ATTm590713   (\x2A864886F71401048679)
#define  ATT_ADDRESS                        0x20100    // ATTm131328   (\x2A864886F71401028200)
#define  ATT_ADDRESS_BOOK_ROOTS             0x904dc    // ATTb591068   (\x2A864886F7140104895C)
#define  ATT_ADDRESS_ENTRY_DISPLAY_TABLE    0x20144    // ATTk131396   (\x2A864886F71401028244)
#define  ATT_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS 0x20190    // ATTk131472   (\x2A864886F71401028310)
#define  ATT_ADDRESS_HOME                   0x20269    // ATTm131689   (\x2A864886F71401028469)
#define  ATT_ADDRESS_SYNTAX                 0x200ff    // ATTk131327   (\x2A864886F7140102817F)
#define  ATT_ADDRESS_TYPE                   0x2015e    // ATTe131422   (\x2A864886F7140102825E)
#define  ATT_ADMIN_CONTEXT_MENU             0x90266    // ATTm590438   (\x2A864886F71401048466)
#define  ATT_ADMIN_COUNT                    0x90096    // ATTj589974   (\x2A864886F71401048116)
#define  ATT_ADMIN_DESCRIPTION              0x200e2    // ATTm131298   (\x2A864886F71401028162)
#define  ATT_ADMIN_DISPLAY_NAME             0x200c2    // ATTm131266   (\x2A864886F71401028142)
#define  ATT_ADMIN_MULTISELECT_PROPERTY_PAGES 0x9069a    // ATTm591514   (\x2A864886F71401048D1A)
#define  ATT_ADMIN_PROPERTY_PAGES           0x90232    // ATTm590386   (\x2A864886F71401048432)
#define  ATT_ALLOWED_ATTRIBUTES             0x90391    // ATTc590737   (\x2A864886F71401048711)
#define  ATT_ALLOWED_ATTRIBUTES_EFFECTIVE   0x90392    // ATTc590738   (\x2A864886F71401048712)
#define  ATT_ALLOWED_CHILD_CLASSES          0x9038f    // ATTc590735   (\x2A864886F7140104870F)
#define  ATT_ALLOWED_CHILD_CLASSES_EFFECTIVE 0x90390    // ATTc590736   (\x2A864886F71401048710)
#define  ATT_ALT_SECURITY_IDENTITIES        0x90363    // ATTm590691   (\x2A864886F71401048663)
#define  ATT_ANR                            0x904b8    // ATTm591032   (\x2A864886F71401048938)
#define  ATT_APP_SCHEMA_VERSION             0x90350    // ATTj590672   (\x2A864886F71401048650)
#define  ATT_APPLICATION_NAME               0x900da    // ATTm590042   (\x2A864886F7140104815A)
#define  ATT_APPLIES_TO                     0x90155    // ATTm590165   (\x2A864886F71401048255)
#define  ATT_ASSET_NUMBER                   0x9011b    // ATTm590107   (\x2A864886F7140104821B)
#define  ATT_ASSISTANT                      0x9028c    // ATTb590476   (\x2A864886F7140104850C)
#define  ATT_ASSOC_NT_ACCOUNT               0x904bd    // ATTk591037   (\x2A864886F7140104893D)
#define  ATT_ASSOCIATEDDOMAIN               0x150025   // ATTf1376293  (\x0992268993F22C640125)
#define  ATT_ASSOCIATEDNAME                 0x150026   // ATTb1376294  (\x0992268993F22C640126)
#define  ATT_ATTRIBUTECERTIFICATEATTRIBUTE  0x3a       // ATTk58       (\x55043A)
#define  ATT_ATTRIBUTE_DISPLAY_NAMES        0x902ec    // ATTm590572   (\x2A864886F7140104856C)
#define  ATT_ATTRIBUTE_ID                   0x2001e    // ATTc131102   (\x2A864886F71401021E)
#define  ATT_ATTRIBUTE_SECURITY_GUID        0x90095    // ATTk589973   (\x2A864886F71401048115)
#define  ATT_ATTRIBUTE_SYNTAX               0x20020    // ATTc131104   (\x2A864886F714010220)
#define  ATT_ATTRIBUTE_TYPES                0x180005   // ATTm1572869  (\x551505)
#define  ATT_AUDIO                          0x150037   // ATTk1376311  (\x0992268993F22C640137)
#define  ATT_AUDITING_POLICY                0x900ca    // ATTk590026   (\x2A864886F7140104814A)
#define  ATT_AUTHENTICATION_OPTIONS         0x9000b    // ATTj589835   (\x2A864886F71401040B)
#define  ATT_AUTHORITY_REVOCATION_LIST      0x26       // ATTk38       (\x550426)
#define  ATT_AUXILIARY_CLASS                0x2015f    // ATTc131423   (\x2A864886F7140102825F)
#define  ATT_BAD_PASSWORD_TIME              0x90031    // ATTq589873   (\x2A864886F714010431)
#define  ATT_BAD_PWD_COUNT                  0x9000c    // ATTj589836   (\x2A864886F71401040C)
#define  ATT_BIRTH_LOCATION                 0x9014c    // ATTk590156   (\x2A864886F7140104824C)
#define  ATT_BRIDGEHEAD_SERVER_LIST_BL      0x90334    // ATTb590644   (\x2A864886F71401048634)
#define  ATT_BRIDGEHEAD_TRANSPORT_LIST      0x90333    // ATTb590643   (\x2A864886F71401048633)
#define  ATT_BUILDINGNAME                   0x150030   // ATTm1376304  (\x0992268993F22C640130)
#define  ATT_BUILTIN_CREATION_TIME          0x9000d    // ATTq589837   (\x2A864886F71401040D)
#define  ATT_BUILTIN_MODIFIED_COUNT         0x9000e    // ATTq589838   (\x2A864886F71401040E)
#define  ATT_BUSINESS_CATEGORY              0xf        // ATTm15       (\x55040F)
#define  ATT_BYTES_PER_MINUTE               0x9011c    // ATTj590108   (\x2A864886F7140104821C)
#define  ATT_CA_CERTIFICATE                 0x25       // ATTk37       (\x550425)
#define  ATT_CA_CERTIFICATE_DN              0x902b9    // ATTm590521   (\x2A864886F71401048539)
#define  ATT_CA_CONNECT                     0x902af    // ATTm590511   (\x2A864886F7140104852F)
#define  ATT_CA_USAGES                      0x902b2    // ATTm590514   (\x2A864886F71401048532)
#define  ATT_CA_WEB_URL                     0x902b0    // ATTm590512   (\x2A864886F71401048530)
#define  ATT_CAN_UPGRADE_SCRIPT             0x9032f    // ATTm590639   (\x2A864886F7140104862F)
#define  ATT_CANONICAL_NAME                 0x90394    // ATTm590740   (\x2A864886F71401048714)
#define  ATT_CARLICENSE                     0x160001   // ATTm1441793  (\x6086480186F842030101)
#define  ATT_CATALOGS                       0x902a3    // ATTm590499   (\x2A864886F71401048523)
#define  ATT_CATEGORIES                     0x902a0    // ATTm590496   (\x2A864886F71401048520)
#define  ATT_CATEGORY_ID                    0x90142    // ATTk590146   (\x2A864886F71401048242)
#define  ATT_CERTIFICATE_AUTHORITY_OBJECT   0x902ac    // ATTb590508   (\x2A864886F7140104852C)
#define  ATT_CERTIFICATE_REVOCATION_LIST    0x27       // ATTk39       (\x550427)
#define  ATT_CERTIFICATE_TEMPLATES          0x90337    // ATTm590647   (\x2A864886F71401048637)
#define  ATT_CLASS_DISPLAY_NAME             0x90262    // ATTm590434   (\x2A864886F71401048462)
#define  ATT_CODE_PAGE                      0x90010    // ATTj589840   (\x2A864886F714010410)
#define  ATT_COM_CLASSID                    0x90013    // ATTm589843   (\x2A864886F714010413)
#define  ATT_COM_CLSID                      0x900f9    // ATTm590073   (\x2A864886F71401048179)
#define  ATT_COM_INTERFACEID                0x90014    // ATTm589844   (\x2A864886F714010414)
#define  ATT_COM_OTHER_PROG_ID              0x900fd    // ATTm590077   (\x2A864886F7140104817D)
#define  ATT_COM_PROGID                     0x90015    // ATTm589845   (\x2A864886F714010415)
#define  ATT_COM_TREAT_AS_CLASS_ID          0x900fb    // ATTm590075   (\x2A864886F7140104817B)
#define  ATT_COM_TYPELIB_ID                 0x900fe    // ATTm590078   (\x2A864886F7140104817E)
#define  ATT_COM_UNIQUE_LIBID               0x900fa    // ATTm590074   (\x2A864886F7140104817A)
#define  ATT_COMMENT                        0x20051    // ATTm131153   (\x2A864886F714010251)
#define  ATT_COMMON_NAME                    0x3        // ATTm3        (\x550403)
#define  ATT_COMPANY                        0x20092    // ATTm131218   (\x2A864886F71401028112)
#define  ATT_CONTENT_INDEXING_ALLOWED       0x90018    // ATTi589848   (\x2A864886F714010418)
#define  ATT_CONTEXT_MENU                   0x901f3    // ATTm590323   (\x2A864886F71401048373)
#define  ATT_CONTROL_ACCESS_RIGHTS          0x900c8    // ATTk590024   (\x2A864886F71401048148)
#define  ATT_COST                           0x20087    // ATTj131207   (\x2A864886F71401028107)
#define  ATT_COUNTRY_CODE                   0x90019    // ATTj589849   (\x2A864886F714010419)
#define  ATT_COUNTRY_NAME                   0x6        // ATTm6        (\x550406)
#define  ATT_CREATE_DIALOG                  0x9032a    // ATTm590634   (\x2A864886F7140104862A)
#define  ATT_CREATE_TIME_STAMP              0x190001   // ATTl1638401  (\x551201)
#define  ATT_CREATE_WIZARD_EXT              0x9032c    // ATTm590636   (\x2A864886F7140104862C)
#define  ATT_CREATION_TIME                  0x9001a    // ATTq589850   (\x2A864886F71401041A)
#define  ATT_CREATION_WIZARD                0x901f2    // ATTm590322   (\x2A864886F71401048372)
#define  ATT_CREATOR                        0x902a7    // ATTm590503   (\x2A864886F71401048527)
#define  ATT_CRL_OBJECT                     0x902b1    // ATTb590513   (\x2A864886F71401048531)
#define  ATT_CRL_PARTITIONED_REVOCATION_LIST 0x902ab    // ATTk590507   (\x2A864886F7140104852B)
#define  ATT_CROSS_CERTIFICATE_PAIR         0x28       // ATTk40       (\x550428)
#define  ATT_CURR_MACHINE_ID                0x90151    // ATTk590161   (\x2A864886F71401048251)
#define  ATT_CURRENT_LOCATION               0x9014f    // ATTk590159   (\x2A864886F7140104824F)
#define  ATT_CURRENT_PARENT_CA              0x902b8    // ATTb590520   (\x2A864886F71401048538)
#define  ATT_CURRENT_VALUE                  0x9001b    // ATTk589851   (\x2A864886F71401041B)
#define  ATT_DBCS_PWD                       0x90037    // ATTk589879   (\x2A864886F714010437)
#define  ATT_DEFAULT_CLASS_STORE            0x900d5    // ATTb590037   (\x2A864886F71401048155)
#define  ATT_DEFAULT_GROUP                  0x901e0    // ATTb590304   (\x2A864886F71401048360)
#define  ATT_DEFAULT_HIDING_VALUE           0x90206    // ATTi590342   (\x2A864886F71401048406)
#define  ATT_DEFAULT_LOCAL_POLICY_OBJECT    0x90039    // ATTb589881   (\x2A864886F714010439)
#define  ATT_DEFAULT_OBJECT_CATEGORY        0x9030f    // ATTb590607   (\x2A864886F7140104860F)
#define  ATT_DEFAULT_PRIORITY               0x900e8    // ATTj590056   (\x2A864886F71401048168)
#define  ATT_DEFAULT_SECURITY_DESCRIPTOR    0x900e0    // ATTm590048   (\x2A864886F71401048160)
#define  ATT_DELTA_REVOCATION_LIST          0x35       // ATTk53       (\x550435)
#define  ATT_DEPARTMENT                     0x2008d    // ATTm131213   (\x2A864886F7140102810D)
#define  ATT_DEPARTMENTNUMBER               0x160002   // ATTm1441794  (\x6086480186F842030102)
#define  ATT_DESCRIPTION                    0xd        // ATTm13       (\x55040D)
#define  ATT_DESKTOP_PROFILE                0x9015a    // ATTm590170   (\x2A864886F7140104825A)
#define  ATT_DESTINATION_INDICATOR          0x1b       // ATTf27       (\x55041B)
#define  ATT_DHCP_CLASSES                   0x902cb    // ATTk590539   (\x2A864886F7140104854B)
#define  ATT_DHCP_FLAGS                     0x902bc    // ATTq590524   (\x2A864886F7140104853C)
#define  ATT_DHCP_IDENTIFICATION            0x902bd    // ATTm590525   (\x2A864886F7140104853D)
#define  ATT_DHCP_MASK                      0x902c2    // ATTf590530   (\x2A864886F71401048542)
#define  ATT_DHCP_MAXKEY                    0x902cf    // ATTq590543   (\x2A864886F7140104854F)
#define  ATT_DHCP_OBJ_DESCRIPTION           0x902bf    // ATTm590527   (\x2A864886F7140104853F)
#define  ATT_DHCP_OBJ_NAME                  0x902be    // ATTm590526   (\x2A864886F7140104853E)
#define  ATT_DHCP_OPTIONS                   0x902ca    // ATTk590538   (\x2A864886F7140104854A)
#define  ATT_DHCP_PROPERTIES                0x902ce    // ATTk590542   (\x2A864886F7140104854E)
#define  ATT_DHCP_RANGES                    0x902c3    // ATTf590531   (\x2A864886F71401048543)
#define  ATT_DHCP_RESERVATIONS              0x902c5    // ATTf590533   (\x2A864886F71401048545)
#define  ATT_DHCP_SERVERS                   0x902c0    // ATTf590528   (\x2A864886F71401048540)
#define  ATT_DHCP_SITES                     0x902c4    // ATTf590532   (\x2A864886F71401048544)
#define  ATT_DHCP_STATE                     0x902cd    // ATTf590541   (\x2A864886F7140104854D)
#define  ATT_DHCP_SUBNETS                   0x902c1    // ATTf590529   (\x2A864886F71401048541)
#define  ATT_DHCP_TYPE                      0x902bb    // ATTj590523   (\x2A864886F7140104853B)
#define  ATT_DHCP_UNIQUE_KEY                0x902ba    // ATTq590522   (\x2A864886F7140104853A)
#define  ATT_DHCP_UPDATE_TIME               0x902d0    // ATTq590544   (\x2A864886F71401048550)
#define  ATT_DISPLAY_NAME                   0x2000d    // ATTm131085   (\x2A864886F71401020D)
#define  ATT_DISPLAY_NAME_PRINTABLE         0x20161    // ATTf131425   (\x2A864886F71401028261)
#define  ATT_DIT_CONTENT_RULES              0x180002   // ATTm1572866  (\x551502)
#define  ATT_DIVISION                       0x90105    // ATTm590085   (\x2A864886F71401048205)
#define  ATT_DMD_LOCATION                   0x20024    // ATTb131108   (\x2A864886F714010224)
#define  ATT_DMD_NAME                       0x20256    // ATTm131670   (\x2A864886F71401028456)
#define  ATT_DN_REFERENCE_UPDATE            0x904da    // ATTb591066   (\x2A864886F7140104895A)
#define  ATT_DNS_ALLOW_DYNAMIC              0x9017a    // ATTi590202   (\x2A864886F7140104827A)
#define  ATT_DNS_ALLOW_XFR                  0x9017b    // ATTi590203   (\x2A864886F7140104827B)
#define  ATT_DNS_HOST_NAME                  0x9026b    // ATTm590443   (\x2A864886F7140104846B)
#define  ATT_DNS_NOTIFY_SECONDARIES         0x9017d    // ATTj590205   (\x2A864886F7140104827D)
#define  ATT_DNS_PROPERTY                   0x9051a    // ATTk591130   (\x2A864886F71401048A1A)
#define  ATT_DNS_RECORD                     0x9017e    // ATTk590206   (\x2A864886F7140104827E)
#define  ATT_DNS_ROOT                       0x9001c    // ATTm589852   (\x2A864886F71401041C)
#define  ATT_DNS_SECURE_SECONDARIES         0x9017c    // ATTj590204   (\x2A864886F7140104827C)
#define  ATT_DNS_TOMBSTONED                 0x90586    // ATTi591238   (\x2A864886F71401048B06)
#define  ATT_DOCUMENTAUTHOR                 0x15000e   // ATTb1376270  (\x0992268993F22C64010E)
#define  ATT_DOCUMENTIDENTIFIER             0x15000b   // ATTm1376267  (\x0992268993F22C64010B)
#define  ATT_DOCUMENTLOCATION               0x15000f   // ATTm1376271  (\x0992268993F22C64010F)
#define  ATT_DOCUMENTPUBLISHER              0x150038   // ATTm1376312  (\x0992268993F22C640138)
#define  ATT_DOCUMENTTITLE                  0x15000c   // ATTm1376268  (\x0992268993F22C64010C)
#define  ATT_DOCUMENTVERSION                0x15000d   // ATTm1376269  (\x0992268993F22C64010D)
#define  ATT_DOMAIN_CERTIFICATE_AUTHORITIES 0x9029c    // ATTb590492   (\x2A864886F7140104851C)
#define  ATT_DOMAIN_COMPONENT               0x150019   // ATTm1376281  (\x0992268993F22C640119)
#define  ATT_DOMAIN_CROSS_REF               0x901d8    // ATTb590296   (\x2A864886F71401048358)
#define  ATT_DOMAIN_ID                      0x902ae    // ATTb590510   (\x2A864886F7140104852E)
#define  ATT_DOMAIN_IDENTIFIER              0x902f3    // ATTj590579   (\x2A864886F71401048573)
#define  ATT_DOMAIN_POLICY_OBJECT           0x90020    // ATTb589856   (\x2A864886F714010420)
#define  ATT_DOMAIN_POLICY_REFERENCE        0x901a6    // ATTb590246   (\x2A864886F71401048326)
#define  ATT_DOMAIN_REPLICA                 0x9009e    // ATTm589982   (\x2A864886F7140104811E)
#define  ATT_DOMAIN_WIDE_POLICY             0x901a5    // ATTk590245   (\x2A864886F71401048325)
#define  ATT_DRINK                          0x150005   // ATTm1376261  (\x0992268993F22C640105)
#define  ATT_DRIVER_NAME                    0x900e5    // ATTm590053   (\x2A864886F71401048165)
#define  ATT_DRIVER_VERSION                 0x90114    // ATTj590100   (\x2A864886F71401048214)
#define  ATT_DS_CORE_PROPAGATION_DATA       0x9054d    // ATTl591181   (\x2A864886F71401048A4D)
#define  ATT_DS_HEURISTICS                  0x200d4    // ATTm131284   (\x2A864886F71401028154)
#define  ATT_DS_UI_ADMIN_MAXIMUM            0x90540    // ATTj591168   (\x2A864886F71401048A40)
#define  ATT_DS_UI_ADMIN_NOTIFICATION       0x9053f    // ATTm591167   (\x2A864886F71401048A3F)
#define  ATT_DS_UI_SHELL_MAXIMUM            0x90541    // ATTj591169   (\x2A864886F71401048A41)
#define  ATT_DSA_SIGNATURE                  0x2004a    // ATTk131146   (\x2A864886F71401024A)
#define  ATT_DYNAMIC_LDAP_SERVER            0x90219    // ATTb590361   (\x2A864886F71401048419)
#define  ATT_E_MAIL_ADDRESSES               0x150003   // ATTm1376259  (\x0992268993F22C640103)
#define  ATT_EFSPOLICY                      0x9010c    // ATTk590092   (\x2A864886F7140104820C)
#define  ATT_EMPLOYEE_ID                    0x90023    // ATTm589859   (\x2A864886F714010423)
#define  ATT_EMPLOYEE_NUMBER                0x20262    // ATTm131682   (\x2A864886F71401028462)
#define  ATT_EMPLOYEE_TYPE                  0x20265    // ATTm131685   (\x2A864886F71401028465)
#define  ATT_ENABLED                        0x2022d    // ATTi131629   (\x2A864886F7140102842D)
#define  ATT_ENABLED_CONNECTION             0x90024    // ATTi589860   (\x2A864886F714010424)
#define  ATT_ENROLLMENT_PROVIDERS           0x90339    // ATTm590649   (\x2A864886F71401048639)
#define  ATT_EXTENDED_ATTRIBUTE_INFO        0x9038d    // ATTm590733   (\x2A864886F7140104870D)
#define  ATT_EXTENDED_CHARS_ALLOWED         0x2017c    // ATTi131452   (\x2A864886F7140102827C)
#define  ATT_EXTENDED_CLASS_INFO            0x9038c    // ATTm590732   (\x2A864886F7140104870C)
#define  ATT_EXTENSION_NAME                 0x200e3    // ATTm131299   (\x2A864886F71401028163)
#define  ATT_EXTRA_COLUMNS                  0x90697    // ATTm591511   (\x2A864886F71401048D17)
#define  ATT_FACSIMILE_TELEPHONE_NUMBER     0x17       // ATTm23       (\x550417)
#define  ATT_FILE_EXT_PRIORITY              0x90330    // ATTm590640   (\x2A864886F71401048630)
#define  ATT_FLAGS                          0x90026    // ATTj589862   (\x2A864886F714010426)
#define  ATT_FLAT_NAME                      0x901ff    // ATTm590335   (\x2A864886F7140104837F)
#define  ATT_FORCE_LOGOFF                   0x90027    // ATTq589863   (\x2A864886F714010427)
#define  ATT_FOREIGN_IDENTIFIER             0x90164    // ATTk590180   (\x2A864886F71401048264)
#define  ATT_FRIENDLY_NAMES                 0x902aa    // ATTm590506   (\x2A864886F7140104852A)
#define  ATT_FROM_ENTRY                     0x9038e    // ATTi590734   (\x2A864886F7140104870E)
#define  ATT_FROM_SERVER                    0x90028    // ATTb589864   (\x2A864886F714010428)
#define  ATT_FRS_COMPUTER_REFERENCE         0x90365    // ATTb590693   (\x2A864886F71401048665)
#define  ATT_FRS_COMPUTER_REFERENCE_BL      0x90366    // ATTb590694   (\x2A864886F71401048666)
#define  ATT_FRS_CONTROL_DATA_CREATION      0x90367    // ATTm590695   (\x2A864886F71401048667)
#define  ATT_FRS_CONTROL_INBOUND_BACKLOG    0x90368    // ATTm590696   (\x2A864886F71401048668)
#define  ATT_FRS_CONTROL_OUTBOUND_BACKLOG   0x90369    // ATTm590697   (\x2A864886F71401048669)
#define  ATT_FRS_DIRECTORY_FILTER           0x901e4    // ATTm590308   (\x2A864886F71401048364)
#define  ATT_FRS_DS_POLL                    0x901ea    // ATTj590314   (\x2A864886F7140104836A)
#define  ATT_FRS_EXTENSIONS                 0x90218    // ATTk590360   (\x2A864886F71401048418)
#define  ATT_FRS_FAULT_CONDITION            0x901eb    // ATTm590315   (\x2A864886F7140104836B)
#define  ATT_FRS_FILE_FILTER                0x901e3    // ATTm590307   (\x2A864886F71401048363)
#define  ATT_FRS_FLAGS                      0x9036a    // ATTj590698   (\x2A864886F7140104866A)
#define  ATT_FRS_LEVEL_LIMIT                0x90216    // ATTj590358   (\x2A864886F71401048416)
#define  ATT_FRS_MEMBER_REFERENCE           0x9036b    // ATTb590699   (\x2A864886F7140104866B)
#define  ATT_FRS_MEMBER_REFERENCE_BL        0x9036c    // ATTb590700   (\x2A864886F7140104866C)
#define  ATT_FRS_PARTNER_AUTH_LEVEL         0x9036d    // ATTj590701   (\x2A864886F7140104866D)
#define  ATT_FRS_PRIMARY_MEMBER             0x9036e    // ATTb590702   (\x2A864886F7140104866E)
#define  ATT_FRS_REPLICA_SET_GUID           0x90215    // ATTk590357   (\x2A864886F71401048415)
#define  ATT_FRS_REPLICA_SET_TYPE           0x9001f    // ATTj589855   (\x2A864886F71401041F)
#define  ATT_FRS_ROOT_PATH                  0x901e7    // ATTm590311   (\x2A864886F71401048367)
#define  ATT_FRS_ROOT_SECURITY              0x90217    // ATTp590359   (\x2A864886F71401048417)
#define  ATT_FRS_SERVICE_COMMAND            0x901f4    // ATTm590324   (\x2A864886F71401048374)
#define  ATT_FRS_SERVICE_COMMAND_STATUS     0x9036f    // ATTm590703   (\x2A864886F7140104866F)
#define  ATT_FRS_STAGING_PATH               0x901e8    // ATTm590312   (\x2A864886F71401048368)
#define  ATT_FRS_TIME_LAST_COMMAND          0x90370    // ATTl590704   (\x2A864886F71401048670)
#define  ATT_FRS_TIME_LAST_CONFIG_CHANGE    0x90371    // ATTl590705   (\x2A864886F71401048671)
#define  ATT_FRS_UPDATE_TIMEOUT             0x901e5    // ATTj590309   (\x2A864886F71401048365)
#define  ATT_FRS_VERSION                    0x90372    // ATTm590706   (\x2A864886F71401048672)
#define  ATT_FRS_VERSION_GUID               0x9002b    // ATTk589867   (\x2A864886F71401042B)
#define  ATT_FRS_WORKING_PATH               0x901e6    // ATTm590310   (\x2A864886F71401048366)
#define  ATT_FSMO_ROLE_OWNER                0x90171    // ATTb590193   (\x2A864886F71401048271)
#define  ATT_GARBAGE_COLL_PERIOD            0x2012d    // ATTj131373   (\x2A864886F7140102822D)
#define  ATT_GENERATED_CONNECTION           0x90029    // ATTi589865   (\x2A864886F714010429)
#define  ATT_GENERATION_QUALIFIER           0x2c       // ATTm44       (\x55042C)
#define  ATT_GIVEN_NAME                     0x2a       // ATTm42       (\x55042A)
#define  ATT_GLOBAL_ADDRESS_LIST            0x904dd    // ATTb591069   (\x2A864886F7140104895D)
#define  ATT_GOVERNS_ID                     0x20016    // ATTc131094   (\x2A864886F714010216)
#define  ATT_GP_LINK                        0x9037b    // ATTm590715   (\x2A864886F7140104867B)
#define  ATT_GP_OPTIONS                     0x9037c    // ATTj590716   (\x2A864886F7140104867C)
#define  ATT_GPC_FILE_SYS_PATH              0x9037e    // ATTm590718   (\x2A864886F7140104867E)
#define  ATT_GPC_FUNCTIONALITY_VERSION      0x9037d    // ATTj590717   (\x2A864886F7140104867D)
#define  ATT_GPC_MACHINE_EXTENSION_NAMES    0x90544    // ATTm591172   (\x2A864886F71401048A44)
#define  ATT_GPC_USER_EXTENSION_NAMES       0x90545    // ATTm591173   (\x2A864886F71401048A45)
#define  ATT_GPC_WQL_FILTER                 0x9069e    // ATTm591518   (\x2A864886F71401048D1E)
#define  ATT_GROUP_ATTRIBUTES               0x90098    // ATTj589976   (\x2A864886F71401048118)
#define  ATT_GROUP_MEMBERSHIP_SAM           0x900a6    // ATTk589990   (\x2A864886F71401048126)
#define  ATT_GROUP_PRIORITY                 0x90159    // ATTm590169   (\x2A864886F71401048259)
#define  ATT_GROUP_TYPE                     0x902ee    // ATTj590574   (\x2A864886F7140104856E)
#define  ATT_GROUPS_TO_IGNORE               0x90158    // ATTm590168   (\x2A864886F71401048258)
#define  ATT_HAS_MASTER_NCS                 0x2000e    // ATTb131086   (\x2A864886F71401020E)
#define  ATT_HAS_PARTIAL_REPLICA_NCS        0x2000f    // ATTb131087   (\x2A864886F71401020F)
#define  ATT_HELP_DATA16                    0x20192    // ATTk131474   (\x2A864886F71401028312)
#define  ATT_HELP_DATA32                    0x20009    // ATTk131081   (\x2A864886F714010209)
#define  ATT_HELP_FILE_NAME                 0x20147    // ATTm131399   (\x2A864886F71401028247)
#define  ATT_HIDE_FROM_AB                   0x906f4    // ATTi591604   (\x2A864886F71401048D74)
#define  ATT_HOME_DIRECTORY                 0x9002c    // ATTm589868   (\x2A864886F71401042C)
#define  ATT_HOME_DRIVE                     0x9002d    // ATTm589869   (\x2A864886F71401042D)
#define  ATT_HOUSEIDENTIFIER                0x33       // ATTm51       (\x550433)
#define  ATT_HOST                           0x150009   // ATTm1376265  (\x0992268993F22C640109)
#define  ATT_ICON_PATH                      0x900db    // ATTm590043   (\x2A864886F7140104815B)
#define  ATT_IMPLEMENTED_CATEGORIES         0x90140    // ATTk590144   (\x2A864886F71401048240)
#define  ATT_INDEXEDSCOPES                  0x902a9    // ATTm590505   (\x2A864886F71401048529)
#define  ATT_INITIAL_AUTH_INCOMING          0x9021b    // ATTm590363   (\x2A864886F7140104841B)
#define  ATT_INITIAL_AUTH_OUTGOING          0x9021c    // ATTm590364   (\x2A864886F7140104841C)
#define  ATT_INITIALS                       0x2b       // ATTm43       (\x55042B)
#define  ATT_INSTALL_UI_LEVEL               0x9034f    // ATTj590671   (\x2A864886F7140104864F)
#define  ATT_INSTANCE_TYPE                  0x20001    // ATTj131073   (\x2A864886F714010201)
#define  ATT_INTER_SITE_TOPOLOGY_FAILOVER   0x904e0    // ATTj591072   (\x2A864886F71401048960)
#define  ATT_INTER_SITE_TOPOLOGY_GENERATOR  0x904de    // ATTb591070   (\x2A864886F7140104895E)
#define  ATT_INTER_SITE_TOPOLOGY_RENEW      0x904df    // ATTj591071   (\x2A864886F7140104895F)
#define  ATT_INTERNATIONAL_ISDN_NUMBER      0x19       // ATTg25       (\x550419)
#define  ATT_INVOCATION_ID                  0x20073    // ATTk131187   (\x2A864886F714010273)
#define  ATT_IPSEC_DATA                     0x9026f    // ATTk590447   (\x2A864886F7140104846F)
#define  ATT_IPSEC_DATA_TYPE                0x9026e    // ATTj590446   (\x2A864886F7140104846E)
#define  ATT_IPSEC_FILTER_REFERENCE         0x90275    // ATTb590453   (\x2A864886F71401048475)
#define  ATT_IPSEC_ID                       0x9026d    // ATTm590445   (\x2A864886F7140104846D)
#define  ATT_IPSEC_ISAKMP_REFERENCE         0x90272    // ATTb590450   (\x2A864886F71401048472)
#define  ATT_IPSEC_NAME                     0x9026c    // ATTm590444   (\x2A864886F7140104846C)
#define  ATT_IPSEC_NEGOTIATION_POLICY_ACTION 0x90378    // ATTm590712   (\x2A864886F71401048678)
#define  ATT_IPSEC_NEGOTIATION_POLICY_REFERENCE 0x90274    // ATTb590452   (\x2A864886F71401048474)
#define  ATT_IPSEC_NEGOTIATION_POLICY_TYPE  0x90377    // ATTm590711   (\x2A864886F71401048677)
#define  ATT_IPSEC_NFA_REFERENCE            0x90273    // ATTb590451   (\x2A864886F71401048473)
#define  ATT_IPSEC_OWNERS_REFERENCE         0x90270    // ATTb590448   (\x2A864886F71401048470)
#define  ATT_IPSEC_POLICY_REFERENCE         0x90205    // ATTb590341   (\x2A864886F71401048405)
#define  ATT_IS_CRITICAL_SYSTEM_OBJECT      0x90364    // ATTi590692   (\x2A864886F71401048664)
#define  ATT_IS_DEFUNCT                     0x90295    // ATTi590485   (\x2A864886F71401048515)
#define  ATT_IS_DELETED                     0x20030    // ATTi131120   (\x2A864886F714010230)
#define  ATT_IS_EPHEMERAL                   0x904bc    // ATTi591036   (\x2A864886F7140104893C)
#define  ATT_IS_MEMBER_OF_DL                0x20066    // ATTb131174   (\x2A864886F714010266)
#define  ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET 0x9027f    // ATTi590463   (\x2A864886F7140104847F)
#define  ATT_IS_PRIVILEGE_HOLDER            0x9027e    // ATTb590462   (\x2A864886F7140104847E)
#define  ATT_IS_SINGLE_VALUED               0x20021    // ATTi131105   (\x2A864886F714010221)
#define  ATT_JPEGPHOTO                      0x15003c   // ATTk1376316  (\x0992268993F22C64013C)
#define  ATT_KEYWORDS                       0x90030    // ATTm589872   (\x2A864886F714010430)
#define  ATT_KNOWLEDGE_INFORMATION          0x2        // ATTe2        (\x550402)
#define  ATT_LAST_BACKUP_RESTORATION_TIME   0x90207    // ATTq590343   (\x2A864886F71401048407)
#define  ATT_LAST_CONTENT_INDEXED           0x90032    // ATTq589874   (\x2A864886F714010432)
#define  ATT_LAST_KNOWN_PARENT              0x9030d    // ATTb590605   (\x2A864886F7140104860D)
#define  ATT_LAST_LOGOFF                    0x90033    // ATTq589875   (\x2A864886F714010433)
#define  ATT_LAST_LOGON                     0x90034    // ATTq589876   (\x2A864886F714010434)
#define  ATT_LAST_LOGON_TIMESTAMP           0x906a0    // ATTq591520   (\x2A864886F71401048D20)
#define  ATT_LAST_SET_TIME                  0x90035    // ATTq589877   (\x2A864886F714010435)
#define  ATT_LAST_UPDATE_SEQUENCE           0x9014a    // ATTm590154   (\x2A864886F7140104824A)
#define  ATT_LDAP_ADMIN_LIMITS              0x9034b    // ATTm590667   (\x2A864886F7140104864B)
#define  ATT_LDAP_DISPLAY_NAME              0x201cc    // ATTm131532   (\x2A864886F7140102834C)
#define  ATT_LDAP_IPDENY_LIST               0x9034c    // ATTk590668   (\x2A864886F7140104864C)
#define  ATT_LEGACY_EXCHANGE_DN             0x9028f    // ATTe590479   (\x2A864886F7140104850F)
#define  ATT_LINK_ID                        0x20032    // ATTj131122   (\x2A864886F714010232)
#define  ATT_LINK_TRACK_SECRET              0x9010d    // ATTk590093   (\x2A864886F7140104820D)
#define  ATT_LM_PWD_HISTORY                 0x900a0    // ATTk589984   (\x2A864886F71401048120)
#define  ATT_LOCAL_POLICY_FLAGS             0x90038    // ATTj589880   (\x2A864886F714010438)
#define  ATT_LOCAL_POLICY_REFERENCE         0x901c9    // ATTb590281   (\x2A864886F71401048349)
#define  ATT_LOCALE_ID                      0x9003a    // ATTj589882   (\x2A864886F71401043A)
#define  ATT_LOCALITY_NAME                  0x7        // ATTm7        (\x550407)
#define  ATT_LOCALIZED_DESCRIPTION          0x90331    // ATTm590641   (\x2A864886F71401048631)
#define  ATT_LOCALIZATION_DISPLAY_ID        0x90549    // ATTj591177   (\x2A864886F71401048A49)
#define  ATT_LOCATION                       0x900de    // ATTm590046   (\x2A864886F7140104815E)
#define  ATT_LOCK_OUT_OBSERVATION_WINDOW    0x9003d    // ATTq589885   (\x2A864886F71401043D)
#define  ATT_LOCKOUT_DURATION               0x9003c    // ATTq589884   (\x2A864886F71401043C)
#define  ATT_LOCKOUT_THRESHOLD              0x90049    // ATTj589897   (\x2A864886F714010449)
#define  ATT_LOCKOUT_TIME                   0x90296    // ATTq590486   (\x2A864886F71401048516)
#define  ATT_LOGO                           0x160024   // ATTk1441828  (\x6086480186F842030124)
#define  ATT_LOGON_COUNT                    0x900a9    // ATTj589993   (\x2A864886F71401048129)
#define  ATT_LOGON_HOURS                    0x90040    // ATTk589888   (\x2A864886F714010440)
#define  ATT_LOGON_WORKSTATION              0x90041    // ATTk589889   (\x2A864886F714010441)
#define  ATT_LSA_CREATION_TIME              0x90042    // ATTq589890   (\x2A864886F714010442)
#define  ATT_LSA_MODIFIED_COUNT             0x90043    // ATTq589891   (\x2A864886F714010443)
#define  ATT_MACHINE_ARCHITECTURE           0x90044    // ATTj589892   (\x2A864886F714010444)
#define  ATT_MACHINE_PASSWORD_CHANGE_INTERVAL 0x90208    // ATTq590344   (\x2A864886F71401048408)
#define  ATT_MACHINE_ROLE                   0x90047    // ATTj589895   (\x2A864886F714010447)
#define  ATT_MACHINE_WIDE_POLICY            0x901cb    // ATTk590283   (\x2A864886F7140104834B)
#define  ATT_MANAGED_BY                     0x9028d    // ATTb590477   (\x2A864886F7140104850D)
#define  ATT_MANAGED_OBJECTS                0x9028e    // ATTb590478   (\x2A864886F7140104850E)
#define  ATT_MANAGER                        0x15000a   // ATTb1376266  (\x0992268993F22C64010A)
#define  ATT_MAPI_ID                        0x20031    // ATTj131121   (\x2A864886F714010231)
#define  ATT_MARSHALLED_INTERFACE           0x90048    // ATTk589896   (\x2A864886F714010448)
#define  ATT_MASTERED_BY                    0x90581    // ATTb591233   (\x2A864886F71401048B01)
#define  ATT_MAX_PWD_AGE                    0x9004a    // ATTq589898   (\x2A864886F71401044A)
#define  ATT_MAX_RENEW_AGE                  0x9004b    // ATTq589899   (\x2A864886F71401044B)
#define  ATT_MAX_STORAGE                    0x9004c    // ATTq589900   (\x2A864886F71401044C)
#define  ATT_MAX_TICKET_AGE                 0x9004d    // ATTq589901   (\x2A864886F71401044D)
#define  ATT_MAY_CONTAIN                    0x20019    // ATTc131097   (\x2A864886F714010219)
#define  ATT_MEETINGADVERTISESCOPE          0x90246    // ATTm590406   (\x2A864886F71401048446)
#define  ATT_MEETINGAPPLICATION             0x9023d    // ATTm590397   (\x2A864886F7140104843D)
#define  ATT_MEETINGBANDWIDTH               0x9024d    // ATTj590413   (\x2A864886F7140104844D)
#define  ATT_MEETINGBLOB                    0x9024e    // ATTk590414   (\x2A864886F7140104844E)
#define  ATT_MEETINGCONTACTINFO             0x90242    // ATTm590402   (\x2A864886F71401048442)
#define  ATT_MEETINGDESCRIPTION             0x90237    // ATTm590391   (\x2A864886F71401048437)
#define  ATT_MEETINGENDTIME                 0x9024c    // ATTl590412   (\x2A864886F7140104844C)
#define  ATT_MEETINGID                      0x90235    // ATTm590389   (\x2A864886F71401048435)
#define  ATT_MEETINGIP                      0x90244    // ATTm590404   (\x2A864886F71401048444)
#define  ATT_MEETINGISENCRYPTED             0x90249    // ATTm590409   (\x2A864886F71401048449)
#define  ATT_MEETINGKEYWORD                 0x90238    // ATTm590392   (\x2A864886F71401048438)
#define  ATT_MEETINGLANGUAGE                0x9023e    // ATTm590398   (\x2A864886F7140104843E)
#define  ATT_MEETINGLOCATION                0x90239    // ATTm590393   (\x2A864886F71401048439)
#define  ATT_MEETINGMAXPARTICIPANTS         0x90240    // ATTj590400   (\x2A864886F71401048440)
#define  ATT_MEETINGNAME                    0x90236    // ATTm590390   (\x2A864886F71401048436)
#define  ATT_MEETINGORIGINATOR              0x90241    // ATTm590401   (\x2A864886F71401048441)
#define  ATT_MEETINGOWNER                   0x90243    // ATTm590403   (\x2A864886F71401048443)
#define  ATT_MEETINGPROTOCOL                0x9023a    // ATTm590394   (\x2A864886F7140104843A)
#define  ATT_MEETINGRATING                  0x90248    // ATTm590408   (\x2A864886F71401048448)
#define  ATT_MEETINGRECURRENCE              0x9024a    // ATTm590410   (\x2A864886F7140104844A)
#define  ATT_MEETINGSCOPE                   0x90245    // ATTm590405   (\x2A864886F71401048445)
#define  ATT_MEETINGSTARTTIME               0x9024b    // ATTl590411   (\x2A864886F7140104844B)
#define  ATT_MEETINGTYPE                    0x9023b    // ATTm590395   (\x2A864886F7140104843B)
#define  ATT_MEETINGURL                     0x90247    // ATTm590407   (\x2A864886F71401048447)
#define  ATT_MEMBER                         0x1f       // ATTb31       (\x55041F)
#define  ATT_MHS_OR_ADDRESS                 0x9028a    // ATTm590474   (\x2A864886F7140104850A)
#define  ATT_MIN_PWD_AGE                    0x9004e    // ATTq589902   (\x2A864886F71401044E)
#define  ATT_MIN_PWD_LENGTH                 0x9004f    // ATTj589903   (\x2A864886F71401044F)
#define  ATT_MIN_TICKET_AGE                 0x90050    // ATTq589904   (\x2A864886F714010450)
#define  ATT_MODIFIED_COUNT                 0x900a8    // ATTq589992   (\x2A864886F71401048128)
#define  ATT_MODIFIED_COUNT_AT_LAST_PROM    0x90051    // ATTq589905   (\x2A864886F714010451)
#define  ATT_MODIFY_TIME_STAMP              0x190002   // ATTl1638402  (\x551202)
#define  ATT_MONIKER                        0x90052    // ATTk589906   (\x2A864886F714010452)
#define  ATT_MONIKER_DISPLAY_NAME           0x90053    // ATTm589907   (\x2A864886F714010453)
#define  ATT_MOVE_TREE_STATE                0x90519    // ATTk591129   (\x2A864886F71401048A19)
#define  ATT_MS_COM_DEFAULTPARTITIONLINK    0x90593    // ATTb591251   (\x2A864886F71401048B13)
#define  ATT_MS_COM_OBJECTID                0x90594    // ATTk591252   (\x2A864886F71401048B14)
#define  ATT_MS_COM_PARTITIONLINK           0x9058f    // ATTb591247   (\x2A864886F71401048B0F)
#define  ATT_MS_COM_PARTITIONSETLINK        0x90590    // ATTb591248   (\x2A864886F71401048B10)
#define  ATT_MS_COM_USERLINK                0x90591    // ATTb591249   (\x2A864886F71401048B11)
#define  ATT_MS_COM_USERPARTITIONSETLINK    0x90592    // ATTb591250   (\x2A864886F71401048B12)
#define  ATT_MS_DRM_IDENTITY_CERTIFICATE    0x90733    // ATTk591667   (\x2A864886F71401048E33)
#define  ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME 0x906b5    // ATTm591541   (\x2A864886F71401048D35)
#define  ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME 0x906b6    // ATTm591542   (\x2A864886F71401048D36)
#define  ATT_MS_DS_ALL_USERS_TRUST_QUOTA    0x906fd    // ATTj591613   (\x2A864886F71401048D7D)
#define  ATT_MS_DS_ALLOWED_DNS_SUFFIXES     0x906ae    // ATTm591534   (\x2A864886F71401048D2E)
#define  ATT_MS_DS_ALLOWED_TO_DELEGATE_TO   0x906fb    // ATTm591611   (\x2A864886F71401048D7B)
#define  ATT_MS_DS_AUXILIARY_CLASSES        0x905b2    // ATTc591282   (\x2A864886F71401048B32)
#define  ATT_MS_DS_APPROX_IMMED_SUBORDINATES 0x90685    // ATTj591493   (\x2A864886F71401048D05)
#define  ATT_MS_DS_AZ_APPLICATION_DATA      0x9071b    // ATTm591643   (\x2A864886F71401048E1B)
#define  ATT_MS_DS_AZ_APPLICATION_NAME      0x90706    // ATTm591622   (\x2A864886F71401048E06)
#define  ATT_MS_DS_AZ_APPLICATION_VERSION   0x90719    // ATTm591641   (\x2A864886F71401048E19)
#define  ATT_MS_DS_AZ_BIZ_RULE              0x90709    // ATTm591625   (\x2A864886F71401048E09)
#define  ATT_MS_DS_AZ_BIZ_RULE_LANGUAGE     0x9070a    // ATTm591626   (\x2A864886F71401048E0A)
#define  ATT_MS_DS_AZ_CLASS_ID              0x90718    // ATTm591640   (\x2A864886F71401048E18)
#define  ATT_MS_DS_AZ_DOMAIN_TIMEOUT        0x90703    // ATTj591619   (\x2A864886F71401048E03)
#define  ATT_MS_DS_AZ_GENERATE_AUDITS       0x9070d    // ATTi591629   (\x2A864886F71401048E0D)
#define  ATT_MS_DS_AZ_LAST_IMPORTED_BIZ_RULE_PATH 0x9070b    // ATTm591627   (\x2A864886F71401048E0B)
#define  ATT_MS_DS_AZ_LDAP_QUERY            0x90700    // ATTm591616   (\x2A864886F71401048E00)
#define  ATT_MS_DS_AZ_MAJOR_VERSION         0x90720    // ATTj591648   (\x2A864886F71401048E20)
#define  ATT_MS_DS_AZ_MINOR_VERSION         0x90721    // ATTj591649   (\x2A864886F71401048E21)
#define  ATT_MS_DS_AZ_OPERATION_ID          0x90708    // ATTj591624   (\x2A864886F71401048E08)
#define  ATT_MS_DS_AZ_SCOPE_NAME            0x90707    // ATTm591623   (\x2A864886F71401048E07)
#define  ATT_MS_DS_AZ_SCRIPT_ENGINE_CACHE_MAX 0x90704    // ATTj591620   (\x2A864886F71401048E04)
#define  ATT_MS_DS_AZ_SCRIPT_TIMEOUT        0x90705    // ATTj591621   (\x2A864886F71401048E05)
#define  ATT_MS_DS_AZ_TASK_IS_ROLE_DEFINITION 0x9071a    // ATTi591642   (\x2A864886F71401048E1A)
#define  ATT_MS_DS_BEHAVIOR_VERSION         0x905b3    // ATTj591283   (\x2A864886F71401048B33)
#define  ATT_MS_DS_BYTE_ARRAY               0x90727    // ATTk591655   (\x2A864886F71401048E27)
#define  ATT_MS_DS_CACHED_MEMBERSHIP        0x905a1    // ATTk591265   (\x2A864886F71401048B21)
#define  ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP 0x905a2    // ATTq591266   (\x2A864886F71401048B22)
#define  ATT_MS_DS_CONSISTENCY_GUID         0x90550    // ATTk591184   (\x2A864886F71401048A50)
#define  ATT_MS_DS_CONSISTENCY_CHILD_COUNT  0x90551    // ATTj591185   (\x2A864886F71401048A51)
#define  ATT_MS_DS_CREATOR_SID              0x90582    // ATTr591234   (\x2A864886F71401048B02)
#define  ATT_MS_DS_DATE_TIME                0x90728    // ATTl591656   (\x2A864886F71401048E28)
#define  ATT_MS_DS_DEFAULT_QUOTA            0x90736    // ATTj591670   (\x2A864886F71401048E36)
#define  ATT_MS_DS_DNSROOTALIAS             0x906b7    // ATTm591543   (\x2A864886F71401048D37)
#define  ATT_MS_DS_ENTRY_TIME_TO_DIE        0x90656    // ATTl591446   (\x2A864886F71401048C56)
#define  ATT_MS_DS_EXECUTESCRIPTPASSWORD    0x906f7    // ATTk591607   (\x2A864886F71401048D77)
#define  ATT_MS_DS_EXTERNAL_KEY             0x90729    // ATTm591657   (\x2A864886F71401048E29)
#define  ATT_MS_DS_EXTERNAL_STORE           0x9072a    // ATTm591658   (\x2A864886F71401048E2A)
#define  ATT_MS_DS_FILTER_CONTAINERS        0x906a7    // ATTm591527   (\x2A864886F71401048D27)
#define  ATT_MS_DS_HAS_INSTANTIATED_NCS     0x906ad    // ATTh591533   (\x2A864886F71401048D2D)
#define  ATT_MS_DS_HAS_DOMAIN_NCS           0x9071c    // ATTb591644   (\x2A864886F71401048E1C)
#define  ATT_MS_DS_HAS_MASTER_NCS           0x9072c    // ATTb591660   (\x2A864886F71401048E2C)
#define  ATT_MS_DS_INTEGER                  0x9072b    // ATTj591659   (\x2A864886F71401048E2B)
#define  ATT_MS_DS_INTID                    0x906b4    // ATTj591540   (\x2A864886F71401048D34)
#define  ATT_MS_DS_KEYVERSIONNUMBER         0x906f6    // ATTj591606   (\x2A864886F71401048D76)
#define  ATT_MS_DS_LOGON_TIME_SYNC_INTERVAL 0x906f8    // ATTj591608   (\x2A864886F71401048D78)
#define  ATT_MS_DS_MASTERED_BY              0x9072d    // ATTb591661   (\x2A864886F71401048E2D)
#define  ATT_MS_DS_MAX_VALUES               0x90732    // ATTj591666   (\x2A864886F71401048E32)
#define  ATT_MS_DS_MEMBERS_FOR_AZ_ROLE      0x9070e    // ATTb591630   (\x2A864886F71401048E0E)
#define  ATT_MS_DS_MEMBERS_FOR_AZ_ROLE_BL   0x9070f    // ATTb591631   (\x2A864886F71401048E0F)
#define  ATT_MS_DS_NON_MEMBERS              0x90701    // ATTb591617   (\x2A864886F71401048E01)
#define  ATT_MS_DS_NON_MEMBERS_BL           0x90702    // ATTb591618   (\x2A864886F71401048E02)
#define  ATT_MS_DS_TRUST_FOREST_TRUST_INFO  0x906a6    // ATTk591526   (\x2A864886F71401048D26)
#define  ATT_MS_DS_TOMBSTONE_QUOTA_FACTOR   0x90737    // ATTj591671   (\x2A864886F71401048E37)
#define  ATT_MS_DS_TOP_QUOTA_USAGE          0x9073a    // ATTm591674   (\x2A864886F71401048E3A)
#define  ATT_MS_DS_MACHINE_ACCOUNT_QUOTA    0x90583    // ATTj591235   (\x2A864886F71401048B03)
#define  ATT_MS_DS_OBJECT_REFERENCE         0x90730    // ATTb591664   (\x2A864886F71401048E30)
#define  ATT_MS_DS_OBJECT_REFERENCE_BL      0x90731    // ATTb591665   (\x2A864886F71401048E31)
#define  ATT_MS_DS_OPERATIONS_FOR_AZ_ROLE   0x90714    // ATTb591636   (\x2A864886F71401048E14)
#define  ATT_MS_DS_OPERATIONS_FOR_AZ_ROLE_BL 0x90715    // ATTb591637   (\x2A864886F71401048E15)
#define  ATT_MS_DS_OPERATIONS_FOR_AZ_TASK   0x90710    // ATTb591632   (\x2A864886F71401048E10)
#define  ATT_MS_DS_OPERATIONS_FOR_AZ_TASK_BL 0x90711    // ATTb591633   (\x2A864886F71401048E11)
#define  ATT_MS_DS_OTHER_SETTINGS           0x90655    // ATTm591445   (\x2A864886F71401048C55)
#define  ATT_MS_DS_QUOTA_AMOUNT             0x90735    // ATTj591669   (\x2A864886F71401048E35)
#define  ATT_MS_DS_QUOTA_EFFECTIVE          0x90738    // ATTj591672   (\x2A864886F71401048E38)
#define  ATT_MS_DS_QUOTA_TRUSTEE            0x90734    // ATTr591668   (\x2A864886F71401048E34)
#define  ATT_MS_DS_QUOTA_USED               0x90739    // ATTj591673   (\x2A864886F71401048E39)
#define  ATT_MS_DS_NC_REPL_CURSORS          0x906a8    // ATTm591528   (\x2A864886F71401048D28)
#define  ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS 0x906a9    // ATTm591529   (\x2A864886F71401048D29)
#define  ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS 0x906aa    // ATTm591530   (\x2A864886F71401048D2A)
#define  ATT_MS_DS_NC_REPLICA_LOCATIONS     0x9067d    // ATTb591485   (\x2A864886F71401048C7D)
#define  ATT_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES 0x90699    // ATTm591513   (\x2A864886F71401048D19)
#define  ATT_MS_DS_PER_USER_TRUST_QUOTA     0x906fc    // ATTj591612   (\x2A864886F71401048D7C)
#define  ATT_MS_DS_PER_USER_TRUST_TOMBSTONES_QUOTA 0x906fe    // ATTj591614   (\x2A864886F71401048D7E)
#define  ATT_MS_DS_PREFERRED_GC_SITE        0x905a4    // ATTb591268   (\x2A864886F71401048B24)
#define  ATT_MS_DS_REPL_ATTRIBUTE_META_DATA 0x906ab    // ATTm591531   (\x2A864886F71401048D2B)
#define  ATT_MS_DS_REPL_VALUE_META_DATA     0x906ac    // ATTm591532   (\x2A864886F71401048D2C)
#define  ATT_MS_DS_REPLICATES_NC_REASON     0x90580    // ATTh591232   (\x2A864886F71401048B00)
#define  ATT_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY 0x9067f    // ATTj591487   (\x2A864886F71401048C7F)
#define  ATT_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY 0x90680    // ATTj591488   (\x2A864886F71401048D00)
#define  ATT_MS_DS_REPLICATIONEPOCH         0x906b8    // ATTj591544   (\x2A864886F71401048D38)
#define  ATT_MS_DS_RETIRED_REPL_NC_SIGNATURES 0x90722    // ATTk591650   (\x2A864886F71401048E22)
#define  ATT_MS_DS_SCHEMA_EXTENSIONS        0x905a0    // ATTk591264   (\x2A864886F71401048B20)
#define  ATT_MS_DS_SD_REFERENCE_DOMAIN      0x906af    // ATTb591535   (\x2A864886F71401048D2F)
#define  ATT_MS_DS_SECURITY_GROUP_EXTRA_CLASSES 0x90698    // ATTm591512   (\x2A864886F71401048D18)
#define  ATT_MS_DS_SETTINGS                 0x906a1    // ATTm591521   (\x2A864886F71401048D21)
#define  ATT_MS_DS_SITE_AFFINITY            0x905a3    // ATTk591267   (\x2A864886F71401048B23)
#define  ATT_MS_DS_SPN_SUFFIXES             0x906b3    // ATTm591539   (\x2A864886F71401048D33)
#define  ATT_MS_DS_TASKS_FOR_AZ_ROLE        0x90716    // ATTb591638   (\x2A864886F71401048E16)
#define  ATT_MS_DS_TASKS_FOR_AZ_ROLE_BL     0x90717    // ATTb591639   (\x2A864886F71401048E17)
#define  ATT_MS_DS_TASKS_FOR_AZ_TASK        0x90712    // ATTb591634   (\x2A864886F71401048E12)
#define  ATT_MS_DS_TASKS_FOR_AZ_TASK_BL     0x90713    // ATTb591635   (\x2A864886F71401048E13)
#define  ATT_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED 0x905b4    // ATTj591284   (\x2A864886F71401048B34)
#define  ATT_MS_DS_UPDATESCRIPT             0x906b9    // ATTm591545   (\x2A864886F71401048D39)
#define  ATT_MS_EXCH_ASSISTANT_NAME         0x201bc    // ATTm131516   (\x2A864886F7140102833C)
#define  ATT_MS_EXCH_HOUSE_IDENTIFIER       0x20254    // ATTm131668   (\x2A864886F71401028454)
#define  ATT_MS_EXCH_LABELEDURI             0x20251    // ATTm131665   (\x2A864886F71401028451)
#define  ATT_MS_EXCH_OWNER_BL               0x20068    // ATTb131176   (\x2A864886F714010268)
#define  ATT_MS_FRS_HUB_MEMBER              0x9069d    // ATTb591517   (\x2A864886F71401048D1D)
#define  ATT_MS_FRS_TOPOLOGY_PREF           0x9069c    // ATTm591516   (\x2A864886F71401048D1C)
#define  ATT_MS_IEEE_80211_DATA             0x9071d    // ATTk591645   (\x2A864886F71401048E1D)
#define  ATT_MS_IEEE_80211_DATA_TYPE        0x9071e    // ATTj591646   (\x2A864886F71401048E1E)
#define  ATT_MS_IEEE_80211_ID               0x9071f    // ATTm591647   (\x2A864886F71401048E1F)
#define  ATT_MS_IIS_FTP_DIR                 0x906fa    // ATTm591610   (\x2A864886F71401048D7A)
#define  ATT_MS_IIS_FTP_ROOT                0x906f9    // ATTm591609   (\x2A864886F71401048D79)
#define  ATT_MS_PKI_CERT_TEMPLATE_OID       0x9059c    // ATTm591260   (\x2A864886F71401048B1C)
#define  ATT_MS_PKI_CERTIFICATE_APPLICATION_POLICY 0x9068a    // ATTm591498   (\x2A864886F71401048D0A)
#define  ATT_MS_PKI_CERTIFICATE_NAME_FLAG   0x90598    // ATTj591256   (\x2A864886F71401048B18)
#define  ATT_MS_PKI_CERTIFICATE_POLICY      0x9059f    // ATTm591263   (\x2A864886F71401048B1F)
#define  ATT_MS_PKI_ENROLLMENT_FLAG         0x90596    // ATTj591254   (\x2A864886F71401048B16)
#define  ATT_MS_PKI_MINIMAL_KEY_SIZE        0x90599    // ATTj591257   (\x2A864886F71401048B19)
#define  ATT_MS_PKI_OID_ATTRIBUTE           0x90687    // ATTj591495   (\x2A864886F71401048D07)
#define  ATT_MS_PKI_OID_CPS                 0x90688    // ATTm591496   (\x2A864886F71401048D08)
#define  ATT_MS_PKI_OID_LOCALIZEDNAME       0x906b0    // ATTm591536   (\x2A864886F71401048D30)
#define  ATT_MS_PKI_OID_USER_NOTICE         0x90689    // ATTm591497   (\x2A864886F71401048D09)
#define  ATT_MS_PKI_PRIVATE_KEY_FLAG        0x90597    // ATTj591255   (\x2A864886F71401048B17)
#define  ATT_MS_PKI_SUPERSEDE_TEMPLATES     0x9059d    // ATTm591261   (\x2A864886F71401048B1D)
#define  ATT_MS_PKI_TEMPLATE_MINOR_REVISION 0x9059b    // ATTj591259   (\x2A864886F71401048B1B)
#define  ATT_MS_PKI_TEMPLATE_SCHEMA_VERSION 0x9059a    // ATTj591258   (\x2A864886F71401048B1A)
#define  ATT_MS_PKI_RA_APPLICATION_POLICIES 0x9068b    // ATTm591499   (\x2A864886F71401048D0B)
#define  ATT_MS_PKI_RA_POLICIES             0x9059e    // ATTm591262   (\x2A864886F71401048B1E)
#define  ATT_MS_PKI_RA_SIGNATURE            0x90595    // ATTj591253   (\x2A864886F71401048B15)
#define  ATT_MS_RRAS_ATTRIBUTE              0x90374    // ATTm590708   (\x2A864886F71401048674)
#define  ATT_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY 0x90373    // ATTm590707   (\x2A864886F71401048673)
#define  ATT_MS_SQL_NAME                    0x90553    // ATTm591187   (\x2A864886F71401048A53)
#define  ATT_MS_SQL_REGISTEREDOWNER         0x90554    // ATTm591188   (\x2A864886F71401048A54)
#define  ATT_MS_SQL_CONTACT                 0x90555    // ATTm591189   (\x2A864886F71401048A55)
#define  ATT_MS_SQL_LOCATION                0x90556    // ATTm591190   (\x2A864886F71401048A56)
#define  ATT_MS_SQL_MEMORY                  0x90557    // ATTq591191   (\x2A864886F71401048A57)
#define  ATT_MS_SQL_BUILD                   0x90558    // ATTj591192   (\x2A864886F71401048A58)
#define  ATT_MS_SQL_SERVICEACCOUNT          0x90559    // ATTm591193   (\x2A864886F71401048A59)
#define  ATT_MS_SQL_CHARACTERSET            0x9055a    // ATTj591194   (\x2A864886F71401048A5A)
#define  ATT_MS_SQL_SORTORDER               0x9055b    // ATTm591195   (\x2A864886F71401048A5B)
#define  ATT_MS_SQL_UNICODESORTORDER        0x9055c    // ATTj591196   (\x2A864886F71401048A5C)
#define  ATT_MS_SQL_CLUSTERED               0x9055d    // ATTi591197   (\x2A864886F71401048A5D)
#define  ATT_MS_SQL_NAMEDPIPE               0x9055e    // ATTm591198   (\x2A864886F71401048A5E)
#define  ATT_MS_SQL_MULTIPROTOCOL           0x9055f    // ATTm591199   (\x2A864886F71401048A5F)
#define  ATT_MS_SQL_SPX                     0x90560    // ATTm591200   (\x2A864886F71401048A60)
#define  ATT_MS_SQL_TCPIP                   0x90561    // ATTm591201   (\x2A864886F71401048A61)
#define  ATT_MS_SQL_APPLETALK               0x90562    // ATTm591202   (\x2A864886F71401048A62)
#define  ATT_MS_SQL_VINES                   0x90563    // ATTm591203   (\x2A864886F71401048A63)
#define  ATT_MS_SQL_STATUS                  0x90564    // ATTq591204   (\x2A864886F71401048A64)
#define  ATT_MS_SQL_LASTUPDATEDDATE         0x90565    // ATTm591205   (\x2A864886F71401048A65)
#define  ATT_MS_SQL_INFORMATIONURL          0x90566    // ATTm591206   (\x2A864886F71401048A66)
#define  ATT_MS_SQL_CONNECTIONURL           0x90567    // ATTm591207   (\x2A864886F71401048A67)
#define  ATT_MS_SQL_PUBLICATIONURL          0x90568    // ATTm591208   (\x2A864886F71401048A68)
#define  ATT_MS_SQL_GPSLATITUDE             0x90569    // ATTm591209   (\x2A864886F71401048A69)
#define  ATT_MS_SQL_GPSLONGITUDE            0x9056a    // ATTm591210   (\x2A864886F71401048A6A)
#define  ATT_MS_SQL_GPSHEIGHT               0x9056b    // ATTm591211   (\x2A864886F71401048A6B)
#define  ATT_MS_SQL_VERSION                 0x9056c    // ATTm591212   (\x2A864886F71401048A6C)
#define  ATT_MS_SQL_LANGUAGE                0x9056d    // ATTm591213   (\x2A864886F71401048A6D)
#define  ATT_MS_SQL_DESCRIPTION             0x9056e    // ATTm591214   (\x2A864886F71401048A6E)
#define  ATT_MS_SQL_TYPE                    0x9056f    // ATTm591215   (\x2A864886F71401048A6F)
#define  ATT_MS_SQL_INFORMATIONDIRECTORY    0x90570    // ATTi591216   (\x2A864886F71401048A70)
#define  ATT_MS_SQL_DATABASE                0x90571    // ATTm591217   (\x2A864886F71401048A71)
#define  ATT_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION 0x90572    // ATTi591218   (\x2A864886F71401048A72)
#define  ATT_MS_SQL_ALIAS                   0x90573    // ATTm591219   (\x2A864886F71401048A73)
#define  ATT_MS_SQL_SIZE                    0x90574    // ATTq591220   (\x2A864886F71401048A74)
#define  ATT_MS_SQL_CREATIONDATE            0x90575    // ATTm591221   (\x2A864886F71401048A75)
#define  ATT_MS_SQL_LASTBACKUPDATE          0x90576    // ATTm591222   (\x2A864886F71401048A76)
#define  ATT_MS_SQL_LASTDIAGNOSTICDATE      0x90577    // ATTm591223   (\x2A864886F71401048A77)
#define  ATT_MS_SQL_APPLICATIONS            0x90578    // ATTm591224   (\x2A864886F71401048A78)
#define  ATT_MS_SQL_KEYWORDS                0x90579    // ATTm591225   (\x2A864886F71401048A79)
#define  ATT_MS_SQL_PUBLISHER               0x9057a    // ATTm591226   (\x2A864886F71401048A7A)
#define  ATT_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION 0x9057b    // ATTi591227   (\x2A864886F71401048A7B)
#define  ATT_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTION 0x9057c    // ATTi591228   (\x2A864886F71401048A7C)
#define  ATT_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION 0x9057d    // ATTi591229   (\x2A864886F71401048A7D)
#define  ATT_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING 0x9057e    // ATTi591230   (\x2A864886F71401048A7E)
#define  ATT_MS_SQL_THIRDPARTY              0x9057f    // ATTi591231   (\x2A864886F71401048A7F)
#define  ATT_MS_TAPI_CONFERENCE_BLOB        0x906a4    // ATTk591524   (\x2A864886F71401048D24)
#define  ATT_MS_TAPI_IP_ADDRESS             0x906a5    // ATTm591525   (\x2A864886F71401048D25)
#define  ATT_MS_TAPI_PROTOCOL_ID            0x906a3    // ATTm591523   (\x2A864886F71401048D23)
#define  ATT_MS_TAPI_UNIQUE_IDENTIFIER      0x906a2    // ATTm591522   (\x2A864886F71401048D22)
#define  ATT_MS_WMI_AUTHOR                  0x90657    // ATTm591447   (\x2A864886F71401048C57)
#define  ATT_MS_WMI_CHANGEDATE              0x90658    // ATTm591448   (\x2A864886F71401048C58)
#define  ATT_MS_WMI_CLASS                   0x9068c    // ATTm591500   (\x2A864886F71401048D0C)
#define  ATT_MS_WMI_CLASSDEFINITION         0x90659    // ATTm591449   (\x2A864886F71401048C59)
#define  ATT_MS_WMI_CREATIONDATE            0x9065a    // ATTm591450   (\x2A864886F71401048C5A)
#define  ATT_MS_WMI_GENUS                   0x9068d    // ATTj591501   (\x2A864886F71401048D0D)
#define  ATT_MS_WMI_ID                      0x9065b    // ATTm591451   (\x2A864886F71401048C5B)
#define  ATT_MS_WMI_INTDEFAULT              0x9065c    // ATTj591452   (\x2A864886F71401048C5C)
#define  ATT_MS_WMI_INTFLAGS1               0x9068e    // ATTj591502   (\x2A864886F71401048D0E)
#define  ATT_MS_WMI_INTFLAGS2               0x9068f    // ATTj591503   (\x2A864886F71401048D0F)
#define  ATT_MS_WMI_INTFLAGS3               0x90690    // ATTj591504   (\x2A864886F71401048D10)
#define  ATT_MS_WMI_INTFLAGS4               0x90691    // ATTj591505   (\x2A864886F71401048D11)
#define  ATT_MS_WMI_INTMAX                  0x9065d    // ATTj591453   (\x2A864886F71401048C5D)
#define  ATT_MS_WMI_INTMIN                  0x9065e    // ATTj591454   (\x2A864886F71401048C5E)
#define  ATT_MS_WMI_INTVALIDVALUES          0x9065f    // ATTj591455   (\x2A864886F71401048C5F)
#define  ATT_MS_WMI_INT8DEFAULT             0x90660    // ATTq591456   (\x2A864886F71401048C60)
#define  ATT_MS_WMI_INT8MAX                 0x90661    // ATTq591457   (\x2A864886F71401048C61)
#define  ATT_MS_WMI_INT8MIN                 0x90662    // ATTq591458   (\x2A864886F71401048C62)
#define  ATT_MS_WMI_INT8VALIDVALUES         0x90663    // ATTq591459   (\x2A864886F71401048C63)
#define  ATT_MS_WMI_MOF                     0x90666    // ATTm591462   (\x2A864886F71401048C66)
#define  ATT_MS_WMI_NAME                    0x90667    // ATTm591463   (\x2A864886F71401048C67)
#define  ATT_MS_WMI_NORMALIZEDCLASS         0x90668    // ATTm591464   (\x2A864886F71401048C68)
#define  ATT_MS_WMI_PARM1                   0x90692    // ATTm591506   (\x2A864886F71401048D12)
#define  ATT_MS_WMI_PARM2                   0x90693    // ATTm591507   (\x2A864886F71401048D13)
#define  ATT_MS_WMI_PARM3                   0x90694    // ATTm591508   (\x2A864886F71401048D14)
#define  ATT_MS_WMI_PARM4                   0x90695    // ATTm591509   (\x2A864886F71401048D15)
#define  ATT_MS_WMI_PROPERTYNAME            0x90669    // ATTm591465   (\x2A864886F71401048C69)
#define  ATT_MS_WMI_QUERY                   0x9066a    // ATTm591466   (\x2A864886F71401048C6A)
#define  ATT_MS_WMI_QUERYLANGUAGE           0x9066b    // ATTm591467   (\x2A864886F71401048C6B)
#define  ATT_MS_WMI_SCOPEGUID               0x90696    // ATTm591510   (\x2A864886F71401048D16)
#define  ATT_MS_WMI_SOURCEORGANIZATION      0x9066c    // ATTm591468   (\x2A864886F71401048C6C)
#define  ATT_MS_WMI_STRINGDEFAULT           0x90664    // ATTm591460   (\x2A864886F71401048C64)
#define  ATT_MS_WMI_STRINGVALIDVALUES       0x90665    // ATTm591461   (\x2A864886F71401048C65)
#define  ATT_MS_WMI_TARGETCLASS             0x9066d    // ATTm591469   (\x2A864886F71401048C6D)
#define  ATT_MS_WMI_TARGETNAMESPACE         0x9066e    // ATTm591470   (\x2A864886F71401048C6E)
#define  ATT_MS_WMI_TARGETOBJECT            0x9066f    // ATTk591471   (\x2A864886F71401048C6F)
#define  ATT_MS_WMI_TARGETPATH              0x90670    // ATTm591472   (\x2A864886F71401048C70)
#define  ATT_MS_WMI_TARGETTYPE              0x90671    // ATTm591473   (\x2A864886F71401048C71)
#define  ATT_MSCOPE_ID                      0x902cc    // ATTf590540   (\x2A864886F7140104854C)
#define  ATT_MSI_FILE_LIST                  0x9029f    // ATTm590495   (\x2A864886F7140104851F)
#define  ATT_MSI_SCRIPT                     0x9032e    // ATTk590638   (\x2A864886F7140104862E)
#define  ATT_MSI_SCRIPT_NAME                0x9034d    // ATTm590669   (\x2A864886F7140104864D)
#define  ATT_MSI_SCRIPT_PATH                0x9000f    // ATTm589839   (\x2A864886F71401040F)
#define  ATT_MSI_SCRIPT_SIZE                0x9034e    // ATTj590670   (\x2A864886F7140104864E)
#define  ATT_MSMQ_AUTHENTICATE              0x9039b    // ATTi590747   (\x2A864886F7140104871B)
#define  ATT_MSMQ_BASE_PRIORITY             0x90398    // ATTj590744   (\x2A864886F71401048718)
#define  ATT_MSMQ_COMPUTER_TYPE             0x903a5    // ATTe590757   (\x2A864886F71401048725)
#define  ATT_MSMQ_COMPUTER_TYPE_EX          0x90589    // ATTm591241   (\x2A864886F71401048B09)
#define  ATT_MSMQ_COST                      0x903b2    // ATTj590770   (\x2A864886F71401048732)
#define  ATT_MSMQ_CSP_NAME                  0x903ac    // ATTe590764   (\x2A864886F7140104872C)
#define  ATT_MSMQ_DEPENDENT_CLIENT_SERVICE  0x904d7    // ATTi591063   (\x2A864886F71401048957)
#define  ATT_MSMQ_DEPENDENT_CLIENT_SERVICES 0x904ca    // ATTi591050   (\x2A864886F7140104894A)
#define  ATT_MSMQ_DIGESTS                   0x903b4    // ATTk590772   (\x2A864886F71401048734)
#define  ATT_MSMQ_DIGESTS_MIG               0x903c6    // ATTk590790   (\x2A864886F71401048746)
#define  ATT_MSMQ_DS_SERVICE                0x904d6    // ATTi591062   (\x2A864886F71401048956)
#define  ATT_MSMQ_DS_SERVICES               0x904cc    // ATTi591052   (\x2A864886F7140104894C)
#define  ATT_MSMQ_ENCRYPT_KEY               0x903a8    // ATTk590760   (\x2A864886F71401048728)
#define  ATT_MSMQ_FOREIGN                   0x903a6    // ATTi590758   (\x2A864886F71401048726)
#define  ATT_MSMQ_IN_ROUTING_SERVERS        0x903a1    // ATTb590753   (\x2A864886F71401048721)
#define  ATT_MSMQ_INTERVAL1                 0x9051c    // ATTj591132   (\x2A864886F71401048A1C)
#define  ATT_MSMQ_INTERVAL2                 0x9051d    // ATTj591133   (\x2A864886F71401048A1D)
#define  ATT_MSMQ_JOURNAL                   0x90396    // ATTi590742   (\x2A864886F71401048716)
#define  ATT_MSMQ_JOURNAL_QUOTA             0x90399    // ATTj590745   (\x2A864886F71401048719)
#define  ATT_MSMQ_LABEL                     0x9039a    // ATTe590746   (\x2A864886F7140104871A)
#define  ATT_MSMQ_LABEL_EX                  0x90587    // ATTm591239   (\x2A864886F71401048B07)
#define  ATT_MSMQ_LONG_LIVED                0x903ad    // ATTj590765   (\x2A864886F7140104872D)
#define  ATT_MSMQ_MIGRATED                  0x903b8    // ATTi590776   (\x2A864886F71401048738)
#define  ATT_MSMQ_MULTICAST_ADDRESS         0x906b2    // ATTm591538   (\x2A864886F71401048D32)
#define  ATT_MSMQ_NAME_STYLE                0x903ab    // ATTi590763   (\x2A864886F7140104872B)
#define  ATT_MSMQ_NT4_FLAGS                 0x903c4    // ATTj590788   (\x2A864886F71401048744)
#define  ATT_MSMQ_NT4_STUB                  0x903c0    // ATTj590784   (\x2A864886F71401048740)
#define  ATT_MSMQ_OS_TYPE                   0x903a7    // ATTj590759   (\x2A864886F71401048727)
#define  ATT_MSMQ_OUT_ROUTING_SERVERS       0x903a0    // ATTb590752   (\x2A864886F71401048720)
#define  ATT_MSMQ_OWNER_ID                  0x9039d    // ATTk590749   (\x2A864886F7140104871D)
#define  ATT_MSMQ_PREV_SITE_GATES           0x904c9    // ATTb591049   (\x2A864886F71401048949)
#define  ATT_MSMQ_PRIVACY_LEVEL             0x9039c    // ATTj590748   (\x2A864886F7140104871C)
#define  ATT_MSMQ_QM_ID                     0x903b7    // ATTk590775   (\x2A864886F71401048737)
#define  ATT_MSMQ_QUEUE_JOURNAL_QUOTA       0x903c3    // ATTj590787   (\x2A864886F71401048743)
#define  ATT_MSMQ_QUEUE_NAME_EXT            0x904db    // ATTm591067   (\x2A864886F7140104895B)
#define  ATT_MSMQ_QUEUE_QUOTA               0x903c2    // ATTj590786   (\x2A864886F71401048742)
#define  ATT_MSMQ_QUEUE_TYPE                0x90395    // ATTk590741   (\x2A864886F71401048715)
#define  ATT_MSMQ_QUOTA                     0x90397    // ATTj590743   (\x2A864886F71401048717)
#define  ATT_MSMQ_RECIPIENT_FORMATNAME      0x9069f    // ATTm591519   (\x2A864886F71401048D1F)
#define  ATT_MSMQ_ROUTING_SERVICE           0x904d5    // ATTi591061   (\x2A864886F71401048955)
#define  ATT_MSMQ_ROUTING_SERVICES          0x904cb    // ATTi591051   (\x2A864886F7140104894B)
#define  ATT_MSMQ_SECURED_SOURCE            0x906b1    // ATTi591537   (\x2A864886F71401048D31)
#define  ATT_MSMQ_SERVICE_TYPE              0x903a2    // ATTj590754   (\x2A864886F71401048722)
#define  ATT_MSMQ_SERVICES                  0x903b6    // ATTj590774   (\x2A864886F71401048736)
#define  ATT_MSMQ_SIGN_CERTIFICATES         0x903b3    // ATTk590771   (\x2A864886F71401048733)
#define  ATT_MSMQ_SIGN_CERTIFICATES_MIG     0x903c7    // ATTk590791   (\x2A864886F71401048747)
#define  ATT_MSMQ_SIGN_KEY                  0x903a9    // ATTk590761   (\x2A864886F71401048729)
#define  ATT_MSMQ_SITE_1                    0x903af    // ATTb590767   (\x2A864886F7140104872F)
#define  ATT_MSMQ_SITE_2                    0x903b0    // ATTb590768   (\x2A864886F71401048730)
#define  ATT_MSMQ_SITE_FOREIGN              0x903c1    // ATTi590785   (\x2A864886F71401048741)
#define  ATT_MSMQ_SITE_GATES                0x903b1    // ATTb590769   (\x2A864886F71401048731)
#define  ATT_MSMQ_SITE_GATES_MIG            0x9051e    // ATTb591134   (\x2A864886F71401048A1E)
#define  ATT_MSMQ_SITE_ID                   0x903b9    // ATTk590777   (\x2A864886F71401048739)
#define  ATT_MSMQ_SITE_NAME                 0x903c5    // ATTe590789   (\x2A864886F71401048745)
#define  ATT_MSMQ_SITE_NAME_EX              0x90588    // ATTm591240   (\x2A864886F71401048B08)
#define  ATT_MSMQ_SITES                     0x9039f    // ATTk590751   (\x2A864886F7140104871F)
#define  ATT_MSMQ_TRANSACTIONAL             0x9039e    // ATTi590750   (\x2A864886F7140104871E)
#define  ATT_MSMQ_USER_SID                  0x90539    // ATTk591161   (\x2A864886F71401048A39)
#define  ATT_MSMQ_VERSION                   0x903ae    // ATTj590766   (\x2A864886F7140104872E)
#define  ATT_MSNPALLOWDIALIN                0x9045f    // ATTi590943   (\x2A864886F7140104885F)
#define  ATT_MSNPCALLEDSTATIONID            0x90463    // ATTf590947   (\x2A864886F71401048863)
#define  ATT_MSNPCALLINGSTATIONID           0x90464    // ATTf590948   (\x2A864886F71401048864)
#define  ATT_MSNPSAVEDCALLINGSTATIONID      0x9046a    // ATTf590954   (\x2A864886F7140104886A)
#define  ATT_MSRADIUSCALLBACKNUMBER         0x90479    // ATTf590969   (\x2A864886F71401048879)
#define  ATT_MSRADIUSFRAMEDIPADDRESS        0x90481    // ATTj590977   (\x2A864886F71401048901)
#define  ATT_MSRADIUSFRAMEDROUTE            0x90486    // ATTf590982   (\x2A864886F71401048906)
#define  ATT_MSRADIUSSERVICETYPE            0x90493    // ATTj590995   (\x2A864886F71401048913)
#define  ATT_MSRASSAVEDCALLBACKNUMBER       0x904a5    // ATTf591013   (\x2A864886F71401048925)
#define  ATT_MSRASSAVEDFRAMEDIPADDRESS      0x904a6    // ATTj591014   (\x2A864886F71401048926)
#define  ATT_MSRASSAVEDFRAMEDROUTE          0x904a7    // ATTf591015   (\x2A864886F71401048927)
#define  ATT_MUST_CONTAIN                   0x20018    // ATTc131096   (\x2A864886F714010218)
#define  ATT_NAME_SERVICE_FLAGS             0x902f1    // ATTj590577   (\x2A864886F71401048571)
#define  ATT_NC_NAME                        0x20010    // ATTb131088   (\x2A864886F714010210)
#define  ATT_NETBIOS_NAME                   0x90057    // ATTm589911   (\x2A864886F714010457)
#define  ATT_NETBOOT_ALLOW_NEW_CLIENTS      0x90351    // ATTi590673   (\x2A864886F71401048651)
#define  ATT_NETBOOT_ANSWER_ONLY_VALID_CLIENTS 0x90356    // ATTi590678   (\x2A864886F71401048656)
#define  ATT_NETBOOT_ANSWER_REQUESTS        0x90355    // ATTi590677   (\x2A864886F71401048655)
#define  ATT_NETBOOT_CURRENT_CLIENT_COUNT   0x90354    // ATTj590676   (\x2A864886F71401048654)
#define  ATT_NETBOOT_GUID                   0x90167    // ATTk590183   (\x2A864886F71401048267)
#define  ATT_NETBOOT_INITIALIZATION         0x90166    // ATTm590182   (\x2A864886F71401048266)
#define  ATT_NETBOOT_INTELLIMIRROR_OSES     0x90359    // ATTm590681   (\x2A864886F71401048659)
#define  ATT_NETBOOT_LIMIT_CLIENTS          0x90352    // ATTi590674   (\x2A864886F71401048652)
#define  ATT_NETBOOT_LOCALLY_INSTALLED_OSES 0x9035b    // ATTm590683   (\x2A864886F7140104865B)
#define  ATT_NETBOOT_MACHINE_FILE_PATH      0x90169    // ATTm590185   (\x2A864886F71401048269)
#define  ATT_NETBOOT_MAX_CLIENTS            0x90353    // ATTj590675   (\x2A864886F71401048653)
#define  ATT_NETBOOT_MIRROR_DATA_FILE       0x904d9    // ATTm591065   (\x2A864886F71401048959)
#define  ATT_NETBOOT_NEW_MACHINE_NAMING_POLICY 0x90357    // ATTm590679   (\x2A864886F71401048657)
#define  ATT_NETBOOT_NEW_MACHINE_OU         0x90358    // ATTb590680   (\x2A864886F71401048658)
#define  ATT_NETBOOT_SCP_BL                 0x90360    // ATTb590688   (\x2A864886F71401048660)
#define  ATT_NETBOOT_SERVER                 0x9035c    // ATTb590684   (\x2A864886F7140104865C)
#define  ATT_NETBOOT_SIF_FILE               0x904d8    // ATTm591064   (\x2A864886F71401048958)
#define  ATT_NETBOOT_TOOLS                  0x9035a    // ATTm590682   (\x2A864886F7140104865A)
#define  ATT_NETWORK_ADDRESS                0x201cb    // ATTe131531   (\x2A864886F7140102834B)
#define  ATT_NEXT_LEVEL_STORE               0x900d6    // ATTb590038   (\x2A864886F71401048156)
#define  ATT_NEXT_RID                       0x90058    // ATTj589912   (\x2A864886F714010458)
#define  ATT_NON_SECURITY_MEMBER            0x90212    // ATTb590354   (\x2A864886F71401048412)
#define  ATT_NON_SECURITY_MEMBER_BL         0x90213    // ATTb590355   (\x2A864886F71401048413)
#define  ATT_NOTIFICATION_LIST              0x9012f    // ATTb590127   (\x2A864886F7140104822F)
#define  ATT_NT_GROUP_MEMBERS               0x90059    // ATTk589913   (\x2A864886F714010459)
#define  ATT_NT_MIXED_DOMAIN                0x90165    // ATTj590181   (\x2A864886F71401048265)
#define  ATT_NT_PWD_HISTORY                 0x9005e    // ATTk589918   (\x2A864886F71401045E)
#define  ATT_NT_SECURITY_DESCRIPTOR         0x20119    // ATTp131353   (\x2A864886F71401028219)
#define  ATT_OBJ_DIST_NAME                  0x31       // ATTb49       (\x550431)
#define  ATT_OBJECT_CATEGORY                0x9030e    // ATTb590606   (\x2A864886F7140104860E)
#define  ATT_OBJECT_CLASS                   0x0        // ATTc0        (\x550400)
#define  ATT_OBJECT_CLASS_CATEGORY          0x20172    // ATTj131442   (\x2A864886F71401028272)
#define  ATT_OBJECT_CLASSES                 0x180006   // ATTm1572870  (\x551506)
#define  ATT_OBJECT_COUNT                   0x901fa    // ATTj590330   (\x2A864886F7140104837A)
#define  ATT_OBJECT_GUID                    0x90002    // ATTk589826   (\x2A864886F714010402)
#define  ATT_OBJECT_SID                     0x90092    // ATTr589970   (\x2A864886F71401048112)
#define  ATT_OBJECT_VERSION                 0x2004c    // ATTj131148   (\x2A864886F71401024C)
#define  ATT_OEM_INFORMATION                0x90097    // ATTm589975   (\x2A864886F71401048117)
#define  ATT_OM_OBJECT_CLASS                0x200da    // ATTk131290   (\x2A864886F7140102815A)
#define  ATT_OM_SYNTAX                      0x200e7    // ATTj131303   (\x2A864886F71401028167)
#define  ATT_OMT_GUID                       0x901f9    // ATTk590329   (\x2A864886F71401048379)
#define  ATT_OMT_INDX_GUID                  0x9014d    // ATTk590157   (\x2A864886F7140104824D)
#define  ATT_OPERATING_SYSTEM               0x9016b    // ATTm590187   (\x2A864886F7140104826B)
#define  ATT_OPERATING_SYSTEM_HOTFIX        0x9019f    // ATTm590239   (\x2A864886F7140104831F)
#define  ATT_OPERATING_SYSTEM_SERVICE_PACK  0x9016d    // ATTm590189   (\x2A864886F7140104826D)
#define  ATT_OPERATING_SYSTEM_VERSION       0x9016c    // ATTm590188   (\x2A864886F7140104826C)
#define  ATT_OPERATOR_COUNT                 0x90090    // ATTj589968   (\x2A864886F71401048110)
#define  ATT_OPTION_DESCRIPTION             0x902c8    // ATTm590536   (\x2A864886F71401048548)
#define  ATT_OPTIONS                        0x90133    // ATTj590131   (\x2A864886F71401048233)
#define  ATT_OPTIONS_LOCATION               0x902c9    // ATTf590537   (\x2A864886F71401048549)
#define  ATT_ORGANIZATION_NAME              0xa        // ATTm10       (\x55040A)
#define  ATT_ORGANIZATIONAL_UNIT_NAME       0xb        // ATTm11       (\x55040B)
#define  ATT_ORGANIZATIONALSTATUS           0x15002d   // ATTm1376301  (\x0992268993F22C64012D)
#define  ATT_ORIGINAL_DISPLAY_TABLE         0x201bd    // ATTk131517   (\x2A864886F7140102833D)
#define  ATT_ORIGINAL_DISPLAY_TABLE_MSDOS   0x200d6    // ATTk131286   (\x2A864886F71401028156)
#define  ATT_OTHER_LOGIN_WORKSTATIONS       0x9005b    // ATTm589915   (\x2A864886F71401045B)
#define  ATT_OTHER_MAILBOX                  0x9028b    // ATTm590475   (\x2A864886F7140104850B)
#define  ATT_OTHER_NAME                     0x160022   // ATTm1441826  (\x6086480186F842030122)
#define  ATT_OTHER_WELL_KNOWN_OBJECTS       0x9054f    // ATTh591183   (\x2A864886F71401048A4F)
#define  ATT_OWNER                          0x20       // ATTb32       (\x550420)
#define  ATT_PACKAGE_FLAGS                  0x90147    // ATTj590151   (\x2A864886F71401048247)
#define  ATT_PACKAGE_NAME                   0x90146    // ATTm590150   (\x2A864886F71401048246)
#define  ATT_PACKAGE_TYPE                   0x90144    // ATTj590148   (\x2A864886F71401048244)
#define  ATT_PARENT_CA                      0x9022d    // ATTb590381   (\x2A864886F7140104842D)
#define  ATT_PARENT_CA_CERTIFICATE_CHAIN    0x902ad    // ATTk590509   (\x2A864886F7140104852D)
#define  ATT_PARENT_GUID                    0x904c8    // ATTk591048   (\x2A864886F71401048948)
#define  ATT_PARTIAL_ATTRIBUTE_DELETION_LIST 0x90297    // ATTk590487   (\x2A864886F71401048517)
#define  ATT_PARTIAL_ATTRIBUTE_SET          0x90280    // ATTk590464   (\x2A864886F71401048500)
#define  ATT_PEK_KEY_CHANGE_INTERVAL        0x90362    // ATTq590690   (\x2A864886F71401048662)
#define  ATT_PEK_LIST                       0x90361    // ATTk590689   (\x2A864886F71401048661)
#define  ATT_PENDING_CA_CERTIFICATES        0x902b5    // ATTk590517   (\x2A864886F71401048535)
#define  ATT_PENDING_PARENT_CA              0x902b7    // ATTb590519   (\x2A864886F71401048537)
#define  ATT_PER_MSG_DIALOG_DISPLAY_TABLE   0x20145    // ATTk131397   (\x2A864886F71401028245)
#define  ATT_PER_RECIP_DIALOG_DISPLAY_TABLE 0x20146    // ATTk131398   (\x2A864886F71401028246)
#define  ATT_PERSONAL_TITLE                 0x20267    // ATTm131687   (\x2A864886F71401028467)
#define  ATT_PHONE_FAX_OTHER                0x90286    // ATTm590470   (\x2A864886F71401048506)
#define  ATT_PHONE_HOME_OTHER               0x20115    // ATTm131349   (\x2A864886F71401028215)
#define  ATT_PHONE_HOME_PRIMARY             0x150014   // ATTm1376276  (\x0992268993F22C640114)
#define  ATT_PHONE_IP_OTHER                 0x902d2    // ATTm590546   (\x2A864886F71401048552)
#define  ATT_PHONE_IP_PRIMARY               0x902d1    // ATTm590545   (\x2A864886F71401048551)
#define  ATT_PHONE_ISDN_PRIMARY             0x90289    // ATTm590473   (\x2A864886F71401048509)
#define  ATT_PHONE_MOBILE_OTHER             0x90287    // ATTm590471   (\x2A864886F71401048507)
#define  ATT_PHONE_MOBILE_PRIMARY           0x150029   // ATTm1376297  (\x0992268993F22C640129)
#define  ATT_PHONE_OFFICE_OTHER             0x20012    // ATTm131090   (\x2A864886F714010212)
#define  ATT_PHONE_PAGER_OTHER              0x20076    // ATTm131190   (\x2A864886F714010276)
#define  ATT_PHONE_PAGER_PRIMARY            0x15002a   // ATTm1376298  (\x0992268993F22C64012A)
#define  ATT_PHOTO                          0x150007   // ATTk1376263  (\x0992268993F22C640107)
#define  ATT_PHYSICAL_DELIVERY_OFFICE_NAME  0x13       // ATTm19       (\x550413)
#define  ATT_PHYSICAL_LOCATION_OBJECT       0x90202    // ATTb590338   (\x2A864886F71401048402)
#define  ATT_PICTURE                        0x160023   // ATTk1441827  (\x6086480186F842030123)
#define  ATT_PKI_CRITICAL_EXTENSIONS        0x90532    // ATTm591154   (\x2A864886F71401048A32)
#define  ATT_PKI_DEFAULT_CSPS               0x90536    // ATTm591158   (\x2A864886F71401048A36)
#define  ATT_PKI_DEFAULT_KEY_SPEC           0x9052f    // ATTj591151   (\x2A864886F71401048A2F)
#define  ATT_PKI_ENROLLMENT_ACCESS          0x90537    // ATTp591159   (\x2A864886F71401048A37)
#define  ATT_PKI_EXPIRATION_PERIOD          0x90533    // ATTk591155   (\x2A864886F71401048A33)
#define  ATT_PKI_EXTENDED_KEY_USAGE         0x90535    // ATTm591157   (\x2A864886F71401048A35)
#define  ATT_PKI_KEY_USAGE                  0x90530    // ATTk591152   (\x2A864886F71401048A30)
#define  ATT_PKI_MAX_ISSUING_DEPTH          0x90531    // ATTj591153   (\x2A864886F71401048A31)
#define  ATT_PKI_OVERLAP_PERIOD             0x90534    // ATTk591156   (\x2A864886F71401048A34)
#define  ATT_PKT                            0x900ce    // ATTk590030   (\x2A864886F7140104814E)
#define  ATT_PKT_GUID                       0x900cd    // ATTk590029   (\x2A864886F7140104814D)
#define  ATT_POLICY_REPLICATION_FLAGS       0x90279    // ATTj590457   (\x2A864886F71401048479)
#define  ATT_PORT_NAME                      0x900e4    // ATTm590052   (\x2A864886F71401048164)
#define  ATT_POSS_SUPERIORS                 0x20008    // ATTc131080   (\x2A864886F714010208)
#define  ATT_POSSIBLE_INFERIORS             0x90393    // ATTc590739   (\x2A864886F71401048713)
#define  ATT_POST_OFFICE_BOX                0x12       // ATTm18       (\x550412)
#define  ATT_POSTAL_ADDRESS                 0x10       // ATTm16       (\x550410)
#define  ATT_POSTAL_CODE                    0x11       // ATTm17       (\x550411)
#define  ATT_PREFERRED_DELIVERY_METHOD      0x1c       // ATTj28       (\x55041C)
#define  ATT_PREFERREDLANGUAGE              0x160027   // ATTm1441831  (\x6086480186F842030127)
#define  ATT_PREFERRED_OU                   0x90061    // ATTb589921   (\x2A864886F714010461)
#define  ATT_PREFIX_MAP                     0x9021a    // ATTk590362   (\x2A864886F7140104841A)
#define  ATT_PRESENTATION_ADDRESS           0x1d       // ATTn29       (\x55041D)
#define  ATT_PREVIOUS_CA_CERTIFICATES       0x902b4    // ATTk590516   (\x2A864886F71401048534)
#define  ATT_PREVIOUS_PARENT_CA             0x902b6    // ATTb590518   (\x2A864886F71401048536)
#define  ATT_PRIMARY_GROUP_ID               0x90062    // ATTj589922   (\x2A864886F714010462)
#define  ATT_PRIMARY_GROUP_TOKEN            0x90584    // ATTj591236   (\x2A864886F71401048B04)
#define  ATT_PRINT_ATTRIBUTES               0x900f7    // ATTj590071   (\x2A864886F71401048177)
#define  ATT_PRINT_BIN_NAMES                0x900ed    // ATTm590061   (\x2A864886F7140104816D)
#define  ATT_PRINT_COLLATE                  0x900f2    // ATTi590066   (\x2A864886F71401048172)
#define  ATT_PRINT_COLOR                    0x900f3    // ATTi590067   (\x2A864886F71401048173)
#define  ATT_PRINT_DUPLEX_SUPPORTED         0x9051f    // ATTi591135   (\x2A864886F71401048A1F)
#define  ATT_PRINT_END_TIME                 0x900ea    // ATTj590058   (\x2A864886F7140104816A)
#define  ATT_PRINT_FORM_NAME                0x900eb    // ATTm590059   (\x2A864886F7140104816B)
#define  ATT_PRINT_KEEP_PRINTED_JOBS        0x90113    // ATTi590099   (\x2A864886F71401048213)
#define  ATT_PRINT_LANGUAGE                 0x900f6    // ATTm590070   (\x2A864886F71401048176)
#define  ATT_PRINT_MAC_ADDRESS              0x90120    // ATTm590112   (\x2A864886F71401048220)
#define  ATT_PRINT_MAX_COPIES               0x900f1    // ATTj590065   (\x2A864886F71401048171)
#define  ATT_PRINT_MAX_RESOLUTION_SUPPORTED 0x900ee    // ATTj590062   (\x2A864886F7140104816E)
#define  ATT_PRINT_MAX_X_EXTENT             0x90115    // ATTj590101   (\x2A864886F71401048215)
#define  ATT_PRINT_MAX_Y_EXTENT             0x90116    // ATTj590102   (\x2A864886F71401048216)
#define  ATT_PRINT_MEDIA_READY              0x90121    // ATTm590113   (\x2A864886F71401048221)
#define  ATT_PRINT_MEDIA_SUPPORTED          0x9012b    // ATTm590123   (\x2A864886F7140104822B)
#define  ATT_PRINT_MEMORY                   0x9011a    // ATTj590106   (\x2A864886F7140104821A)
#define  ATT_PRINT_MIN_X_EXTENT             0x90117    // ATTj590103   (\x2A864886F71401048217)
#define  ATT_PRINT_MIN_Y_EXTENT             0x90118    // ATTj590104   (\x2A864886F71401048218)
#define  ATT_PRINT_NETWORK_ADDRESS          0x9011f    // ATTm590111   (\x2A864886F7140104821F)
#define  ATT_PRINT_NOTIFY                   0x90110    // ATTm590096   (\x2A864886F71401048210)
#define  ATT_PRINT_NUMBER_UP                0x90122    // ATTj590114   (\x2A864886F71401048222)
#define  ATT_PRINT_ORIENTATIONS_SUPPORTED   0x900f0    // ATTm590064   (\x2A864886F71401048170)
#define  ATT_PRINT_OWNER                    0x9010f    // ATTm590095   (\x2A864886F7140104820F)
#define  ATT_PRINT_PAGES_PER_MINUTE         0x90277    // ATTj590455   (\x2A864886F71401048477)
#define  ATT_PRINT_RATE                     0x9011d    // ATTj590109   (\x2A864886F7140104821D)
#define  ATT_PRINT_RATE_UNIT                0x9011e    // ATTm590110   (\x2A864886F7140104821E)
#define  ATT_PRINT_SEPARATOR_FILE           0x900e6    // ATTm590054   (\x2A864886F71401048166)
#define  ATT_PRINT_SHARE_NAME               0x9010e    // ATTm590094   (\x2A864886F7140104820E)
#define  ATT_PRINT_SPOOLING                 0x90112    // ATTm590098   (\x2A864886F71401048212)
#define  ATT_PRINT_STAPLING_SUPPORTED       0x90119    // ATTi590105   (\x2A864886F71401048219)
#define  ATT_PRINT_START_TIME               0x900e9    // ATTj590057   (\x2A864886F71401048169)
#define  ATT_PRINT_STATUS                   0x90111    // ATTm590097   (\x2A864886F71401048211)
#define  ATT_PRINTER_NAME                   0x9012c    // ATTm590124   (\x2A864886F7140104822C)
#define  ATT_PRIOR_SET_TIME                 0x90063    // ATTq589923   (\x2A864886F714010463)
#define  ATT_PRIOR_VALUE                    0x90064    // ATTk589924   (\x2A864886F714010464)
#define  ATT_PRIORITY                       0x900e7    // ATTj590055   (\x2A864886F71401048167)
#define  ATT_PRIVATE_KEY                    0x90065    // ATTk589925   (\x2A864886F714010465)
#define  ATT_PRIVILEGE_ATTRIBUTES           0x9027c    // ATTj590460   (\x2A864886F7140104847C)
#define  ATT_PRIVILEGE_DISPLAY_NAME         0x9027a    // ATTm590458   (\x2A864886F7140104847A)
#define  ATT_PRIVILEGE_HOLDER               0x9027d    // ATTb590461   (\x2A864886F7140104847D)
#define  ATT_PRIVILEGE_VALUE                0x9027b    // ATTq590459   (\x2A864886F7140104847B)
#define  ATT_PRODUCT_CODE                   0x90332    // ATTk590642   (\x2A864886F71401048632)
#define  ATT_PROFILE_PATH                   0x9008b    // ATTm589963   (\x2A864886F7140104810B)
#define  ATT_PROXIED_OBJECT_NAME            0x904e1    // ATTh591073   (\x2A864886F71401048961)
#define  ATT_PROXY_ADDRESSES                0x200d2    // ATTm131282   (\x2A864886F71401028152)
#define  ATT_PROXY_GENERATION_ENABLED       0x2020b    // ATTi131595   (\x2A864886F7140102840B)
#define  ATT_PROXY_LIFETIME                 0x90067    // ATTq589927   (\x2A864886F714010467)
#define  ATT_PUBLIC_KEY_POLICY              0x901a4    // ATTk590244   (\x2A864886F71401048324)
#define  ATT_PURPORTED_SEARCH               0x90376    // ATTm590710   (\x2A864886F71401048676)
#define  ATT_PWD_HISTORY_LENGTH             0x9005f    // ATTj589919   (\x2A864886F71401045F)
#define  ATT_PWD_LAST_SET                   0x90060    // ATTq589920   (\x2A864886F714010460)
#define  ATT_PWD_PROPERTIES                 0x9005d    // ATTj589917   (\x2A864886F71401045D)
#define  ATT_QUALITY_OF_SERVICE             0x901ca    // ATTj590282   (\x2A864886F7140104834A)
#define  ATT_QUERY_FILTER                   0x9054b    // ATTm591179   (\x2A864886F71401048A4B)
#define  ATT_QUERY_POLICY_BL                0x90260    // ATTb590432   (\x2A864886F71401048460)
#define  ATT_QUERY_POLICY_OBJECT            0x9025f    // ATTb590431   (\x2A864886F7140104845F)
#define  ATT_QUERYPOINT                     0x902a8    // ATTm590504   (\x2A864886F71401048528)
#define  ATT_RANGE_LOWER                    0x20022    // ATTj131106   (\x2A864886F714010222)
#define  ATT_RANGE_UPPER                    0x20023    // ATTj131107   (\x2A864886F714010223)
#define  ATT_RDN                            0x90001    // ATTm589825   (\x2A864886F714010401)
#define  ATT_RDN_ATT_ID                     0x2001a    // ATTc131098   (\x2A864886F71401021A)
#define  ATT_REGISTERED_ADDRESS             0x1a       // ATTk26       (\x55041A)
#define  ATT_REMOTE_SERVER_NAME             0x90069    // ATTm589929   (\x2A864886F714010469)
#define  ATT_REMOTE_SOURCE                  0x9006b    // ATTm589931   (\x2A864886F71401046B)
#define  ATT_REMOTE_SOURCE_TYPE             0x9006c    // ATTj589932   (\x2A864886F71401046C)
#define  ATT_REMOTE_STORAGE_GUID            0x90329    // ATTm590633   (\x2A864886F71401048629)
#define  ATT_REPL_PROPERTY_META_DATA        0x90003    // ATTk589827   (\x2A864886F714010403)
#define  ATT_REPL_TOPOLOGY_STAY_OF_EXECUTION 0x902a5    // ATTj590501   (\x2A864886F71401048525)
#define  ATT_REPL_UPTODATE_VECTOR           0x90004    // ATTk589828   (\x2A864886F714010404)
#define  ATT_REPLICA_SOURCE                 0x9006d    // ATTm589933   (\x2A864886F71401046D)
#define  ATT_REPORTS                        0x201b4    // ATTb131508   (\x2A864886F71401028334)
#define  ATT_REPL_INTERVAL                  0x90538    // ATTj591160   (\x2A864886F71401048A38)
#define  ATT_REPS_FROM                      0x2005b    // ATTk131163   (\x2A864886F71401025B)
#define  ATT_REPS_TO                        0x20053    // ATTk131155   (\x2A864886F714010253)
#define  ATT_REQUIRED_CATEGORIES            0x90141    // ATTk590145   (\x2A864886F71401048241)
#define  ATT_RETIRED_REPL_DSA_SIGNATURES    0x902a1    // ATTk590497   (\x2A864886F71401048521)
#define  ATT_TOKEN_GROUPS                   0x90515    // ATTr591125   (\x2A864886F71401048A15)
#define  ATT_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL 0x9058a    // ATTr591242   (\x2A864886F71401048B0A)
#define  ATT_TOKEN_GROUPS_NO_GC_ACCEPTABLE  0x90517    // ATTr591127   (\x2A864886F71401048A17)
#define  ATT_REVISION                       0x90091    // ATTj589969   (\x2A864886F71401048111)
#define  ATT_RID                            0x90099    // ATTj589977   (\x2A864886F71401048119)
#define  ATT_RID_ALLOCATION_POOL            0x90173    // ATTq590195   (\x2A864886F71401048273)
#define  ATT_RID_AVAILABLE_POOL             0x90172    // ATTq590194   (\x2A864886F71401048272)
#define  ATT_RID_MANAGER_REFERENCE          0x90170    // ATTb590192   (\x2A864886F71401048270)
#define  ATT_RID_NEXT_RID                   0x90176    // ATTj590198   (\x2A864886F71401048276)
#define  ATT_RID_PREVIOUS_ALLOCATION_POOL   0x90174    // ATTq590196   (\x2A864886F71401048274)
#define  ATT_RID_SET_REFERENCES             0x9029d    // ATTb590493   (\x2A864886F7140104851D)
#define  ATT_RID_USED_POOL                  0x90175    // ATTq590197   (\x2A864886F71401048275)
#define  ATT_RIGHTS_GUID                    0x90154    // ATTm590164   (\x2A864886F71401048254)
#define  ATT_ROLE_OCCUPANT                  0x21       // ATTb33       (\x550421)
#define  ATT_ROOMNUMBER                     0x150006   // ATTm1376262  (\x0992268993F22C640106)
#define  ATT_ROOT_TRUST                     0x902a2    // ATTb590498   (\x2A864886F71401048522)
#define  ATT_RPC_NS_ANNOTATION              0x9016e    // ATTm590190   (\x2A864886F7140104826E)
#define  ATT_RPC_NS_BINDINGS                0x90071    // ATTm589937   (\x2A864886F714010471)
#define  ATT_RPC_NS_CODESET                 0x9016f    // ATTm590191   (\x2A864886F7140104826F)
#define  ATT_RPC_NS_ENTRY_FLAGS             0x902f2    // ATTj590578   (\x2A864886F71401048572)
#define  ATT_RPC_NS_GROUP                   0x90072    // ATTm589938   (\x2A864886F714010472)
#define  ATT_RPC_NS_INTERFACE_ID            0x90073    // ATTm589939   (\x2A864886F714010473)
#define  ATT_RPC_NS_OBJECT_ID               0x90138    // ATTm590136   (\x2A864886F71401048238)
#define  ATT_RPC_NS_PRIORITY                0x90075    // ATTj589941   (\x2A864886F714010475)
#define  ATT_RPC_NS_PROFILE_ENTRY           0x90076    // ATTm589942   (\x2A864886F714010476)
#define  ATT_RPC_NS_TRANSFER_SYNTAX         0x9013a    // ATTm590138   (\x2A864886F7140104823A)
#define  ATT_SAM_ACCOUNT_NAME               0x900dd    // ATTm590045   (\x2A864886F7140104815D)
#define  ATT_SAM_ACCOUNT_TYPE               0x9012e    // ATTj590126   (\x2A864886F7140104822E)
#define  ATT_SCHEDULE                       0x900d3    // ATTk590035   (\x2A864886F71401048153)
#define  ATT_SCHEMA_FLAGS_EX                0x90078    // ATTj589944   (\x2A864886F714010478)
#define  ATT_SCHEMA_ID_GUID                 0x90094    // ATTk589972   (\x2A864886F71401048114)
#define  ATT_SCHEMA_INFO                    0x9054e    // ATTk591182   (\x2A864886F71401048A4E)
#define  ATT_SCHEMA_UPDATE                  0x901e1    // ATTl590305   (\x2A864886F71401048361)
#define  ATT_SCHEMA_VERSION                 0x201d7    // ATTj131543   (\x2A864886F71401028357)
#define  ATT_SCOPE_FLAGS                    0x9054a    // ATTj591178   (\x2A864886F71401048A4A)
#define  ATT_SCRIPT_PATH                    0x9003e    // ATTm589886   (\x2A864886F71401043E)
#define  ATT_SD_RIGHTS_EFFECTIVE            0x90518    // ATTj591128   (\x2A864886F71401048A18)
#define  ATT_SEARCH_FLAGS                   0x2014e    // ATTj131406   (\x2A864886F7140102824E)
#define  ATT_SEARCH_GUIDE                   0xe        // ATTk14       (\x55040E)
#define  ATT_SECRETARY                      0x150015   // ATTb1376277  (\x0992268993F22C640115)
#define  ATT_SECURITY_IDENTIFIER            0x90079    // ATTr589945   (\x2A864886F714010479)
#define  ATT_SEE_ALSO                       0x22       // ATTb34       (\x550422)
#define  ATT_SEQ_NOTIFICATION               0x901f8    // ATTj590328   (\x2A864886F71401048378)
#define  ATT_SERIAL_NUMBER                  0x5        // ATTf5        (\x550405)
#define  ATT_SERVER_NAME                    0x900df    // ATTm590047   (\x2A864886F7140104815F)
#define  ATT_SERVER_REFERENCE               0x90203    // ATTb590339   (\x2A864886F71401048403)
#define  ATT_SERVER_REFERENCE_BL            0x90204    // ATTb590340   (\x2A864886F71401048404)
#define  ATT_SERVER_ROLE                    0x9009d    // ATTj589981   (\x2A864886F7140104811D)
#define  ATT_SERVER_STATE                   0x9009a    // ATTj589978   (\x2A864886F7140104811A)
#define  ATT_SERVICE_BINDING_INFORMATION    0x901fe    // ATTm590334   (\x2A864886F7140104837E)
#define  ATT_SERVICE_CLASS_ID               0x9007a    // ATTk589946   (\x2A864886F71401047A)
#define  ATT_SERVICE_CLASS_INFO             0x9007b    // ATTk589947   (\x2A864886F71401047B)
#define  ATT_SERVICE_CLASS_NAME             0x901fd    // ATTm590333   (\x2A864886F7140104837D)
#define  ATT_SERVICE_DNS_NAME               0x90291    // ATTm590481   (\x2A864886F71401048511)
#define  ATT_SERVICE_DNS_NAME_TYPE          0x90293    // ATTm590483   (\x2A864886F71401048513)
#define  ATT_SERVICE_INSTANCE_VERSION       0x900c7    // ATTk590023   (\x2A864886F71401048147)
#define  ATT_SERVICE_PRINCIPAL_NAME         0x90303    // ATTm590595   (\x2A864886F71401048603)
#define  ATT_SETUP_COMMAND                  0x90145    // ATTm590149   (\x2A864886F71401048245)
#define  ATT_SHELL_CONTEXT_MENU             0x90267    // ATTm590439   (\x2A864886F71401048467)
#define  ATT_SHELL_PROPERTY_PAGES           0x90233    // ATTm590387   (\x2A864886F71401048433)
#define  ATT_SHORT_SERVER_NAME              0x904b9    // ATTm591033   (\x2A864886F71401048939)
#define  ATT_SHOW_IN_ADDRESS_BOOK           0x90284    // ATTb590468   (\x2A864886F71401048504)
#define  ATT_SHOW_IN_ADVANCED_VIEW_ONLY     0x200a9    // ATTi131241   (\x2A864886F71401028129)
#define  ATT_SID_HISTORY                    0x90261    // ATTr590433   (\x2A864886F71401048461)
#define  ATT_SIGNATURE_ALGORITHMS           0x90338    // ATTm590648   (\x2A864886F71401048638)
#define  ATT_SITE_GUID                      0x9016a    // ATTk590186   (\x2A864886F7140104826A)
#define  ATT_SITE_LINK_LIST                 0x90336    // ATTb590646   (\x2A864886F71401048636)
#define  ATT_SITE_LIST                      0x90335    // ATTb590645   (\x2A864886F71401048635)
#define  ATT_SITE_OBJECT                    0x90200    // ATTb590336   (\x2A864886F71401048400)
#define  ATT_SITE_OBJECT_BL                 0x90201    // ATTb590337   (\x2A864886F71401048401)
#define  ATT_SITE_SERVER                    0x901ee    // ATTb590318   (\x2A864886F7140104836E)
#define  ATT_SMTP_MAIL_ADDRESS              0x90312    // ATTm590610   (\x2A864886F71401048612)
#define  ATT_SPN_MAPPINGS                   0x90543    // ATTm591171   (\x2A864886F71401048A43)
#define  ATT_STATE_OR_PROVINCE_NAME         0x8        // ATTm8        (\x550408)
#define  ATT_STREET_ADDRESS                 0x9        // ATTm9        (\x550409)
#define  ATT_STRUCTURAL_OBJECT_CLASS        0x180009   // ATTc1572873  (\x551509)
#define  ATT_SUB_CLASS_OF                   0x20015    // ATTc131093   (\x2A864886F714010215)
#define  ATT_SUB_REFS                       0x20007    // ATTb131079   (\x2A864886F714010207)
#define  ATT_SUBSCHEMASUBENTRY              0x19000a   // ATTb1638410  (\x55120A)
#define  ATT_SUPER_SCOPE_DESCRIPTION        0x902c7    // ATTm590535   (\x2A864886F71401048547)
#define  ATT_SUPER_SCOPES                   0x902c6    // ATTf590534   (\x2A864886F71401048546)
#define  ATT_SUPERIOR_DNS_ROOT              0x90214    // ATTm590356   (\x2A864886F71401048414)
#define  ATT_SUPPLEMENTAL_CREDENTIALS       0x9007d    // ATTk589949   (\x2A864886F71401047D)
#define  ATT_SUPPORTED_APPLICATION_CONTEXT  0x1e       // ATTk30       (\x55041E)
#define  ATT_SURNAME                        0x4        // ATTm4        (\x550404)
#define  ATT_SYNC_ATTRIBUTES                0x9029a    // ATTj590490   (\x2A864886F7140104851A)
#define  ATT_SYNC_MEMBERSHIP                0x90299    // ATTb590489   (\x2A864886F71401048519)
#define  ATT_SYNC_WITH_OBJECT               0x90298    // ATTb590488   (\x2A864886F71401048518)
#define  ATT_SYNC_WITH_SID                  0x9029b    // ATTr590491   (\x2A864886F7140104851B)
#define  ATT_SYSTEM_AUXILIARY_CLASS         0x900c6    // ATTc590022   (\x2A864886F71401048146)
#define  ATT_SYSTEM_FLAGS                   0x90177    // ATTj590199   (\x2A864886F71401048277)
#define  ATT_SYSTEM_MAY_CONTAIN             0x900c4    // ATTc590020   (\x2A864886F71401048144)
#define  ATT_SYSTEM_MUST_CONTAIN            0x900c5    // ATTc590021   (\x2A864886F71401048145)
#define  ATT_SYSTEM_ONLY                    0x900aa    // ATTi589994   (\x2A864886F7140104812A)
#define  ATT_SYSTEM_POSS_SUPERIORS          0x900c3    // ATTc590019   (\x2A864886F71401048143)
#define  ATT_TELEPHONE_NUMBER               0x14       // ATTm20       (\x550414)
#define  ATT_TELETEX_TERMINAL_IDENTIFIER    0x16       // ATTk22       (\x550416)
#define  ATT_TELEX_NUMBER                   0x15       // ATTk21       (\x550415)
#define  ATT_TELEX_PRIMARY                  0x90288    // ATTm590472   (\x2A864886F71401048508)
#define  ATT_TEMPLATE_ROOTS                 0x90542    // ATTb591170   (\x2A864886F71401048A42)
#define  ATT_TERMINAL_SERVER                0x90375    // ATTk590709   (\x2A864886F71401048675)
#define  ATT_TEXT_COUNTRY                   0x20083    // ATTm131203   (\x2A864886F71401028103)
#define  ATT_TEXT_ENCODED_OR_ADDRESS        0x150002   // ATTm1376258  (\x0992268993F22C640102)
#define  ATT_TIME_REFRESH                   0x901f7    // ATTq590327   (\x2A864886F71401048377)
#define  ATT_TIME_VOL_CHANGE                0x901f6    // ATTq590326   (\x2A864886F71401048376)
#define  ATT_TITLE                          0xc        // ATTm12       (\x55040C)
#define  ATT_TOMBSTONE_LIFETIME             0x20036    // ATTj131126   (\x2A864886F714010236)
#define  ATT_TRANSPORT_ADDRESS_ATTRIBUTE    0x9037f    // ATTc590719   (\x2A864886F7140104867F)
#define  ATT_TRANSPORT_DLL_NAME             0x90315    // ATTm590613   (\x2A864886F71401048615)
#define  ATT_TRANSPORT_TYPE                 0x90317    // ATTb590615   (\x2A864886F71401048617)
#define  ATT_TREAT_AS_LEAF                  0x90326    // ATTi590630   (\x2A864886F71401048626)
#define  ATT_TREE_NAME                      0x90294    // ATTm590484   (\x2A864886F71401048514)
#define  ATT_TRUST_ATTRIBUTES               0x901d6    // ATTj590294   (\x2A864886F71401048356)
#define  ATT_TRUST_AUTH_INCOMING            0x90081    // ATTk589953   (\x2A864886F71401048101)
#define  ATT_TRUST_AUTH_OUTGOING            0x90087    // ATTk589959   (\x2A864886F71401048107)
#define  ATT_TRUST_DIRECTION                0x90084    // ATTj589956   (\x2A864886F71401048104)
#define  ATT_TRUST_PARENT                   0x901d7    // ATTb590295   (\x2A864886F71401048357)
#define  ATT_TRUST_PARTNER                  0x90085    // ATTm589957   (\x2A864886F71401048105)
#define  ATT_TRUST_POSIX_OFFSET             0x90086    // ATTj589958   (\x2A864886F71401048106)
#define  ATT_TRUST_TYPE                     0x90088    // ATTj589960   (\x2A864886F71401048108)
#define  ATT_UAS_COMPAT                     0x9009b    // ATTj589979   (\x2A864886F7140104811B)
#define  ATT_UID                            0x150001   // ATTm1376257  (\x0992268993F22C640101)
#define  ATT_UNC_NAME                       0x90089    // ATTm589961   (\x2A864886F71401048109)
#define  ATT_UNICODE_PWD                    0x9005a    // ATTk589914   (\x2A864886F71401045A)
#define  ATT_UNIQUEIDENTIFIER               0x15002c   // ATTm1376300  (\x0992268993F22C64012C)
#define  ATT_UNIQUEMEMBER                   0x32       // ATTb50       (\x550432)
#define  ATT_UPGRADE_PRODUCT_CODE           0x9032d    // ATTk590637   (\x2A864886F7140104862D)
#define  ATT_UPN_SUFFIXES                   0x9037a    // ATTm590714   (\x2A864886F7140104867A)
#define  ATT_USER_ACCOUNT_CONTROL           0x90008    // ATTj589832   (\x2A864886F714010408)
#define  ATT_USER_CERT                      0x90285    // ATTk590469   (\x2A864886F71401048505)
#define  ATT_USER_COMMENT                   0x9009c    // ATTm589980   (\x2A864886F7140104811C)
#define  ATT_USER_PARAMETERS                0x9008a    // ATTm589962   (\x2A864886F7140104810A)
#define  ATT_USER_PASSWORD                  0x23       // ATTk35       (\x550423)
#define  ATT_USERCLASS                      0x150008   // ATTm1376264  (\x0992268993F22C640108)
#define  ATT_USERPKCS12                     0x1600d8   // ATTk1442008  (\x6086480186F84203018158)
#define  ATT_USER_PRINCIPAL_NAME            0x90290    // ATTm590480   (\x2A864886F71401048510)
#define  ATT_USER_SHARED_FOLDER             0x902ef    // ATTm590575   (\x2A864886F7140104856F)
#define  ATT_USER_SHARED_FOLDER_OTHER       0x902f0    // ATTm590576   (\x2A864886F71401048570)
#define  ATT_USER_SMIME_CERTIFICATE         0x14008c   // ATTk1310860  (\x6086480186F84203810C)
#define  ATT_USER_WORKSTATIONS              0x90056    // ATTm589910   (\x2A864886F714010456)
#define  ATT_USN_CHANGED                    0x20078    // ATTq131192   (\x2A864886F714010278)
#define  ATT_USN_CREATED                    0x20013    // ATTq131091   (\x2A864886F714010213)
#define  ATT_USN_DSA_LAST_OBJ_REMOVED       0x2010b    // ATTq131339   (\x2A864886F7140102820B)
#define  ATT_USN_INTERSITE                  0x201d5    // ATTj131541   (\x2A864886F71401028355)
#define  ATT_USN_LAST_OBJ_REM               0x20079    // ATTq131193   (\x2A864886F714010279)
#define  ATT_USN_SOURCE                     0x90380    // ATTq590720   (\x2A864886F71401048700)
#define  ATT_VALID_ACCESSES                 0x9054c    // ATTj591180   (\x2A864886F71401048A4C)
#define  ATT_VENDOR                         0x900ff    // ATTm590079   (\x2A864886F7140104817F)
#define  ATT_VERSION_NUMBER                 0x9008d    // ATTj589965   (\x2A864886F7140104810D)
#define  ATT_VERSION_NUMBER_HI              0x90148    // ATTj590152   (\x2A864886F71401048248)
#define  ATT_VERSION_NUMBER_LO              0x90149    // ATTj590153   (\x2A864886F71401048249)
#define  ATT_VOL_TABLE_GUID                 0x90150    // ATTk590160   (\x2A864886F71401048250)
#define  ATT_VOL_TABLE_IDX_GUID             0x9014e    // ATTk590158   (\x2A864886F7140104824E)
#define  ATT_VOLUME_COUNT                   0x901fb    // ATTj590331   (\x2A864886F7140104837B)
#define  ATT_WBEM_PATH                      0x9012d    // ATTm590125   (\x2A864886F7140104822D)
#define  ATT_WELL_KNOWN_OBJECTS             0x9026a    // ATTh590442   (\x2A864886F7140104846A)
#define  ATT_WHEN_CHANGED                   0x20003    // ATTl131075   (\x2A864886F714010203)
#define  ATT_WHEN_CREATED                   0x20002    // ATTl131074   (\x2A864886F714010202)
#define  ATT_WINSOCK_ADDRESSES              0x9008e    // ATTk589966   (\x2A864886F7140104810E)
#define  ATT_WWW_HOME_PAGE                  0x201d0    // ATTm131536   (\x2A864886F71401028350)
#define  ATT_WWW_PAGE_OTHER                 0x902ed    // ATTm590573   (\x2A864886F7140104856D)
#define  ATT_X121_ADDRESS                   0x18       // ATTg24       (\x550418)
#define  ATT_X500UNIQUEIDENTIFIER           0x2d       // ATTk45       (\x55042D)
#define  ATT_X509_CERT                      0x24       // ATTk36       (\x550424)


//--------------------------------------
// CLASS MAPPINGS
//--------------------------------------
#define CLASS_ACS_POLICY                       655497 // 0xa0089    (\x2A864886F71401058109)
#define CLASS_ACS_RESOURCE_LIMITS              655551 // 0xa00bf    (\x2A864886F7140105813F)
#define CLASS_ACS_SUBNET                       655498 // 0xa008a    (\x2A864886F7140105810A)
#define CLASS_ADDRESS_BOOK_CONTAINER           655485 // 0xa007d    (\x2A864886F71401057D)
#define CLASS_ADDRESS_TEMPLATE                 196666 // 0x3003a    (\x2A864886F71401033A)
#define CLASS_APPLICATION_ENTITY                65548 // 0x1000c    (\x55060C)
#define CLASS_APPLICATION_PROCESS               65547 // 0x1000b    (\x55060B)
#define CLASS_APPLICATION_SETTINGS            1507377 // 0x170031   (\x2A864886F7140105B65831)
#define CLASS_APPLICATION_SITE_SETTINGS        655428 // 0xa0044    (\x2A864886F714010544)
#define CLASS_APPLICATION_VERSION              655576 // 0xa00d8    (\x2A864886F71401058158)
#define CLASS_ATTRIBUTE_SCHEMA                 196622 // 0x3000e    (\x2A864886F71401030E)
#define CLASS_BUILTIN_DOMAIN                   655364 // 0xa0004    (\x2A864886F714010504)
#define CLASS_CATEGORY_REGISTRATION            655434 // 0xa004a    (\x2A864886F71401054A)
#define CLASS_CERTIFICATION_AUTHORITY           65552 // 0x10010    (\x550610)
#define CLASS_CLASS_REGISTRATION               655370 // 0xa000a    (\x2A864886F71401050A)
#define CLASS_CLASS_SCHEMA                     196621 // 0x3000d    (\x2A864886F71401030D)
#define CLASS_CLASS_STORE                      655404 // 0xa002c    (\x2A864886F71401052C)
#define CLASS_COM_CONNECTION_POINT             655371 // 0xa000b    (\x2A864886F71401050B)
#define CLASS_COMPUTER                         196638 // 0x3001e    (\x2A864886F71401031E)
#define CLASS_CONFIGURATION                    655372 // 0xa000c    (\x2A864886F71401050C)
#define CLASS_CONNECTION_POINT                 655374 // 0xa000e    (\x2A864886F71401050E)
#define CLASS_CONTACT                          655375 // 0xa000f    (\x2A864886F71401050F)
#define CLASS_CONTAINER                        196631 // 0x30017    (\x2A864886F714010317)
#define CLASS_CONTROL_ACCESS_RIGHT             655437 // 0xa004d    (\x2A864886F71401054D)
#define CLASS_COUNTRY                           65538 // 0x10002    (\x550602)
#define CLASS_CRL_DISTRIBUTION_POINT            65555 // 0x10013    (\x550613)
#define CLASS_CROSS_REF                        196619 // 0x3000b    (\x2A864886F71401030B)
#define CLASS_CROSS_REF_CONTAINER             1507381 // 0x170035   (\x2A864886F7140105B65835)
#define CLASS_DEVICE                            65550 // 0x1000e    (\x55060E)
#define CLASS_DFS_CONFIGURATION                655402 // 0xa002a    (\x2A864886F71401052A)
#define CLASS_DHCP_CLASS                       655492 // 0xa0084    (\x2A864886F71401058104)
#define CLASS_DISPLAY_SPECIFIER                655444 // 0xa0054    (\x2A864886F714010554)
#define CLASS_DISPLAY_TEMPLATE                 196667 // 0x3003b    (\x2A864886F71401033B)
#define CLASS_DMD                              196617 // 0x30009    (\x2A864886F714010309)
#define CLASS_DNS_NODE                         655446 // 0xa0056    (\x2A864886F714010556)
#define CLASS_DNS_ZONE                         655445 // 0xa0055    (\x2A864886F714010555)
#define CLASS_DOMAIN                           655426 // 0xa0042    (\x2A864886F714010542)
#define CLASS_DOMAIN_DNS                       655427 // 0xa0043    (\x2A864886F714010543)
#define CLASS_DOMAIN_POLICY                    655378 // 0xa0012    (\x2A864886F714010512)
#define CLASS_DS_UI_SETTINGS                   655543 // 0xa00b7    (\x2A864886F71401058137)
#define CLASS_DSA                               65549 // 0x1000d    (\x55060D)
#define CLASS_FILE_LINK_TRACKING               655412 // 0xa0034    (\x2A864886F714010534)
#define CLASS_FILE_LINK_TRACKING_ENTRY         655419 // 0xa003b    (\x2A864886F71401053B)
#define CLASS_FOREIGN_SECURITY_PRINCIPAL       655436 // 0xa004c    (\x2A864886F71401054C)
#define CLASS_FT_DFS                           655403 // 0xa002b    (\x2A864886F71401052B)
#define CLASS_GROUP                            655368 // 0xa0008    (\x2A864886F714010508)
#define CLASS_GROUP_OF_NAMES                    65545 // 0x10009    (\x550609)
#define CLASS_GROUPOFUNIQUENAMES                65553 // 0x10011    (\x550611)
#define CLASS_GROUP_POLICY_CONTAINER           655517 // 0xa009d    (\x2A864886F7140105811D)
#define CLASS_INDEX_SERVER_CATALOG             655490 // 0xa0082    (\x2A864886F71401058102)
#define CLASS_INFRASTRUCTURE_UPDATE            655535 // 0xa00af    (\x2A864886F7140105812F)
#define CLASS_INTELLIMIRROR_GROUP              655512 // 0xa0098    (\x2A864886F71401058118)
#define CLASS_INTELLIMIRROR_SCP                655511 // 0xa0097    (\x2A864886F71401058117)
#define CLASS_INTER_SITE_TRANSPORT             655501 // 0xa008d    (\x2A864886F7140105810D)
#define CLASS_INTER_SITE_TRANSPORT_CONTAINER   655500 // 0xa008c    (\x2A864886F7140105810C)
#define CLASS_IPSEC_BASE                      1507384 // 0x170038   (\x2A864886F7140105B65838)
#define CLASS_IPSEC_FILTER                     655478 // 0xa0076    (\x2A864886F714010576)
#define CLASS_IPSEC_ISAKMP_POLICY              655480 // 0xa0078    (\x2A864886F714010578)
#define CLASS_IPSEC_NEGOTIATION_POLICY         655479 // 0xa0077    (\x2A864886F714010577)
#define CLASS_IPSEC_NFA                        655481 // 0xa0079    (\x2A864886F714010579)
#define CLASS_IPSEC_POLICY                     655458 // 0xa0062    (\x2A864886F714010562)
#define CLASS_LEAF                             655380 // 0xa0014    (\x2A864886F714010514)
#define CLASS_LICENSING_SITE_SETTINGS          655438 // 0xa004e    (\x2A864886F71401054E)
#define CLASS_LINK_TRACK_OBJECT_MOVE_TABLE     655451 // 0xa005b    (\x2A864886F71401055B)
#define CLASS_LINK_TRACK_OMT_ENTRY             655453 // 0xa005d    (\x2A864886F71401055D)
#define CLASS_LINK_TRACK_VOL_ENTRY             655452 // 0xa005c    (\x2A864886F71401055C)
#define CLASS_LINK_TRACK_VOLUME_TABLE          655450 // 0xa005a    (\x2A864886F71401055A)
#define CLASS_LOCALITY                          65539 // 0x10003    (\x550603)
#define CLASS_LOST_AND_FOUND                   655499 // 0xa008b    (\x2A864886F7140105810B)
#define CLASS_MAIL_RECIPIENT                   196654 // 0x3002e    (\x2A864886F71401032E)
#define CLASS_MEETING                          655464 // 0xa0068    (\x2A864886F714010568)
#define CLASS_MS_COM_PARTITION                 655553 // 0xa00c1    (\x2A864886F71401058141)
#define CLASS_MS_COM_PARTITIONSET              655554 // 0xa00c2    (\x2A864886F71401058142)
#define CLASS_MS_DS_APP_CONFIGURATION          655580 // 0xa00dc    (\x2A864886F7140105815C)
#define CLASS_MS_DS_APP_DATA                   655601 // 0xa00f1    (\x2A864886F71401058171)
#define CLASS_MS_DS_AZ_ADMIN_MANAGER           655594 // 0xa00ea    (\x2A864886F7140105816A)
#define CLASS_MS_DS_AZ_APPLICATION             655595 // 0xa00eb    (\x2A864886F7140105816B)
#define CLASS_MS_DS_AZ_OPERATION               655596 // 0xa00ec    (\x2A864886F7140105816C)
#define CLASS_MS_DS_AZ_ROLE                    655599 // 0xa00ef    (\x2A864886F7140105816F)
#define CLASS_MS_DS_AZ_SCOPE                   655597 // 0xa00ed    (\x2A864886F7140105816D)
#define CLASS_MS_DS_AZ_TASK                    655598 // 0xa00ee    (\x2A864886F7140105816E)
#define CLASS_MS_DS_QUOTA_CONTAINER            655602 // 0xa00f2    (\x2A864886F71401058172)
#define CLASS_MS_DS_QUOTA_CONTROL              655603 // 0xa00f3    (\x2A864886F71401058173)
#define CLASS_MS_EXCH_CONFIGURATION_CONTAINER   655536 // 0xa00b0    (\x2A864886F71401058130)
#define CLASS_MS_IEEE_80211_POLICY             655600 // 0xa00f0    (\x2A864886F71401058170)
#define CLASS_MS_PKI_ENTERPRISE_OID            655556 // 0xa00c4    (\x2A864886F71401058144)
#define CLASS_MS_PKI_KEY_RECOVERY_AGENT        655555 // 0xa00c3    (\x2A864886F71401058143)
#define CLASS_MS_SQL_SQLSERVER                 655544 // 0xa00b8    (\x2A864886F71401058138)
#define CLASS_MS_SQL_OLAPSERVER                655545 // 0xa00b9    (\x2A864886F71401058139)
#define CLASS_MS_SQL_SQLREPOSITORY             655546 // 0xa00ba    (\x2A864886F7140105813A)
#define CLASS_MS_SQL_SQLPUBLICATION            655547 // 0xa00bb    (\x2A864886F7140105813B)
#define CLASS_MS_SQL_SQLDATABASE               655548 // 0xa00bc    (\x2A864886F7140105813C)
#define CLASS_MS_SQL_OLAPDATABASE              655549 // 0xa00bd    (\x2A864886F7140105813D)
#define CLASS_MS_SQL_OLAPCUBE                  655550 // 0xa00be    (\x2A864886F7140105813E)
#define CLASS_MS_TAPI_RT_CONFERENCE            655581 // 0xa00dd    (\x2A864886F7140105815D)
#define CLASS_MS_TAPI_RT_PERSON                655582 // 0xa00de    (\x2A864886F7140105815E)
#define CLASS_MS_WMI_INTRANGEPARAM             655565 // 0xa00cd    (\x2A864886F7140105814D)
#define CLASS_MS_WMI_INTSETPARAM               655566 // 0xa00ce    (\x2A864886F7140105814E)
#define CLASS_MS_WMI_MERGEABLEPOLICYTEMPLATE   655562 // 0xa00ca    (\x2A864886F7140105814A)
#define CLASS_MS_WMI_OBJECTENCODING            655577 // 0xa00d9    (\x2A864886F71401058159)
#define CLASS_MS_WMI_POLICYTEMPLATE            655560 // 0xa00c8    (\x2A864886F71401058148)
#define CLASS_MS_WMI_POLICYTYPE                655571 // 0xa00d3    (\x2A864886F71401058153)
#define CLASS_MS_WMI_RANGEPARAM                655563 // 0xa00cb    (\x2A864886F7140105814B)
#define CLASS_MS_WMI_REALRANGEPARAM            655569 // 0xa00d1    (\x2A864886F71401058151)
#define CLASS_MS_WMI_RULE                      655574 // 0xa00d6    (\x2A864886F71401058156)
#define CLASS_MS_WMI_SHADOWOBJECT              655572 // 0xa00d4    (\x2A864886F71401058154)
#define CLASS_MS_WMI_SIMPLEPOLICYTEMPLATE      655561 // 0xa00c9    (\x2A864886F71401058149)
#define CLASS_MS_WMI_SOM                       655573 // 0xa00d5    (\x2A864886F71401058155)
#define CLASS_MS_WMI_STRINGSETPARAM            655570 // 0xa00d2    (\x2A864886F71401058152)
#define CLASS_MS_WMI_UINTRANGEPARAM            655567 // 0xa00cf    (\x2A864886F7140105814F)
#define CLASS_MS_WMI_UINTSETPARAM              655568 // 0xa00d0    (\x2A864886F71401058150)
#define CLASS_MS_WMI_UNKNOWNRANGEPARAM         655564 // 0xa00cc    (\x2A864886F7140105814C)
#define CLASS_MS_WMI_WMIGPO                    655575 // 0xa00d7    (\x2A864886F71401058157)
#define CLASS_MSMQ_CONFIGURATION               655522 // 0xa00a2    (\x2A864886F71401058122)
#define CLASS_MSMQ_CUSTOM_RECIPIENT            655578 // 0xa00da    (\x2A864886F7140105815A)
#define CLASS_MSMQ_ENTERPRISE_SETTINGS         655523 // 0xa00a3    (\x2A864886F71401058123)
#define CLASS_MSMQ_GROUP                       655579 // 0xa00db    (\x2A864886F7140105815B)
#define CLASS_MSMQ_MIGRATED_USER               655539 // 0xa00b3    (\x2A864886F71401058133)
#define CLASS_MSMQ_QUEUE                       655521 // 0xa00a1    (\x2A864886F71401058121)
#define CLASS_MSMQ_SETTINGS                    655525 // 0xa00a5    (\x2A864886F71401058125)
#define CLASS_MSMQ_SITE_LINK                   655524 // 0xa00a4    (\x2A864886F71401058124)
#define CLASS_NTDS_CONNECTION                  655431 // 0xa0047    (\x2A864886F714010547)
#define CLASS_NTDS_DSA                        1507375 // 0x17002f   (\x2A864886F7140105B6582F)
#define CLASS_NTDS_SERVICE                     655432 // 0xa0048    (\x2A864886F714010548)
#define CLASS_NTDS_SITE_SETTINGS               655429 // 0xa0045    (\x2A864886F714010545)
#define CLASS_NTFRS_MEMBER                     655513 // 0xa0099    (\x2A864886F71401058119)
#define CLASS_NTFRS_REPLICA_SET                655462 // 0xa0066    (\x2A864886F714010566)
#define CLASS_NTFRS_SETTINGS                   655449 // 0xa0059    (\x2A864886F714010559)
#define CLASS_NTFRS_SUBSCRIBER                 655515 // 0xa009b    (\x2A864886F7140105811B)
#define CLASS_NTFRS_SUBSCRIPTIONS              655514 // 0xa009a    (\x2A864886F7140105811A)
#define CLASS_ORGANIZATION                      65540 // 0x10004    (\x550604)
#define CLASS_ORGANIZATIONAL_PERSON             65543 // 0x10007    (\x550607)
#define CLASS_ORGANIZATIONAL_ROLE               65544 // 0x10008    (\x550608)
#define CLASS_ORGANIZATIONAL_UNIT               65541 // 0x10005    (\x550605)
#define CLASS_PACKAGE_REGISTRATION             655409 // 0xa0031    (\x2A864886F714010531)
#define CLASS_PERSON                            65542 // 0x10006    (\x550606)
#define CLASS_PHYSICAL_LOCATION                655457 // 0xa0061    (\x2A864886F714010561)
#define CLASS_PKI_CERTIFICATE_TEMPLATE         655537 // 0xa00b1    (\x2A864886F71401058131)
#define CLASS_PKI_ENROLLMENT_SERVICE           655538 // 0xa00b2    (\x2A864886F71401058132)
#define CLASS_MS_PKI_PRIVATE_KEY_RECOVERY_AGENT   655583 // 0xa00df    (\x2A864886F7140105815F)
#define CLASS_PRINT_QUEUE                      655383 // 0xa0017    (\x2A864886F714010517)
#define CLASS_QUERY_POLICY                     655466 // 0xa006a    (\x2A864886F71401056A)
#define CLASS_REMOTE_MAIL_RECIPIENT            655384 // 0xa0018    (\x2A864886F714010518)
#define CLASS_REMOTE_STORAGE_SERVICE_POINT     655506 // 0xa0092    (\x2A864886F71401058112)
#define CLASS_RESIDENTIAL_PERSON                65546 // 0x1000a    (\x55060A)
#define CLASS_RID_MANAGER                      655443 // 0xa0053    (\x2A864886F714010553)
#define CLASS_RID_SET                          655489 // 0xa0081    (\x2A864886F71401058101)
#define CLASS_RPC_CONTAINER                    655496 // 0xa0088    (\x2A864886F71401058108)
#define CLASS_RPC_ENTRY                        655387 // 0xa001b    (\x2A864886F71401051B)
#define CLASS_RPC_GROUP                        655440 // 0xa0050    (\x2A864886F714010550)
#define CLASS_RPC_PROFILE                      655442 // 0xa0052    (\x2A864886F714010552)
#define CLASS_RPC_PROFILE_ELEMENT              655386 // 0xa001a    (\x2A864886F71401051A)
#define CLASS_RPC_SERVER                       655441 // 0xa0051    (\x2A864886F714010551)
#define CLASS_RPC_SERVER_ELEMENT               655433 // 0xa0049    (\x2A864886F714010549)
#define CLASS_RRAS_ADMINISTRATION_CONNECTION_POINT   655510 // 0xa0096    (\x2A864886F71401058116)
#define CLASS_RRAS_ADMINISTRATION_DICTIONARY   655516 // 0xa009c    (\x2A864886F7140105811C)
#define CLASS_SAM_DOMAIN                       655363 // 0xa0003    (\x2A864886F714010503)
#define CLASS_SAM_DOMAIN_BASE                  655362 // 0xa0002    (\x2A864886F714010502)
#define CLASS_SAM_SERVER                       655365 // 0xa0005    (\x2A864886F714010505)
#define CLASS_SECRET                           655388 // 0xa001c    (\x2A864886F71401051C)
#define CLASS_SECURITY_OBJECT                  655361 // 0xa0001    (\x2A864886F714010501)
#define CLASS_SECURITY_PRINCIPAL               655366 // 0xa0006    (\x2A864886F714010506)
#define CLASS_SERVER                           655377 // 0xa0011    (\x2A864886F714010511)
#define CLASS_SERVERS_CONTAINER               1507376 // 0x170030   (\x2A864886F7140105B65830)
#define CLASS_SERVICE_ADMINISTRATION_POINT     655454 // 0xa005e    (\x2A864886F71401055E)
#define CLASS_SERVICE_CLASS                    655389 // 0xa001d    (\x2A864886F71401051D)
#define CLASS_SERVICE_CONNECTION_POINT         655486 // 0xa007e    (\x2A864886F71401057E)
#define CLASS_SERVICE_INSTANCE                 655390 // 0xa001e    (\x2A864886F71401051E)
#define CLASS_SITE                             655391 // 0xa001f    (\x2A864886F71401051F)
#define CLASS_SITE_LINK                        655507 // 0xa0093    (\x2A864886F71401058113)
#define CLASS_SITE_LINK_BRIDGE                 655508 // 0xa0094    (\x2A864886F71401058114)
#define CLASS_SITES_CONTAINER                  655467 // 0xa006b    (\x2A864886F71401056B)
#define CLASS_STORAGE                          655393 // 0xa0021    (\x2A864886F714010521)
#define CLASS_SUBNET                           655456 // 0xa0060    (\x2A864886F714010560)
#define CLASS_SUBNET_CONTAINER                 655455 // 0xa005f    (\x2A864886F71401055F)
#define CLASS_SUBSCHEMA                       1703937 // 0x1a0001   (\x551401)
#define CLASS_TOP                               65536 // 0x10000    (\x550600)
#define CLASS_TRUSTED_DOMAIN                   655394 // 0xa0022    (\x2A864886F714010522)
#define CLASS_TYPE_LIBRARY                     655413 // 0xa0035    (\x2A864886F714010535)
#define CLASS_USER                             655369 // 0xa0009    (\x2A864886F714010509)
#define CLASS_VOLUME                           655396 // 0xa0024    (\x2A864886F714010524)


//--------------------------------------
// ATTRIBUTE Syntax
//--------------------------------------
#define  SYNTAX_ID_ACCOUNT_EXPIRES                      16 // 0x41      
#define  SYNTAX_ID_ACCOUNT_NAME_HISTORY                 12 // 0x40      
#define  SYNTAX_ID_ACS_AGGREGATE_TOKEN_RATE_PER_USER       16 // 0x41      
#define  SYNTAX_ID_ACS_ALLOCABLE_RSVP_BANDWIDTH         16 // 0x41      
#define  SYNTAX_ID_ACS_CACHE_TIMEOUT                     9 // 0x2       
#define  SYNTAX_ID_ACS_DIRECTION                         9 // 0x2       
#define  SYNTAX_ID_ACS_DSBM_DEADTIME                     9 // 0x2       
#define  SYNTAX_ID_ACS_DSBM_PRIORITY                     9 // 0x2       
#define  SYNTAX_ID_ACS_DSBM_REFRESH                      9 // 0x2       
#define  SYNTAX_ID_ACS_ENABLE_ACS_SERVICE                8 // 0x1       
#define  SYNTAX_ID_ACS_ENABLE_RSVP_ACCOUNTING            8 // 0x1       
#define  SYNTAX_ID_ACS_ENABLE_RSVP_MESSAGE_LOGGING        8 // 0x1       
#define  SYNTAX_ID_ACS_EVENT_LOG_LEVEL                   9 // 0x2       
#define  SYNTAX_ID_ACS_IDENTITY_NAME                    12 // 0x40      
#define  SYNTAX_ID_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER       16 // 0x41      
#define  SYNTAX_ID_ACS_MAX_DURATION_PER_FLOW             9 // 0x2       
#define  SYNTAX_ID_ACS_MAX_NO_OF_ACCOUNT_FILES           9 // 0x2       
#define  SYNTAX_ID_ACS_MAX_NO_OF_LOG_FILES               9 // 0x2       
#define  SYNTAX_ID_ACS_MAX_PEAK_BANDWIDTH               16 // 0x41      
#define  SYNTAX_ID_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW       16 // 0x41      
#define  SYNTAX_ID_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE        9 // 0x2       
#define  SYNTAX_ID_ACS_MAX_SIZE_OF_RSVP_LOG_FILE         9 // 0x2       
#define  SYNTAX_ID_ACS_MAX_TOKEN_BUCKET_PER_FLOW        16 // 0x41      
#define  SYNTAX_ID_ACS_MAX_TOKEN_RATE_PER_FLOW          16 // 0x41      
#define  SYNTAX_ID_ACS_MAXIMUM_SDU_SIZE                 16 // 0x41      
#define  SYNTAX_ID_ACS_MINIMUM_DELAY_VARIATION          16 // 0x41      
#define  SYNTAX_ID_ACS_MINIMUM_LATENCY                  16 // 0x41      
#define  SYNTAX_ID_ACS_MINIMUM_POLICED_SIZE             16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_MAX_SDU_SIZE        16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_MIN_POLICED_SIZE       16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_PEAK_RATE           16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_TOKEN_SIZE          16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_TX_LIMIT            16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_TX_SIZE             16 // 0x41      
#define  SYNTAX_ID_ACS_PERMISSION_BITS                  16 // 0x41      
#define  SYNTAX_ID_ACS_POLICY_NAME                      12 // 0x40      
#define  SYNTAX_ID_ACS_PRIORITY                          9 // 0x2       
#define  SYNTAX_ID_ACS_RSVP_ACCOUNT_FILES_LOCATION       12 // 0x40      
#define  SYNTAX_ID_ACS_RSVP_LOG_FILES_LOCATION          12 // 0x40      
#define  SYNTAX_ID_ACS_SERVICE_TYPE                      9 // 0x2       
#define  SYNTAX_ID_ACS_TIME_OF_DAY                      12 // 0x40      
#define  SYNTAX_ID_ACS_TOTAL_NO_OF_FLOWS                 9 // 0x2       
#define  SYNTAX_ID_ACS_SERVER_LIST                      12 // 0x40      
#define  SYNTAX_ID_ADDITIONAL_INFORMATION               12 // 0x40      
#define  SYNTAX_ID_ADDITIONAL_TRUSTED_SERVICE_NAMES       12 // 0x40      
#define  SYNTAX_ID_ADDRESS                              12 // 0x40      
#define  SYNTAX_ID_ADDRESS_BOOK_ROOTS                    1 // 0x7f      
#define  SYNTAX_ID_ADDRESS_ENTRY_DISPLAY_TABLE          10 // 0x4       
#define  SYNTAX_ID_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS       10 // 0x4       
#define  SYNTAX_ID_ADDRESS_HOME                         12 // 0x40      
#define  SYNTAX_ID_ADDRESS_SYNTAX                       10 // 0x4       
#define  SYNTAX_ID_ADDRESS_TYPE                          4 // 0x14      
#define  SYNTAX_ID_ADMIN_CONTEXT_MENU                   12 // 0x40      
#define  SYNTAX_ID_ADMIN_COUNT                           9 // 0x2       
#define  SYNTAX_ID_ADMIN_DESCRIPTION                    12 // 0x40      
#define  SYNTAX_ID_ADMIN_DISPLAY_NAME                   12 // 0x40      
#define  SYNTAX_ID_ADMIN_MULTISELECT_PROPERTY_PAGES       12 // 0x40      
#define  SYNTAX_ID_ADMIN_PROPERTY_PAGES                 12 // 0x40      
#define  SYNTAX_ID_ALLOWED_ATTRIBUTES                    2 // 0x6       
#define  SYNTAX_ID_ALLOWED_ATTRIBUTES_EFFECTIVE          2 // 0x6       
#define  SYNTAX_ID_ALLOWED_CHILD_CLASSES                 2 // 0x6       
#define  SYNTAX_ID_ALLOWED_CHILD_CLASSES_EFFECTIVE        2 // 0x6       
#define  SYNTAX_ID_ALT_SECURITY_IDENTITIES              12 // 0x40      
#define  SYNTAX_ID_ANR                                  12 // 0x40      
#define  SYNTAX_ID_APP_SCHEMA_VERSION                    9 // 0x2       
#define  SYNTAX_ID_APPLICATION_NAME                     12 // 0x40      
#define  SYNTAX_ID_APPLIES_TO                           12 // 0x40      
#define  SYNTAX_ID_ASSET_NUMBER                         12 // 0x40      
#define  SYNTAX_ID_ASSISTANT                             1 // 0x7f      
#define  SYNTAX_ID_ASSOC_NT_ACCOUNT                     10 // 0x4       
#define  SYNTAX_ID_ASSOCIATEDDOMAIN                      5 // 0x16      
#define  SYNTAX_ID_ASSOCIATEDNAME                        1 // 0x7f      
#define  SYNTAX_ID_ATTRIBUTECERTIFICATEATTRIBUTE        10 // 0x4       
#define  SYNTAX_ID_ATTRIBUTE_DISPLAY_NAMES              12 // 0x40      
#define  SYNTAX_ID_ATTRIBUTE_ID                          2 // 0x6       
#define  SYNTAX_ID_ATTRIBUTE_SECURITY_GUID              10 // 0x4       
#define  SYNTAX_ID_ATTRIBUTE_SYNTAX                      2 // 0x6       
#define  SYNTAX_ID_ATTRIBUTE_TYPES                      12 // 0x40      
#define  SYNTAX_ID_AUDIO                                10 // 0x4       
#define  SYNTAX_ID_AUDITING_POLICY                      10 // 0x4       
#define  SYNTAX_ID_AUTHENTICATION_OPTIONS                9 // 0x2       
#define  SYNTAX_ID_AUTHORITY_REVOCATION_LIST            10 // 0x4       
#define  SYNTAX_ID_AUXILIARY_CLASS                       2 // 0x6       
#define  SYNTAX_ID_BAD_PASSWORD_TIME                    16 // 0x41      
#define  SYNTAX_ID_BAD_PWD_COUNT                         9 // 0x2       
#define  SYNTAX_ID_BIRTH_LOCATION                       10 // 0x4       
#define  SYNTAX_ID_BRIDGEHEAD_SERVER_LIST_BL             1 // 0x7f      
#define  SYNTAX_ID_BRIDGEHEAD_TRANSPORT_LIST             1 // 0x7f      
#define  SYNTAX_ID_BUILDINGNAME                         12 // 0x40      
#define  SYNTAX_ID_BUILTIN_CREATION_TIME                16 // 0x41      
#define  SYNTAX_ID_BUILTIN_MODIFIED_COUNT               16 // 0x41      
#define  SYNTAX_ID_BUSINESS_CATEGORY                    12 // 0x40      
#define  SYNTAX_ID_BYTES_PER_MINUTE                      9 // 0x2       
#define  SYNTAX_ID_CA_CERTIFICATE                       10 // 0x4       
#define  SYNTAX_ID_CA_CERTIFICATE_DN                    12 // 0x40      
#define  SYNTAX_ID_CA_CONNECT                           12 // 0x40      
#define  SYNTAX_ID_CA_USAGES                            12 // 0x40      
#define  SYNTAX_ID_CA_WEB_URL                           12 // 0x40      
#define  SYNTAX_ID_CAN_UPGRADE_SCRIPT                   12 // 0x40      
#define  SYNTAX_ID_CANONICAL_NAME                       12 // 0x40      
#define  SYNTAX_ID_CARLICENSE                           12 // 0x40      
#define  SYNTAX_ID_CATALOGS                             12 // 0x40      
#define  SYNTAX_ID_CATEGORIES                           12 // 0x40      
#define  SYNTAX_ID_CATEGORY_ID                          10 // 0x4       
#define  SYNTAX_ID_CERTIFICATE_AUTHORITY_OBJECT          1 // 0x7f      
#define  SYNTAX_ID_CERTIFICATE_REVOCATION_LIST          10 // 0x4       
#define  SYNTAX_ID_CERTIFICATE_TEMPLATES                12 // 0x40      
#define  SYNTAX_ID_CLASS_DISPLAY_NAME                   12 // 0x40      
#define  SYNTAX_ID_CODE_PAGE                             9 // 0x2       
#define  SYNTAX_ID_COM_CLASSID                          12 // 0x40      
#define  SYNTAX_ID_COM_CLSID                            12 // 0x40      
#define  SYNTAX_ID_COM_INTERFACEID                      12 // 0x40      
#define  SYNTAX_ID_COM_OTHER_PROG_ID                    12 // 0x40      
#define  SYNTAX_ID_COM_PROGID                           12 // 0x40      
#define  SYNTAX_ID_COM_TREAT_AS_CLASS_ID                12 // 0x40      
#define  SYNTAX_ID_COM_TYPELIB_ID                       12 // 0x40      
#define  SYNTAX_ID_COM_UNIQUE_LIBID                     12 // 0x40      
#define  SYNTAX_ID_COMMENT                              12 // 0x40      
#define  SYNTAX_ID_COMMON_NAME                          12 // 0x40      
#define  SYNTAX_ID_COMPANY                              12 // 0x40      
#define  SYNTAX_ID_CONTENT_INDEXING_ALLOWED              8 // 0x1       
#define  SYNTAX_ID_CONTEXT_MENU                         12 // 0x40      
#define  SYNTAX_ID_CONTROL_ACCESS_RIGHTS                10 // 0x4       
#define  SYNTAX_ID_COST                                  9 // 0x2       
#define  SYNTAX_ID_COUNTRY_CODE                          9 // 0x2       
#define  SYNTAX_ID_COUNTRY_NAME                         12 // 0x40      
#define  SYNTAX_ID_CREATE_DIALOG                        12 // 0x40      
#define  SYNTAX_ID_CREATE_TIME_STAMP                    11 // 0x18      
#define  SYNTAX_ID_CREATE_WIZARD_EXT                    12 // 0x40      
#define  SYNTAX_ID_CREATION_TIME                        16 // 0x41      
#define  SYNTAX_ID_CREATION_WIZARD                      12 // 0x40      
#define  SYNTAX_ID_CREATOR                              12 // 0x40      
#define  SYNTAX_ID_CRL_OBJECT                            1 // 0x7f      
#define  SYNTAX_ID_CRL_PARTITIONED_REVOCATION_LIST       10 // 0x4       
#define  SYNTAX_ID_CROSS_CERTIFICATE_PAIR               10 // 0x4       
#define  SYNTAX_ID_CURR_MACHINE_ID                      10 // 0x4       
#define  SYNTAX_ID_CURRENT_LOCATION                     10 // 0x4       
#define  SYNTAX_ID_CURRENT_PARENT_CA                     1 // 0x7f      
#define  SYNTAX_ID_CURRENT_VALUE                        10 // 0x4       
#define  SYNTAX_ID_DBCS_PWD                             10 // 0x4       
#define  SYNTAX_ID_DEFAULT_CLASS_STORE                   1 // 0x7f      
#define  SYNTAX_ID_DEFAULT_GROUP                         1 // 0x7f      
#define  SYNTAX_ID_DEFAULT_HIDING_VALUE                  8 // 0x1       
#define  SYNTAX_ID_DEFAULT_LOCAL_POLICY_OBJECT           1 // 0x7f      
#define  SYNTAX_ID_DEFAULT_OBJECT_CATEGORY               1 // 0x7f      
#define  SYNTAX_ID_DEFAULT_PRIORITY                      9 // 0x2       
#define  SYNTAX_ID_DEFAULT_SECURITY_DESCRIPTOR          12 // 0x40      
#define  SYNTAX_ID_DELTA_REVOCATION_LIST                10 // 0x4       
#define  SYNTAX_ID_DEPARTMENT                           12 // 0x40      
#define  SYNTAX_ID_DEPARTMENTNUMBER                     12 // 0x40      
#define  SYNTAX_ID_DESCRIPTION                          12 // 0x40      
#define  SYNTAX_ID_DESKTOP_PROFILE                      12 // 0x40      
#define  SYNTAX_ID_DESTINATION_INDICATOR                 5 // 0x13      
#define  SYNTAX_ID_DHCP_CLASSES                         10 // 0x4       
#define  SYNTAX_ID_DHCP_FLAGS                           16 // 0x41      
#define  SYNTAX_ID_DHCP_IDENTIFICATION                  12 // 0x40      
#define  SYNTAX_ID_DHCP_MASK                             5 // 0x13      
#define  SYNTAX_ID_DHCP_MAXKEY                          16 // 0x41      
#define  SYNTAX_ID_DHCP_OBJ_DESCRIPTION                 12 // 0x40      
#define  SYNTAX_ID_DHCP_OBJ_NAME                        12 // 0x40      
#define  SYNTAX_ID_DHCP_OPTIONS                         10 // 0x4       
#define  SYNTAX_ID_DHCP_PROPERTIES                      10 // 0x4       
#define  SYNTAX_ID_DHCP_RANGES                           5 // 0x13      
#define  SYNTAX_ID_DHCP_RESERVATIONS                     5 // 0x13      
#define  SYNTAX_ID_DHCP_SERVERS                          5 // 0x13      
#define  SYNTAX_ID_DHCP_SITES                            5 // 0x13      
#define  SYNTAX_ID_DHCP_STATE                            5 // 0x13      
#define  SYNTAX_ID_DHCP_SUBNETS                          5 // 0x13      
#define  SYNTAX_ID_DHCP_TYPE                             9 // 0x2       
#define  SYNTAX_ID_DHCP_UNIQUE_KEY                      16 // 0x41      
#define  SYNTAX_ID_DHCP_UPDATE_TIME                     16 // 0x41      
#define  SYNTAX_ID_DISPLAY_NAME                         12 // 0x40      
#define  SYNTAX_ID_DISPLAY_NAME_PRINTABLE                5 // 0x13      
#define  SYNTAX_ID_DIT_CONTENT_RULES                    12 // 0x40      
#define  SYNTAX_ID_DIVISION                             12 // 0x40      
#define  SYNTAX_ID_DMD_LOCATION                          1 // 0x7f      
#define  SYNTAX_ID_DMD_NAME                             12 // 0x40      
#define  SYNTAX_ID_DN_REFERENCE_UPDATE                   1 // 0x7f      
#define  SYNTAX_ID_DNS_ALLOW_DYNAMIC                     8 // 0x1       
#define  SYNTAX_ID_DNS_ALLOW_XFR                         8 // 0x1       
#define  SYNTAX_ID_DNS_HOST_NAME                        12 // 0x40      
#define  SYNTAX_ID_DNS_NOTIFY_SECONDARIES                9 // 0x2       
#define  SYNTAX_ID_DNS_PROPERTY                         10 // 0x4       
#define  SYNTAX_ID_DNS_RECORD                           10 // 0x4       
#define  SYNTAX_ID_DNS_ROOT                             12 // 0x40      
#define  SYNTAX_ID_DNS_SECURE_SECONDARIES                9 // 0x2       
#define  SYNTAX_ID_DNS_TOMBSTONED                        8 // 0x1       
#define  SYNTAX_ID_DOCUMENTAUTHOR                        1 // 0x7f      
#define  SYNTAX_ID_DOCUMENTIDENTIFIER                   12 // 0x40      
#define  SYNTAX_ID_DOCUMENTLOCATION                     12 // 0x40      
#define  SYNTAX_ID_DOCUMENTPUBLISHER                    12 // 0x40      
#define  SYNTAX_ID_DOCUMENTTITLE                        12 // 0x40      
#define  SYNTAX_ID_DOCUMENTVERSION                      12 // 0x40      
#define  SYNTAX_ID_DOMAIN_CERTIFICATE_AUTHORITIES        1 // 0x7f      
#define  SYNTAX_ID_DOMAIN_COMPONENT                     12 // 0x40      
#define  SYNTAX_ID_DOMAIN_CROSS_REF                      1 // 0x7f      
#define  SYNTAX_ID_DOMAIN_ID                             1 // 0x7f      
#define  SYNTAX_ID_DOMAIN_IDENTIFIER                     9 // 0x2       
#define  SYNTAX_ID_DOMAIN_POLICY_OBJECT                  1 // 0x7f      
#define  SYNTAX_ID_DOMAIN_POLICY_REFERENCE               1 // 0x7f      
#define  SYNTAX_ID_DOMAIN_REPLICA                       12 // 0x40      
#define  SYNTAX_ID_DOMAIN_WIDE_POLICY                   10 // 0x4       
#define  SYNTAX_ID_DRINK                                12 // 0x40      
#define  SYNTAX_ID_DRIVER_NAME                          12 // 0x40      
#define  SYNTAX_ID_DRIVER_VERSION                        9 // 0x2       
#define  SYNTAX_ID_DS_CORE_PROPAGATION_DATA             11 // 0x18      
#define  SYNTAX_ID_DS_HEURISTICS                        12 // 0x40      
#define  SYNTAX_ID_DS_UI_ADMIN_MAXIMUM                   9 // 0x2       
#define  SYNTAX_ID_DS_UI_ADMIN_NOTIFICATION             12 // 0x40      
#define  SYNTAX_ID_DS_UI_SHELL_MAXIMUM                   9 // 0x2       
#define  SYNTAX_ID_DSA_SIGNATURE                        10 // 0x4       
#define  SYNTAX_ID_DYNAMIC_LDAP_SERVER                   1 // 0x7f      
#define  SYNTAX_ID_E_MAIL_ADDRESSES                     12 // 0x40      
#define  SYNTAX_ID_EFSPOLICY                            10 // 0x4       
#define  SYNTAX_ID_EMPLOYEE_ID                          12 // 0x40      
#define  SYNTAX_ID_EMPLOYEE_NUMBER                      12 // 0x40      
#define  SYNTAX_ID_EMPLOYEE_TYPE                        12 // 0x40      
#define  SYNTAX_ID_ENABLED                               8 // 0x1       
#define  SYNTAX_ID_ENABLED_CONNECTION                    8 // 0x1       
#define  SYNTAX_ID_ENROLLMENT_PROVIDERS                 12 // 0x40      
#define  SYNTAX_ID_ENTRY_TTL                             9 // 0x2       
#define  SYNTAX_ID_EXTENDED_ATTRIBUTE_INFO              12 // 0x40      
#define  SYNTAX_ID_EXTENDED_CHARS_ALLOWED                8 // 0x1       
#define  SYNTAX_ID_EXTENDED_CLASS_INFO                  12 // 0x40      
#define  SYNTAX_ID_EXTENSION_NAME                       12 // 0x40      
#define  SYNTAX_ID_EXTRA_COLUMNS                        12 // 0x40      
#define  SYNTAX_ID_FACSIMILE_TELEPHONE_NUMBER           12 // 0x40      
#define  SYNTAX_ID_FILE_EXT_PRIORITY                    12 // 0x40      
#define  SYNTAX_ID_FLAGS                                 9 // 0x2       
#define  SYNTAX_ID_FLAT_NAME                            12 // 0x40      
#define  SYNTAX_ID_FORCE_LOGOFF                         16 // 0x41      
#define  SYNTAX_ID_FOREIGN_IDENTIFIER                   10 // 0x4       
#define  SYNTAX_ID_FRIENDLY_NAMES                       12 // 0x40      
#define  SYNTAX_ID_FROM_ENTRY                            8 // 0x1       
#define  SYNTAX_ID_FROM_SERVER                           1 // 0x7f      
#define  SYNTAX_ID_FRS_COMPUTER_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_FRS_COMPUTER_REFERENCE_BL             1 // 0x7f      
#define  SYNTAX_ID_FRS_CONTROL_DATA_CREATION            12 // 0x40      
#define  SYNTAX_ID_FRS_CONTROL_INBOUND_BACKLOG          12 // 0x40      
#define  SYNTAX_ID_FRS_CONTROL_OUTBOUND_BACKLOG         12 // 0x40      
#define  SYNTAX_ID_FRS_DIRECTORY_FILTER                 12 // 0x40      
#define  SYNTAX_ID_FRS_DS_POLL                           9 // 0x2       
#define  SYNTAX_ID_FRS_EXTENSIONS                       10 // 0x4       
#define  SYNTAX_ID_FRS_FAULT_CONDITION                  12 // 0x40      
#define  SYNTAX_ID_FRS_FILE_FILTER                      12 // 0x40      
#define  SYNTAX_ID_FRS_FLAGS                             9 // 0x2       
#define  SYNTAX_ID_FRS_LEVEL_LIMIT                       9 // 0x2       
#define  SYNTAX_ID_FRS_MEMBER_REFERENCE                  1 // 0x7f      
#define  SYNTAX_ID_FRS_MEMBER_REFERENCE_BL               1 // 0x7f      
#define  SYNTAX_ID_FRS_PARTNER_AUTH_LEVEL                9 // 0x2       
#define  SYNTAX_ID_FRS_PRIMARY_MEMBER                    1 // 0x7f      
#define  SYNTAX_ID_FRS_REPLICA_SET_GUID                 10 // 0x4       
#define  SYNTAX_ID_FRS_REPLICA_SET_TYPE                  9 // 0x2       
#define  SYNTAX_ID_FRS_ROOT_PATH                        12 // 0x40      
#define  SYNTAX_ID_FRS_ROOT_SECURITY                    15 // 0x42      
#define  SYNTAX_ID_FRS_SERVICE_COMMAND                  12 // 0x40      
#define  SYNTAX_ID_FRS_SERVICE_COMMAND_STATUS           12 // 0x40      
#define  SYNTAX_ID_FRS_STAGING_PATH                     12 // 0x40      
#define  SYNTAX_ID_FRS_TIME_LAST_COMMAND                11 // 0x17      
#define  SYNTAX_ID_FRS_TIME_LAST_CONFIG_CHANGE          11 // 0x17      
#define  SYNTAX_ID_FRS_UPDATE_TIMEOUT                    9 // 0x2       
#define  SYNTAX_ID_FRS_VERSION                          12 // 0x40      
#define  SYNTAX_ID_FRS_VERSION_GUID                     10 // 0x4       
#define  SYNTAX_ID_FRS_WORKING_PATH                     12 // 0x40      
#define  SYNTAX_ID_FSMO_ROLE_OWNER                       1 // 0x7f      
#define  SYNTAX_ID_GARBAGE_COLL_PERIOD                   9 // 0x2       
#define  SYNTAX_ID_GENERATED_CONNECTION                  8 // 0x1       
#define  SYNTAX_ID_GENERATION_QUALIFIER                 12 // 0x40      
#define  SYNTAX_ID_GIVEN_NAME                           12 // 0x40      
#define  SYNTAX_ID_GLOBAL_ADDRESS_LIST                   1 // 0x7f      
#define  SYNTAX_ID_GOVERNS_ID                            2 // 0x6       
#define  SYNTAX_ID_GP_LINK                              12 // 0x40      
#define  SYNTAX_ID_GP_OPTIONS                            9 // 0x2       
#define  SYNTAX_ID_GPC_FILE_SYS_PATH                    12 // 0x40      
#define  SYNTAX_ID_GPC_FUNCTIONALITY_VERSION             9 // 0x2       
#define  SYNTAX_ID_GPC_MACHINE_EXTENSION_NAMES          12 // 0x40      
#define  SYNTAX_ID_GPC_USER_EXTENSION_NAMES             12 // 0x40      
#define  SYNTAX_ID_GPC_WQL_FILTER                       12 // 0x40      
#define  SYNTAX_ID_GROUP_ATTRIBUTES                      9 // 0x2       
#define  SYNTAX_ID_GROUP_MEMBERSHIP_SAM                 10 // 0x4       
#define  SYNTAX_ID_GROUP_PRIORITY                       12 // 0x40      
#define  SYNTAX_ID_GROUP_TYPE                            9 // 0x2       
#define  SYNTAX_ID_GROUPS_TO_IGNORE                     12 // 0x40      
#define  SYNTAX_ID_HAS_MASTER_NCS                        1 // 0x7f      
#define  SYNTAX_ID_HAS_PARTIAL_REPLICA_NCS               1 // 0x7f      
#define  SYNTAX_ID_HELP_DATA16                          10 // 0x4       
#define  SYNTAX_ID_HELP_DATA32                          10 // 0x4       
#define  SYNTAX_ID_HELP_FILE_NAME                       12 // 0x40      
#define  SYNTAX_ID_HIDE_FROM_AB                          8 // 0x1       
#define  SYNTAX_ID_HOME_DIRECTORY                       12 // 0x40      
#define  SYNTAX_ID_HOME_DRIVE                           12 // 0x40      
#define  SYNTAX_ID_HOUSEIDENTIFIER                      12 // 0x40      
#define  SYNTAX_ID_HOST                                 12 // 0x40      
#define  SYNTAX_ID_ICON_PATH                            12 // 0x40      
#define  SYNTAX_ID_IMPLEMENTED_CATEGORIES               10 // 0x4       
#define  SYNTAX_ID_INDEXEDSCOPES                        12 // 0x40      
#define  SYNTAX_ID_INITIAL_AUTH_INCOMING                12 // 0x40      
#define  SYNTAX_ID_INITIAL_AUTH_OUTGOING                12 // 0x40      
#define  SYNTAX_ID_INITIALS                             12 // 0x40      
#define  SYNTAX_ID_INSTALL_UI_LEVEL                      9 // 0x2       
#define  SYNTAX_ID_INSTANCE_TYPE                         9 // 0x2       
#define  SYNTAX_ID_INTER_SITE_TOPOLOGY_FAILOVER          9 // 0x2       
#define  SYNTAX_ID_INTER_SITE_TOPOLOGY_GENERATOR         1 // 0x7f      
#define  SYNTAX_ID_INTER_SITE_TOPOLOGY_RENEW             9 // 0x2       
#define  SYNTAX_ID_INTERNATIONAL_ISDN_NUMBER             6 // 0x12      
#define  SYNTAX_ID_INVOCATION_ID                        10 // 0x4       
#define  SYNTAX_ID_IPSEC_DATA                           10 // 0x4       
#define  SYNTAX_ID_IPSEC_DATA_TYPE                       9 // 0x2       
#define  SYNTAX_ID_IPSEC_FILTER_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_IPSEC_ID                             12 // 0x40      
#define  SYNTAX_ID_IPSEC_ISAKMP_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_IPSEC_NAME                           12 // 0x40      
#define  SYNTAX_ID_IPSEC_NEGOTIATION_POLICY_ACTION       12 // 0x40      
#define  SYNTAX_ID_IPSEC_NEGOTIATION_POLICY_REFERENCE        1 // 0x7f      
#define  SYNTAX_ID_IPSEC_NEGOTIATION_POLICY_TYPE        12 // 0x40      
#define  SYNTAX_ID_IPSEC_NFA_REFERENCE                   1 // 0x7f      
#define  SYNTAX_ID_IPSEC_OWNERS_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_IPSEC_POLICY_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_IS_CRITICAL_SYSTEM_OBJECT             8 // 0x1       
#define  SYNTAX_ID_IS_DEFUNCT                            8 // 0x1       
#define  SYNTAX_ID_IS_DELETED                            8 // 0x1       
#define  SYNTAX_ID_IS_EPHEMERAL                          8 // 0x1       
#define  SYNTAX_ID_IS_MEMBER_OF_DL                       1 // 0x7f      
#define  SYNTAX_ID_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET        8 // 0x1       
#define  SYNTAX_ID_IS_PRIVILEGE_HOLDER                   1 // 0x7f      
#define  SYNTAX_ID_IS_SINGLE_VALUED                      8 // 0x1       
#define  SYNTAX_ID_JPEGPHOTO                            10 // 0x4       
#define  SYNTAX_ID_KEYWORDS                             12 // 0x40      
#define  SYNTAX_ID_KNOWLEDGE_INFORMATION                 4 // 0x14      
#define  SYNTAX_ID_LABELEDURI                           12 // 0x40      
#define  SYNTAX_ID_LAST_BACKUP_RESTORATION_TIME         16 // 0x41      
#define  SYNTAX_ID_LAST_CONTENT_INDEXED                 16 // 0x41      
#define  SYNTAX_ID_LAST_KNOWN_PARENT                     1 // 0x7f      
#define  SYNTAX_ID_LAST_LOGOFF                          16 // 0x41      
#define  SYNTAX_ID_LAST_LOGON                           16 // 0x41      
#define  SYNTAX_ID_LAST_LOGON_TIMESTAMP                 16 // 0x41      
#define  SYNTAX_ID_LAST_SET_TIME                        16 // 0x41      
#define  SYNTAX_ID_LAST_UPDATE_SEQUENCE                 12 // 0x40      
#define  SYNTAX_ID_LDAP_ADMIN_LIMITS                    12 // 0x40      
#define  SYNTAX_ID_LDAP_DISPLAY_NAME                    12 // 0x40      
#define  SYNTAX_ID_LDAP_IPDENY_LIST                     10 // 0x4       
#define  SYNTAX_ID_LEGACY_EXCHANGE_DN                    4 // 0x14      
#define  SYNTAX_ID_LINK_ID                               9 // 0x2       
#define  SYNTAX_ID_LINK_TRACK_SECRET                    10 // 0x4       
#define  SYNTAX_ID_LM_PWD_HISTORY                       10 // 0x4       
#define  SYNTAX_ID_LOCAL_POLICY_FLAGS                    9 // 0x2       
#define  SYNTAX_ID_LOCAL_POLICY_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_LOCALE_ID                             9 // 0x2       
#define  SYNTAX_ID_LOCALITY_NAME                        12 // 0x40      
#define  SYNTAX_ID_LOCALIZED_DESCRIPTION                12 // 0x40      
#define  SYNTAX_ID_LOCALIZATION_DISPLAY_ID               9 // 0x2       
#define  SYNTAX_ID_LOCATION                             12 // 0x40      
#define  SYNTAX_ID_LOCK_OUT_OBSERVATION_WINDOW          16 // 0x41      
#define  SYNTAX_ID_LOCKOUT_DURATION                     16 // 0x41      
#define  SYNTAX_ID_LOCKOUT_THRESHOLD                     9 // 0x2       
#define  SYNTAX_ID_LOCKOUT_TIME                         16 // 0x41      
#define  SYNTAX_ID_LOGO                                 10 // 0x4       
#define  SYNTAX_ID_LOGON_COUNT                           9 // 0x2       
#define  SYNTAX_ID_LOGON_HOURS                          10 // 0x4       
#define  SYNTAX_ID_LOGON_WORKSTATION                    10 // 0x4       
#define  SYNTAX_ID_LSA_CREATION_TIME                    16 // 0x41      
#define  SYNTAX_ID_LSA_MODIFIED_COUNT                   16 // 0x41      
#define  SYNTAX_ID_MACHINE_ARCHITECTURE                  9 // 0xa       
#define  SYNTAX_ID_MACHINE_PASSWORD_CHANGE_INTERVAL       16 // 0x41      
#define  SYNTAX_ID_MACHINE_ROLE                          9 // 0xa       
#define  SYNTAX_ID_MACHINE_WIDE_POLICY                  10 // 0x4       
#define  SYNTAX_ID_MANAGED_BY                            1 // 0x7f      
#define  SYNTAX_ID_MANAGED_OBJECTS                       1 // 0x7f      
#define  SYNTAX_ID_MANAGER                               1 // 0x7f      
#define  SYNTAX_ID_MAPI_ID                               9 // 0x2       
#define  SYNTAX_ID_MARSHALLED_INTERFACE                 10 // 0x4       
#define  SYNTAX_ID_MASTERED_BY                           1 // 0x7f      
#define  SYNTAX_ID_MAX_PWD_AGE                          16 // 0x41      
#define  SYNTAX_ID_MAX_RENEW_AGE                        16 // 0x41      
#define  SYNTAX_ID_MAX_STORAGE                          16 // 0x41      
#define  SYNTAX_ID_MAX_TICKET_AGE                       16 // 0x41      
#define  SYNTAX_ID_MAY_CONTAIN                           2 // 0x6       
#define  SYNTAX_ID_MEETINGADVERTISESCOPE                12 // 0x40      
#define  SYNTAX_ID_MEETINGAPPLICATION                   12 // 0x40      
#define  SYNTAX_ID_MEETINGBANDWIDTH                      9 // 0x2       
#define  SYNTAX_ID_MEETINGBLOB                          10 // 0x4       
#define  SYNTAX_ID_MEETINGCONTACTINFO                   12 // 0x40      
#define  SYNTAX_ID_MEETINGDESCRIPTION                   12 // 0x40      
#define  SYNTAX_ID_MEETINGENDTIME                       11 // 0x17      
#define  SYNTAX_ID_MEETINGID                            12 // 0x40      
#define  SYNTAX_ID_MEETINGIP                            12 // 0x40      
#define  SYNTAX_ID_MEETINGISENCRYPTED                   12 // 0x40      
#define  SYNTAX_ID_MEETINGKEYWORD                       12 // 0x40      
#define  SYNTAX_ID_MEETINGLANGUAGE                      12 // 0x40      
#define  SYNTAX_ID_MEETINGLOCATION                      12 // 0x40      
#define  SYNTAX_ID_MEETINGMAXPARTICIPANTS                9 // 0x2       
#define  SYNTAX_ID_MEETINGNAME                          12 // 0x40      
#define  SYNTAX_ID_MEETINGORIGINATOR                    12 // 0x40      
#define  SYNTAX_ID_MEETINGOWNER                         12 // 0x40      
#define  SYNTAX_ID_MEETINGPROTOCOL                      12 // 0x40      
#define  SYNTAX_ID_MEETINGRATING                        12 // 0x40      
#define  SYNTAX_ID_MEETINGRECURRENCE                    12 // 0x40      
#define  SYNTAX_ID_MEETINGSCOPE                         12 // 0x40      
#define  SYNTAX_ID_MEETINGSTARTTIME                     11 // 0x17      
#define  SYNTAX_ID_MEETINGTYPE                          12 // 0x40      
#define  SYNTAX_ID_MEETINGURL                           12 // 0x40      
#define  SYNTAX_ID_MEMBER                                1 // 0x7f      
#define  SYNTAX_ID_MHS_OR_ADDRESS                       12 // 0x40      
#define  SYNTAX_ID_MIN_PWD_AGE                          16 // 0x41      
#define  SYNTAX_ID_MIN_PWD_LENGTH                        9 // 0x2       
#define  SYNTAX_ID_MIN_TICKET_AGE                       16 // 0x41      
#define  SYNTAX_ID_MODIFIED_COUNT                       16 // 0x41      
#define  SYNTAX_ID_MODIFIED_COUNT_AT_LAST_PROM          16 // 0x41      
#define  SYNTAX_ID_MODIFY_TIME_STAMP                    11 // 0x18      
#define  SYNTAX_ID_MONIKER                              10 // 0x4       
#define  SYNTAX_ID_MONIKER_DISPLAY_NAME                 12 // 0x40      
#define  SYNTAX_ID_MOVE_TREE_STATE                      10 // 0x4       
#define  SYNTAX_ID_MS_COM_DEFAULTPARTITIONLINK           1 // 0x7f      
#define  SYNTAX_ID_MS_COM_OBJECTID                      10 // 0x4       
#define  SYNTAX_ID_MS_COM_PARTITIONLINK                  1 // 0x7f      
#define  SYNTAX_ID_MS_COM_PARTITIONSETLINK               1 // 0x7f      
#define  SYNTAX_ID_MS_COM_USERLINK                       1 // 0x7f      
#define  SYNTAX_ID_MS_COM_USERPARTITIONSETLINK           1 // 0x7f      
#define  SYNTAX_ID_MS_DRM_IDENTITY_CERTIFICATE          10 // 0x4       
#define  SYNTAX_ID_MS_DS_ADDITIONAL_DNS_HOST_NAME       12 // 0x40      
#define  SYNTAX_ID_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME       12 // 0x40      
#define  SYNTAX_ID_MS_DS_ALL_USERS_TRUST_QUOTA           9 // 0x2       
#define  SYNTAX_ID_MS_DS_ALLOWED_DNS_SUFFIXES           12 // 0x40      
#define  SYNTAX_ID_MS_DS_ALLOWED_TO_DELEGATE_TO         12 // 0x40      
#define  SYNTAX_ID_MS_DS_AUXILIARY_CLASSES               2 // 0x6       
#define  SYNTAX_ID_MS_DS_APPROX_IMMED_SUBORDINATES        9 // 0x2       
#define  SYNTAX_ID_MS_DS_AZ_APPLICATION_DATA            12 // 0x40      
#define  SYNTAX_ID_MS_DS_AZ_APPLICATION_NAME            12 // 0x40      
#define  SYNTAX_ID_MS_DS_AZ_APPLICATION_VERSION         12 // 0x40      
#define  SYNTAX_ID_MS_DS_AZ_BIZ_RULE                    12 // 0x40      
#define  SYNTAX_ID_MS_DS_AZ_BIZ_RULE_LANGUAGE           12 // 0x40      
#define  SYNTAX_ID_MS_DS_AZ_CLASS_ID                    12 // 0x40      
#define  SYNTAX_ID_MS_DS_AZ_DOMAIN_TIMEOUT               9 // 0x2       
#define  SYNTAX_ID_MS_DS_AZ_GENERATE_AUDITS              8 // 0x1       
#define  SYNTAX_ID_MS_DS_AZ_LAST_IMPORTED_BIZ_RULE_PATH       12 // 0x40      
#define  SYNTAX_ID_MS_DS_AZ_LDAP_QUERY                  12 // 0x40      
#define  SYNTAX_ID_MS_DS_AZ_MAJOR_VERSION                9 // 0x2       
#define  SYNTAX_ID_MS_DS_AZ_MINOR_VERSION                9 // 0x2       
#define  SYNTAX_ID_MS_DS_AZ_OPERATION_ID                 9 // 0x2       
#define  SYNTAX_ID_MS_DS_AZ_SCOPE_NAME                  12 // 0x40      
#define  SYNTAX_ID_MS_DS_AZ_SCRIPT_ENGINE_CACHE_MAX        9 // 0x2       
#define  SYNTAX_ID_MS_DS_AZ_SCRIPT_TIMEOUT               9 // 0x2       
#define  SYNTAX_ID_MS_DS_AZ_TASK_IS_ROLE_DEFINITION        8 // 0x1       
#define  SYNTAX_ID_MS_DS_BEHAVIOR_VERSION                9 // 0x2       
#define  SYNTAX_ID_MS_DS_BYTE_ARRAY                     10 // 0x4       
#define  SYNTAX_ID_MS_DS_CACHED_MEMBERSHIP              10 // 0x4       
#define  SYNTAX_ID_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP       16 // 0x41      
#define  SYNTAX_ID_MS_DS_CONSISTENCY_GUID               10 // 0x4       
#define  SYNTAX_ID_MS_DS_CONSISTENCY_CHILD_COUNT         9 // 0x2       
#define  SYNTAX_ID_MS_DS_CREATOR_SID                    17 // 0x4       
#define  SYNTAX_ID_MS_DS_DATE_TIME                      11 // 0x18      
#define  SYNTAX_ID_MS_DS_DEFAULT_QUOTA                   9 // 0x2       
#define  SYNTAX_ID_MS_DS_DNSROOTALIAS                   12 // 0x40      
#define  SYNTAX_ID_MS_DS_ENTRY_TIME_TO_DIE              11 // 0x18      
#define  SYNTAX_ID_MS_DS_EXECUTESCRIPTPASSWORD          10 // 0x4       
#define  SYNTAX_ID_MS_DS_EXTERNAL_KEY                   12 // 0x40      
#define  SYNTAX_ID_MS_DS_EXTERNAL_STORE                 12 // 0x40      
#define  SYNTAX_ID_MS_DS_FILTER_CONTAINERS              12 // 0x40      
#define  SYNTAX_ID_MS_DS_HAS_INSTANTIATED_NCS            7 // 0x7f      
#define  SYNTAX_ID_MS_DS_HAS_DOMAIN_NCS                  1 // 0x7f      
#define  SYNTAX_ID_MS_DS_HAS_MASTER_NCS                  1 // 0x7f      
#define  SYNTAX_ID_MS_DS_INTEGER                         9 // 0x2       
#define  SYNTAX_ID_MS_DS_INTID                           9 // 0x2       
#define  SYNTAX_ID_MS_DS_KEYVERSIONNUMBER                9 // 0x2       
#define  SYNTAX_ID_MS_DS_LOGON_TIME_SYNC_INTERVAL        9 // 0x2       
#define  SYNTAX_ID_MS_DS_MASTERED_BY                     1 // 0x7f      
#define  SYNTAX_ID_MS_DS_MAX_VALUES                      9 // 0x2       
#define  SYNTAX_ID_MS_DS_MEMBERS_FOR_AZ_ROLE             1 // 0x7f      
#define  SYNTAX_ID_MS_DS_MEMBERS_FOR_AZ_ROLE_BL          1 // 0x7f      
#define  SYNTAX_ID_MS_DS_NON_MEMBERS                     1 // 0x7f      
#define  SYNTAX_ID_MS_DS_NON_MEMBERS_BL                  1 // 0x7f      
#define  SYNTAX_ID_MS_DS_TRUST_FOREST_TRUST_INFO        10 // 0x4       
#define  SYNTAX_ID_MS_DS_TOMBSTONE_QUOTA_FACTOR          9 // 0x2       
#define  SYNTAX_ID_MS_DS_TOP_QUOTA_USAGE                12 // 0x40      
#define  SYNTAX_ID_MS_DS_MACHINE_ACCOUNT_QUOTA           9 // 0x2       
#define  SYNTAX_ID_MS_DS_OBJECT_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_MS_DS_OBJECT_REFERENCE_BL             1 // 0x7f      
#define  SYNTAX_ID_MS_DS_OPERATIONS_FOR_AZ_ROLE          1 // 0x7f      
#define  SYNTAX_ID_MS_DS_OPERATIONS_FOR_AZ_ROLE_BL        1 // 0x7f      
#define  SYNTAX_ID_MS_DS_OPERATIONS_FOR_AZ_TASK          1 // 0x7f      
#define  SYNTAX_ID_MS_DS_OPERATIONS_FOR_AZ_TASK_BL        1 // 0x7f      
#define  SYNTAX_ID_MS_DS_OTHER_SETTINGS                 12 // 0x40      
#define  SYNTAX_ID_MS_DS_QUOTA_AMOUNT                    9 // 0x2       
#define  SYNTAX_ID_MS_DS_QUOTA_EFFECTIVE                 9 // 0x2       
#define  SYNTAX_ID_MS_DS_QUOTA_TRUSTEE                  17 // 0x4       
#define  SYNTAX_ID_MS_DS_QUOTA_USED                      9 // 0x2       
#define  SYNTAX_ID_MS_DS_NC_REPL_CURSORS                12 // 0x40      
#define  SYNTAX_ID_MS_DS_NC_REPL_INBOUND_NEIGHBORS       12 // 0x40      
#define  SYNTAX_ID_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS       12 // 0x40      
#define  SYNTAX_ID_MS_DS_NC_REPLICA_LOCATIONS            1 // 0x7f      
#define  SYNTAX_ID_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES       12 // 0x40      
#define  SYNTAX_ID_MS_DS_PER_USER_TRUST_QUOTA            9 // 0x2       
#define  SYNTAX_ID_MS_DS_PER_USER_TRUST_TOMBSTONES_QUOTA        9 // 0x2       
#define  SYNTAX_ID_MS_DS_PREFERRED_GC_SITE               1 // 0x7f      
#define  SYNTAX_ID_MS_DS_REPL_ATTRIBUTE_META_DATA       12 // 0x40      
#define  SYNTAX_ID_MS_DS_REPL_VALUE_META_DATA           12 // 0x40      
#define  SYNTAX_ID_MS_DS_REPLICATES_NC_REASON            7 // 0x7f      
#define  SYNTAX_ID_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY        9 // 0x2       
#define  SYNTAX_ID_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY        9 // 0x2       
#define  SYNTAX_ID_MS_DS_REPLICATIONEPOCH                9 // 0x2       
#define  SYNTAX_ID_MS_DS_RETIRED_REPL_NC_SIGNATURES       10 // 0x4       
#define  SYNTAX_ID_MS_DS_SCHEMA_EXTENSIONS              10 // 0x4       
#define  SYNTAX_ID_MS_DS_SD_REFERENCE_DOMAIN             1 // 0x7f      
#define  SYNTAX_ID_MS_DS_SECURITY_GROUP_EXTRA_CLASSES       12 // 0x40      
#define  SYNTAX_ID_MS_DS_SETTINGS                       12 // 0x40      
#define  SYNTAX_ID_MS_DS_SITE_AFFINITY                  10 // 0x4       
#define  SYNTAX_ID_MS_DS_SPN_SUFFIXES                   12 // 0x40      
#define  SYNTAX_ID_MS_DS_TASKS_FOR_AZ_ROLE               1 // 0x7f      
#define  SYNTAX_ID_MS_DS_TASKS_FOR_AZ_ROLE_BL            1 // 0x7f      
#define  SYNTAX_ID_MS_DS_TASKS_FOR_AZ_TASK               1 // 0x7f      
#define  SYNTAX_ID_MS_DS_TASKS_FOR_AZ_TASK_BL            1 // 0x7f      
#define  SYNTAX_ID_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED        9 // 0x2       
#define  SYNTAX_ID_MS_DS_UPDATESCRIPT                   12 // 0x40      
#define  SYNTAX_ID_MS_EXCH_ASSISTANT_NAME               12 // 0x40      
#define  SYNTAX_ID_MS_EXCH_HOUSE_IDENTIFIER             12 // 0x40      
#define  SYNTAX_ID_MS_EXCH_LABELEDURI                   12 // 0x40      
#define  SYNTAX_ID_MS_EXCH_OWNER_BL                      1 // 0x7f      
#define  SYNTAX_ID_MS_FRS_HUB_MEMBER                     1 // 0x7f      
#define  SYNTAX_ID_MS_FRS_TOPOLOGY_PREF                 12 // 0x40      
#define  SYNTAX_ID_MS_IEEE_80211_DATA                   10 // 0x4       
#define  SYNTAX_ID_MS_IEEE_80211_DATA_TYPE               9 // 0x2       
#define  SYNTAX_ID_MS_IEEE_80211_ID                     12 // 0x40      
#define  SYNTAX_ID_MS_IIS_FTP_DIR                       12 // 0x40      
#define  SYNTAX_ID_MS_IIS_FTP_ROOT                      12 // 0x40      
#define  SYNTAX_ID_MS_PKI_CERT_TEMPLATE_OID             12 // 0x40      
#define  SYNTAX_ID_MS_PKI_CERTIFICATE_APPLICATION_POLICY       12 // 0x40      
#define  SYNTAX_ID_MS_PKI_CERTIFICATE_NAME_FLAG          9 // 0x2       
#define  SYNTAX_ID_MS_PKI_CERTIFICATE_POLICY            12 // 0x40      
#define  SYNTAX_ID_MS_PKI_ENROLLMENT_FLAG                9 // 0x2       
#define  SYNTAX_ID_MS_PKI_MINIMAL_KEY_SIZE               9 // 0x2       
#define  SYNTAX_ID_MS_PKI_OID_ATTRIBUTE                  9 // 0x2       
#define  SYNTAX_ID_MS_PKI_OID_CPS                       12 // 0x40      
#define  SYNTAX_ID_MS_PKI_OID_LOCALIZEDNAME             12 // 0x40      
#define  SYNTAX_ID_MS_PKI_OID_USER_NOTICE               12 // 0x40      
#define  SYNTAX_ID_MS_PKI_PRIVATE_KEY_FLAG               9 // 0x2       
#define  SYNTAX_ID_MS_PKI_SUPERSEDE_TEMPLATES           12 // 0x40      
#define  SYNTAX_ID_MS_PKI_TEMPLATE_MINOR_REVISION        9 // 0x2       
#define  SYNTAX_ID_MS_PKI_TEMPLATE_SCHEMA_VERSION        9 // 0x2       
#define  SYNTAX_ID_MS_PKI_RA_APPLICATION_POLICIES       12 // 0x40      
#define  SYNTAX_ID_MS_PKI_RA_POLICIES                   12 // 0x40      
#define  SYNTAX_ID_MS_PKI_RA_SIGNATURE                   9 // 0x2       
#define  SYNTAX_ID_MS_RRAS_ATTRIBUTE                    12 // 0x40      
#define  SYNTAX_ID_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY       12 // 0x40      
#define  SYNTAX_ID_MS_SQL_NAME                          12 // 0x40      
#define  SYNTAX_ID_MS_SQL_REGISTEREDOWNER               12 // 0x40      
#define  SYNTAX_ID_MS_SQL_CONTACT                       12 // 0x40      
#define  SYNTAX_ID_MS_SQL_LOCATION                      12 // 0x40      
#define  SYNTAX_ID_MS_SQL_MEMORY                        16 // 0x41      
#define  SYNTAX_ID_MS_SQL_BUILD                          9 // 0x2       
#define  SYNTAX_ID_MS_SQL_SERVICEACCOUNT                12 // 0x40      
#define  SYNTAX_ID_MS_SQL_CHARACTERSET                   9 // 0x2       
#define  SYNTAX_ID_MS_SQL_SORTORDER                     12 // 0x40      
#define  SYNTAX_ID_MS_SQL_UNICODESORTORDER               9 // 0x2       
#define  SYNTAX_ID_MS_SQL_CLUSTERED                      8 // 0x1       
#define  SYNTAX_ID_MS_SQL_NAMEDPIPE                     12 // 0x40      
#define  SYNTAX_ID_MS_SQL_MULTIPROTOCOL                 12 // 0x40      
#define  SYNTAX_ID_MS_SQL_SPX                           12 // 0x40      
#define  SYNTAX_ID_MS_SQL_TCPIP                         12 // 0x40      
#define  SYNTAX_ID_MS_SQL_APPLETALK                     12 // 0x40      
#define  SYNTAX_ID_MS_SQL_VINES                         12 // 0x40      
#define  SYNTAX_ID_MS_SQL_STATUS                        16 // 0x41      
#define  SYNTAX_ID_MS_SQL_LASTUPDATEDDATE               12 // 0x40      
#define  SYNTAX_ID_MS_SQL_INFORMATIONURL                12 // 0x40      
#define  SYNTAX_ID_MS_SQL_CONNECTIONURL                 12 // 0x40      
#define  SYNTAX_ID_MS_SQL_PUBLICATIONURL                12 // 0x40      
#define  SYNTAX_ID_MS_SQL_GPSLATITUDE                   12 // 0x40      
#define  SYNTAX_ID_MS_SQL_GPSLONGITUDE                  12 // 0x40      
#define  SYNTAX_ID_MS_SQL_GPSHEIGHT                     12 // 0x40      
#define  SYNTAX_ID_MS_SQL_VERSION                       12 // 0x40      
#define  SYNTAX_ID_MS_SQL_LANGUAGE                      12 // 0x40      
#define  SYNTAX_ID_MS_SQL_DESCRIPTION                   12 // 0x40      
#define  SYNTAX_ID_MS_SQL_TYPE                          12 // 0x40      
#define  SYNTAX_ID_MS_SQL_INFORMATIONDIRECTORY           8 // 0x1       
#define  SYNTAX_ID_MS_SQL_DATABASE                      12 // 0x40      
#define  SYNTAX_ID_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION        8 // 0x1       
#define  SYNTAX_ID_MS_SQL_ALIAS                         12 // 0x40      
#define  SYNTAX_ID_MS_SQL_SIZE                          16 // 0x41      
#define  SYNTAX_ID_MS_SQL_CREATIONDATE                  12 // 0x40      
#define  SYNTAX_ID_MS_SQL_LASTBACKUPDATE                12 // 0x40      
#define  SYNTAX_ID_MS_SQL_LASTDIAGNOSTICDATE            12 // 0x40      
#define  SYNTAX_ID_MS_SQL_APPLICATIONS                  12 // 0x40      
#define  SYNTAX_ID_MS_SQL_KEYWORDS                      12 // 0x40      
#define  SYNTAX_ID_MS_SQL_PUBLISHER                     12 // 0x40      
#define  SYNTAX_ID_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION        8 // 0x1       
#define  SYNTAX_ID_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTION        8 // 0x1       
#define  SYNTAX_ID_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION        8 // 0x1       
#define  SYNTAX_ID_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING        8 // 0x1       
#define  SYNTAX_ID_MS_SQL_THIRDPARTY                     8 // 0x1       
#define  SYNTAX_ID_MS_TAPI_CONFERENCE_BLOB              10 // 0x4       
#define  SYNTAX_ID_MS_TAPI_IP_ADDRESS                   12 // 0x40      
#define  SYNTAX_ID_MS_TAPI_PROTOCOL_ID                  12 // 0x40      
#define  SYNTAX_ID_MS_TAPI_UNIQUE_IDENTIFIER            12 // 0x40      
#define  SYNTAX_ID_MS_WMI_AUTHOR                        12 // 0x40      
#define  SYNTAX_ID_MS_WMI_CHANGEDATE                    12 // 0x40      
#define  SYNTAX_ID_MS_WMI_CLASS                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_CLASSDEFINITION               12 // 0x40      
#define  SYNTAX_ID_MS_WMI_CREATIONDATE                  12 // 0x40      
#define  SYNTAX_ID_MS_WMI_GENUS                          9 // 0x2       
#define  SYNTAX_ID_MS_WMI_ID                            12 // 0x40      
#define  SYNTAX_ID_MS_WMI_INTDEFAULT                     9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTFLAGS1                      9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTFLAGS2                      9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTFLAGS3                      9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTFLAGS4                      9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTMAX                         9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTMIN                         9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTVALIDVALUES                 9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INT8DEFAULT                   16 // 0x41      
#define  SYNTAX_ID_MS_WMI_INT8MAX                       16 // 0x41      
#define  SYNTAX_ID_MS_WMI_INT8MIN                       16 // 0x41      
#define  SYNTAX_ID_MS_WMI_INT8VALIDVALUES               16 // 0x41      
#define  SYNTAX_ID_MS_WMI_MOF                           12 // 0x40      
#define  SYNTAX_ID_MS_WMI_NAME                          12 // 0x40      
#define  SYNTAX_ID_MS_WMI_NORMALIZEDCLASS               12 // 0x40      
#define  SYNTAX_ID_MS_WMI_PARM1                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_PARM2                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_PARM3                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_PARM4                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_PROPERTYNAME                  12 // 0x40      
#define  SYNTAX_ID_MS_WMI_QUERY                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_QUERYLANGUAGE                 12 // 0x40      
#define  SYNTAX_ID_MS_WMI_SCOPEGUID                     12 // 0x40      
#define  SYNTAX_ID_MS_WMI_SOURCEORGANIZATION            12 // 0x40      
#define  SYNTAX_ID_MS_WMI_STRINGDEFAULT                 12 // 0x40      
#define  SYNTAX_ID_MS_WMI_STRINGVALIDVALUES             12 // 0x40      
#define  SYNTAX_ID_MS_WMI_TARGETCLASS                   12 // 0x40      
#define  SYNTAX_ID_MS_WMI_TARGETNAMESPACE               12 // 0x40      
#define  SYNTAX_ID_MS_WMI_TARGETOBJECT                  10 // 0x4       
#define  SYNTAX_ID_MS_WMI_TARGETPATH                    12 // 0x40      
#define  SYNTAX_ID_MS_WMI_TARGETTYPE                    12 // 0x40      
#define  SYNTAX_ID_MSCOPE_ID                             5 // 0x13      
#define  SYNTAX_ID_MSI_FILE_LIST                        12 // 0x40      
#define  SYNTAX_ID_MSI_SCRIPT                           10 // 0x4       
#define  SYNTAX_ID_MSI_SCRIPT_NAME                      12 // 0x40      
#define  SYNTAX_ID_MSI_SCRIPT_PATH                      12 // 0x40      
#define  SYNTAX_ID_MSI_SCRIPT_SIZE                       9 // 0x2       
#define  SYNTAX_ID_MSMQ_AUTHENTICATE                     8 // 0x1       
#define  SYNTAX_ID_MSMQ_BASE_PRIORITY                    9 // 0x2       
#define  SYNTAX_ID_MSMQ_COMPUTER_TYPE                    4 // 0x14      
#define  SYNTAX_ID_MSMQ_COMPUTER_TYPE_EX                12 // 0x40      
#define  SYNTAX_ID_MSMQ_COST                             9 // 0x2       
#define  SYNTAX_ID_MSMQ_CSP_NAME                         4 // 0x14      
#define  SYNTAX_ID_MSMQ_DEPENDENT_CLIENT_SERVICE         8 // 0x1       
#define  SYNTAX_ID_MSMQ_DEPENDENT_CLIENT_SERVICES        8 // 0x1       
#define  SYNTAX_ID_MSMQ_DIGESTS                         10 // 0x4       
#define  SYNTAX_ID_MSMQ_DIGESTS_MIG                     10 // 0x4       
#define  SYNTAX_ID_MSMQ_DS_SERVICE                       8 // 0x1       
#define  SYNTAX_ID_MSMQ_DS_SERVICES                      8 // 0x1       
#define  SYNTAX_ID_MSMQ_ENCRYPT_KEY                     10 // 0x4       
#define  SYNTAX_ID_MSMQ_FOREIGN                          8 // 0x1       
#define  SYNTAX_ID_MSMQ_IN_ROUTING_SERVERS               1 // 0x7f      
#define  SYNTAX_ID_MSMQ_INTERVAL1                        9 // 0x2       
#define  SYNTAX_ID_MSMQ_INTERVAL2                        9 // 0x2       
#define  SYNTAX_ID_MSMQ_JOURNAL                          8 // 0x1       
#define  SYNTAX_ID_MSMQ_JOURNAL_QUOTA                    9 // 0x2       
#define  SYNTAX_ID_MSMQ_LABEL                            4 // 0x14      
#define  SYNTAX_ID_MSMQ_LABEL_EX                        12 // 0x40      
#define  SYNTAX_ID_MSMQ_LONG_LIVED                       9 // 0x2       
#define  SYNTAX_ID_MSMQ_MIGRATED                         8 // 0x1       
#define  SYNTAX_ID_MSMQ_MULTICAST_ADDRESS   