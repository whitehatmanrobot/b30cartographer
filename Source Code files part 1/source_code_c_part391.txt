AME;
        }
        return WsaStatus;
    }

    if ( wcscmp( LocalSubnetName, CanonicalSubnetName ) != 0 ) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: not canonical %ws\n", SubnetName, CanonicalSubnetName ));
        return ERROR_INVALID_NAME;
    }



    //
    // Ensure there are no bits set that aren't included in the subnet mask.
    //

    if ( (*SubnetAddress) & ~(*SubnetMask)) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: bits not in subnet mask %8.8lX %8.8lX\n", SubnetName, *SubnetAddress, *SubnetMask ));
        return ERROR_INVALID_NAME;
    }

    //
    // Ensure the subnet mask isn't 0 since
    //  RFC950 says "the value of all zeros and all ones should not be assigned
    //  to physical subnets" since all zeros implies "this network" and all ones
    //  implies "all hosts"

    if ( *SubnetAddress == 0 ||
         *SubnetAddress == *SubnetMask ) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: all zero or all one subnet address %8.8lX %8.8lX\n", SubnetName, *SubnetAddress, *SubnetMask ));
        return ERROR_INVALID_NAME;
    }

    return NO_ERROR;
}
#endif // WIN32_CHICAGO

#ifdef _NETLOGON_SERVER

VOID
NetpDcFlushNegativeCache(
    VOID
    )
/*++

Routine Description:

    Flush any failures to discover a DC.

Arguments:

    None.


Return Value:

    None.

--*/
{
    PLIST_ENTRY DomainEntry;
    PNL_DC_DOMAIN_ENTRY NlDcDomainEntry;
    ULONG QueryType;



    //
    // Loop through each cache entry
    //
    EnterCriticalSection(&NlDcCritSect);

    for ( DomainEntry = NlDcDomainList.Flink ;
          DomainEntry != &NlDcDomainList;
          DomainEntry = DomainEntry->Flink ) {

        NlDcDomainEntry = CONTAINING_RECORD( DomainEntry, NL_DC_DOMAIN_ENTRY, Next);

        //
        // Clear the failure time for each query type.
        //
        for ( QueryType = 0; QueryType < NlDcQueryTypeCount; QueryType ++ ) {
            NlFlushNegativeCacheEntry( &NlDcDomainEntry->Dc[QueryType] );
        }


    }

    LeaveCriticalSection(&NlDcCritSect);

    return;
}
#endif // _NETLOGON_SERVER


NET_API_STATUS
NetpDcInitializeCache(
    VOID
    )

/*++

Routine Description:

    Initialize the cache of discovered DCs.

Arguments:

    None.


Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - The cache could not be allocated.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;

    try {
        InitializeCriticalSection( &NlDcCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NlPrint(( NL_CRITICAL,
                  "NetpDcInitializeCache: Cannot initialize NlDcCritSect\n" ));
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeListHead( &NlDcDomainList );
    NlDcDomainCount = 0;

    RtlZeroMemory( &NlDcZeroGuid, sizeof(NlDcZeroGuid) );
    NlDcDnsFailureTime = 0;

    return NetStatus;
}



VOID
NetpDcUninitializeCache(
    VOID
    )
/*++

Routine Description:

    Uninitialize the cache of discovered DCs.

Arguments:

    None.


Return Value:

    None.

--*/
{

    //
    // Delete existing domain entries.
    //

    EnterCriticalSection( &NlDcCritSect );
    while (!IsListEmpty(&NlDcDomainList)) {

        PNL_DC_DOMAIN_ENTRY NlDcDomainEntry =
            CONTAINING_RECORD( NlDcDomainList.Flink, NL_DC_DOMAIN_ENTRY, Next);

        NlAssert( NlDcDomainEntry->ReferenceCount == 1 );
        NetpDcDeleteDomainEntry( NlDcDomainEntry );
    }

    LeaveCriticalSection( &NlDcCritSect );
    DeleteCriticalSection( &NlDcCritSect );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\idl\nlcommon.c ===
/*++

Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    nlcommon.c

Abstract:

    Routines shared by logonsrv\server and logonsrv\common

Author:

    Cliff Van Dyke (cliffv) 20-July-1996

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#ifndef _NETLOGON_SERVER
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <rpc.h>        // RPC_STATUS

#include <windef.h>
#include <winsock2.h>

#include <lmcons.h>     // General net defines
#include <dsgetdc.h>    // DsGetDcName()
#include <align.h>      // ROUND_UP_COUNT()
#include <lmerr.h>      // System Error Log definitions
#include <lmapibuf.h>   // NetapipBufferAllocate
#include <netlib.h>     // NetpMemoryAllcate(
#include <netlibnt.h>   // NetpApiStatusToNtStatus();
#include <netlogon.h>   // Definition of mailslot messages
#include <ntddbrow.h>   // Needed by nlcommon.h
#include <ntrpcp.h>

#if DBG
#define NETLOGONDBG 1
#endif // DBG
#include <nldebug.h>    // NlPrint()
#include <nlbind.h>   // Definitions shared with netlogon
#include <nlcommon.h>   // Definitions shared with netlogon
#include <stdlib.h>     // C library functions (rand, etc)


#endif // _NETLOGON_SERVER

//
// Include nlcommon.h again allocating the actual variables
// this time around.
//

// #define NLCOMMON_ALLOCATE
// #include "nlcommon.h"
// #undef NLCOMMON_ALLOCATE


#ifndef WIN32_CHICAGO


VOID
NlForestRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    )

/*++

Routine Description:

   Routine to relocate the pointers from the fixed portion of a NetGroupEnum
   enumeration
   buffer to the string portion of an enumeration buffer.  It is called
   as a callback routine from NetpAllocateEnumBuffer when it re-allocates
   such a buffer.  NetpAllocateEnumBuffer copied the fixed portion and
   string portion into the new buffer before calling this routine.

Arguments:

    Level - Level of information in the  buffer.

    BufferDescriptor - Description of the new buffer.

    Offset - Offset to add to each pointer in the fixed portion.

Return Value:

    Returns the error code for the operation.

--*/

{
    DWORD EntryCount;
    DWORD EntryNumber;
    DWORD FixedSize;


    //
    // Local macro to add a byte offset to a pointer.
    //

#define RELOCATE_ONE( _fieldname, _offset ) \
        if ( (_fieldname) != NULL ) { \
            _fieldname = (PVOID) ((LPBYTE)(_fieldname) + (_offset)); \
        }

        //
    // Compute the number of fixed size entries
    //

    FixedSize = sizeof(DS_DOMAIN_TRUSTSW);

    EntryCount =
        ((DWORD)(BufferDescriptor->FixedDataEnd - BufferDescriptor->Buffer)) /
        FixedSize;

    //
    // Loop relocating each field in each fixed size structure
    //

    for ( EntryNumber=0; EntryNumber<EntryCount; EntryNumber++ ) {

        LPBYTE TheStruct = BufferDescriptor->Buffer + FixedSize * EntryNumber;

        RELOCATE_ONE( ((PDS_DOMAIN_TRUSTSW)TheStruct)->NetbiosDomainName, Offset );
        RELOCATE_ONE( ((PDS_DOMAIN_TRUSTSW)TheStruct)->DnsDomainName, Offset );
        RELOCATE_ONE( ((PDS_DOMAIN_TRUSTSW)TheStruct)->DomainSid, Offset );

    }

    return;

    UNREFERENCED_PARAMETER( Level );

}


NTSTATUS
NlAllocateForestTrustListEntry (
    IN PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PUNICODE_STRING InNetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING InDnsDomainName OPTIONAL,
    IN ULONG Flags,
    IN ULONG ParentIndex,
    IN ULONG TrustType,
    IN ULONG TrustAttributes,
    IN PSID DomainSid OPTIONAL,
    IN GUID *DomainGuid,
    OUT PULONG RetSize,
    OUT PDS_DOMAIN_TRUSTSW *RetTrustedDomain
    )

/*++

Routine Description:

    Add a DS_DOMAIN_TRUSTSW structure to the buffer described by BufferDescriptor.

Arguments:

    BufferDescriptor - Buffer entry is to be added to.

    NetbiosDomainName, DnsDomainName, Flags, ParentIndex, TrustType,
        TrustAttributes, DomainSid, DomainGuid - Fields to fill into
        the DS_DOMAIN_TRUSTSW structure

    RetSize - Returns the size in bytes of the allocated entry

    RetTrustedDomain - Returns a pointer to the newly allocated structure

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    PDS_DOMAIN_TRUSTSW TrustedDomain = NULL;
    UNICODE_STRING NetbiosDomainName;
    UNICODE_STRING DnsDomainName;

    ULONG Size;
    ULONG VariableSize;

    //
    // Initialization
    //

    if ( InNetbiosDomainName == NULL ) {
        RtlInitUnicodeString( &NetbiosDomainName, NULL );
    } else {
        NetbiosDomainName = *InNetbiosDomainName;
    }

    if ( InDnsDomainName == NULL ) {
        RtlInitUnicodeString( &DnsDomainName, NULL );
    } else {
        DnsDomainName = *InDnsDomainName;
    }

    //
    // Determine the size of this entry
    //

    Size = sizeof(DS_DOMAIN_TRUSTSW);
    VariableSize = 0;
    if ( DnsDomainName.Length != 0 ) {
        VariableSize += DnsDomainName.Length + sizeof(WCHAR);
    }
    if ( NetbiosDomainName.Length != 0 ) {
        VariableSize += NetbiosDomainName.Length + sizeof(WCHAR);
    }
    if ( DomainSid != NULL  ) {
        VariableSize += RtlLengthSid( DomainSid );
    }
    VariableSize = ROUND_UP_COUNT( VariableSize, ALIGN_DWORD );
    *RetSize = Size + VariableSize;

    Size += VariableSize;
    Size += sizeof(DWORD);    // Size is really a function of alignment of EndOfVariableData


    NetStatus = NetpAllocateEnumBufferEx(
                    BufferDescriptor,
                    FALSE,      // Not a 'get' operation
                    0xFFFFFFFF, // PrefMaxLen,
                    Size,
                    NlForestRelocationRoutine,
                    0,
                    512 );  // Grow by at most 512 bytes more than Size

    if (NetStatus != NERR_Success) {
        Status = NetpApiStatusToNtStatus( NetStatus );
        goto Cleanup;
    }

    //
    // Copy this entry into the buffer
    //

    TrustedDomain = (PDS_DOMAIN_TRUSTSW)(BufferDescriptor->FixedDataEnd);
    *RetTrustedDomain = TrustedDomain;
    BufferDescriptor->FixedDataEnd += sizeof(DS_DOMAIN_TRUSTSW);

    //
    // Copy the fixed size data
    //

    TrustedDomain->Flags = Flags;
    TrustedDomain->ParentIndex = ParentIndex;
    TrustedDomain->TrustType = TrustType;
    TrustedDomain->TrustAttributes = TrustAttributes;
    if ( DomainGuid == NULL ) {
        RtlZeroMemory( &TrustedDomain->DomainGuid, sizeof(GUID) );
    } else {
        TrustedDomain->DomainGuid = *DomainGuid;
    }


    //
    // Copy the information into the buffer.
    //

    //
    // Copy the DWORD aligned data
    //
    if ( DomainSid != NULL ) {
        if ( !NetpCopyDataToBuffer (
                (LPBYTE)DomainSid,
                RtlLengthSid( DomainSid ),
                BufferDescriptor->FixedDataEnd,
                &BufferDescriptor->EndOfVariableData,
                (LPBYTE *)&TrustedDomain->DomainSid,
                sizeof(DWORD) ) ) {

            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
    } else {
        TrustedDomain->DomainSid = NULL;
    }


    //
    // Copy the WCHAR aligned data.
    //

    if ( NetbiosDomainName.Length != 0 ) {
        if ( !NetpCopyStringToBuffer(
                    NetbiosDomainName.Buffer,
                    NetbiosDomainName.Length/sizeof(WCHAR),
                    BufferDescriptor->FixedDataEnd,
                    (LPWSTR *)&BufferDescriptor->EndOfVariableData,
                    &TrustedDomain->NetbiosDomainName ) ) {

            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
    } else {
        TrustedDomain->NetbiosDomainName = NULL;
    }

    if ( DnsDomainName.Length != 0 ) {
        if ( !NetpCopyStringToBuffer(
                    DnsDomainName.Buffer,
                    DnsDomainName.Length/sizeof(WCHAR),
                    BufferDescriptor->FixedDataEnd,
                    (LPWSTR *)&BufferDescriptor->EndOfVariableData,
                    &TrustedDomain->DnsDomainName ) ) {

            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
    } else {
        TrustedDomain->DnsDomainName = NULL;
    }


    Status = STATUS_SUCCESS;


    //
    //
Cleanup:

    return Status;
}


NTSTATUS
NlGetNt4TrustedDomainList (
    IN LPWSTR UncDcName,
    IN PUNICODE_STRING InNetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING InDnsDomainName OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    OUT PDS_DOMAIN_TRUSTSW *ForestTrustList,
    OUT PULONG ForestTrustListSize,
    OUT PULONG ForestTrustListCount
    )

/*++

Routine Description:

    Get the list of trusted domains from the specified DC using NT 4 protocols.

Arguments:

    UncDcName - Specifies the name of a DC in the domain.

    InNetbiosDomainName - Netbios domain of the domain Dc is in.

    InDnsDomainName - Dns domain of the domain Dc is in.

    DomainSid - Sid of the domain Dc is in.

    DomainGuid - Guid of the domain Dc is in.

    ForestTrustList - Returns a list of trusted domains.
        Must be freed using NetApiBufferFree

    ForestTrustListSize - Size (in bytes) of ForestTrustList

    ForestTrustListCount - Number of entries in ForestTrustList

Return Value:

    STATUS_SUCCESS - if the trust list was successfully returned

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    LSA_HANDLE LsaHandle = NULL;
    UNICODE_STRING UncDcNameString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    LSA_ENUMERATION_HANDLE EnumerationContext;
    BOOLEAN AllDone = FALSE;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;

    PLSA_TRUST_INFORMATION TrustList = NULL;
    BUFFER_DESCRIPTOR BufferDescriptor;
    PDS_DOMAIN_TRUSTSW TrustedDomain;
    DWORD Size;

    //
    // Initialization
    //

    *ForestTrustListCount = 0;
    *ForestTrustListSize = 0;
    *ForestTrustList = NULL;
    BufferDescriptor.Buffer = NULL;


    //
    // Open the policy database on the DC
    //

    RtlInitUnicodeString( &UncDcNameString, UncDcName );

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0,  NULL, NULL );

    Status = LsaOpenPolicy( &UncDcNameString,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle );

    if ( !NT_SUCCESS(Status) ) {

        NlPrint((NL_CRITICAL,
                "NlGetNt4TrustedDomainList: %ws: LsaOpenPolicy failed: %lx\n",
                UncDcName,
                Status ));

        LsaHandle = NULL;
        goto Cleanup;

    }

    //
    // If the caller didn't specify primary domain information,
    //  get it from the DC
    //


    if ( InNetbiosDomainName == NULL ) {

        //
        // Get the name of the primary domain from LSA
        //
        Status = LsaQueryInformationPolicy(
                       LsaHandle,
                       PolicyPrimaryDomainInformation,
                       (PVOID *) &PrimaryDomainInfo
                       );

        if (! NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,
                      "NlGetNt4TrustedDomainList: LsaQueryInformationPolicy failed %lx\n",
                      Status));
            goto Cleanup;
        }


        //
        // Grab the returned information
        //

        InNetbiosDomainName = &PrimaryDomainInfo->Name;
        InDnsDomainName = NULL;
        DomainSid = PrimaryDomainInfo->Sid;
        DomainGuid = NULL;
    }

    //
    // The LsaEnumerateTrustedDomain doesn't have the PrimaryDomain in the trust list.
    //  Add it to our list here.
    //

    Status = NlAllocateForestTrustListEntry (
                        &BufferDescriptor,
                        InNetbiosDomainName,
                        InDnsDomainName,
                        DS_DOMAIN_PRIMARY,
                        0,      // No ParentIndex
                        TRUST_TYPE_DOWNLEVEL,
                        0,      // No TrustAttributes
                        DomainSid,
                        DomainGuid,
                        &Size,
                        &TrustedDomain );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    *ForestTrustListSize += Size;
    (*ForestTrustListCount) ++;

    //
    // Loop getting a list of trusted domains
    //

    EnumerationContext = 0;

    do {
        ULONG i;
        ULONG CountReturned;

        //
        // Free any buffers from a previous iteration.
        //
        if ( TrustList != NULL ) {
            (VOID) LsaFreeMemory( TrustList );
        }

        //
        // Get more trusted domains names
        //

        Status = LsaEnumerateTrustedDomains(
                                LsaHandle,
                                &EnumerationContext,
                                (PVOID *) &TrustList,
                                0xFFFFFFFF,
                                &CountReturned );

        if ( Status == STATUS_NO_MORE_ENTRIES ) {
            AllDone = TRUE;
            Status = STATUS_SUCCESS;
        }

        if ( !NT_SUCCESS(Status) ) {

            NlPrint((NL_CRITICAL,
                    "NlGetNt4TrustedDomainList: %ws: LsaEnumerateTrustedDomains failed: %lx\n",
                    UncDcName,
                    Status ));

            TrustList = NULL;
            goto Cleanup;
        }


        //
        // Handle each trusted domain.
        //

        for ( i=0; i<CountReturned; i++ ) {

            Status = NlAllocateForestTrustListEntry (
                                &BufferDescriptor,
                                &TrustList[i].Name,
                                NULL,   // No DNS domain name
                                DS_DOMAIN_DIRECT_OUTBOUND,
                                0,      // No ParentIndex
                                TRUST_TYPE_DOWNLEVEL,
                                0,      // No TrustAttributes
                                TrustList[i].Sid,
                                NULL,   // No DomainGuid
                                &Size,
                                &TrustedDomain );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            //
            // Account for the newly allocated entry
            //

            *ForestTrustListSize += Size;
            (*ForestTrustListCount) ++;

        }

    } while ( !AllDone );

    *ForestTrustList = (PDS_DOMAIN_TRUSTSW) BufferDescriptor.Buffer;
    BufferDescriptor.Buffer = NULL;
    Status = STATUS_SUCCESS;

    //
    // Free any locally used resources.
    //
Cleanup:

    if ( LsaHandle != NULL ) {
        (VOID) LsaClose( LsaHandle );
    }

    if ( TrustList != NULL ) {
        (VOID) LsaFreeMemory( TrustList );
    }

    if ( BufferDescriptor.Buffer != NULL ) {
        NetApiBufferFree( BufferDescriptor.Buffer );
    }

    if ( PrimaryDomainInfo != NULL ) {
        (void) LsaFreeMemory( PrimaryDomainInfo );
    }

    return Status;
}



NTSTATUS
NlRpcpBindRpc(
    IN LPWSTR ServerName,
    IN LPWSTR ServiceName,
    IN LPWSTR NetworkOptions,
    IN NL_RPC_BINDING RpcBindingType,
    OUT RPC_BINDING_HANDLE *pBindingHandle
    )

/*++

Routine Description:

    Binds to the RPC server if possible.

Arguments:

    ServerName - Name of server to bind with.

    ServiceName - Name of service to bind with.

    RpcBindingType - Determines whether to use unauthenticated TCP/IP transport instead of
        a named pipe.

    pBindingHandle - Location where binding handle is to be placed

Return Value:

    STATUS_SUCCESS - The binding has been successfully completed.

    STATUS_INVALID_COMPUTER_NAME - The ServerName syntax is invalid.

    STATUS_NO_MEMORY - There is not sufficient memory available to the
        caller to perform the binding.

--*/

{
    RPC_STATUS        RpcStatus;
    LPWSTR            StringBinding;
    WCHAR             ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR            NewServerName = NULL;
    DWORD             bufLen = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // If we're supposed to use named pipes,
    //  call the standard routine.
    //

    if ( RpcBindingType == UseNamedPipe ) {
        return RpcpBindRpc( ServerName, ServiceName, NetworkOptions, pBindingHandle );
    }

    //
    // Otherwise, use TCP/IP directly.
    //

    *pBindingHandle = NULL;

    if (ServerName != NULL) {
        if (GetComputerNameW(ComputerName,&bufLen)) {
            if ((_wcsicmp(ComputerName,ServerName) == 0) ||
                ((ServerName[0] == '\\') &&
                 (ServerName[1] == '\\') &&
                 (_wcsicmp(ComputerName,&(ServerName[2]))==0))) {
                NewServerName = NULL;
            }
            else {
                NewServerName = ServerName;
            }
        }
    }

    //
    // Ditch the \\
    //
    if ( NewServerName != NULL &&
         NewServerName[0] == '\\' &&
         NewServerName[1] == '\\' ) {
        NewServerName += 2;
    }

    //
    // Enpoint isn't known.
    //  Rpc will contact the endpoint mapper for it.
    //
    RpcStatus = RpcStringBindingComposeW(0, L"ncacn_ip_tcp", NewServerName,
                    NULL, NetworkOptions, &StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
        return( STATUS_NO_MEMORY );
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, pBindingHandle);
    RpcStringFreeW(&StringBinding);
    if ( RpcStatus != RPC_S_OK ) {
        *pBindingHandle = NULL;
        if ( RpcStatus == RPC_S_INVALID_ENDPOINT_FORMAT ||
             RpcStatus == RPC_S_INVALID_NET_ADDR ) {

            return( STATUS_INVALID_COMPUTER_NAME );
        }
        if ( RpcStatus == RPC_S_PROTSEQ_NOT_SUPPORTED ) {
            return RPC_NT_PROTSEQ_NOT_SUPPORTED;
        }
        return(STATUS_NO_MEMORY);
    }
    return(STATUS_SUCCESS);
}


BOOLEAN
NlDoingSetup(
    VOID
    )

/*++

Routine Description:

    Returns TRUE if we're running setup.

Arguments:

    NONE.

Return Status:

    TRUE - We're currently running setup
    FALSE - We're not running setup or aren't sure.

--*/

{
    DWORD Value;

    if ( !NlReadDwordHklmRegValue( "SYSTEM\\Setup",
                                   "SystemSetupInProgress",
                                   &Value ) ) {
        return FALSE;
    }

    if ( Value != 1 ) {
        // NlPrint(( 0, "NlDoingSetup: not doing setup\n" ));
        return FALSE;
    }

    NlPrint(( 0, "NlDoingSetup: doing setup\n" ));
    return TRUE;
}

#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\nltest\nltestrk.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    nltestrk.c

Abstract:

    This is the reskit version of nltest

Author:

    Cliff Van Dyke (cliffv) 24-Aug-1998

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//
#define  NTRK_RELEASE 1

#include  "nltest.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\nltest\nlsubr\chutil_stub.c ===
#include "chutil.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\nltest\nltest1.c ===
/*--

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nltest.c

Abstract:

    Test program for the Netlogon service.

Author:

    21-Apr-1993 (madana)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#include <logonsrv.h>   // Include files common to entire service
#include <stdio.h>
#include <string.h>
#include <align.h>

//
// delta entry in the list
//

typedef struct _DELTA_ENTRY {
    LIST_ENTRY Next;
    PCHANGELOG_ENTRY ChangeLogEntry;
    DWORD Order;
} DELTA_ENTRY, *PDELTA_ENTRY;


LIST_ENTRY GlobalDeltaLists[NUM_DBS + 1];
                    // list of deltas, include VOID DB also.

//
// Externals needed by chutil.obj

CRITICAL_SECTION NlGlobalChangeLogCritSect;
CHANGELOG_DESCRIPTOR NlGlobalChangeLogDesc;
CHANGELOG_DESCRIPTOR NlGlobalTempChangeLogDesc;
CHANGELOG_ROLE NlGlobalChangeLogRole;
WCHAR NlGlobalChangeLogFilePrefix[MAX_PATH+1];
LARGE_INTEGER NlGlobalChangeLogPromotionIncrement = DOMAIN_PROMOTION_INCREMENT;
LARGE_INTEGER PromotionMask = DOMAIN_PROMOTION_MASK;
LONG NlGlobalChangeLogPromotionMask;

//
// Stub routines needed by chutil.obj
//

VOID
NlpWriteEventlog (
    IN DWORD EventID,
    IN DWORD EventType,
    IN LPBYTE RawDataBuffer OPTIONAL,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN DWORD StringCount
    )
{
    return;
    UNREFERENCED_PARAMETER( EventID );
    UNREFERENCED_PARAMETER( EventType );
    UNREFERENCED_PARAMETER( RawDataBuffer );
    UNREFERENCED_PARAMETER( RawDataSize );
    UNREFERENCED_PARAMETER( StringArray );
    UNREFERENCED_PARAMETER( StringCount );
}


VOID
MakeDeltaLists(
    VOID
    )
/*++

Routine Description:

    This routine make list of deltas of individual databases.

Arguments:

    None

Return Value:

    none.

--*/
{

    PCHANGELOG_ENTRY ChangeLogEntry;
    DWORD j;
    DWORD Order = 1;

    //
    // initialize list enties.
    //

    for( j = 0; j < NUM_DBS + 1; j++ ) {
        InitializeListHead(&GlobalDeltaLists[j]);
    }

    //
    // The cache is valid if it is empty.
    //

    if ( ChangeLogIsEmpty( &NlGlobalChangeLogDesc) ) {
        return;
    }

    ChangeLogEntry = (PCHANGELOG_ENTRY)(NlGlobalChangeLogDesc.Head+1);
    do {

        PDELTA_ENTRY NewDelta;

        //
        // make delta entry to insert in the list
        //

        NewDelta = (PDELTA_ENTRY)NetpMemoryAllocate( sizeof(DELTA_ENTRY) );

        if ( NewDelta == NULL ) {
            fprintf( stderr, "Not enough memory\n" );
            return;
        }

        NewDelta->ChangeLogEntry = ChangeLogEntry;
        NewDelta->Order = Order++;

        //
        // add this entry to appropriate list.
        //

        InsertTailList( &GlobalDeltaLists[ChangeLogEntry->DBIndex],
                            &NewDelta->Next );


    } while ( ( ChangeLogEntry =
        NlMoveToNextChangeLogEntry(&NlGlobalChangeLogDesc, ChangeLogEntry) ) != NULL );

    return;

}

#if !NETLOGONDBG
// This routine is defined in chutil.obj for the debug version

VOID
PrintChangeLogEntry(
    PCHANGELOG_ENTRY ChangeLogEntry
    )
/*++

Routine Description:

    This routine print the content of the given changelog entry.

Arguments:

    ChangeLogEntry -- pointer to the change log entry to print

Return Value:

    none.

--*/
{
    LPSTR DeltaName;

    switch ( ChangeLogEntry->DeltaType ) {
    case AddOrChangeDomain:
        DeltaName = "AddOrChangeDomain";
        break;
    case AddOrChangeGroup:
        DeltaName = "AddOrChangeGroup";
        break;
    case DeleteGroupByName:
    case DeleteGroup:
        DeltaName = "DeleteGroup";
        break;
    case RenameGroup:
        DeltaName = "RenameGroup";
        break;
    case AddOrChangeUser:
        DeltaName = "AddOrChangeUser";
        break;
    case DeleteUserByName:
    case DeleteUser:
        DeltaName = "DeleteUser";
        break;
    case RenameUser:
        DeltaName = "RenameUser";
        break;
    case ChangeGroupMembership:
        DeltaName = "ChangeGroupMembership";
        break;
    case AddOrChangeAlias:
        DeltaName = "AddOrChangeAlias";
        break;
    case DeleteAlias:
        DeltaName = "DeleteAlias";
        break;
    case RenameAlias:
        DeltaName = "RenameAlias";
        break;
    case ChangeAliasMembership:
        DeltaName = "ChangeAliasMembership";
        break;
    case AddOrChangeLsaPolicy:
        DeltaName = "AddOrChangeLsaPolicy";
        break;
    case AddOrChangeLsaTDomain:
        DeltaName = "AddOrChangeLsaTDomain";
        break;
    case DeleteLsaTDomain:
        DeltaName = "DeleteLsaTDomain";
        break;
    case AddOrChangeLsaAccount:
        DeltaName = "AddOrChangeLsaAccount";
        break;
    case DeleteLsaAccount:
        DeltaName = "DeleteLsaAccount";
        break;
    case AddOrChangeLsaSecret:
        DeltaName = "AddOrChangeLsaSecret";
        break;
    case DeleteLsaSecret:
        DeltaName = "DeleteLsaSecret";
        break;
    case SerialNumberSkip:
        DeltaName = "SerialNumberSkip";
        break;
    case DummyChangeLogEntry:
        DeltaName = "DummyChangeLogEntry";
        break;

    default:
        DeltaName ="(Unknown)";
        break;
    }

    NlPrint((NL_CHANGELOG,
        "DeltaType %s (%ld) SerialNumber: %lx %lx",
        DeltaName,
        ChangeLogEntry->DeltaType,
        ChangeLogEntry->SerialNumber.HighPart,
        ChangeLogEntry->SerialNumber.LowPart ));

    if ( ChangeLogEntry->ObjectRid != 0 ) {
        NlPrint((NL_CHANGELOG," Rid: 0x%lx", ChangeLogEntry->ObjectRid ));
    }
    if ( ChangeLogEntry->Flags & CHANGELOG_REPLICATE_IMMEDIATELY ) {
        NlPrint((NL_CHANGELOG," Immediately" ));
    }
    if ( ChangeLogEntry->Flags & CHANGELOG_PDC_PROMOTION ) {
        NlPrint((NL_CHANGELOG," Promotion" ));
    }
    if ( ChangeLogEntry->Flags & CHANGELOG_PASSWORD_CHANGE ) {
        NlPrint((NL_CHANGELOG," PasswordChanged" ));
    }


    if( ChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED ) {
        NlPrint(( NL_CHANGELOG, " Name: '" FORMAT_LPWSTR "'",
                (LPWSTR)((PBYTE)(ChangeLogEntry)+ sizeof(CHANGELOG_ENTRY))));
    }

    if( ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED ) {
        NlPrint((NL_CHANGELOG," Sid: "));
        NlpDumpSid( NL_CHANGELOG,
                    (PSID)((PBYTE)(ChangeLogEntry)+ sizeof(CHANGELOG_ENTRY)) );
    } else {
        NlPrint((NL_CHANGELOG,"\n" ));
    }
}
#endif // NETLOGONDBG


VOID
PrintDelta(
    PDELTA_ENTRY Delta
    )
/*++

Routine Description:

    This routine print the content of the given delta.

Arguments:

    Delta: pointer to a delta entry to be printed.

Return Value:

    none.

--*/
{
    printf( "Order: %ld ", Delta->Order );
    PrintChangeLogEntry( Delta->ChangeLogEntry );
}


VOID
PrintDeltaLists(
    )
/*++

Routine Description:

    This routine prints deltas of individual databases and validates the
    sequence.

Arguments:

    none.

Return Value:

    none.

--*/
{

    DWORD j;
    LARGE_INTEGER RunningChangeLogSerialNumber[NUM_DBS+1];

    for( j = 0; j < NUM_DBS + 1; j++ ) {
        RunningChangeLogSerialNumber[j].QuadPart = 0;
    }

    //
    // for each database.
    //
    for( j = 0; j < NUM_DBS + 1; j++ ) {

        if( j == SAM_DB ) {
            printf("Deltas of SAM DATABASE \n\n" );
        } else if( j == BUILTIN_DB ) {
            printf("Deltas of BUILTIN DATABASE \n\n" );
        } else if( j == LSA_DB ) {
            printf("Deltas of LSA DATABASE \n\n" );
        } else if( j == VOID_DB ) {
            printf("VOID Deltas \n\n" );
        }

        while( !IsListEmpty( &GlobalDeltaLists[j] ) ) {

            PDELTA_ENTRY NextDelta;
            PCHANGELOG_ENTRY ChangeLogEntry;

            NextDelta = (PDELTA_ENTRY)
                            RemoveHeadList( &GlobalDeltaLists[j] );

            ChangeLogEntry = NextDelta->ChangeLogEntry;

            //
            // validate this delta.
            //

            if ( RunningChangeLogSerialNumber[j].QuadPart == 0 ) {

                //
                // first entry for this database
                //
                // Increment to next expected serial number
                //

                RunningChangeLogSerialNumber[j].QuadPart =
                    ChangeLogEntry->SerialNumber.QuadPart + 1;


            //
            // Otherwise ensure the serial number is the value expected.
            //

            } else {


                //
                // If the order is wrong,
                //  just report the problem.
                //

                if ( !IsSerialNumberEqual(
                            &NlGlobalChangeLogDesc,
                            ChangeLogEntry,
                            &RunningChangeLogSerialNumber[j] ) ) {

                    if ( j != NUM_DBS ) {
                        printf("*** THIS ENTRY IS OUT OF SEQUENCE *** \n");
                    }

                }

                RunningChangeLogSerialNumber[j].QuadPart =
                    ChangeLogEntry->SerialNumber.QuadPart + 1;
            }



            //
            // print delta
            //

            PrintDelta( NextDelta );

            //
            // free this entry.
            //

            NetpMemoryFree( NextDelta );

        }

        printf("-----------------------------------------------\n");
    }

}

VOID
ListDeltas(
    LPWSTR DeltaFileName
    )
/*++

Routine Description:

    This function prints out the content of the change log file in
    readable format. Also it also checks the consistency of the change
    log. If not, it will point out the inconsistency.

Arguments:

    DeltaFileName - name of the change log file.

Return Value:

    none.

--*/
{
    NTSTATUS Status;

    // Needed by routines in chutil.obj
    try {
        InitializeCriticalSection( &NlGlobalChangeLogCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        fprintf( stderr,  "Cannot initialize NlGlobalChangeLogCritSect\n" );
        goto Cleanup;
    }
    NlGlobalChangeLogPromotionMask = PromotionMask.HighPart;
    InitChangeLogDesc( &NlGlobalChangeLogDesc );

    //
    // Read in the existing changelog file.
    //

    Status = NlOpenChangeLogFile( DeltaFileName, &NlGlobalChangeLogDesc, TRUE );

    if ( !NT_SUCCESS(Status) ) {

        fprintf( stderr, "Couldn't NlOpenChangeLogFile'"  FORMAT_LPWSTR
                            "': 0x%lx \n",
                            DeltaFileName,
                            Status );

        goto Cleanup;
    }

    //
    // Write to this file if conversion needed.
    //
    if ( NlGlobalChangeLogDesc.Version3 ) {
        printf( "Converting version 3 changelog to version 4 -- writing netlv40.chg\n");
        wcscpy( NlGlobalChangeLogFilePrefix, L"netlv40" );
    }

    //
    // Convert the changelog file to the right size/version.
    //

    Status = NlResizeChangeLogFile( &NlGlobalChangeLogDesc, NlGlobalChangeLogDesc.BufferSize );

    if ( !NT_SUCCESS(Status) ) {

        fprintf( stderr, "Couldn't NlOpenChangeLogFile'"  FORMAT_LPWSTR
                            "': 0x%lx \n",
                            DeltaFileName,
                            Status );

        goto Cleanup;
    }

    //
    // print change log signature

    printf( "FILE SIGNATURE : %s \n\n", NlGlobalChangeLogDesc.Buffer );

    MakeDeltaLists();

    PrintDeltaLists();

Cleanup:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\nltest\sources.inc ===
!IF 0

Copyright (c) 1989-96  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

INCLUDES=\
    ..; \
    ..\..\server; \
    ..\..; \
    ..\..\idl; \
    ..\..\idl\$(O); \
    $(NTDS_INC); \
    $(NET_INC_PATH); \
    $(BASE_INC_PATH); \
    $(COM_INC_PATH); \
    $(PROJECT_ROOT)\netapi\inc;

C_DEFINES=$(C_DEFINES) -DNLTEST_IMAGE=1 -DSECURITY_WIN32

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

USE_MSVCRT=1

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\nltest\nltest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    nltest.c

Abstract:

    Test program for the Netlogon service.

    This code is shared between the RESKIT and non-RESKIT versions of nltest

Author:

    13-Apr-1992 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    Madana - added various options.

--*/


//
// Common include files.
//

#include <logonsrv.h>   // Include files common to entire service

//
// Include files specific to this .c file
//
#include <align.h>
#include <dsgetdcp.h>
#include <netlogp.h>
#include <stdio.h>
#include <string.h>
#include <strarray.h>
#include <tstring.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <ssiapi.h>
#include <winreg.h>
#include <samregp.h>
#include <wtypes.h>
#include <ntstatus.dbg>
#include <winerror.dbg>
#include <iniparm.h>


VOID
ListDeltas(
    LPWSTR DeltaFileName
    );

NETLOGON_PARAMETERS NlGlobalParameters;
GUID NlGlobalZeroGuid;

typedef struct _MAILSLOT_INFO {
    CHAR Name[DNLEN+NETLOGON_NT_MAILSLOT_LEN+3];
    HANDLE ResponseHandle;
    BOOL State;
    NETLOGON_SAM_LOGON_RESPONSE SamLogonResponse;
    OVERLAPPED OverLapped;
    BOOL ReadPending;
} MAIL_INFO, PMAIL_INFO;

MAIL_INFO GlobalMailInfo[64];
DWORD GlobalIterationCount = 0;
LPWSTR GlobalAccountName;
HANDLE GlobalPostEvent;
CRITICAL_SECTION GlobalPrintCritSect;

HCRYPTPROV NlGlobalCryptProvider;


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++
Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
    DWORD j;
    PULONG LongBuffer;
    ULONG LongLength;

    LongBuffer = Buffer;
    LongLength = min( BufferSize, 512 )/4;

    for(j = 0; j < LongLength; j++) {
        printf("%08lx ", LongBuffer[j]);
    }

    if ( BufferSize != LongLength*4 ) {
        printf( "..." );
    }

    printf("\n");

}


VOID
NlpDumpBuffer(
    IN DWORD DebugFlag,
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    DebugFlag: Debug flag to pass on to NlPrintRoutine

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;

    if ( BufferSize == 0 ) {
        return;
    }

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            NlPrint((0,"%02x ", BufferPtr[i]));

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            NlPrint((0,"   "));
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            NlPrint((0,"  %s\n", TextBuffer));
        }

    }

    UNREFERENCED_PARAMETER( DebugFlag );
}


VOID
NlpDumpSid(
    IN DWORD DebugFlag,
    IN PSID Sid OPTIONAL
    )
/*++

Routine Description:

    Dumps a SID to the debugger output

Arguments:

    DebugFlag - Debug flag to pass on to NlPrintRoutine

    Sid - SID to output

Return Value:

    none

--*/
{

    //
    // Output the SID
    //

    if ( Sid == NULL ) {
        NlPrint((0, "(null)\n"));
    } else {
        UNICODE_STRING SidString;
        NTSTATUS Status;

        Status = RtlConvertSidToUnicodeString( &SidString, Sid, TRUE );

        if ( !NT_SUCCESS(Status) ) {
            NlPrint((0, "Invalid 0x%lX\n", Status ));
        } else {
            NlPrint((0, "%wZ\n", &SidString ));
            RtlFreeUnicodeString( &SidString );
        }
    }

    UNREFERENCED_PARAMETER( DebugFlag );
}



VOID
PrintTime(
    LPSTR Comment,
    LARGE_INTEGER ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - GMT time to print (Nothing is printed if this is zero)

Return Value:

    None

--*/
{
    //
    // If we've been asked to convert an NT GMT time to ascii,
    //  Do so
    //

    if ( ConvertTime.QuadPart != 0 ) {
        LARGE_INTEGER LocalTime;
        TIME_FIELDS TimeFields;
        NTSTATUS Status;

        printf( "%s", Comment );

        Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
        if ( !NT_SUCCESS( Status )) {
            printf( "Can't convert time from GMT to Local time\n" );
            LocalTime = ConvertTime;
        }

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%8.8lx %8.8lx = %ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                ConvertTime.LowPart,
                ConvertTime.HighPart,
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }
}

LPSTR
FindSymbolicNameForStatus(
    DWORD Id
    )
{
    ULONG i;

    i = 0;
    if (Id == 0) {
        return "STATUS_SUCCESS";
    }

    if (Id & 0xC0000000) {
        while (ntstatusSymbolicNames[ i ].SymbolicName) {
            if (ntstatusSymbolicNames[ i ].MessageId == (NTSTATUS)Id) {
                return ntstatusSymbolicNames[ i ].SymbolicName;
            } else {
                i += 1;
            }
        }
    }

    while (winerrorSymbolicNames[ i ].SymbolicName) {
        if (winerrorSymbolicNames[ i ].MessageId == Id) {
            return winerrorSymbolicNames[ i ].SymbolicName;
        } else {
            i += 1;
        }
    }

#ifdef notdef
    while (neteventSymbolicNames[ i ].SymbolicName) {
        if (neteventSymbolicNames[ i ].MessageId == Id) {
            return neteventSymbolicNames[ i ].SymbolicName
        } else {
            i += 1;
        }
    }
#endif // notdef

    return NULL;
}


VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case NERR_UserNotFound:
        printf( " NERR_UserNotFound" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    default:
        printf( " %s", FindSymbolicNameForStatus( NetStatus ) );
        break;

    }

    printf( "\n" );
}


VOID
NlAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
        printf( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

}


NTSTATUS
NlBrowserSendDatagram(
    IN PVOID ContextDomainInfo,
    IN ULONG IpAddress,
    IN LPWSTR UnicodeDestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR TransportName,
    IN LPSTR OemMailslotName,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOL SendSynchronously,
    IN OUT PBOOL FlushNameOnOneIpTransport OPTIONAL
    )
/*++

Routine Description:

    Send the specified mailslot message to the specified mailslot on the
    specified server on the specified transport..

Arguments:

    DomainInfo - Hosted domain sending the datagram

    IpAddress - IpAddress of the machine to send the pind to.
        If zero, UnicodeDestinationName must be specified.

    UnicodeDestinationName -- Name of the server to send to.

    NameType -- Type of name represented by UnicodeDestinationName.

    TransportName -- Name of the transport to send on.
        Use NULL to send on all transports.

    OemMailslotName -- Name of the mailslot to send to.

    Buffer -- Specifies a pointer to the mailslot message to send.

    BufferSize -- Size in bytes of the mailslot message

Return Value:

    Status of the operation.

--*/
{
    return STATUS_INTERNAL_ERROR;
    // If this routine is ever needed, copy it from logonsrv\client\getdcnam.c

    UNREFERENCED_PARAMETER(ContextDomainInfo);
    UNREFERENCED_PARAMETER(IpAddress);
    UNREFERENCED_PARAMETER(UnicodeDestinationName);
    UNREFERENCED_PARAMETER(NameType);
    UNREFERENCED_PARAMETER(TransportName);
    UNREFERENCED_PARAMETER(OemMailslotName);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferSize);
    UNREFERENCED_PARAMETER(SendSynchronously);
    UNREFERENCED_PARAMETER(FlushNameOnOneIpTransport);
}


VOID
WhoWillLogMeOnResponse(
    )

/*++

Routine Description:

    This routine reads the responses that are received for the query
    messages sent from the main thread.

Arguments:

    none

Return Value:

    None

--*/
{
    DWORD i;
    DWORD WaitCount;
    DWORD IndexArray[64];
    HANDLE HandleArray[64];

    PNL_DC_CACHE_ENTRY NlDcCacheEntry = NULL;
    SYSTEMTIME SystemTime;

    NETLOGON_SAM_LOGON_RESPONSE SamLogonResponse;
    DWORD SamLogonResponseSize;
    DWORD WaitStatus;
    NET_API_STATUS NetStatus;
    BOOL AllReceived;

    for(;;) {

        //
        // make wait array.
        //

        WaitCount = 0;

        AllReceived = TRUE;

        for (i = 0; i < GlobalIterationCount; i++ ) {

            //
            if( GlobalMailInfo[i].State == TRUE ) {

                //
                // if a response is received.
                //

                continue;
            }

            AllReceived = FALSE;

            //
            // post a read.
            //

            if( GlobalMailInfo[i].ReadPending == FALSE ) {

                if ( !ReadFile( GlobalMailInfo[i].ResponseHandle,
                        (PCHAR)&GlobalMailInfo[i].SamLogonResponse,
                        sizeof(NETLOGON_SAM_LOGON_RESPONSE),
                        &SamLogonResponseSize,
                        &GlobalMailInfo[i].OverLapped )) {   // Overlapped I/O

                    NetStatus = GetLastError();

                    if( NetStatus != ERROR_IO_PENDING ) {

                        printf( "Cannot read mailslot (%s) : %ld\n",
                                GlobalMailInfo[i].Name,
                                NetStatus);
                        goto Cleanup;
                    }
                }

                GlobalMailInfo[i].ReadPending = TRUE;

            }

            HandleArray[WaitCount] = GlobalMailInfo[i].ResponseHandle;
            IndexArray[WaitCount] = i;

            WaitCount++;
        }

        if( (WaitCount == 0) ) {

            if( AllReceived ) {

                //
                // we received responses for all messages, so we are
                // done.
                //

                goto Cleanup;
            }
            else {

                // wait for an query posted
                //

                WaitStatus = WaitForSingleObject( GlobalPostEvent, (DWORD) -1 );

                if( WaitStatus != 0 ) {
                    printf("Can't successfully wait post event %ld\n",
                        WaitStatus );

                    goto Cleanup;
                }

                continue;
            }
        }

        //
        // wait for response.
        //

        WaitStatus = WaitForMultipleObjects(
                        WaitCount,
                        HandleArray,
                        FALSE,     // Wait for ANY handle
                        15000 );   // 3 * 5 Secs

        if( WaitStatus == WAIT_TIMEOUT ) {

            // we are done.

            break;
        }

        if ( WaitStatus == WAIT_FAILED ) {
            printf( "Can't successfully wait for multiple objects %ld\n",
                    GetLastError() );

            goto Cleanup;
        }

        if( WaitStatus >= WaitCount ) {

            printf("Invalid WaitStatus returned %ld\n", WaitStatus );
            goto Cleanup;
        }

        //
        // get index
        //

        i = IndexArray[WaitStatus];


        //
        // read response
        //

        if( !GetOverlappedResult(
                GlobalMailInfo[i].ResponseHandle,
                &GlobalMailInfo[i].OverLapped,
                &SamLogonResponseSize,
                TRUE) ) {       // wait for the read complete.

            printf("can't read overlapped response %ld",GetLastError() );
            goto Cleanup;

        }

        SamLogonResponse = GlobalMailInfo[i].SamLogonResponse;

        //
        // indicate that we received a response.
        //

        GlobalMailInfo[i].State = TRUE;
        GlobalMailInfo[i].ReadPending = FALSE;


        GetLocalTime( &SystemTime );

        EnterCriticalSection( &GlobalPrintCritSect );

        printf( "[%02u:%02u:%02u] ",
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );

        printf( "Response %ld: ", i);

        NetStatus = NetpDcParsePingResponse(
                        NULL,
                        &SamLogonResponse,
                        SamLogonResponseSize,
                        &NlDcCacheEntry );

        if ( NetStatus != NO_ERROR ) {
            printf("Failure parsing response: ");
            PrintStatus( NetStatus );
            goto Continue;
        }

        //
        // If the response is for the correct account,
        //  break out of the loop.
        //

        if ( NlNameCompare(
                GlobalAccountName,
                NlDcCacheEntry->UnicodeUserName,
                NAMETYPE_USER)!=0){

            printf("Response not for correct User name "
                    FORMAT_LPWSTR " s.b. " FORMAT_LPWSTR "\n",
                    NlDcCacheEntry->UnicodeUserName, GlobalAccountName );
            goto Continue;
        }



        printf( "S:" FORMAT_LPWSTR " D:" FORMAT_LPWSTR
                    " A:" FORMAT_LPWSTR,
                    NlDcCacheEntry->UnicodeNetbiosDcName,
                    NlDcCacheEntry->UnicodeNetbiosDomainName,
                    NlDcCacheEntry->UnicodeUserName );

        //
        // If the DC recognizes our account,
        //  we've successfully found the DC.
        //

        switch (NlDcCacheEntry->Opcode) {
        case LOGON_SAM_LOGON_RESPONSE:

            printf( " (Act found)\n" );
            break;

        case LOGON_SAM_USER_UNKNOWN:

            printf( " (Act not found)\n" );
            break;

        case LOGON_PAUSE_RESPONSE:

            printf( " (netlogon paused)\n" );
            break;

         default:
            printf( " (Unknown opcode: %lx)\n", SamLogonResponse.Opcode );
            break;
         }

         //
         // Print the additional NT 5 specific information.
         //
         if ( NlDcCacheEntry->UnicodeDnsForestName != NULL ) {
             printf( "    Tree: %ws\n", NlDcCacheEntry->UnicodeDnsForestName );
         }
         if ( NlDcCacheEntry->UnicodeDnsDomainName != NULL ) {
             printf( "    Dom:  %ws\n", NlDcCacheEntry->UnicodeDnsDomainName );
         }
         if ( NlDcCacheEntry->UnicodeDnsHostName != NULL ) {
             printf( "   Host:  %ws\n", NlDcCacheEntry->UnicodeDnsHostName );
         }
         if ( NlDcCacheEntry->ReturnFlags != 0 ) {
             printf( "    Flags: 0x%lx\n", NlDcCacheEntry->ReturnFlags );
         }

Continue:
        if ( NlDcCacheEntry != NULL ) {
            NetpMemoryFree( NlDcCacheEntry );
            NlDcCacheEntry = NULL;
        }

        LeaveCriticalSection( &GlobalPrintCritSect );
    }

Cleanup:

    //
    // print non-responsed mailslots.
    //

    for( i = 0; i < GlobalIterationCount; i++ ) {

        if( GlobalMailInfo[i].State == FALSE ) {

            printf("Didn't receive a response for mail "
                   "message %ld (%s)\n", i, GlobalMailInfo[i].Name );
        }
    }

    return;
}



VOID
WhoWillLogMeOn(
    IN LPWSTR DomainName,
    IN LPWSTR AccountName,
    IN DWORD IterationCount
    )

/*++

Routine Description:

    Determine which DC will log the specified account on

Arguments:

    DomainName - name of the "doamin" to send the message to

    AccountName - Name of our user account to find.

    IterationCount - Number of consecutive messages to send.

Return Value:

    None

--*/
{

    NET_API_STATUS NetStatus;
    ULONG AllowableAccountControlBits = USER_ACCOUNT_TYPE_MASK;

    WCHAR NetlogonMailslotName[DNLEN+1+NETLOGON_NT_MAILSLOT_LEN+4];

    HANDLE *ResponseMailslotHandle = NULL;

    WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD ComputerNameLength = MAX_COMPUTERNAME_LENGTH+1;

    DWORD i;
    DWORD j;
    SYSTEMTIME SystemTime;

    HANDLE ResponseThreadHandle = NULL;
    DWORD ThreadId;
    DWORD WaitStatus;
    DWORD SamLogonResponseSize;
    ULONG DomainNameLength;

    //
    // Verify the domain name length to avoid buffer overrun
    //

    DomainNameLength = wcslen(DomainName);

    //
    // Domain name should be at most 16 characters where the 16th character must be '*'
    //

    if ( (DomainNameLength > DNLEN + 1) ||
         (DomainNameLength == DNLEN + 1 && DomainName[DNLEN] != L'*') ) {

        fprintf( stderr, "Invalid Netbios domain or server name '%ws' specified (too long)\n", DomainName );
        return;
    }

    //
    // support only 64 iterations
    //

    if( IterationCount > 64 ) {

        printf("Interations set to 64, maximum supported\n");
        IterationCount = 64;
    }

    GlobalIterationCount = IterationCount;
    GlobalAccountName = AccountName;

    try {
        InitializeCriticalSection( &GlobalPrintCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        fprintf( stderr, "NLTEST.EXE: Cannot initialize GlobalPrintCritSect\n" );
        return;
    }


    //
    // Get out computer name
    //

    if (!GetComputerName( ComputerName, &ComputerNameLength ) ) {
        printf( "Can't GetComputerName\n" );
        return;
    }

    //
    // create mailslots
    //

    for (i = 0; i < IterationCount; i++ ) {

        //
        // Create a mailslot for the DC's to respond to.
        //

        if (NetStatus = NetpLogonCreateRandomMailslot(
                            GlobalMailInfo[i].Name,
                            &GlobalMailInfo[i].ResponseHandle)){

            printf( "Cannot create temp mailslot %ld\n", NetStatus );
            goto Cleanup;
        }

        if ( !SetMailslotInfo( GlobalMailInfo[i].ResponseHandle,
                  (DWORD) MAILSLOT_WAIT_FOREVER ) ) {
            printf( "Cannot set mailslot info %ld\n", GetLastError() );
            goto Cleanup;
        }

        (void) memset( &GlobalMailInfo[i].OverLapped, '\0',
                            sizeof(OVERLAPPED) );

        GlobalMailInfo[i].State = FALSE;
        GlobalMailInfo[i].ReadPending = FALSE;
    }


    //
    // create post event
    //

    GlobalPostEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if( GlobalPostEvent == NULL ) {

        printf("can't create post event %ld \n", GetLastError() );
        goto Cleanup;
    }

    //
    // start response thread.
    //

    ResponseThreadHandle =
        CreateThread(
            NULL, // No security attributes
            0,
            (LPTHREAD_START_ROUTINE)
                WhoWillLogMeOnResponse,
            NULL,
            0, // No special creation flags
            &ThreadId );

    if ( ResponseThreadHandle == NULL ) {

        printf("can't create response thread %ld\n", GetLastError() );
        goto Cleanup;
    }

    wcscpy( NetlogonMailslotName, L"\\\\" );
    wcscat( NetlogonMailslotName, DomainName );
    // wcscat( NetlogonMailslotName, L"*" );  // Don't add for computer name
    wcscat( NetlogonMailslotName, NETLOGON_NT_MAILSLOT_W);

    //
    // Send atmost 3 messages/mailslot
    //

    for( j = 0; j < 3; j++ ) {

        //
        // Repeat the message multiple times to load the servers
        //

        for (i = 0; i < IterationCount; i++ ) {
            PNETLOGON_SAM_LOGON_REQUEST SamLogonRequest;
            ULONG SamLogonRequestSize;

            if( GlobalMailInfo[i].State == TRUE ) {

                //
                // if a response is received.
                //

                continue;
            }

            //
            // Build the query message.
            //

            NetStatus = NetpDcBuildPing (
                FALSE,  // Not only PDC
                0,      // Retry count
                ComputerName,
                AccountName,
                GlobalMailInfo[i].Name,
                AllowableAccountControlBits,
                NULL,   // No Domain SID
                0,      // Not NT Version 5
                &SamLogonRequest,
                &SamLogonRequestSize );

            if ( NetStatus != NO_ERROR ) {
                printf("can't allocate mailslot message %ld\n", NetStatus );
                goto Cleanup;
            }

            //
            // Send the message to a DC for the domain.
            //

            NetStatus = NetpLogonWriteMailslot(
                                NetlogonMailslotName,
                                (PCHAR)SamLogonRequest,
                                SamLogonRequestSize );

            NetpMemoryFree( SamLogonRequest );

            if ( NetStatus != NERR_Success ) {
                    printf( "Cannot write netlogon mailslot: %ld\n", NetStatus);
                    goto Cleanup;
            }

            GetLocalTime( &SystemTime );

            EnterCriticalSection( &GlobalPrintCritSect );

            printf( "[%02u:%02u:%02u] ",
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );

            printf( "Mail message %ld sent successfully (%s) \n",
                        i, GlobalMailInfo[i].Name );

            LeaveCriticalSection( &GlobalPrintCritSect );

            if( !SetEvent( GlobalPostEvent ) ) {
                printf("Can't set post event %ld \n", GetLastError() );
                goto Cleanup;
            }


        }

        //
        // wait 5 secs to see response thread received all responses.
        //

        WaitStatus = WaitForSingleObject( ResponseThreadHandle, 5000 );
                                            // 15 secs. TIMEOUT

        if( WaitStatus != WAIT_TIMEOUT ) {

            if( WaitStatus != 0 ) {
                printf("can't do WaitForSingleObject %ld\n", WaitStatus);
            }

            goto Cleanup;
        }
    }


Cleanup:

    //
    // Wait for the response thread to complete.
    //

    if( ResponseThreadHandle != NULL ) {

        WaitStatus = WaitForSingleObject( ResponseThreadHandle, 15000 );
                                            // 15 secs. TIMEOUT

        if( WaitStatus ) {

            if( WaitStatus == WAIT_TIMEOUT ) {
                printf("Can't stop response thread (TIMEOUT) \n");
            } else {
                printf("Can't stop response thread %ld \n", WaitStatus);
            }
        }

    }


    for (i = 0; i < IterationCount; i++ ) {

        if( GlobalMailInfo[i].ResponseHandle != NULL ) {
            CloseHandle( GlobalMailInfo[i].ResponseHandle);
        }
    }

    if( GlobalPostEvent != NULL ) {
        CloseHandle( GlobalPostEvent );
    }

    DeleteCriticalSection( &GlobalPrintCritSect );

    return;
}

#define MAX_PRINTF_LEN 1024        // Arbitrary.

VOID
NlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
{
    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    (VOID) _vsnprintf( OutputBuffer, MAX_PRINTF_LEN - 1, Format, arglist );
    va_end(arglist);

    OutputBuffer[MAX_PRINTF_LEN - 1] = '\0';

    printf( "%s", OutputBuffer );
    return;
    UNREFERENCED_PARAMETER( DebugFlag );
}

NTSTATUS
SimulateFullSync(
    LPWSTR PdcName,
    LPWSTR MachineName
    )
/*++

Routine Description:

    This function simulate a full sync replication by calling
    NetDatabaseSync API and simply ignoring successfully returned data.

Arguments:

    PdcName - Name of the PDC from where the database replicated.

    MachineName - Name of the machine account used to authenticate.

Return Value:

    Network Status code.

--*/
{
    NTSTATUS Status;

    NETLOGON_CREDENTIAL ServerChallenge;
    NETLOGON_CREDENTIAL ClientChallenge;
    NETLOGON_CREDENTIAL ComputedServerCredential;
    NETLOGON_CREDENTIAL ReturnedServerCredential;

    NETLOGON_CREDENTIAL AuthenticationSeed;
    NETLOGON_SESSION_KEY SessionKey;

    NETLOGON_AUTHENTICATOR OurAuthenticator;
    NETLOGON_AUTHENTICATOR ReturnAuthenticator;

    UNICODE_STRING Password;
    NT_OWF_PASSWORD NtOwfPassword;

    ULONG SamSyncContext = 0;
    PNETLOGON_DELTA_ENUM_ARRAY DeltaArray = NULL;

    DWORD DatabaseIndex;
    DWORD i;

    WCHAR AccountName[SSI_ACCOUNT_NAME_LENGTH+1];

    //
    // Validate machine name
    //

    if ( wcslen(MachineName) > CNLEN ) {
        fprintf( stderr, "Invalid machine name '%ws' (too long)\n", MachineName );
        return STATUS_INVALID_PARAMETER;
    }


    //
    // Prepare our challenge
    //

    NlComputeChallenge( &ClientChallenge );

    printf("ClientChallenge = %lx %lx\n",
            ((DWORD*)&ClientChallenge)[0],
            ((DWORD *)&ClientChallenge)[1]);

    //
    // Get the primary's challenge
    //

    Status = I_NetServerReqChallenge(PdcName,
                                     MachineName,
                                     &ClientChallenge,
                                     &ServerChallenge );

    if ( !NT_SUCCESS( Status ) ) {
        fprintf( stderr,
                "I_NetServerReqChallenge to " FORMAT_LPWSTR
                " returned 0x%lx\n",
                PdcName,
                Status );
        return(Status);
    }


    printf("ServerChallenge = %lx %lx\n",
            ((DWORD *)&ServerChallenge)[0],
            ((DWORD *)&ServerChallenge)[1]);

    Password.Length =
        Password.MaximumLength = wcslen(MachineName) * sizeof(WCHAR);
    Password.Buffer = MachineName;

    //
    // Compute the NT OWF password for this user.
    //

    Status = RtlCalculateNtOwfPassword( &Password, &NtOwfPassword );

    if ( !NT_SUCCESS( Status ) ) {

        fprintf(stderr, "Can't compute OWF password 0x%lx \n", Status );
        return(Status);
    }


    printf("Password = %lx %lx %lx %lx\n",
                    ((DWORD *) (&NtOwfPassword))[0],
                    ((DWORD *) (&NtOwfPassword))[1],
                    ((DWORD *) (&NtOwfPassword))[2],
                    ((DWORD *) (&NtOwfPassword))[3]);


    //
    // Actually compute the session key given the two challenges and the
    //  password.
    //

    NlMakeSessionKey(
                    0,
                    &NtOwfPassword,
                    &ClientChallenge,
                    &ServerChallenge,
                    &SessionKey );

    printf("SessionKey = %lx %lx %lx %lx\n",
                    ((DWORD *) (&SessionKey))[0],
                    ((DWORD *) (&SessionKey))[1],
                    ((DWORD *) (&SessionKey))[2],
                    ((DWORD *) (&SessionKey))[3]);

     //
     // Prepare credentials using our challenge.
     //

     NlComputeCredentials( &ClientChallenge,
                           &AuthenticationSeed,
                           &SessionKey );

     printf("ClientCredential = %lx %lx\n",
                ((DWORD *) (&AuthenticationSeed))[0],
                ((DWORD *) (&AuthenticationSeed))[1]);

     //
     // Send these credentials to primary. The primary will compute
     // credentials using the challenge supplied by us and compare
     // with these. If both match then it will compute credentials
     // using its challenge and return it to us for verification
     //

     wcscpy( AccountName, MachineName );
     wcscat( AccountName, SSI_ACCOUNT_NAME_POSTFIX);

     Status = I_NetServerAuthenticate( PdcName,
                                       AccountName,
                                       ServerSecureChannel,
                                       MachineName,
                                       &AuthenticationSeed,
                                       &ReturnedServerCredential );

     if ( !NT_SUCCESS( Status ) ) {

        fprintf(stderr,
            "I_NetServerAuthenticate to " FORMAT_LPWSTR  " 0x%lx\n",
                &PdcName,
                Status );

        return(Status);

     }


     printf("ServerCredential GOT = %lx %lx\n",
                ((DWORD *) (&ReturnedServerCredential))[0],
                ((DWORD *) (&ReturnedServerCredential))[1]);


     //
     // The DC returned a server credential to us,
     //  ensure the server credential matches the one we would compute.
     //

     NlComputeCredentials( &ServerChallenge,
                           &ComputedServerCredential,
                           &SessionKey);


     printf("ServerCredential MADE =%lx %lx\n",
                ((DWORD *) (&ComputedServerCredential))[0],
                ((DWORD *) (&ComputedServerCredential))[1]);


     if (RtlCompareMemory( &ReturnedServerCredential,
                           &ComputedServerCredential,
                           sizeof(ReturnedServerCredential)) !=
                           sizeof(ReturnedServerCredential)) {

        fprintf( stderr, "Access Denied \n");
        return( STATUS_ACCESS_DENIED );
     }


     printf("Session Setup to " FORMAT_LPWSTR " completed successfully \n",
            PdcName);

    //
    // retrive database info
    //

    for( DatabaseIndex = 0 ;  DatabaseIndex < 3; DatabaseIndex++) {

        SamSyncContext = 0;

        for( i = 0; ; i++) {

            NlBuildAuthenticator(
                        &AuthenticationSeed,
                        &SessionKey,
                        &OurAuthenticator);

            Status = I_NetDatabaseSync(
                        PdcName,
                        MachineName,
                        &OurAuthenticator,
                        &ReturnAuthenticator,
                        DatabaseIndex,
                        &SamSyncContext,
                        &DeltaArray,
                        128 * 1024 ); // 128K

            if ( !NT_SUCCESS( Status ) ) {

                fprintf( stderr,
                        "I_NetDatabaseSync to " FORMAT_LPWSTR " failed 0x%lx\n",
                            PdcName,
                            Status );

                return(Status);
            }

            if ( ( !NlUpdateSeed(
                            &AuthenticationSeed,
                            &ReturnAuthenticator.Credential,
                            &SessionKey) ) ) {

                fprintf(stderr, "NlUpdateSeed failed \n" );
                return( STATUS_ACCESS_DENIED );
            }

            printf( "Received %ld Buffer data \n", i);
            //
            // ignore return data
            //

            MIDL_user_free( DeltaArray );

            if ( Status == STATUS_SUCCESS ) {

                break;
            }

        }

        printf("FullSync replication of database %ld completed "
                    "successfully \n", DatabaseIndex );

    }

    return Status;
}


LONG
ForceRegOpenSubkey(
    HKEY ParentHandle,
    LPSTR KeyName,
    LPSTR Subkey,
    REGSAM DesiredAccess,
    PHKEY ReturnHandle
    )

/*++

Routine Description:

    Open the specified key one subkey at a time defeating access denied by
    setting the DACL to allow us access.  This kludge is needed since the
    security tree is shipped not allowing Administrators access.

Arguments:

    ParentHandle - Currently open handle

    KeyName - Entire key name (for error messages only)

    Subkey - Direct subkey of ParentHandle

    DesiredAccess - Desired access to the new key

    ReturnHandle - Returns an open handle to the newly opened key.


Return Value:

    Return TRUE for success.

--*/

{
    LONG RegStatus;
    LONG SavedStatus;
    HKEY TempHandle = NULL;
    BOOLEAN DaclChanged = FALSE;

    SECURITY_INFORMATION SecurityInformation = DACL_SECURITY_INFORMATION;
    DWORD OldSecurityDescriptorSize;
    CHAR OldSecurityDescriptor[1024];
    CHAR NewSecurityDescriptor[1024];

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdminSid = NULL;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    PACL Dacl;
    ACL_SIZE_INFORMATION AclSizeInfo;
    ACCESS_ALLOWED_ACE *Ace;
    DWORD i;


    //
    // Open the sub-key
    //

    SavedStatus = RegOpenKeyExA(
                    ParentHandle,
                    Subkey,
                    0,      //Reserved
                    DesiredAccess,
                    ReturnHandle );

    if ( SavedStatus != ERROR_ACCESS_DENIED ) {
        return SavedStatus;
    }

    //
    // If access is denied,
    //  try changing the DACL to give us access
    //

    // printf( "Cannot RegOpenKey %s subkey %s ", KeyName, Subkey );
    // PrintStatus( SavedStatus );

    //
    // Open again asking to change the DACL
    //

    RegStatus = RegOpenKeyExA(
                    ParentHandle,
                    Subkey,
                    0,      //Reserved
                    WRITE_DAC | READ_CONTROL,
                    &TempHandle );

    if ( RegStatus != ERROR_SUCCESS) {
        printf( "Cannot RegOpenKey to change DACL %s subkey %s ", KeyName, Subkey );
        PrintStatus( RegStatus );
        goto Cleanup;
    }

    //
    // Get the current DACL so we can restore it.
    //

    OldSecurityDescriptorSize = sizeof(OldSecurityDescriptor);
    RegStatus = RegGetKeySecurity(
                    TempHandle,
                    SecurityInformation,
                    (PSECURITY_DESCRIPTOR) OldSecurityDescriptor,
                    &OldSecurityDescriptorSize );

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot RegGetKeySecurity for %s subkey %s ", KeyName, Subkey );
        PrintStatus( RegStatus );
        goto Cleanup;
    }

    //
    // Build the Administrators SID
    //
    if ( !AllocateAndInitializeSid( &NtAuthority,
                                    2,      // two subauthorities
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    &AdminSid ) ) {
        printf( "Cannot AllocateAndInitializeSid " );
        PrintStatus( GetLastError() );
        goto Cleanup;
    }

    //
    // Change the DACL to allow all access
    //

    RtlCopyMemory( NewSecurityDescriptor,
                   OldSecurityDescriptor,
                   OldSecurityDescriptorSize );

    if ( !GetSecurityDescriptorDacl(
                    (PSECURITY_DESCRIPTOR)NewSecurityDescriptor,
                    &DaclPresent,
                    &Dacl,
                    &DaclDefaulted )) {
        printf( "Cannot GetSecurityDescriptorDacl for %s subkey %s ", KeyName, Subkey );
        PrintStatus( GetLastError() );
        goto Cleanup;
    }

    if ( !DaclPresent ) {
        printf( "Cannot GetSecurityDescriptorDacl " );
        printf( "Cannot DaclNotPresent for %s subkey %s ", KeyName, Subkey );
        goto Cleanup;
    }

    if ( !GetAclInformation(
                    Dacl,
                    &AclSizeInfo,
                    sizeof(AclSizeInfo),
                    AclSizeInformation )) {
        printf( "Cannot GetAclInformation for %s subkey %s ", KeyName, Subkey );
        PrintStatus( GetLastError() );
        goto Cleanup;
    }



    //
    // Search for an administrators ACE and give it "DesiredAccess"
    //

    for ( i=0; i<AclSizeInfo.AceCount ; i++ ) {

        if ( !GetAce( Dacl, i, (LPVOID *) &Ace ) ) {
            printf( "Cannot GetAce %ld for %s subkey %s ", i, KeyName, Subkey );
            PrintStatus( GetLastError() );
            goto Cleanup;
        }

        if ( Ace->Header.AceType != ACCESS_ALLOWED_ACE_TYPE ) {
            continue;
        }

        if ( !EqualSid( AdminSid, (PSID)&Ace->SidStart ) ) {
            continue;
        }

        Ace->Mask |= DesiredAccess;
        break;

    }

    if ( i >= AclSizeInfo.AceCount ) {
        printf( "No Administrators Ace for %s subkey %s\n", KeyName, Subkey );
        goto Cleanup;
    }

    //
    // Actually set the new DACL on the key
    //

    RegStatus = RegSetKeySecurity(
                    TempHandle,
                    SecurityInformation,
                    (PSECURITY_DESCRIPTOR)NewSecurityDescriptor );

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot RegSetKeySecurity for %s subkey %s ", KeyName, Subkey );
        PrintStatus( RegStatus );
        goto Cleanup;
    }

    DaclChanged = TRUE;


    //
    // Open the sub-key again with the desired access
    //

    SavedStatus = RegOpenKeyExA(
                    ParentHandle,
                    Subkey,
                    0,      //Reserved
                    DesiredAccess,
                    ReturnHandle );

    if ( SavedStatus != ERROR_SUCCESS ) {
        printf( "Cannot RegOpenKeyEx following DACL change for %s subkey %s ", KeyName, Subkey );
        PrintStatus( SavedStatus );
        goto Cleanup;
    }


Cleanup:
    if ( TempHandle != NULL ) {
        //
        // Restore DACL to original value.
        //

        if ( DaclChanged ) {

            RegStatus = RegSetKeySecurity(
                            TempHandle,
                            SecurityInformation,
                            (PSECURITY_DESCRIPTOR)OldSecurityDescriptor );

            if ( RegStatus != ERROR_SUCCESS ) {
                printf( "Cannot RegSetKeySecurity to restore %s subkey %s ", KeyName, Subkey );
                PrintStatus( RegStatus );
                goto Cleanup;
            }
        }
        (VOID) RegCloseKey( TempHandle );
    }

    if ( AdminSid != NULL ) {
        (VOID) FreeSid( AdminSid );
    }

    return SavedStatus;

}



LONG
ForceRegOpenKey(
    HKEY BaseHandle,
    LPSTR KeyName,
    REGSAM DesiredAccess,
    PHKEY ReturnHandle
    )

/*++

Routine Description:

    Open the specified key one subkey at a time defeating access denied by
    setting the DACL to allow us access.  This kludge is needed since the
    security tree is shipped not allowing Administrators access.

Arguments:

    BaseHandle - Currently open handle

    KeyName - Registry key to open relative to BaseHandle.

    DesiredAccess - Desired access to the new key

    ReturnHandle - Returns an open handle to the newly opened key.


Return Value:

    Return TRUE for success.

--*/

{
    LONG RegStatus;
    PCHAR StartOfSubkey;
    PCHAR EndOfSubkey;
    CHAR Subkey[512];
    HKEY ParentHandle;

    ASSERT( KeyName[0] != '\0' );
    if ( KeyName[0] == '\0' ) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Loop opening the next subkey.
    //

    EndOfSubkey = KeyName;
    ParentHandle = BaseHandle;

    for (;;) {


        //
        // Compute the name of the next subkey.
        //

        StartOfSubkey = EndOfSubkey;

        for ( ;; ) {

            if ( *EndOfSubkey == '\0' || *EndOfSubkey == '\\' ) {

                if ( EndOfSubkey-StartOfSubkey >= sizeof(Subkey) ) {
                    return ERROR_INVALID_PARAMETER;
                }
                strncpy( Subkey, StartOfSubkey, (int)(EndOfSubkey-StartOfSubkey) );
                Subkey[EndOfSubkey-StartOfSubkey] = '\0';
                if ( *EndOfSubkey == '\\' ) {
                    EndOfSubkey ++;
                }
                break;
            }
            EndOfSubkey ++;
        }


        //
        // Open the sub-key
        //

        RegStatus = ForceRegOpenSubkey(
                        ParentHandle,
                        KeyName,
                        Subkey,
                        DesiredAccess,
                        ReturnHandle );


        //
        // Close the parent handle and return any error condition.
        //

        if ( ParentHandle != BaseHandle ) {
            (VOID) RegCloseKey( ParentHandle );
        }

        if( RegStatus != ERROR_SUCCESS ) {
            *ReturnHandle = NULL;
            return RegStatus;
        }


        //
        // If this is the entire key name,
        //  we're done.
        //

        if ( *EndOfSubkey == '\0' ) {
            return ERROR_SUCCESS;
        }

        ParentHandle = *ReturnHandle;

    }

}


struct {
    LPSTR Name;
    enum {
        UnicodeStringType,
        HexDataType,
        LmPasswordType,
        NtPasswordType
    } Type;
} UserVariableDataTypes[] = {
    { "SecurityDescriptor" , HexDataType },
    { "AccountName"        , UnicodeStringType },
    { "FullName"           , UnicodeStringType },
    { "AdminComment"       , UnicodeStringType },
    { "UserComment"        , UnicodeStringType },
    { "Parameters"         , UnicodeStringType },
    { "HomeDirectory"      , UnicodeStringType },
    { "HomeDirectoryDrive" , UnicodeStringType },
    { "ScriptPath"         , UnicodeStringType },
    { "ProfilePath"        , UnicodeStringType },
    { "Workstations"       , UnicodeStringType },
    { "LogonHours"         , HexDataType },
    { "Groups"             , HexDataType },
    { "LmOwfPassword"      , LmPasswordType },
    { "NtOwfPassword"      , NtPasswordType },
    { "NtPasswordHistory"  , HexDataType },
    { "LmPasswordHistory"  , HexDataType }
};


VOID
PrintUserInfo(
    IN LPWSTR ServerName,
    IN LPSTR UserName
    )
/*++

Routine Description:

    Print a user's description from the SAM database

Arguments:

    ServerName - Name of server to query

    UserName - Name of user to query

Return Value:

    None

--*/
{
    NTSTATUS Status;
    LONG RegStatus;
    ULONG i;

    HKEY BaseHandle = NULL;
    HKEY UserHandle = NULL;
    HKEY RidHandle = NULL;

    CHAR UserKey[200];
    CHAR RidKey[200];
    LONG Rid;
    CHAR AnsiRid[20];

    CHAR FixedData[1000];
    ULONG FixedDataSize;
    SAMP_V1_0A_FIXED_LENGTH_USER FixedUser1_0A;
    PSAMP_V1_0A_FIXED_LENGTH_USER f;
    PSAMP_V1_0_FIXED_LENGTH_USER f1_0;
    BOOLEAN IsVersion1_0;

    CHAR VariableData[32768];
    ULONG VariableDataSize;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE v;

    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;

    //
    // Open the registry
    //

    RegStatus = RegConnectRegistryW( ServerName,
                                     HKEY_LOCAL_MACHINE,
                                     &BaseHandle);

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot connect to registy on " FORMAT_LPWSTR " ", ServerName );
        PrintStatus( RegStatus );
        goto Cleanup;
    }


    //
    // Open the key for this user name.
    //

    strcpy( UserKey, "SAM\\SAM\\Domains\\Account\\Users\\Names\\" );

    //
    // Ensure UserName is short enough to fit into our buffer
    //

    if ( strlen(UserName) + strlen(UserKey) >= sizeof(UserKey) ) {
        return;
    }
    strcat( UserKey, UserName );

    RegStatus = ForceRegOpenKey( BaseHandle,
                                 UserKey,
                                 KEY_READ|KEY_QUERY_VALUE,
                                 &UserHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot open %s ", UserKey );
        PrintStatus( RegStatus );
        goto Cleanup;
    }

    //
    // Get the RID of the user
    //

    RegStatus = RegQueryValueExW( UserHandle,
                                  NULL,         // No name
                                  NULL,         // Reserved
                                  &Rid,         // Really the type
                                  NULL,         // Data not needed
                                  NULL);        // Data not needed

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot Query %s ", UserKey );
        PrintStatus( RegStatus );
        goto Cleanup;
    }

    printf( "User: %s\nRid: 0x%lx\n",
            UserName,
            Rid );


    //
    // Open the key for this user rid.
    //

    sprintf( AnsiRid, "%8.8lx", Rid );
    strcpy( RidKey, "SAM\\SAM\\Domains\\Account\\Users\\" );
    strcat( RidKey, AnsiRid );

    RegStatus = ForceRegOpenKey( BaseHandle,
                                 RidKey,
                                 KEY_READ|KEY_QUERY_VALUE,
                                 &RidHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot open %s ", RidKey );
        PrintStatus( RegStatus );
        goto Cleanup;
    }


    //
    // Get the Fixed Values associated with this RID
    //

    FixedDataSize = sizeof(FixedData);
    RegStatus = RegQueryValueExA( RidHandle,
                                  "F",          // Fixed value
                                  NULL,         // Reserved
                                  NULL,         // Type Not Needed
                                  FixedData,
                                  &FixedDataSize );

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot Query %s ", RidKey );
        PrintStatus( RegStatus );
        goto Cleanup;
    }

    //
    // If the fixed length data is NT 3.1,
    //  convert it to NT 3.5x format.
    //

    if ( IsVersion1_0 = (FixedDataSize == sizeof(*f1_0)) ) {
        f1_0 = (PSAMP_V1_0_FIXED_LENGTH_USER) FixedData;
        FixedUser1_0A.LastLogon = f1_0->LastLogon;
        FixedUser1_0A.LastLogoff = f1_0->LastLogoff;
        FixedUser1_0A.PasswordLastSet = f1_0->PasswordLastSet;
        FixedUser1_0A.AccountExpires = f1_0->AccountExpires;
        FixedUser1_0A.UserId = f1_0->UserId;
        FixedUser1_0A.PrimaryGroupId = f1_0->PrimaryGroupId;
        FixedUser1_0A.UserAccountControl = f1_0->UserAccountControl;
        FixedUser1_0A.CountryCode = f1_0->CountryCode;
        FixedUser1_0A.BadPasswordCount = f1_0->BadPasswordCount;
        FixedUser1_0A.LogonCount = f1_0->LogonCount;
        FixedUser1_0A.AdminCount = f1_0->AdminCount;
        RtlCopyMemory( FixedData, &FixedUser1_0A, sizeof(FixedUser1_0A) );
    }

    //
    // Print the fixed length data.
    //

    f = (PSAMP_V1_0A_FIXED_LENGTH_USER) FixedData;

    if ( !IsVersion1_0) {
        printf( "Version: 0x%lx\n", f->Revision );
    }

    PrintTime( "LastLogon: ", f->LastLogon );
    PrintTime( "LastLogoff: ", f->LastLogoff );
    PrintTime( "PasswordLastSet: ", f->PasswordLastSet );
    PrintTime( "AccountExpires: ", f->AccountExpires );
    if ( !IsVersion1_0) {
        PrintTime( "LastBadPasswordTime: ", f->LastBadPasswordTime );
    }

    printf( "PrimaryGroupId: 0x%lx\n", f->PrimaryGroupId );
    printf( "UserAccountControl: 0x%lx\n", f->UserAccountControl );

    printf( "CountryCode: 0x%lx\n", f->CountryCode );
    printf( "CodePage: 0x%lx\n", f->CodePage );
    printf( "BadPasswordCount: 0x%lx\n", f->BadPasswordCount );
    printf( "LogonCount: 0x%lx\n", f->LogonCount );
    printf( "AdminCount: 0x%lx\n", f->AdminCount );


    //
    // Get the Variable Values associated with this RID
    //

    VariableDataSize = sizeof(VariableData);
    RegStatus = RegQueryValueExA( RidHandle,
                                  "V",          // Variable value
                                  NULL,         // Reserved
                                  NULL,         // Type Not Needed
                                  VariableData,
                                  &VariableDataSize );

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot Query %s \n", RidKey );
        PrintStatus( RegStatus );
        goto Cleanup;
    }

    //
    // Loop printing all the attributes.
    //

    v = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE) VariableData;

    for ( i=0;
          i<sizeof(UserVariableDataTypes)/sizeof(UserVariableDataTypes[0]);
          i++ ) {

        UNICODE_STRING UnicodeString;

        //
        // Make the offset relative to the beginning of the queried value.
        //

        v[i].Offset += SAMP_USER_VARIABLE_ATTRIBUTES *
                       sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE);



        //
        // Ensure the data item descriptor is in the registry.
        //

        if ( ((PCHAR)&v[i]) > ((PCHAR)v)+VariableDataSize ) {
            printf( "Variable data desc %ld not in variable value.\n", i );
            goto Cleanup;
        }

        if ( v[i].Offset > (LONG) VariableDataSize ||
             v[i].Offset + v[i].Length > VariableDataSize ) {
            printf( "Variable data item %ld not in variable value.\n", i );
            printf( "Offset: %ld Length: %ld Size: %ld\n",
                    v[i].Offset,
                    v[i].Length,
                    VariableDataSize );
            goto Cleanup;

        }

        //
        // Don't print null data.
        //

        if ( v[i].Length == 0 ) {
            continue;
        }

        //
        // Print the various types of data.
        //

        switch ( UserVariableDataTypes[i].Type ) {
        case UnicodeStringType:

            UnicodeString.Buffer = (PUSHORT)(((PCHAR)v)+v[i].Offset);
            UnicodeString.Length = (USHORT)v[i].Length;
            printf( "%s: %wZ\n", UserVariableDataTypes[i].Name, &UnicodeString);
            break;

        case LmPasswordType:
            Status = RtlDecryptLmOwfPwdWithIndex(
                        (PENCRYPTED_LM_OWF_PASSWORD)(((PCHAR)v)+v[i].Offset),
                        &Rid,
                        &LmOwfPassword );

            if ( !NT_SUCCESS( Status ) ) {
                printf( "Cannot decrypt LM password: " );
                PrintStatus( Status );
                goto Cleanup;
            }

            printf( "%s: ", UserVariableDataTypes[i].Name);
            DumpBuffer( &LmOwfPassword, sizeof(LmOwfPassword ));
            break;

        case NtPasswordType:
            Status = RtlDecryptNtOwfPwdWithIndex(
                        (PENCRYPTED_NT_OWF_PASSWORD)(((PCHAR)v)+v[i].Offset),
                        &Rid,
                        &NtOwfPassword );

            if ( !NT_SUCCESS( Status ) ) {
                printf( "Cannot decrypt NT password: " );
                PrintStatus( Status );
                goto Cleanup;
            }

            printf( "%s: ", UserVariableDataTypes[i].Name);
            DumpBuffer( &NtOwfPassword, sizeof(NtOwfPassword ));
            break;


        case HexDataType:

            printf( "%s: ", UserVariableDataTypes[i].Name);
            DumpBuffer( (((PCHAR)v)+v[i].Offset), v[i].Length );
            break;
        }
    }


    //
    // Be tidy.
    //
Cleanup:
    if ( UserHandle != NULL ) {
        RegCloseKey( UserHandle );
    }
    if ( RidHandle != NULL ) {
        RegCloseKey( RidHandle );
    }
    if ( BaseHandle != NULL ) {
        RegCloseKey( BaseHandle );
    }
    return;

}


VOID
SetDbflagInRegistry(
    LPWSTR ServerName,
    ULONG DbFlagValue
    )
/*++

Routine Description:

    Set the value DbFlagValue in the Netlogon service portion of the registry.

Arguments:

    ServerName - Name of the server to update

    DbFlagValue - Value to set dbflag to.

Return Value:

    None.

--*/
{
    LONG RegStatus;
    UCHAR AnsiDbFlag[20];
    DWORD AnsiDbFlagLength;

    HKEY BaseHandle = NULL;
    HKEY ParmHandle = NULL;
    LPSTR KeyName;

    //
    // Open the registry
    //

    RegStatus = RegConnectRegistryW( ServerName,
                                     HKEY_LOCAL_MACHINE,
                                     &BaseHandle);

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot connect to registy on " FORMAT_LPWSTR " ", ServerName );
        PrintStatus( RegStatus );
        goto Cleanup;
    }


    //
    // Open the key for Netlogon\parameters.
    //

    KeyName = NL_PARAM_KEY;
    RegStatus = ForceRegOpenKey(
                    BaseHandle,
                    KeyName,
                    KEY_SET_VALUE,
                    &ParmHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot open " NL_PARAM_KEY );
        PrintStatus( RegStatus );
        goto Cleanup;
    }

    //
    // Set the DbFlag value into the registry.
    //

    AnsiDbFlagLength = sprintf( AnsiDbFlag, "0x%8.8lx", DbFlagValue );

    RegStatus = RegSetValueExA( ParmHandle,
                                "DbFlag",
                                0,              // Reserved
                                REG_SZ,
                                AnsiDbFlag,
                                AnsiDbFlagLength + 1 );

    if ( RegStatus != ERROR_SUCCESS ) {
        printf( "Cannot Set %s:", KeyName );
        PrintStatus( RegStatus );
        goto Cleanup;
    }

    printf( "%s set to %s\n", KeyName, AnsiDbFlag );

    //
    // Be tidy.
    //
Cleanup:
    if ( ParmHandle != NULL ) {
        RegCloseKey( ParmHandle );
    }
    if ( BaseHandle != NULL ) {
        RegCloseKey( BaseHandle );
    }
    return;

}





VOID
StopService(
    LPWSTR ServiceName
    )

/*++

Routine Description:

    Stop the named service.

Arguments:

    ServiceName (Name of service to stop)
    None.

Return Status:

    STATUS_SUCCESS - Indicates service successfully stopped
    STATUS_NETLOGON_NOT_STARTED - Timeout occurred.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD Timeout;


    //
    // Open a handle to the Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        NetStatus = GetLastError();

        printf( "OpenSCManager failed: " );
        PrintStatus( NetStatus );
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        ServiceName,
                        SERVICE_QUERY_STATUS |
                            SERVICE_INTERROGATE |
                            SERVICE_ENUMERATE_DEPENDENTS |
                            SERVICE_STOP |
                            SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        NetStatus = GetLastError();

        printf( "OpenService [%ws] failed: ", ServiceName );
        PrintStatus( NetStatus );
        goto Cleanup;
    }


    //
    // Ask the service to stop.
    //

    if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) {
        NetStatus = GetLastError();

        //
        // If there are dependent services running,
        //  determine their names and stop them.
        //

        if ( NetStatus == ERROR_DEPENDENT_SERVICES_RUNNING ) {
            BYTE ConfigBuffer[4096];
            LPENUM_SERVICE_STATUS ServiceConfig = (LPENUM_SERVICE_STATUS) ConfigBuffer;
            DWORD BytesNeeded;
            DWORD ServiceCount;
            DWORD ServiceIndex;

            //
            // Get the names of the dependent services.
            //

            if ( !EnumDependentServicesW( ServiceHandle,
                                          SERVICE_ACTIVE,
                                          ServiceConfig,
                                          sizeof(ConfigBuffer),
                                          &BytesNeeded,
                                          &ServiceCount ) ) {
                NetStatus = GetLastError();
                printf( "EnumDependentServicesW [Stop %ws] failed: ", ServiceName );
                PrintStatus( NetStatus );
                goto Cleanup;
            }

            //
            // Stop those services.
            //

            for ( ServiceIndex=0; ServiceIndex<ServiceCount; ServiceIndex++ ) {
                StopService( ServiceConfig[ServiceIndex].lpServiceName );
            }

            //
            // Ask the original service to stop.
            //

            if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) {
                NetStatus = GetLastError();
                printf( "ControlService [Stop %ws] failed: ", ServiceName );
                PrintStatus( NetStatus );
                goto Cleanup;
            }

        } else {
            printf( "ControlService [Stop %ws] failed: ", ServiceName );
            PrintStatus( NetStatus );
            goto Cleanup;
        }
    }

    printf( "%ws service is stopping", ServiceName );



    //
    // Loop waiting for the service to stop.
    //

    for ( Timeout=0; Timeout<45; Timeout++ ) {

        //
        // Return or continue waiting depending on the state of
        //  the service.
        //

        if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED ) {
            printf( "\n" );
            goto Cleanup;
        }

        //
        // Wait a second for the service to finish stopping.
        //

        Sleep( 1000 );
        printf( "." );


        //
        // Query the status of the service again.
        //

        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {
            NetStatus = GetLastError();

            printf( "\nQueryServiceStatus [%ws] failed: ", ServiceName );
            PrintStatus( NetStatus );
            goto Cleanup;
        }

    }

    printf( "%ws service failed to stop\n", ServiceName );

Cleanup:
    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    return;
}

BOOL
GetDcListFromDs(
    IN LPWSTR DomainName
    )
/*++

Routine Description:

    Get a list of DCs in this domain from the DS on an up DC.

Arguments:

    DomainName - Domain to get the DC list for

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    PDS_DOMAIN_CONTROLLER_INFO_1W DsDcInfo = NULL;
    PDOMAIN_CONTROLLER_INFOW DcInfo = NULL;
    HANDLE DsHandle = NULL;
    DWORD DsDcCount = 0;
    BOOL RetVal = TRUE;
    ULONG i;
    ULONG DnsLength;


    //
    // Get a DC to seed the algorithm with
    //

    NetStatus = DsGetDcName( NULL,
                             DomainName,
                             NULL,
                             NULL,
                             DS_DIRECTORY_SERVICE_PREFERRED,
                             &DcInfo );

    if ( NetStatus != NO_ERROR ) {
        printf("Cannot find DC to get DC list from." );
        PrintStatus( NetStatus );
        RetVal = TRUE;
        goto Cleanup;
    }

    if ( (DcInfo->Flags & DS_DS_FLAG) == 0 ) {
        printf( "Domain '%ws' is pre Windows 2000 domain.  (Using NetServerEnum).\n",
                DomainName );
        RetVal = FALSE;
        goto Cleanup;
    }


    printf("Get list of DCs in domain '%ws' from '%ws'.\n",
               DomainName,
               DcInfo->DomainControllerName );

    //
    // Bind to the target DC
    //

    NetStatus = DsBindW( DcInfo->DomainControllerName,
                         NULL,
                         &DsHandle );

    if ( NetStatus != NO_ERROR ) {

        //
        // Only warn if we don't have access
        //

        if ( NetStatus == ERROR_ACCESS_DENIED ) {
            printf("You don't have access to DsBind to %ws (%ws) (Trying NetServerEnum).\n",
                   DomainName,
                   DcInfo->DomainControllerName );
        } else {
            printf("Cannot DsBind to %ws (%ws).",
                   DomainName,
                   DcInfo->DomainControllerName );
            PrintStatus( NetStatus );
        }
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Get the list of DCs from the target DC.
    //
    NetStatus = DsGetDomainControllerInfoW(
                    DsHandle,
                    DcInfo->DomainName,
                    1,      // Info level
                    &DsDcCount,
                    &DsDcInfo );

    if ( NetStatus != NO_ERROR ) {
        printf("Cannot call DsGetDomainControllerInfoW to %ws (%ws).",
               DomainName,
               DcInfo->DomainControllerName );
        PrintStatus( NetStatus );
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Compute the length of the

    DnsLength = 1;
    for ( i=0; i<DsDcCount; i++ ) {
        ULONG Length;
        Length = wcslen( DsDcInfo[i].DnsHostName != NULL ?
                    DsDcInfo[i].DnsHostName :
                    DsDcInfo[i].NetbiosName );

        DnsLength = max( DnsLength, Length );
    }
    DnsLength = min( DnsLength, 50 );

    //
    // Loop though the list of DCs.
    //

    for ( i=0; i<DsDcCount; i++ ) {
        printf("    %*ws",
               DnsLength,
               DsDcInfo[i].DnsHostName != NULL ?
                    DsDcInfo[i].DnsHostName :
                    DsDcInfo[i].NetbiosName );
        if ( DsDcInfo[i].fIsPdc ) {
            printf(" [PDC]");
        } else {
            printf("      ");
        }
        if ( DsDcInfo[i].fDsEnabled ) {
            printf(" [DS]");
        } else {
            printf("     ");
        }
        if ( DsDcInfo[i].SiteName != NULL ) {
            printf(" Site: %ws", DsDcInfo[i].SiteName );
        }
        printf("\n");
    }


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( DsDcInfo != NULL ) {
        DsFreeDomainControllerInfoW( 1, DsDcCount, DsDcInfo );
    }

    if ( DsHandle != NULL ) {
        DsUnBindW( &DsHandle );
    }
    return RetVal;
}

NET_API_STATUS
NetpSockAddrToStr(
    PSOCKADDR SockAddr,
    ULONG SockAddrSize,
    CHAR SockAddrString[NL_SOCK_ADDRESS_LENGTH+1]
    );


int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the Netlogon service by calling I_NetLogonControl2.

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    LPSTR argument;
    int i;
    DWORD FunctionCode = 0;
    LPSTR AnsiServerName = NULL;
    CHAR AnsiUncServerName[DNS_MAX_NAME_LENGTH+2+1];
    LPSTR AnsiDomainName = NULL;
    LPSTR AnsiTrustedDomainName = NULL;
    LPWSTR TrustedDomainName = NULL;
    LPSTR AnsiUserName = NULL;
    LPSTR AnsiSiteName = NULL;
#ifndef NTRK_RELEASE
    LPSTR AnsiPassword = NULL;
    BOOLEAN UnloadNetlogonFlag = FALSE;
#endif // NTRK_RELEASE
    ULONG Rid = 0;
    LPSTR AnsiSimMachineName = NULL;
    LPSTR AnsiDeltaFileName = NULL;
    LPSTR ShutdownReason = NULL;
    LPWSTR ServerName = NULL;
    LPWSTR UserName = NULL;
    PNETLOGON_INFO_1 NetlogonInfo1 = NULL;
    DWORD Level = 1;
    DWORD ShutdownSeconds;
    LPBYTE InputDataPtr = NULL;
    PDOMAIN_CONTROLLER_INFOA DomainControllerInfo;

    DWORD DbFlagValue;

    LARGE_INTEGER ConvertTime;
    ULONG IterationCount;
    ULONG DsGetDcOpenFlags = 0;

    NT_OWF_PASSWORD NtOwfPassword;
    BOOLEAN NtPasswordPresent = FALSE;
    LM_OWF_PASSWORD LmOwfPassword;
    BOOLEAN LmPasswordPresent = FALSE;
    BOOLEAN GetPdcName = FALSE;
    BOOLEAN DoDsGetDcName = FALSE;
    BOOLEAN DoDsGetDcOpen = FALSE;
    BOOLEAN DoDsGetFtinfo = FALSE;
    BOOLEAN DoDsGetSiteName = FALSE;
    BOOLEAN DoDsGetDcSiteCoverage = FALSE;
    BOOLEAN DoGetParentDomain = FALSE;
    DWORD DsGetDcNameFlags = 0;
    DWORD DsGetFtinfoFlags = 0;
    BOOLEAN GetDcList = FALSE;
    BOOLEAN WhoWill = FALSE;
    BOOLEAN QuerySync = FALSE;
    BOOLEAN SimFullSync = FALSE;
    BOOLEAN QueryUser = FALSE;
    BOOLEAN ListDeltasFlag = FALSE;
    BOOLEAN ResetSecureChannelsFlag = FALSE;
    BOOLEAN ShutdownAbort = FALSE;
    BOOLEAN DomainTrustsFlag = FALSE;
    BOOLEAN TrustedDomainsVerboseOutput = FALSE;
    BOOLEAN DeregisterDnsHostRecords = FALSE;
    BOOLEAN DoClientDigest = FALSE;
    BOOLEAN DoServerDigest = FALSE;

    char *StringGuid;
    RPC_STATUS RpcStatus;
    ULONG TrustsNeeded = 0;
    LPSTR AnsiDnsHostName = NULL;
    LPSTR AnsiDnsDomainName = NULL;
    LPSTR StringDomainGuid = NULL;
    LPSTR StringDsaGuid = NULL;
    LPSTR Message = NULL;


#define QUERY_PARAM "/QUERY"
#define REPL_PARAM "/REPL"
#define SYNC_PARAM "/SYNC"
#define PDC_REPL_PARAM "/PDC_REPL"
#define SERVER_PARAM "/SERVER:"
#define PWD_PARAM "/PWD:"
#define RID_PARAM "/RID:"
#define USER_PARAM "/USER:"
#define BP_PARAM "/BP"
#define DBFLAG_PARAM "/DBFLAG:"
#define DCLIST_PARAM "/DCLIST:"
#define DCNAME_PARAM "/DCNAME:"
#define TRUNCATE_LOG_PARAM "/TRUNC"
#define TIME_PARAM "/TIME:"
#define WHOWILL_PARAM "/WHOWILL:"
#define BDC_QUERY_PARAM "/BDC_QUERY:"
#define LOGON_QUERY_PARAM "/LOGON_QUERY"
#define SIM_SYNC_PARAM "/SIM_SYNC:"
#define LIST_DELTAS_PARAM "/LIST_DELTAS:"
#define SC_RESET_PARAM "/SC_RESET:"
#define SC_QUERY_PARAM "/SC_QUERY:"
#define SC_VERIFY_PARAM "/SC_VERIFY:"
#define SC_CHANGE_PASSWORD_PARAM "/SC_CHANGE_PWD:"
#define SHUTDOWN_PARAM "/SHUTDOWN:"
#define SHUTDOWN_ABORT_PARAM "/SHUTDOWN_ABORT"
#define TRANSPORT_PARAM "/TRANSPORT_NOTIFY"
#define FINDUSER_PARAM "/FINDUSER:"
#define TRUSTED_DOMAINS_PARAM "/TRUSTED_DOMAINS"
#define DOMAIN_TRUSTS_PARAM "/DOMAIN_TRUSTS"
#define UNLOAD_PARAM "/UNLOAD"
#define DSGETSITE_PARAM "/DSGETSITE"
#define DSGETSITECOV_PARAM "/DSGETSITECOV"
#define DSDEREGISTERDNS_PARAM    "/DSDEREGDNS:"
#define DSREGISTERDNS_PARAM      "/DSREGDNS"
#define DSQUERYDNS_PARAM      "/DSQUERYDNS"

#define DSGETFTI_PARAM "/DSGETFTI:"
#define UPDATE_TDO_PARAM "/UPDATE_TDO"

#define DSGETDC_PARAM "/DSGETDC:"
#define PARENTDOMAIN_PARAM "/PARENTDOMAIN"
#define PDC_PARAM "/PDC"
#define LDAPONLY_PARAM "/LDAPONLY"
#define DS_PARAM "/DS"
#define DSP_PARAM "/DSP"
#define GC_PARAM "/GC"
#define KDC_PARAM "/KDC"
#define TIMESERV_PARAM "/TIMESERV"
#define GTIMESERV_PARAM "/GTIMESERV"
#define AVOIDSELF_PARAM "/AVOIDSELF"
#define NETBIOS_PARAM "/NETBIOS"
#define DNS_PARAM "/DNS"
#define RET_DNS_PARAM "/RET_DNS"
#define RET_NETBIOS_PARAM "/RET_NETBIOS"
#define IP_PARAM "/IP"
#define BACKG_PARAM "/BACKG"
#define FORCE_PARAM "/FORCE"
#define WRITABLE_PARAM "/WRITABLE"
#define SITE_PARAM "/SITE:"
#define ACCOUNT_PARAM "/ACCOUNT:"
#define VERBOSE_PARAM "/V"
#define TRUSTS_PRIMARY_PARAM "/PRIMARY"
#define TRUSTS_FOREST_PARAM "/FOREST"
#define TRUSTS_DIRECT_OUT_PARAM "/DIRECT_OUT"
#define TRUSTS_DIRECT_IN_PARAM "/DIRECT_IN"
#define TRUSTS_ALL_PARAM "/ALL_TRUSTS"
#define DEREG_DOMAIN_PARAM "/DOM:"
#define DEREG_DOMAIN_GUID "/DOMGUID:"
#define DEREG_DSA_GUID "/DSAGUID:"
#define DSGETDCOPEN_PARAM "/DNSGETDC:"
#define DSGETDCOPEN_SITEONLY "/SITESPEC"

#define GET_SERVER_DIGEST "/SDIGEST:"
#define GET_CLIENT_DIGEST "/CDIGEST:"
#define GET_CLIENT_DIGEST_DOMAIN "/DOMAIN:"

    //
    // Set the netlib debug flag.
    //
    extern DWORD NetlibpTrace;
    NetlibpTrace |= 0x8000; // NETLIB_DEBUG_LOGON
    NlGlobalParameters.DbFlag = 0xFFFFFFFF;

    ConvertTime.QuadPart = 0;
    RtlZeroMemory( &NlGlobalZeroGuid, sizeof(NlGlobalZeroGuid) );


    if ( !CryptAcquireContext(
                    &NlGlobalCryptProvider,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                    ))
    {
        printf("Failed to acquire cryptographic CSP (error=%lu)\n", GetLastError());
        return 2;
    }

    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];


        //
        // Handle /QUERY
        //

        if ( _stricmp( argument, QUERY_PARAM ) == 0 ) {
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_QUERY;


        //
        // Handle /SC_QUERY
        //

        } else if ( _strnicmp( argument,
                        SC_QUERY_PARAM,
                        sizeof(SC_QUERY_PARAM) - 1 ) == 0 ) {
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_TC_QUERY;

            AnsiTrustedDomainName = &argument[sizeof(SC_QUERY_PARAM)-1];

            TrustedDomainName = NetpAllocWStrFromAStr( AnsiTrustedDomainName );

            if ( TrustedDomainName == NULL ) {
                fprintf( stderr, "Not enough memory\n" );
                return(1);
            }

            Level = 2;
            InputDataPtr = (LPBYTE)TrustedDomainName;

        //
        // Handle /SC_CHANGE_PWD
        //

        } else if ( _strnicmp( argument,
                        SC_CHANGE_PASSWORD_PARAM,
                        sizeof(SC_CHANGE_PASSWORD_PARAM) - 1 ) == 0 ) {
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_CHANGE_PASSWORD;

            AnsiTrustedDomainName = &argument[sizeof(SC_CHANGE_PASSWORD_PARAM)-1];

            TrustedDomainName = NetpAllocWStrFromAStr( AnsiTrustedDomainName );

            if ( TrustedDomainName == NULL ) {
                fprintf( stderr, "Not enough memory\n" );
                return(1);
            }

            Level = 1;
            InputDataPtr = (LPBYTE)TrustedDomainName;

        //
        // Handle /FINDUSER
        //

        } else if ( _strnicmp( argument,
                        FINDUSER_PARAM,
                        sizeof(FINDUSER_PARAM) - 1 ) == 0 ) {
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_FIND_USER;

            AnsiUserName = &argument[sizeof(FINDUSER_PARAM)-1];

            TrustedDomainName = NetpAllocWStrFromAStr( AnsiUserName );

            if ( TrustedDomainName == NULL ) {
                fprintf( stderr, "Not enough memory\n" );
                return(1);
            }

            Level = 4;
            InputDataPtr = (LPBYTE)TrustedDomainName;

        //
        // Handle /REPL
        //

        } else if (_stricmp(argument, REPL_PARAM ) == 0 ){
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_REPLICATE;


        //
        // Handle /SYNC
        //

        } else if (_stricmp(argument, SYNC_PARAM ) == 0 ){
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_SYNCHRONIZE;


        //
        // Handle /SC_RESET
        //

        } else if (_strnicmp(argument,
                        SC_RESET_PARAM,
                        sizeof(SC_RESET_PARAM) - 1 ) == 0 ){
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_REDISCOVER;
            AnsiTrustedDomainName = &argument[sizeof(SC_RESET_PARAM)-1];

            TrustedDomainName = NetpAllocWStrFromAStr( AnsiTrustedDomainName );

            if ( TrustedDomainName == NULL ) {
                fprintf( stderr, "Not enough memory\n" );
                return(1);
            }

            Level = 2;
            InputDataPtr = (LPBYTE)TrustedDomainName;

        //
        // Handle /SC_VERIFY
        //

        } else if (_strnicmp(argument,
                        SC_VERIFY_PARAM,
                        sizeof(SC_VERIFY_PARAM) - 1 ) == 0 ){
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_TC_VERIFY;
            AnsiTrustedDomainName = &argument[sizeof(SC_VERIFY_PARAM)-1];

            TrustedDomainName = NetpAllocWStrFromAStr( AnsiTrustedDomainName );

            if ( TrustedDomainName == NULL ) {
                fprintf( stderr, "Not enough memory\n" );
                return(1);
            }

            Level = 2;
            InputDataPtr = (LPBYTE)TrustedDomainName;

        //
        // Handle /QUERY
        //

        } else if ( _stricmp( argument, TRANSPORT_PARAM ) == 0 ) {
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_TRANSPORT_NOTIFY;


        //
        // Handle /PDC_REPL
        //

        } else if (_stricmp(argument, PDC_REPL_PARAM ) == 0 ){
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_PDC_REPLICATE;

#ifndef NTRK_RELEASE

        //
        // Handle /BP
        //

        } else if (_stricmp(argument, BP_PARAM ) == 0 ){
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_BREAKPOINT;
#endif // NTRK_RELEASE

#ifndef NTRK_RELEASE

        //
        // Handle /TRUNCATE_LOG
        //

        } else if (_stricmp(argument, TRUNCATE_LOG_PARAM ) == 0 ){
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_TRUNCATE_LOG;

#endif // NTRK_RELEASE

        //
        // Handle /DBFLAG:dbflag
        //

        } else if (_strnicmp(argument,
                            DBFLAG_PARAM,
                            sizeof(DBFLAG_PARAM)-1 ) == 0 ){
            char *end;

            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_SET_DBFLAG;

            DbFlagValue = strtoul( &argument[sizeof(DBFLAG_PARAM)-1], &end, 16 );
            InputDataPtr = (LPBYTE) ULongToPtr( DbFlagValue );

        //
        // Handle /Time:LSL MSL
        //

        } else if (_strnicmp(argument,
                            TIME_PARAM,
                            sizeof(TIME_PARAM)-1 ) == 0 ){
            char *end;

            if ( ConvertTime.QuadPart != 0 ) {
                goto Usage;
            }

            ConvertTime.LowPart = strtoul( &argument[sizeof(TIME_PARAM)-1], &end, 16 );
            i++;
            argument = argv[i];

            ConvertTime.HighPart = strtoul( argument, &end, 16 );


        //
        // Handle /WHOWILL:Domain User [IterationCount]
        //

        } else if (_strnicmp(argument,
                            WHOWILL_PARAM,
                            sizeof(WHOWILL_PARAM)-1 ) == 0 ){
            char *end;

            if ( AnsiDomainName != NULL ) {
                goto Usage;
            }

            AnsiDomainName = &argument[sizeof(WHOWILL_PARAM)-1];

            i++;
            argument = argv[i];
            AnsiUserName = argument;

            if ( i+1 < argc ) {
                i++;
                argument = argv[i];

                IterationCount = strtoul( argument, &end, 16 );
            } else {
                IterationCount = 1;
            }

            WhoWill = TRUE;



        //
        // Handle /BDC_QUERY:Domain
        //

        } else if (_strnicmp(argument,
                            BDC_QUERY_PARAM,
                            sizeof(BDC_QUERY_PARAM)-1 ) == 0 ){

            if ( AnsiDomainName != NULL ) {
                goto Usage;
            }

            AnsiDomainName = &argument[sizeof(BDC_QUERY_PARAM)-1];
            QuerySync = TRUE;

        //
        // Handle /LOGON_QUERY
        //

        } else if ( _stricmp( argument, LOGON_QUERY_PARAM ) == 0 ) {
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_QUERY;
            Level = 3;

        //
        // Handle full sync simulation
        //

        } else if (_strnicmp(argument,
                            SIM_SYNC_PARAM,
                            sizeof(SIM_SYNC_PARAM)-1 ) == 0 ){

            if ( AnsiDomainName != NULL ) {
                goto Usage;
            }

            AnsiDomainName = &argument[sizeof(SIM_SYNC_PARAM)-1];

            i++;

            if( i >= argc ) {
                goto Usage;
            }

            argument = argv[i];
            AnsiSimMachineName = argument;

            SimFullSync = TRUE;

        //
        // handle delta listing
        //

        } else if (_strnicmp(argument,
                            LIST_DELTAS_PARAM,
                            sizeof(LIST_DELTAS_PARAM)-1 ) == 0 ){

            if ( AnsiDeltaFileName != NULL ) {
                goto Usage;
            }

            AnsiDeltaFileName = &argument[sizeof(LIST_DELTAS_PARAM)-1];

            ListDeltasFlag = TRUE;


        //
        // Handle /DCLIST
        //

        } else if (_strnicmp(argument,
                            DCLIST_PARAM,
                            sizeof(DCLIST_PARAM)-1 ) == 0 ){

            if ( AnsiDomainName != NULL ) {
                goto Usage;
            }

            AnsiDomainName = &argument[sizeof(DCLIST_PARAM)-1];
            GetDcList = TRUE;

        //
        // Handle /DCNAME
        //

        } else if (_strnicmp(argument,
                            DCNAME_PARAM,
                            sizeof(DCNAME_PARAM)-1 ) == 0 ){

            if ( AnsiDomainName != NULL ) {
                goto Usage;
            }

            AnsiDomainName = &argument[sizeof(DCNAME_PARAM)-1];
            GetPdcName = TRUE;


        //
        // Handle /DSGETDC
        //

        } else if (_strnicmp(argument,
                            DSGETDC_PARAM,
                            sizeof(DSGETDC_PARAM)-1 ) == 0 ){

            if ( AnsiDomainName != NULL ) {
                goto Usage;
            }

            AnsiDomainName = &argument[sizeof(DSGETDC_PARAM)-1];
            DoDsGetDcName = TRUE;



        //
        // Handle /DSGETFTI
        //

        } else if (_strnicmp(argument,
                            DSGETFTI_PARAM,
                            sizeof(DSGETFTI_PARAM)-1 ) == 0 ){

            if ( AnsiDomainName != NULL ) {
                goto Usage;
            }

            AnsiDomainName = &argument[sizeof(DSGETFTI_PARAM)-1];
            DoDsGetFtinfo = TRUE;


        //
        // Handle /UPDATE_TDO modifier to /DSGETFTI parameter
        //

        } else if ( _stricmp( argument, UPDATE_TDO_PARAM ) == 0 ) {
            if ( !DoDsGetFtinfo ) {
                goto Usage;
            }

            DsGetFtinfoFlags |= DS_GFTI_UPDATE_TDO;



        //
        // Handle /SERVER:servername
        //

        } else if (_strnicmp(argument, SERVER_PARAM, sizeof(SERVER_PARAM)-1 ) == 0 ){
            if ( AnsiServerName != NULL ) {
                goto Usage;
            }

            AnsiServerName = &argument[sizeof(SERVER_PARAM)-1];

#ifndef NTRK_RELEASE

        //
        // Handle /PWD:password
        //

        } else if (_strnicmp(argument, PWD_PARAM, sizeof(PWD_PARAM)-1 ) == 0 ){
            if ( AnsiPassword != NULL ) {
                goto Usage;
            }

            AnsiPassword = &argument[sizeof(PWD_PARAM)-1];

#endif // NTRK_RELEASE

        //
        // Handle /USER:username
        //

        } else if (_strnicmp(argument, USER_PARAM, sizeof(USER_PARAM)-1 ) == 0 ){
            if ( AnsiUserName != NULL ) {
                goto Usage;
            }

            AnsiUserName = &argument[sizeof(USER_PARAM)-1];
            QueryUser = TRUE;


#ifndef NTRK_RELEASE
        //
        // Handle /RID:relative_id
        //

        } else if (_strnicmp(argument, RID_PARAM, sizeof(RID_PARAM)-1 ) == 0 ){
            char *end;

            if ( Rid != 0 ) {
                goto Usage;
            }

            Rid = strtol( &argument[sizeof(RID_PARAM)-1], &end, 16 );
#endif // NTRK_RELEASE

        //
        // Handle /SHUTDOWN:Reason seconds
        //

        } else if (_strnicmp(argument,
                            SHUTDOWN_PARAM,
                            sizeof(SHUTDOWN_PARAM)-1 ) == 0 ){

            if ( ShutdownReason != NULL ) {
                goto Usage;
            }

            ShutdownReason = &argument[sizeof(SHUTDOWN_PARAM)-1];

            if ( i+1 < argc ) {
                char *end;
                i++;
                argument = argv[i];
                if ( !ISDIGIT(argument[0]) ) {
                    fprintf(stderr, "Second argument to " SHUTDOWN_PARAM " must be a number.\n\n");
                    goto Usage;
                }
                ShutdownSeconds = strtoul( argument, &end, 10 );
            } else {
                ShutdownSeconds = 60;
            }


        //
        // Handle /SHUTDOWN_ABORT
        //

        } else if (_stricmp(argument, SHUTDOWN_ABORT_PARAM ) == 0 ){

            ShutdownAbort = TRUE;


        //
        // Handle /DOMAIN_TRUSTS
        //  Allow the old spelling of //TRUSTED_DOMAINS
        //

        } else if (_stricmp(argument, TRUSTED_DOMAINS_PARAM ) == 0 ||
                   _stricmp(argument, DOMAIN_TRUSTS_PARAM ) == 0 ){

            DomainTrustsFlag = TRUE;

#ifndef NTRK_RELEASE

        //
        // Handle /UNLOAD
        //

        } else if ( _stricmp( argument, UNLOAD_PARAM ) == 0 ) {
            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_UNLOAD_NETLOGON_DLL;
            UnloadNetlogonFlag = TRUE;
#endif // NTRK_RELEASE

        //
        // Handle /DSGETSITE
        //

        } else if ( _stricmp( argument, DSGETSITE_PARAM ) == 0 ) {
            DoDsGetSiteName = TRUE;

        //
        // Handle /DSGETSITECOV
        //

        } else if ( _stricmp( argument, DSGETSITECOV_PARAM ) == 0 ) {
            DoDsGetDcSiteCoverage = TRUE;

        //
        // Handle /PARENTDOMAIN
        //

        } else if ( _stricmp( argument, PARENTDOMAIN_PARAM ) == 0 ) {
            DoGetParentDomain = TRUE;

        //
        // Handle /DSDEREGDNS
        //

        } else if (_strnicmp(argument,
                            DSDEREGISTERDNS_PARAM,
                            sizeof(DSDEREGISTERDNS_PARAM)-1 ) == 0 ){
            DeregisterDnsHostRecords = TRUE;

            if ( AnsiDnsHostName != NULL ) {
                goto Usage;
            }

            AnsiDnsHostName = &argument[sizeof(DSDEREGISTERDNS_PARAM)-1];

        //
        // Handle /DSREGDNS
        //

        } else if ( _stricmp( argument, DSREGISTERDNS_PARAM ) == 0 ) {

            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_FORCE_DNS_REG;

        //
        // Handle /DSQUERYDNS
        //

        } else if ( _stricmp( argument, DSQUERYDNS_PARAM ) == 0 ) {

            if ( FunctionCode != 0 ) {
                goto Usage;
            }

            FunctionCode = NETLOGON_CONTROL_QUERY_DNS_REG;

        //
        // Handle /PDC modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, PDC_PARAM ) == 0 ) {
            if ( !DoDsGetDcName && !DoDsGetDcOpen ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_PDC_REQUIRED;


        //
        // Handle /LDAPONLY modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, LDAPONLY_PARAM ) == 0 ) {
            if ( !DoDsGetDcName && !DoDsGetDcOpen ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_ONLY_LDAP_NEEDED;


        //
        // Handle /DS modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, DS_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_DIRECTORY_SERVICE_REQUIRED;


        //
        // Handle /DSP modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, DSP_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_DIRECTORY_SERVICE_PREFERRED;


        //
        // Handle /KDC modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, KDC_PARAM ) == 0 ) {
            if ( !DoDsGetDcName && !DoDsGetDcOpen ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_KDC_REQUIRED;


        //
        // Handle /TIMESERV modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, TIMESERV_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_TIMESERV_REQUIRED;


        //
        // Handle /GTIMESERV modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, GTIMESERV_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_GOOD_TIMESERV_PREFERRED;


        //
        // Handle /AVOIDSELF modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, AVOIDSELF_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_AVOID_SELF;


        //
        // Handle /GC modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, GC_PARAM ) == 0 ) {
            if ( !DoDsGetDcName && !DoDsGetDcOpen ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_GC_SERVER_REQUIRED;



        //
        // Handle /NETBIOS modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, NETBIOS_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_IS_FLAT_NAME;


        //
        // Handle /DNS modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, DNS_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_IS_DNS_NAME;


        //
        // Handle /RET_DNS modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, RET_DNS_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_RETURN_DNS_NAME;


        //
        // Handle /RET_NETBIOS modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, RET_NETBIOS_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_RETURN_FLAT_NAME;


        //
        // Handle /IP modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, IP_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_IP_REQUIRED;


        //
        // Handle /BACKG modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, BACKG_PARAM ) == 0 ) {
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_BACKGROUND_ONLY;


        //
        // Handle /FORCE modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, FORCE_PARAM ) == 0 ) {
            if ( !DoDsGetDcName && !DoDsGetDcOpen ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_FORCE_REDISCOVERY;


        //
        // Handle /WRITABLE modifier to /DSGETDC parameter
        //

        } else if ( _stricmp( argument, WRITABLE_PARAM ) == 0 ) {
            if ( !DoDsGetDcName && !DoDsGetDcOpen ) {
                goto Usage;
            }

            DsGetDcNameFlags |= DS_WRITABLE_REQUIRED;

        //
        // Handle /SITE:
        //

        } else if (_strnicmp(argument,
                            SITE_PARAM,
                            sizeof(SITE_PARAM)-1 ) == 0 ){
            if ( !DoDsGetDcName && !DoDsGetDcOpen ) {
                goto Usage;
            }

            if ( AnsiSiteName != NULL ) {
                goto Usage;
            }

            AnsiSiteName = &argument[sizeof(SITE_PARAM)-1];

        //
        // Handle /ACCOUNT:
        //

        } else if (_strnicmp(argument,
                            ACCOUNT_PARAM,
                            sizeof(ACCOUNT_PARAM)-1 ) == 0 ){
            if ( !DoDsGetDcName ) {
                goto Usage;
            }

            if ( AnsiUserName != NULL ) {
                goto Usage;
            }

            AnsiUserName = &argument[sizeof(ACCOUNT_PARAM)-1];

        //
        // Handle /PRIMARY modifier to DsEnumerateDomainTrusts
        //

        } else if ( _stricmp( argument, TRUSTS_PRIMARY_PARAM ) == 0 ) {
            if ( !DomainTrustsFlag ) {
                goto Usage;
            }
            TrustsNeeded |= DS_DOMAIN_PRIMARY;

        //
        // Handle /FOREST modifier to DsEnumerateDomainTrusts
        //

        } else if ( _stricmp( argument, TRUSTS_FOREST_PARAM ) == 0 ) {
            if ( !DomainTrustsFlag ) {
                goto Usage;
            }
            TrustsNeeded |= DS_DOMAIN_IN_FOREST;


        //
        // Handle /DIRECT_OUT modifier to DsEnumerateDomainTrusts
        //

        } else if ( _stricmp( argument, TRUSTS_DIRECT_OUT_PARAM ) == 0 ) {
            if ( !DomainTrustsFlag ) {
                goto Usage;
            }
            TrustsNeeded |= DS_DOMAIN_DIRECT_OUTBOUND;

        //
        // Handle /DIRECT_IN modifier to DsEnumerateDomainTrusts
        //

        } else if ( _stricmp( argument, TRUSTS_DIRECT_IN_PARAM ) == 0 ) {
            if ( !DomainTrustsFlag ) {
                goto Usage;
            }
            TrustsNeeded |= DS_DOMAIN_DIRECT_INBOUND;

        //
        // Handle /ALL_TRUSTS modifier to DsEnumerateDomainTrusts
        //

        } else if ( _stricmp( argument, TRUSTS_ALL_PARAM ) == 0 ) {
            if ( !DomainTrustsFlag ) {
                goto Usage;
            }
            TrustsNeeded |= (DS_DOMAIN_PRIMARY |
                             DS_DOMAIN_IN_FOREST |
                             DS_DOMAIN_DIRECT_OUTBOUND |
                             DS_DOMAIN_DIRECT_INBOUND);

        //
        // Handle the verbosity level of the trust output
        //

        } else if ( _stricmp( argument, VERBOSE_PARAM ) == 0 ) {
            if ( !DomainTrustsFlag ) {
                goto Usage;
            }

            TrustedDomainsVerboseOutput = TRUE;

        //
        // Handle /DOM: modifier to DsDeregesterHostDnsRecors
        //

        } else if (_strnicmp(argument,
                            DEREG_DOMAIN_PARAM,
                            sizeof(DEREG_DOMAIN_PARAM)-1 ) == 0 ){
            if ( !DeregisterDnsHostRecords ) {
                goto Usage;
            }

            if ( AnsiDnsDomainName != NULL ) {
                goto Usage;
            }

            AnsiDnsDomainName = &argument[sizeof(DEREG_DOMAIN_PARAM)-1];

        //
        // Handle /DOMGUID: modifier to DsDeregesterHostDnsRecors
        //

        } else if (_strnicmp(argument,
                            DEREG_DOMAIN_GUID,
                            sizeof(DEREG_DOMAIN_GUID)-1 ) == 0 ){
            if ( !DeregisterDnsHostRecords ) {
                goto Usage;
            }

            if ( StringDomainGuid != NULL ) {
                goto Usage;
            }

            StringDomainGuid = &argument[sizeof(DEREG_DOMAIN_GUID)-1];

        //
        // Handle /DSAGUID: modifier to DsDeregesterHostDnsRecors
        //

        } else if (_strnicmp(argument,
                            DEREG_DSA_GUID,
                            sizeof(DEREG_DSA_GUID)-1 ) == 0 ){
            if ( !DeregisterDnsHostRecords ) {
                goto Usage;
            }

            if ( StringDsaGuid != NULL ) {
                goto Usage;
            }

            StringDsaGuid = &argument[sizeof(DEREG_DSA_GUID)-1];

        //
        // Handle /DNSGETDC
        //

        } else if (_strnicmp(argument,
                            DSGETDCOPEN_PARAM,
                            sizeof(DSGETDCOPEN_PARAM)-1 ) == 0 ){

            if ( AnsiDomainName != NULL ) {
                goto Usage;
            }

            AnsiDomainName = &argument[sizeof(DSGETDCOPEN_PARAM)-1];
            DoDsGetDcOpen = TRUE;

        //
        // Handle /SITESPEC modifier to DsGetDcOpen
        //

        } else if ( _stricmp( argument, DSGETDCOPEN_SITEONLY ) == 0 ) {
            if ( !DoDsGetDcOpen ) {
                goto Usage;
            }
            DsGetDcOpenFlags |= DS_ONLY_DO_SITE_NAME;

        //
        // Handle /CDIGEST
        //

        } else if ( _strnicmp( argument,
                              GET_CLIENT_DIGEST,
                              sizeof(GET_CLIENT_DIGEST)-1 ) == 0 ) {

            DoClientDigest = TRUE;

            if ( Message != NULL ) {
                goto Usage;
            }

            Message = &argument[sizeof(GET_CLIENT_DIGEST)-1];

        //
        // Handle domain name for /CDIGEST
        //

        } else if ( _strnicmp( argument,
                               GET_CLIENT_DIGEST_DOMAIN,
                               sizeof(GET_CLIENT_DIGEST_DOMAIN)-1 ) == 0 ) {
            if ( !DoClientDigest ) {
                goto Usage;
            }
            if ( AnsiDomainName != NULL ) {
                goto Usage;
            }

            AnsiDomainName = &argument[sizeof(GET_CLIENT_DIGEST_DOMAIN)-1];

        //
        // Handle /SDIGEST
        //

        } else if ( _strnicmp( argument,
                              GET_SERVER_DIGEST,
                              sizeof(GET_SERVER_DIGEST)-1 ) == 0 ) {

            DoServerDigest = TRUE;

            if ( Message != NULL ) {
                goto Usage;
            }

            Message = &argument[sizeof(GET_SERVER_DIGEST)-1];

        //
        // Handle all other parameters
        //

        } else {
Usage:
            fprintf( stderr, "Usage: nltest [/OPTIONS]\n\n" );

            fprintf(
                stderr,
                "\n"
                "    " SERVER_PARAM "<ServerName> - Specify <ServerName>\n"
                "\n"
                "    " QUERY_PARAM " - Query <ServerName> netlogon service\n"
                "    " REPL_PARAM " - Force partial sync on <ServerName> BDC\n"
                "    " SYNC_PARAM " - Force full sync on <ServerName> BDC\n"
                "    " PDC_REPL_PARAM " - Force UAS change message from <ServerName> PDC\n"
                "\n"
                "    " SC_QUERY_PARAM "<DomainName> - Query secure channel for <Domain> on <ServerName>\n"
                "    " SC_RESET_PARAM "<DomainName>[\\<DcName>] - Reset secure channel for <Domain> on <ServerName> to <DcName>\n"
                "    " SC_VERIFY_PARAM "<DomainName> - Verify secure channel for <Domain> on <ServerName>\n"
                "    " SC_CHANGE_PASSWORD_PARAM "<DomainName> - Change a secure channel  password for <Domain> on <ServerName>\n"
                "    " DCLIST_PARAM "<DomainName> - Get list of DC's for <DomainName>\n"
                "    " DCNAME_PARAM "<DomainName> - Get the PDC name for <DomainName>\n"
                "    " DSGETDC_PARAM "<DomainName> - Call DsGetDcName"
                " " PDC_PARAM
                " " DS_PARAM
                " " DSP_PARAM
                " " GC_PARAM
                " " KDC_PARAM
                "\n        "
                " " TIMESERV_PARAM
                " " GTIMESERV_PARAM
                " " NETBIOS_PARAM
                " " DNS_PARAM
                " " IP_PARAM
                " " FORCE_PARAM
                " " WRITABLE_PARAM
                " " AVOIDSELF_PARAM
                " " LDAPONLY_PARAM
                " " BACKG_PARAM
                "\n        "
                " " SITE_PARAM "<SiteName>"
                " " ACCOUNT_PARAM "<AccountName>"
                " " RET_DNS_PARAM
                " " RET_NETBIOS_PARAM
                "\n"
                "    " DSGETDCOPEN_PARAM "<DomainName> - Call DsGetDcOpen/Next/Close"
                " " PDC_PARAM
                " " GC_PARAM
                "\n        "
                " " KDC_PARAM
                " " WRITABLE_PARAM
                " " LDAPONLY_PARAM
                " " FORCE_PARAM
                " " DSGETDCOPEN_SITEONLY
                "\n"
                "    " DSGETFTI_PARAM "<DomainName> - Call DsGetForestTrustInformation"
                "\n        "
                " " UPDATE_TDO_PARAM
                "\n"
                "    " DSGETSITE_PARAM " - Call DsGetSiteName\n"
                "    " DSGETSITECOV_PARAM " - Call DsGetDcSiteCoverage\n"
                "    " PARENTDOMAIN_PARAM " - Get the name of the parent domain of this machine\n"
                "    " WHOWILL_PARAM "<Domain>* <User> [<Iteration>] - See if <Domain> will log on <User>\n"
                "    " FINDUSER_PARAM "<User> - See which trusted domain will log on <User>\n"
                "    " TRANSPORT_PARAM " - Notify netlogon of new transport\n"
                "\n"
#ifndef NTRK_RELEASE
                "    " BP_PARAM " - Force a BreakPoint in Netlogon on <ServerName>\n"
#endif // NTRK_RELEASE
                "    " DBFLAG_PARAM "<HexFlags> - New debug flag\n"
#ifndef NTRK_RELEASE
                "    " TRUNCATE_LOG_PARAM " - Truncate log file (rename to *.bak)\n"
                "    " UNLOAD_PARAM " - Unload netlogon.dll from lsass.exe\n"
#endif // NTRK_RELEASE
                "\n"
#ifndef NTRK_RELEASE
                "    " PWD_PARAM "<CleartextPassword> - Specify Password to encrypt\n"
                "    " RID_PARAM "<HexRid> - RID to encrypt Password with\n"
#endif // NTRK_RELEASE
                "    " USER_PARAM "<UserName> - Query User info on <ServerName>\n"
                "\n"
                "    " TIME_PARAM "<Hex LSL> <Hex MSL> - Convert NT GMT time to ascii\n"
                "    " LOGON_QUERY_PARAM " - Query number of cumulative logon attempts\n"
                "    " DOMAIN_TRUSTS_PARAM " - Query domain trusts on <ServerName>"
                "\n        "
                " " TRUSTS_PRIMARY_PARAM
                " " TRUSTS_FOREST_PARAM
                " " TRUSTS_DIRECT_OUT_PARAM
                " " TRUSTS_DIRECT_IN_PARAM
                " " TRUSTS_ALL_PARAM
                " " VERBOSE_PARAM
                "\n"
                "    " DSREGISTERDNS_PARAM " - Force registration of all DC-specific DNS records"
                "\n"
                "    " DSDEREGISTERDNS_PARAM "<DnsHostName> - Deregister DC-specific DNS records for specified DC"
                "\n        "
                " " DEREG_DOMAIN_PARAM "<DnsDomainName>"
                " " DEREG_DOMAIN_GUID  "<DomainGuid>"
                " " DEREG_DSA_GUID     "<DsaGuid>"
                "\n"
                "    " DSQUERYDNS_PARAM " - Query the status of the last update for all DC-specific DNS records"
                "\n\n"
                "    " BDC_QUERY_PARAM "<DomainName> - Query replication status of BDCs for <DomainName>\n"
                "    " SIM_SYNC_PARAM "<DomainName> <MachineName> - Simulate full sync replication\n"
                "\n"
                "    " LIST_DELTAS_PARAM "<FileName> - display the content of given change log file \n"
                "\n"
                "    " GET_CLIENT_DIGEST "<Message> "GET_CLIENT_DIGEST_DOMAIN "<DomainName> - Get client digest\n"
                "    " GET_SERVER_DIGEST "<Message> "RID_PARAM "<RID in hex> - Get server digest\n"
                "\n"
                "    " SHUTDOWN_PARAM "<Reason> [<Seconds>] - Shutdown <ServerName> for <Reason>\n"
                "    " SHUTDOWN_ABORT_PARAM " - Abort a system shutdown\n"
                "\n" );
            return(1);
        }
    }


    //
    // Convert the server name to unicode.
    //

    if ( AnsiServerName != NULL ) {
        if ( AnsiServerName[0] == '\\' && AnsiServerName[1] == '\\' ) {
            ServerName = NetpAllocWStrFromAStr( AnsiServerName );
        } else {

            if ( strlen(AnsiServerName) > DNS_MAX_NAME_LENGTH ) {
                fprintf( stderr, "Invalid server name\n" );
                return(1);
            }
            AnsiUncServerName[0] = '\\';
            AnsiUncServerName[1] = '\\';
            strcpy(AnsiUncServerName+2, AnsiServerName);
            ServerName = NetpAllocWStrFromAStr( AnsiUncServerName );
            AnsiServerName = AnsiUncServerName;
        }
    }

    //
    // Convert the user name to unicode.
    //

    if ( AnsiUserName != NULL ) {

        UserName = NetpAllocWStrFromAStr( AnsiUserName );

        if ( UserName == NULL ) {
            fprintf( stderr, "Not enough memory\n" );
            return(1);
        }
    }


    //
    // If we've been asked to contact the Netlogon service,
    //  Do so
    //

    if ( FunctionCode != 0 ) {


        //
        // The dbflag should be set in the registry as well as in netlogon
        // proper.
        //

        if ( FunctionCode == NETLOGON_CONTROL_SET_DBFLAG ) {
            SetDbflagInRegistry( ServerName, DbFlagValue );
        }

        NetStatus = I_NetLogonControl2( ServerName,
                                       FunctionCode,
                                       Level,
                                       (LPBYTE) &InputDataPtr,
                                       (LPBYTE *)&NetlogonInfo1 );

        if ( NetStatus != NERR_Success ) {
            fprintf( stderr, "I_NetLogonControl failed: " );
            PrintStatus( NetStatus );
            return(1);
        }

        if( (Level == 1) || (Level == 2) ) {

            //
            // Print level 1  information
            //

            printf( "Flags: %lx", NetlogonInfo1->netlog1_flags );

            if ( NetlogonInfo1->netlog1_flags & NETLOGON_REPLICATION_IN_PROGRESS ) {

                if ( NetlogonInfo1->netlog1_flags & NETLOGON_FULL_SYNC_REPLICATION ) {
                    printf( " FULL_SYNC " );
                }
                else {
                    printf( " PARTIAL_SYNC " );
                }

                printf( " REPLICATION_IN_PROGRESS" );
            }
            else if ( NetlogonInfo1->netlog1_flags & NETLOGON_REPLICATION_NEEDED ) {

                if ( NetlogonInfo1->netlog1_flags & NETLOGON_FULL_SYNC_REPLICATION ) {
                    printf( " FULL_SYNC " );
                }
                else {
                    printf( " PARTIAL_SYNC " );
                }

                printf( " REPLICATION_NEEDED" );
            }
            if ( NetlogonInfo1->netlog1_flags & NETLOGON_REDO_NEEDED) {
                printf( " REDO_NEEDED" );
            }
            if ( Level != 2 ) {
                printf( "\n" );
            }

            //
            // For level 2, this is superfluous (same as tc_connection_status) or
            //  miss leading (the status for the BDC to PDC trust not for the queried domain).
            //

            if ( Level != 2 ) {
                printf( "Connection ");
                PrintStatus( NetlogonInfo1->netlog1_pdc_connection_status );
            }

            //
            // Output the last DNS update status if asked
            //
            if ( FunctionCode == NETLOGON_CONTROL_QUERY_DNS_REG ) {
                if ( NetlogonInfo1->netlog1_flags & NETLOGON_DNS_UPDATE_FAILURE ) {
                    printf( "There was a failure in the last update for one of the DC-specific DNS records\n" );
                } else {
                    printf( "There was no failure in the last update for all DC-specific DNS records\n" );
                }
            }
        }

        if( Level == 2 ) {

            //
            // Print level 2 only information
            //

            PNETLOGON_INFO_2  NetlogonInfo2;

            NetlogonInfo2 = (PNETLOGON_INFO_2)NetlogonInfo1;

            if ( NetlogonInfo2->netlog2_flags & NETLOGON_HAS_IP ) {
                printf( " HAS_IP " );
            }
            if ( NetlogonInfo2->netlog2_flags & NETLOGON_HAS_TIMESERV ) {
                printf( " HAS_TIMESERV " );
            }
            printf("\n");

            printf("Trusted DC Name %ws \n",
                NetlogonInfo2->netlog2_trusted_dc_name );
            printf("Trusted DC Connection Status ");
            PrintStatus( NetlogonInfo2->netlog2_tc_connection_status );

            //
            // If the server returned the trust verification status,
            //  print it out
            //
            if ( NetlogonInfo2->netlog2_flags & NETLOGON_VERIFY_STATUS_RETURNED ) {
                printf("Trust Verification ");
                PrintStatus( NetlogonInfo2->netlog2_pdc_connection_status );
            }
        }
        if ( Level == 3 ) {
            printf( "Number of attempted logons: %ld\n",
                    ((PNETLOGON_INFO_3)NetlogonInfo1)->netlog3_logon_attempts );
        }
        if( Level == 4 ) {

            PNETLOGON_INFO_4  NetlogonInfo4;

            NetlogonInfo4 = (PNETLOGON_INFO_4)NetlogonInfo1;

            printf("Domain Name: %ws\n",
                NetlogonInfo4->netlog4_trusted_domain_name );
            printf("Trusted DC Name %ws \n",
                NetlogonInfo4->netlog4_trusted_dc_name );
        }

        NetApiBufferFree( NetlogonInfo1 );
    }

#ifndef NTRK_RELEASE
    //
    // If we've been asked to debug password encryption,
    //  do so.
    //

    if ( AnsiPassword != NULL ) {
        LPWSTR Password = NULL;
        UNICODE_STRING UnicodePasswordString;
        STRING AnsiPasswordString;
        CHAR LmPasswordBuffer[LM20_PWLEN + 1];

        Password = NetpAllocWStrFromAStr( AnsiPassword );
        RtlInitUnicodeString( &UnicodePasswordString, Password );


        //
        // Compute the NT One-Way-Function of the password
        //

        Status = RtlCalculateNtOwfPassword( &UnicodePasswordString,
                                            &NtOwfPassword );
        if ( !NT_SUCCESS(Status) ) {
            fprintf( stderr, "RtlCalculateNtOwfPassword failed: 0x%lx", Status);
            return(1);
        }

        printf( "NT OWF Password for: %s             ", AnsiPassword );
        DumpBuffer( &NtOwfPassword, sizeof( NtOwfPassword ));
        printf("\n");
        NtPasswordPresent = TRUE;



        //
        // Compute the Ansi version to the Cleartext password.
        //
        //  The Ansi version of the Cleartext password is at most 14 bytes long,
        //      exists in a trailing zero filled 15 byte buffer,
        //      is uppercased.
        //

        AnsiPasswordString.Buffer = LmPasswordBuffer;
        AnsiPasswordString.MaximumLength = sizeof(LmPasswordBuffer);

        RtlZeroMemory( LmPasswordBuffer, sizeof(LmPasswordBuffer) );

        Status = RtlUpcaseUnicodeStringToOemString(
                   &AnsiPasswordString,
                   &UnicodePasswordString,
                   FALSE );

         if ( !NT_SUCCESS(Status) ) {

            RtlZeroMemory( LmPasswordBuffer, sizeof(LmPasswordBuffer) );
            Status = STATUS_SUCCESS;

            printf( "LM OWF Password for: %s\n", AnsiPassword );
            printf( "   ----- Password doesn't translate from unicode ----\n");
            LmPasswordPresent = FALSE;

         } else {

            Status = RtlCalculateLmOwfPassword(
                            LmPasswordBuffer,
                            &LmOwfPassword);
            printf( "LM OWF Password for: %s             ", AnsiPassword );
            DumpBuffer( &LmOwfPassword, sizeof( LmOwfPassword ));
            printf("\n");
            LmPasswordPresent = TRUE;
        }

    }

    //
    // If we've been given a Rid,
    //  use it to further encrypt the password
    //

    if ( Rid != 0 ) {
        ENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword;
        ENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword;

        if ( NtPasswordPresent ) {

            Status = RtlEncryptNtOwfPwdWithIndex(
                           &NtOwfPassword,
                           &Rid,
                           &EncryptedNtOwfPassword
                           );

            printf( "NT OWF Password encrypted by: 0x%lx    ", Rid );
            if ( NT_SUCCESS( Status ) ) {
                DumpBuffer( &EncryptedNtOwfPassword,sizeof(EncryptedNtOwfPassword));
                printf("\n");
            } else {
                printf( "RtlEncryptNtOwfPwdWithIndex returns 0x%lx\n", Status );
            }
        }

        if ( LmPasswordPresent ) {

            Status = RtlEncryptLmOwfPwdWithIndex(
                           &LmOwfPassword,
                           &Rid,
                           &EncryptedLmOwfPassword
                           );

            printf( "LM OWF Password encrypted by: 0x%lx    ", Rid );
            if ( NT_SUCCESS( Status ) ) {
                DumpBuffer( &EncryptedLmOwfPassword,sizeof(EncryptedLmOwfPassword));
                printf("\n");
            } else {
                printf( "RtlEncryptNtOwfPwdWithIndex returns 0x%lx\n", Status );
            }
        }
    }
#endif // NTRK_RELEASE

    //
    // If we've been asked to query a user,
    //  do so.
    //

    if ( QueryUser ) {
        if ( AnsiUserName != NULL && *AnsiUserName != L'\0' ) {
            PrintUserInfo( ServerName, AnsiUserName );
        } else {
            goto Usage;
        }
    }

    //
    // If we've been asked to get the list of domain controllers,
    //  Do so
    //

    if ( AnsiDomainName != NULL ) {
        LPWSTR DomainName;

        DomainName = NetpAllocWStrFromAStr( AnsiDomainName );

        if ( DomainName == NULL ) {
            fprintf( stderr, "Not enough memory\n" );
            return(1);
        }

        if ( GetPdcName ) {
            LPWSTR PdcName;

            NetStatus = NetGetDCName(
                            ServerName,
                            DomainName,
                            (LPBYTE *)&PdcName );

            if ( NetStatus != NERR_Success ) {
                fprintf( stderr, "NetGetDCName failed: " );
                PrintStatus( NetStatus );
                return(1);
            }

            printf( "PDC for Domain " FORMAT_LPWSTR " is " FORMAT_LPWSTR "\n",
                    DomainName, PdcName );


        } else if ( DoDsGetDcName ) {


            NetStatus = DsGetDcNameWithAccountA(
                            AnsiServerName,
                            AnsiUserName,
                            AnsiUserName == NULL ? 0 : 0xFFFFFFFF,
                            AnsiDomainName,
                            NULL,       // No domain guid
                            AnsiSiteName,
                            DsGetDcNameFlags,
                            &DomainControllerInfo );

            if ( NetStatus != NERR_Success ) {
                fprintf( stderr, "DsGetDcName failed: ");
                PrintStatus( NetStatus );
                return(1);
            }

            printf("           DC: %s\n", DomainControllerInfo->DomainControllerName );
            printf("      Address: %s\n", DomainControllerInfo->DomainControllerAddress );

            if ( !IsEqualGUID( &DomainControllerInfo->DomainGuid, &NlGlobalZeroGuid) ) {

                RpcStatus = UuidToStringA( &DomainControllerInfo->DomainGuid, &StringGuid );
                if ( RpcStatus != RPC_S_OK ) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                printf("     Dom Guid: %s\n", StringGuid );
                RpcStringFreeA( &StringGuid );
            }

            if ( DomainControllerInfo->DomainName != NULL ) {
                printf("     Dom Name: %s\n", DomainControllerInfo->DomainName );
            }
            if ( DomainControllerInfo->DnsForestName != NULL ) {
                printf("  Forest Name: %s\n", DomainControllerInfo->DnsForestName );
            }
            if ( DomainControllerInfo->DcSiteName != NULL ) {
                printf(" Dc Site Name: %s\n", DomainControllerInfo->DcSiteName );
            }
            if ( DomainControllerInfo->ClientSiteName != NULL ) {
                printf("Our Site Name: %s\n", DomainControllerInfo->ClientSiteName );
            }
            if ( DomainControllerInfo->Flags ) {
                printf("        Flags:" );
                if ( DomainControllerInfo->Flags & DS_NDNC_FLAG ) {
                    printf(" NDNC");
                    DomainControllerInfo->Flags &= ~DS_NDNC_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_PDC_FLAG ) {
                    printf(" PDC");
                    DomainControllerInfo->Flags &= ~DS_PDC_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_GC_FLAG ) {
                    printf(" GC");
                    DomainControllerInfo->Flags &= ~DS_GC_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_DS_FLAG ) {
                    printf(" DS");
                    DomainControllerInfo->Flags &= ~DS_DS_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_LDAP_FLAG ) {
                    printf(" LDAP");
                    DomainControllerInfo->Flags &= ~DS_LDAP_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_KDC_FLAG ) {
                    printf(" KDC");
                    DomainControllerInfo->Flags &= ~DS_KDC_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_TIMESERV_FLAG ) {
                    printf(" TIMESERV");
                    DomainControllerInfo->Flags &= ~DS_TIMESERV_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_GOOD_TIMESERV_FLAG ) {
                    printf(" GTIMESERV");
                    DomainControllerInfo->Flags &= ~DS_GOOD_TIMESERV_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_WRITABLE_FLAG ) {
                    printf(" WRITABLE");
                    DomainControllerInfo->Flags &= ~DS_WRITABLE_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_DNS_CONTROLLER_FLAG ) {
                    printf(" DNS_DC");
                    DomainControllerInfo->Flags &= ~DS_DNS_CONTROLLER_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_DNS_DOMAIN_FLAG ) {
                    printf(" DNS_DOMAIN");
                    DomainControllerInfo->Flags &= ~DS_DNS_DOMAIN_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_DNS_FOREST_FLAG ) {
                    printf(" DNS_FOREST");
                    DomainControllerInfo->Flags &= ~DS_DNS_FOREST_FLAG;
                }
                if ( DomainControllerInfo->Flags & DS_CLOSEST_FLAG ) {
                    printf(" CLOSE_SITE");
                    DomainControllerInfo->Flags &= ~DS_CLOSEST_FLAG;
                }
                if ( DomainControllerInfo->Flags != 0 ) {
                    printf(" 0x%lX", DomainControllerInfo->Flags);
                }
                printf("\n");
            }

        } else if ( DoDsGetFtinfo ) {
            PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo;
            ULONG Index;


            NetStatus = DsGetForestTrustInformationW(
                            ServerName,
                            DomainName,
                            DsGetFtinfoFlags,
                            &ForestTrustInfo );

            if ( NetStatus != NERR_Success ) {
                fprintf( stderr, "DsGetForestTrustInformation failed: ");
                PrintStatus( NetStatus );
                return(1);
            }


            for ( Index=0; Index<ForestTrustInfo->RecordCount; Index++ ) {

                switch ( ForestTrustInfo->Entries[Index]->ForestTrustType ) {
                case ForestTrustTopLevelName:
                    printf( "TLN: %wZ\n",
                            &ForestTrustInfo->Entries[Index]->ForestTrustData.TopLevelName );
                    break;
                case ForestTrustDomainInfo:
                    printf( "Dom: %wZ (%wZ)\n",
                            &ForestTrustInfo->Entries[Index]->ForestTrustData.DomainInfo.DnsName,
                            &ForestTrustInfo->Entries[Index]->ForestTrustData.DomainInfo.NetbiosName );
                    break;
                default:
                    printf( "Invalid Type: %ld\n", ForestTrustInfo->Entries[Index]->ForestTrustType );
                }
            }

        } else if ( GetDcList ) {

            if ( !GetDcListFromDs( DomainName ) ) {
                DWORD DCCount;
                PUNICODE_STRING DCNames;
                DWORD i;

                NetStatus = I_NetGetDCList(
                                ServerName,
                                DomainName,
                                &DCCount,
                                &DCNames );

                if ( NetStatus != NERR_Success ) {
                    fprintf( stderr, "I_NetGetDCList failed: ");
                    PrintStatus( NetStatus );
                    return(1);
                }

                printf( "List of DCs in Domain " FORMAT_LPWSTR "\n", DomainName );
                for (i=0; i<DCCount; i++ ) {
                    if ( DCNames[i].Length > 0 ) {
                        printf("    %wZ", &DCNames[i] );
                    } else {
                        printf("    NULL");
                    }
                    if ( i==0 ) {
                        printf( " (PDC)");
                    }
                    printf("\n");
                }
            }

        } else if ( WhoWill ) {

            if ( DomainName != NULL && *DomainName != L'\0' ) {
                WhoWillLogMeOn( DomainName, UserName, IterationCount );
            } else {
                goto Usage;
            }

        } else if( QuerySync ) {

            DWORD DCCount;
            PUNICODE_STRING DCNames;
            DWORD i;
            PNETLOGON_INFO_1 SyncNetlogonInfo1 = NULL;
            LPWSTR SyncServerName = NULL;

            NetStatus = I_NetGetDCList(
                            ServerName,
                            DomainName,
                            &DCCount,
                            &DCNames );

            if ( NetStatus != NERR_Success ) {
                fprintf( stderr, "I_NetGetDCList failed: ");
                PrintStatus( NetStatus );
                return(1);
            }

            for (i=1; i<DCCount; i++ ) {

                if ( DCNames[i].Length > 0 ) {
                    SyncServerName = DCNames[i].Buffer;
                } else {
                    SyncServerName = NULL;
                }

                NetStatus = I_NetLogonControl(
                                SyncServerName,
                                NETLOGON_CONTROL_QUERY,
                                1,
                                (LPBYTE *)&SyncNetlogonInfo1 );

                if ( NetStatus != NERR_Success ) {
                    printf( "Server : " FORMAT_LPWSTR "\n", SyncServerName );
                    printf( "\tI_NetLogonControl failed: ");
                    PrintStatus( NetStatus );
                }
                else {

                    printf( "Server : " FORMAT_LPWSTR "\n", SyncServerName );

                    printf( "\tSyncState : " );

                    if ( SyncNetlogonInfo1->netlog1_flags == 0 ) {
                        printf( " IN_SYNC \n" );
                    }
                    else if ( SyncNetlogonInfo1->netlog1_flags & NETLOGON_REPLICATION_IN_PROGRESS ) {
                        printf( " REPLICATION_IN_PROGRESS \n" );
                    }
                    else if ( SyncNetlogonInfo1->netlog1_flags & NETLOGON_REPLICATION_NEEDED ) {
                        printf( " REPLICATION_NEEDED \n" );
                    } else {
                        printf( " UNKNOWN \n" );
                    }

                    printf( "\tConnectionState : ");
                    PrintStatus( SyncNetlogonInfo1->netlog1_pdc_connection_status );

                    NetApiBufferFree( SyncNetlogonInfo1 );
                }
            }
        } else if( SimFullSync ) {

            LPWSTR MachineName;
            LPWSTR PdcName;

            MachineName = NetpAllocWStrFromAStr( AnsiSimMachineName );

            if ( MachineName == NULL ) {
                fprintf( stderr, "Not enough memory\n" );
                return(1);
            }

            NetStatus = NetGetDCName(
                            ServerName,
                            DomainName,
                            (LPBYTE *)&PdcName );

            if ( NetStatus != NERR_Success ) {
                fprintf( stderr, "NetGetDCName failed: " );
                PrintStatus( NetStatus );
                return(1);
            }

            Status = SimulateFullSync( PdcName, MachineName );

            if ( !NT_SUCCESS( Status )) {
                return(1);
            }
        }
    }

    //
    // if we are asked to display the change log file. do so.
    //

    if( ListDeltasFlag ) {

        LPWSTR DeltaFileName;

        DeltaFileName = NetpAllocWStrFromAStr( AnsiDeltaFileName );

        if ( DeltaFileName == NULL ) {
            fprintf( stderr, "Not enough memory\n" );
            return(1);
        }

        ListDeltas( DeltaFileName );
    }


    //
    // Handle shutting down a system.
    //

    if ( ShutdownReason != NULL ) {
        if ( !InitiateSystemShutdownExA( AnsiServerName,
                                       ShutdownReason,
                                       ShutdownSeconds,
                                       FALSE,     // Don't lose unsaved changes
                                       TRUE,      // Reboot when done
                                       SHTDN_REASON_FLAG_PLANNED |
                                        SHTDN_REASON_MAJOR_APPLICATION |
                                        SHTDN_REASON_MINOR_MAINTENANCE ) ) {
            fprintf( stderr, "InitiateSystemShutdownEx failed: ");
            PrintStatus( GetLastError() );
            return 1;
        }
    }

    if ( ShutdownAbort ) {
        if ( !AbortSystemShutdownA( AnsiServerName ) ) {
            fprintf( stderr, "AbortSystemShutdown failed: ");
            PrintStatus( GetLastError() );
            return 1;
        }
    }


    //
    // Print the list of domain trusts on a workstation.
    //
    if ( DomainTrustsFlag ) {
        ULONG CurrentIndex;
        ULONG EntryCount;
        PDS_DOMAIN_TRUSTSA TrustedDomainList;

        if ( TrustsNeeded == 0 ) {
            TrustsNeeded = DS_DOMAIN_VALID_FLAGS;
        }

        NetStatus = DsEnumerateDomainTrustsA(
                    AnsiServerName,
                    TrustsNeeded,
                    &TrustedDomainList,
                    &EntryCount );

        if ( NetStatus != NO_ERROR ) {
            fprintf( stderr, "DsEnumerateDomainTrusts failed: ");
            PrintStatus( NetStatus );
            return 1;
        }

        printf( "List of domain trusts:\n" );

        for ( CurrentIndex=0; CurrentIndex<EntryCount; CurrentIndex++ ) {

            printf( "    %ld:", CurrentIndex );
            NlPrintTrustedDomain( (PDS_DOMAIN_TRUSTSW)&TrustedDomainList[CurrentIndex],
                                  TrustedDomainsVerboseOutput,
                                  TRUE );

        }

        NetApiBufferFree( TrustedDomainList );
    }

    //
    // Print the site names of all sites covered by this DC
    //
    if ( DoDsGetDcSiteCoverage ) {
        LPSTR *SiteNames;
        ULONG Nsites, i;

        NetStatus = DsGetDcSiteCoverageA(
                        AnsiServerName,
                        &Nsites,
                        &SiteNames);

        if ( NetStatus != NERR_Success ) {
            fprintf( stderr, "DsGetDcSiteCoverage failed: ");
            PrintStatus( NetStatus );
            return(1);
        }

        for ( i = 0; i < Nsites; i++ ) {
            printf("%s\n", SiteNames[i]);
        }

        NetApiBufferFree( SiteNames );
    }


    //
    // Get the site name of a machine.
    //

    if ( DoDsGetSiteName ) {
        LPSTR SiteName;

        NetStatus = DsGetSiteNameA(
                        AnsiServerName,
                        &SiteName );

        if ( NetStatus != NERR_Success ) {
            fprintf( stderr, "DsGetSiteName failed: ");
            PrintStatus( NetStatus );
            return(1);
        }

        printf("%s\n", SiteName );
    }

    //
    // Get the parent domain of a machine.
    //

    if ( DoGetParentDomain ) {
        LPWSTR ParentName;
        BOOL PdcSameSite;

        NetStatus = NetLogonGetTimeServiceParentDomain(
                        ServerName,
                        &ParentName,
                        &PdcSameSite );

        if ( NetStatus != NERR_Success ) {
            fprintf( stderr, "GetParentDomain failed: ");
            PrintStatus( NetStatus );
            return(1);
        }

        printf("%ws (%ld)\n", ParentName, PdcSameSite );
    }

    //
    // Deregister DNS host records
    //

    if ( DeregisterDnsHostRecords ) {

        RPC_STATUS RpcStatus;
        GUID DomainGuid;
        GUID DsaGuid;

        //
        // Convert domain Guid string into the domain Guid
        //
        if ( StringDomainGuid != NULL ) {
            RpcStatus = UuidFromStringA ( StringDomainGuid, &DomainGuid );
            if ( RpcStatus != RPC_S_OK ) {
                fprintf( stderr, "ERROR: Invalid Domain GUID specified\n" );
                return(1);
            }
        }

        //
        // Convert Dsa Guid string into the Dsa Guid
        //
        if ( StringDsaGuid != NULL ) {
            RpcStatus = UuidFromStringA ( StringDsaGuid, &DsaGuid );
            if ( RpcStatus != RPC_S_OK ) {
                fprintf( stderr, "ERROR: Invalid DSA GUID specified\n" );
                return(1);
            }
        }

        NetStatus = DsDeregisterDnsHostRecordsA (
                          AnsiServerName,
                          AnsiDnsDomainName,
                          StringDomainGuid == NULL ? NULL : &DomainGuid,
                          StringDsaGuid == NULL ? NULL : &DsaGuid,
                          AnsiDnsHostName );

        if ( NetStatus != NERR_Success ) {
            fprintf( stderr, "DsDeregisterDnsHostRecordsA failed: ");
            PrintStatus( NetStatus );
            return(1);
        }
    }

    //
    // Get the list of DC records in DNS for a given domain
    //

    if ( DoDsGetDcOpen ) {
        HANDLE DsGetDcHandle = NULL;
        ULONG SockAddressCount = 0;
        LPSOCKET_ADDRESS SockAddressList = NULL;
        CHAR SockAddrString[NL_SOCK_ADDRESS_LENGTH+1];
        LPSTR AnsiHostName = NULL;
        BOOL PreamblePrinted = FALSE;
        BOOL SiteSpecPrinted = FALSE;
        BOOL NonSiteSpecPrinted = FALSE;
        WORD wVersionRequested;
        WSADATA wsaData;

        //
        // Initilaize Winsock (needed for NetpSockAddrToStr);
        //

        wVersionRequested = MAKEWORD( 1, 1 );
        NetStatus = WSAStartup( wVersionRequested, &wsaData );
        if ( NetStatus != 0 ) {
            fprintf( stderr, "Cannot initialize winsock: " );
            PrintStatus( NetStatus );
            return(1);
        }

        //
        // Get a context for the DNS name queries.
        //

        NetStatus = DsGetDcOpenA( AnsiDomainName,
                                  DS_NOTIFY_AFTER_SITE_RECORDS | DsGetDcOpenFlags,
                                  AnsiSiteName,
                                  NULL,   // No domain guid
                                  NULL,   // No forest name
                                  DsGetDcNameFlags,
                                  &DsGetDcHandle );

        if ( NetStatus != NO_ERROR ) {
            fprintf( stderr, "DsGetDcOpenA failed: ");
            PrintStatus( NetStatus );
            return(1);
        }

        //
        // Loop getting addresses
        //

        for ( ;; ) {

            //
            // Free any memory from a previous iteration.
            //

            if ( SockAddressList != NULL ) {
                LocalFree( SockAddressList );
                SockAddressList = NULL;
            }
            if ( AnsiHostName != NULL ) {
                NetApiBufferFree( AnsiHostName );
                AnsiHostName = NULL;
            }

            //
            // Get the next set of IP addresses from DNS
            //

            NetStatus = DsGetDcNextA( DsGetDcHandle,
                                      &SockAddressCount,
                                      &SockAddressList,
                                      &AnsiHostName );

            //
            // Process the exeptional conditions
            //

            if ( NetStatus == NO_ERROR ) {
                ULONG i;

                if ( !PreamblePrinted ) {
                    printf( "List of DCs in pseudo-random order taking into account SRV priorities and weights:\n" );
                    PreamblePrinted = TRUE;
                }

                if ( AnsiSiteName != NULL && !SiteSpecPrinted ) {
                    printf( "Site specific:\n" );
                    SiteSpecPrinted = TRUE;
                }

                if ( AnsiSiteName == NULL && !NonSiteSpecPrinted ) {
                    printf( "Non-Site specific:\n" );
                    NonSiteSpecPrinted = TRUE;
                }

                printf( "   %s", AnsiHostName );

                for (i = 0; i < SockAddressCount; i++ ) {
                    NetStatus = NetpSockAddrToStr( SockAddressList[i].lpSockaddr,
                                                   SockAddressList[i].iSockaddrLength,
                                                   SockAddrString );

                    if ( NetStatus == NO_ERROR ) {
                        printf( "  %s", SockAddrString );
                    }
                }

                printf( "\n" );

            //
            // If the A record cannot be found for the SRV record in DNS,
            //  try the other name type.
            //
            } else if ( NetStatus == DNS_ERROR_RCODE_NAME_ERROR ) {

                printf( "WARNING: No records available of specified type\n" );
                continue;

            //
            // If we've processed all of the site specific SRV records
            //  just indicate that we continue with non-site specific
            //
            } else if ( NetStatus == ERROR_FILEMARK_DETECTED ) {

                AnsiSiteName = NULL;
                continue;

            //
            // If we're done,
            //  break out of the loop.
            //
            } else if ( NetStatus == ERROR_NO_MORE_ITEMS ) {

                break;

            //
            // If DNS isn't available,
            //  blow this request away.
            //
            } else if ( NetStatus == ERROR_TIMEOUT ||
                        NetStatus == DNS_ERROR_RCODE_SERVER_FAILURE ) { // Server failed

                fprintf( stderr, "ERROR: DNS server failure: ");
                PrintStatus( NetStatus );
                return(1);

            //
            // If IP or DNS is not configured,
            //  tell the caller.
            //
            } else if ( NetStatus == DNS_ERROR_NO_TCPIP ||        // TCP/IP not configured
                        NetStatus == DNS_ERROR_NO_DNS_SERVERS ) { // DNS not configured

                printf( "ERROR: DNS query indicates that IP is not configured on this machine\n" );
                break;

            //
            // We don't handle any other error.
            //
            } else {
                fprintf( stderr, "ERROR: DNS query failure: ");
                PrintStatus( NetStatus );
                return(1);
            }
        }

        //
        // Close
        //

        if ( DsGetDcHandle != NULL ) {
            DsGetDcCloseW( DsGetDcHandle );
        }
    }

    //
    // Get the client digest
    //

    if ( DoClientDigest ) {
        ULONG Rid;
        LPWSTR UnicodeDomainName = NULL;
        CHAR NewMessageDigest[NL_DIGEST_SIZE];
        CHAR OldMessageDigest[NL_DIGEST_SIZE];

        UnicodeDomainName = NetpAllocWStrFromAStr( AnsiDomainName );
        if ( UnicodeDomainName == NULL ) {
            fprintf( stderr, "Not enough memory\n");
            return(1);
        }

        //
        // First get the trust RID
        //
        NetStatus = I_NetlogonGetTrustRid( ServerName,
                                           UnicodeDomainName,
                                           &Rid );

        if ( NetStatus != NO_ERROR ) {
            fprintf( stderr, "I_NetlogonGetTrustRid failed: ");
            PrintStatus( NetStatus );
            return(1);
        }

        //
        // Next calculate the client digest
        //

        NetStatus = I_NetlogonComputeClientDigest(
                              ServerName,
                              UnicodeDomainName,
                              Message,
                              strlen(Message)*sizeof(CHAR),
                              NewMessageDigest,
                              OldMessageDigest );

        if ( NetStatus != NO_ERROR ) {
            fprintf( stderr, "I_NetlogonComputeClientDigest failed: ");
            PrintStatus( NetStatus );
            return(1);
        }

        //
        // Output the RID and the digest
        //

        printf( "Account RID: 0x%lx\n", Rid );

        printf( "New digest: " );
        NlpDumpBuffer(NL_ENCRYPT, NewMessageDigest, sizeof(NewMessageDigest) );

        printf( "Old digest: " );
        NlpDumpBuffer(NL_ENCRYPT, OldMessageDigest, sizeof(OldMessageDigest) );
    }

    //
    // Get the server digest
    //

    if ( DoServerDigest ) {
        CHAR NewMessageDigest[NL_DIGEST_SIZE];
        CHAR OldMessageDigest[NL_DIGEST_SIZE];

        NetStatus = I_NetlogonComputeServerDigest(
                              ServerName,
                              Rid,
                              Message,
                              strlen(Message)*sizeof(CHAR),
                              NewMessageDigest,
                              OldMessageDigest );

        if ( NetStatus != NO_ERROR ) {
            fprintf( stderr, "I_NetlogonComputeServerDigest failed: ");
            PrintStatus( NetStatus );
            return(1);
        }

        //
        // Output the RID and the digest
        //

        printf( "Account RID: 0x%lx\n", Rid );

        printf( "New digest: " );
        NlpDumpBuffer(NL_ENCRYPT, NewMessageDigest, sizeof(NewMessageDigest) );

        printf( "Old digest: " );
        NlpDumpBuffer(NL_ENCRYPT, OldMessageDigest, sizeof(OldMessageDigest) );
    }

    //
    // If we've been asked to convert an NT GMT time to ascii,
    //  Do so
    //

    PrintTime( "", ConvertTime );

#ifndef NTRK_RELEASE
    //
    // If we've been asked to unload netlogon.dll,
    //  stop the service.
    //

    if ( UnloadNetlogonFlag ) {
        StopService( SERVICE_NETLOGON );
    }
#endif // NTRK_RELEASE

    printf("The command completed successfully\n");
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\nltest\setprefdc.c ===
/*--

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setprefdc.c

Abstract:

    Program to set the preferred trusted DC to a particular DC.

Author:

    13-Mar-1997 (Cliff Van Dyke)

--*/

#define UNICODE 1
#include <windows.h>
#include <shellapi.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmuse.h>
#include <stdio.h>

#define OneStatus( _x ) \
    case _x: \
        fprintf( stderr, #_x "\n" ); \
        break;

VOID
PrintError( NET_API_STATUS NetStatus )
{
    switch ( NetStatus ) {
    OneStatus(ERROR_NO_SUCH_DOMAIN);
    OneStatus(ERROR_BAD_NETPATH);
    OneStatus(ERROR_ACCESS_DENIED);
    OneStatus(ERROR_NOT_SUPPORTED);
    OneStatus(ERROR_NO_TRUST_SAM_ACCOUNT);
    OneStatus(ERROR_NO_TRUST_LSA_SECRET);
    OneStatus(ERROR_TRUSTED_DOMAIN_FAILURE);
    OneStatus(ERROR_TRUSTED_RELATIONSHIP_FAILURE);
    OneStatus(ERROR_NETLOGON_NOT_STARTED);
    OneStatus(NO_ERROR);
    default:
        fprintf( stderr, "%ld\n", NetStatus );
        break;
    }
}



_cdecl
main(int argc, char **argv)
{
    NET_API_STATUS NetStatus;
    LPWSTR CommandLine;
    LPWSTR *argvw;
    int argcw;
    LPWSTR ServerName = NULL;   // Make local calls
    LPWSTR TrustedDomainName;
    PNETLOGON_INFO_2 OrigNetlogonInfo2 = NULL;
    PNETLOGON_INFO_2 NewNetlogonInfo2 = NULL;
    USE_INFO_2 UseInfo2;
    int i;

    WCHAR UncDcName[UNCLEN+1];
    WCHAR ShareName[UNCLEN+1+NNLEN+1];
    WCHAR NewDomainAndDc[DNLEN+1+CNLEN+1];
    LPWSTR NewDomainAndDcPtr;
    LPWSTR DcName;
    ULONG DcNameLen;

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW( CommandLine, &argcw );

    if ( argvw == NULL ) {
        fprintf( stderr, "Can't convert command line to Unicode: %ld\n", GetLastError() );
        return 1;
    }

    //
    // Get the arguments
    //
    if ( argcw < 3 ) {
Usage:
        fprintf( stderr, "Usage: %s <TrustedDomain> <ListOfDcsInTrustedDomain>\n", argv[0]);
        return 1;
    }
    TrustedDomainName = argvw[1];
    _wcsupr( TrustedDomainName );

    if ( wcslen(TrustedDomainName) > DNLEN ) {
        fprintf( stderr, "TrustedDomain '%ws' is invalid.\n", TrustedDomainName );
        goto Usage;
    }

    //
    // Query the secure channel to find out the current DC being used.
    //

    NetStatus = I_NetLogonControl2( ServerName,
                                    NETLOGON_CONTROL_TC_QUERY,
                                    2,
                                   (LPBYTE) &TrustedDomainName,
                                   (LPBYTE *)&OrigNetlogonInfo2 );

    if ( NetStatus != NERR_Success ) {
        fprintf( stderr, "Cannot determine current trusted DC of domain '%ws': ", TrustedDomainName );
        PrintError( NetStatus );
        return 1;
    }


    //
    // Loop handling each preferred DC.
    //

    for ( i=2; i<argcw; i++ ) {

        //
        // Grab the DC name specified by the caller.
        //

        DcName = argvw[i];
        _wcsupr( DcName );
        if ( DcName[0] == L'\\' && DcName[1] == L'\\' ) {
            DcName += 2;
        }
        DcNameLen = wcslen(DcName);
        if ( DcNameLen < 1 || DcNameLen > CNLEN ) {
            fprintf( stderr, "DcName '%ws' is invalid.\n", DcName );
            goto Usage;
        }
        wcscpy( UncDcName, L"\\\\" );
        wcscat( UncDcName, DcName );

        //
        // If the named DC is already the current DC,
        //  just tell the caller.
        //

        if ( OrigNetlogonInfo2->netlog2_trusted_dc_name != NULL &&
             _wcsicmp( OrigNetlogonInfo2->netlog2_trusted_dc_name,
                      UncDcName) == 0 ) {
            fprintf( stderr, "DC already is '%ws'.\n", UncDcName );
            return 0;
        }


        //
        // Test if this DC is up.
        //

        wcscpy( ShareName, UncDcName );
        wcscat( ShareName, L"\\IPC$" );

        UseInfo2.ui2_local = NULL;
        UseInfo2.ui2_remote = ShareName;
        UseInfo2.ui2_password = NULL;
        UseInfo2.ui2_asg_type = USE_IPC;
        UseInfo2.ui2_username = NULL;
        UseInfo2.ui2_domainname = NULL;

        NetStatus = NetUseAdd( NULL, 2, (LPBYTE) &UseInfo2, NULL );

        if ( NetStatus == NERR_Success ) {
            NetStatus = NetUseDel( NULL, ShareName, FALSE );

            if ( NetStatus != NERR_Success ) {
                fprintf( stderr, "Cannot remove connection to '%ws' (Continuing): ", UncDcName );
                PrintError( NetStatus );
            }

        } else if ( NetStatus == ERROR_ACCESS_DENIED ) {
            /* Server really is up */
        } else if ( NetStatus == ERROR_SESSION_CREDENTIAL_CONFLICT ) {
            /* We can only assume the server is up */
        } else {
            fprintf( stderr, "Cannot connect to '%ws': ", UncDcName );
            PrintError( NetStatus );
            continue;
        }

        //
        // This DC is up.  Try to use it.
        //

        wcscpy( NewDomainAndDc, TrustedDomainName );
        wcscat( NewDomainAndDc, L"\\" );
        wcscat( NewDomainAndDc, UncDcName+2 );
        NewDomainAndDcPtr = NewDomainAndDc;

        NetStatus = I_NetLogonControl2( ServerName,
                                        NETLOGON_CONTROL_REDISCOVER,
                                        2,
                                       (LPBYTE) &NewDomainAndDcPtr,
                                       (LPBYTE *)&NewNetlogonInfo2 );

        if ( NetStatus != NERR_Success ) {
            fprintf( stderr, "Cannot set new trusted DC to '%ws': ", UncDcName );
            PrintError( NetStatus );
            continue;
        }


        //
        // If the named DC is now the DC,
        //  tell the caller.
        //

        if ( NewNetlogonInfo2->netlog2_trusted_dc_name != NULL &&
             _wcsicmp( NewNetlogonInfo2->netlog2_trusted_dc_name,
                      UncDcName) == 0 ) {
            fprintf( stderr, "Successfully set DC to '%ws'.\n", UncDcName );
            return 0;
        }

        fprintf( stderr,
                 "Cannot set trusted DC to '%ws' it is '%ws': \n",
                 UncDcName,
                 NewNetlogonInfo2->netlog2_trusted_dc_name,
                 NewNetlogonInfo2->netlog2_tc_connection_status );
        PrintError( NetStatus );

    }

    fprintf( stderr, "Failed to set the DC.\n" );

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\nltest\nlsubr\ssiauth_stub.c ===
#include "ssiauth.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\nltest\nlsubr\netpdc_stub.c ===
#include "netpdc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\announce.c ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    announce.c

Abstract:

    Routines to handle ssi announcements.

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.
--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//


//
// Maximum number of pulses that we allow a BDC to ignore before ignoring it.
//
#define MAX_PULSE_TIMEOUT 3

VOID
NlRemovePendingBdc(
    IN PSERVER_SESSION ServerSession
    )
/*++

Routine Description:

    Remove the specified Server Session from the list of pending BDCs.

    Enter with the ServerSessionTable Sem locked

Arguments:

    ServerSession -- Pointer to the server session structure to remove from the
        list.

Return Value:

    None.

--*/
{

    //
    // Ensure the server session is really on the list.
    //

    if ( (ServerSession->SsFlags & SS_PENDING_BDC) == 0 ) {
        return;
    }

    //
    // Decrement the count of pending BDCs
    //

    NlAssert( NlGlobalPendingBdcCount > 0 );
    NlGlobalPendingBdcCount --;

    //
    // If this is the last BDC in the pending list,
    //  turn off the timer.
    //

    if ( NlGlobalPendingBdcCount == 0 ) {
        NlGlobalPendingBdcTimer.Period = (DWORD) MAILSLOT_WAIT_FOREVER;
    }

    //
    // Remove the pending BDC from the list of pending BDCs.
    //

    RemoveEntryList( &ServerSession->SsPendingBdcList );

    //
    // Turn off the flag indicating we're in the list.
    //

    ServerSession->SsFlags &= ~SS_PENDING_BDC;

    NlPrint((NL_PULSE_MORE,
            "NlRemovePendingBdc: %s: Removed from pending list. Count: %ld\n",
            ServerSession->SsComputerName,
            NlGlobalPendingBdcCount ));

}


VOID
NlAddPendingBdc(
    IN PSERVER_SESSION ServerSession
    )
/*++

Routine Description:

    Add the specified Server Session to the list of pending BDCs.

    Enter with the ServerSessionTable Sem locked

Arguments:

    ServerSession -- Pointer to the server session structure to add to the
        list.

Return Value:

    None.

--*/
{

    //
    // Ensure the server session is really off the list.
    //

    if ( ServerSession->SsFlags & SS_PENDING_BDC ) {
        return;
    }

    //
    // If this is the first pending BDC,
    //  start the timer.
    //

    if ( NlGlobalPendingBdcCount == 0 ) {
        // Run the timer at twice the frequency of the timeout to ensure that
        // entries don't have to wait nearly twice the timeout period before
        // they expire.
        NlGlobalPendingBdcTimer.Period = NlGlobalParameters.PulseTimeout1 * 500;
        NlQuerySystemTime( &NlGlobalPendingBdcTimer.StartTime );

        //
        // Tell the main thread that I've changed a timer.
        //

        if ( !SetEvent( NlGlobalTimerEvent ) ) {
            NlPrint(( NL_CRITICAL,
                    "NlAddPendingBdc: %s: SetEvent2 failed %ld\n",
                    ServerSession->SsComputerName,
                    GetLastError() ));
        }

    }

    //
    // Increment the count of pending BDCs
    //

    NlGlobalPendingBdcCount ++;

    //
    // Add the pending BDC to the list of pending BDCs.
    //

    InsertTailList( &NlGlobalPendingBdcList, &ServerSession->SsPendingBdcList );

    //
    // Turn on the flag indicating we're in the list.
    //

    ServerSession->SsFlags |= SS_PENDING_BDC;

    NlPrint((NL_PULSE_MORE,
            "NlAddPendingBdc: %s: Added to pending list. Count: %ld\n",
            ServerSession->SsComputerName,
            NlGlobalPendingBdcCount ));

}


VOID
NetpLogonPutDBInfo(
    IN PDB_CHANGE_INFO  DBInfo,
    IN OUT PCHAR * Where
)
/*++

Routine Description:

    Put Database info structure in mailslot buffer.

Arguments:

    DBInfo  : database info structure pointer.

    Where   : indirect pointer to mailslot buffer. Database info
                is copied over here. When returned this pointer is
                updated to point the end of mailslot buffer.

Return Value:

    None.

--*/

{

    NetpLogonPutBytes( &DBInfo->DBIndex, sizeof(DBInfo->DBIndex), Where);

    NetpLogonPutBytes( &(DBInfo->LargeSerialNumber),
                        sizeof(DBInfo->LargeSerialNumber),
                        Where);

    NetpLogonPutBytes( &(DBInfo->NtDateAndTime),
                        sizeof(DBInfo->NtDateAndTime),
                        Where);
}


VOID
NetpLogonUpdateDBInfo(
    IN PLARGE_INTEGER SerialNumber,
    IN OUT PCHAR * Where
)
/*++

Routine Description:

    Update the Serial Number within the already packed mailslot buffer.

Arguments:

    SerialNumber: New SerialNumber.

    Where   : indirect pointer to mailslot buffer. Database info
                is copied over here. When returned this pointer is
                updated to point the end of mailslot buffer.

Return Value:

    None.

--*/

{

    *Where += sizeof(DWORD);

    NetpLogonPutBytes( SerialNumber, sizeof(LARGE_INTEGER), Where);

    *Where += sizeof(LARGE_INTEGER);
}



BOOLEAN
NlAllocatePrimaryAnnouncement(
    OUT PNETLOGON_DB_CHANGE *UasChangeBuffer,
    OUT LPDWORD UasChangeSize,
    OUT PCHAR *DbChangeInfoPointer
    )
/*++

Routine Description:

    Build and allocate an UAS_CHANGE message which describes the latest
    account database changes.

Arguments:

    UasChangeBuffer - Returns a pointer to the buffer containing the message.
        The caller is responsible for freeing the buffer using NetpMemoryFree.

    UasChangeSize - Returns the size (in bytes) of the allocated buffer.

    DbChangeInfoPointer - Returns the address of the DB Change info
        within the allocated buffer.  The field is not properly aligned.

Return Value:

    TRUE - iff the buffer could be successfully allocated.


--*/
{
    PNETLOGON_DB_CHANGE UasChange;
    DB_CHANGE_INFO DBChangeInfo;
    ULONG DateAndTime1970;

    DWORD NumDBs;
    PCHAR Where;

    DWORD i;
    DWORD DomainSidSize;

    //
    // allocate space for this message.
    //

    DomainSidSize = RtlLengthSid( NlGlobalDomainInfo->DomAccountDomainId );

    UasChange = NetpMemoryAllocate(
                    sizeof(NETLOGON_DB_CHANGE)+
                    (NUM_DBS - 1) * sizeof(DB_CHANGE_INFO) +
                    (DomainSidSize - 1) +
                    sizeof(DWORD) // for DWORD alignment of SID
                    );

    if( UasChange == NULL ) {

        NlPrint((NL_CRITICAL, "NlAllocatePrimaryAnnouncement can't allocate memory\n" ));
        return FALSE;
    }


    //
    // Build the UasChange message using the latest domain modified
    // information from SAM.
    //

    UasChange->Opcode = LOGON_UAS_CHANGE;

    LOCK_CHANGELOG();
    SmbPutUlong( &UasChange->LowSerialNumber,
                    NlGlobalChangeLogDesc.SerialNumber[SAM_DB].LowPart);

    if (!RtlTimeToSecondsSince1970( &NlGlobalDBInfoArray[SAM_DB].CreationTime,
                                    &DateAndTime1970 )) {
        NlPrint((NL_CRITICAL, "DomainCreationTime can't be converted\n" ));
        DateAndTime1970 = 0;
    }
    SmbPutUlong( &UasChange->DateAndTime, DateAndTime1970 );

    // Tell the BDC we only intend to send pulses infrequently
    SmbPutUlong( &UasChange->Pulse, NlGlobalParameters.PulseMaximum);

    // Caller will change this field as appropriate
    SmbPutUlong( &UasChange->Random, 0 );

    Where = UasChange->PrimaryDCName;

    NetpLogonPutOemString( NlGlobalDomainInfo->DomOemComputerName,
                      sizeof(UasChange->PrimaryDCName),
                      &Where );

    NetpLogonPutOemString( NlGlobalDomainInfo->DomOemDomainName,
                       sizeof(UasChange->DomainName),
                       &Where );

    //
    // builtin domain support
    //

    NetpLogonPutUnicodeString( NlGlobalDomainInfo->DomUnicodeComputerNameString.Buffer,
                         sizeof(UasChange->UnicodePrimaryDCName),
                         &Where );

    NetpLogonPutUnicodeString( NlGlobalDomainInfo->DomUnicodeDomainName,
                         sizeof(UasChange->UnicodeDomainName),
                         &Where );

    //
    // number of database info that follow
    //

    NumDBs = NUM_DBS;

    NetpLogonPutBytes( &NumDBs, sizeof(NumDBs), &Where );

    *DbChangeInfoPointer = Where;
    for( i = 0; i < NUM_DBS; i++) {

        DBChangeInfo.DBIndex =
            NlGlobalDBInfoArray[i].DBIndex;
        DBChangeInfo.LargeSerialNumber =
            NlGlobalChangeLogDesc.SerialNumber[i];
        DBChangeInfo.NtDateAndTime =
            NlGlobalDBInfoArray[i].CreationTime;

        NetpLogonPutDBInfo( &DBChangeInfo, &Where );
    }

    //
    // place domain SID in the message.
    //

    NetpLogonPutBytes( &DomainSidSize, sizeof(DomainSidSize), &Where );
    NetpLogonPutDomainSID( NlGlobalDomainInfo->DomAccountDomainId, DomainSidSize, &Where );

    NetpLogonPutNtToken( &Where, 0 );
    UNLOCK_CHANGELOG();


    *UasChangeSize = (DWORD)(Where - (PCHAR)UasChange);
    *UasChangeBuffer = UasChange;
    return TRUE;
}



VOID
NlPrimaryAnnouncementFinish(
    IN PSERVER_SESSION ServerSession,
    IN DWORD DatabaseId,
    IN PLARGE_INTEGER SerialNumber
    )
/*++

Routine Description:

    Indicate that the specified BDC has completed replication of the specified
    database.

    Note: this BDC might not be on the pending list at at if it was doing the
    replication on its own accord.  This routine is designed to handle that
    eventuality.

Arguments:

    ServerSession -- Pointer to the server session structure to remove from the
        list.

    DatabaseID -- Database ID of the database

    SerialNumber -- SerialNumber of the latest delta returned to the BDC.
        NULL indicates a full sync just completed


Return Value:

    None.

--*/
{
    BOOLEAN SendPulse = FALSE;
    //
    // Mark the session that the replication of this particular database
    // has finished.
    //

    LOCK_SERVER_SESSION_TABLE( ServerSession->SsDomainInfo );
    ServerSession->SsFlags &= ~NlGlobalDBInfoArray[DatabaseId].DBSessionFlag;

    //
    // If all of the databases are now replicated, OR
    // the BDC just finished a full sync on one or more of its database,
    //  remove this BDC from the pending list.
    //

    if ( (ServerSession->SsFlags & SS_REPL_MASK) == 0 || SerialNumber == NULL ) {
        NlPrint((NL_PULSE_MORE,
                "NlPrimaryAnnouncementFinish: %s: all databases are now in sync on BDC\n",
                ServerSession->SsComputerName ));
        NlRemovePendingBdc( ServerSession );
        SendPulse = TRUE;
    }

    //
    // If a full sync just completed,
    //  force a partial sync so we can update our serial numbers.
    //

    if ( SerialNumber == NULL ) {

        ServerSession->SsBdcDbSerialNumber[DatabaseId].QuadPart = 0;
        ServerSession->SsFlags |= NlGlobalDBInfoArray[DatabaseId].DBSessionFlag;

    //
    // Save the current serial number for this BDC.
    //

    } else {
        ServerSession->SsBdcDbSerialNumber[DatabaseId] = *SerialNumber;
    }

    NlPrint((NL_PULSE_MORE,
            "NlPrimaryAnnouncementFinish: %s: " FORMAT_LPWSTR " SerialNumber: %lx %lx\n",
            ServerSession->SsComputerName,
            NlGlobalDBInfoArray[DatabaseId].DBName,
            ServerSession->SsBdcDbSerialNumber[DatabaseId].HighPart,
            ServerSession->SsBdcDbSerialNumber[DatabaseId].LowPart ));

    UNLOCK_SERVER_SESSION_TABLE( ServerSession->SsDomainInfo );

    //
    // If this BDC is finished,
    //  try to send a pulse to more BDCs.
    //

    if ( SendPulse ) {
        NlPrimaryAnnouncement( ANNOUNCE_CONTINUE );
    }
}


VOID
NlPrimaryAnnouncementTimeout(
    VOID
    )
/*++

Routine Description:

    The primary announcement timer has expired.

    Handle timing out any BDC's that haven't responded yet.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LARGE_INTEGER TimeNow;
    BOOLEAN SendPulse = FALSE;
    PLIST_ENTRY ListEntry;
    PSERVER_SESSION ServerSession;

    //
    // Get the current time of day
    //

    NlQuerySystemTime( &TimeNow );

    //
    // Handle each BDC that has a pulse pending.
    //

    LOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );

    for ( ListEntry = NlGlobalPendingBdcList.Flink ;
          ListEntry != &NlGlobalPendingBdcList ;
          ListEntry = ListEntry->Flink) {


        ServerSession = CONTAINING_RECORD( ListEntry, SERVER_SESSION, SsPendingBdcList );

        //
        // Ignore entries that haven't timed out yet.
        //

        if ( ServerSession->SsLastPulseTime.QuadPart +
             NlGlobalParameters.PulseTimeout1_100ns.QuadPart >
             TimeNow.QuadPart ) {

            continue;
        }

        //
        // If the pulse has been sent and there has been no response at all,
        // OR there hasn't been another response in a VERY long time
        //  time this entry out.
        //
        if ( (ServerSession->SsFlags & SS_PULSE_SENT) ||
             (ServerSession->SsLastPulseTime.QuadPart +
             NlGlobalParameters.PulseTimeout2_100ns.QuadPart <=
             TimeNow.QuadPart) ) {

            //
            // Increment the count of times this BDC has timed out.
            //
            if ( ServerSession->SsPulseTimeoutCount < MAX_PULSE_TIMEOUT ) {
                ServerSession->SsPulseTimeoutCount++;
            }

            //
            // Remove this entry from the queue.
            //

            NlPrint((NL_PULSE_MORE,
                    "NlPrimaryAnnouncementTimeout: %s: BDC didn't respond to pulse.\n",
                    ServerSession->SsComputerName ));
            NlRemovePendingBdc( ServerSession );

            //
            // Indicate we should send more pulses
            //

            SendPulse = TRUE;

        }

    }

    UNLOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );

    //
    // If any entry has timed out,
    //  try to send a pulse to more BDCs.
    //
    // Do this in the domain thread as this routine is
    //  called from the main thread that should not
    //  be blocked on network I/O.
    //

    if ( SendPulse ) {
        DWORD DomFlags = DOM_PRIMARY_ANNOUNCE_CONTINUE;
        NlStartDomainThread( NlGlobalDomainInfo, &DomFlags );
    }
}



VOID
NlPrimaryAnnouncement(
    IN DWORD AnnounceFlags
    )
/*++

Routine Description:

    Periodic broadcast of messages to domain containing latest
    account database changes.

Arguments:

    AnnounceFlags - Flags requesting special handling of the announcement.

        ANNOUNCE_FORCE  -- set to indicate that the pulse should be forced to
            all BDCs in the domain.

        ANNOUNCE_CONTINUE  -- set to indicate that this call is a
            continuation of a previous call to process all entries.

        ANNOUNCE_IMMEDIATE -- set to indicate that this call is a result
            of a request for immediate replication

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PNETLOGON_DB_CHANGE UasChange;
    DWORD UasChangeSize;
    PCHAR DbChangeInfoPointer;
    LARGE_INTEGER TimeNow;
    DWORD SessionFlags;

    PSERVER_SESSION ServerSession;
    PLIST_ENTRY ListEntry;
    static ULONG EntriesHandled = 0;
    static BOOLEAN ImmediateAnnouncement;


    NlPrint((NL_PULSE_MORE, "NlPrimaryAnnouncement: Entered %ld\n", AnnounceFlags ));

    //
    // If the DS is recovering from a backup,
    //  avoid announcing that we're available.
    //

    if ( NlGlobalDsPaused ) {
        NlPrint((NL_PULSE_MORE, "NlPrimaryAnnouncement: Ds is paused\n" ));
        return;
    }

    //
    // Allocate the UAS_CHANGE message to send.
    //

    if ( !NlAllocatePrimaryAnnouncement( &UasChange,
                                         &UasChangeSize,
                                         &DbChangeInfoPointer ) ) {
        return;
    }


    //
    // If we need to force the pulse to all the BDCs,
    //  mark that we've not done any entries yet, and
    //  mark each entry that a pulse is needed.
    //


    LOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );
    if ( AnnounceFlags & ANNOUNCE_FORCE ) {
        EntriesHandled = 0;

        for ( ListEntry = NlGlobalBdcServerSessionList.Flink ;
              ListEntry != &NlGlobalBdcServerSessionList ;
              ListEntry = ListEntry->Flink) {


            ServerSession = CONTAINING_RECORD( ListEntry, SERVER_SESSION, SsBdcList );

            ServerSession->SsFlags |= SS_FORCE_PULSE;

        }

    }

    //
    // If this isn't a continuation of a previous request to send out pulses,
    //  Reset the count of BDCs that have been handled.
    //

    if ( (AnnounceFlags & ANNOUNCE_CONTINUE) == 0 ) {
        EntriesHandled = 0;

        //
        // Remember whether this was an immediate announcement for the
        //  initial call and all of the continuations.
        //
        ImmediateAnnouncement = (AnnounceFlags & ANNOUNCE_IMMEDIATE) != 0;
    }


    //
    // Loop sending announcements until
    //  we have the maximum number of announcements outstanding, OR
    //  we've processed all the entries in the list.
    //

    while ( NlGlobalPendingBdcCount < NlGlobalParameters.PulseConcurrency &&
            EntriesHandled < NlGlobalBdcServerSessionCount ) {

        BOOLEAN SendPulse;
        LPWSTR TransportName;
        DWORD MaxSessionFlags;

        //
        // If netlogon is exitting,
        //  stop sending announcements
        //

        if ( NlGlobalTerminate ) {
            break;
        }

        //
        // Get the server session entry for the next BDC in the list.
        //
        // The BDC Server Session list is maintained in the order pulses should
        // be sent.  As a pulse is sent (or is skipped), the entry is placed
        // at the tail of the list.  This gives each BDC a chance at a pulse
        // before any BDC is repeated.

        ListEntry = NlGlobalBdcServerSessionList.Flink ;
        ServerSession = CONTAINING_RECORD( ListEntry, SERVER_SESSION, SsBdcList );
        SendPulse = FALSE;
        SessionFlags = 0;

        // Only replicate those databases that negotiation says to replicate
        MaxSessionFlags = NlMaxReplMask(ServerSession->SsNegotiatedFlags);

        if ( ServerSession->SsTransport == NULL ) {
            TransportName = NULL;
        } else {
            TransportName = ServerSession->SsTransport->TransportName;
        }


        //
        // Determine if we should send an announcement to this BDC.
        //
        // Send a pluse unconditionally if a pulse is being forced.
        //

        if ( ServerSession->SsFlags & SS_FORCE_PULSE ) {

            NlPrint((NL_PULSE_MORE,
                    "NlPrimaryAnnouncement: %s: pulse forced to be sent\n",
                    ServerSession->SsComputerName ));
            SendPulse = TRUE;
            ServerSession->SsFlags &= ~SS_FORCE_PULSE;
            SessionFlags = MaxSessionFlags;

            TransportName = NULL; // Send on all transports

        //
        // Only send to any other BDC if there isn't a pulse outstanding and
        // previous announcements haven't been ignored.
        //

        } else if ( (ServerSession->SsFlags & SS_PENDING_BDC) == 0 &&
                     ServerSession->SsPulseTimeoutCount < MAX_PULSE_TIMEOUT ) {

            ULONG i;
            SessionFlags = 0;

            //
            // Only send an announcement if at least one database is out
            //  of sync.
            //

            for( i = 0; i < NUM_DBS; i++) {

                //
                // If this BDC isn't interested in this database,
                //  just skip it.
                //

                if ( (NlGlobalDBInfoArray[i].DBSessionFlag & MaxSessionFlags) == 0 ) {
                    continue;
                }

                //
                // If we need to know the serial number of the BDC,
                //  force the replication.
                //

                if ( ServerSession->SsFlags &
                     NlGlobalDBInfoArray[i].DBSessionFlag ) {

                    NlPrint((NL_PULSE_MORE,
                            "NlPrimaryAnnouncement: %s: " FORMAT_LPWSTR " database serial number needed.  Pulse sent.\n",
                            ServerSession->SsComputerName,
                            NlGlobalDBInfoArray[i].DBName ));
                    SendPulse = TRUE;
                    SessionFlags |= NlGlobalDBInfoArray[i].DBSessionFlag;

                //
                // If the BDC is out of sync with us,
                //  tell it.
                //

                } else if ( NlGlobalChangeLogDesc.SerialNumber[i].QuadPart >
                     ServerSession->SsBdcDbSerialNumber[i].QuadPart ) {
                    NlPrint((NL_PULSE_MORE,
                            "NlPrimaryAnnouncement: %s: " FORMAT_LPWSTR " database is out of sync.  Pulse sent.\n",
                            ServerSession->SsComputerName,
                            NlGlobalDBInfoArray[i].DBName ));
                    SendPulse = TRUE;
                    SessionFlags |= NlGlobalDBInfoArray[i].DBSessionFlag;

                }
            }

            //
            // Fix a timing window on NT 3.1 BDCs.
            //
            // During promotion of a BDC to PDC, the following events occur:
            //  Two server accounts are changed on the old PDC and
            //      are marked for immediate replication.
            //  The Server manager asks the new PDC to partial sync.
            //
            // If the first immediate replication starts immediately, and the
            // second immediate replication pulse is ignored because replication
            // is in progress, and the first replication has finished the SAM
            // database and is working on the LSA database when the server
            // manager partial sync request comes in, then that request will be
            // ignored (rightfully) since replication is still in progress.
            // However, an NT 3.1 BDC replicator thread will not go back to
            // do the SAM database once it finishes with the LSA database. So
            // the replicator thread terminates with the SAM database still
            // needing replication.  The server manager (rightfully) interprets
            // this as an error.
            //
            // Our solution is to set the backoff period on such "immediate"
            // replication attempts to the same value an NT 3.1 PDC would use.
            // This typically prevents the initial replication from starting in
            // the first place.
            //
            // Only do it for NT 3.1 BDCs since we're risking being overloaded.
            //

            if ( ImmediateAnnouncement &&
                 SendPulse &&
                 (ServerSession->SsFlags & SS_AUTHENTICATED) &&
                 (ServerSession->SsNegotiatedFlags & NETLOGON_SUPPORTS_PERSISTENT_BDC) == 0 ) {
                SessionFlags = 0;
            }
        }

        //
        // Send a pulse unconditionally if it has been PulseMaximum since the
        // latest pulse.
        //
        // Avoid this if the BDC is an NT 5 BDC that doesn't use Netlogon to replicate
        // from us.
        //

        if ( !SendPulse &&
             MaxSessionFlags != 0 &&
             NlTimeHasElapsedEx( &ServerSession->SsLastPulseTime,
                                 &NlGlobalParameters.PulseMaximum_100ns,
                                 NULL ) ) {

            NlPrint((NL_PULSE_MORE,
                    "NlPrimaryAnnouncement: %s: Maximum pulse since previous pulse. Pulse sent.\n",
                    ServerSession->SsComputerName ));
            SendPulse = TRUE;
            SessionFlags = 0;
            TransportName = NULL; // Send on all transports
        }

        //
        // Put this entry at the tail of the list regardless of whether
        //  we'll actually send an announcement to it.
        //

        RemoveEntryList( ListEntry );
        InsertTailList( &NlGlobalBdcServerSessionList, ListEntry );
        EntriesHandled ++;

        //
        // Send the announcement.
        //

        if ( SendPulse ) {
            WCHAR LocalComputerName[CNLEN+1];
            PCHAR Where;
            ULONG i;

            //
            // Add this BDC to the list of BDCs that have a pulse pending.
            //
            // Don't add this BDC to the list if we don't expect a response.
            // We don't expect a response from an LM BDC.  We don't expect
            // a response from a BDC that is merely getting its PulseMaximum
            // pulse.
            //
            // If we don't expect a response, set the backoff period to a
            // large value to prevent a large load on the PDC in the case
            // that the BDC does actually respond.
            //
            // If we expect a response, set the backoff period to almost
            // immediately since we're waiting for them.
            //

            if ( SessionFlags == 0 ) {
                SmbPutUlong( &UasChange->Random,
                             max(NlGlobalParameters.Randomize,
                                 NlGlobalParameters.Pulse/10) );
            } else {
                NlAddPendingBdc( ServerSession );
                SmbPutUlong( &UasChange->Random, NlGlobalParameters.Randomize );
            }

            //
            // Indicate that the pulse has been sent.
            //  This flag is set from the time we send the pulse until the
            //  first time the BDC responds. We use this to detect failed
            //  BDCs that have a secure channel up.
            //

            ServerSession->SsFlags &= ~SS_REPL_MASK;
            ServerSession->SsFlags |= SS_PULSE_SENT | SessionFlags;
            NlQuerySystemTime( &TimeNow );
            ServerSession->SsLastPulseTime = TimeNow;

            //
            // Don't keep the server session locked since sending the mailslot
            // message takes a long time.
            //

            NetpCopyStrToWStr( LocalComputerName,
                               ServerSession->SsComputerName );

            UNLOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );

            //
            // Update the message to be specific to this BDC.
            //
            // If we need the BDC to respond,
            //  set the serial number to make the BDC think it has a lot
            //  of deltas to pick up.
            //

            LOCK_CHANGELOG();
            Where = DbChangeInfoPointer;
            for( i = 0; i < NUM_DBS; i++) {
                LARGE_INTEGER SerialNumber;

                SerialNumber = NlGlobalChangeLogDesc.SerialNumber[i];

                if ( NlGlobalDBInfoArray[i].DBSessionFlag & SessionFlags ) {
                    //
                    // Don't change the high part since
                    //  a) NT 3.1 BDCs will do a full sync if there are too
                    //     many changes.
                    //  b) The high part contains the PDC promotion count.
                    //
                    SerialNumber.LowPart = 0xFFFFFFFF;
                }

                NetpLogonUpdateDBInfo( &SerialNumber, &Where );
            }
            UNLOCK_CHANGELOG();



            //
            // Send the datagram to this BDC.
            //  Failure isn't fatal
            //

#if NETLOGONDBG
            NlPrintDom((NL_MAILSLOT, NlGlobalDomainInfo,
                     "Sent '%s' message to %ws[%s] on %ws.\n",
                     NlMailslotOpcode(UasChange->Opcode),
                     LocalComputerName,
                     NlDgrNameType(ComputerName),
                     TransportName ));
#endif // NETLOGONDBG

            Status = NlBrowserSendDatagram(
                        NlGlobalDomainInfo,
                        0,
                        LocalComputerName,
                        ComputerName,
                        TransportName,
                        NETLOGON_LM_MAILSLOT_A,
                        UasChange,
                        UasChangeSize,
                        TRUE,  // send synchronously
                        NULL );  // Don't flush Netbios cache

            if ( !NT_SUCCESS(Status) ) {
                NlPrint((NL_CRITICAL,
                        "Cannot send datagram to '%ws' 0x%lx\n",
                        LocalComputerName,
                        Status ));
            }

            LOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );

        } else {
            NlPrint((NL_PULSE_MORE,
                    "NlPrimaryAnnouncement: %s: pulse not needed at this time.\n",
                    ServerSession->SsComputerName ));
        }

    }

    //
    // If the flags are zero, we are called from
    //  the domain thread started by the main loop.
    //  Tell the main loop we are done doing the work.
    //

    if ( AnnounceFlags == 0 ) {
        NlGlobalPrimaryAnnouncementIsRunning = FALSE;
    }

    UNLOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );


    //
    // Free up message memory.
    //

    NetpMemoryFree( UasChange );

    NlPrint((NL_PULSE_MORE, "NlPrimaryAnnouncement: Return\n" ));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\changelg.c ===
/*++

Copyright (c) 1987-1997 Microsoft Corporation

Module Name:

    changelg.c

Abstract:

    Change Log implementation.

    This file implements the change log.  It is isolated in this file
    because it has several restrictions.

    * The globals maintained by this module are initialized during
      netlogon.dll process attach. They are cleaned up netlogon.dll
      process detach.

    * These procedures are used by SAM, LSA, and the netlogon service.
      The LSA should be the first to load netlogon.dll.  It should
      then immediately call I_NetNotifyRole before allowing SAM or the
      netlogon service to start.

    * These procedures cannot use any globals initialized by the netlogon
      service.

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    22-Jul-1991 (cliffv)
        Ported to NT.  Converted to NT style.

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.

    04-Apr-1992 (madana)
        Added support for LSA replication.

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//
#include <configp.h>    // USE_WIN32_CONFIG (if defined), etc.


//
// Globals defining change log worker thread.
//
HANDLE NlGlobalChangeLogWorkerThreadHandle;
BOOL NlGlobalChangeLogWorkerIsRunning;
BOOL NlGlobalChangeLogNotifyBrowser;
BOOL NlGlobalChangeLogNotifyBrowserIsRunning;

BOOL
IsChangeLogWorkerRunning(
    VOID
    );


VOID
NlChangeLogWorker(
    IN LPVOID ChangeLogWorkerParam
    )
/*++

Routine Description:

    This thread performs any long term operations that:

    A) must happen even though netlogon isn't up, and
    B) cannot happen in the context of an LSA or SAM notification.

Arguments:

    None.

Return Value:


--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    LPWSTR NewDomainName;

    NlPrint((NL_CHANGELOG, "ChangeLogWorker Thread is starting \n"));


    //
    // Loop until there is no more work to do.
    //

    LOCK_CHANGELOG();
    for (;;) {

        //
        // Handle the domain being renamed.
        //
        if ( NlGlobalChangeLogNotifyBrowser ) {
            NlGlobalChangeLogNotifyBrowser = FALSE;
            NlGlobalChangeLogNotifyBrowserIsRunning = TRUE;
            UNLOCK_CHANGELOG();

            NetStatus = NetpGetDomainName( &NewDomainName );

            if ( NetStatus == NO_ERROR ) {

                //
                // Tell the bowser about the new domain name
                //

                Status = NlBrowserRenameDomain( NULL, NewDomainName );

                if ( !NT_SUCCESS(Status) ) {
                    NlPrint(( NL_CRITICAL,
                              "ChangeLogWorker: Browser won't rename domain: %lx\n",
                              Status ));
                }

                //
                // Free the domain name.
                //
                NetApiBufferFree( NewDomainName );
            } else {
                NlPrint(( NL_CRITICAL,
                          "ChangeLogWorker cannot get new domain name: %ld\n",
                          NetStatus ));
            }

            LOCK_CHANGELOG();
            NlGlobalChangeLogNotifyBrowserIsRunning = FALSE;

        //
        // If there is nothing more to do,
        //  exit the thread.
        //
        } else {
            NlPrint((NL_CHANGELOG, "ChangeLogWorker Thread is exiting \n"));
            NlGlobalChangeLogWorkerIsRunning = FALSE;
            break;
        }
    }
    UNLOCK_CHANGELOG();

    return;
    UNREFERENCED_PARAMETER( ChangeLogWorkerParam );
}



BOOL
NlStartChangeLogWorkerThread(
    VOID
    )
/*++

Routine Description:

    Start the Change Log Worker thread if it is not already running.

    Enter with NlGlobalChangeLogCritSect locked.

Arguments:

    None.

Return Value:
    None.

--*/
{
    DWORD ThreadHandle;

    //
    // If the worker thread is already running, do nothing.
    //

    if ( IsChangeLogWorkerRunning() ) {
        return FALSE;
    }

    NlGlobalChangeLogWorkerThreadHandle = CreateThread(
                                 NULL, // No security attributes
                                 0,
                                 (LPTHREAD_START_ROUTINE)
                                    NlChangeLogWorker,
                                 NULL,
                                 0, // No special creation flags
                                 &ThreadHandle );

    if ( NlGlobalChangeLogWorkerThreadHandle == NULL ) {

        //
        // ?? Shouldn't we do something in non-debug case
        //

        NlPrint((NL_CRITICAL, "Can't create change log worker thread %lu\n",
                 GetLastError() ));

        return FALSE;
    }

    NlGlobalChangeLogWorkerIsRunning = TRUE;

    return TRUE;

}


VOID
NlStopChangeLogWorker(
    VOID
    )
/*++

Routine Description:

    Stops the worker thread if it is running and waits for it to stop.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    //
    // Determine if the worker thread is already running.
    //

    if ( NlGlobalChangeLogWorkerThreadHandle != NULL ) {

        //
        // We've asked the worker to stop.  It should do so soon.
        //    Wait for it to stop.
        //

        NlWaitForSingleObject( "Wait for worker to stop",
                               NlGlobalChangeLogWorkerThreadHandle );


        CloseHandle( NlGlobalChangeLogWorkerThreadHandle );
        NlGlobalChangeLogWorkerThreadHandle = NULL;

    }

    return;
}


BOOL
IsChangeLogWorkerRunning(
    VOID
    )
/*++

Routine Description:

    Test if the change log worker thread is running

    Enter with NlGlobalChangeLogCritSect locked.

Arguments:

    NONE

Return Value:

    TRUE - if the worker thread is running.

    FALSE - if the worker thread is not running.

--*/
{
    DWORD WaitStatus;

    //
    // Determine if the worker thread is already running.
    //

    if ( NlGlobalChangeLogWorkerThreadHandle != NULL ) {

        //
        // Time out immediately if the worker is still running.
        //

        WaitStatus = WaitForSingleObject(
                        NlGlobalChangeLogWorkerThreadHandle, 0 );

        if ( WaitStatus == WAIT_TIMEOUT ) {

            //
            // Handle the case that the thread has finished
            //  processing, but is in the process of exitting.
            //

            if ( !NlGlobalChangeLogWorkerIsRunning ) {
                NlStopChangeLogWorker();
                return FALSE;
            }
            return TRUE;

        } else if ( WaitStatus == 0 ) {
            CloseHandle( NlGlobalChangeLogWorkerThreadHandle );
            NlGlobalChangeLogWorkerThreadHandle = NULL;
            return FALSE;

        } else {
            NlPrint((NL_CRITICAL,
                    "Cannot WaitFor Change Log Worker thread: %ld\n",
                    WaitStatus ));
            return TRUE;
        }

    }

    return FALSE;
}


VOID
NlWaitForChangeLogBrowserNotify(
    VOID
    )
/*++

Routine Description:

    Wait for up 20 seconds for the change log worker thread to finish
    the browser notification on the domain join.

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG WaitCount = 0;

    //
    // Wait for 20 seconds max. This is a rare operation,
    //  so just polling periodically is not too bad here.
    //

    LOCK_CHANGELOG();
    while ( WaitCount < 40 &&
            (NlGlobalChangeLogNotifyBrowser || NlGlobalChangeLogNotifyBrowserIsRunning) ) {

        if ( WaitCount == 0 ) {
            NlPrint(( NL_MISC,
                      "NlWaitForChangeLogBrowserNotify: Waiting for change log worker to exit\n" ));
        }

        //
        // Sleep half a second
        //

        UNLOCK_CHANGELOG();
        Sleep( 500 );
        LOCK_CHANGELOG();
        WaitCount ++;
    }
    UNLOCK_CHANGELOG();

    if ( WaitCount == 40 ) {
        NlPrint(( NL_CRITICAL,
                  "NlWaitForChangeLogBrowserNotify: Couldn't wait for change log worker exit\n" ));
    }
}


NTSTATUS
NlSendChangeLogNotification(
    IN enum CHANGELOG_NOTIFICATION_TYPE EntryType,
    IN PUNICODE_STRING ObjectName,
    IN PSID ObjectSid,
    IN ULONG ObjectRid,
    IN GUID *ObjectGuid,
    IN GUID *DomainGuid,
    IN PUNICODE_STRING DomainName
    )
/*++

Routine Description:

    Put a ChangeLog Notification entry for netlogon to pick up.

Arguments:

    EntryType - The type of the entry being inserted

    ObjectName - The name of the account being changed.

    ObjectSid - Sid of the account be changed.

    ObjectRid - Rid of the object being changed.

    ObjectGuid - Guid of the object being changed.

    DomainGuid - Guid of the domain the object is in

    DomainName - Name of the domain the object is in

Return Value:

    Status of the operation.

--*/
{
    PCHANGELOG_NOTIFICATION Notification;
    LPBYTE Where;
    ULONG SidSize = 0;
    ULONG NameSize = 0;
    ULONG DomainNameSize = 0;
    ULONG Size;

    //
    // If the netlogon service isn't running (or at least starting),
    //   don't queue messages to it.
    //

    if( NlGlobalChangeLogNetlogonState == NetlogonStopped ) {
        return STATUS_SUCCESS;
    }

    //
    // Allocate a buffer for the object name.
    //

    if ( ObjectSid != NULL ) {
        SidSize = RtlLengthSid( ObjectSid );
    }

    if ( ObjectName != NULL ) {
        NameSize = ObjectName->Length + sizeof(WCHAR);
    }

    if ( DomainName != NULL ) {
        DomainNameSize = DomainName->Length + sizeof(WCHAR);
    }

    Size = sizeof(*Notification) + SidSize + NameSize + DomainNameSize;
    Size = ROUND_UP_COUNT( Size, ALIGN_WORST );

    Notification = NetpMemoryAllocate( Size );

    if ( Notification == NULL ) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory( Notification, Size );

    Notification->EntryType = EntryType;
    Notification->ObjectRid = ObjectRid;

    Where = (LPBYTE) (Notification + 1);

    //
    // Copy the object sid into the buffer.
    //

    if ( ObjectSid != NULL ) {
        RtlCopyMemory( Where, ObjectSid, SidSize );
        Notification->ObjectSid = (PSID) Where;
        Where += SidSize;
    } else {
        Notification->ObjectSid = NULL;
    }


    //
    // Copy the object name into the buffer.
    //

    if ( ObjectName != NULL ) {
        Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );
        RtlCopyMemory( Where, ObjectName->Buffer, ObjectName->Length );
        ((LPWSTR)Where)[ObjectName->Length/sizeof(WCHAR)] = L'\0';

        RtlInitUnicodeString( &Notification->ObjectName, (LPWSTR)Where);
        Where += NameSize;
    } else {
        RtlInitUnicodeString( &Notification->ObjectName, NULL);
    }


    //
    // Copy the domain name into the buffer.
    //

    if ( DomainName != NULL ) {
        Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );
        RtlCopyMemory( Where, DomainName->Buffer, DomainName->Length );
        ((LPWSTR)Where)[DomainName->Length/sizeof(WCHAR)] = L'\0';

        RtlInitUnicodeString( &Notification->DomainName, (LPWSTR)Where);
        Where += DomainNameSize;
    } else {
        RtlInitUnicodeString( &Notification->DomainName, NULL);
    }

    //
    // Copy the GUIDs into the buffer
    //

    if ( ObjectGuid != NULL) {
        Notification->ObjectGuid = *ObjectGuid;
    }

    if ( DomainGuid != NULL) {
        Notification->DomainGuid = *DomainGuid;
    }

    //
    // Indicate we're about to send the event.
    //

#if NETLOGONDBG
    EnterCriticalSection( &NlGlobalLogFileCritSect );
    NlPrint((NL_CHANGELOG,
            "NlSendChangeLogNotification: sent %ld for",
             Notification->EntryType ));
    if ( ObjectName != NULL ) {
        NlPrint((NL_CHANGELOG,
                " %wZ",
                 ObjectName));
    }
    if ( DomainName != NULL ) {
        NlPrint((NL_CHANGELOG,
                " Dom:%wZ",
                 DomainName));
    }
    if ( ObjectRid != 0 ) {
        NlPrint((NL_CHANGELOG,
                " Rid:0x%lx",
                 ObjectRid ));
    }
    if ( ObjectSid != NULL ) {
        NlPrint((NL_CHANGELOG, " Sid:" ));
        NlpDumpSid( NL_CHANGELOG, ObjectSid );
    }
    if ( ObjectGuid != NULL ) {
        NlPrint((NL_CHANGELOG, " Obj Guid:" ));
        NlpDumpGuid( NL_CHANGELOG, ObjectGuid );
    }
    if ( DomainGuid != NULL ) {
        NlPrint((NL_CHANGELOG, " Dom Guid:" ));
        NlpDumpGuid( NL_CHANGELOG, DomainGuid );
    }
    NlPrint((NL_CHANGELOG, "\n" ));
    LeaveCriticalSection( &NlGlobalLogFileCritSect );
#endif // NETLOGONDBG



    //
    // Insert the entry into the list
    //

    LOCK_CHANGELOG();
    InsertTailList( &NlGlobalChangeLogNotifications, &Notification->Next );
    UNLOCK_CHANGELOG();

    if ( !SetEvent( NlGlobalChangeLogEvent ) ) {
        NlPrint((NL_CRITICAL,
                "Cannot set ChangeLog event: %lu\n",
                GetLastError() ));
    }

    return STATUS_SUCCESS;
}



NTSTATUS
I_NetNotifyDelta (
    IN SECURITY_DB_TYPE DbType,
    IN LARGE_INTEGER SerialNumber,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA MemberId
    )
/*++

Routine Description:

    This function is called by the SAM and LSA services after each
    change is made to the SAM and LSA databases.  The services describe
    the type of object that is modified, the type of modification made
    on the object, the serial number of this modification etc.  This
    information is stored for later retrieval when a BDC or member
    server wants a copy of this change.  See the description of
    I_NetSamDeltas for a description of how the change log is used.

    Add a change log entry to circular change log maintained in cache as
    well as on the disk and update the head and tail pointers

    It is assumed that Tail points to a block where this new change log
    entry may be stored.

Arguments:

    DbType - Type of the database that has been modified.

    SerialNumber - The value of the DomainModifiedCount field for the
        domain following the modification.

    DeltaType - The type of modification that has been made on the object.

    ObjectType - The type of object that has been modified.

    ObjectRid - The relative ID of the object that has been modified.
        This parameter is valid only when the object type specified is
        either SecurityDbObjectSamUser, SecurityDbObjectSamGroup or
        SecurityDbObjectSamAlias otherwise this parameter is set to zero.

    ObjectSid - The SID of the object that has been modified.  If the object
        modified is in a SAM database, ObjectSid is the DomainId of the Domain
        containing the object.

    ObjectName - The name of the secret object when the object type
        specified is SecurityDbObjectLsaSecret or the old name of the object
        when the object type specified is either SecurityDbObjectSamUser,
        SecurityDbObjectSamGroup or SecurityDbObjectSamAlias and the delta
        type is SecurityDbRename otherwise this parameter is set to NULL.

    ReplicateImmediately - TRUE if the change should be immediately
        replicated to all BDCs.  A password change should set the flag
        TRUE.

    MemberId - This parameter is specified when group/alias membership
        is modified. This structure will then point to the member's ID that
        has been updated.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{
    NTSTATUS Status;
    CHANGELOG_ENTRY ChangeLogEntry;
    NETLOGON_DELTA_TYPE NetlogonDeltaType;
    USHORT Flags = 0;

    //
    // Ensure the role is right.  Otherwise, all the globals used below
    //  aren't initialized.
    //

    if ( NlGlobalChangeLogRole != ChangeLogPrimary &&
         NlGlobalChangeLogRole != ChangeLogBackup ) {
        return STATUS_INVALID_DOMAIN_ROLE;
    }

    //
    // Also make sure that the change log cache is available.
    //

    if ( NlGlobalChangeLogDesc.Buffer == NULL ) {
        return STATUS_INVALID_DOMAIN_ROLE;
    }


    //
    // Determine the database index.
    //

    if( DbType == SecurityDbLsa ) {

        ChangeLogEntry.DBIndex = LSA_DB;

    } else if( DbType == SecurityDbSam ) {

        if ( RtlEqualSid( ObjectSid, NlGlobalChangeLogBuiltinDomainSid )) {

            ChangeLogEntry.DBIndex = BUILTIN_DB;

        } else {

            ChangeLogEntry.DBIndex = SAM_DB;

        }

        //
        // For the SAM database, we no longer need the ObjectSid.
        // Null out the pointer to prevent us from storing it in the
        // changelog.
        //

        ObjectSid = NULL;

    } else {

        //
        // unknown database, do nothing.
        //

        NlPrint((NL_CRITICAL,
                 "I_NetNotifyDelta: Unknown database: %ld\n",
                 DbType ));
        return STATUS_SUCCESS;
    }



    //
    // Map object type and delta type to NetlogonDeltaType
    //

    switch( ObjectType ) {
    case SecurityDbObjectLsaPolicy:

        switch (DeltaType) {
        case SecurityDbNew:
        case SecurityDbChange:
            NetlogonDeltaType = AddOrChangeLsaPolicy;
            break;

        // unknown delta type
        default:
            NlPrint((NL_CRITICAL,
                     "I_NetNotifyDelta: Unknown deltatype for policy: %ld\n",
                     DeltaType ));
            return STATUS_SUCCESS;
        }
        break;


    case SecurityDbObjectLsaTDomain:

        switch (DeltaType) {
        case SecurityDbNew:
        case SecurityDbChange:
            NetlogonDeltaType = AddOrChangeLsaTDomain;
            break;

        case SecurityDbDelete:
            NetlogonDeltaType = DeleteLsaTDomain;
            break;

        // unknown delta type
        default:
            NlPrint((NL_CRITICAL,
                     "I_NetNotifyDelta: Unknown deltatype for tdomain: %ld\n",
                     DeltaType ));
            return STATUS_SUCCESS;
        }
        break;


    case SecurityDbObjectLsaAccount:

        switch (DeltaType) {
        case SecurityDbNew:
        case SecurityDbChange:
            NetlogonDeltaType = AddOrChangeLsaAccount;
            break;

        case SecurityDbDelete:
            NetlogonDeltaType = DeleteLsaAccount;
            break;

        // unknown delta type
        default:
            NlPrint((NL_CRITICAL,
                     "I_NetNotifyDelta: Unknown deltatype for lsa account: %ld\n",
                     DeltaType ));
            return STATUS_SUCCESS;
        }
        break;


    case SecurityDbObjectLsaSecret:

        switch (DeltaType) {
        case SecurityDbNew:
        case SecurityDbChange:
            NetlogonDeltaType = AddOrChangeLsaSecret;
            break;

        case SecurityDbDelete:
            NetlogonDeltaType = DeleteLsaSecret;
            break;

        // unknown delta type
        default:
            NlPrint((NL_CRITICAL,
                     "I_NetNotifyDelta: Unknown deltatype for lsa secret: %ld\n",
                     DeltaType ));
            return STATUS_SUCCESS;
        }
        break;


    case SecurityDbObjectSamDomain:

        switch (DeltaType) {
        case SecurityDbNew:
        case SecurityDbChange:
            NetlogonDeltaType = AddOrChangeDomain;
            break;

        // unknown delta type
        default:
            NlPrint((NL_CRITICAL,
                     "I_NetNotifyDelta: Unknown deltatype for sam domain: %ld\n",
                     DeltaType ));
            return STATUS_SUCCESS;
        }
        break;

    case SecurityDbObjectSamUser:

        switch (DeltaType) {
        case SecurityDbChangePassword:
        case SecurityDbNew:
        case SecurityDbChange:
        case SecurityDbRename:
            NetlogonDeltaType = AddOrChangeUser;
            break;

        case SecurityDbDelete:
            NetlogonDeltaType = DeleteUser;
            break;

        //
        // unknown delta type
        //

        default:
            NlPrint((NL_CRITICAL,
                     "I_NetNotifyDelta: Unknown deltatype for sam user: %ld\n",
                     DeltaType ));
            return STATUS_SUCCESS;
        }

        break;

    case SecurityDbObjectSamGroup:

        switch ( DeltaType ) {
        case SecurityDbNew:
        case SecurityDbChange:
        case SecurityDbRename:
        case SecurityDbChangeMemberAdd:
        case SecurityDbChangeMemberSet:
        case SecurityDbChangeMemberDel:
            NetlogonDeltaType = AddOrChangeGroup;
            break;

        case SecurityDbDelete:
            NetlogonDeltaType = DeleteGroup;
            break;

        //
        // unknown delta type
        //
        default:
            NlPrint((NL_CRITICAL,
                     "I_NetNotifyDelta: Unknown deltatype for sam group: %ld\n",
                     DeltaType ));
            return STATUS_SUCCESS;
        }
        break;

    case SecurityDbObjectSamAlias:

        switch (DeltaType) {
        case SecurityDbNew:
        case SecurityDbChange:
        case SecurityDbRename:
        case SecurityDbChangeMemberAdd:
        case SecurityDbChangeMemberSet:
        case SecurityDbChangeMemberDel:
            NetlogonDeltaType = AddOrChangeAlias;
            break;

        case SecurityDbDelete:
            NetlogonDeltaType = DeleteAlias;
            break;

        // unknown delta type
        default:
            NlPrint((NL_CRITICAL,
                     "I_NetNotifyDelta: Unknown deltatype for sam alias: %ld\n",
                     DeltaType ));
            return STATUS_SUCCESS;
        }
        break;

    default:

        // unknown object type
        NlPrint((NL_CRITICAL,
                 "I_NetNotifyDelta: Unknown object type: %ld\n",
                 ObjectType ));
        return STATUS_SUCCESS;

    }


    //
    // Build the changelog entry and write it to the changelog
    //

    ChangeLogEntry.DeltaType = (UCHAR)NetlogonDeltaType;
    ChangeLogEntry.SerialNumber = SerialNumber;
    ChangeLogEntry.ObjectRid = ObjectRid;
    ChangeLogEntry.Flags = Flags;

    Status = NlWriteChangeLogEntry( &NlGlobalChangeLogDesc,
                                    &ChangeLogEntry,
                                    ObjectSid,
                                    ObjectName,
                                    TRUE );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    //
    // If this change requires immediate replication, do so
    //

    if( ReplicateImmediately ) {

        LOCK_CHANGELOG();
        NlGlobalChangeLogReplicateImmediately = TRUE;
        UNLOCK_CHANGELOG();

        if ( !SetEvent( NlGlobalChangeLogEvent ) ) {
            NlPrint((NL_CRITICAL,
                    "Cannot set ChangeLog event: %lu\n",
                    GetLastError() ));
        }

    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( MemberId );
}


NTSTATUS
I_NetLogonGetSerialNumber (
    IN SECURITY_DB_TYPE DbType,
    IN PSID DomainSid,
    OUT PLARGE_INTEGER SerialNumber
    )
/*++

Routine Description:

    This function is called by the SAM and LSA services when they startup
    to get the current serial number written to the changelog.

Arguments:

    DbType - Type of the database that has been modified.

    DomainSid - For the SAM and builtin database, this specifies the DomainId of
        the domain whose serial number is to be returned.

    SerialNumber - Returns the latest set value of the DomainModifiedCount
        field for the domain.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_INVALID_DOMAIN_ROLE - This machine is not the PDC.

--*/
{
    NTSTATUS Status;
    CHANGELOG_ENTRY ChangeLogEntry;
    NETLOGON_DELTA_TYPE NetlogonDeltaType;
    USHORT Flags = 0;
    ULONG DbIndex;

    //
    // Ensure the role is right.  Otherwise, all the globals used below
    //  aren't initialized.
    //

    if ( NlGlobalChangeLogRole != ChangeLogPrimary &&
         NlGlobalChangeLogRole != ChangeLogBackup ) {
        NlPrint((NL_CHANGELOG,
                "I_NetLogonGetSerialNumber: failed 1\n" ));
        return STATUS_INVALID_DOMAIN_ROLE;
    }

    //
    // Also make sure that the change log cache is available.
    //

    if ( NlGlobalChangeLogDesc.Buffer == NULL ) {
        NlPrint((NL_CHANGELOG,
                "I_NetLogonGetSerialNumber: failed 2\n" ));
        return STATUS_INVALID_DOMAIN_ROLE;
    }


    //
    // Determine the database index.
    //

    if( DbType == SecurityDbLsa ) {

        DbIndex = LSA_DB;

    } else if( DbType == SecurityDbSam ) {

        if ( RtlEqualSid( DomainSid, NlGlobalChangeLogBuiltinDomainSid )) {

            DbIndex = BUILTIN_DB;

        } else {

            DbIndex = SAM_DB;

        }

    } else {

        NlPrint((NL_CHANGELOG,
                "I_NetLogonGetSerialNumber: failed 3\n" ));
        return STATUS_INVALID_DOMAIN_ROLE;
    }

    //
    // Return the current serial number.
    //

    SerialNumber->QuadPart = NlGlobalChangeLogDesc.SerialNumber[DbIndex].QuadPart;
    NlPrint((NL_CHANGELOG,
            "I_NetLogonGetSerialNumber: returns 0x%lx 0x%lx\n",
            SerialNumber->HighPart,
            SerialNumber->LowPart ));

    return STATUS_SUCCESS;
}




NTSTATUS
NlInitChangeLogBuffer(
    VOID
)
/*++

Routine Description:

    Open the change log file (netlogon.chg) for reading or writing one or
    more records.  Create this file if it does not exist or is out of
    sync with the SAM database (see note below).

    This file must be opened for R/W (deny-none share mode) at the time
    the cache is initialized.  If the file already exists when NETLOGON
    service started, its contents will be cached in its entirety
    provided the last change log record bears the same serial number as
    the serial number field in SAM database else this file will be
    removed and a new one created.  If the change log file did not exist
    then it will be created.

Arguments:

    NONE

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    UINT WindowsDirectoryLength;
    WCHAR ChangeLogFile[MAX_PATH+1];

    LPNET_CONFIG_HANDLE SectionHandle = NULL;
    DWORD NewChangeLogSize;

    //
    // Initialize
    //

    LOCK_CHANGELOG();


    //
    // Get the size of the changelog.


    //
    // Open the NetLogon configuration section.
    //

    NewChangeLogSize = DEFAULT_CHANGELOGSIZE;
    NetStatus = NetpOpenConfigData(
            &SectionHandle,
            NULL,                       // no server name.
            SERVICE_NETLOGON,
            TRUE );                     // we only want readonly access

    if ( NetStatus == NO_ERROR ) {

        (VOID) NlParseOne( SectionHandle,
                           FALSE,   // not a GP section
                           NETLOGON_KEYWORD_CHANGELOGSIZE,
                           DEFAULT_CHANGELOGSIZE,
                           MIN_CHANGELOGSIZE,
                           MAX_CHANGELOGSIZE,
                           &NewChangeLogSize );

         (VOID) NetpCloseConfigData( SectionHandle );
    }

    NewChangeLogSize = ROUND_UP_COUNT( NewChangeLogSize, ALIGN_WORST);

#ifdef notdef
    NlPrint((NL_INIT, "ChangeLogSize: 0x%lx\n", NewChangeLogSize ));
#endif // notdef


    //
    // Build the change log file name
    //

    WindowsDirectoryLength = GetSystemWindowsDirectoryW(
                                NlGlobalChangeLogFilePrefix,
                                sizeof(NlGlobalChangeLogFilePrefix)/sizeof(WCHAR) );

    if ( WindowsDirectoryLength == 0 ) {

        NlPrint((NL_CRITICAL,"Unable to get changelog file directory name, "
                    "WinError = %ld \n", GetLastError() ));

        NlGlobalChangeLogFilePrefix[0] = L'\0';
        goto CleanChangeLogFile;
    }

    if ( WindowsDirectoryLength * sizeof(WCHAR) + sizeof(CHANGELOG_FILE_PREFIX) +
            CHANGELOG_FILE_POSTFIX_LENGTH * sizeof(WCHAR)
            > sizeof(NlGlobalChangeLogFilePrefix) ) {

        NlPrint((NL_CRITICAL,"Changelog file directory name length is "
                    "too long \n" ));

        NlGlobalChangeLogFilePrefix[0] = L'\0';
        goto CleanChangeLogFile;
    }

    wcscat( NlGlobalChangeLogFilePrefix, CHANGELOG_FILE_PREFIX );


    //
    // Read in the existing changelog file.
    //

    wcscpy( ChangeLogFile, NlGlobalChangeLogFilePrefix );
    wcscat( ChangeLogFile, CHANGELOG_FILE_POSTFIX );

    InitChangeLogDesc( &NlGlobalChangeLogDesc );
    Status = NlOpenChangeLogFile( ChangeLogFile, &NlGlobalChangeLogDesc, FALSE );

    if ( !NT_SUCCESS(Status) ) {
        goto CleanChangeLogFile;
    }


    //
    // Convert the changelog file to the right size/version.
    //

    Status = NlResizeChangeLogFile( &NlGlobalChangeLogDesc, NewChangeLogSize );

    if ( !NT_SUCCESS(Status) ) {
        goto CleanChangeLogFile;
    }

    goto Cleanup;


    //
    // CleanChangeLogFile
    //

CleanChangeLogFile:

    //
    // If we just need to start with a newly initialized file,
    //  do it.
    //

    Status = NlResetChangeLog( &NlGlobalChangeLogDesc, NewChangeLogSize );

Cleanup:

    //
    // Free any resources on error.
    //

    if ( !NT_SUCCESS(Status) ) {
        NlCloseChangeLogFile( &NlGlobalChangeLogDesc );
    }

    UNLOCK_CHANGELOG();

    return Status;
}


NTSTATUS
I_NetNotifyRole (
    IN POLICY_LSA_SERVER_ROLE Role
    )
/*++

Routine Description:

    This function is called by the LSA service upon LSA initialization
    and when LSA changes domain role.  This routine will initialize the
    change log cache if the role specified is PDC or delete the change
    log cache if the role specified is other than PDC.

    When this function initializing the change log if the change log
    currently exists on disk, the cache will be initialized from disk.
    LSA should treat errors from this routine as non-fatal.  LSA should
    log the errors so they may be corrected then continue
    initialization.  However, LSA should treat the system databases as
    read-only in this case.

Arguments:

    Role - Current role of the server.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    CHANGELOG_ROLE PreviousChangeLogRole;

    //
    // Change the role of the changelog itself.
    //

    Status = NetpNotifyRole ( Role );

    //
    //  Tell the netlogon service about the role change.
    //

    if ( NT_SUCCESS(Status) ) {

        Status = NlSendChangeLogNotification( ChangeLogRoleChanged,
                                            NULL,
                                            NULL,
                                            0,
                                            NULL,   // Object GUID,
                                            NULL,   // Domain GUID,
                                            NULL ); // Domain Name
    }


    return Status;
}


NTSTATUS
NetpNotifyRole (
    IN POLICY_LSA_SERVER_ROLE Role
    )
/*++

Routine Description:

    This function is called by the LSA service upon LSA initialization
    and when LSA changes domain role.  This routine will initialize the
    change log cache if the role specified is PDC or delete the change
    log cache if the role specified is other than PDC.

    When this function initializing the change log if the change log
    currently exists on disk, the cache will be initialized from disk.
    LSA should treat errors from this routine as non-fatal.  LSA should
    log the errors so they may be corrected then continue
    initialization.  However, LSA should treat the system databases as
    read-only in this case.

Arguments:

    Role - Current role of the server.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    CHANGELOG_ROLE PreviousChangeLogRole;

    //
    // If this is a workstation, simply return.
    //

    if ( NlGlobalChangeLogRole == ChangeLogMemberWorkstation ) {
        return STATUS_SUCCESS;
    }

    //
    // Set our role to the new value.
    //

    LOCK_CHANGELOG();
    PreviousChangeLogRole = NlGlobalChangeLogRole;

    if( Role == PolicyServerRolePrimary) {
        NlGlobalChangeLogRole = ChangeLogPrimary;
        NlPrint(( NL_DOMAIN,
                "NetpNotifyRole: LSA setting our role to Primary.\n"));
    } else {
        NlGlobalChangeLogRole = ChangeLogBackup;
        NlPrint(( NL_DOMAIN,
                "NetpNotifyRole: LSA setting our role to Backup.\n"));
    }

    //
    // If the role has changed,
    //  Delete any previous change log buffer.
    //  (Reopen it now to resize it upon role change.)
    //

    if ( NlGlobalChangeLogRole != PreviousChangeLogRole ) {
        NlCloseChangeLogFile( &NlGlobalChangeLogDesc );

        Status = NlInitChangeLogBuffer();

    }
    UNLOCK_CHANGELOG();

    return Status;
}

//
// Defines a set of handles to Netlogon.dll
//

#if NETLOGONDBG
#define MAX_NETLOGON_DLL_HANDLES 8

PHANDLE NlGlobalNetlogonDllHandles[MAX_NETLOGON_DLL_HANDLES];
ULONG NlGlobalNetlogonDllHandleCount = 0;
#endif // NETLOGONDBG


NTSTATUS
I_NetNotifyNetlogonDllHandle (
    IN PHANDLE NetlogonDllHandle
    )
/*++

Routine Description:

    Registers the fact that a service has an open handle to the NetlogonDll.
    This function is called by the LSA service, SAM service, and MSV1_0
    authentication package when the load netlogon.dll into the lsass.exe
    process.  Netlogon will close these handles (and NULL the handle) when
    it wants to unload the DLL from the lsass.exe process.  The DLL is only
    unloaded for debugging purposes.


Arguments:

    NetlogonDllHandle - Specifies a pointer to a handle to netlogon.dll

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{
#if NETLOGONDBG
    LOCK_CHANGELOG();
    if ( NlGlobalNetlogonDllHandleCount >= MAX_NETLOGON_DLL_HANDLES ) {
        NlPrint((NL_CRITICAL, "Too many Netlogon Dll handles registered.\n" ));
    } else {
#ifdef notdef
        NlPrint(( NL_MISC,
                  "I_NetNotifyNetlogonDllHandle loading 0x%lx %lx (%ld)\n",
                  NetlogonDllHandle,
                  *NetlogonDllHandle,
                  NlGlobalNetlogonDllHandleCount ));
#endif // notdef
        NlGlobalNetlogonDllHandles[NlGlobalNetlogonDllHandleCount] =
            NetlogonDllHandle;
        NlGlobalNetlogonDllHandleCount++;
    }
    UNLOCK_CHANGELOG();
#endif // NETLOGONDBG

    return STATUS_SUCCESS;
}


NET_API_STATUS
NlpFreeNetlogonDllHandles (
    VOID
    )
/*++

Routine Description:

    Free any curretly register NetlogonDll handles.


Arguments:

    None.

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
#if NETLOGONDBG
    ULONG i;
    ULONG NewHandleCount = 0;

    LOCK_CHANGELOG();
    for ( i=0; i<NlGlobalNetlogonDllHandleCount; i++ ) {
        if ( !FreeLibrary( *(NlGlobalNetlogonDllHandles[i]) ) ) {
            NetStatus = GetLastError();
            NlPrint(( NL_CRITICAL,
                      "Cannot Free NetlogonDll handle. %ld\n",
                      NetStatus ));

            NlGlobalNetlogonDllHandles[NewHandleCount] =
                NlGlobalNetlogonDllHandles[i];
            NewHandleCount++;

        } else {
            NlPrint(( NL_MISC,
                      "NlpFreeNetlogonDllHandle freed 0x%lx 0x%lx (%ld)\n",
                      NlGlobalNetlogonDllHandles[i],
                      *(NlGlobalNetlogonDllHandles[i]),
                      i ));
            *(NlGlobalNetlogonDllHandles[i]) = NULL;
        }
    }

    NlGlobalNetlogonDllHandleCount = NewHandleCount;

    UNLOCK_CHANGELOG();
#endif // NETLOGONDBG

    return NetStatus;
}



NTSTATUS
I_NetNotifyMachineAccount (
    IN ULONG ObjectRid,
    IN PSID DomainSid,
    IN ULONG OldUserAccountControl,
    IN ULONG NewUserAccountControl,
    IN PUNICODE_STRING ObjectName
    )
/*++

Routine Description:

    This function is called by the SAM to indicate that the account type
    of a machine account has changed.  Specifically, if
    USER_INTERDOMAIN_TRUST_ACCOUNT, USER_WORKSTATION_TRUST_ACCOUNT, or
    USER_SERVER_TRUST_ACCOUNT change for a particular account, this
    routine is called to let Netlogon know of the account change.

    This function is called for both PDC and BDC.

Arguments:

    ObjectRid - The relative ID of the object that has been modified.

    DomainSid - Specifies the SID of the Domain containing the object.

    OldUserAccountControl - Specifies the previous value of the
        UserAccountControl field of the user.

    NewUserAccountControl - Specifies the new (current) value of the
        UserAccountControl field of the user.

    ObjectName - The name of the account being changed.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    NTSTATUS SavedStatus = STATUS_SUCCESS;

    //
    // If the netlogon service isn't running,
    //   Don't bother with the coming and going of accounts.
    //

    if( NlGlobalChangeLogNetlogonState == NetlogonStopped ) {
        return(STATUS_SUCCESS);
    }

    //
    // If this is windows NT,
    //  There is nothing to maintain.
    //

    if ( NlGlobalChangeLogRole == ChangeLogMemberWorkstation ) {
        return(STATUS_SUCCESS);
    }


    //
    // Make available just the machine account bits.
    //

    OldUserAccountControl &= USER_MACHINE_ACCOUNT_MASK;
    NewUserAccountControl &= USER_MACHINE_ACCOUNT_MASK;

    if ( OldUserAccountControl == NewUserAccountControl ) {
        return STATUS_SUCCESS;
    }


    //
    // Handle deletion of a Workstation Trust Account
    // Handle deletion of a Server Trust Account
    //

    if ( OldUserAccountControl == USER_SERVER_TRUST_ACCOUNT ||
         OldUserAccountControl == USER_WORKSTATION_TRUST_ACCOUNT ) {

        Status = NlSendChangeLogNotification( ChangeLogTrustAccountDeleted,
                                              ObjectName,
                                              NULL,
                                              0,
                                              NULL, // Object GUID,
                                              NULL, // Domain GUID,
                                              NULL );   // Domain Name

        if ( NT_SUCCESS(SavedStatus) ) {
            SavedStatus = Status;
        }

    }

    //
    // Handle creation or change of a Workstation Trust Account
    // Handle creation or change of a Server Trust Account
    //
    // Sam is no longer capable of telling me the "previous" value of
    // account control.
    //

    if ( NewUserAccountControl == USER_SERVER_TRUST_ACCOUNT ||
         NewUserAccountControl == USER_WORKSTATION_TRUST_ACCOUNT ) {

        NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType;
        GUID ObjectGuid;

        if ( NewUserAccountControl == USER_SERVER_TRUST_ACCOUNT ) {
            SecureChannelType = ServerSecureChannel;
        } else if ( NewUserAccountControl == USER_WORKSTATION_TRUST_ACCOUNT ) {
            SecureChannelType = WorkstationSecureChannel;
        }


        RtlZeroMemory( &ObjectGuid, sizeof(ObjectGuid) );
        *(PULONG)&ObjectGuid = SecureChannelType;

        Status = NlSendChangeLogNotification( ChangeLogTrustAccountAdded,
                                              ObjectName,
                                              NULL,
                                              ObjectRid,
                                              &ObjectGuid, // Object GUID
                                              NULL, // Domain GUID
                                              NULL );   // Domain Name

        if ( NT_SUCCESS(SavedStatus) ) {
            SavedStatus = Status;
        }

    }

    return SavedStatus;
    UNREFERENCED_PARAMETER( DomainSid );
}



NTSTATUS
I_NetNotifyDsChange(
    IN NL_DS_CHANGE_TYPE DsChangeType
    )
/*++

Routine Description:

    This function is called by the LSA to indicate that configuration information
    in the DS has changed.

    This function is called for both PDC and BDC.

Arguments:

    DsChangeType - Indicates the type of information that has changed.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;

    //
    // If the netlogon service isn't running,
    //   Don't bother with the coming and going of DS information.
    //

    if( NlGlobalChangeLogNetlogonState == NetlogonStopped ) {
        return(STATUS_SUCCESS);
    }

    //
    // If this is windows NT,
    //  There is nothing to maintain.
    //

    if ( NlGlobalChangeLogRole == ChangeLogMemberWorkstation ) {
        return(STATUS_SUCCESS);
    }

    //
    // If this is a notification about the DC demotion,
    //  just set the global boolean accordingly.
    //

    if ( DsChangeType == NlDcDemotionInProgress ) {
        NlGlobalDcDemotionInProgress = TRUE;
        return(STATUS_SUCCESS);
    }

    if ( DsChangeType == NlDcDemotionCompleted ) {
        NlGlobalDcDemotionInProgress = FALSE;
        return(STATUS_SUCCESS);
    }

    //
    // Reset the TrustInfoUpToDate event so that any thread that wants to
    // access the trust info list will wait until the info is updated (by
    // the NlInitTrustList function).
    //

    if ( DsChangeType == NlOrgChanged ) {
        if ( !ResetEvent( NlGlobalTrustInfoUpToDateEvent ) ) {
            NlPrint((NL_CRITICAL,
                    "Cannot reset NlGlobalTrustInfoUpToDateEvent event: %lu\n",
                    GetLastError() ));
        }
    }

    //
    //  Tell the netlogon service about the change.
    //

    Status = NlSendChangeLogNotification( ChangeLogDsChanged,
                                          NULL,
                                          NULL,
                                          (ULONG) DsChangeType,
                                          NULL, // Object GUID,
                                          NULL, // Domain GUID,
                                          NULL );   // Domain Name


    return Status;
}



VOID
I_NetNotifyLsaPolicyChange(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangeInfoClass
    )
/*++

Routine Description:

    This function is called by the LSA to indicate that policy information
    in the LSA has changed.

    This function is called for both PDC and BDC.

Arguments:

    DsChangeType - Indicates the type of information that has changed.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;



    //
    // If the netlogon service is running,
    //  Tell it about the change.
    //
    //  It will, in turn, tell the bowser.
    //

    if( NlGlobalChangeLogNetlogonState != NetlogonStopped ) {

        //
        //  Tell the netlogon service about the change.
        //

        Status = NlSendChangeLogNotification( ChangeLogLsaPolicyChanged,
                                              NULL,
                                              NULL,
                                              (ULONG) ChangeInfoClass,
                                              NULL, // Object GUID,
                                              NULL, // Domain GUID,
                                              NULL );   // Domain Name
    //
    // If the netlogon service is not running,
    //  handle operations that need handling here.
    //
    } else {
        //
        // Tell the browser about the change.
        //
        switch ( ChangeInfoClass ) {
        case PolicyNotifyDnsDomainInformation:

            //
            // Tell the worker that it needs to notify the browser.
            //
            LOCK_CHANGELOG();
            NlGlobalChangeLogNotifyBrowser  = TRUE;

            //
            // Start the worker.
            //

            NlStartChangeLogWorkerThread();
            UNLOCK_CHANGELOG();

        }
    }


    return;
}


NTSTATUS
I_NetNotifyTrustedDomain (
    IN PSID HostedDomainSid,
    IN PSID TrustedDomainSid,
    IN BOOLEAN IsDeletion
    )
/*++

Routine Description:

    This function is called by the LSA to indicate that a trusted domain
    object has changed.

    This function is called for both PDC and BDC.

Arguments:

    HostedDomainSid - Domain SID of the domain the trust is from.

    TrustedDomainSid - Domain SID of the domain the trust is to.

    IsDeletion - TRUE if the trusted domain object was deleted.
        FALSE if the trusted domain object was created or modified.


Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;

    //
    // If the netlogon service isn't running,
    //   Don't bother with the coming and going of trusted domains..
    //

    if( NlGlobalChangeLogNetlogonState == NetlogonStopped ) {
        return(STATUS_SUCCESS);
    }

    //
    // If this is windows NT,
    //  There is nothing to maintain.
    //

    if ( NlGlobalChangeLogRole == ChangeLogMemberWorkstation ) {
        return(STATUS_SUCCESS);
    }

    //
    // Reset the TrustInfoUpToDate event so that any thread that wants to
    // access the trust info list will wait until the info is updated (by
    // the NlInitTrustList function).
    //

    if ( !ResetEvent( NlGlobalTrustInfoUpToDateEvent ) ) {
        NlPrint((NL_CRITICAL,
                "Cannot reset NlGlobalTrustInfoUpToDateEvent event: %lu\n",
                GetLastError() ));
    }

    //
    // Notify whether this is a creation/change/deletion.

    if ( IsDeletion ) {

        //
        //  Tell the netlogon service to update its in-memory list now.
        //

        Status = NlSendChangeLogNotification( ChangeLogTrustDeleted,
                                              NULL,
                                              TrustedDomainSid,
                                              0,
                                              NULL, // Object GUID,
                                              NULL, // Domain GUID,
                                              NULL );   // Domain Name
    } else {
        //
        //  Tell the netlogon service to update its in-memory list now.
        //

        Status = NlSendChangeLogNotification( ChangeLogTrustAdded,
                                              NULL,
                                              TrustedDomainSid,
                                              0,
                                              NULL, // Object GUID,
                                              NULL, // Domain GUID,
                                              NULL );   // Domain Name
    }



    return Status;
    UNREFERENCED_PARAMETER( HostedDomainSid );
}

NTSTATUS
I_NetNotifyNtdsDsaDeletion (
    IN LPWSTR DnsDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN GUID *DsaGuid OPTIONAL,
    IN LPWSTR DnsHostName
    )
/*++

Routine Description:

    This function is called by the DS to indicate that a NTDS-DSA object
    and/or DNS records associated with the DNS host name are being deleted.

    This function is called on the DC that the object is originally deleted on.
    It is not called when the deletion is replicated to other DCs.

Arguments:

    DnsDomainName - DNS domain name of the domain the DC was in.
        This need not be a domain hosted by this DC.
        If NULL, it is implied to be the DnsHostName with the leftmost label
            removed.

    DomainGuid - Domain Guid of the domain specified by DnsDomainName
        If NULL, GUID specific names will not be removed.

    DsaGuid - GUID of the NtdsDsa object that is being deleted.

    DnsHostName - DNS host name of the DC whose NTDS-DSA object is being deleted.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING DnsDomainNameString;
    PUNICODE_STRING DnsDomainNameStringPtr = NULL;
    UNICODE_STRING DnsHostNameString;

    //
    // If the netlogon service isn't running,
    //   Don't bother with the coming and going of trusted domains..
    //

    if( NlGlobalChangeLogNetlogonState == NetlogonStopped ) {
        return(STATUS_SUCCESS);
    }

    //
    // If this is windows NT,
    //  There is nothing to maintain.
    //

    if ( NlGlobalChangeLogRole == ChangeLogMemberWorkstation ) {
        return(STATUS_SUCCESS);
    }

    //
    // Queue this to the netlogon service
    //

    if ( DnsDomainName != NULL ) {
        RtlInitUnicodeString( &DnsDomainNameString, DnsDomainName );
        DnsDomainNameStringPtr = &DnsDomainNameString;
    }
    RtlInitUnicodeString( &DnsHostNameString, DnsHostName );
    Status = NlSendChangeLogNotification( ChangeLogNtdsDsaDeleted,
                                          &DnsHostNameString,
                                          NULL,
                                          0,
                                          DsaGuid,
                                          DomainGuid,
                                          DnsDomainNameStringPtr );


    return Status;
}

NTSTATUS
I_NetLogonSetServiceBits(
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    )

/*++

Routine Description:

    Inidcates whether this DC is currently running the specified service.

    For instance,

        I_NetLogonSetServiceBits( DS_KDC_FLAG, DS_KDC_FLAG );

    tells Netlogon the KDC is running.  And

        I_NetLogonSetServiceBits( DS_KDC_FLAG, 0 );

    tells Netlogon the KDC is not running.

Arguments:

    ServiceBitsOfInterest - A mask of the service bits being changed, set,
        or reset by this call.  Only the following flags are valid:

            DS_KDC_FLAG
            DS_DS_FLAG
            DS_TIMESERV_FLAG
            DS_GOOD_TIMESERV_FLAG

    ServiceBits - A mask indicating what the bits specified by ServiceBitsOfInterest
        should be set to.


Return Value:

    STATUS_SUCCESS - Success.

    STATUS_INVALID_PARAMETER - The parameters have extaneous bits set.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG OldDnsBits;
    ULONG NewDnsBits;

    //
    // Ensure the caller passed valid bits.
    //

    if ( (ServiceBitsOfInterest & ~DS_VALID_SERVICE_BITS) != 0 ||
         (ServiceBits & ~ServiceBitsOfInterest) != 0 ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Change the bits.
    //
    LOCK_CHANGELOG();
    OldDnsBits = NlGlobalChangeLogServiceBits & DS_DNS_SERVICE_BITS;
    NlGlobalChangeLogServiceBits &= ~ServiceBitsOfInterest;
    NlGlobalChangeLogServiceBits |= ServiceBits;
    NewDnsBits = NlGlobalChangeLogServiceBits & DS_DNS_SERVICE_BITS;
    NlGlobalChangeLogDllUnloaded = FALSE;
    UNLOCK_CHANGELOG();

    //
    // If bits changed that would affect which names we register in DNS,
    //  change the registration now.
    //

    if ( OldDnsBits != NewDnsBits ) {
        //
        //  Tell the netlogon service to update now.
        //

        Status = NlSendChangeLogNotification( ChangeDnsNames,
                                              NULL,
                                              NULL,
                                              0,    // Name registration need not be forced
                                              NULL, // Object GUID,
                                              NULL, // Domain GUID,
                                              NULL );   // Domain Name
    }

    return Status;
}


NTSTATUS
NlInitChangeLog(
    VOID
)
/*++

Routine Description:

    Do the portion of ChangeLog initialization which happens on process
    attach for netlogon.dll.

    Specifically, Initialize the NlGlobalChangeLogCritSect and several
    other global variables.

Arguments:

    NONE

Return Value:

    NT Status code

--*/
{
    LARGE_INTEGER DomainPromotionIncrement = DOMAIN_PROMOTION_INCREMENT;
    LARGE_INTEGER DomainPromotionMask = DOMAIN_PROMOTION_MASK;
    NTSTATUS Status;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    NT_PRODUCT_TYPE NtProductType;


    //
    // Initialize the critical section and anything process detach depends on.
    //

#if NETLOGONDBG
    try {
        InitializeCriticalSection(&NlGlobalLogFileCritSect);
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NlPrint((NL_CRITICAL, "Cannot InitializeCriticalSection for NlGlobalLogFileCritSect\n" ));
        return STATUS_NO_MEMORY;
    }
#endif // NETLOGONDBG

    try {
        InitializeCriticalSection( &NlGlobalChangeLogCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NlPrint((NL_CRITICAL, "Cannot InitializeCriticalSection for NlGlobalChangeLogCritSect\n" ));
        return STATUS_NO_MEMORY;
    }

    try {
        InitializeCriticalSection( &NlGlobalSecPkgCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NlPrint((NL_CRITICAL, "Cannot InitializeCriticalSection for NlGlobalSecPkgCritSect\n" ));
        return STATUS_NO_MEMORY;
    }

#if NETLOGONDBG
    NlGlobalParameters.DbFlag = 0xFFFFFFFF;
    NlGlobalLogFile = INVALID_HANDLE_VALUE;
    NlGlobalParameters.LogFileMaxSize = DEFAULT_MAXIMUM_LOGFILE_SIZE;
    NlGlobalLogFileOutputBuffer = NULL;
#endif // NETLOGONDBG
    InitChangeLogDesc( &NlGlobalChangeLogDesc );
    InitChangeLogDesc( &NlGlobalTempChangeLogDesc );
    NlGlobalChangeLogBuiltinDomainSid = NULL;
    NlGlobalChangeLogServiceBits = 0;
    NlGlobalChangeLogWorkerThreadHandle = NULL;
    NlGlobalChangeLogNotifyBrowser = FALSE;
    NlGlobalChangeLogNotifyBrowserIsRunning = FALSE;
    NlGlobalChangeLogWorkerIsRunning = FALSE;
    NlGlobalChangeLogDllUnloaded = TRUE;

    NlGlobalChangeLogNetlogonState = NetlogonStopped;
    NlGlobalChangeLogEvent = NULL;
    NlGlobalChangeLogReplicateImmediately = FALSE;
    InitializeListHead( &NlGlobalChangeLogNotifications );

    NlGlobalEventlogHandle = NetpEventlogOpen ( SERVICE_NETLOGON,
                                                0 ); // No timeout for now

    if ( NlGlobalEventlogHandle == NULL ) {
        NlPrint((NL_CRITICAL, "Cannot NetpEventlogOpen\n" ));
        return STATUS_NO_MEMORY;
    }


    NlGlobalChangeLogFilePrefix[0] = L'\0';
    NlGlobalChangeLogPromotionIncrement = DomainPromotionIncrement;
    NlGlobalChangeLogPromotionMask = DomainPromotionMask.HighPart;

    //
    // Create special change log notify event.
    //

    NlGlobalChangeLogEvent =
        CreateEvent( NULL,     // No security attributes
                    FALSE,    // Is automatically reset
                    FALSE,    // Initially not signaled
                    NULL );   // No name

    if ( NlGlobalChangeLogEvent == NULL ) {
        NET_API_STATUS NetStatus;

        NetStatus = GetLastError();
        NlPrint((NL_CRITICAL, "Cannot create ChangeLog Event %lu\n",
                    NetStatus ));
        return (int) NetpApiStatusToNtStatus(NetStatus);
    }

    //
    // Create the trust-info-up-to-date event.
    //

    NlGlobalTrustInfoUpToDateEvent =
        CreateEvent( NULL,    // No security attributes
                    TRUE,     // Is manually reset
                    TRUE,     // Initially signaled
                    NULL );   // No name

    if ( NlGlobalTrustInfoUpToDateEvent == NULL ) {
        NET_API_STATUS NetStatus;

        NetStatus = GetLastError();
        NlPrint((NL_CRITICAL, "Cannot create TrustInfoUpToDate Event %lu\n",
                    NetStatus ));
        return (int) NetpApiStatusToNtStatus(NetStatus);
    }

    //
    // Initialize the Role.
    //
    // For Windows-NT, just set the role to member workstation once and for all.
    //
    // For LanMan-Nt initially set it to "unknown" to prevent the
    // changelog from being maintained until LSA calls I_NetNotifyRole.
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        NtProductType = NtProductWinNt;
    }

    if ( NtProductType == NtProductLanManNt ) {
        NlGlobalChangeLogRole = ChangeLogUnknown;
    } else {
        NlGlobalChangeLogRole = ChangeLogMemberWorkstation;
    }

    //
    // Initialize DC specific globals.
    //

    if ( NtProductType == NtProductLanManNt ) {

        //
        // Build a Sid for the SAM Builtin domain
        //

        Status = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,              // Sub Authority Count
                    SECURITY_BUILTIN_DOMAIN_RID,
                    0,              // Unused
                    0,              // Unused
                    0,              // Unused
                    0,              // Unused
                    0,              // Unused
                    0,              // Unused
                    0,              // Unused
                    &NlGlobalChangeLogBuiltinDomainSid);

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }
    }

    //
    // Ask the LSA to notify us of any changes to the LSA database.
    //

    Status = LsaIRegisterPolicyChangeNotificationCallback(
                &I_NetNotifyLsaPolicyChange,
                PolicyNotifyDnsDomainInformation );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint((NL_CRITICAL,
                "Failed to LsaIRegisterPolicyChangeNotificationCallback. %lX\n",
                 Status ));
        goto Cleanup;
    }

    //
    // Success...
    //


    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //

Cleanup:

    return Status;
}

//
// netlogon.dll never detaches
//
#if NETLOGONDBG

NTSTATUS
NlCloseChangeLog(
    VOID
)
/*++

Routine Description:

    Frees any resources consumed by NlInitChangeLog.

Arguments:

    NONE

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;

    //
    // Ask the LSA to notify us of any changes to the LSA database.
    //

    Status = LsaIUnregisterAllPolicyChangeNotificationCallback(
                &I_NetNotifyLsaPolicyChange );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint((NL_CRITICAL,
                "Failed to LsaIUnregisterPolicyChangeNotificationCallback. %lX\n",
                 Status ));
    }


    if ( (NlGlobalChangeLogDesc.FileHandle == INVALID_HANDLE_VALUE) &&
         (NlGlobalChangeLogRole == ChangeLogPrimary) ) {

        //
        // try to save change log cache one last time.
        //

        (VOID)NlCreateChangeLogFile( &NlGlobalChangeLogDesc );
    }

    //
    // Close the changelogs
    //

    NlCloseChangeLogFile( &NlGlobalChangeLogDesc );
    NlCloseChangeLogFile( &NlGlobalTempChangeLogDesc );



    //
    // Initialize the globals.
    //

    NlGlobalChangeLogFilePrefix[0] = L'\0';


    if ( NlGlobalChangeLogBuiltinDomainSid != NULL ) {
        RtlFreeSid( NlGlobalChangeLogBuiltinDomainSid );
        NlGlobalChangeLogBuiltinDomainSid = NULL;
    }

    if ( NlGlobalChangeLogEvent != NULL ) {
        (VOID) CloseHandle(NlGlobalChangeLogEvent);
        NlGlobalChangeLogEvent = NULL;
    }

    if ( NlGlobalTrustInfoUpToDateEvent != NULL ) {
        (VOID) CloseHandle(NlGlobalTrustInfoUpToDateEvent);
        NlGlobalTrustInfoUpToDateEvent = NULL;
    }


    //
    // Stop the worker thread if it is running
    //
    NlStopChangeLogWorker();


    LOCK_CHANGELOG();

    NlAssert( IsListEmpty( &NlGlobalChangeLogNotifications ) );

    UNLOCK_CHANGELOG();

    //
    // Close the eventlog handle
    //

    NetpEventlogClose( NlGlobalEventlogHandle );

    //
    // close all handles
    //

    DeleteCriticalSection(&NlGlobalSecPkgCritSect);
    DeleteCriticalSection( &NlGlobalChangeLogCritSect );
#if NETLOGONDBG
    if ( NlGlobalLogFileOutputBuffer != NULL ) {
        LocalFree( NlGlobalLogFileOutputBuffer );
        NlGlobalLogFileOutputBuffer = NULL;
    }
    DeleteCriticalSection( &NlGlobalLogFileCritSect );
#endif // NETLOGONDBG

    return STATUS_SUCCESS;

}
#endif // NETLOGONDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\dns.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dns.c

Abstract:

    Routines to register DNS names.

Author:

    Cliff Van Dyke (CliffV) 28-May-1996

Revision History:

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

BOOL NlGlobalDnsScavengeNeeded = FALSE;
BOOL NlGlobalDnsScavengingInProgress = FALSE;
ULONG NlGlobalDnsScavengeFlags = 0;
WORKER_ITEM NlGlobalDnsScavengeWorkItem;

BOOL NlDnsWriteServerFailureEventLog = FALSE;
ULONG NlDnsInitCount = 0;    // The number of times we have been started

//
// The timeout after our start when it's OK to write DNS errors into
//  the event log. We postpone error output because the DNS server
//  (if it runs locally) may not have started yet.
//
#define NL_DNS_EVENTLOG_TIMEOUT  (2 * 60 * 1000)  // 2 minutes

//
// Max time that a name update should reasonably take.
//  We will indicate in netlogon.log if a given update
//  takes longer than this threshold.
//
#define NL_DNS_ONE_THRESHOLD (15*1000)  // 15 seconds

//
// Max time that DNS deregistrations are allowed to take on shutdown.
//  We will abort deregistration cycle on shutdown if total deregisrtaion
//  time for all records takes longer than this timeout.
//
#define NL_DNS_SHUTDOWN_THRESHOLD  60000 // 1 minute

//
// Max number of times we will restart concurrent DNS scavenging
//  before giving up.
//
#define NL_DNS_MAX_SCAVENGE_RESTART  10  // 10 times

//
// State of a DNS name.
//

typedef enum {
    RegisterMe,     // Name needs to be registered
    Registered,     // Name is registered
    DeregisterMe,   // Name needs to be deregistered
    DelayedDeregister,  // Name will be marked for deregistration in the future
    DeleteMe,        // This entry should be deleted.
    DnsNameStateInvalid  // State is invalid
} NL_DNS_NAME_STATE;


//
// Structure representing an added DNS name.
//  (All fields serialized by NlGlobalDnsCritSect)
//

typedef struct _NL_DNS_NAME {

    //
    // Link in list of all such structures headed by NlGlobalDnsList
    //
    LIST_ENTRY Next;

    //
    // Type of name registed.
    //
    NL_DNS_NAME_TYPE NlDnsNameType;

    //
    // Domain this entry refers to.
    //
    PDOMAIN_INFO DomainInfo;

    //
    // Flags describing the entry.
    //

    ULONG Flags;

#define NL_DNS_REGISTER_DOMAIN      0x0001  // All names for domain being registered.
#define NL_DNS_REGISTERED_ONCE      0x0002  // Name has been registered at least once

    //
    // The time of the first failure to deregister this name.
    //  Reset to zero on successful deregistration.
    //

    LARGE_INTEGER FirstDeregFailureTime;

    //
    // Each regisration is periodically re-done (whether successful or not).
    // This timer indicates when the next re-registration should be done.
    //
    // The initial re-registration is done after 5 minute.  The period then
    // doubles until it reaches a maximum of DnsRefreshInterval.
    //

    TIMER ScavengeTimer;

#define ORIG_DNS_SCAVENGE_PERIOD  (5*60*1000)    // 5 minute


    //
    // Actual DNS name registered.
    //
    LPSTR DnsRecordName;


    //
    // Data for the SRV record
    //
    ULONG Priority;
    ULONG Weight;
    ULONG Port;
    LPSTR DnsHostName;

    //
    // Data for the A record
    //
    ULONG IpAddress;


    //
    // State of this entry.
    //
    NL_DNS_NAME_STATE State;

    //
    // Last DNS update status for this name
    //
    NET_API_STATUS NlDnsNameLastStatus;

} NL_DNS_NAME, *PNL_DNS_NAME;

//
// Header for binary Dns log file.
//

typedef struct _NL_DNSLOG_HEADER {

    ULONG Version;

} NL_DNSLOG_HEADER, *PNL_DNSLOG_HEADER;

#define NL_DNSLOG_VERSION   1


//
// Entry in the binary Dns log file.
//

typedef struct _NL_DNSLOG_ENTRY {

    //
    // Size (in bytes) of this entry
    //
    ULONG EntrySize;

    //
    // Type of name registed.
    //
    NL_DNS_NAME_TYPE NlDnsNameType;

    //
    // Data for the SRV record
    //
    ULONG Priority;
    ULONG Weight;
    ULONG Port;

    //
    // Data for the A record
    //
    ULONG IpAddress;

} NL_DNSLOG_ENTRY, *PNL_DNSLOG_ENTRY;


//
// Globals specific to this .c file.
//

//
// True if the DNS list needs to be output to netlogon.dns
//
BOOLEAN NlGlobalDnsListDirty;

//
// True if the initial cleanup of previously registered names has been done.
//
BOOLEAN NlGlobalDnsInitialCleanupDone;

//
// Time when netlogon was started.
//
DWORD NlGlobalDnsStartTime;
#define NL_DNS_INITIAL_CLEANUP_TIME (10 * 60 * 1000)    // 10 minutes




VOID
NlDnsNameToStr(
    IN PNL_DNS_NAME NlDnsName,
    OUT CHAR Utf8DnsRecord[NL_DNS_RECORD_STRING_SIZE]
    )
/*++

Routine Description:

    This routine builds a textual representation of NlDnsName

Arguments:

    NlDnsName - Name to register or deregister.

    Utf8DnsRecord - Preallocated buffer to build the text string into.
        The built record is a UTF-8 zero terminated string.
        The string is concatenated to this buffer.


Return Value:

    None.

--*/
{
    CHAR Number[33];

    //
    // Write the record name
    //

    strcat( Utf8DnsRecord, NlDnsName->DnsRecordName );

    //
    // Concatenate the TTL
    //

    _ltoa( NlGlobalParameters.DnsTtl, Number, 10 );
    strcat( Utf8DnsRecord, " " );
    strcat( Utf8DnsRecord, Number );

    //
    // Build an A record.
    //

    if ( NlDnsARecord( NlDnsName->NlDnsNameType ) ) {
        CHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1];

        strcat( Utf8DnsRecord, NL_DNS_A_RR_VALUE_1 );
        NetpIpAddressToStr( NlDnsName->IpAddress, IpAddressString );
        strcat( Utf8DnsRecord, IpAddressString );

    //
    // Build a CNAME record
    //

    } else if ( NlDnsCnameRecord( NlDnsName->NlDnsNameType ) ) {
        strcat( Utf8DnsRecord, NL_DNS_CNAME_RR_VALUE_1 );
        strcat( Utf8DnsRecord, NlDnsName->DnsHostName );
        strcat( Utf8DnsRecord, "." );

    //
    // Build a SRV record
    //

    } else {
        strcat( Utf8DnsRecord, NL_DNS_SRV_RR_VALUE_1 );

        _ltoa( NlDnsName->Priority, Number, 10 );
        strcat( Utf8DnsRecord, Number );
        strcat( Utf8DnsRecord, " " );

        _ltoa( NlDnsName->Weight, Number, 10 );
        strcat( Utf8DnsRecord, Number );
        strcat( Utf8DnsRecord, " " );

        _ltoa( NlDnsName->Port, Number, 10 );
        strcat( Utf8DnsRecord, Number );
        strcat( Utf8DnsRecord, " " );

        strcat( Utf8DnsRecord, NlDnsName->DnsHostName );
        strcat( Utf8DnsRecord, "." );

    }
}

LPWSTR
NlDnsNameToWStr(
    IN PNL_DNS_NAME NlDnsName
    )
/*++

Routine Description:

    This routine builds a textual representation of NlDnsName

Arguments:

    NlDnsName - Name to register or deregister.

    Utf8DnsRecord - Preallocated buffer to build the text string into.
        The built record is a UTF-8 zero terminated string.
        The string is concatenated to this buffer.


Return Value:

    Buffer containing a textual representation of NlDnsName
    NULL: Buffer could not be allocated

    Buffer should be free by calling NetApiBufferFree();

--*/
{
    LPSTR DnsRecord = NULL;
    LPWSTR UnicodeDnsRecord;

    //
    // Allocate a buffer for the UTF-8 version of the string.
    //
    DnsRecord = LocalAlloc( 0, NL_DNS_RECORD_STRING_SIZE + 1 );

    if ( DnsRecord == NULL ) {
        return NULL;
    }

    DnsRecord[0] = '\0';

    //
    // Create the text string in UTF-8
    //
    NlDnsNameToStr( NlDnsName, DnsRecord );


    //
    // Convert to Unicode
    //
    UnicodeDnsRecord = NetpAllocWStrFromUtf8Str( DnsRecord );

    LocalFree( DnsRecord );

    return UnicodeDnsRecord;
}

LPWSTR
NlDnsNameToDomainName(
    IN PNL_DNS_NAME NlDnsName
    )
/*++

Routine Description:

    This routine parses the record and returns the DNS name
    of the domain the record belongs to.

    Note that we have to parse the name because we may not have
    the DomainInfo structure hanging off NlDnsName if this is a
    deregistration of no longer hosted domain.

    Note that this routine relies on a particular structure
    of DNS records that netlogon registers.  If that structure
    changes, this routine will have to change accordingly.

Arguments:

    NlDnsName - Name to register or deregister.

Return Value:

    Pointer to the alocated DNS domain name.  Must be freed
    by calling NetApiBufferFree.

--*/
{
    LPWSTR UnicodeRecordName = NULL;
    LPWSTR UnicodeDnsDomainName = NULL;

    LPWSTR Ptr = NULL;
    LPWSTR DotPtr = NULL;

    //
    // The record name has a structure where the label immediately
    //  before the domain name has a leading underscore. There might
    //  be no label before the domain name for A records -- we will
    //  treat the absence of underscore in the name as an indication
    //  of that the record name is the domain name itself.
    //

    UnicodeRecordName = NetpAllocWStrFromUtf8Str( NlDnsName->DnsRecordName );

    if ( UnicodeRecordName == NULL || *UnicodeRecordName == UNICODE_NULL ) {
        goto Cleanup;
    }

    //
    // Starting from the last character and going to the front,
    //  search for the characters of interest.
    //

    Ptr = UnicodeRecordName + wcslen( UnicodeRecordName ) - 1;

    while ( Ptr != UnicodeRecordName ) {

        //
        // If this is the next dot going from the end,
        //  remember its location
        //
        if ( *Ptr == NL_DNS_DOT ) {
            DotPtr = Ptr;
        }

        //
        // If this is the first underscore going from the end,
        //  break from the loop: the domain name is immediately
        //  after the previous dot
        //
        if ( *Ptr == NL_DNS_UNDERSCORE ) {
            NlAssert( DotPtr != NULL );
            break;
        }

        Ptr --;
    }

    //
    // If there is no underscore in the name,
    //  the domain name is the record name itself.
    //  Otherwise, the domain name follows immediately
    //  after the last dot.
    //

    if ( Ptr == UnicodeRecordName ) {
        UnicodeDnsDomainName = NetpAllocWStrFromWStr( UnicodeRecordName );
    } else if ( DotPtr != NULL ) {
        UnicodeDnsDomainName = NetpAllocWStrFromWStr( DotPtr + 1 );
    }

Cleanup:

    if ( UnicodeRecordName != NULL ) {
        NetApiBufferFree( UnicodeRecordName );
    }

    return UnicodeDnsDomainName;
}

#if  NETLOGONDBG
#define NlPrintDns(_x_) NlPrintDnsRoutine _x_
#else
#define NlPrintDns(_x_)
#endif // NETLOGONDBG

#if NETLOGONDBG
VOID
NlPrintDnsRoutine(
    IN DWORD DebugFlag,
    IN PNL_DNS_NAME NlDnsName,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;
    CHAR Utf8DnsRecord[NL_DNS_RECORD_STRING_SIZE];

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &NlGlobalLogFileCritSect );

    //
    // Prefix the printed line with the domain name
    //

    if ( NlGlobalServicedDomainCount > 1 ) {
        if ( NlDnsName->DomainInfo == NULL ) {
            NlPrint(( DebugFlag, "%ws: ", L"[Unknown]" ));
        } else if ( NlDnsName->DomainInfo->DomUnicodeDomainName != NULL &&
                    *(NlDnsName->DomainInfo->DomUnicodeDomainName) != UNICODE_NULL ) {
            NlPrint(( DebugFlag, "%ws: ", NlDnsName->DomainInfo->DomUnicodeDomainName ));
        } else {
            NlPrint(( DebugFlag, "%ws: ", NlDnsName->DomainInfo->DomUnicodeDnsDomainName ));
        }
    }


    //
    // Simply change arguments to va_list form and call NlPrintRoutineV
    //

    va_start(arglist, Format);

    NlPrintRoutineV( DebugFlag, Format, arglist );

    va_end(arglist);


    //
    // Finally print a description of the DNS record in question.
    //

    Utf8DnsRecord[0] = '\0';
    NlDnsNameToStr( NlDnsName, Utf8DnsRecord );

    NlPrint(( DebugFlag,
              ": %ws: %s\n",
              NlDcDnsNameTypeDesc[NlDnsName->NlDnsNameType].Name,
              Utf8DnsRecord ));

    LeaveCriticalSection( &NlGlobalLogFileCritSect );

}
#endif // NETLOGONDBG

BOOL
NlDnsSetAvoidRegisterNameParam(
    IN LPTSTR_ARRAY NewDnsAvoidRegisterRecords
    )
/*++

Routine Description:

    This routine sets the names of DNS records this DC should avoid registering.

Arguments:

    NewSiteCoverage - Specifies the new list of names to avoid registering

Return Value:

    TRUE: iff the list of names to avoid registering changed

--*/
{
    BOOL DnsAvoidRegisterRecordsChanged = FALSE;

    EnterCriticalSection( &NlGlobalParametersCritSect );

    //
    // Handle DnsAvoidRegisterRecords changing
    //

    DnsAvoidRegisterRecordsChanged = !NetpEqualTStrArrays(
                                          NlGlobalParameters.DnsAvoidRegisterRecords,
                                          NewDnsAvoidRegisterRecords );

    if ( DnsAvoidRegisterRecordsChanged ) {
        //
        // Swap in the new value.
        (VOID) NetApiBufferFree( NlGlobalParameters.DnsAvoidRegisterRecords );
        NlGlobalParameters.DnsAvoidRegisterRecords = NewDnsAvoidRegisterRecords;
    }

    LeaveCriticalSection( &NlGlobalParametersCritSect );
    return DnsAvoidRegisterRecordsChanged;
}

NET_API_STATUS
NlGetConfiguredDnsDomainName(
    OUT LPWSTR *DnsDomainName
    )
/*++

Routine Description:

    This routine gets the DNS domain name of domain as configured by DNS or DHCP

    NOTE: THIS ROUTINE IS CURRENTLY UNUSED

Arguments:

    DnsDomainName -  Returns the DNS domain name of the domain.
        The returned name has a trailing . since the name is an absolute name.
        The allocated buffer must be freed via NetApiBufferFree.
        Returns NO_ERROR and a pointer to a NULL buffer if there is no
        domain name configured.

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    WCHAR LocalDnsDomainNameBuffer[NL_MAX_DNS_LENGTH+1];
    LPWSTR LocalDnsDomainName = NULL;

    LPNET_CONFIG_HANDLE SectionHandle = NULL;

    *DnsDomainName = NULL;

    //
    // Get the domain name from the registery
    //


    NetStatus = NetpOpenConfigData(
            &SectionHandle,
            NULL,                       // no server name.
            SERVICE_TCPIP,
            TRUE );                     // we only want readonly access

    if ( NetStatus != NO_ERROR ) {
        //
        // Simply return success if TCP/IP isn't configured.
        //
        if ( NetStatus == NERR_CfgCompNotFound ) {
            NetStatus = NO_ERROR;
        }
        SectionHandle = NULL;
        goto Cleanup;
    }

    //
    // Get the "Domain" parameter from the TCPIP service.
    //

    NetStatus = NetpGetConfigValue (
            SectionHandle,
            L"Domain",      // key wanted
            &LocalDnsDomainName );      // Must be freed by NetApiBufferFree().

    if ( NetStatus == NO_ERROR && *LocalDnsDomainName == L'\0' ) {
        NetStatus = NERR_CfgParamNotFound;
        NetApiBufferFree( LocalDnsDomainName );
        LocalDnsDomainName = NULL;
    }

    if (NetStatus != NERR_CfgParamNotFound ) {
        goto Cleanup;
    }


    //
    // Fall back to the "DhcpDomain" parameter from the TCPIP service.
    //

    NetStatus = NetpGetConfigValue (
            SectionHandle,
            L"DhcpDomain",      // key wanted
            &LocalDnsDomainName );      // Must be freed by NetApiBufferFree().

    if ( NetStatus == NO_ERROR && *LocalDnsDomainName == L'\0' ) {
        NetStatus = NERR_CfgParamNotFound;
        NetApiBufferFree( LocalDnsDomainName );
        LocalDnsDomainName = NULL;
    }

    if (NetStatus == NERR_CfgParamNotFound ) {
        NetStatus = NO_ERROR;
    }

Cleanup:
    if ( NetStatus == NO_ERROR ) {
        if ( LocalDnsDomainName != NULL ) {
            ULONG LocalDnsDomainNameLen = wcslen(LocalDnsDomainName);
            if ( LocalDnsDomainNameLen != 0 ) {
                if ( LocalDnsDomainNameLen > NL_MAX_DNS_LENGTH-1 ) {
                    NetStatus = ERROR_INVALID_DOMAINNAME;
                } else {
                    NetStatus = NetapipBufferAllocate(
                                    (LocalDnsDomainNameLen + 2) * sizeof(WCHAR),
                                    DnsDomainName );
                    if ( NetStatus == NO_ERROR ) {
                        wcscpy( *DnsDomainName, LocalDnsDomainName );
                        if ( (*DnsDomainName)[LocalDnsDomainNameLen-1] != L'.' ) {
                            wcscat( *DnsDomainName, L"." );
                        }
                    }
                }
            }
        }
    }
    if ( SectionHandle != NULL ) {
        (VOID) NetpCloseConfigData( SectionHandle );
    }
    if ( LocalDnsDomainName != NULL ) {
        NetApiBufferFree( LocalDnsDomainName );
    }

    return NetStatus;
}

VOID
NlDnsSetState(
    PNL_DNS_NAME NlDnsName,
    NL_DNS_NAME_STATE State
    )
/*++

Routine Description:

    Set the state of the entry.

Arguments:

    NlDnsName - Structure describing name.

    State - New state for the name.

Return Value:

    None.

--*/
{
    EnterCriticalSection( &NlGlobalDnsCritSect );

    //
    // If this name got registered,
    //  remember that fact
    //

    if ( State == Registered ) {
        NlDnsName->Flags |= NL_DNS_REGISTERED_ONCE;
    }

    //
    // If the state changes, do appropriate updates
    //

    if ( NlDnsName->State != State ) {
        NlDnsName->State = State;
        NlGlobalDnsListDirty = TRUE;

        //
        // If the new state says I need to update the DNS server,
        //  set the retry period to indicate to do that now.
        //

        if ( NlDnsName->State == RegisterMe ||
             NlDnsName->State == DeregisterMe ) {

            NlDnsName->ScavengeTimer.StartTime.QuadPart = 0;
            NlDnsName->ScavengeTimer.Period = 0;
        }
    }

    LeaveCriticalSection( &NlGlobalDnsCritSect );
}



NET_API_STATUS
NlDnsBuildName(
    IN PDOMAIN_INFO DomainInfo,
    IN NL_DNS_NAME_TYPE NlDnsNameType,
    IN LPWSTR SiteName,
    IN BOOL DnsNameAlias,
    OUT char DnsName[NL_MAX_DNS_LENGTH+1]
    )
/*++

Routine Description:

    This routine returns the textual DNS name for a particular domain and
    name type.

Arguments:

    DomainInfo - Domain the name is for.

    NlDnsNameType - The specific type of name.

    SiteName - If NlDnsNameType is any of the *AtSite values,
        the site name of the site this name is registered for.

    DnsNameAlias - If TRUE, the built name should correspond to the
        alias of the domain/forest name.

    DnsName - Textual representation of the name. If the name is not
        applicable (DnsNameAlias is TRUE but there is no alias for
        the name), the returned string will be empty.

Return Value:

    NO_ERROR: The name was returned;

    ERROR_NO_SUCH_DOMAIN: No (active) domain name is known for this domain.

    ERROR_INVALID_DOMAINNAME: Domain's name is too long. Additional labels
        cannot be concatenated.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    GUID DomainGuid;
    LPSTR DnsDomainName = NULL;
    BOOLEAN UseForestName = FALSE;

    //
    // Initialization
    //

    RtlZeroMemory( DnsName, (NL_MAX_DNS_LENGTH+1)*sizeof(char) );

    //
    // Get the Domain GUID for the case where the DC domain name.
    //  The Domain GUID is registered at the TreeName
    //

    EnterCriticalSection(&NlGlobalDomainCritSect);
    if ( NlDnsDcGuid( NlDnsNameType ) ) {
        if ( DomainInfo->DomDomainGuid == NULL ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlDnsBuildName: Domain has no GUID.\n" ));
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }
        DomainGuid = *(DomainInfo->DomDomainGuid);

        UseForestName = TRUE;


    //
    // Get the DSA Guid for the case where the DC is renamed.
    //

    } else if ( NlDnsCnameRecord( NlDnsNameType) ) {

        if ( IsEqualGUID( &NlGlobalDsaGuid, &NlGlobalZeroGuid) ) {
            NlPrintDom((NL_DNS, DomainInfo,
                    "NlDnsBuildName: DSA has no GUID.\n" ));
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }
        DomainGuid = NlGlobalDsaGuid;

        UseForestName = TRUE;
    }

    //
    // Ensure site specific names have been passed a site name
    //

    if ( NlDcDnsNameTypeDesc[NlDnsNameType].IsSiteSpecific ) {
        if ( SiteName == NULL ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlDnsBuildName: DC has no Site Name.\n" ));
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }
    }

    //
    // GC's are registered at the Forest name.
    //

    if ( NlDnsGcName( NlDnsNameType ) ) {
        UseForestName = TRUE;
    }


    //
    // Pick up the ForestName or DomainName as flagged above.
    //

    if ( UseForestName ) {
        if ( !DnsNameAlias ) {
            DnsDomainName = NlGlobalUtf8DnsForestName;

            //
            // We must have an active forest name
            //
            if ( NlGlobalUtf8DnsForestName == NULL ) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NlDnsBuildName: Domain has no Forest Name.\n" ));
                NetStatus = ERROR_NO_SUCH_DOMAIN;
                goto Cleanup;
            }
        } else {
            DnsDomainName = NlGlobalUtf8DnsForestNameAlias;
        }
    } else {
        if ( !DnsNameAlias ) {
            DnsDomainName = DomainInfo->DomUtf8DnsDomainName;

            //
            // We must have an active domain name
            //
            if ( DomainInfo->DomUtf8DnsDomainName == NULL ) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NlDnsBuildName: Domain has no Domain Name.\n" ));
                NetStatus = ERROR_NO_SUCH_DOMAIN;
                goto Cleanup;
            }
        } else {
            DnsDomainName = DomainInfo->DomUtf8DnsDomainNameAlias;
        }
    }

    //
    // Build the appropriate name as applicable
    //

    if ( DnsDomainName != NULL ) {
        NetStatus = NetpDcBuildDnsName( NlDnsNameType,
                                   &DomainGuid,
                                   SiteName,
                                   DnsDomainName,
                                   DnsName );
    }

Cleanup:
    LeaveCriticalSection(&NlGlobalDomainCritSect);
    return NetStatus;

}


HKEY
NlOpenNetlogonKey(
    LPSTR KeyName
    )
/*++

Routine Description:

    Create/Open the Netlogon key in the registry.

Arguments:

    KeyName - Name of the key to open

Return Value:

    Return a handle to the key.  NULL means the key couldn't be opened.

--*/
{
    LONG RegStatus;

    HKEY ParmHandle = NULL;
    ULONG Disposition;


    //
    // Open the key for Netlogon\Parameters
    //

    RegStatus = RegCreateKeyExA(
                    HKEY_LOCAL_MACHINE,
                    KeyName,
                    0,      //Reserved
                    NULL,   // Class
                    REG_OPTION_NON_VOLATILE,
                    KEY_SET_VALUE | KEY_QUERY_VALUE | KEY_NOTIFY,
                    NULL,   // Security descriptor
                    &ParmHandle,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "NlOpenNetlogonKey: Cannot create registy key %s %ld.\n",
                  KeyName,
                  RegStatus ));
        return NULL;
    }

    return ParmHandle;
}

VOID
NlDnsWriteBinaryLog(
    VOID
    )
/*++

Routine Description:

    Write the list of registered DNS names to the registry.

Arguments:

    None

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;

    PLIST_ENTRY ListEntry;
    PNL_DNS_NAME NlDnsName;

    ULONG DnsRecordBufferSize;
    PNL_DNSLOG_HEADER DnsRecordBuffer = NULL;
    PNL_DNSLOG_ENTRY DnsLogEntry;
    ULONG CurrentSize;

    LPBYTE Where;

    //
    // Compute the size of the buffer to allocate.
    //

    DnsRecordBufferSize = ROUND_UP_COUNT( sizeof(NL_DNSLOG_HEADER), ALIGN_WORST );

    EnterCriticalSection( &NlGlobalDnsCritSect );
    for ( ListEntry = NlGlobalDnsList.Flink ;
          ListEntry != &NlGlobalDnsList ;
          ListEntry = ListEntry->Flink ) {

        NlDnsName = CONTAINING_RECORD( ListEntry, NL_DNS_NAME, Next );

        //
        // If this entry is marked for deletion,
        //  skip it
        //
        if ( NlDnsName->State == DeleteMe ) {
            continue;
        }

        //
        // Only do entries that have been registered.
        //
        // The whole purpose of this log is to keep track of names that
        // need to be deregistered sooner or later.
        //
        if ( NlDnsName->Flags & NL_DNS_REGISTERED_ONCE ) {

            //
            // Compute the size of this entry.
            //

            CurrentSize = sizeof(NL_DNSLOG_ENTRY);
            CurrentSize += strlen( NlDnsName->DnsRecordName ) + 1;
            if ( NlDnsName->DnsHostName != NULL ) {
                CurrentSize += strlen( NlDnsName->DnsHostName ) + 1;
            }
            CurrentSize = ROUND_UP_COUNT( CurrentSize, ALIGN_WORST );

            //
            // Add it to the size needed for the file.
            //

            DnsRecordBufferSize += CurrentSize;
        }


    }

    //
    // Allocate a block to build the binary log into.
    //  (and the build the file name in)
    //

    DnsRecordBuffer = LocalAlloc( LMEM_ZEROINIT, DnsRecordBufferSize );

    if ( DnsRecordBuffer == NULL ) {
        LeaveCriticalSection( &NlGlobalDnsCritSect );
        goto Cleanup;
    }

    DnsRecordBuffer->Version = NL_DNSLOG_VERSION;
    DnsLogEntry = (PNL_DNSLOG_ENTRY)ROUND_UP_POINTER( (DnsRecordBuffer + 1), ALIGN_WORST );

    for ( ListEntry = NlGlobalDnsList.Flink ;
          ListEntry != &NlGlobalDnsList ;
          ListEntry = ListEntry->Flink ) {

        ULONG DnsRecordNameSize;
        ULONG DnsHostNameSize;

        NlDnsName = CONTAINING_RECORD( ListEntry, NL_DNS_NAME, Next );

        //
        // If this entry is marked for deletion,
        //  skip it
        //
        if ( NlDnsName->State == DeleteMe ) {
            continue;
        }

        //
        // Only do entries that have been registered.
        //
        // The whole purpose of this log is to keep track of names that
        // need to be deregistered sooner or later.
        //
        if ( NlDnsName->Flags & NL_DNS_REGISTERED_ONCE ) {

            //
            // Compute the size of this entry.
            //

            DnsRecordNameSize = strlen( NlDnsName->DnsRecordName ) + 1;

            CurrentSize = sizeof(NL_DNSLOG_ENTRY) + DnsRecordNameSize;
            if ( NlDnsName->DnsHostName != NULL ) {
                DnsHostNameSize = strlen( NlDnsName->DnsHostName ) + 1;
                CurrentSize += DnsHostNameSize;
            }
            CurrentSize = ROUND_UP_COUNT( CurrentSize, ALIGN_WORST );

            //
            // Put the constant size fields in the buffer.
            //

            DnsLogEntry->EntrySize = CurrentSize;
            DnsLogEntry->NlDnsNameType = NlDnsName->NlDnsNameType;
            DnsLogEntry->IpAddress = NlDnsName->IpAddress;
            DnsLogEntry->Priority = NlDnsName->Priority;
            DnsLogEntry->Weight = NlDnsName->Weight;
            DnsLogEntry->Port = NlDnsName->Port;

            //
            // Copy the variable length entries.
            //

            Where = (LPBYTE) (DnsLogEntry+1);
            strcpy( Where, NlDnsName->DnsRecordName );
            Where += DnsRecordNameSize;

            if ( NlDnsName->DnsHostName != NULL ) {
                strcpy( Where, NlDnsName->DnsHostName );
                Where += DnsHostNameSize;
            }
            Where = ROUND_UP_POINTER( Where, ALIGN_WORST );

            NlAssert( (ULONG)(Where-(LPBYTE)DnsLogEntry) == CurrentSize );
            NlAssert( (ULONG)(Where-(LPBYTE)DnsRecordBuffer) <= DnsRecordBufferSize );

            //
            // Move on to the next entry.
            //

            DnsLogEntry = (PNL_DNSLOG_ENTRY)Where;
        } else {
            NlPrintDns(( NL_DNS_MORE, NlDnsName,
                       "NlDnsWriteBinaryLog: not written to binary log file." ));
        }

    }

    //
    // Write the buffer to the file.
    //

    NetStatus = NlWriteBinaryLog(
                    NL_DNS_BINARY_LOG_FILE,
                    (LPBYTE) DnsRecordBuffer,
                    DnsRecordBufferSize );

    LeaveCriticalSection( &NlGlobalDnsCritSect );

    //
    // Write event log on error
    //

    if ( NetStatus != NO_ERROR ) {
        LPWSTR MsgStrings[2];

        MsgStrings[0] = NL_DNS_BINARY_LOG_FILE;
        MsgStrings[1] = (LPWSTR) UlongToPtr( NetStatus );

        NlpWriteEventlog (NELOG_NetlogonFailedFileCreate,
                          EVENTLOG_ERROR_TYPE,
                          (LPBYTE) &NetStatus,
                          sizeof(NetStatus),
                          MsgStrings,
                          2 | NETP_LAST_MESSAGE_IS_NETSTATUS );
    }

Cleanup:

    if ( DnsRecordBuffer != NULL ) {
        LocalFree( DnsRecordBuffer );
    }
    return;
}

PNL_DNS_NAME
NlDnsAllocateEntry(
    IN NL_DNS_NAME_TYPE NlDnsNameType,
    IN LPSTR DnsRecordName,
    IN ULONG Priority,
    IN ULONG Weight,
    IN ULONG Port,
    IN LPCSTR DnsHostName OPTIONAL,
    IN ULONG IpAddress,
    IN NL_DNS_NAME_STATE State
    )
/*++

Routine Description:

    Allocate and initialize a DNS name entry.

Arguments:

    Fields of the structure.

Return Value:

    Pointer to the allocated structure.

    NULL: not enough memory to allocate the structure

--*/
{
    PNL_DNS_NAME NlDnsName;
    ULONG Utf8DnsHostNameSize;
    ULONG DnsRecordNameSize;
    LPBYTE Where;

    //
    // Allocate a structure to represent this name.
    //

    if ( NlDnsARecord( NlDnsNameType ) ) {
        Utf8DnsHostNameSize = 0;
    } else {
        Utf8DnsHostNameSize = strlen(DnsHostName) + 1;
    }
    DnsRecordNameSize = strlen( DnsRecordName ) + 1;

    NlDnsName = LocalAlloc( LMEM_ZEROINIT, sizeof( NL_DNS_NAME ) +
                                            Utf8DnsHostNameSize +
                                            DnsRecordNameSize );

    if ( NlDnsName == NULL ) {
        return NULL;
    }

    Where = (LPBYTE)(NlDnsName+1);

    //
    // Initialize it and link it in.
    //

    NlDnsName->NlDnsNameType = NlDnsNameType;

    NlDnsName->DnsRecordName = Where;
    RtlCopyMemory( Where, DnsRecordName, DnsRecordNameSize );
    Where += DnsRecordNameSize;


    if ( NlDnsARecord( NlDnsNameType ) ) {
        NlDnsName->IpAddress = IpAddress;

    } else if ( NlDnsCnameRecord( NlDnsNameType ) ) {
        NlDnsName->DnsHostName = Where;
        RtlCopyMemory( Where, DnsHostName, Utf8DnsHostNameSize );
        // Where += Utf8DnsHostNameSize;

    } else {
        NlDnsName->Priority = Priority;
        NlDnsName->Port = Port;
        NlDnsName->Weight = Weight;

        NlDnsName->DnsHostName = Where;
        RtlCopyMemory( Where, DnsHostName, Utf8DnsHostNameSize );
        // Where += Utf8DnsHostNameSize;
    }

    NlDnsName->State = State;
    NlGlobalDnsListDirty = TRUE;

    EnterCriticalSection( &NlGlobalDnsCritSect );
    InsertTailList(&NlGlobalDnsList, &NlDnsName->Next);
    LeaveCriticalSection( &NlGlobalDnsCritSect );

    return NlDnsName;
}



VOID
NlDnsWriteLog(
    VOID
    )
/*++

Routine Description:

    Write the list of registered DNS names to
    %SystemRoot%\System32\Config\netlogon.dns.

Arguments:

    None

Return Value:

    None.

--*/
{
    PLIST_ENTRY ListEntry;
    PNL_DNS_NAME NlDnsName;

    NET_API_STATUS NetStatus;

    LPWSTR AllocatedBuffer = NULL;
    LPWSTR FileName;

    LPSTR DnsRecord;
    LPSTR DnsName;

    UINT WindowsDirectoryLength;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;


    EnterCriticalSection( &NlGlobalDnsCritSect );
    if ( !NlGlobalDnsListDirty ) {
        LeaveCriticalSection( &NlGlobalDnsCritSect );
        return;
    }

    //
    // Allocate a buffer for storage local to this procedure.
    //  (Don't put it on the stack since we don't want to commit a huge stack.)
    //

    AllocatedBuffer = LocalAlloc( 0, sizeof(WCHAR) * (MAX_PATH+1) +
                                        NL_MAX_DNS_LENGTH+1 +
                                        NL_DNS_RECORD_STRING_SIZE + 1 );

    if ( AllocatedBuffer == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    FileName = AllocatedBuffer;
    DnsName = (LPSTR)(&AllocatedBuffer[MAX_PATH+1]);
    DnsRecord = &DnsName[NL_MAX_DNS_LENGTH+1];


    //
    // Write the binary version of the log first.
    //
    NlDnsWriteBinaryLog();


    //
    // Build the name of the log file
    //

    WindowsDirectoryLength = GetSystemWindowsDirectoryW(
                                FileName,
                                sizeof(WCHAR) * (MAX_PATH+1) );

    if ( WindowsDirectoryLength == 0 ) {

        NetStatus = GetLastError();
        NlPrint(( NL_CRITICAL,
                  "NlDnsWriteLog: Unable to GetSystemWindowsDirectoryW (%ld)\n",
                  NetStatus ));
        goto Cleanup;
    }

    if ( WindowsDirectoryLength * sizeof(WCHAR) +
            sizeof(WCHAR) +
            sizeof(NL_DNS_LOG_FILE)
            >= sizeof(WCHAR) * MAX_PATH ) {

        NlPrint((NL_CRITICAL,
                 "NlDnsWriteLog: file name length is too long \n" ));
        goto Cleanup;

    }

    wcscat( FileName, NL_DNS_LOG_FILE );

    //
    // Create a file to write to.
    //  If it exists already then truncate it.
    //

    FileHandle = CreateFileW(
                        FileName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,        // allow backups and debugging
                        NULL,                   // Supply better security ??
                        CREATE_ALWAYS,          // Overwrites always
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );                 // No template

    if ( FileHandle == INVALID_HANDLE_VALUE) {
        LPWSTR MsgStrings[2];

        NetStatus = GetLastError();
        NlPrint((NL_CRITICAL,
                 "NlDnsWriteLog: %ws: Unable to create file: %ld \n",
                 FileName,
                 NetStatus));

        MsgStrings[0] = FileName;
        MsgStrings[1] = (LPWSTR) UlongToPtr( NetStatus );

        NlpWriteEventlog (NELOG_NetlogonFailedFileCreate,
                          EVENTLOG_ERROR_TYPE,
                          (LPBYTE) &NetStatus,
                          sizeof(NetStatus),
                          MsgStrings,
                          2 | NETP_LAST_MESSAGE_IS_NETSTATUS );
        goto Cleanup;
    }


    //
    // Loop through the list of DNS names writing each one to the log
    //

    for ( ListEntry = NlGlobalDnsList.Flink ;
          ListEntry != &NlGlobalDnsList ;
          ListEntry = ListEntry->Flink ) {

        ULONG DnsRecordLength;
        ULONG BytesWritten;

        //
        // If this entry really doesn't exist,
        //  comment it out.
        //

        NlDnsName = CONTAINING_RECORD( ListEntry, NL_DNS_NAME, Next );

        //
        // If this entry is marked for deletion,
        //  skip it (we must have successfully
        //  deregistered it and only need to
        //  delink and free this entry).
        //
        if ( NlDnsName->State == DeleteMe ) {
            continue;
        }

        DnsRecord[0] = '\0';
        switch (NlDnsName->State) {
        case RegisterMe:
        case Registered:
            break;

        default:
            NlPrint(( NL_CRITICAL,
                      "NlDnsWriteLog: %ld: Invalid state\n",
                      NlDnsName->State ));
            /* Drop through */
        case DeregisterMe:
        case DelayedDeregister:
            strcat( DnsRecord, "; " );
            break;
        }

        //
        // Create the text string to write.
        //
        NlDnsNameToStr( NlDnsName, DnsRecord );
        strcat( DnsRecord, NL_DNS_RR_EOL );

        //
        // Write the record to the file.
        //
        DnsRecordLength = strlen( DnsRecord );

        if ( !WriteFile( FileHandle,
                        DnsRecord,
                        DnsRecordLength,
                        &BytesWritten,
                        NULL ) ) {  // Not Overlapped

            NetStatus = GetLastError();

            NlPrint(( NL_CRITICAL,
                      "NlDnsWriteLog: %ws: Unable to WriteFile. %ld\n",
                      FileName,
                      NetStatus ));

            goto Cleanup;
        }

        if ( BytesWritten !=  DnsRecordLength) {
            NlPrint((NL_CRITICAL,
                    "NlDnsWriteLog: %ws: Write bad byte count %ld s.b. %ld\n",
                    FileName,
                    BytesWritten,
                    DnsRecordLength ));

            goto Cleanup;
        }

    }

    NlGlobalDnsListDirty = FALSE;

Cleanup:
    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
    }
    LeaveCriticalSection( &NlGlobalDnsCritSect );

    if ( AllocatedBuffer != NULL ) {
        LocalFree(AllocatedBuffer);
    }
    return;

}


BOOLEAN
NlDnsHasDnsServers(
    VOID
    )
/*++

Routine Description:

    Returns TRUE if this machine has one or more DNS servers configured.

    If FALSE, it is highly unlikely that DNS name resolution will work.

Arguments:

    None.

Return Value:

    TRUE: This machine has one or more DNS servers configured.


--*/
{
    BOOLEAN RetVal;
    NET_API_STATUS NetStatus;

    PDNS_RECORD DnsARecords = NULL;


    //
    // If there are no IP addresses,
    //  there are no DNS servers.
    //

    if ( NlGlobalWinsockPnpAddresses == NULL ) {

        RetVal = FALSE;

    } else {
        //
        // Try getting the A records for the DNS servers from DNS
        //
        // REVIEW: consider having DNS notify us when the DNS server state changes.
        //  Then we wouldn't have to bother DNS each time we need to know.
        //

        NetStatus = DnsQuery_UTF8(
                                "",     // Ask for addresses of the DNS servers
                                DNS_TYPE_A,
                                0,      // No special flags
                                NULL,   // No list of DNS servers
                                &DnsARecords,
                                NULL );

        if ( NetStatus != NO_ERROR ) {
            RetVal = FALSE;
        } else {
            RetVal = (DnsARecords != NULL);
        }

        if ( DnsARecords != NULL ) {
            DnsRecordListFree( DnsARecords, DnsFreeRecordListDeep );
        }
    }


    return RetVal;
}

BOOL
NlDnsCheckLastStatus(
    VOID
    )
/*++

Routine Description:

    Query the status of DNS updates for all records as they
    were registered/deregistered last time.

Arguments:

    None

Return Value:

    Returns TRUE if there was no error for last DNS updates
    for all records.  Otherwise returns FALSE.

--*/
{
    PLIST_ENTRY ListEntry;
    PNL_DNS_NAME NlDnsName;

    BOOL Result = TRUE;

    EnterCriticalSection( &NlGlobalDnsCritSect );
    for ( ListEntry = NlGlobalDnsList.Flink ;
          ListEntry != &NlGlobalDnsList ;
          ListEntry = ListEntry->Flink ) {

        NlDnsName = CONTAINING_RECORD( ListEntry, NL_DNS_NAME, Next );

        if ( NlDnsName->State != DeleteMe &&
             NlDnsName->NlDnsNameLastStatus != NO_ERROR ) {
            Result = FALSE;
            break;
        }
    }
    LeaveCriticalSection( &NlGlobalDnsCritSect );

    return Result;
}

VOID
NlDnsServerFailureOutputCheck(
    VOID
    )
/*++

Routine Description:

    Check if it's OK to write DNS server failure event logs

Arguments:

    None

Return Value:

    None.

--*/
{
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;

    //
    // If we have already determined on any previous
    //  start on this boot that we should write the
    //  event log, there is nothing we need to check.
    //

    if ( NlDnsWriteServerFailureEventLog ) {
        return;
    }

    //
    // Query the service controller to see
    //  whether the DNS service exists
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    //
    // If we couldn't open the SC,
    //  proceed with checking the timeout
    //

    if ( ScManagerHandle == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NlDnsServerFailureOutputCheck: OpenSCManager failed: 0x%lx\n",
                  GetLastError()));
    } else {
        ServiceHandle = OpenService(
                            ScManagerHandle,
                            L"DNS",
                            SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

        (VOID) CloseServiceHandle( ScManagerHandle );

        //
        // If DNS service does not exits locally,
        //  we should write DNS server failure errors
        //
        if ( ServiceHandle == NULL ) {
            if ( GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST ) {
                NlDnsWriteServerFailureEventLog = TRUE;
                return;
            }

        //
        // Service exists. Proceed with checking the timeout
        //
        } else {
            (VOID) CloseServiceHandle( ServiceHandle );
        }
    }

    //
    // If this is not the first time we have been started or
    //  the timeout has elapsed, it is time to write event errors
    //

    if ( NlDnsInitCount > 1 ||
         NetpDcElapsedTime(NlGlobalDnsStartTime) > NL_DNS_EVENTLOG_TIMEOUT ) {
        NlDnsWriteServerFailureEventLog = TRUE;
    }

    return;
}

NET_API_STATUS
NlDnsUpdate(
    IN PNL_DNS_NAME NlDnsName,
    IN BOOLEAN Register
    )
/*++

Routine Description:

    This routine does the actual call to DNS to register or deregister a name.

Arguments:

    NlDnsName - Name to register or deregister.

    Register - True to register the name.
        False to deregister the name.


Return Value:

    NO_ERROR: The name was registered or deregistered.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    DNS_RECORD DnsRecord;
    LPWSTR MsgStrings[5] = {NULL};
    ULONG DnsUpdateFlags = DNS_UPDATE_SECURITY_USE_DEFAULT;
    DNS_UPDATE_EXTRA_INFO DnsUpdateExtraInfo = {0};
    WCHAR DnsServerIpAddressString[NL_IP_ADDRESS_LENGTH+1];
    WCHAR RcodeString[] = L"<UNAVAILABLE>";
    WCHAR StatusString[] = L"<UNAVAILABLE>";

    static BOOL NetlogonNoDynamicDnsLogged = FALSE;

    //
    // Don't let the service controller think we've hung.
    //
    if ( !GiveInstallHints( FALSE ) ) {
        NetStatus = ERROR_DNS_NOT_CONFIGURED;
        goto Cleanup;
    }

    //
    // If dynamic DNS is manually disabled,
    //  warn the user to update DNS manually.
    //  But do not abuse the event log, write only once
    //
    if ( !NlGlobalParameters.UseDynamicDns ) {
        NetStatus = ERROR_DYNAMIC_DNS_NOT_SUPPORTED;

        if ( !NetlogonNoDynamicDnsLogged ) {
            NlpWriteEventlog( NELOG_NetlogonNoDynamicDnsManual,
                              EVENTLOG_WARNING_TYPE,
                              NULL,
                              0,
                              NULL,
                              0 );

            NetlogonNoDynamicDnsLogged = TRUE;
        }

        goto Cleanup;

    //
    // Otherwise, reset the boolean to account for the case when
    //  dynamic DNS being disabled gets enabled and then disabled again.
    //
    } else {
        NetlogonNoDynamicDnsLogged = FALSE;
    }

    //
    // Build the common parts of the RR.
    //

    RtlZeroMemory( &DnsRecord, sizeof(DnsRecord) );
    DnsRecord.pNext = NULL;
    DnsRecord.pName = (LPTSTR) NlDnsName->DnsRecordName;
    DnsRecord.dwTtl = NlGlobalParameters.DnsTtl;

    //
    // Build an A RR
    //
    if ( NlDnsARecord( NlDnsName->NlDnsNameType ) ) {
        DnsRecord.wType = DNS_TYPE_A;
        DnsRecord.wDataLength = sizeof( DNS_A_DATA );
        DnsRecord.Data.A.IpAddress = NlDnsName->IpAddress;

    //
    // Build a CNAME RR
    //
    } else if ( NlDnsCnameRecord( NlDnsName->NlDnsNameType ) ) {
        DnsRecord.wType = DNS_TYPE_CNAME;
        DnsRecord.wDataLength = sizeof( DNS_PTR_DATA );
        DnsRecord.Data.CNAME.pNameHost = (LPTSTR) NlDnsName->DnsHostName;

    //
    // Build a SRV RR
    //
    } else {
        DnsRecord.wType = DNS_TYPE_SRV;
        DnsRecord.wDataLength = sizeof( DNS_SRV_DATA );
        DnsRecord.Data.SRV.pNameTarget = (LPTSTR) NlDnsName->DnsHostName;
        DnsRecord.Data.SRV.wPriority = (WORD) NlDnsName->Priority;
        DnsRecord.Data.SRV.wWeight = (WORD) NlDnsName->Weight;
        DnsRecord.Data.SRV.wPort = (WORD) NlDnsName->Port;
    }

    //
    // Tell DNS to skip adapters where dynamic DNS updates
    // are disabled unless we are instructed otherwise
    //
    if ( !NlGlobalParameters.DnsUpdateOnAllAdapters ) {
        DnsUpdateFlags |= DNS_UPDATE_SKIP_NO_UPDATE_ADAPTERS;
    }

    //
    // If it's a CNAME record (used by the DS replication),
    //  tell DNS to register on a remote server (in addition
    //  to the local server if this machine is a DNS server)
    //  to avoid the following so called island problem (chicken
    //  & egg problem): Other DCs (i.e replication destinations)
    //  can't locate this replication source because their DNS database
    //  doesn't contain this CNAME record, and their DNS database doesn't
    //  contain this CNAME record because the the destination DCs can't
    //  locate the source and can't replicate this record.
    //
    if ( NlDnsCnameRecord(NlDnsName->NlDnsNameType) ) {
        DnsUpdateFlags |= DNS_UPDATE_REMOTE_SERVER;
    }

    //
    // Ask DNS to return the debug info
    //

    DnsUpdateExtraInfo.Id = DNS_UPDATE_INFO_ID_RESULT_INFO;

    //
    // Call DNS to do the update.
    //

    if ( Register ) {

        // According to RFC 2136 (and bug 173936) we need to replace the RRSet for
        // CNAME records to avoid an error if other records exist by the
        // same name.
        //
        // Note that the dynamic DNS RFC says that CNAME records ALWAYS overwrite the
        // existing single record (ignoring the DNS_UPDATE_SHARED).
        //
        // Also, replace the record if this is a PDC name (there should be only one PDC)
        //
        if ( NlDnsCnameRecord( NlDnsName->NlDnsNameType ) ||
             NlDnsPdcName( NlDnsName->NlDnsNameType ) ) {
            NetStatus = DnsReplaceRecordSetUTF8(
                            &DnsRecord,     // New record set
                            DnsUpdateFlags,
                            NULL,           // No context handle
                            NULL,           // DNS will choose the servers
                            &DnsUpdateExtraInfo );
        } else {
            NetStatus = DnsModifyRecordsInSet_UTF8(
                            &DnsRecord,     // Add record
                            NULL,           // No delete records
                            DnsUpdateFlags,
                            NULL,           // No context handle
                            NULL,           // DNS will choose the servers
                            &DnsUpdateExtraInfo );
        }
    } else {
        NetStatus = DnsModifyRecordsInSet_UTF8(
                        NULL,           // No add records
                        &DnsRecord,     // Delete this record
                        DnsUpdateFlags,
                        NULL,           // No context handle
                        NULL,           // DNS will choose the servers
                        &DnsUpdateExtraInfo );
    }

    //
    // Convert the status codes to ones we understand.
    //

    switch ( NetStatus ) {
    case NO_ERROR:
        NlDnsName->NlDnsNameLastStatus = NetStatus;
        break;

    case ERROR_TIMEOUT:     // DNS server isn't available
    case DNS_ERROR_RCODE_SERVER_FAILURE:  // Server failed

        //
        // Don't log an error specific to the DnsRecordName since all of them
        // are probably going to fail.
        //
        if ( NlDnsWriteServerFailureEventLog ) {
            LPWSTR LocalDnsDomainName = NULL;

            //
            // Remember the status of the failure
            //
            NlDnsName->NlDnsNameLastStatus = NetStatus;

            //
            // Get the name of the domain that this record belongs to.
            //
            LocalDnsDomainName = NlDnsNameToDomainName( NlDnsName );

            if ( LocalDnsDomainName != NULL ) {
                MsgStrings[0] = LocalDnsDomainName;

                NlpWriteEventlog( NELOG_NetlogonDynamicDnsServerFailure,
                                  EVENTLOG_WARNING_TYPE,
                                  (LPBYTE) &NetStatus,
                                  sizeof(NetStatus),
                                  MsgStrings,
                                  1 );

                NetApiBufferFree( LocalDnsDomainName );
            }
        }

        NetStatus = ERROR_DNS_NOT_AVAILABLE;
        break;

    case DNS_ERROR_NO_TCPIP:    // TCP/IP not configured
    case DNS_ERROR_NO_DNS_SERVERS:  // DNS not configured
    case WSAEAFNOSUPPORT:       // Winsock Address Family not supported ??

        NlDnsName->NlDnsNameLastStatus = NetStatus;

        MsgStrings[0] = (LPWSTR) UlongToPtr( NetStatus );

        // Don't log an error specific to the DnsRecordName since all of them
        // are probably going to fail.
        NlpWriteEventlog( NELOG_NetlogonDynamicDnsFailure,
                          EVENTLOG_WARNING_TYPE,
                          (LPBYTE) &NetStatus,
                          sizeof(NetStatus),
                          MsgStrings,
                          1 | NETP_LAST_MESSAGE_IS_NETSTATUS );

        NetStatus = ERROR_DNS_NOT_CONFIGURED;
        break;

    default:

        NlDnsName->NlDnsNameLastStatus = NetStatus;

        //
        // Get the IP address
        //

        if ( DnsUpdateExtraInfo.U.Results.ServerIp4 != 0 ) {
            NetpIpAddressToWStr( DnsUpdateExtraInfo.U.Results.ServerIp4,
                                 DnsServerIpAddressString );
        } else {
            wcscpy( DnsServerIpAddressString, L"<UNAVAILABLE>" );
        }

        //
        // Get the RCODE. Rcode is a WORD, but let's be careful to avoid
        //  buffer overrun problems if they change it to __int64 one day.
        //  Max DWORD in decimal is "4294967295" which is 11 characters
        //  long, so we've got enough storage for it in RcodeString.
        //

        if ( DnsUpdateExtraInfo.U.Results.Rcode <= MAXULONG ) {
            swprintf( RcodeString, L"%lu", DnsUpdateExtraInfo.U.Results.Rcode );
        }

        //
        // Get the status string.  Above comment applies here, too.
        //

        if ( DnsUpdateExtraInfo.U.Results.Status <= MAXULONG ) {
            swprintf( StatusString, L"%lu", DnsUpdateExtraInfo.U.Results.Status );
        }

        // Old server that doesn't understand dynamic DNS
        if ( NetStatus == DNS_ERROR_RCODE_NOT_IMPLEMENTED ) {
            MsgStrings[0] = DnsServerIpAddressString;
            MsgStrings[1] = RcodeString;
            MsgStrings[2] = StatusString;

            NlpWriteEventlog( NELOG_NetlogonNoDynamicDns,
                              EVENTLOG_WARNING_TYPE,
                              (LPBYTE) &DnsUpdateExtraInfo.U.Results.Rcode,
                              sizeof(DnsUpdateExtraInfo.U.Results.Rcode),
                              MsgStrings,
                              3 );

            NetStatus = ERROR_DYNAMIC_DNS_NOT_SUPPORTED;

        // All other errors
        } else {
            MsgStrings[0] = NlDnsNameToWStr( NlDnsName );

            if ( MsgStrings[0] != NULL ) {
                MsgStrings[1] = (LPWSTR) UlongToPtr( NetStatus );
                MsgStrings[2] = DnsServerIpAddressString;
                MsgStrings[3] = RcodeString;
                MsgStrings[4] = StatusString;

                NlpWriteEventlogEx(
                                  Register ?
                                    NELOG_NetlogonDynamicDnsRegisterFailure :
                                    NELOG_NetlogonDynamicDnsDeregisterFailure,
                                  EVENTLOG_ERROR_TYPE,
                                  (LPBYTE) &DnsUpdateExtraInfo.U.Results.Rcode,
                                  sizeof(DnsUpdateExtraInfo.U.Results.Rcode),
                                  MsgStrings,
                                  5 | NETP_LAST_MESSAGE_IS_NETSTATUS,
                                  1 );  // status message index

                NetApiBufferFree( MsgStrings[0] );
            }
        }
        break;

    }

Cleanup:

    //
    // Compute when we want to try this name again
    //

    NlQuerySystemTime( &NlDnsName->ScavengeTimer.StartTime );

    if ( NlDnsName->ScavengeTimer.Period == 0 ) {
        NlDnsName->ScavengeTimer.Period = min( ORIG_DNS_SCAVENGE_PERIOD, NlGlobalParameters.DnsRefreshIntervalPeriod );
    } else if ( NlDnsName->ScavengeTimer.Period < NlGlobalParameters.DnsRefreshIntervalPeriod / 2 ) {
        NlDnsName->ScavengeTimer.Period *= 2;
    } else {
        NlDnsName->ScavengeTimer.Period = NlGlobalParameters.DnsRefreshIntervalPeriod;
    }

    return NetStatus;
}


NET_API_STATUS
NlDnsRegisterOne(
    IN PNL_DNS_NAME NlDnsName,
    OUT NL_DNS_NAME_STATE *ResultingState
    )
/*++

Routine Description:

    This routine registers a SRV record for a particular name with DNS.

Arguments:

    NlDnsName - Structure describing name to register.

    ResultingState - The state of the entry after it has been scavenged.
        May be undefined if we couldn't scavenge the entry for some reason.

Return Value:

    NO_ERROR: The name was registered

--*/
{
    NET_API_STATUS NetStatus;

    //
    // Initialization
    //

    *ResultingState = DnsNameStateInvalid;

    //
    // Register the name with DNS
    //

    NetStatus = NlDnsUpdate( NlDnsName, TRUE );

    if ( NetStatus == NO_ERROR ) {

        //
        // Mark that the name is really registered.
        //

        *ResultingState = Registered;

        NlPrintDns(( NL_DNS_MORE, NlDnsName,
                  "NlDnsRegisterOne: registered (success)" ));

    //
    // If DNS is not configured on this machine,
    //  silently ignore the error.
    //
    } else if ( NetStatus == ERROR_DNS_NOT_CONFIGURED ) {
        NetStatus = NO_ERROR;

        NlPrintDns(( NL_DNS_MORE, NlDnsName,
                  "NlDnsRegisterOne: not registered (dns not configured)" ));

    //
    // If the DNS server cannot be reached at this time,
    //  simply don't mark the name as registered.  We'll register it later.
    //
    } else if ( NetStatus == ERROR_DNS_NOT_AVAILABLE ) {
        NetStatus = NO_ERROR;

        NlPrintDns(( NL_DNS_MORE, NlDnsName,
                  "NlDnsRegisterOne: not registered (dns server not available)" ));

    //
    // If Dynamic Dns is not supported,
    //  complain so the names can be added manually.
    //

    } else if ( NetStatus == ERROR_DYNAMIC_DNS_NOT_SUPPORTED ) {

        NlPrintDns(( NL_DNS_MORE, NlDnsName,
                  "NlDnsRegisterOne: not registered (dynamic dns not supported)" ));

        NetStatus = NO_ERROR;

    }

    return NetStatus;


}

NET_API_STATUS
NlDnsAddName(
    IN PDOMAIN_INFO DomainInfo,
    IN NL_DNS_NAME_TYPE NlDnsNameType,
    IN LPWSTR SiteName,
    IN ULONG IpAddress
    )
/*++

Routine Description:

    This routine adds a particular DNS name to the global list
    of all DNS names registed by this DC.

    Enter with NlGlobalDnsCritSect locked

Arguments:

    DomainInfo - Domain the name is to be registered for.

    NlDnsNameType - The specific type of name to be registered.

    SiteName - If NlDnsNameType is any of the *AtSite values,
        the site name of the site this name is registered for.

    IpAddress - If NlDnsNameType is NlDnsLdapIpAddress or NlDnsGcIpAddress,
        the IP address of the DC.

Return Value:

    NO_ERROR: The name was registered or queued to be registered.

--*/
{
    NET_API_STATUS NetStatus;

    CHAR DnsRecordName[NL_MAX_DNS_LENGTH+1];
    PNL_DNS_NAME NlDnsName = NULL;
    PNL_DNS_NAME FoundNlDnsName = NULL;
    ULONG Weight;
    ULONG Port;
    ULONG Priority;
    ULONG LoopCount;

    PLIST_ENTRY ListEntry;

    //
    // If there is no DNS domain name for this domain,
    //  silently return;
    //

    if ( DomainInfo->DomUtf8DnsDomainName == NULL ) {
        NlPrintDom(( NL_DNS, DomainInfo,
                  "NlDnsRegister: %ws: Domain has no DNS domain name (silently return)\n",
                  NlDcDnsNameTypeDesc[NlDnsNameType].Name ));
        return NO_ERROR;
    }

    //
    // If this is a SRV or CNAME record,
    //  require that there is a dns host name.
    //

    if ( (NlDnsSrvRecord( NlDnsNameType ) || NlDnsCnameRecord( NlDnsNameType ) ) &&
         DomainInfo->DomUtf8DnsHostName == NULL ) {
        NlPrintDom(( NL_DNS, DomainInfo,
                  "NlDnsRegister: %ws: Domain has no DNS host name (silently return)\n",
                  NlDcDnsNameTypeDesc[NlDnsNameType].Name ));
        return NO_ERROR;
    }



    //
    // Grab the parameters we're going to register.
    //

    Priority = NlGlobalParameters.LdapSrvPriority;
    Weight = NlGlobalParameters.LdapSrvWeight;

    if  ( NlDnsGcName( NlDnsNameType ) ) {
        Port = NlGlobalParameters.LdapGcSrvPort;
    } else if ( NlDnsKpwdRecord( NlDnsNameType )) {
        Port = 464;
    } else if ( NlDnsKdcRecord( NlDnsNameType ) ) {
        Port = NlGlobalParameters.KdcSrvPort;
    } else {
        Port = NlGlobalParameters.LdapSrvPort;
    }

    //
    // Register the record for the name and for the name alias, if any
    //

    for ( LoopCount = 0; LoopCount < 2; LoopCount++ ) {
        NlDnsName = NULL;
        FoundNlDnsName = NULL;

        //
        // Build the name of this DNS record.
        //
        //  On the first loop iteration, build the active name.
        //  On the second loop iteration, build the name alias, if any.
        //
        NetStatus = NlDnsBuildName( DomainInfo,
                                    NlDnsNameType,
                                    SiteName,
                                    (LoopCount == 0) ?
                                        FALSE :  // active name
                                        TRUE,    // name alias
                                    DnsRecordName );

        if ( NetStatus != NO_ERROR ) {

            //
            // If the domain has no DNS domain name,
            //  simply bypass the name registration forever.
            //
            if ( NetStatus == ERROR_NO_SUCH_DOMAIN ) {
                NlPrintDom(( NL_CRITICAL, DomainInfo,
                          "NlDnsAddName: %ws: NlDnsBuildName indicates something is missing and this DNS name cannot be built (ignored)\n",
                          NlDcDnsNameTypeDesc[NlDnsNameType].Name ));
                return NO_ERROR;
            } else {
                NlPrintDom(( NL_CRITICAL, DomainInfo,
                          "NlDnsAddName: %ws: Cannot NlDnsBuildName %ld\n",
                          NlDcDnsNameTypeDesc[NlDnsNameType].Name,
                          NetStatus ));
                return NetStatus;
            }
        }

        //
        // If this name doesn't exist, skip it
        //
        if ( *DnsRecordName == '\0' ) {
            continue;
        }

        //
        // Loop through the list of DNS names finding any that match the one we're
        //  about to register.
        //
        for ( ListEntry = NlGlobalDnsList.Flink ;
              ListEntry != &NlGlobalDnsList ;
              ListEntry = ListEntry->Flink ) {


            NlDnsName = CONTAINING_RECORD( ListEntry, NL_DNS_NAME, Next );

            //
            // If this entry is marked for deletion,
            //  skip it
            //
            if ( NlDnsName->State == DeleteMe ) {
                continue;
            }

            //
            // The names will only be equal if the name types are equal,
            //  the domains are compatible (equal or not specified),
            //  and the DnsRecordName is identical.
            //
            // This first test sees if the record "identifies" the same record.
            //
            //
            if ( NlDnsName->NlDnsNameType == NlDnsNameType &&
                 (NlDnsName->DomainInfo == DomainInfo ||
                    NlDnsName->DomainInfo == NULL ) &&
                 NlDnsName->IpAddress == IpAddress &&
                 NlEqualDnsNameUtf8( DnsRecordName, NlDnsName->DnsRecordName ) ) {

                BOOLEAN Identical;
                BOOLEAN DeleteIt;

                //
                // Assume the records are identical.
                //
                // This second test sees if any of the "data" portion of the record
                // changes.
                //
                // The Dynamic DNS RFC says that the Ttl field isn't used to
                // distiguish the record.  So, ignore it here knowing we'll
                // simply re-register with the new value if the Ttl has changed.
                //

                DeleteIt = FALSE;
                Identical = TRUE;

                // Compare A records
                if ( NlDnsARecord( NlDnsNameType ) ) {
                    // Nothing else to compare

                // Compare CNAME records
                } else if ( NlDnsCnameRecord( NlDnsNameType ) ) {

                    //
                    // The Dynamic DNS RFC says that the host name part of the
                    // CNAME record isn't used for comparison purposes.  There
                    // can only be one record for a particular name.
                    // So, if the host name is different, simply ditch this entry and
                    // allocate a new one with the right host name.
                    //
                    if ( !NlEqualDnsNameUtf8( DomainInfo->DomUtf8DnsHostName, NlDnsName->DnsHostName )) {
                        DeleteIt = TRUE;

                        NlPrintDns(( NL_DNS_MORE, NlDnsName,
                                   "NlDnsAddName: CNAME Host not equal. %s %s",
                                   DomainInfo->DomUtf8DnsHostName,
                                   NlDnsName->DnsHostName ));
                    }

                // Compare SRV records
                } else {
                    if ( NlDnsName->Priority != Priority ) {
                        Identical = FALSE;

                        NlPrintDns(( NL_DNS_MORE, NlDnsName,
                                   "NlDnsAddName: Priority not equal. %ld %ld",
                                   NlDnsName->Priority,
                                   Priority ));
                    } else if ( NlDnsName->Port != Port ) {
                        Identical = FALSE;

                        NlPrintDns(( NL_DNS_MORE, NlDnsName,
                                   "NlDnsAddName: Port not equal. %ld %ld",
                                   NlDnsName->Port,
                                   Port ));
                    } else if ( NlDnsName->Weight != Weight ) {
                        Identical = FALSE;

                        NlPrintDns(( NL_DNS_MORE, NlDnsName,
                                   "NlDnsAddName: Weight not equal. %ld %ld",
                                   NlDnsName->Weight,
                                   Weight ));
                    } else if ( !NlEqualDnsNameUtf8( DomainInfo->DomUtf8DnsHostName, NlDnsName->DnsHostName )) {
                        Identical = FALSE;

                        NlPrintDns(( NL_DNS_MORE, NlDnsName,
                                   "NlDnsAddName: Host not equal. %s %s",
                                   DomainInfo->DomUtf8DnsHostName,
                                   NlDnsName->DnsHostName ));
                    }
                }


                //
                // If the entry should simply be deleted,
                //  do so now.
                //

                if ( DeleteIt ) {

                    NlDnsSetState( NlDnsName, DeleteMe );

                    NlPrintDns(( NL_CRITICAL, NlDnsName,
                                   "NlDnsAddName: Annoying entry found (recovering)" ));
                //
                // If this is the exact record,
                //  simply mark it for registration.
                //

                } else if ( Identical ) {

                    //
                    // If this is the second such entry we've found,
                    //  this is an internal error.
                    //  But recover by deleting the entry.
                    //

                    if ( FoundNlDnsName != NULL ) {

                        NlDnsSetState( NlDnsName, DeleteMe );

                        NlPrintDns(( NL_CRITICAL, NlDnsName,
                                   "NlDnsAddName: Duplicate entry found (recovering)" ));
                    } else {

                        if ( NlDnsName->State != Registered ) {
                            NlDnsSetState( NlDnsName, RegisterMe );
                        }

                        //
                        // DomainInfo might be NULL if this was a record marked for
                        //  deletion.
                        //
                        NlDnsName->DomainInfo = DomainInfo;

                        //
                        // Cooperate with NlDnsAddDomainRecords and tell it that
                        // this entry can be kept.
                        //
                        NlDnsName->Flags &= ~NL_DNS_REGISTER_DOMAIN;

                        FoundNlDnsName = NlDnsName;
                    }

                //
                // If this record isn't exact,
                //  deregister the previous value.
                //
                // Don't scavenge yet.  We'll pick this up when the scavenger gets
                // around to running.
                //

                } else {
                    NlDnsSetState( NlDnsName, DeregisterMe );

                    NlPrintDns(( NL_CRITICAL, NlDnsName,
                               "NlDnsAddName: Similar entry found and marked for deregistration" ));
                }

            }
        }

        //
        // If the name was found,
        //  use it.

        if ( FoundNlDnsName != NULL ) {
            NlDnsName = FoundNlDnsName;
            NlPrintDns(( NL_DNS_MORE, NlDnsName,
                         "NlDnsAddName: Name already on the list" ));
        //
        // If not,
        //  allocate the structure now.
        //

        } else {

            NlDnsName = NlDnsAllocateEntry(
                                NlDnsNameType,
                                DnsRecordName,
                                Priority,
                                Weight,
                                Port,
                                DomainInfo->DomUtf8DnsHostName,
                                IpAddress,
                                RegisterMe );

            if ( NlDnsName == NULL ) {
                NlPrintDom(( NL_CRITICAL, DomainInfo,
                          "NlDnsRegister: %ws: Cannot allocate DnsName structure\n",
                          NlDcDnsNameTypeDesc[NlDnsNameType].Name ));
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            NlPrintDns(( NL_DNS, NlDnsName,
                         "NlDnsAddName: New name added to the list" ));

            NlDnsName->DomainInfo = DomainInfo;
        }
    }

    return NO_ERROR;
}


NET_API_STATUS
NlDnsDeregisterOne(
    IN PNL_DNS_NAME NlDnsName,
    OUT NL_DNS_NAME_STATE *ResultingState
    )
/*++

Routine Description:

    This routine deregisters a the SRV record for a particular name with DNS.

Arguments:

    NlDnsName - Structure describing name to deregister.

    ResultingState - The state of the entry after it has been scavenged.
        May be undefined if we couldn't scavenge the entry for some reason.

Return Value:

    NO_ERROR: The name was deregistered
    Otherwise, the name was not deregistered.  The operation should be retried.

--*/
{
    NET_API_STATUS NetStatus;

    //
    // Initialization
    //

    *ResultingState = DnsNameStateInvalid;

    //
    // Deregister the name with DNS
    //

    NetStatus = NlDnsUpdate( NlDnsName, FALSE );

    //
    // If the name has been removed for all practical purposes,
    //  Indicate this routine was successful.
    //
    if ( NetStatus == NO_ERROR ||
         NetStatus == ERROR_DYNAMIC_DNS_NOT_SUPPORTED ) {

        NlPrintDns(( NL_DNS, NlDnsName,
                  "NlDnsDeregisterOne: being deregistered (success) %ld",
                  NetStatus ));

        *ResultingState = DeleteMe;
        NetStatus = NO_ERROR;

    //
    // If the DNS server cannot be reached at this time,
    //      we'll deregister it later.
    //

    } else if ( NetStatus == ERROR_DNS_NOT_AVAILABLE ) {

        NlPrintDns(( NL_DNS, NlDnsName,
                  "NlDnsDeregisterOne: being deregistered (DNS server not available)" ));

    //
    // If the DNS server is not configured,
    //      we'll deregister it later.
    //
    // DNS was available when we registered the name.  So this is probably
    // a temporary condition (such as we temporarily don't have an IP address).
    //

    } else if ( NetStatus == ERROR_DNS_NOT_CONFIGURED ) {

        //
        // If it's never really been registered,
        //  ditch the name
        //
        if ( NlDnsName->Flags & NL_DNS_REGISTERED_ONCE ) {

            NlPrintDns(( NL_DNS, NlDnsName,
                      "NlDnsDeregisterOne: being deregistered (DNS not configured) (Try later)" ));
        } else {

            NlPrintDns(( NL_DNS, NlDnsName,
                      "NlDnsDeregisterOne: being deregistered (DNS not configured) (Ditch it)" ));
            *ResultingState = DeleteMe;
            NetStatus = NO_ERROR;
        }

    }

    //
    // If we successfully deregistered,
    //  reset the first deregistration failure time stamp
    //

    EnterCriticalSection( &NlGlobalDnsCritSect );

    if ( NetStatus == NO_ERROR ) {
        NlDnsName->FirstDeregFailureTime.QuadPart = 0;

    //
    // If we failed to deregister and we postponed it until later,
    //  check if it's time to give up on this entry
    //

    } else if ( *ResultingState != DeleteMe ) {
        ULONG LocalDnsFailedDeregisterTimeout;
        BOOLEAN FirstFailure = FALSE;

        //
        // Set the first deregistration failure time stamp
        //
        if ( NlDnsName->FirstDeregFailureTime.QuadPart == 0 ) {
            NlQuerySystemTime( &NlDnsName->FirstDeregFailureTime );
            FirstFailure = TRUE;
        }

        //
        // Get the reg value for failed deregistration timeout (in seconds)
        //  and convert it to milliseconds
        //
        LocalDnsFailedDeregisterTimeout = NlGlobalParameters.DnsFailedDeregisterTimeout;

        // if the value converted into milliseconds fits into a ULONG, use it
        if ( LocalDnsFailedDeregisterTimeout <= MAXULONG/1000 ) {
            LocalDnsFailedDeregisterTimeout *= 1000;     // convert into milliseconds

        // otherwise, use the max ULONG
        } else {
            LocalDnsFailedDeregisterTimeout = MAXULONG;  // infinity
        }

        //
        // Determine if it's time to give up on this entry
        //
        // If timeout is zero we are to delete immediately
        //   after the first failure
        // Otherwise, if this is not the first failure,
        //   check the timestamp
        //
        if ( LocalDnsFailedDeregisterTimeout == 0 ||
             (!FirstFailure &&
              NetpLogonTimeHasElapsed(NlDnsName->FirstDeregFailureTime,
                                      LocalDnsFailedDeregisterTimeout)) ) {

            NlPrintDns(( NL_DNS, NlDnsName,
                         "NlDnsDeregisterOne: Ditch it due to time expire" ));
            *ResultingState = DeleteMe;
            NetStatus = NO_ERROR;
        }
    }

    LeaveCriticalSection( &NlGlobalDnsCritSect );

    return NetStatus;
}

VOID
NlDnsScavengeOne(
    IN PNL_DNS_NAME NlDnsName,
    OUT NL_DNS_NAME_STATE *ResultingState
    )
/*++

Routine Description:

    Register or Deregister any DNS names that need it.

Arguments:

    NlDnsName - Name to scavenge.  This structure will be marked for deletion
        if it is no longer needed.

    ResultingState - The state of the entry after it has been scavenged.
        May be undefined if we couldn't scavenge the entry for some reason.

Return Value:

    None.

--*/
{
    LARGE_INTEGER TimeNow;
    ULONG Timeout;

    //
    // Only scavenge this entry if its timer has expired
    //

    Timeout = (DWORD) -1;
    NlQuerySystemTime( &TimeNow );
    if ( TimerExpired( &NlDnsName->ScavengeTimer, &TimeNow, &Timeout)) {

        //
        // If the name needs to be deregistered,
        //  do it now.
        //

        switch ( NlDnsName->State ) {
        case DeregisterMe:

            NlDnsDeregisterOne( NlDnsName, ResultingState );
            break;


        //
        // If the name needs to be registered,
        //  do it now.
        //

        case RegisterMe:
        case Registered:

            NlDnsRegisterOne( NlDnsName, ResultingState );
            break;
        }
    }
}

VOID
NlDnsScavengeWorker(
    IN LPVOID ScavengeRecordsParam
    )
/*++

Routine Description:

    Scavenge through the list of all DNS records and
    register/deregisteer each record as apprropriate.

Arguments:

    ScavengeRecordsParam - not used

Return Value:

    None.

--*/
{
    ULONG LoopCount = 0;
    ULONG StartTime = 0;
    ULONG CycleStartTime = 0;
    ULONG Timeout = MAXULONG;
    ULONG Flags = 0;
    LARGE_INTEGER TimeNow;

    BOOL ReasonLogged = FALSE;
    BOOL ScavengeAbortedOnShutdown = FALSE;

    PLIST_ENTRY ListEntry = NULL;
    PNL_DNS_NAME NlDnsName = NULL;
    NL_DNS_NAME_STATE ResultingState = DnsNameStateInvalid;

    EnterCriticalSection( &NlGlobalDnsCritSect );

    while ( NlGlobalDnsScavengeNeeded ) {
        NlGlobalDnsScavengeNeeded = FALSE;

        CycleStartTime = GetTickCount();

        //
        // Guard against infinite loop processing
        //
        LoopCount ++;
        if ( LoopCount > NL_DNS_MAX_SCAVENGE_RESTART ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsScavengeWorker: Avoid ReStarting DNS scavenge after too many times %ld\n",
                      LoopCount ));
            break;
        }

        //
        // If required,
        //  ensure the DomainName<1B> names are properly registered.
        //  Doing this only once is enough.
        //
        // Avoid having a crit sect locked while doing network I/O
        //
        if ( NlGlobalDnsScavengeFlags & NL_DNS_FIX_BROWSER_NAMES ) {
            NlGlobalDnsScavengeFlags &= ~NL_DNS_FIX_BROWSER_NAMES;
            LeaveCriticalSection( &NlGlobalDnsCritSect );
            (VOID) NlEnumerateDomains( FALSE, NlBrowserFixAllNames, NULL );
            EnterCriticalSection( &NlGlobalDnsCritSect );
        }

        //
        // Restart the scavenge if some other thread indicated so
        //  and we still can do another loop.  If we have no loop
        //  left, just press on and finish this loop -- we will
        //  remember this fact and retry scavenging in 5 minutes.
        //
        if ( NlGlobalDnsScavengeNeeded &&
             LoopCount < NL_DNS_MAX_SCAVENGE_RESTART ) {
            NlPrint(( NL_DNS,
                      "NlDnsScavengeWorker: ReStarting scavenge %ld (after adding <1B> names)\n",
                      LoopCount ));
            continue;
        }

        //
        // Refresh records for all domains/NDNCs in the global list
        //  as needed.
        //
        // Avoid having a crit sect locked while doing network I/O.
        //
        if ( NlGlobalDnsScavengeFlags & NL_DNS_REFRESH_DOMAIN_RECORDS ||
             NlGlobalDnsScavengeFlags & NL_DNS_FORCE_REFRESH_DOMAIN_RECORDS ) {
            Flags = NlGlobalDnsScavengeFlags;
            LeaveCriticalSection( &NlGlobalDnsCritSect );
            NlEnumerateDomains( TRUE, NlDnsAddDomainRecordsWithSiteRefresh, &Flags );
            EnterCriticalSection( &NlGlobalDnsCritSect );
        }

        //
        // Restart the scavenge if some other thread indicated so
        //  and we still can do another loop.  If we have no loop
        //  left, just press on and finish this loop -- we will
        //  remember this fact and retry scavenging in 5 minutes.
        //
        if ( NlGlobalDnsScavengeNeeded &&
             LoopCount < NL_DNS_MAX_SCAVENGE_RESTART ) {
            NlPrint(( NL_DNS,
                      "NlDnsScavengeWorker: ReStarting scavenge %ld (after adding domain records)\n",
                      LoopCount ));
            continue;
        }

        //
        // Now that the global list has been updated,
        //  register/deregister each record as appropriate
        //

        for ( ListEntry = NlGlobalDnsList.Flink ;
              ListEntry != &NlGlobalDnsList ;
              ListEntry = ListEntry->Flink ) {

            NlDnsName = CONTAINING_RECORD( ListEntry, NL_DNS_NAME, Next );

            //
            // If this entry is marked for deletion,
            //  skip it -- we will remove it below
            //

            if ( NlDnsName->State == DeleteMe ) {
                continue;
            }

            //
            // Abort the scavenge if we are terminating
            //  unless we are configured otherwise
            //

            if ( NlGlobalTerminate ) {
                ULONG TotalElapsedTime = NetpDcElapsedTime( CycleStartTime );

                //
                // Continue if we are in the process of demotion
                //
                if ( NlGlobalDcDemotionInProgress ) {
                    if ( !ReasonLogged ) {
                        NlPrint(( NL_DNS,
                                  "NlDnsScavengeWorker: Continue DNS scavenge on demotion\n" ));
                        ReasonLogged = TRUE;
                    }

                //
                // Continue if we are configured to deregister on shutdown
                //
                } else if ( !NlGlobalParameters.AvoidDnsDeregOnShutdown ) {
                    if ( !ReasonLogged ) {
                        NlPrint(( NL_DNS,
                                  "NlDnsScavengeWorker: Continue DNS scavenge on shutdown (config)\n" ));
                        ReasonLogged = TRUE;
                    }

                //
                // Otherwise, abort the scavenge cycle
                //
                } else {
                    NlPrint(( NL_DNS_MORE,
                              "NlDnsScavengeWorker: Avoiding DNS scavenge on shutdown\n" ));
                    break;
                }

                //
                // If we have spent all the time alloted for DNS deregistartions
                //  on shutdown, abort the scavenge cycle as we can't wait.
                //  Don't be tempted to measure the time spent on the entire
                //  routine rather than this cycle because previous cycles
                //  (if any) might not be due to a shutdown deregistration cleanup.
                //
                if ( TotalElapsedTime > NL_DNS_SHUTDOWN_THRESHOLD ) {
                    ScavengeAbortedOnShutdown = TRUE;

                    NlPrint(( NL_CRITICAL,
                         "NlDnsScavengeWorker: Abort DNS scavenge on shutdown because DNS is too slow %lu\n",
                         TotalElapsedTime ));
                    break;
                }

                //
                // We continue the deregistration scavenge on shutdown.
                //  Set this entry state to deregister it.
                //
                NlDnsSetState( NlDnsName, DeregisterMe );
            }

            //
            // Scavenge this entry
            //
            // Avoid having crit sect locked while doing network IO
            //

            NlPrintDns(( NL_DNS_MORE, NlDnsName, "NlDnsScavengeWorker: scavenging name" ));
            StartTime = GetTickCount();

            LeaveCriticalSection( &NlGlobalDnsCritSect );
            ResultingState = DnsNameStateInvalid;
            NlDnsScavengeOne( NlDnsName, &ResultingState );
            EnterCriticalSection( &NlGlobalDnsCritSect );

            //
            // Report if we've spent a long time on this DNS record
            //

            if ( NetpDcElapsedTime(StartTime) > NL_DNS_ONE_THRESHOLD ) {
                NlPrintDns(( NL_CRITICAL, NlDnsName,
                             "NlDnsScavengeWorker: DNS is really slow: %ld",
                             NetpDcElapsedTime(StartTime) ));
            }

            //
            // Restart the scavenge if some other thread indicated so
            //  and we still can do another loop.  If we have no loop
            //  left, just press on and finish this loop -- we will
            //  remember this fact and retry scavenging in 5 minutes.
            //

            if ( NlGlobalDnsScavengeNeeded &&
                 LoopCount < NL_DNS_MAX_SCAVENGE_RESTART ) {
                NlPrint(( NL_DNS,
                          "NlDnsScavengeWorker: ReStarting scavenge %ld of DNS names\n",
                          LoopCount ));
                break;
            }

            //
            // Set the state of this entry if it's known.
            //
            // Note that we set the state only if the record list was
            //  intact while we release the crit sect doing the network
            //  I/O. We do this to avoid reseting the new state to
            //  preserve the updated knowledge about what needs to be
            //  done with this record on the next cycle (which is just
            //  about to start).
            //

            if ( ResultingState != DnsNameStateInvalid ) {
                NlDnsSetState( NlDnsName, ResultingState );
            }
        }
    }

    //
    // Do a pass through all records to:
    //
    //  * Delete names which we successfully deregistered above
    //  * Determine when we should scavenge next
    //

    NlQuerySystemTime( &TimeNow );

    for ( ListEntry = NlGlobalDnsList.Flink ;
          ListEntry != &NlGlobalDnsList ;
          ) {

        NlDnsName = CONTAINING_RECORD( ListEntry, NL_DNS_NAME, Next );
        ListEntry = ListEntry->Flink;

        //
        // Remove this entry if it has been deregistered successfully
        //
        if ( NlDnsName->State == DeleteMe ) {
            RemoveEntryList( &NlDnsName->Next );
            LocalFree( NlDnsName );
            continue;
        }

        //
        // Determine when this entry should be scavenged next
        //
        // Note that the only way the timer can expire here is when it took
        //  exceptionally long to update through all names so that by the
        //  end of the update cycle it's time to restart the cycle again.
        //
        if ( TimerExpired(&NlDnsName->ScavengeTimer, &TimeNow, &Timeout) ) {
            Timeout = 0;
        }
    }

    //
    // Wait a couple of extra seconds. There are multiple DNS entries. They
    // won't all expire at the same time.  They typically expire within
    // a couple of seconds of one another.  Doing this will increase the
    // likelihood that all DNS names will get scavenged in a single
    // scavenge cycle.
    //

    if ( Timeout < (MAXULONG - 2000) ) {
        Timeout += 2000;
    } else {
        Timeout = MAXULONG;
    }

    //
    // Check whether the auto site coverage scavenging needs to happen earlier.
    //
    // If it does, we will do site coverage refresh (as part of DNS scavenging)
    //  earlier but we will not update records in DNS (because records will
    //  not timeout) unless site coverages changes.
    //

    if ( NlGlobalParameters.AutoSiteCoverage &&
         NlGlobalParameters.SiteCoverageRefreshInterval*1000 < Timeout ) {
        Timeout = NlGlobalParameters.SiteCoverageRefreshInterval * 1000;
    }

    //
    // Now reset the scavenger timer unless we are terminating
    //

    if ( !NlGlobalTerminate ) {
        NlGlobalDnsScavengerTimer.StartTime.QuadPart = TimeNow.QuadPart;

        //
        // If we had to abort the scavenge due to too many concurrent
        //  requests, backoff for 5 minutes
        //
        if ( NlGlobalDnsScavengeNeeded ) {
            NlGlobalDnsScavengerTimer.Period = ORIG_DNS_SCAVENGE_PERIOD;
        } else {
            NlGlobalDnsScavengerTimer.Period = Timeout;
        }
        NlPrint(( NL_DNS,
                  "NlDnsScavengeWorker: Set DNS scavenger to run in %ld minutes (%ld).\n",
                  (NlGlobalDnsScavengerTimer.Period+59999)/60000,
                  NlGlobalDnsScavengerTimer.Period ));

        if ( !SetEvent(NlGlobalTimerEvent) ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsScavengeWorker: SetEvent failed %ld\n",
                      GetLastError() ));
        }
    }

    //
    // In all cases, flush any changes to disk
    //

    NlDnsWriteLog();

    //
    // If we had to abort the scavenge on demotion,
    //  log the event log to that effect. Do this
    //  after flushing the changes to the log file
    //  as the file is referenced in the event message.
    //

    if ( NlGlobalDcDemotionInProgress && ScavengeAbortedOnShutdown ) {
        NlpWriteEventlog( NELOG_NetlogonDnsDeregAborted,
                          EVENTLOG_ERROR_TYPE,
                          NULL,
                          0,
                          NULL,
                          0 );
    }

    //
    // If we had to abort the scavenge due to too many concurrent
    //  requests, preserve the flags so that we redo what's needed
    //  in 5 minutes. Set the bit to avoid forced DNS scavenge within
    //  these 5 minutes.
    //

    if ( NlGlobalDnsScavengeNeeded ) {
        NlGlobalDnsScavengeFlags |= NL_DNS_AVOID_FORCED_SCAVENGE;
        NlPrint(( NL_CRITICAL,
                  "NlDnsScavengeWorker: Preserving the scavenge flags for future re-do: %ld\n",
                  NlGlobalDnsScavengeFlags ));
    } else {
        NlGlobalDnsScavengeFlags = 0;
    }

    //
    // Indicate that we are done
    //

    NlGlobalDnsScavengingInProgress = FALSE;
    LeaveCriticalSection( &NlGlobalDnsCritSect );

    UNREFERENCED_PARAMETER( ScavengeRecordsParam );
}

VOID
NlDnsScavenge(
    IN BOOL NormalScavenge,
    IN BOOL RefreshDomainRecords,
    IN BOOL ForceRefreshDomainRecords,
    IN BOOL ForceReregister
    )
/*++

Routine Description:

    Register or Deregister any DNS (and <1B>) names that need it.

Arguments:

    NormalScavenge  -- Indicates whether this is a normal periodic
        scavenge vs. scavenge forced by some external event like PnP
        event. For normal scavenge, we will do periodic browser <1B>
        name refresh.

    RefreshDomainRecords -- Indicates whether domain records should be
        refreshed in the global list before doing the DNS updates

    ForceRefreshDomainRecords -- Indicates whether the refresh is forced,
        that is whether we should refresh even if there is no site coverage
        change. Ignored if RefreshDomainRecords is FALSE.

    ForceReregister -- TRUE if records that have been already
        registered should be re-registered even if their scavenge
        timer hasn't expired yet.

Return Value:

    None.

--*/
{
    PLIST_ENTRY ListEntry;
    PNL_DNS_NAME NlDnsName;

    //
    // Nothing to register on a workstation
    //

    if ( NlGlobalMemberWorkstation ) {
        return;
    }

    NlPrint(( NL_DNS,
              "NlDnsScavenge: Starting DNS scavenge with: %s %s %s %s\n",
              (NormalScavenge ? "Normal" : "Force"),
              (RefreshDomainRecords ? "RefreshDomainRecords" : "0"),
              (ForceRefreshDomainRecords ? "ForceRefreshDomainRecords" : "0"),
              (ForceReregister ? "ForceReregister" : "0") ));

    //
    // If Netlogon has been started for a long time,
    //  deregister any names that have been registered in
    //  a previous incarnation, but have not been registered in this incarnation.
    //
    // We wait a while to do these deregistrations because:
    //
    // * Some of the registrations done by netlogon are a function of multiple
    //   hosted domains.  The initialization of such domains are done asynchronously.
    // * Some of the registrations done by netlogon are done as a function of
    //   other processes telling us that a name needs registration.  (e.g., the
    //   GC name is registered only after the DS starts completely.)
    //
    // So, it is better to wait a long time to deregister these old registrations
    // than to risk deregistering them then immediately re-registering them.
    //

    EnterCriticalSection( &NlGlobalDnsCritSect );

    if ( !NlGlobalDnsInitialCleanupDone &&
         NetpDcElapsedTime(NlGlobalDnsStartTime) > NL_DNS_INITIAL_CLEANUP_TIME ) {

        NlPrint(( NL_DNS,
                  "NlDnsScavenge: Mark all delayed deregistrations for deregistration.\n" ));

        //
        // Mark all delayed deregistrations to deregister now.
        //
        for ( ListEntry = NlGlobalDnsList.Flink ;
              ListEntry != &NlGlobalDnsList ;
              ListEntry = ListEntry->Flink ) {


            NlDnsName = CONTAINING_RECORD( ListEntry, NL_DNS_NAME, Next );

            if ( NlDnsName->State == DelayedDeregister ) {
                NlDnsSetState( NlDnsName, DeregisterMe );
            }

        }

        NlGlobalDnsInitialCleanupDone = TRUE;
    }


    //
    // Check if it's time to log "DNS server failure" errors.
    //  We do this check before the series of updates so that
    //  we don't miss an error for any given name we register.
    //

    NlDnsServerFailureOutputCheck();

    //
    // Indicate that a new scavenge cycle is needed
    //

    NlGlobalDnsScavengeNeeded = TRUE;

    //
    // Set the scavenge flags. Don't clear any flags as there might
    //  already be an outstanding scavenge running that requires
    //  a bigger work.  This way we will do all the work required
    //  in the last of the oustanding scavenging cycles. The scavenge
    //  worker will clear all the bits when it's done.
    //
    // Indicate whether domain records should be refreshed in
    //  the global list before doing the DNS updates
    //

    if ( RefreshDomainRecords ) {

        //
        // Indicate whether the refresh if forced even if there is
        //  no site coverage change
        //
        if ( ForceRefreshDomainRecords ) {
            NlGlobalDnsScavengeFlags |= NL_DNS_FORCE_REFRESH_DOMAIN_RECORDS;
        } else {
            NlGlobalDnsScavengeFlags |= NL_DNS_REFRESH_DOMAIN_RECORDS;
        }
    }

    //
    // Indicate wether we should re-register all those records which
    //  have already been registered in the previous cycle even if
    //  their timers have not expired yet.
    //

    if ( ForceReregister ) {
        NlGlobalDnsScavengeFlags |= NL_DNS_FORCE_RECORD_REREGISTER;
    }

    //
    // The periodic DNS scavenger has good backoff characteristics so
    //  take this opportunity to ensure the DomainName<1B> names are
    //  properly registered.
    //

    if ( NormalScavenge ) {
        NlGlobalDnsScavengeFlags |= NL_DNS_FIX_BROWSER_NAMES;
    }

    //
    // Start a worker thread if it's not already running
    //

    if ( !NlGlobalDnsScavengingInProgress ) {

        //
        // Avoid starting the worker if this scavenge is forced by some external
        //  event while we are backing off due to high scavenging load.
        //  Preserve all the flags we set above so that we do all the work
        //  requested later when normal scavenging kicks off that should
        //  happen within 5 minutes.
        //
        if ( !NormalScavenge &&
             (NlGlobalDnsScavengeFlags & NL_DNS_AVOID_FORCED_SCAVENGE) != 0 ) {

            NlPrint(( NL_CRITICAL, "NlDnsScavengeRecords: avoid forced scavenge due to high load\n" ));

        } else {
            if ( NlQueueWorkItem( &NlGlobalDnsScavengeWorkItem, TRUE, FALSE ) ) {
                NlGlobalDnsScavengingInProgress = TRUE;
            } else {
                NlPrint(( NL_CRITICAL, "NlDnsScavengeRecords: couldn't queue DNS scavenging\n" ));
            }
        }
    }

    LeaveCriticalSection( &NlGlobalDnsCritSect );
}

VOID
NlDnsForceScavenge(
    IN BOOL RefreshDomainRecords,
    IN BOOL ForceReregister
    )
/*++

Routine Description:

    Thing wrapper around NlDnsScavenge to pass proper
    arguments for induced scavenging

Arguments:

    RefreshDomainRecords -- If TRUE, domain records will be
        refreshed and refreshed with force (even if site coverege
        doesn't change) before doing DNS updates

    ForceReregister -- TRUE if records that have been already
        registered should be re-registered even if their scavenge
        timer hasn't expired yet.

Return Value:

    None.

--*/
{
    BOOL LocalRefreshDomainRecords = FALSE;
    BOOL ForceRefreshDomainRecords = FALSE;

    //
    // Indicate that we should refresh domain records
    //  in the global list with force unless we are
    //  instructed otherwise
    //

    if ( RefreshDomainRecords ) {
        LocalRefreshDomainRecords = TRUE;
        ForceRefreshDomainRecords = TRUE;
    }

    //
    // Do the work
    //

    NlDnsScavenge( FALSE,  // not a normal periodic scavenge
                   LocalRefreshDomainRecords,
                   ForceRefreshDomainRecords,
                   ForceReregister );
}

NET_API_STATUS
NlDnsNtdsDsaDeleteOne(
    IN NL_DNS_NAME_TYPE NlDnsNameType,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN LPCSTR DnsDomainName,
    IN LPCSTR DnsHostName OPTIONAL
    )
/*++

Routine Description:

    This routine adds a single DNS entry associated with a particular
    NtDsDsa object and/or a particular DNS host name to the global
    list of all DNS records registered/deregistered by this DC. The
    entry is marked for deregistration.

Arguments:

    NlDnsNameType - The specific type of name.

    DomainGuid - Guid to append to DNS name.
        For NlDnsDcByGuid, this is the GUID of the domain being located.
        For NlDnsDsaCname, this is the GUID of the DSA being located.

    SiteName - Name of the site to append to DNS name.
        If NlDnsNameType is any of the *AtSite values,
        this is the name of the site the DC is in.

    DnsDomainName - Specifies the DNS domain for the name.

        For NlDnsDcByGuid or any of the GC names,
            this is the DNS domain name of the domain at the root of the tree of
            domains.
        For all others, this is the DNS domain for the DC.

    DnsHostName - Specifies the DnsHostName for the record.

        For SRV and CNAME records, this name must be specified
        For A records, this name is ignored

Return Value:

    NO_ERROR: The name was returned;

    ERROR_INVALID_DOMAINNAME: Domain's name is too long. Additional labels
        cannot be concatenated.

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory to complete the operation.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_DNS_NAME NlDnsName;
    ULONG Port;
    ULONG DefaultPort;
    char DnsRecordName[NL_MAX_DNS_LENGTH+1];

    //
    // Build the name of the record to delete
    //

    NetStatus = NetpDcBuildDnsName( NlDnsNameType,
                                   DomainGuid,
                                   SiteName,
                                   DnsDomainName,
                                   DnsRecordName );

    if ( NetStatus != NO_ERROR ) {
        return NetStatus;
    }


    //
    // Compute the port number for this SRV record
    //

    if  ( NlDnsGcName( NlDnsNameType ) ) {
        Port = NlGlobalParameters.LdapGcSrvPort;
        DefaultPort = DEFAULT_LDAPGCSRVPORT;
    } else if ( NlDnsKpwdRecord( NlDnsNameType )) {
        Port = 464;
        DefaultPort = 464;
    } else if ( NlDnsKdcRecord( NlDnsNameType )) {
        Port = NlGlobalParameters.KdcSrvPort;
        DefaultPort = DEFAULT_KDCSRVPORT;
    } else {
        Port = NlGlobalParameters.LdapSrvPort;
        DefaultPort = DEFAULT_LDAPSRVPORT;
    }

    //
    // Queue the entry for deletion.
    //
    EnterCriticalSection( &NlGlobalDnsCritSect );
    NlDnsName = NlDnsAllocateEntry( NlDnsNameType,
                                    DnsRecordName,
                                    NlGlobalParameters.LdapSrvPriority,  // Priority
                                    NlGlobalParameters.LdapSrvWeight,    // Weight
                                    Port,  // Port
                                    DnsHostName,
                                    0,  // IpAddress
                                    DeregisterMe );

    if ( NlDnsName == NULL ) {
        LeaveCriticalSection( &NlGlobalDnsCritSect );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Persist this entry so we try to delete it after a reboot
    //
    NlDnsName->Flags |= NL_DNS_REGISTERED_ONCE;
    NlPrintDns(( NL_DNS, NlDnsName,
              "NlDnsNtdsDsaDelete: Name queued for deletion" ));

    //
    // If any of the parameters configured on this machine aren't the default values,
    //  try the defaults, too
    //

    if ( NlGlobalParameters.LdapSrvPriority != DEFAULT_LDAPSRVPRIORITY ||
         NlGlobalParameters.LdapSrvWeight != DEFAULT_LDAPSRVWEIGHT ||
         Port != DefaultPort ) {

        //
        // Queue the entry for deletion.
        //
        NlDnsName = NlDnsAllocateEntry( NlDnsNameType,
                                        DnsRecordName,
                                        DEFAULT_LDAPSRVPRIORITY,  // Priority
                                        DEFAULT_LDAPSRVWEIGHT,    // Weight
                                        DefaultPort,  // Port
                                        DnsHostName,
                                        0,  // IpAddress
                                        DeregisterMe );

        if ( NlDnsName == NULL ) {
            LeaveCriticalSection( &NlGlobalDnsCritSect );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Persist this entry so we try to delete it after a reboot
        //
        NlDnsName->Flags |= NL_DNS_REGISTERED_ONCE;
        NlPrintDns(( NL_DNS, NlDnsName,
                  "NlDnsNtdsDsaDelete: Name queued for deletion" ));
    }

    LeaveCriticalSection( &NlGlobalDnsCritSect );

    return NO_ERROR;
}

NTSTATUS
NlDnsNtdsDsaDeletion (
    IN LPWSTR DnsDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN GUID *DsaGuid OPTIONAL,
    IN LPWSTR DnsHostName
    )
/*++

Routine Description:

    This function deletes all DNS entries associated with a particular
    NtDsDsa object and/or a particular DNS host name.

    This routine does NOT delete A records registered by the DC.  We have
    no way of finding out the IP addresses of the long gone DC.

Arguments:

    DnsDomainName - DNS domain name of the domain the DC was in.
        This need not be a domain hosted by this DC.
        If NULL, it is implied to be the DnsHostName with the leftmost label
            removed.

    DomainGuid - Domain Guid of the domain specified by DnsDomainName
        If NULL, GUID specific names will not be removed.

    DsaGuid - GUID of the NtdsDsa object that is being deleted.

    DnsHostName - DNS host name of the DC whose NTDS-DSA object is being deleted.

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    LPSTR Utf8DnsDomainName = NULL;
    LPSTR Utf8DnsHostName = NULL;
    PLSAP_SITE_INFO SiteInformation = NULL;

    ULONG i;
    ULONG NameIndex;

    //
    // Validate passed parameters
    //

    if ( DnsHostName == NULL ||
         !NetpDcValidDnsDomain(DnsHostName) ) {
        NetStatus = ERROR_INVALID_NAME;
        goto Cleanup;
    }

    //
    // If DNS domain name isn't specified,
    //  infer it from the DnsHostName
    //

    if ( DnsDomainName == NULL ) {
        DnsDomainName = wcschr( DnsHostName, L'.' );

        if ( DnsDomainName == NULL ) {
            NetStatus = ERROR_INVALID_NAME;
            goto Cleanup;
        }

        DnsDomainName ++;
        if ( *DnsDomainName == '\0' ) {
            NetStatus = ERROR_INVALID_NAME;
            goto Cleanup;
        }
    } else if ( !NetpDcValidDnsDomain(DnsDomainName) ) {
        NetStatus = ERROR_INVALID_NAME;
        goto Cleanup;
    }

    //
    // Initialization
    //

    Utf8DnsDomainName = NetpAllocUtf8StrFromWStr( DnsDomainName );

    if ( Utf8DnsDomainName == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Utf8DnsHostName = NetpAllocUtf8StrFromWStr( DnsHostName );

    if ( Utf8DnsHostName == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Enumerate the sites supported by this forest so we can delete
    //  the records that are named by site.
    //
    // We need to delete the records for all sites since we don't know which
    //  sites are "covered" by the removed DC.
    //

    Status = LsaIQuerySiteInfo( &SiteInformation );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint(( NL_CRITICAL,
                  "NlDnsNtdsDsaDeletion: Cannot LsaIQuerySiteInfo 0x%lx\n", Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Loop through the list of names Netlogon understands deleting them all
    //

    for ( NameIndex = 0;
          NameIndex < NL_DNS_NAME_TYPE_COUNT;
          NameIndex++) {
        LPSTR LocalDomainName;
        GUID *LocalGuid;

        //
        // If the name is obsolete,
        //  ignore it.
        //

        if ( NlDcDnsNameTypeDesc[NameIndex].DsGetDcFlags == 0 ) {
            continue;
        }

        //
        // We don't know how to delete the A records since we don't know the IP address.
        //
        // We'd ask DNS what the IP address is, but the name might not exist.  If it does
        //  we don't know whether the IP address has already been assign to another DC.
        //

        if ( NlDnsARecord( NameIndex ) ) {
            continue;
        }

        //
        // Use either the DomainName or ForestName
        //

        if ( NlDcDnsNameTypeDesc[NameIndex].IsForestRelative ) {
            LocalDomainName = NlGlobalUtf8DnsForestName;
        } else {
            LocalDomainName = Utf8DnsDomainName;
        }

        //
        // Figure out which GUID to use for this name.
        //

        if ( NlDnsCnameRecord( NameIndex ) ) {

            //
            // If we don't know the Dsa GUID,
            //  ignore names that need it.
            //
            if ( DsaGuid == NULL || IsEqualGUID( DsaGuid, &NlGlobalZeroGuid) ) {
                continue;
            }

            LocalGuid = DsaGuid;

        } else if ( NlDnsDcGuid( NameIndex )) {

            //
            // If we don't know the Domain GUID,
            //  ignore names that need it.
            //
            if ( DomainGuid == NULL || IsEqualGUID( DomainGuid, &NlGlobalZeroGuid) ) {
                continue;
            }

            LocalGuid = DomainGuid;

        } else {
            LocalGuid = NULL;
        }

        //
        // If the name isn't site specific,
        //  just delete the one name.
        //

        if ( !NlDcDnsNameTypeDesc[NameIndex].IsSiteSpecific ) {


            NetStatus = NlDnsNtdsDsaDeleteOne( (NL_DNS_NAME_TYPE) NameIndex,
                                               LocalGuid,
                                               NULL,       // No site name
                                               LocalDomainName,
                                               Utf8DnsHostName );

            if ( NetStatus != NO_ERROR ) {
                goto Cleanup;
            }

        //
        // If the name is site specific,
        //  we need to delete the records for all sites since we don't know which
        //  sites are "covered" by the removed DC.
        //
        } else {

            //
            // Loop deleting entries for each Site
            //

            for ( i=0; i<SiteInformation->SiteCount; i++ ) {

                NetStatus = NlDnsNtdsDsaDeleteOne( (NL_DNS_NAME_TYPE) NameIndex,
                                                   LocalGuid,
                                                   SiteInformation->Sites[i].SiteName.Buffer,
                                                   LocalDomainName,
                                                   Utf8DnsHostName );

                if ( NetStatus != NO_ERROR ) {
                    goto Cleanup;
                }
            }
        }


    }

    //
    // Now that the entries are on the list,
    //  scavenge through the list and delete
    //  the entries (in a worker thread)
    //

    NlDnsForceScavenge( FALSE,   // don't refresh domain records
                        FALSE ); // don't force re-register

    NetStatus = NO_ERROR;

    //
    // Clean up locally used resources.
    //
Cleanup:

    if ( Utf8DnsDomainName != NULL ) {
        NetpMemoryFree( Utf8DnsDomainName );
    }
    if ( Utf8DnsHostName != NULL ) {
        NetpMemoryFree( Utf8DnsHostName );
    }
    if ( SiteInformation != NULL ) {
        LsaIFree_LSAP_SITE_INFO( SiteInformation );
    }

    //
    // Flush the log
    //

    NlDnsWriteLog();

    return NetStatus;
}

NET_API_STATUS
NlDnsAddDomainRecordsWithSiteRefresh(
    IN PDOMAIN_INFO DomainInfo,
    IN PULONG Flags
    )
/*++

Routine Description:

    This routine refreshes site coverage for a particular domain and then
    it adds all of the DNS names that are supposed to be registered for
    that domain to the global list of all records. It marks for deregister
    any name that should not be registered for that domain.

    ?? This routine should be called when ANY of the information changing the
    registration changes.  For instance, if the domain name changes, simply
    call this routine.

Arguments:

    DomainInfo - Domain the names are to be registered for.

    Flags - Indicates the actions to take:

        NL_DNS_FORCED_SCAVENGE - Register even if site coverage doesn't change
        NL_DNS_FORCE_REREGISTER - Force re-registration of all previously
            registered records

Return Value:

    NO_ERROR: All names could be registered

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    NTSTATUS Status = STATUS_SUCCESS;

    WCHAR CapturedSiteName[NL_MAX_DNS_LABEL_LENGTH+1];
    PISM_CONNECTIVITY SiteConnect = NULL;
    ULONG ThisSiteIndex = 0xFFFFFFFF;

    PSOCKET_ADDRESS SocketAddresses = NULL;
    ULONG SocketAddressCount = 0;
    ULONG BufferSize;
    PNL_SITE_ENTRY SiteEntry = NULL;
    LPWSTR IpAddressList = NULL;
    ULONG Index;

    BOOLEAN SiteCoverageChanged = FALSE;
    HANDLE DsHandle = NULL;

    //
    // This operation is meaningless on a workstation
    //

    if ( NlGlobalMemberWorkstation ) {
        goto Cleanup;
    }

    //
    // Capture the name of the site this machine is in.
    //

    if ( !NlCaptureSiteName( CapturedSiteName ) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                     "NlDnsAddDomainRecordsWithSiteRefresh: Cannot NlCaptureSiteName.\n" ));
        goto Cleanup;
    }

    //
    // If we are to automatically determine site coverage,
    //  get the site link costs.
    //

    if ( NlGlobalParameters.AutoSiteCoverage ) {

        if ( !NlSitesGetIsmConnect(CapturedSiteName,
                                   &SiteConnect,
                                   &ThisSiteIndex) ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                         "NlDnsAddDomainRecordsWithSiteRefresh: NlSitesGetIsmConnect failed\n" ));
        }
    }

    //
    // Ensure that ntdsapi.dll is loaded
    //

    Status = NlLoadNtDsApiDll();

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlDnsAddDomainRecordsWithSiteRefresh: Cannot NlLoadNtDsApiDll 0x%lx.\n",
                  Status ));
        DsHandle = NULL;
    } else {

        //
        // Bind to the DS
        //
        NetStatus = (*NlGlobalpDsBindW)(
                // L"localhost",
                DomainInfo->DomUnicodeComputerNameString.Buffer,
                NULL,
                &DsHandle );

        if ( NetStatus != NO_ERROR ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "NlDnsAddDomainRecordsWithSiteRefresh: Cannot DsBindW %ld.\n",
                      NetStatus ));
            DsHandle = NULL;
        }
    }

    //
    // Update the site coverage for each role we play in
    // this forest/domain/NDNC
    //

    if ( DomainInfo->DomFlags & DOM_REAL_DOMAIN ) {
        NlSitesUpdateSiteCoverageForRole( DomainInfo,
                                          DOM_FOREST,
                                          DsHandle,
                                          SiteConnect,
                                          CapturedSiteName,
                                          ThisSiteIndex,
                                          &SiteCoverageChanged );

        NlSitesUpdateSiteCoverageForRole( DomainInfo,
                                          DOM_REAL_DOMAIN,
                                          DsHandle,
                                          SiteConnect,
                                          CapturedSiteName,
                                          ThisSiteIndex,
                                          &SiteCoverageChanged );
    }

    if ( DomainInfo->DomFlags & DOM_NON_DOMAIN_NC ) {
        NlSitesUpdateSiteCoverageForRole( DomainInfo,
                                          DOM_NON_DOMAIN_NC,
                                          DsHandle,
                                          SiteConnect,
                                          CapturedSiteName,
                                          ThisSiteIndex,
                                          &SiteCoverageChanged );
    }

    //
    // If the site coverage changed or we are forced to refresh
    //  domain records even if site coverage hasn't changed,
    //  do so
    //

    if ( ((*Flags) & NL_DNS_FORCE_REFRESH_DOMAIN_RECORDS) != 0 ||
         SiteCoverageChanged ) {

        NetStatus = NlDnsAddDomainRecords( DomainInfo, *Flags );
        if ( NetStatus != NO_ERROR ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "NlDnsAddDomainRecordsWithSiteRefresh: Cannot NlDnsAddDomainRecords 0x%lx.\n",
                      NetStatus ));
        }
    }

    //
    // Inform the user if none of our IP addresses maps to our site.
    //  Do it only once (for the primary domain processing).
    //  ?? When we support multihosting, our site will be different depending
    //  on the forest of a particular domain we host.  So we will need to do
    //  this check for each site.
    //

    if ( DomainInfo->DomFlags & DOM_PRIMARY_DOMAIN ) {
        SocketAddressCount = NlTransportGetIpAddresses(
                                    0,  // No special header,
                                    FALSE,  // Return pointers
                                    &SocketAddresses,
                                    &BufferSize );

        for ( Index = 0; Index < SocketAddressCount; Index++ ) {
            SiteEntry = NlFindSiteEntryBySockAddr( SocketAddresses[Index].lpSockaddr );

            if ( SiteEntry != NULL ) {
                 if ( _wcsicmp(SiteEntry->SiteName, CapturedSiteName) == 0 ) {
                     break;
                 }
                 NlDerefSiteEntry( SiteEntry );
                 SiteEntry = NULL;
            }
        }

        //
        // Log the error
        //
        if ( SiteEntry == NULL  && SocketAddressCount != 0 ) {
            LPWSTR MsgStrings[2];

            //
            // Form the list of IP addresses for event log output
            //
            IpAddressList = LocalAlloc( LMEM_ZEROINIT,
                    SocketAddressCount * (NL_SOCK_ADDRESS_LENGTH+1) * sizeof(WCHAR) );

            if ( IpAddressList == NULL ) {
                goto Cleanup;
            }

            //
            // Loop adding all addresses to the list
            //
            for ( Index = 0; Index < SocketAddressCount; Index++ ) {
                WCHAR IpAddressString[NL_SOCK_ADDRESS_LENGTH+1] = {0};

                NetStatus = NetpSockAddrToWStr(
                                SocketAddresses[Index].lpSockaddr,
                                SocketAddresses[Index].iSockaddrLength,
                                IpAddressString );

                if ( NetStatus != NO_ERROR ) {
                    goto Cleanup;
                }

                //
                // If this is not the first address on the list,
                //  separate addresses by space
                //
                if ( *IpAddressList != UNICODE_NULL ) {
                    wcscat( IpAddressList, L" " );
                }

                //
                // Add this address to the list
                //
                wcscat( IpAddressList, IpAddressString );
            }

            //
            // Now write the event
            //
            MsgStrings[0] = CapturedSiteName;
            MsgStrings[1] = IpAddressList;

            NlpWriteEventlog( NELOG_NetlogonNoAddressToSiteMapping,
                              EVENTLOG_WARNING_TYPE,
                              NULL,
                              0,
                              MsgStrings,
                              2 );
        }
    }

Cleanup:

    if ( DsHandle != NULL ) {
        (*NlGlobalpDsUnBindW)( &DsHandle );
    }
    if ( SiteConnect != NULL ) {
        I_ISMFree( SiteConnect );
    }
    if ( SocketAddresses != NULL ) {
        LocalFree( SocketAddresses );
    }
    if ( IpAddressList != NULL ) {
        LocalFree( IpAddressList );
    }
    if ( SiteEntry != NULL ) {
        NlDerefSiteEntry( SiteEntry );
    }

    return NO_ERROR;
}


NET_API_STATUS
NlDnsAddDomainRecords(
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG Flags
    )
/*++

Routine Description:

    This routine adds all of the DNS names that are supposed to be
    registered for a particular domain to the global list of all records.
    It marks for deregister any name that should not be registered.

    ?? This routine should be called when ANY of the information changing the
    registration changes.  For instance, if the domain name changes, simply
    call this routine.

Arguments:

    DomainInfo - Domain the names are to be registered for.

    Flags - Indicates the actions to take:

        NL_DNS_FORCE_REREGISTER - Force re-registration of all previously
            registered records

Return Value:

    NO_ERROR: All names could be registered

--*/
{
    NET_API_STATUS NetStatus;
    NET_API_STATUS SaveNetStatus = NO_ERROR;
    PNL_DNS_NAME NlDnsName = NULL;

    PLIST_ENTRY ListEntry;
    ULONG DomainFlags;

    ULONG i;
    ULONG SocketAddressCount;
    PSOCKET_ADDRESS SocketAddresses = NULL;
    ULONG BufferSize;
    PNL_SITE_NAME_ARRAY DcSiteNames = NULL;
    PNL_SITE_NAME_ARRAY GcSiteNames = NULL;

    ULONG SiteIndex;
    ULONG NameIndex;

    //
    // Get the list of IP Addresses for this machine.
    //

    SocketAddressCount = NlTransportGetIpAddresses(
                                0,  // No special header,
                                FALSE,  // Return pointers
                                &SocketAddresses,
                                &BufferSize );


    //
    // Loop marking all of the current entries for this domain.
    //

    EnterCriticalSection( &NlGlobalDnsCritSect );

    for ( ListEntry = NlGlobalDnsList.Flink ;
          ListEntry != &NlGlobalDnsList ;
          ListEntry = ListEntry->Flink ) {

        //
        // If entry is for this domain,
        //  mark it.
        //

        NlDnsName = CONTAINING_RECORD( ListEntry, NL_DNS_NAME, Next );
        if ( NlDnsName->DomainInfo == DomainInfo ) {
            NlDnsName->Flags |= NL_DNS_REGISTER_DOMAIN;

            //
            // If we are to force the re-registration of this record,
            //  mark the name as RegisterMe to force us to try again
            //
            if ( (Flags & NL_DNS_FORCE_RECORD_REREGISTER) != 0 ) {
                if ( NlDnsName->State == Registered ) {
                    NlDnsSetState ( NlDnsName, RegisterMe );
                }
            }
        }
    }

    //
    // If the hosted domain still exists,
    //  register all of the appropriate names.
    //

    if ( (DomainInfo->DomFlags & DOM_DELETED) == 0 ) {

        //
        // Determine which names should be registered now.
        //
        DomainFlags = NlGetDomainFlags( DomainInfo );

        // Always register the DS names regardless of whether the DS is
        //  actually running.
        //
        // We actually think this will always be a no-op except during
        // installation and when booted to use the registry version of SAM.
        //

        if ( DomainInfo->DomFlags & DOM_REAL_DOMAIN ) {
            DomainFlags |= DS_DS_FLAG;
        }

        //
        // Get the list of Sites covered by this DC/NDNC
        //
        NetStatus = NlSitesGetCloseSites( DomainInfo,
                                          DOM_REAL_DOMAIN | DOM_NON_DOMAIN_NC,
                                          &DcSiteNames );

        if ( NetStatus != NERR_Success ) {
            NlPrintDom((NL_INIT, DomainInfo,
                     "Couldn't NlSitesGetCloseSites %ld 0x%lx.\n",
                     NetStatus, NetStatus ));
            SaveNetStatus = NetStatus;
        }

        //
        // Get the list of Sites covered by this GC
        //
        NetStatus = NlSitesGetCloseSites( DomainInfo,
                                          DOM_FOREST,
                                          &GcSiteNames );

        if ( NetStatus != NERR_Success ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                     "Couldn't NlSitesGetCloseSites (GcAtSite) %ld 0x%lx.\n",
                     NetStatus, NetStatus ));
            SaveNetStatus = NetStatus;
        }



        //
        // Loop through each name seeing if it needs to be registered.
        //

        for ( NameIndex = 0;
              NameIndex < NL_DNS_NAME_TYPE_COUNT;
              NameIndex++) {


            //
            // If this DC is playing the role described by this name,
            //  register the name.
            //

            if ( DomainFlags & NlDcDnsNameTypeDesc[NameIndex].DsGetDcFlags ) {
                BOOL SkipName = FALSE;

                //
                // Don't register this name if we are to avoid it
                //

                EnterCriticalSection( &NlGlobalParametersCritSect );
                if ( NlGlobalParameters.DnsAvoidRegisterRecords != NULL ) {
                    LPTSTR_ARRAY TStrArray;

                    TStrArray = NlGlobalParameters.DnsAvoidRegisterRecords;
                    while ( !NetpIsTStrArrayEmpty(TStrArray) ) {

                        if ( _wcsicmp(TStrArray,
                                NlDcDnsNameTypeDesc[NameIndex].Name + NL_DNS_NAME_PREFIX_LENGTH) == 0 ) {
                            SkipName = TRUE;
                            break;
                        }

                        TStrArray = NetpNextTStrArrayEntry(TStrArray);
                    }
                }
                LeaveCriticalSection( &NlGlobalParametersCritSect );

                if ( SkipName ) {
                    NlPrintDom(( NL_DNS, DomainInfo,
                                 "NlDnsAddDomainRecords: Skipping name %ws (per registry)\n",
                                 NlDcDnsNameTypeDesc[NameIndex].Name ));
                    continue;
                }

                //
                // Do other checks since we have to support the old
                //  ways of disabling DNS registrations
                //
                // If the name registers an A record,
                //  register it for each IP address.
                //

                if ( NlDnsARecord( NameIndex) ) {

                    //
                    // If we aren't supposed to register A records,
                    //  Just skip this name
                    //

                    if ( !NlGlobalParameters.RegisterDnsARecords ) {
                        continue;
                    }

                    //
                    // Register the domain name for each IP address of the machine.
                    //

                    for ( i=0; i<SocketAddressCount; i++ ) {
                        ULONG IpAddress;

                        //
                        // Require AF_INET for now
                        //
                        if ( SocketAddresses[i].lpSockaddr->sa_family != AF_INET ) {
                            continue;
                        }

                        IpAddress =
                            ((PSOCKADDR_IN) SocketAddresses[i].lpSockaddr)->sin_addr.S_un.S_addr;

                        NetStatus = NlDnsAddName( DomainInfo,
                                                       (NL_DNS_NAME_TYPE)NameIndex,
                                                       NULL,
                                                       IpAddress );

                        if ( NetStatus != NERR_Success ) {
#if  NETLOGONDBG
                            CHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1];
                            NetpIpAddressToStr( IpAddress, IpAddressString );
                            NlPrintDom((NL_CRITICAL, DomainInfo,
                                     "Couldn't NlDnsAddName (%ws %s) %ld 0x%lx.\n",
                                     NlDcDnsNameTypeDesc[NameIndex].Name,
                                     IpAddressString,
                                     NetStatus, NetStatus ));

#endif // NETLOGONDBG
                            SaveNetStatus = NetStatus;
                        }

                    }

                //
                // If the name isn't site specific,
                //  just register the single name.
                //

                } else if ( !NlDcDnsNameTypeDesc[NameIndex].IsSiteSpecific ) {


                    NetStatus = NlDnsAddName( DomainInfo,
                                                   (NL_DNS_NAME_TYPE)NameIndex,
                                                   NULL,
                                                   0 );

                    if ( NetStatus != NERR_Success ) {
                        NlPrintDom((NL_CRITICAL, DomainInfo,
                                   "Couldn't NlDnsAddName (%ws) %ld 0x%lx.\n",
                                   NlDcDnsNameTypeDesc[NameIndex].Name,
                                   NetStatus, NetStatus ));
                        SaveNetStatus = NetStatus;
                    }

                //
                // If the name is site specific,
                //  register the name for each covered site.
                //

                } else {

                    PUNICODE_STRING SiteNames;
                    ULONG SiteCount;

                    //
                    // Use a different site coverage list depending on the role.
                    //
                    if ( NlDnsGcName( NameIndex) ) {
                        if ( GcSiteNames != NULL ) {
                            SiteNames = GcSiteNames->SiteNames;
                            SiteCount = GcSiteNames->EntryCount;
                        } else {
                            SiteNames = NULL;
                            SiteCount = 0;
                        }
                    //
                    // Use the domain/NDNC specific sites
                    //
                    } else {
                        // ???: Should KDCs have their own site coverage list?
                        if ( DcSiteNames != NULL ) {
                            SiteNames = DcSiteNames->SiteNames;
                            SiteCount = DcSiteNames->EntryCount;
                        } else {
                            SiteNames = NULL;
                            SiteCount = 0;
                        }
                    }

                    //
                    // Loop through the list of sites.
                    //

                    for ( SiteIndex=0; SiteIndex < SiteCount; SiteIndex ++) {

                        NetStatus = NlDnsAddName( DomainInfo,
                                                       (NL_DNS_NAME_TYPE)NameIndex,
                                                       SiteNames[SiteIndex].Buffer,
                                                       0 );

                        if ( NetStatus != NERR_Success ) {
                            NlPrintDom((NL_INIT, DomainInfo,
                                       "Couldn't NlDnsAddName (%ws %ws) %ld 0x%lx.\n",
                                       NlDcDnsNameTypeDesc[NameIndex].Name,
                                       SiteNames[SiteIndex].Buffer,
                                       NetStatus, NetStatus ));
                            SaveNetStatus = NetStatus;
                        }

                    }
                }
            }
        }
    }


    //
    // Do the second pass through records for this domain
    //  and process those which need our attention.
    //
    //  * Any names that are still marked should be deleted.
    //  * If domain is being deleted, indicate that the record
    //      doesn't belong to any domain anymore.
    //

    for ( ListEntry = NlGlobalDnsList.Flink ;
          ListEntry != &NlGlobalDnsList ;
          ListEntry = ListEntry->Flink ) {

        NlDnsName = CONTAINING_RECORD( ListEntry, NL_DNS_NAME, Next );

        //
        // If the entry is marked for deletion,
        //  skip it
        //
        if ( NlDnsName->State == DeleteMe ) {
            continue;
        }

        if ( NlDnsName->DomainInfo == DomainInfo ) {

            //
            // If entry is still marked, deregister it
            //
            if ( (NlDnsName->Flags & NL_DNS_REGISTER_DOMAIN) != 0 ) {
                NlPrintDns(( NL_DNS, NlDnsName,
                             "NlDnsAddDomainRecords: marked for deregister" ));
                NlDnsSetState( NlDnsName, DeregisterMe );
            }

            //
            // If the domain is being deleted,
            //  ditch the dangling pointer to the domain info structure.
            //
            if ( DomainInfo->DomFlags & DOM_DELETED ) {
                NlDnsName->DomainInfo = NULL;
            }
        }
    }

    LeaveCriticalSection( &NlGlobalDnsCritSect );

    if ( SocketAddresses != NULL ) {
        LocalFree( SocketAddresses );
    }

    if ( DcSiteNames != NULL ) {
        NetApiBufferFree( DcSiteNames );
    }

    if ( GcSiteNames != NULL ) {
        NetApiBufferFree( GcSiteNames );
    }

    return SaveNetStatus;
}

NET_API_STATUS
NlDnsInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize the dynamic DNS code.

    Read the list of registered DNS names from the binary log file.  Put each entry in the
    list of registered DNS names.  The names will be marked as DelayedDeregister.
    Such names will be marked for deleting if they aren't re-registered
    during the Netlogon startup process.

Arguments:

    None

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;

    PLIST_ENTRY ListEntry;
    PNL_DNS_NAME NlDnsName;

    ULONG DnsRecordBufferSize;
    PNL_DNSLOG_HEADER DnsRecordBuffer = NULL;
    LPBYTE DnsRecordBufferEnd;
    PNL_DNSLOG_ENTRY DnsLogEntry;
    ULONG CurrentSize;

    LPBYTE Where;



    //
    // Initialization
    //

    EnterCriticalSection( &NlGlobalDnsCritSect );
    NlGlobalDnsStartTime = GetTickCount();
    NlGlobalDnsInitialCleanupDone = FALSE;
    NlGlobalDnsListDirty = FALSE;
    NlGlobalDnsScavengeNeeded = FALSE;
    NlGlobalDnsScavengingInProgress = FALSE;
    NlGlobalDnsScavengeFlags = 0;
    NlDnsInitCount ++;

    //
    // That's it for a workstation.
    //

    if ( NlGlobalMemberWorkstation ) {
        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    NlInitializeWorkItem( &NlGlobalDnsScavengeWorkItem, NlDnsScavengeWorker, NULL );

    //
    // Set the DNS scavenger timer
    //

    NlQuerySystemTime( &NlGlobalDnsScavengerTimer.StartTime );
    NlGlobalDnsScavengerTimer.Period = min( ORIG_DNS_SCAVENGE_PERIOD, NlGlobalParameters.DnsRefreshIntervalPeriod );

    //
    // Read the file into a buffer.
    //

    NetStatus = NlReadBinaryLog(
                    NL_DNS_BINARY_LOG_FILE,
                    FALSE,  // Don't delete the file
                    (LPBYTE *) &DnsRecordBuffer,
                    &DnsRecordBufferSize );

    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "NlDnsInitialize: error reading binary log: %ld.\n",
                  NL_DNS_BINARY_LOG_FILE,
                  DnsRecordBufferSize ));
        goto Cleanup;
    }




    //
    // Validate the returned data.
    //

    if ( DnsRecordBufferSize < sizeof(NL_DNSLOG_HEADER) ) {
        NlPrint(( NL_CRITICAL,
                  "NlDnsInitialize: %ws: size too small: %ld.\n",
                  NL_DNS_BINARY_LOG_FILE,
                  DnsRecordBufferSize ));
        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    if ( DnsRecordBuffer->Version != NL_DNSLOG_VERSION ) {
        NlPrint(( NL_CRITICAL,
                  "NlDnsInitialize: %ws: Version wrong: %ld.\n",
                  NL_DNS_BINARY_LOG_FILE,
                  DnsRecordBuffer->Version ));
        NetStatus = NO_ERROR;
        goto Cleanup;
    }



    //
    // Loop through each log entry.
    //

    DnsRecordBufferEnd = ((LPBYTE)DnsRecordBuffer) + DnsRecordBufferSize;
    DnsLogEntry = (PNL_DNSLOG_ENTRY)ROUND_UP_POINTER( (DnsRecordBuffer + 1), ALIGN_WORST );

    while ( (LPBYTE)(DnsLogEntry+1) <= DnsRecordBufferEnd ) {
        LPSTR DnsRecordName;
        LPSTR DnsHostName;
        LPBYTE DnsLogEntryEnd;

        DnsLogEntryEnd = ((LPBYTE)DnsLogEntry) + DnsLogEntry->EntrySize;

        //
        // Ensure this entry is entirely within the allocated buffer.
        //

        if  ( DnsLogEntryEnd > DnsRecordBufferEnd ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsInitialize: Entry too big: %lx %lx.\n",
                      ((LPBYTE)DnsLogEntry)-((LPBYTE)DnsRecordBuffer),
                      DnsLogEntry->EntrySize ));
            break;
        }

        //
        // Validate the entry
        //

        if ( !COUNT_IS_ALIGNED(DnsLogEntry->EntrySize, ALIGN_DWORD) ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsInitialize: size not aligned %lx.\n",
                      DnsLogEntry->EntrySize ));
            break;
        }

        if ( DnsLogEntry->NlDnsNameType < 0 ||
             DnsLogEntry->NlDnsNameType >= NlDnsInvalid ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsInitialize: Bogus DnsNameType: %lx.\n",
                      DnsLogEntry->NlDnsNameType ));
            break;
        }

        if ( DnsLogEntry->Priority > 0xFFFF ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsInitialize: Bogus priority: %lx.\n",
                      DnsLogEntry->Priority ));
            break;
        }

        if ( DnsLogEntry->Weight > 0xFFFF ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsInitialize: Bogus weight %lx.\n",
                      DnsLogEntry->Weight ));
            break;
        }

        if ( DnsLogEntry->Port > 0xFFFF ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsInitialize: Bogus port %lx.\n",
                      DnsLogEntry->Port ));
            break;
        }


        //
        // Grab the DnsRecordName from the entry.
        //

        Where = (LPBYTE) (DnsLogEntry+1);
        if ( Where >= DnsLogEntryEnd ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsInitialize: DnsRecordName missing: %lx\n",
                      ((LPBYTE)DnsLogEntry)-((LPBYTE)DnsRecordBuffer) ));
            break;
        }

        DnsRecordName = Where;
        while ( *Where != '\0' && Where < DnsLogEntryEnd ) {
            Where ++;
        }

        if ( Where >= DnsLogEntryEnd ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsInitialize: DnsRecordName has no trailing 0: %lx\n",
                      ((LPBYTE)DnsLogEntry)-((LPBYTE)DnsRecordBuffer) ));
            break;
        }
        Where ++;

        //
        // Validate the record name is syntactically valid
        //

        NetStatus = DnsValidateName_UTF8( DnsRecordName, DnsNameDomain );

        if ( NetStatus != ERROR_SUCCESS && NetStatus != DNS_ERROR_NON_RFC_NAME ) {
            NlPrint(( NL_CRITICAL,
                      "NlDnsInitialize: Bad DNS record name encountered: %s\n",
                      DnsRecordName ));
            break;
        }

        //
        // Grab the DnsHostName from the entry.
        //

        if ( !NlDnsARecord( DnsLogEntry->NlDnsNameType ) ) {
            if ( Where >= DnsLogEntryEnd ) {
                NlPrint(( NL_CRITICAL,
                          "NlDnsInitialize: DnsHostName missing: %lx\n",
                          ((LPBYTE)DnsLogEntry)-((LPBYTE)DnsRecordBuffer) ));
                break;
            }

            DnsHostName = Where;
            while ( *Where != '\0' && Where < DnsLogEntryEnd ) {
                Where ++;
            }

            if ( Where >= DnsLogEntryEnd ) {
                NlPrint(( NL_CRITICAL,
                          "NlDnsInitialize: DnsHostName has no trailing 0: %lx\n",
                          ((LPBYTE)DnsLogEntry)-((LPBYTE)DnsRecordBuffer) ));
                break;
            }
            Where ++;
        } else {
            DnsHostName = NULL;
        }

        //
        // Validate the host name is syntactically valid
        //

        if ( DnsHostName != NULL ) {
            NetStatus = DnsValidateName_UTF8( DnsHostName, DnsNameHostnameFull );

            if ( NetStatus != ERROR_SUCCESS && NetStatus != DNS_ERROR_NON_RFC_NAME ) {
                NlPrint(( NL_CRITICAL,
                          "NlDnsInitialize: Bad DNS host name encountered: %s\n",
                          DnsHostName ));
                break;
            }
        }

        //
        // Allocate the entry and mark it as DelayedDeregister.
        //

        NlDnsName = NlDnsAllocateEntry(
                            DnsLogEntry->NlDnsNameType,
                            DnsRecordName,
                            DnsLogEntry->Priority,
                            DnsLogEntry->Weight,
                            DnsLogEntry->Port,
                            DnsHostName,
                            DnsLogEntry->IpAddress,
                            DelayedDeregister );

        if ( NlDnsName == NULL ) {
            NlPrint(( NL_CRITICAL,
                         "NlDnsInitialize: %s: Cannot allocate DnsName structure %lx\n",
                         ((LPBYTE)DnsLogEntry)-((LPBYTE)DnsRecordBuffer) ));
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;

        }

        //
        // This name has been registered once or it wouldn't be here.
        //
        NlDnsName->Flags |= NL_DNS_REGISTERED_ONCE;
        NlPrintDns(( NL_DNS, NlDnsName,
                  "NlDnsInitialize: Previously registered name noticed" ));

        //
        // Move to the next entry.
        //

        DnsLogEntry = (PNL_DNSLOG_ENTRY)(((LPBYTE)DnsLogEntry) + DnsLogEntry->EntrySize);
    }

    NetStatus = NO_ERROR;



    //
    // Be tidy.
    //
Cleanup:
    if ( DnsRecordBuffer != NULL ) {
        LocalFree( DnsRecordBuffer );
    }

    LeaveCriticalSection( &NlGlobalDnsCritSect );

    return NetStatus;

}

VOID
NlDnsShutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup DNS names upon shutdown.

Arguments:

    None.

Return Value:

    None

--*/
{
    NET_API_STATUS NetStatus;
    PNL_DNS_NAME NlDnsName = NULL;

    PLIST_ENTRY ListEntry;

    EnterCriticalSection( &NlGlobalDnsCritSect );

    //
    // Deregister records on shutdown as needed.
    //  Do the work in this thread as we are shutting down.
    //

    NlGlobalDnsScavengeNeeded = TRUE;

    //
    // Clear all options,
    //  just deregister records that are already on the list as appropriate
    //

    NlGlobalDnsScavengeFlags = 0;
    NlDnsScavengeWorker( NULL );

    //
    // Loop deleting all the entries.
    //

    while ( !IsListEmpty( &NlGlobalDnsList ) ) {
        NlDnsName = CONTAINING_RECORD( NlGlobalDnsList.Flink, NL_DNS_NAME, Next );
        RemoveEntryList( &NlDnsName->Next );
        LocalFree( NlDnsName );
    }
    LeaveCriticalSection( &NlGlobalDnsCritSect );
    return;

}




NET_API_STATUS
NlSetDnsForestName(
    IN PUNICODE_STRING DnsForestName OPTIONAL,
    OUT PBOOLEAN DnsForestNameChanged OPTIONAL
    )
/*++

Routine Description:

    Set the DNS tree name in the appropriate globals.

Arguments:

    DnsForestName:  of the tree this machine is in.

    DnsForestNameChanged: Returns TRUE if the tree name changed.

Return Value:

    NO_ERROR - String was saved successfully.


--*/
{
    NET_API_STATUS NetStatus;
    ULONG DnsForestNameLength;
    LPWSTR LocalUnicodeDnsForestName = NULL;
    ULONG LocalUnicodeDnsForestNameLen = 0;
    LPSTR LocalUtf8DnsForestName = NULL;
    BOOLEAN LocalDnsForestNameChanged = FALSE;

    //
    // If a tree name is specified,
    //  allocate buffers for them.
    //

    EnterCriticalSection( &NlGlobalDnsForestNameCritSect );
    if ( DnsForestName != NULL && DnsForestName->Length != 0 ) {

        //
        // If the tree name hasn't changed,
        //  avoid setting it.
        //

        if ( NlGlobalUnicodeDnsForestNameString.Length != 0 ) {

            if ( NlEqualDnsNameU( &NlGlobalUnicodeDnsForestNameString, DnsForestName ) ) {
                NetStatus = NO_ERROR;
                goto Cleanup;
            }
        }

        NlPrint(( NL_DNS,
            "Set DnsForestName to: %wZ\n",
            DnsForestName ));

        //
        // Save the . terminated Unicode version of the string.
        //

        LocalUnicodeDnsForestNameLen = DnsForestName->Length / sizeof(WCHAR);
        if ( LocalUnicodeDnsForestNameLen > NL_MAX_DNS_LENGTH ) {
            NetStatus = ERROR_INVALID_NAME;
            goto Cleanup;
        }
        LocalUnicodeDnsForestName = NetpMemoryAllocate( (LocalUnicodeDnsForestNameLen+2) * sizeof(WCHAR));

        if ( LocalUnicodeDnsForestName == NULL) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RtlCopyMemory( LocalUnicodeDnsForestName,
                       DnsForestName->Buffer,
                       LocalUnicodeDnsForestNameLen*sizeof(WCHAR) );

        if ( LocalUnicodeDnsForestName[LocalUnicodeDnsForestNameLen-1] != L'.' ) {
            LocalUnicodeDnsForestName[LocalUnicodeDnsForestNameLen++] = L'.';
        }
        LocalUnicodeDnsForestName[LocalUnicodeDnsForestNameLen] = L'\0';


        //
        // Convert it to zero terminated UTF-8
        //

        LocalUtf8DnsForestName = NetpAllocUtf8StrFromWStr( LocalUnicodeDnsForestName );

        if (LocalUtf8DnsForestName == NULL) {
            NetpMemoryFree( LocalUnicodeDnsForestName );
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        if ( strlen(LocalUtf8DnsForestName) > NL_MAX_DNS_LENGTH ) {
            NetpMemoryFree( LocalUnicodeDnsForestName );
            NetpMemoryFree( LocalUtf8DnsForestName );
            NetStatus = ERROR_INVALID_NAME;
            goto Cleanup;
        }

        //
        // Indicate the the name has changed.
        //

        LocalDnsForestNameChanged = TRUE;
    }

    //
    // Free any existing global tree name.
    //
    if ( NlGlobalUnicodeDnsForestName != NULL ) {
        NetApiBufferFree( NlGlobalUnicodeDnsForestName );
    }
    if ( NlGlobalUtf8DnsForestName != NULL ) {
        NetpMemoryFree( NlGlobalUtf8DnsForestName );
    }

    //
    // Save the new names in the globals.
    //

    NlGlobalUnicodeDnsForestName = LocalUnicodeDnsForestName;
    NlGlobalUnicodeDnsForestNameLen = LocalUnicodeDnsForestNameLen;

    NlGlobalUnicodeDnsForestNameString.Buffer = LocalUnicodeDnsForestName;
    NlGlobalUnicodeDnsForestNameString.Length = (USHORT)(LocalUnicodeDnsForestNameLen*sizeof(WCHAR));
    NlGlobalUnicodeDnsForestNameString.MaximumLength = (USHORT)((LocalUnicodeDnsForestNameLen+1)*sizeof(WCHAR));

    NlGlobalUtf8DnsForestName = LocalUtf8DnsForestName;

    NetStatus = NO_ERROR;

Cleanup:
    LeaveCriticalSection( &NlGlobalDnsForestNameCritSect );


    //
    // If the name changed,
    //  recompute the DOM_FOREST_ROOT bit on all domains.
    //
    if ( LocalDnsForestNameChanged ) {
        (VOID) NlEnumerateDomains( FALSE, NlSetDomainForestRoot, NULL );
    }

    if ( ARGUMENT_PRESENT( DnsForestNameChanged) ) {
        *DnsForestNameChanged = LocalDnsForestNameChanged;
    }
    return NetStatus;

}

VOID
NlCaptureDnsForestName(
    OUT WCHAR DnsForestName[NL_MAX_DNS_LENGTH+1]
    )
/*++

Routine Description:

    Captures a copy of the DnsForestName for this machine.

Arguments:

    DnsForestName - Returns the DNS name of the tree this machine is in.
        If there is none, an empty string is returned.

Return Value:

    None.
--*/
{
    EnterCriticalSection(&NlGlobalDnsForestNameCritSect);
    if ( NlGlobalUnicodeDnsForestName == NULL ) {
        *DnsForestName = L'\0';
    } else {
        wcscpy( DnsForestName, NlGlobalUnicodeDnsForestName );
    }
    LeaveCriticalSection(&NlGlobalDnsForestNameCritSect);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\changelg.h ===
/*++

Copyright (c) 1991-1997  Microsoft Corporation

Module Name:

    changelg.h

Abstract:

    Defines and routines needed to interface with changelg.c.
    Read the comments in the abstract for changelg.c to determine the
    restrictions on the use of that module.

Author:

    Cliff Van Dyke (cliffv) 07-May-1992

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.

--*/

#if ( _MSC_VER >= 800 )
#pragma warning ( 3 : 4100 ) // enable "Unreferenced formal parameter"
#pragma warning ( 3 : 4219 ) // enable "trailing ',' used for variable argument list"
#endif

#define DS_VALID_SERVICE_BITS ( DS_WRITABLE_FLAG | DS_KDC_FLAG | DS_DS_FLAG | DS_TIMESERV_FLAG | DS_GC_FLAG | DS_GOOD_TIMESERV_FLAG)
#define DS_OUTOFPROC_VALID_SERVICE_BITS ( DS_TIMESERV_FLAG | DS_GOOD_TIMESERV_FLAG )
#define DS_DNS_SERVICE_BITS ( DS_KDC_FLAG | DS_GC_FLAG | DS_DS_FLAG )

/////////////////////////////////////////////////////////////////////////////
//
// Structures and variables describing the Change Log
//
/////////////////////////////////////////////////////////////////////////////

//
// Change log entry is a variable length record, the variable fields SID and
// ObjectName will follow the structure.
//

typedef struct _CHANGELOG_ENTRY_V3 {
    LARGE_INTEGER SerialNumber; // always align this on 8 byte boundary

    DWORD Size;
    USHORT DeltaType;
    UCHAR DBIndex;
    UCHAR ReplicateImmediately;

    ULONG ObjectRid;
    USHORT ObjectSidOffset;
    USHORT ObjectNameOffset;      // null terminated unicode string
} CHANGELOG_ENTRY_V3, *PCHANGELOG_ENTRY_V3;

typedef struct _CHANGELOG_ENTRY {
    LARGE_INTEGER SerialNumber; // always align this on 8 byte boundary

    ULONG ObjectRid;

    USHORT Flags;
#define CHANGELOG_SID_SPECIFIED         0x04
#define CHANGELOG_NAME_SPECIFIED        0x08
#define CHANGELOG_PDC_PROMOTION         0x10

//
// The following bits were used in NT 4.0.  Avoid them if at all possible
#define CHANGELOG_REPLICATE_IMMEDIATELY 0x01
#define CHANGELOG_PASSWORD_CHANGE       0x02
#define CHANGELOG_PREVIOUSLY_USED_BITS  0x23
    UCHAR DBIndex;
    UCHAR DeltaType;

} CHANGELOG_ENTRY, *PCHANGELOG_ENTRY;


//
// List of changes the netlogon needs to be aware of.
//

typedef struct _CHANGELOG_NOTIFICATION {
    LIST_ENTRY Next;

    enum CHANGELOG_NOTIFICATION_TYPE {
        ChangeLogTrustAccountAdded,     // ObjectName/ObjectRid specified
        ChangeLogTrustAccountDeleted,   // ObjectName specified
        ChangeLogTrustAdded,            // ObjectSid specified
        ChangeLogTrustDeleted,          // ObjectSid specified
        ChangeLogRoleChanged,           // Role of the LSA changed
        ChangeDnsNames,                 // DNS names should change
        ChangeLogDsChanged,             // Sundry DS information changed
        ChangeLogLsaPolicyChanged,      // Sundry LSA Policy information changed
        ChangeLogNtdsDsaDeleted         // NTDS-DSA object deleted
    } EntryType;

    UNICODE_STRING ObjectName;

    PSID ObjectSid;

    ULONG ObjectRid;

    GUID ObjectGuid;

    GUID DomainGuid;

    UNICODE_STRING DomainName;

} CHANGELOG_NOTIFICATION, *PCHANGELOG_NOTIFICATION;

//
// To serialize change log access
//

#define LOCK_CHANGELOG()   EnterCriticalSection( &NlGlobalChangeLogCritSect )
#define UNLOCK_CHANGELOG() LeaveCriticalSection( &NlGlobalChangeLogCritSect )

//
// Index to supported data bases.
//

#define SAM_DB      0       // index to SAM database structure
#define BUILTIN_DB  1       // index to BUILTIN database structure
#define LSA_DB      2       // index to LSA database
#define VOID_DB     3       // index to unused database (used to mark changelog
                            // entry as invalid)

#define NUM_DBS     3       // number of databases supported



//
// Netlogon started flag, used by the changelog to determine the
// netlogon service is successfully started and initialization
// completed.
//

typedef enum {
    NetlogonStopped,
    NetlogonStarting,
    NetlogonStarted
} _CHANGELOG_NETLOGON_STATE;

//
// Role of the machine from the changelog's perspective.
//

typedef enum _CHANGELOG_ROLE {
    ChangeLogPrimary,
    ChangeLogBackup,
    ChangeLogMemberWorkstation,
    ChangeLogUnknown
    } CHANGELOG_ROLE;



/////////////////////////////////////////////////////////////////////////////
//
// Procedure forwards
//
/////////////////////////////////////////////////////////////////////////////


NTSTATUS
NlInitChangeLog(
    VOID
);

NTSTATUS
NlCloseChangeLog(
    VOID
);

NTSTATUS
NetpNotifyRole (
    IN POLICY_LSA_SERVER_ROLE Role
    );

DWORD
NlBackupChangeLogFile(
    VOID
    );

NET_API_STATUS
NlpFreeNetlogonDllHandles (
    VOID
    );

NTSTATUS
NlSendChangeLogNotification(
    IN enum CHANGELOG_NOTIFICATION_TYPE EntryType,
    IN PUNICODE_STRING ObjectName,
    IN PSID ObjectSid,
    IN ULONG ObjectRid,
    IN GUID *ObjectGuid,
    IN GUID *DomainGuid,
    IN PUNICODE_STRING DomainName
    );

VOID
NlWaitForChangeLogBrowserNotify(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\chutil.h ===
/*++

Copyright (c) 1991-1997 Microsoft Corporation

Module Name:

    chutil.h

Abstract:

    Definitions of the internals of the changelog.

    Currently only included sparingly.

Author:

    Cliff Van Dyke (cliffv) 07-May-1992

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.

--*/

#if ( _MSC_VER >= 800 )
#pragma warning ( 3 : 4100 ) // enable "Unreferenced formal parameter"
#pragma warning ( 3 : 4219 ) // enable "trailing ',' used for variable argument list"
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Structures and variables describing the Change Log.
//
/////////////////////////////////////////////////////////////////////////////

//
// All of the following data is private to changelg.c and nltest1.c
//

//
// change log file name
//

#define CHANGELOG_FILE_PREFIX         L"\\NETLOGON"

#define CHANGELOG_FILE_POSTFIX_LENGTH 4         // Length of all the following postfixes
#define CHANGELOG_FILE_POSTFIX        L".CHG"
#define TEMP_CHANGELOG_FILE_POSTFIX   L".CHT"
#define BACKUP_CHANGELOG_FILE_POSTFIX L".BKP"
#define REDO_FILE_POSTFIX             L".RDO"

//
// Signature at front of changelog file
//

#define CHANGELOG_SIG_V3 "NT CHANGELOG 3"
#define CHANGELOG_SIG    "NT CHANGELOG 4"

//
// Change log block state
//

typedef enum _CHANGELOG_BLOCK_STATE {
    BlockFree = 1,
    BlockUsed,
    BlockHole
} CHANGELOG_BLOCK_STATE, *PCHANGELOG_BLOCK_STATE;

//
// change log memory block header
//

typedef struct _CHANGELOG_BLOCK_HEADER {
    DWORD BlockSize;
    CHANGELOG_BLOCK_STATE BlockState;
} CHANGELOG_BLOCK_HEADER, *PCHANGELOG_BLOCK_HEADER;

typedef struct _CHANGELOG_BLOCK_TRAILER {
    DWORD BlockSize;
} CHANGELOG_BLOCK_TRAILER, *PCHANGELOG_BLOCK_TRAILER;

//
// Macro to find a trailer (given a header)
//

#define ChangeLogBlockTrailer( _Header ) ( (PCHANGELOG_BLOCK_TRAILER)(\
    ((LPBYTE)(_Header)) + \
    (_Header)->BlockSize - \
    sizeof(CHANGELOG_BLOCK_TRAILER) ))

//
// Macro to find if the change log describe be a particular
// changelog descriptor is empty.
//
//

#define ChangeLogIsEmpty( _Desc ) \
( \
    (_Desc)->FirstBlock == NULL || \
    ((_Desc)->FirstBlock->BlockState == BlockFree && \
     (_Desc)->FirstBlock->BlockSize >= \
        (DWORD)((_Desc)->BufferEnd - (LPBYTE)(_Desc)->FirstBlock) ) \
)

//
// Macro to initialize a changelog desriptor.
//

#define InitChangeLogDesc( _Desc ) \
    RtlZeroMemory( (_Desc), sizeof( *(_Desc) ) ); \
    (_Desc)->FileHandle = INVALID_HANDLE_VALUE;

//
// Macro to determine if the serial number on the change log entry matches
// the serial number specified.
//
// The serial numbers match if there is an exact match or
// if the changelog entry contains the serial number at the instant of promotion and the
// requested serial number is the corresponding pre-promotion value.
//

#define IsSerialNumberEqual( _ChangeLogDesc, _ChangeLogEntry, _SerialNumber ) \
( \
    (_ChangeLogEntry)->SerialNumber.QuadPart == (_SerialNumber)->QuadPart || \
   (((_ChangeLogEntry)->Flags & CHANGELOG_PDC_PROMOTION) && \
    (_ChangeLogEntry)->SerialNumber.QuadPart == \
        (_SerialNumber)->QuadPart + NlGlobalChangeLogPromotionIncrement.QuadPart ) \
)


//
// variables describing the change log
//

typedef struct _CHANGELOG_DESCRIPTOR {

    //
    // Start and end of the allocated block.
    //
    LPBYTE Buffer;      // Cache of the changelog contents
    ULONG BufferSize;   // Size (in bytes) of the buffer
    LPBYTE BufferEnd;   // Address of first byte beyond the end of the buffer

    //
    // Offset of the first and last dirty bytes
    //

    ULONG FirstDirtyByte;
    ULONG LastDirtyByte;

    //
    // Address of the first physical block in the change log
    //
    PCHANGELOG_BLOCK_HEADER FirstBlock; // where delta buffer starts

    //
    // Description of the circular list of change log entries.
    //
    PCHANGELOG_BLOCK_HEADER Head;       // start reading logs from here
    PCHANGELOG_BLOCK_HEADER Tail;       // where next log is written

    //
    // Serial Number of each database.
    //
    // Access is serialized via NlGlobalChangeLogCritSect
    //

    LARGE_INTEGER SerialNumber[NUM_DBS];

    //
    // Number of change log entries in the log for the specified database
    //

    DWORD EntryCount[NUM_DBS];

    //
    // Handle to file acting as backing store for the buffer.
    //

    HANDLE FileHandle;                  // handle for change log file

    //
    // Version 3: True to indicate this is a version 3 buffer.
    //

    BOOLEAN Version3;


    //
    // True if this is a temporary change log
    //

    BOOLEAN TempLog;

} CHANGELOG_DESCRIPTOR, *PCHANGELOG_DESCRIPTOR;


#define IsObjectNotFoundStatus( _DeltaType, _NtStatus ) \
    (((ULONG)(_DeltaType) > MAX_OBJECT_NOT_FOUND_STATUS ) ? \
    FALSE : \
    (NlGlobalObjectNotFoundStatus[ (_DeltaType) ] == (_NtStatus)) )


//
// Tables of related delta types
//

//
// Table of delete delta types.
//  Index into the table with a delta type,
//  the entry is the delta type that is used to delete the object.
//
// There are some objects that can't be deleted.  In that case, this table
// contains a delta type that uniquely identifies the object.  That allows
// this table to be used to see if two deltas describe the same object type.
//

#define MAX_DELETE_DELTA DummyChangeLogEntry
extern const NETLOGON_DELTA_TYPE NlGlobalDeleteDeltaType[MAX_DELETE_DELTA+1];


//
// Table of add delta types.
//  Index into the table with a delta type,
//  the entry is the delta type that is used to add the object.
//
// There are some objects that can't be added.  In that case, this table
// contains a delta type that uniquely identifies the object.  That allows
// this table to be used to see if two deltas describe the same object type.
//
// In the table, Groups and Aliases are represented as renames.  This causes
// NlPackSingleDelta to return both the group attributes and the group
// membership.
//

#define MAX_ADD_DELTA DummyChangeLogEntry
extern const NETLOGON_DELTA_TYPE NlGlobalAddDeltaType[MAX_ADD_DELTA+1];



//
// Table of Status Codes indicating the object doesn't exist.
//  Index into the table with a delta type.
//
// Map to STATUS_SUCCESS for the invalid cases to explicitly avoid other error
// codes.

#define MAX_OBJECT_NOT_FOUND_STATUS DummyChangeLogEntry
extern const NTSTATUS NlGlobalObjectNotFoundStatus[MAX_OBJECT_NOT_FOUND_STATUS+1];


//
// chutil.c
//

NTSTATUS
NlCreateChangeLogFile(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc
    );

NTSTATUS
NlFlushChangeLog(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc
    );

PCHANGELOG_ENTRY
NlMoveToNextChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_ENTRY ChangeLogEntry
    );

VOID
PrintChangeLogEntry(
    IN PCHANGELOG_ENTRY ChangeLogEntry
    );

NTSTATUS
NlResetChangeLog(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN DWORD NewChangeLogSize
    );

NTSTATUS
NlOpenChangeLogFile(
    IN LPWSTR ChangeLogFileName,
    OUT PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN BOOLEAN ReadOnly
    );

VOID
NlCloseChangeLogFile(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc
);

NTSTATUS
NlResizeChangeLogFile(
    IN OUT PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN DWORD NewChangeLogSize
);

NTSTATUS
NlWriteChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_ENTRY ChangeLogEntry,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN BOOLEAN FlushIt
    );

PCHANGELOG_ENTRY
NlFindPromotionChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN LARGE_INTEGER SerialNumber,
    IN DWORD DBIndex
    );

PCHANGELOG_ENTRY
NlGetNextChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN LARGE_INTEGER SerialNumber,
    IN DWORD DBIndex,
    OUT LPDWORD ChangeLogEntrySize OPTIONAL
    );

PCHANGELOG_ENTRY
NlGetNextUniqueChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN LARGE_INTEGER SerialNumber,
    IN DWORD DBIndex,
    OUT LPDWORD ChangeLogEntrySize OPTIONAL
    );

BOOL
NlRecoverChangeLog(
    PCHANGELOG_ENTRY ChangeLogEntry
    );

VOID
NlDeleteChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN DWORD DBIndex,
    IN LARGE_INTEGER SerialNumber
    );

BOOLEAN
NlFixChangeLog(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN DWORD DBIndex,
    IN LARGE_INTEGER SerialNumber
    );

BOOL
NlValidateChangeLogEntry(
    IN PCHANGELOG_ENTRY ChangeLogEntry,
    IN DWORD ChangeLogEntrySize
    );

#undef EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\chutil.c ===
/*++

Copyright (c) 1987-1997  Microsoft Corporation

Module Name:

    chutil.c

Abstract:

    Change Log utility routines.

Author:


Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    11-Jan-1994 (cliffv)
        Split out from changelg.c

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//



//
// Tables of related delta types
//

//
// Table of delete delta types.
//  Index into the table with a delta type,
//  the entry is the delta type that is used to delete the object.
//
// There are some objects that can't be deleted.  In that case, this table
// contains a delta type that uniquely identifies the object.  That allows
// this table to be used to see if two deltas describe the same object type.
//

const NETLOGON_DELTA_TYPE NlGlobalDeleteDeltaType[MAX_DELETE_DELTA+1]
= {
    AddOrChangeDomain,     //   0 is an invalid delta type
    AddOrChangeDomain,     //   AddOrChangeDomain,
    DeleteGroup,           //   AddOrChangeGroup,
    DeleteGroup,           //   DeleteGroup,
    DeleteGroup,           //   RenameGroup,
    DeleteUser,            //   AddOrChangeUser,
    DeleteUser,            //   DeleteUser,
    DeleteUser,            //   RenameUser,
    DeleteGroup,           //   ChangeGroupMembership,
    DeleteAlias,           //   AddOrChangeAlias,
    DeleteAlias,           //   DeleteAlias,
    DeleteAlias,           //   RenameAlias,
    DeleteAlias,           //   ChangeAliasMembership,
    AddOrChangeLsaPolicy,  //   AddOrChangeLsaPolicy,
    DeleteLsaTDomain,      //   AddOrChangeLsaTDomain,
    DeleteLsaTDomain,      //   DeleteLsaTDomain,
    DeleteLsaAccount,      //   AddOrChangeLsaAccount,
    DeleteLsaAccount,      //   DeleteLsaAccount,
    DeleteLsaSecret,       //   AddOrChangeLsaSecret,
    DeleteLsaSecret,       //   DeleteLsaSecret,
    DeleteGroup,           //   DeleteGroupByName,
    DeleteUser,            //   DeleteUserByName,
    SerialNumberSkip,      //   SerialNumberSkip,
    DummyChangeLogEntry    //   DummyChangeLogEntry
};


//
// Table of add delta types.
//  Index into the table with a delta type,
//  the entry is the delta type that is used to add the object.
//
// There are some objects that can't be added.  In that case, this table
// contains a delta type that uniquely identifies the object.  That allows
// this table to be used to see if two deltas describe the same object type.
//
// In the table, Groups and Aliases are represented as renames.  This causes
// NlPackSingleDelta to return both the group attributes and the group
// membership.
//

const NETLOGON_DELTA_TYPE NlGlobalAddDeltaType[MAX_ADD_DELTA+1]
= {
    AddOrChangeDomain,     //   0 is an invalid delta type
    AddOrChangeDomain,     //   AddOrChangeDomain,
    RenameGroup,           //   AddOrChangeGroup,
    RenameGroup,           //   DeleteGroup,
    RenameGroup,           //   RenameGroup,
    AddOrChangeUser,       //   AddOrChangeUser,
    AddOrChangeUser,       //   DeleteUser,
    AddOrChangeUser,       //   RenameUser,
    RenameGroup,           //   ChangeGroupMembership,
    RenameAlias,           //   AddOrChangeAlias,
    RenameAlias,           //   DeleteAlias,
    RenameAlias,           //   RenameAlias,
    RenameAlias,           //   ChangeAliasMembership,
    AddOrChangeLsaPolicy,  //   AddOrChangeLsaPolicy,
    AddOrChangeLsaTDomain, //   AddOrChangeLsaTDomain,
    AddOrChangeLsaTDomain, //   DeleteLsaTDomain,
    AddOrChangeLsaAccount, //   AddOrChangeLsaAccount,
    AddOrChangeLsaAccount, //   DeleteLsaAccount,
    AddOrChangeLsaSecret,  //   AddOrChangeLsaSecret,
    AddOrChangeLsaSecret,  //   DeleteLsaSecret,
    RenameGroup,           //   DeleteGroupByName,
    AddOrChangeUser,       //   DeleteUserByName,
    SerialNumberSkip,      //   SerialNumberSkip,
    DummyChangeLogEntry    //   DummyChangeLogEntry
};



//
// Table of Status Codes indicating the object doesn't exist.
//  Index into the table with a delta type.
//
// Map to STATUS_SUCCESS for the invalid cases to explicitly avoid other error
// codes.

const NTSTATUS NlGlobalObjectNotFoundStatus[MAX_OBJECT_NOT_FOUND_STATUS+1]
= {
    STATUS_SUCCESS,               //   0 is an invalid delta type
    STATUS_NO_SUCH_DOMAIN,        //   AddOrChangeDomain,
    STATUS_NO_SUCH_GROUP,         //   AddOrChangeGroup,
    STATUS_NO_SUCH_GROUP,         //   DeleteGroup,
    STATUS_NO_SUCH_GROUP,         //   RenameGroup,
    STATUS_NO_SUCH_USER,          //   AddOrChangeUser,
    STATUS_NO_SUCH_USER,          //   DeleteUser,
    STATUS_NO_SUCH_USER,          //   RenameUser,
    STATUS_NO_SUCH_GROUP,         //   ChangeGroupMembership,
    STATUS_NO_SUCH_ALIAS,         //   AddOrChangeAlias,
    STATUS_NO_SUCH_ALIAS,         //   DeleteAlias,
    STATUS_NO_SUCH_ALIAS,         //   RenameAlias,
    STATUS_NO_SUCH_ALIAS,         //   ChangeAliasMembership,
    STATUS_SUCCESS,               //   AddOrChangeLsaPolicy,
    STATUS_OBJECT_NAME_NOT_FOUND, //   AddOrChangeLsaTDomain,
    STATUS_OBJECT_NAME_NOT_FOUND, //   DeleteLsaTDomain,
    STATUS_OBJECT_NAME_NOT_FOUND, //   AddOrChangeLsaAccount,
    STATUS_OBJECT_NAME_NOT_FOUND, //   DeleteLsaAccount,
    STATUS_OBJECT_NAME_NOT_FOUND, //   AddOrChangeLsaSecret,
    STATUS_OBJECT_NAME_NOT_FOUND, //   DeleteLsaSecret,
    STATUS_NO_SUCH_GROUP,         //   DeleteGroupByName,
    STATUS_NO_SUCH_USER,          //   DeleteUserByName,
    STATUS_SUCCESS,               //   SerialNumberSkip,
    STATUS_SUCCESS                //   DummyChangeLogEntry
};



//
// Context for I_NetLogonReadChangeLog
//

typedef struct _CHANGELOG_CONTEXT {
    LARGE_INTEGER SerialNumber;
    DWORD DbIndex;
    DWORD SequenceNumber;
} CHANGELOG_CONTEXT, *PCHANGELOG_CONTEXT;

//
// Header for buffers returned from I_NetLogonReadChangeLog
//

typedef struct _CHANGELOG_BUFFER_HEADER {
    DWORD Size;
    DWORD Version;
    DWORD SequenceNumber;
    DWORD Flags;
} CHANGELOG_BUFFER_HEADER, *PCHANGELOG_BUFFER_HEADER;

#define CHANGELOG_BUFFER_VERSION 1


ULONG NlGlobalChangeLogHandle = 0;
ULONG NlGlobalChangeLogSequenceNumber;

/* NlCreateChangeLogFile and NlWriteChangeLogBytes reference each other */
NTSTATUS
NlWriteChangeLogBytes(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN LPBYTE Buffer,
    IN DWORD BufferSize,
    IN BOOLEAN FlushIt
    );




NTSTATUS
NlCreateChangeLogFile(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc
    )
/*++

Routine Description:

    Try to create a change log file. If it is successful then it sets
    the file handle in ChangeLogDesc, otherwise it leaves the handle invalid.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{
    NTSTATUS Status;
    WCHAR ChangeLogFile[MAX_PATH+CHANGELOG_FILE_POSTFIX_LENGTH+1];

    NlAssert( ChangeLogDesc->FileHandle == INVALID_HANDLE_VALUE );

    //
    // if the change file name is unknown, terminate the operation.
    //

    if( NlGlobalChangeLogFilePrefix[0] == L'\0' ) {
        return STATUS_NO_SUCH_FILE;
    }

    //
    // Create change log file. If it exists already then truncate it.
    //
    // Note : if a valid change log file exists on the system, then we
    // would have opened at initialization time.
    //

    wcscpy( ChangeLogFile, NlGlobalChangeLogFilePrefix );
    wcscat( ChangeLogFile,
            ChangeLogDesc->TempLog ? TEMP_CHANGELOG_FILE_POSTFIX : CHANGELOG_FILE_POSTFIX );

    ChangeLogDesc->FileHandle = CreateFileW(
                        ChangeLogFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,        // allow backups and debugging
                        NULL,                   // Supply better security ??
                        CREATE_ALWAYS,          // Overwrites always
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );                 // No template

    if (ChangeLogDesc->FileHandle == INVALID_HANDLE_VALUE) {

        Status = NetpApiStatusToNtStatus( GetLastError());
        NlPrint((NL_CRITICAL,"Unable to create changelog file: 0x%lx \n", Status));
        return Status;
    }

    //
    // Write cache in backup changelog file if the cache is valid.
    //

    if( ChangeLogDesc->Buffer != NULL ) {
         Status = NlWriteChangeLogBytes(
                    ChangeLogDesc,
                    ChangeLogDesc->Buffer,
                    ChangeLogDesc->BufferSize,
                    TRUE ); // Flush the bytes to disk

        return Status;

    }

    return STATUS_SUCCESS;

}

VOID
NlWriteChangeLogCorruptEvent(
    IN NTSTATUS Status,
    IN DWORD DbIndex
    )
/*++

Routine Description:

    This routine writes the event log message stating that
    the change log file is corrupted.

Arguments:

    Status -- Status code of the failure.

    DBIndex -- Index of the database that is corrupted.
        If not void DB, the database name will be logged.

Return Value:

    None

--*/
{
    LPWSTR Database;
    LPWSTR MsgStrings[1];

#ifdef _NETLOGON_SERVER

    //
    // If caller is calling when the netlogon service isn't running,
    //  return.  Otherwise, we may AV when accessing SAM handle
    //  in the primary DomainInfo struct that may not be initialized.
    //

    if ( !NlStartNetlogonCall() ) {
        return;
    }

    //
    // Avoid the event if we are not in mixed mode
    //  when the change log isn't used
    //

    if ( SamIMixedDomain(NlGlobalDomainInfo->DomSamServerHandle) ) {

        if ( DbIndex == LSA_DB ) {
            Database = L"LSA";
        } else if ( DbIndex == SAM_DB ) {
            Database = L"SAM";
        } else if ( DbIndex == BUILTIN_DB ) {
            Database = L"BUILTIN";
        } else {
            Database = L"\0";  // void DB
        }
        MsgStrings[0] = Database;

        //
        // Be consistent with the old versions of the log.
        //  If the database is not void, the DB index should be
        //  written into the raw data.  Otherwise, the Status
        //  should be written into the raw data.
        //
        NlpWriteEventlog ( NELOG_NetlogonChangeLogCorrupt,
                           EVENTLOG_WARNING_TYPE,
                           (DbIndex != VOID_DB) ?
                               (LPBYTE)&DbIndex :
                               (LPBYTE)&Status,
                           (DbIndex != VOID_DB) ?
                               sizeof(DbIndex) :
                               sizeof(Status),
                           MsgStrings,
                           1 );
    }

    //
    // Indicate that we are done using the domain info
    //

    NlEndNetlogonCall();

#else

    UNREFERENCED_PARAMETER( Status );
    UNREFERENCED_PARAMETER( DbIndex );

#endif // _NETLOGON_SERVER

    return;
}


NTSTATUS
NlFlushChangeLog(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc
    )
/*++

Routine Description:

    Flush any dirty buffers to the change log file itself.
    Ensure they are flushed to disk.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

Return Value:

    Status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    OVERLAPPED Overlapped;
    DWORD BytesWritten;
    DWORD BufferSize;

    //
    // If there's nothing to do,
    //  just return.
    //

    if ( ChangeLogDesc->LastDirtyByte == 0 ) {
        return STATUS_SUCCESS;
    }


    //
    // Write to the file.
    //

    if ( ChangeLogDesc->FileHandle == INVALID_HANDLE_VALUE ) {

        Status = NlCreateChangeLogFile( ChangeLogDesc );

        //
        // This must have written entire buffer if it is successful
        // creating the change log file.
        //

        goto Cleanup;
    }

    //
    // if we are unable to create this into the changelog file, work
    // with internal cache, but notify admin by sending admin alert.
    //

    if ( ChangeLogDesc->FileHandle != INVALID_HANDLE_VALUE ) {

#ifdef notdef
        NlPrint((NL_CHANGELOG, "NlFlushChangeLog: %ld to %ld\n",
                 ChangeLogDesc->FirstDirtyByte,
                 ChangeLogDesc->LastDirtyByte ));
#endif // notdef

        //
        // Seek to appropriate offset in the file.
        //

        RtlZeroMemory( &Overlapped, sizeof(Overlapped) );
        Overlapped.Offset = ChangeLogDesc->FirstDirtyByte;

        //
        // Actually write to the file.
        //

        BufferSize = ChangeLogDesc->LastDirtyByte -
                     ChangeLogDesc->FirstDirtyByte + 1;

        if ( !WriteFile( ChangeLogDesc->FileHandle,
                         &ChangeLogDesc->Buffer[ChangeLogDesc->FirstDirtyByte],
                         BufferSize,
                         &BytesWritten,
                         &Overlapped ) ) {

            Status = NetpApiStatusToNtStatus( GetLastError() );
            NlPrint((NL_CRITICAL, "Write to ChangeLog failed 0x%lx\n",
                        Status ));

            //
            // Recreate changelog file
            //

            CloseHandle( ChangeLogDesc->FileHandle );
            ChangeLogDesc->FileHandle = INVALID_HANDLE_VALUE;

            goto Cleanup;
        }

        //
        // Ensure all the bytes made it.
        //

        if ( BytesWritten != BufferSize ) {
            NlPrint((NL_CRITICAL,
                    "Write to ChangeLog bad byte count %ld s.b. %ld\n",
                    BytesWritten,
                    BufferSize ));

            //
            // Recreate changelog file
            //

            CloseHandle( ChangeLogDesc->FileHandle );
            ChangeLogDesc->FileHandle = INVALID_HANDLE_VALUE;

            Status = STATUS_BUFFER_TOO_SMALL;
            goto Cleanup;
        }

        //
        // Force the modifications to disk.
        //

        if ( !FlushFileBuffers( ChangeLogDesc->FileHandle ) ) {

            Status = NetpApiStatusToNtStatus( GetLastError() );
            NlPrint((NL_CRITICAL, "Flush to ChangeLog failed 0x%lx\n", Status ));

            //
            // Recreate changelog file
            //

            CloseHandle( ChangeLogDesc->FileHandle );
            ChangeLogDesc->FileHandle = INVALID_HANDLE_VALUE;

            goto Cleanup;
        }

        //
        // Indicate these byte successfully made it out to disk.
        //

        ChangeLogDesc->FirstDirtyByte = 0;
        ChangeLogDesc->LastDirtyByte = 0;
    }

Cleanup:

    if( !NT_SUCCESS(Status) ) {

        //
        // Write event log.
        //
        NlWriteChangeLogCorruptEvent( Status,
                                      VOID_DB );  // no particular DB
    }

    return Status;
}

NTSTATUS
NlWriteChangeLogBytes(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN LPBYTE Buffer,
    IN DWORD BufferSize,
    IN BOOLEAN FlushIt
    )
/*++

Routine Description:

    Write bytes from the changelog cache to the change log file.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    Buffer - Address within the changelog cache to write.

    BufferSize - Number of bytes to write.

    FlushIt - TRUE if the bytes are to be flushed to disk

Return Value:

    Status of the operation.

--*/

{
    NTSTATUS Status;
    ULONG FirstDirtyByte;
    ULONG LastDirtyByte;

    //
    // Compute the new range of dirty bytes.
    //

    FirstDirtyByte = (ULONG)(((LPBYTE)Buffer) - ((LPBYTE)ChangeLogDesc->Buffer));
    LastDirtyByte = FirstDirtyByte + BufferSize - 1;

#ifdef notdef
    NlPrint((NL_CHANGELOG, "NlWriteChangeLogBytes: %ld to %ld\n",
             FirstDirtyByte,
             LastDirtyByte ));
#endif // notdef

    if ( ChangeLogDesc->LastDirtyByte == 0 ) {
        ChangeLogDesc->FirstDirtyByte = FirstDirtyByte;
        ChangeLogDesc->LastDirtyByte = LastDirtyByte;
    } else {
        if ( ChangeLogDesc->FirstDirtyByte > FirstDirtyByte ) {
            ChangeLogDesc->FirstDirtyByte = FirstDirtyByte;
        }
        if ( ChangeLogDesc->LastDirtyByte < LastDirtyByte ) {
            ChangeLogDesc->LastDirtyByte = LastDirtyByte;
        }
    }

    //
    // If the bytes are to be flushed,
    //  do so.
    //

    if ( FlushIt ) {
        Status = NlFlushChangeLog( ChangeLogDesc );
        return Status;
    }
    return STATUS_SUCCESS;
}




PCHANGELOG_BLOCK_HEADER
NlMoveToNextChangeLogBlock(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_BLOCK_HEADER BlockPtr
    )

/*++

Routine Description:

    This function accepts a pointer to a change log
    block and returns the pointer to the next change log block in the
    buffer.  It however wraps around the change log cache.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    BlockPtr - pointer to a change log block.

Return Value:

    Returns the pointer to the next change log block in the list.

--*/
{
    PCHANGELOG_BLOCK_HEADER ReturnPtr;

    ReturnPtr = (PCHANGELOG_BLOCK_HEADER)
        ((LPBYTE)BlockPtr + BlockPtr->BlockSize);


    NlAssert( (LPBYTE)ReturnPtr <= ChangeLogDesc->BufferEnd );

    if( (LPBYTE)ReturnPtr >= ChangeLogDesc->BufferEnd ) {

        //
        // wrap around
        //

        ReturnPtr = ChangeLogDesc->FirstBlock;
    }

    return ReturnPtr;

}


PCHANGELOG_BLOCK_HEADER
NlMoveToPrevChangeLogBlock(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_BLOCK_HEADER BlockPtr
    )

/*++

Routine Description:

    This function accepts a pointer to a change log
    block and returns the pointer to the next change log block in the
    buffer.  It however wraps around the change log cache.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    BlockPtr - pointer to a change log block.

Return Value:

    Returns the pointer to the next change log block in the list.

--*/
{
    PCHANGELOG_BLOCK_HEADER ReturnPtr;
    PCHANGELOG_BLOCK_TRAILER ReturnTrailer;

    //
    // If this is the first block in the buffer,
    //  return the last block in the buffer.
    //

    if ( BlockPtr == ChangeLogDesc->FirstBlock ) {
        ReturnTrailer = (PCHANGELOG_BLOCK_TRAILER)
            (ChangeLogDesc->BufferEnd - sizeof(CHANGELOG_BLOCK_TRAILER));

    //
    // Otherwise return the buffer immediately before this one.
    //

    } else {
        ReturnTrailer = (PCHANGELOG_BLOCK_TRAILER)
            (((LPBYTE)BlockPtr) - sizeof(CHANGELOG_BLOCK_TRAILER));
    }


    ReturnPtr = (PCHANGELOG_BLOCK_HEADER)
        ((LPBYTE)ReturnTrailer -
        ReturnTrailer->BlockSize +
        sizeof(CHANGELOG_BLOCK_TRAILER) );


    NlAssert( ReturnPtr >= ChangeLogDesc->FirstBlock );
    NlAssert( (LPBYTE)ReturnPtr < ChangeLogDesc->BufferEnd );

    return ReturnPtr;

}



NTSTATUS
NlAllocChangeLogBlock(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN DWORD BlockSize,
    OUT PCHANGELOG_BLOCK_HEADER *AllocatedBlock
    )
/*++

Routine Description:

    This function will allocate a change log block from the free block
    at the tail of the change log circular list.  If the available free
    block size is less than the required size than it will enlarge the
    free block by the freeing up change logs from the header.  Once the
    free block is larger then it will cut the block to the required size
    and adjust the free block pointer.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    BlockSize - size of the change log block required.

    AllocatedBlock - Returns the pointer to the block that is allocated.

Return Value:

    Status of the operation

--*/
{
    PCHANGELOG_BLOCK_HEADER FreeBlock;
    PCHANGELOG_BLOCK_HEADER NewBlock;
    DWORD ReqBlockSize;
    DWORD AllocatedBlockSize;

    //
    // pump up the size to include block header, block trailer,
    // and to align to DWORD.
    //
    // Add in the size of the new free block immediately following the new
    // block.
    //

    AllocatedBlockSize =
        ROUND_UP_COUNT( sizeof(CHANGELOG_BLOCK_HEADER), ALIGN_WORST) +
        ROUND_UP_COUNT( BlockSize+sizeof(CHANGELOG_BLOCK_TRAILER), ALIGN_WORST);

    ReqBlockSize = AllocatedBlockSize +
        ROUND_UP_COUNT( sizeof(CHANGELOG_BLOCK_HEADER), ALIGN_WORST) +
        ROUND_UP_COUNT( sizeof(CHANGELOG_BLOCK_TRAILER), ALIGN_WORST );

    if ( ReqBlockSize >= ChangeLogDesc->BufferSize - 16 ) {
        return STATUS_ALLOTTED_SPACE_EXCEEDED;
    }


    //
    // If the current free block isn't big enough,
    //  make it big enough.
    //

    FreeBlock = ChangeLogDesc->Tail;

    NlAssert( FreeBlock->BlockState == BlockFree );

    while ( FreeBlock->BlockSize <= ReqBlockSize ) {

        //
        // If this is a change log,
        //  make the free block bigger by wrapping around.
        //

        {
            PCHANGELOG_BLOCK_HEADER NextFreeBlock;

            NextFreeBlock = NlMoveToNextChangeLogBlock( ChangeLogDesc, FreeBlock );


            //
            // If this free block is the end block in the cache,
            // so make this as a 'hole' block and wrap around for
            // next free block.
            //

            if( (LPBYTE)NextFreeBlock !=
                    (LPBYTE)FreeBlock + FreeBlock->BlockSize ) {

                NlAssert( ((LPBYTE)FreeBlock + FreeBlock->BlockSize) ==
                                ChangeLogDesc->BufferEnd );

                NlAssert( NextFreeBlock == ChangeLogDesc->FirstBlock );

                FreeBlock->BlockState = BlockHole;

                //
                // Write the 'hole' block status in the file.
                //  (Write the entire block since the block size in the trailer
                //  may have changed on previous iterations of this loop.)
                //

                (VOID) NlWriteChangeLogBytes( ChangeLogDesc,
                                       (LPBYTE) FreeBlock,
                                       FreeBlock->BlockSize,
                                       TRUE ); // Flush the bytes to disk

                //
                // The free block is now at the front of the cache.
                //

                FreeBlock = ChangeLogDesc->FirstBlock;
                FreeBlock->BlockState = BlockFree;

            //
            // Otherwise, enlarge the current free block by merging the next
            //  block into it.   The next free block is either a used block or
            //  the 'hole' block.
            //
            } else {

                //
                // If we've just deleted a used block,
                //  adjust the entry count.
                //
                // VOID_DB entries are "deleted" entries and have already adjusted
                // the entry count.
                //
                if ( NextFreeBlock->BlockState == BlockUsed ) {
                    DWORD DBIndex = ((PCHANGELOG_ENTRY)(NextFreeBlock+1))->DBIndex;
                    if ( DBIndex != VOID_DB ) {
                        ChangeLogDesc->EntryCount[DBIndex] --;
                    }
                }

                FreeBlock->BlockSize += NextFreeBlock->BlockSize;
                ChangeLogBlockTrailer(FreeBlock)->BlockSize = FreeBlock->BlockSize;
            }


            //
            // If we've consumed the head of the cache,
            //  move the head of the cache to the next block.
            //

            if ( NextFreeBlock == ChangeLogDesc->Head ) {

                ChangeLogDesc->Head = NlMoveToNextChangeLogBlock( ChangeLogDesc,
                                                                  NextFreeBlock );

                //
                // if we have moved the global header to hole block,
                // skip and merge it to free block
                //

                NextFreeBlock = ChangeLogDesc->Head;

                if (NextFreeBlock->BlockState == BlockHole ) {

                    FreeBlock->BlockSize += NextFreeBlock->BlockSize;
                    ChangeLogBlockTrailer(FreeBlock)->BlockSize = FreeBlock->BlockSize;

                    ChangeLogDesc->Head =
                        NlMoveToNextChangeLogBlock( ChangeLogDesc, NextFreeBlock );
                }
            }
        }


        // NlAssert(ChangeLogDesc->Head->BlockState == BlockUsed );
        //
        // This assertion is overactive in case the whole buffer becomes free
        // as it does in the following scenario.  Suppose after allocating the
        // whole buffer, we allocate a block that is larger than the half of the
        // buffer.  Then the head (marked used) points to the beginning of the
        // buffer and the tail points to the free part at the end of the buffer.
        // Then we allocate another block that is of the same size as the
        // previously allocated block.  In this case the free block at the end of
        // the buffer will be marked 'hole', the head will be consumed, the head
        // will be moved to the next (hole) block, the head will be moved further
        // (since it points to a hole block) and marked free.  So we end up with the
        // buffer that is completely free; the head points to the beginning of the
        // buffer and marked free, not used.

    }

    NlAssert( (FreeBlock >= ChangeLogDesc->FirstBlock) &&
        (FreeBlock->BlockSize <= ChangeLogDesc->BufferSize) &&
        ( ((LPBYTE)FreeBlock + FreeBlock->BlockSize) <=
         ChangeLogDesc->BufferEnd) );

    //
    // Cut the free block ...
    //

    NewBlock = FreeBlock;

    FreeBlock = (PCHANGELOG_BLOCK_HEADER)
        ((LPBYTE)FreeBlock + AllocatedBlockSize);

    FreeBlock->BlockState = BlockFree;
    FreeBlock->BlockSize = NewBlock->BlockSize - AllocatedBlockSize;
    ChangeLogBlockTrailer(FreeBlock)->BlockSize = FreeBlock->BlockSize;

    ChangeLogDesc->Tail = FreeBlock;

    RtlZeroMemory( NewBlock, AllocatedBlockSize );
    NewBlock->BlockState = BlockUsed;
    NewBlock->BlockSize = AllocatedBlockSize;
    ChangeLogBlockTrailer(NewBlock)->BlockSize = NewBlock->BlockSize;

    NlAssert( (NewBlock >= ChangeLogDesc->FirstBlock) &&
            ( ((LPBYTE)NewBlock + BlockSize) <= ChangeLogDesc->BufferEnd) );

    *AllocatedBlock = NewBlock;

    return STATUS_SUCCESS;

}


PCHANGELOG_ENTRY
NlMoveToNextChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_ENTRY ChangeLogEntry
    )

/*++

Routine Description:

    This function is a worker routine to scan the change log list.  This
    accepts a pointer to a change log structure and returns a pointer to
    the next change log structure.  It returns NULL pointer if the given
    struct is the last change log structure in the list.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    ChangeLogEntry - pointer to a change log strcuture.

Return Value:

    Returns the pointer to the next change log structure in the list.

--*/
{
    PCHANGELOG_BLOCK_HEADER ChangeLogBlock;

    ChangeLogBlock = (PCHANGELOG_BLOCK_HEADER)
        ( (LPBYTE) ChangeLogEntry - sizeof(CHANGELOG_BLOCK_HEADER) );

    NlAssert( ChangeLogBlock->BlockState == BlockUsed );

    ChangeLogBlock = NlMoveToNextChangeLogBlock( ChangeLogDesc, ChangeLogBlock );

    //
    // If we're at the end of the list,
    //  return null
    //
    if ( ChangeLogBlock->BlockState == BlockFree ) {
        return NULL;


    //
    // Skip this block, there will be only one 'Hole' block in the
    // list.
    //
    } else if ( ChangeLogBlock->BlockState == BlockHole ) {


        ChangeLogBlock = NlMoveToNextChangeLogBlock( ChangeLogDesc, ChangeLogBlock );

        if ( ChangeLogBlock->BlockState == BlockFree ) {
            return NULL;
        }

    }

    NlAssert( ChangeLogBlock->BlockState == BlockUsed );

    return (PCHANGELOG_ENTRY)
        ( (LPBYTE)ChangeLogBlock + sizeof(CHANGELOG_BLOCK_HEADER) );

}


PCHANGELOG_ENTRY
NlMoveToPrevChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_ENTRY ChangeLogEntry
    )

/*++

Routine Description:

    This function is a worker routine to scan the change log list.  This
    accepts a pointer to a change log structure and returns a pointer to
    the previous change log structure.  It returns NULL pointer if the given
    struct is the first change log structure in the list.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    ChangeLogEntry - pointer to a change log strcuture.

Return Value:

    Returns the pointer to the next change log structure in the list.

--*/
{
    PCHANGELOG_BLOCK_HEADER ChangeLogBlock;

    ChangeLogBlock = (PCHANGELOG_BLOCK_HEADER)
        ( (LPBYTE) ChangeLogEntry - sizeof(CHANGELOG_BLOCK_HEADER) );

    NlAssert( ChangeLogBlock->BlockState == BlockUsed ||
                ChangeLogBlock->BlockState == BlockFree );

    ChangeLogBlock = NlMoveToPrevChangeLogBlock( ChangeLogDesc, ChangeLogBlock );

    //
    // If we're at the end of the list,
    //  return null
    //
    if ( ChangeLogBlock->BlockState == BlockFree ) {
        return NULL;


    //
    // Skip this block, there will be only one 'Hole' block in the
    // list.
    //
    } else if ( ChangeLogBlock->BlockState == BlockHole ) {


        ChangeLogBlock = NlMoveToPrevChangeLogBlock( ChangeLogDesc, ChangeLogBlock );

        if ( ChangeLogBlock->BlockState == BlockFree ) {
            return NULL;
        }

    }

    NlAssert( ChangeLogBlock->BlockState == BlockUsed );

    return (PCHANGELOG_ENTRY)
        ( (LPBYTE)ChangeLogBlock + sizeof(CHANGELOG_BLOCK_HEADER) );

}


PCHANGELOG_ENTRY
NlFindFirstChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN DWORD DBIndex
    )
/*++

Routine Description:

    Returns a pointer to the first change log entry for the specified
    database.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    DBIndex - Describes which database to find the changelog entry for.

Return Value:

    Non-NULL - change log entry found

    NULL - No such entry exists.

--*/
{
    PCHANGELOG_ENTRY ChangeLogEntry = NULL;

    //
    // If nothing has ever been written to the change log,
    //  indicate nothing is available.
    //

    if ( ChangeLogIsEmpty( ChangeLogDesc ) ) {
        return NULL;
    }

    for ( ChangeLogEntry = (PCHANGELOG_ENTRY) (ChangeLogDesc->Head + 1);
          ChangeLogEntry != NULL  ;
          ChangeLogEntry = NlMoveToNextChangeLogEntry( ChangeLogDesc, ChangeLogEntry) ) {

        if( ChangeLogEntry->DBIndex == (UCHAR) DBIndex ) {
             break;
        }
    }

    return ChangeLogEntry;
}



PCHANGELOG_ENTRY
NlFindChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN LARGE_INTEGER SerialNumber,
    IN BOOL DownLevel,
    IN BOOL NeedExactMatch,
    IN DWORD DBIndex
    )
/*++

Routine Description:

    Search the change log entry in change log cache for a given serial
    number

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    SerialNumber - Serial number of the entry to find.

    DownLevel - True if only the least significant portion of the serial
        number needs to match.

    NeedExactMatch - True if the caller wants us to exactly match the
        specified serial number.

    DBIndex - Describes which database to find the changelog entry for.

Return Value:

    Non-NULL - change log entry found

    NULL - No such entry exists.

--*/
{
    PCHANGELOG_ENTRY ChangeLogEntry;
    PCHANGELOG_ENTRY PriorChangeLogEntry = NULL;

    //
    // If nothing has ever been written to the change log,
    //  indicate nothing is available.
    //

    if ( ChangeLogIsEmpty( ChangeLogDesc ) ) {
        return NULL;
    }

    //
    // Search from the tail of the changelog.  For huge changelogs, this should
    // reduce the working set size since we almost always search for one of
    // the last few entries.
    //

    ChangeLogEntry = (PCHANGELOG_ENTRY) (ChangeLogDesc->Tail + 1);


    while ( ( ChangeLogEntry =
        NlMoveToPrevChangeLogEntry( ChangeLogDesc, ChangeLogEntry) ) != NULL ) {

        if( ChangeLogEntry->DBIndex == (UCHAR) DBIndex ) {

            if ( DownLevel ) {
                if ( ChangeLogEntry->SerialNumber.LowPart ==
                            SerialNumber.LowPart ) {
                    return ChangeLogEntry;
                }
            } else {
                if ( IsSerialNumberEqual( ChangeLogDesc, ChangeLogEntry, &SerialNumber) ){
                    if ( NeedExactMatch &&
                         ChangeLogEntry->SerialNumber.QuadPart != SerialNumber.QuadPart ) {
                        return NULL;
                    }
                    return ChangeLogEntry;
                }

            }

            PriorChangeLogEntry = ChangeLogEntry;

        }
    }

    return NULL;
}


PCHANGELOG_ENTRY
NlDuplicateChangeLogEntry(
    IN PCHANGELOG_ENTRY ChangeLogEntry,
    OUT LPDWORD ChangeLogEntrySize OPTIONAL
    )
/*++

Routine Description:

    Duplicate the specified changelog entry into an allocated buffer.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogEntry -- points to the changelog entry to duplicate

    ChangeLogEntrySize - Optionally returns the size (in bytes) of the
        returned change log entry.

Return Value:

    NULL - Not enough memory to duplicate the change log entry

    Non-NULL - returns a pointer to the duplicate change log entry.  This buffer
        must be freed via NetpMemoryFree.

--*/
{
    PCHANGELOG_ENTRY TempChangeLogEntry = NULL;
    ULONG Size;
    PCHANGELOG_BLOCK_HEADER ChangeLogBlock;

    ChangeLogBlock = (PCHANGELOG_BLOCK_HEADER)
        ( (LPBYTE) ChangeLogEntry - sizeof(CHANGELOG_BLOCK_HEADER) );

    Size = ChangeLogBlock->BlockSize -
           sizeof(CHANGELOG_BLOCK_HEADER) -
           sizeof(CHANGELOG_BLOCK_TRAILER);

    TempChangeLogEntry = (PCHANGELOG_ENTRY) NetpMemoryAllocate( Size );

    if( TempChangeLogEntry == NULL ) {
        return NULL;
    }

    RtlCopyMemory( TempChangeLogEntry, ChangeLogEntry, Size );

    if ( ChangeLogEntrySize != NULL ) {
        *ChangeLogEntrySize = Size;
    }

    return TempChangeLogEntry;
}



PCHANGELOG_ENTRY
NlFindPromotionChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN LARGE_INTEGER SerialNumber,
    IN DWORD DBIndex
    )
/*++

Routine Description:

    Find the last change log entry with the same promotion count
    as SerialNumber.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    SerialNumber - Serial number containing the promotion count to query.

    DBIndex - Describes which database to find the changelog entry for.

Return Value:

    Non-NULL - returns a pointer to the duplicate change log entry.  This buffer
        must be freed via NetpMemoryFree.

    NULL - No such entry exists.

--*/
{
    PCHANGELOG_ENTRY ChangeLogEntry;
    LONG GoalPromotionCount;
    LONG PromotionCount;

    //
    // If nothing has ever been written to the change log,
    //  indicate nothing is available.
    //

    if ( ChangeLogIsEmpty( ChangeLogDesc ) ) {
        return NULL;
    }



    //
    // Search from the tail of the changelog.  For huge changelogs, this should
    // reduce the working set size since we almost always search for one of
    // the last few entries.
    //

    ChangeLogEntry = (PCHANGELOG_ENTRY) (ChangeLogDesc->Tail + 1);
    GoalPromotionCount = SerialNumber.HighPart & NlGlobalChangeLogPromotionMask;

    while ( ( ChangeLogEntry =
        NlMoveToPrevChangeLogEntry( ChangeLogDesc, ChangeLogEntry) ) != NULL ) {

        if( ChangeLogEntry->DBIndex == (UCHAR) DBIndex ) {
            PromotionCount = ChangeLogEntry->SerialNumber.HighPart & NlGlobalChangeLogPromotionMask;

            //
            // If the Current Change Log entry has a greater promotion count,
            //  continue searching backward.
            //

            if ( PromotionCount > GoalPromotionCount ) {
                continue;
            }

            //
            // If the current change log entry has a smaller promotion count,
            //  indicate we couldn't find a change log entry.
            //

            if ( PromotionCount < GoalPromotionCount ) {
                break;
            }

            //
            // Otherwise, success
            //

            return NlDuplicateChangeLogEntry( ChangeLogEntry, NULL );

        }
    }

    return NULL;
}


PCHANGELOG_ENTRY
NlGetNextDownlevelChangeLogEntry(
    ULONG DownlevelSerialNumber
    )
/*++

Routine Description:

    Find the change log entry for the delta with a serial number greater
    than the one specified.

    NOTE: This function must be called with the change log locked.

Arguments:

    DownlevelSerialNumber - The downlevel serial number

Return Value:

    Non-NULL - change log entry found.  This changelog entry must be
        deallocated using NetpMemoryFree.

    NULL - No such entry exists.

--*/
{
    PCHANGELOG_ENTRY ChangeLogEntry;
    LARGE_INTEGER SerialNumber;

    SerialNumber.QuadPart = DownlevelSerialNumber + 1;

    ChangeLogEntry = NlFindChangeLogEntry( &NlGlobalChangeLogDesc, SerialNumber, TRUE, TRUE, SAM_DB);

    if ( ChangeLogEntry == NULL ||
         ChangeLogEntry->DeltaType == DummyChangeLogEntry ) {
        return NULL;
    }

    return NlDuplicateChangeLogEntry( ChangeLogEntry, NULL );
}


PCHANGELOG_ENTRY
NlFindNextChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_ENTRY LastChangeLogEntry,
    IN DWORD DBIndex
    )
/*++

Routine Description:

    Find the next change log entry in change log following a particular
    changelog entry.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    LastChangeLogEntry - last found changelog entry.

    DBIndex - database index of the next entry to find

Return Value:

    Non-null - change log entry found

    NULL - No such entry exists.


--*/
{
    PCHANGELOG_ENTRY NextChangeLogEntry = LastChangeLogEntry;
    LARGE_INTEGER SerialNumber;

    //
    // Loop through the log finding this entry starting from the last
    // found record.
    //

    SerialNumber.QuadPart = LastChangeLogEntry->SerialNumber.QuadPart + 1;
    while ( ( NextChangeLogEntry =
        NlMoveToNextChangeLogEntry( ChangeLogDesc, NextChangeLogEntry) ) != NULL ) {

        if( NextChangeLogEntry->DBIndex == DBIndex ) {

            //
            // next log entry in the change log for
            // this database. The serial number should match.
            //

            if ( !IsSerialNumberEqual( ChangeLogDesc, NextChangeLogEntry, &SerialNumber) ) {

                NlPrint((NL_CRITICAL,
                        "NlFindNextChangeLogEntry: Serial numbers not contigous %lx %lx and %lx %lx\n",
                         NextChangeLogEntry->SerialNumber.HighPart,
                         NextChangeLogEntry->SerialNumber.LowPart,
                         SerialNumber.HighPart,
                         SerialNumber.LowPart ));

                //
                // write event log
                //

                NlWriteChangeLogCorruptEvent( STATUS_INTERNAL_DB_CORRUPTION,
                                              DBIndex );
                return NULL;

            }

            return NextChangeLogEntry;

        }
    }

    return NULL;
}


BOOLEAN
NlCompareChangeLogEntries(
    IN PCHANGELOG_ENTRY ChangeLogEntry1,
    IN PCHANGELOG_ENTRY ChangeLogEntry2
    )
/*++

Routine Description:

    The two change log entries are compared to see if the are for the same
    object.  If

Arguments:

    ChangeLogEntry1 - First change log entry to compare.

    ChangeLogEntry2 - Second change log entry to compare.

Return Value:

    TRUE - iff the change log entries are for the same object.

--*/
{
    //
    // Ensure the DbIndex is the same for both entries.
    //

    if ( ChangeLogEntry1->DBIndex != ChangeLogEntry2->DBIndex ) {
        return FALSE;
    }

    //
    // Ensure the entries both describe the same object type.
    //

    if ( ChangeLogEntry1->DeltaType >= MAX_DELETE_DELTA ) {
        NlPrint(( NL_CRITICAL,
                  "NlCompateChangeLogEntries: invalid delta type %lx\n",
                  ChangeLogEntry1->DeltaType ));
        return FALSE;
    }

    if ( ChangeLogEntry2->DeltaType >= MAX_DELETE_DELTA ) {
        NlPrint(( NL_CRITICAL,
                  "NlCompateChangeLogEntries: invalid delta type %lx\n",
                  ChangeLogEntry2->DeltaType ));
        return FALSE;
    }

    if ( NlGlobalDeleteDeltaType[ChangeLogEntry1->DeltaType] !=
         NlGlobalDeleteDeltaType[ChangeLogEntry2->DeltaType] ) {
        return FALSE;
    }

    //
    // Depending on the delta type, ensure the entries refer to the same object.
    //

    switch(ChangeLogEntry1->DeltaType) {

    case AddOrChangeGroup:
    case DeleteGroup:
    case RenameGroup:
    case AddOrChangeUser:
    case DeleteUser:
    case RenameUser:
    case ChangeGroupMembership:
    case AddOrChangeAlias:
    case DeleteAlias:
    case RenameAlias:
    case ChangeAliasMembership:

        if (ChangeLogEntry1->ObjectRid == ChangeLogEntry2->ObjectRid ) {
            return TRUE;
        }
        break;


    case AddOrChangeLsaTDomain:
    case DeleteLsaTDomain:
    case AddOrChangeLsaAccount:
    case DeleteLsaAccount:

        NlAssert( ChangeLogEntry1->Flags & CHANGELOG_SID_SPECIFIED );
        NlAssert( ChangeLogEntry2->Flags & CHANGELOG_SID_SPECIFIED );

        if( (ChangeLogEntry1->Flags & CHANGELOG_SID_SPECIFIED) == 0 ||
                (ChangeLogEntry2->Flags & CHANGELOG_SID_SPECIFIED) == 0) {
            break;
        }

        if( RtlEqualSid(
            (PSID)((LPBYTE)ChangeLogEntry1 + sizeof(CHANGELOG_ENTRY)),
            (PSID)((LPBYTE)ChangeLogEntry2 + sizeof(CHANGELOG_ENTRY))) ) {

            return TRUE;
        }
        break;

    case AddOrChangeLsaSecret:
    case DeleteLsaSecret:

        NlAssert( ChangeLogEntry1->Flags & CHANGELOG_NAME_SPECIFIED );
        NlAssert( ChangeLogEntry2->Flags & CHANGELOG_NAME_SPECIFIED );

        if( (ChangeLogEntry1->Flags & CHANGELOG_NAME_SPECIFIED) == 0 ||
                (ChangeLogEntry2->Flags & CHANGELOG_NAME_SPECIFIED) == 0 ) {
            break;
        }

        if( _wcsicmp(
            (LPWSTR)((LPBYTE)ChangeLogEntry1 + sizeof(CHANGELOG_ENTRY)),
            (LPWSTR)((LPBYTE)ChangeLogEntry2 + sizeof(CHANGELOG_ENTRY))
            ) == 0 ) {

            return TRUE;
        }
        break;

    case AddOrChangeLsaPolicy:
    case AddOrChangeDomain:
        return TRUE;

    default:
        NlPrint((NL_CRITICAL,
                 "NlCompareChangeLogEntries: invalid delta type %lx\n",
                 ChangeLogEntry1->DeltaType ));
        break;
    }

    return FALSE;
}


PCHANGELOG_ENTRY
NlGetNextChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN LARGE_INTEGER SerialNumber,
    IN DWORD DBIndex,
    OUT LPDWORD ChangeLogEntrySize OPTIONAL
    )
/*++

Routine Description:

    Search the change log entry in change log cache for a given serial
    number.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer to use.

    SerialNumber - Serial number preceeding that of the entry to find.

    DBIndex - Describes which database to find the changelog entry for.

    ChangeLogEntrySize - Optionally returns the size (in bytes) of the
        returned change log entry.

Return Value:

    Non-NULL - returns a pointer to a duplicate of the found change log entry.
        This buffer must be freed via NetpMemoryFree.

    NULL - No such entry exists.



--*/
{
    PCHANGELOG_ENTRY ChangeLogEntry;


    //
    // Increment the serial number, get the change log entry, duplicate it
    //

    LOCK_CHANGELOG();
    SerialNumber.QuadPart += 1;
    ChangeLogEntry = NlFindChangeLogEntry(
                ChangeLogDesc,
                SerialNumber,
                FALSE,
                FALSE,
                DBIndex );

    if ( ChangeLogEntry != NULL ) {
        ChangeLogEntry = NlDuplicateChangeLogEntry(ChangeLogEntry, ChangeLogEntrySize );
    }

    UNLOCK_CHANGELOG();
    return ChangeLogEntry;
}


PCHANGELOG_ENTRY
NlGetNextUniqueChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN LARGE_INTEGER SerialNumber,
    IN DWORD DBIndex,
    OUT LPDWORD ChangeLogEntrySize OPTIONAL
    )
/*++

Routine Description:

    Search the change log entry in change log cache for a given serial
    number. If there are more than one change log entry for the same
    object then this routine will return the last log entry of that
    object.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer to use.

    SerialNumber - Serial number preceeding that of the entry to find.

    DBIndex - Describes which database to find the changelog entry for.

    ChangeLogEntrySize - Optionally returns the size (in bytes) of the
        returned change log entry.

Return Value:

    Non-NULL - returns a pointer to a duplicate of the found change log entry.
        This buffer must be freed via NetpMemoryFree.

    NULL - No such entry exists.



--*/
{
    PCHANGELOG_ENTRY ChangeLogEntry;
    PCHANGELOG_ENTRY NextChangeLogEntry;
    PCHANGELOG_ENTRY FoundChangeLogEntry;


    //
    // Get the first entry we want to deal with.
    //
    SerialNumber.QuadPart += 1;
    ChangeLogEntry = NlFindChangeLogEntry(
                ChangeLogDesc,
                SerialNumber,
                FALSE,
                FALSE,
                DBIndex );

    if ( ChangeLogEntry == NULL ) {
        return NULL;
    }


    //
    // Skip over any leading dummy change log entries
    //

    while ( ChangeLogEntry->DeltaType == DummyChangeLogEntry ) {

        //
        // Get the next change log entry to compare with.
        //

        NextChangeLogEntry = NlFindNextChangeLogEntry( ChangeLogDesc,
                                                       ChangeLogEntry,
                                                       DBIndex );

        if( NextChangeLogEntry == NULL ) {
            return NULL;
        }

        //
        // skip 'ChangeLogEntry' entry
        //

        ChangeLogEntry = NextChangeLogEntry;
    }


    //
    // Check to see if the next entry is a "duplicate" of this entry.
    //

    FoundChangeLogEntry = ChangeLogEntry;

    for (;;) {

        //
        // Don't walk past a change log entry for a promotion.
        //  Promotions don't happen very often, but passing the BDC the
        //  change log entry will allow it to do a better job of building
        //  its own change log.
        //

        if ( FoundChangeLogEntry->Flags & CHANGELOG_PDC_PROMOTION ) {
            break;
        }

        //
        // Get the next change log entry to compare with.
        //

        NextChangeLogEntry = NlFindNextChangeLogEntry( ChangeLogDesc,
                                                       ChangeLogEntry,
                                                       DBIndex );

        if( NextChangeLogEntry == NULL ) {
            break;
        }

        //
        // Just skip any dummy entries.
        //

        if ( NextChangeLogEntry->DeltaType == DummyChangeLogEntry ) {
            ChangeLogEntry = NextChangeLogEntry;
            continue;
        }

        //
        // if 'FoundChangeLogEntry' and 'NextChangeLogEntry' entries are
        // for different objects or are different delta types.
        //  then return 'FoundChangeLogEntry' to the caller.
        //

        if ( FoundChangeLogEntry->DeltaType != NextChangeLogEntry->DeltaType ||
             !NlCompareChangeLogEntries( FoundChangeLogEntry, NextChangeLogEntry ) ){
            break;

        }


        //
        // Skip 'FoundChangeLogEntry' entry
        // Mark this entry as the being the best one to return.
        //

        ChangeLogEntry = NextChangeLogEntry;
        FoundChangeLogEntry = ChangeLogEntry;
    }

    return NlDuplicateChangeLogEntry(FoundChangeLogEntry, ChangeLogEntrySize );
}


BOOL
NlRecoverChangeLog(
    PCHANGELOG_ENTRY OrigChangeLogEntry
    )

/*++

Routine Description:

    This routine traverses the change log list from current change log entry
    determines whether the current change log can be ignored under
    special conditions.

Arguments:

    OrigChangeLogEntry - pointer to log structure that is under investigation.

Return Value:

    TRUE - if the given change log can be ignored.

    FALSE - otherwise.

--*/
{
    PCHANGELOG_ENTRY NextChangeLogEntry;
    BOOLEAN ReturnValue;

    //
    // Find the original change log entry.
    //

    LOCK_CHANGELOG();
    NextChangeLogEntry = NlFindChangeLogEntry(
                    &NlGlobalChangeLogDesc,
                    OrigChangeLogEntry->SerialNumber,
                    FALSE,      // Not downlevel
                    FALSE,      // Not exact match
                    OrigChangeLogEntry->DBIndex );

    if (NextChangeLogEntry == NULL) {
        ReturnValue = FALSE;
        goto Cleanup;
    }

    if ( OrigChangeLogEntry->DeltaType >= MAX_DELETE_DELTA ) {
        NlPrint(( NL_CRITICAL,
                  "NlRecoverChangeLog: invalid delta type %lx\n",
                  OrigChangeLogEntry->DeltaType ));
        ReturnValue = FALSE;
        goto Cleanup;
    }

    //
    // Loop for each entry with a greater serial number.
    //

    for (;;) {

        NextChangeLogEntry = NlFindNextChangeLogEntry(
                                    &NlGlobalChangeLogDesc,
                                    NextChangeLogEntry,
                                    OrigChangeLogEntry->DBIndex );

        if (NextChangeLogEntry == NULL) {
            break;
        }

        //
        // If the delta we found is the type that deletes the original delta,
        //  and the objects described by the two deltas are the same,
        //  tell the caller to not worry about the original delta failing.
        //

        if ( NextChangeLogEntry->DeltaType ==
             NlGlobalDeleteDeltaType[OrigChangeLogEntry->DeltaType] &&
             NlCompareChangeLogEntries( OrigChangeLogEntry,
                                        NextChangeLogEntry ) ) {
            ReturnValue = TRUE;
            goto Cleanup;
        }

    }

    ReturnValue = FALSE;

Cleanup:
    UNLOCK_CHANGELOG();
    return ReturnValue;

}


VOID
NlVoidChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_ENTRY ChangeLogEntry,
    IN BOOLEAN FlushIt
    )
/*++

Routine Description:

    Mark a changelog entry as void.  If there are no more change log entries in the file,
    the file is deleted.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer to use.

    ChangeLogEntry -- Change Log Entry to mark as void.

    FlushIt - TRUE if the bytes are to be flushed to disk

Return Value:

    None.

--*/
{
    DWORD DBIndex = ChangeLogEntry->DBIndex;


    //
    // Mark the changelog entry as being deleted.
    //  (and force the change to disk).
    //

    NlPrint((NL_CHANGELOG,
            "NlVoidChangeLogEntry: %lx %lx: deleting change log entry.\n",
            ChangeLogEntry->SerialNumber.HighPart,
            ChangeLogEntry->SerialNumber.LowPart ));

    ChangeLogDesc->EntryCount[DBIndex] --;

    ChangeLogEntry->DBIndex = VOID_DB;

    (VOID) NlWriteChangeLogBytes(
                           ChangeLogDesc,
                           &ChangeLogEntry->DBIndex,
                           sizeof(ChangeLogEntry->DBIndex),
                           FlushIt );


    return;
}


VOID
NlDeleteChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN DWORD DBIndex,
    IN LARGE_INTEGER SerialNumber
    )
/*++

Routine Description:

    This routine deletes the change log entry with the particular serial number.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer to use.

    DBIndex - Describes which database to find the changelog entry for.

    SerialNumber - Serial number of the entry to find.

Return Value:

    None.

--*/
{
    PCHANGELOG_ENTRY ChangeLogEntry;



    //
    // Find the specified change log entry.
    //

    LOCK_CHANGELOG();
    ChangeLogEntry = NlFindChangeLogEntry(
                ChangeLogDesc,
                SerialNumber,
                FALSE,      // Not downlevel
                TRUE,       // Exact match
                DBIndex );

    if (ChangeLogEntry != NULL) {

        //
        // Mark the changelog entry as being deleted.
        //  (and force the change to disk).
        //

        NlVoidChangeLogEntry( ChangeLogDesc, ChangeLogEntry, TRUE );

    } else {
        NlPrint((NL_CRITICAL,
                "NlDeleteChangeLogEntry: %lx %lx: couldn't find change log entry.\n",
                SerialNumber.HighPart,
                SerialNumber.LowPart ));
    }

    UNLOCK_CHANGELOG();
    return;
}


NTSTATUS
NlCopyChangeLogEntry(
    IN BOOLEAN SourceIsVersion3,
    IN PCHANGELOG_ENTRY SourceChangeLogEntry,
    IN PCHANGELOG_DESCRIPTOR DestChangeLogDesc
)
/*++

Routine Description:

    Copies the specified change log entry for the specified "source" change log to
    the specified "destination" change log.  The caller is responsible for flushing the
    entry to disk by calling NlFlushChangeLog.

    NOTE: This function must be called with the change log locked.

Arguments:

    SourceIsVersion3 - True if the source is a version 3 change log entry

    SourceChangeLogEntry -- The particular entry to copy

    DestChangeLogDesc -- a description of the ChangelogBuffer to copy to

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;
    CHANGELOG_ENTRY DestChangeLogEntry;
    PSID ObjectSid;
    UNICODE_STRING ObjectNameString;
    PUNICODE_STRING ObjectName;

    //
    // If this entry has been marked void, ignore it.
    //

    if ( SourceChangeLogEntry->DBIndex == VOID_DB ) {
        return STATUS_SUCCESS;
    }

    //
    // Build a version 4 changelog entry from a version 3 one.
    //

    ObjectSid = NULL;
    ObjectName = NULL;

    if ( SourceIsVersion3 ) {
        PCHANGELOG_ENTRY_V3 Version3;

        Version3 = (PCHANGELOG_ENTRY_V3)SourceChangeLogEntry;

        DestChangeLogEntry.SerialNumber = Version3->SerialNumber;
        DestChangeLogEntry.DeltaType = (BYTE) Version3->DeltaType;
        DestChangeLogEntry.DBIndex = Version3->DBIndex;
        DestChangeLogEntry.ObjectRid = Version3->ObjectRid;
        DestChangeLogEntry.Flags = 0;
        if ( Version3->ObjectSidOffset ) {
            ObjectSid = (PSID)(((LPBYTE)Version3) +
                        Version3->ObjectSidOffset);
        }
        if ( Version3->ObjectNameOffset ) {
            RtlInitUnicodeString( &ObjectNameString,
                                  (LPWSTR)(((LPBYTE)Version3) +
                                    Version3->ObjectNameOffset));
            ObjectName = &ObjectNameString;
        }

    //
    // Build a version 4 changelog entry from a version 4 one.
    //
    } else {

        RtlCopyMemory( &DestChangeLogEntry, SourceChangeLogEntry, sizeof(DestChangeLogEntry) );

        if ( SourceChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED ) {
            ObjectSid = (PSID)(((LPBYTE)SourceChangeLogEntry) +
                        sizeof(CHANGELOG_ENTRY));
        } else if ( SourceChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED ) {
            RtlInitUnicodeString( &ObjectNameString,
                                  (LPWSTR)(((LPBYTE)SourceChangeLogEntry) +
                                  sizeof(CHANGELOG_ENTRY)));
            ObjectName = &ObjectNameString;
        }


    }


    Status = NlWriteChangeLogEntry( DestChangeLogDesc,
                                    &DestChangeLogEntry,
                                    ObjectSid,
                                    ObjectName,
                                    FALSE );    // Don't flush to disk

    return Status;
}


BOOLEAN
NlFixChangeLog(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN DWORD DBIndex,
    IN LARGE_INTEGER SerialNumber
    )
/*++

Routine Description:

    This routine scans the change log and 'removes' all change log entries
    with a serial number greater than the one specified.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer to use.

    DBIndex - Describes which database to find the changelog entry for.

    SerialNumber - Serial number of the entry to find.

Return Value:

    TRUE -- if the entry specied by SerialNumber was found.

--*/
{
    PCHANGELOG_ENTRY ChangeLogEntry;
    BOOLEAN SkipFirstEntry = TRUE;

    //
    // In all cases,
    //  the new serial number of the change log is the one passed in.
    //

    ChangeLogDesc->SerialNumber[DBIndex] = SerialNumber;

    //
    // Find the specified change log entry.
    //

    ChangeLogEntry = NlFindChangeLogEntry(
                            ChangeLogDesc,
                            SerialNumber,
                            FALSE,      // Not downlevel
                            TRUE,       // exact match
                            DBIndex );

    if (ChangeLogEntry == NULL) {

        //
        // If we can't find the entry,
        //  simply start from the beginning and delete all entries for this
        //  database.
        //

        ChangeLogEntry = NlFindFirstChangeLogEntry( ChangeLogDesc, DBIndex );
        SkipFirstEntry = FALSE;

        if (ChangeLogEntry == NULL) {
            return FALSE;
        }
    }


    //
    // Loop for each entry with a greater serial number.
    //

    for (;;) {

        //
        // Skip past the previous entry.
        //
        // Don't do this the first time if we want to start at the very beginning.
        //

        if ( SkipFirstEntry ) {
            ChangeLogEntry = NlFindNextChangeLogEntry( ChangeLogDesc,
                                                       ChangeLogEntry,
                                                       DBIndex );
        } else {
            SkipFirstEntry = TRUE;
        }


        if (ChangeLogEntry == NULL) {
            break;
        }


        //
        // Mark the changelog entry as being deleted.
        //  (but don't flush to disk yet).
        //

        NlVoidChangeLogEntry( ChangeLogDesc, ChangeLogEntry, FALSE );

        //
        // If deleting the change log entry caused the changelog to be deleted,
        //  exit now since 'ChangeLogEntry' points to freed memory.
        //

        if ( ChangeLogDesc->EntryCount[DBIndex] == 0 ) {
            break;
        }

    }

    //
    // Flush all the changes to disk.
    //

    (VOID) NlFlushChangeLog( ChangeLogDesc );


    return TRUE;
}


BOOL
NlValidateChangeLogEntry(
    IN PCHANGELOG_ENTRY ChangeLogEntry,
    IN DWORD ChangeLogEntrySize
    )
/*++

Routine Description:

    Validate the a ChangeLogEntry is structurally sound.

Arguments:

    ChangeLogEntry: pointer to a change log entry.

    ChangeLogEntrySize -- Size (in bytes) of the change log entry not including
        header and trailer.

Return Value:

    TRUE:  if the given entry is valid

    FALSE: otherwise.

--*/
{

    //
    // Ensure the entry is big enough.
    //

    if ( ChangeLogEntrySize < sizeof(CHANGELOG_ENTRY) ) {
        NlPrint((NL_CRITICAL,
                "NlValidateChangeLogEntry: Entry size is too small: %ld\n",
                ChangeLogEntrySize ));
        return FALSE;
    }

    //
    // Ensure strings are zero terminated.
    //

    if ( ChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED ) {

        LPWSTR ZeroTerminator = (LPWSTR)(ChangeLogEntry+1);
        BOOLEAN ZeroTerminatorFound = FALSE;

        if ( ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED ) {
            NlPrint((NL_CRITICAL,
                    "NlValidateChangeLogEntry: %lx %lx: both Name and Sid specified.\n",
                    ChangeLogEntry->SerialNumber.HighPart,
                    ChangeLogEntry->SerialNumber.LowPart ));
            return FALSE;
        }

        while ( (DWORD)((LPBYTE)ZeroTerminator - (LPBYTE) ChangeLogEntry) <
                ChangeLogEntrySize - 1 ) {

            if ( *ZeroTerminator == L'\0' ) {
                ZeroTerminatorFound = TRUE;
                break;
            }
            ZeroTerminator ++;
        }

        if ( !ZeroTerminatorFound ) {
            NlPrint((NL_CRITICAL,
                    "NlValidateChangeLogEntry: %lx %lx: String not zero terminated. (no string)\n",
                    ChangeLogEntry->SerialNumber.HighPart,
                    ChangeLogEntry->SerialNumber.LowPart ));
            return FALSE;
        }

    }

    //
    // Ensure the sid is entirely within the block.
    //

    if ( ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED ) {

        if ( GetSidLengthRequired(0) >
                ChangeLogEntrySize - sizeof(*ChangeLogEntry) ||
             RtlLengthSid( (PSID)(ChangeLogEntry+1) ) >
                ChangeLogEntrySize - sizeof(*ChangeLogEntry) ) {
            NlPrint((NL_CRITICAL,
                    "NlValidateChangeLogEntry: %lx %lx: Sid too large.\n",
                    ChangeLogEntry->SerialNumber.HighPart,
                    ChangeLogEntry->SerialNumber.LowPart ));
            return FALSE;
        }

    }

    //
    // Ensure the database # is valid.
    //  ARGH! Allow VOID_DB.
    //

    if ( ChangeLogEntry->DBIndex > NUM_DBS ) {
        NlPrint((NL_CRITICAL,
                 "NlValidateChangeLogEntry: %lx %lx: DBIndex is bad %ld.\n",
                 ChangeLogEntry->SerialNumber.HighPart,
                 ChangeLogEntry->SerialNumber.LowPart,
                 ChangeLogEntry->DBIndex ));
        return FALSE;
    }

    return TRUE;
}


BOOL
ValidateThisEntry(
    IN OUT PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_ENTRY ChangeLogEntry,
    IN OUT PLARGE_INTEGER NextSerialNumber,
    IN BOOLEAN InitialCall
    )
/*++

Routine Description:

    Determine the given log entry is a valid next log in the change log
    list.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer to validate.

    ChangeLogEntry:   pointer to a new log entry.

    NextSerialNumber: pointer to an array of serial numbers.
        (NULL if serial numbers aren't to be validated.)

    Initialcall: TRUE iff SerialNumber array should be initialized.

Return Value:

    TRUE:  if the given entry is a valid next entry.

    FALSE: otherwise.

Assumed: non-empty ChangeLog list.

--*/
{
    PCHANGELOG_BLOCK_HEADER Block = ((PCHANGELOG_BLOCK_HEADER)ChangeLogEntry) - 1;

    //
    // Do Version 3 specific things
    //

    if ( ChangeLogDesc->Version3 ) {

        //
        // Ensure the block is big enough.
        //

        if ( Block->BlockSize <
            sizeof(CHANGELOG_ENTRY_V3) + sizeof(CHANGELOG_BLOCK_HEADER) ) {
            NlPrint((NL_CRITICAL,
                    "ValidateThisEntry: Block size is too small: %ld\n",
                    Block->BlockSize ));
            return FALSE;
        }

        //
        // Ensure the database # is valid.
        //

        if ( ChangeLogEntry->DBIndex > NUM_DBS ) {
            NlPrint((NL_CRITICAL,
                     "ValidateThisEntry: %lx %lx: DBIndex is bad %ld.\n",
                     ChangeLogEntry->SerialNumber.HighPart,
                     ChangeLogEntry->SerialNumber.LowPart,
                     ChangeLogEntry->DBIndex ));
            return FALSE;
        }


    //
    // Do version 4 specific validation
    //

    } else {

        //
        // Ensure the block is big enough.
        //

        if ( Block->BlockSize <
            sizeof(CHANGELOG_BLOCK_HEADER) +
            sizeof(CHANGELOG_ENTRY) +
            sizeof(CHANGELOG_BLOCK_TRAILER) ) {

            NlPrint((NL_CRITICAL,
                    "ValidateThisEntry: Block size is too small: %ld\n",
                    Block->BlockSize ));
            return FALSE;
        }


        //
        // Validate the contents of the block itself.
        //

        if ( !NlValidateChangeLogEntry(
                    ChangeLogEntry,
                    Block->BlockSize -
                        sizeof(CHANGELOG_BLOCK_HEADER) -
                        sizeof(CHANGELOG_BLOCK_TRAILER) ) ) {

            return FALSE;
        }

    }


    //
    // Validate the serial number sequence.
    //

    if ( ChangeLogEntry->DBIndex != VOID_DB && NextSerialNumber != NULL ) {

        //
        // If this is the first entry in the database,
        //  Save its serial number.
        //

        if ( NextSerialNumber[ChangeLogEntry->DBIndex].QuadPart == 0 ) {

            //
            // first entry for this database
            //

            NextSerialNumber[ChangeLogEntry->DBIndex] = ChangeLogEntry->SerialNumber;


        //
        // Otherwise ensure the serial number is the value expected.
        //

        } else {

            if ( !IsSerialNumberEqual(
                        ChangeLogDesc,
                        ChangeLogEntry,
                        &NextSerialNumber[ChangeLogEntry->DBIndex] )){

                    NlPrint((NL_CRITICAL,
                            "ValidateThisEntry: %lx %lx: Serial number is bad. s.b. %lx %lx\n",
                            ChangeLogEntry->SerialNumber.HighPart,
                            ChangeLogEntry->SerialNumber.LowPart,
                            NextSerialNumber[ChangeLogEntry->DBIndex].HighPart,
                            NextSerialNumber[ChangeLogEntry->DBIndex].LowPart ));
                    return FALSE;
            }
        }

        //
        // Increment next expected serial number
        //

        NextSerialNumber[ChangeLogEntry->DBIndex].QuadPart =
            ChangeLogEntry->SerialNumber.QuadPart + 1;


        //
        // The current entry specifies the highest serial number for its
        //  database.
        //

        if ( InitialCall ) {
            ChangeLogDesc->SerialNumber[ChangeLogEntry->DBIndex] =
                ChangeLogEntry->SerialNumber;
            ChangeLogDesc->EntryCount[ChangeLogEntry->DBIndex] ++;
        }

    }


    return TRUE;
}


BOOL
ValidateBlock(
    IN OUT PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_BLOCK_HEADER Block,
    IN OUT LARGE_INTEGER *NextSerialNumber,
    IN BOOLEAN InitialCall
    )
/*++

Routine Description:

    Validate a changelog block.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer to validate.

    Block:   pointer to the change log block to validate

    NextSerialNumber: pointer to an array of serial numbers.
        (NULL if serial numbers aren't to be validated.)

    InitializeCall: TRUE iff SerialNumber array should be initialized.

Return Value:

    TRUE:  if the given entry is a valid next entry.

    FALSE: otherwise.

--*/
{
    //
    // Ensure Block size is properly aligned.
    //

    if ( Block->BlockSize != ROUND_UP_COUNT(Block->BlockSize, ALIGN_WORST) ) {
        NlPrint((NL_CRITICAL,
                "ValidateBlock: Block size alignment is bad.\n" ));
        return FALSE;
    }


    //
    // Ensure the block is contained in the cache.
    //

    if ( Block->BlockSize > ChangeLogDesc->BufferSize ||
         ((LPBYTE)Block + Block->BlockSize) > ChangeLogDesc->BufferEnd ) {
        NlPrint((NL_CRITICAL,
                 "ValidateBlock: Block extends beyond end of buffer.\n" ));
        return FALSE;

    }


    //
    // Do Version 3 specific things
    //

    if ( ChangeLogDesc->Version3 ) {

        //
        // Ensure the block is big enough.
        //

        if ( Block->BlockSize < sizeof(CHANGELOG_BLOCK_HEADER) ) {
            NlPrint((NL_CRITICAL,
                    "ValidateBlock: Block size is too small: %ld\n",
                    Block->BlockSize ));
            return FALSE;
        }


    //
    // Do version 4 specific validation
    //

    } else {

        //
        // Ensure the block is big enough.
        //

        if ( Block->BlockSize <
            sizeof(CHANGELOG_BLOCK_HEADER) +
            sizeof(CHANGELOG_BLOCK_TRAILER) ) {

            NlPrint((NL_CRITICAL,
                    "ValidateBlock: Block size is too small: %ld\n",
                    Block->BlockSize ));
            return FALSE;
        }

        //
        // Ensure trailer and header match
        //

        if ( ChangeLogBlockTrailer(Block)->BlockSize != Block->BlockSize ) {
            NlPrint((NL_CRITICAL,
                    "ValidateBlock: Header/Trailer block size mismatch: %ld %ld (Trailer fixed).\n",
                    Block->BlockSize,
                    ChangeLogBlockTrailer(Block)->BlockSize ));
            ChangeLogBlockTrailer(Block)->BlockSize = Block->BlockSize;
        }


    }

    //
    // Free blocks have no other checking to do
    //
    switch ( Block->BlockState ) {
    case BlockFree:

        break;

    //
    // Used blocks have more checking to do.
    //

    case BlockUsed:

        if ( !ValidateThisEntry( ChangeLogDesc,
                                 (PCHANGELOG_ENTRY)(Block+1),
                                 NextSerialNumber,
                                 InitialCall )) {
            return FALSE;
        }
        break;


    //
    // The hole is allowed only at the end of the buffer.
    //

    case BlockHole:
        if ( (LPBYTE)Block + Block->BlockSize != ChangeLogDesc->BufferEnd ) {
            NlPrint((NL_CRITICAL,
                     "ValidateBlock: Hole block in middle of buffer (buffer truncated).\n" ));
            Block->BlockSize = (ULONG)(ChangeLogDesc->BufferEnd - (LPBYTE)Block);
        }
        break;

    default:
        NlPrint((NL_CRITICAL,
                 "ValidateBlock: Invalid block type %ld.\n",
                 Block->BlockState ));
        return FALSE;
    }


    return TRUE;
}


BOOL
ValidateList(
    IN OUT PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN BOOLEAN InitialCall
    )
/*++

Routine Description:

    Determine the given header is a valid header.  It is done by
    traversing the circular buffer starting from the given header and
    validate each entry.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer to validate.

    InitialCall: TRUE iff SerialNumber Array and EntryCount should
        be initialized.

Return Value:

    TRUE:  if the given header is valid.

    FALSE: otherwise


--*/
{

    LARGE_INTEGER    NextSerialNumber[NUM_DBS];
    PCHANGELOG_BLOCK_HEADER ChangeLogBlock;
    DWORD j;

    //
    // setup a  NextSerialNumber array first.
    //

    for( j = 0; j < NUM_DBS; j++ ) {

        NextSerialNumber[j].QuadPart = 0;

        if ( InitialCall ) {
            ChangeLogDesc->SerialNumber[j].QuadPart = 0;
        }
    }

    //
    // The cache is valid if it is empty.
    //

    if ( ChangeLogIsEmpty(ChangeLogDesc) ) {
        return TRUE;
    }

    //
    // Validate each block
    //

    for ( ChangeLogBlock = ChangeLogDesc->Head;
            ;
          ChangeLogBlock = NlMoveToNextChangeLogBlock( ChangeLogDesc, ChangeLogBlock) ) {

        //
        // Validate the block.
        //

        if( !ValidateBlock( ChangeLogDesc,
                            ChangeLogBlock,
                            NextSerialNumber,
                            InitialCall) ) {
            return FALSE;
        }

        //
        // Stop when we get to the end.
        //
        if ( ChangeLogBlock->BlockState == BlockFree ) {
            break;
        }

    }

    return TRUE;

}


BOOL
InitChangeLogHeadAndTail(
    IN OUT PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN BOOLEAN NewChangeLog
    )

/*++

Routine Description:

    This function initializes the global head and tail pointers of change
    log block list.  The change log cache is made up of variable length
    blocks, each block has a header containing the length of the block
    and the block state ( BlockFree, BlockUsed and BlockHole ).  The
    last block in the change log block list is always the free block,
    all other blocks in the cache are used blocks except a block at the
    end of the cache may be a unused block known as 'hole' block.  So
    the head of the change log block list is the block that is just next
    to the free block and the tail is the free block.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer to analyze.
        On entry, Buffer and BufferSize describe the allocated block containing
        the change log read from disk.
        On TRUE return, all the fields are filled in.

    NewChangeLog -- True if no entries are in the change log

Return Value:

    TRUE: if valid head and tail are successfully initialized.

    FALSE: if valid head and tail can't be determined.  This may be due
        to the corrupted change log file.

--*/
{
    PCHANGELOG_BLOCK_HEADER Block;
    PCHANGELOG_BLOCK_HEADER FreeBlock;
    DWORD i;

    ChangeLogDesc->BufferEnd =
        ChangeLogDesc->Buffer + ChangeLogDesc->BufferSize;

    //
    // Compute the address of the first physical cache entry.
    //
    ChangeLogDesc->FirstBlock = (PCHANGELOG_BLOCK_HEADER)
                        (ChangeLogDesc->Buffer +
                        sizeof(CHANGELOG_SIG));

    ChangeLogDesc->FirstBlock = (PCHANGELOG_BLOCK_HEADER)
        ROUND_UP_POINTER ( ChangeLogDesc->FirstBlock, ALIGN_WORST );

    //
    // Clear the count of entries in the change log and the serial numbers
    //  (We'll compute them later when we call ValidateList().)

    for( i = 0; i < NUM_DBS; i++ ) {
        ChangeLogDesc->EntryCount[i] = 0;
        ChangeLogDesc->SerialNumber[i].QuadPart = 0;
    }


    //
    // If this is a new change log,
    //  Initialize the Change Log Cache to zero.
    //

    Block = ChangeLogDesc->FirstBlock;

    if ( NewChangeLog ) {

        RtlZeroMemory(ChangeLogDesc->Buffer, ChangeLogDesc->BufferSize);
        (VOID) strcpy( (PCHAR)ChangeLogDesc->Buffer, CHANGELOG_SIG);

        Block->BlockState = BlockFree;

        Block->BlockSize =
            (ULONG)(ChangeLogDesc->BufferEnd - (LPBYTE)ChangeLogDesc->FirstBlock);
        ChangeLogBlockTrailer(Block)->BlockSize = Block->BlockSize;

        ChangeLogDesc->Version3 = FALSE;
        ChangeLogDesc->Head = ChangeLogDesc->Tail = ChangeLogDesc->FirstBlock;
        return TRUE;
    }

    //
    // If no entries have been written to the changelog,
    //  simply initialize the head and tail to the block start.
    //

    if ( ChangeLogIsEmpty( ChangeLogDesc ) ) {

        ChangeLogDesc->Head = ChangeLogDesc->Tail = ChangeLogDesc->FirstBlock;

        NlPrint((NL_CHANGELOG,
                 "InitChangeLogHeadAndTail: Change log is empty.\n" ));
        return TRUE;
    }

    //
    // Loop through the cache looking for a free block.
    //

    FreeBlock = NULL;

    do {

        //
        // Validate the block's integrity.
        //

        if ( !ValidateBlock( ChangeLogDesc, Block, NULL, FALSE )) {
            return FALSE;
        }

        //
        // Just remember where the free block is.
        //

        if ( Block->BlockState == BlockFree ) {

            if ( FreeBlock != NULL ) {
                NlPrint((NL_CRITICAL,
                         "InitChangeLogHeadAndTail: Multiple free blocks found.\n" ));
                return FALSE;
            }

            FreeBlock = Block;
        }

        //
        // Move to next block
        //

        Block = (PCHANGELOG_BLOCK_HEADER) ((LPBYTE)Block + Block->BlockSize);

    } while ( (LPBYTE)Block < ChangeLogDesc->BufferEnd );

    //
    // If we didn't find a free block,
    //  the changelog is corrupt.
    //

    if ( FreeBlock == NULL ) {
        NlPrint((NL_CRITICAL,
                 "InitChangeLogHeadAndTail: No Free block anywhere in buffer.\n" ));
        return FALSE;
    }

    //
    // We found the free block.
    //  (The tail pointer always points to the free block.)
    //

    ChangeLogDesc->Tail = FreeBlock;

    //
    // If free block is the last block in the change log block
    // list, the head of the list is the first block in
    // the list.
    //
    if( ((LPBYTE)FreeBlock + FreeBlock->BlockSize) >=
                            ChangeLogDesc->BufferEnd ) {

        ChangeLogDesc->Head = ChangeLogDesc->FirstBlock;

    //
    //
    // Otherwise, the head of the list is immediately after the tail.
    //

    } else {

        ChangeLogDesc->Head = (PCHANGELOG_BLOCK_HEADER)
            ((LPBYTE)FreeBlock + FreeBlock->BlockSize);
    }


    //
    // Validate the list before returning from here.
    //

    if ( !ValidateList( ChangeLogDesc, TRUE) ) {
        return FALSE;
    }

    return TRUE;
}


NTSTATUS
NlResetChangeLog(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN DWORD NewChangeLogSize
    )
/*++

Routine Description:

    This function resets the change log cache and change log file.  This
    function is called from InitChangeLog() function to afresh the
    change log.  This function may also be called from
    I_NetNotifyDelta() function when the serial number of the new entry
    is out of order.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    NewChangeLogSize -- Size (in bytes) of the new change log.

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;

    NlPrint((NL_CHANGELOG, "%s log being reset.\n",
              ChangeLogDesc->TempLog ? "TempChange" : "Change" ));

    //
    // Start with a clean slate.
    //

    NlCloseChangeLogFile( ChangeLogDesc );

    //
    // Allocate a buffer.
    //

    ChangeLogDesc->BufferSize = NewChangeLogSize;

    ChangeLogDesc->Buffer = NetpMemoryAllocate(ChangeLogDesc->BufferSize );

    if ( ChangeLogDesc->Buffer == NULL ) {
        return STATUS_NO_MEMORY;
    }


    //
    // Initialize the Change Log Cache to zero.
    //

    (VOID) InitChangeLogHeadAndTail( ChangeLogDesc, TRUE );

    //
    // Write the cache to the file.
    //

    Status = NlWriteChangeLogBytes( ChangeLogDesc,
                                    ChangeLogDesc->Buffer,
                                    ChangeLogDesc->BufferSize,
                                    TRUE ); // Flush the bytes to disk

    return Status;
}


NTSTATUS
I_NetLogonReadChangeLog(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    )
/*++

Routine Description:

    This function returns a portion of the change log to the caller.

    The caller asks for the first portion of the change log by passing zero as
    the InContext/InContextSize.  Each call passes out an OutContext that
    indentifies the last change returned to the caller.  That context can
    be passed in on a subsequent call to I_NetlogonReadChangeLog.

Arguments:

    InContext - Opaque context describing the last entry to have been previously
        returned.  Specify NULL to request the first entry.

    InContextSize - Size (in bytes) of InContext.  Specify 0 to request the
        first entry.

    ChangeBufferSize - Specifies the size (in bytes) of the passed in ChangeBuffer.

    ChangeBuffer - Returns the next several entries from the change log.
        Buffer must be DWORD aligned.

    BytesRead - Returns the size (in bytes) of the entries returned in ChangeBuffer.

    OutContext - Returns an opaque context describing the last entry returned
        in ChangeBuffer.  NULL is returned if no entries were returned.
        The buffer must be freed using I_NetLogonFree

    OutContextSize - Returns the size (in bytes) of OutContext.


Return Value:

    STATUS_MORE_ENTRIES - More entries are available.  This function should
        be called again to retrieve the remaining entries.

    STATUS_SUCCESS - No more entries are currently available.  Some entries may
        have been returned on this call.  This function need not be called again.
        However, the caller can determine if new change log entries were
        added to the log, by calling this function again passing in the returned
        context.

    STATUS_INVALID_PARAMETER - InContext is invalid.
        Either it is too short or the change log entry described no longer
        exists in the change log.

    STATUS_INVALID_DOMAIN_ROLE - Change log not initialized

    STATUS_NO_MEMORY - There is not enough memory to allocate OutContext.


--*/
{
    NTSTATUS Status;
    CHANGELOG_CONTEXT Context;
    PCHANGELOG_ENTRY ChangeLogEntry;
    ULONG BytesCopied = 0;
    LPBYTE Where = (LPBYTE)ChangeBuffer;
    ULONG EntriesCopied = 0;

    //
    // Initialization.
    //

    *OutContext = NULL;
    *OutContextSize = 0;

    //
    // Ensure the role is right.  Otherwise, all the globals used below
    //  aren't initialized.
    //

    if ( NlGlobalChangeLogRole != ChangeLogPrimary ) {
        NlPrint((NL_CHANGELOG,
                "I_NetLogonReadChangeLog: failed 1\n" ));
        return STATUS_INVALID_DOMAIN_ROLE;
    }

    //
    // Also make sure that the change log cache is available.
    //

    if ( NlGlobalChangeLogDesc.Buffer == NULL ) {
        NlPrint((NL_CHANGELOG,
                "I_NetLogonReadChangeLog: failed 2\n" ));
        return STATUS_INVALID_DOMAIN_ROLE;
    }

    //
    // Validate the context.
    //

    LOCK_CHANGELOG();
    if ( InContext == NULL ) {
        NlPrint((NL_CHANGELOG, "I_NetLogonReadChangeLog: called with NULL\n" ));

        //
        // Start the sequence number at one.
        //

        Context.SequenceNumber = 1;

        //
        // If nothing has ever been written to the change log,
        //  indicate nothing is available.
        //

        if ( ChangeLogIsEmpty( &NlGlobalChangeLogDesc ) ) {
            ChangeLogEntry = NULL;

        //
        // Otherwise, start at the beginning of the log.
        //
        } else {
            ChangeLogEntry = (PCHANGELOG_ENTRY) (NlGlobalChangeLogDesc.Head + 1);
        }


    } else {

        //
        // Ensure the context wasn't mangled.
        //

        if ( InContextSize < sizeof(CHANGELOG_CONTEXT) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        RtlCopyMemory( &Context, InContext, sizeof(CHANGELOG_CONTEXT) );


        NlPrint((NL_CHANGELOG, "I_NetLogonReadChangeLog: called with %lx %lx in %ld (%ld)\n",
                 Context.SerialNumber.HighPart,
                 Context.SerialNumber.LowPart,
                 Context.DbIndex,
                 Context.SequenceNumber ));

        //
        // Increment the sequence number.
        //

        Context.SequenceNumber++;

        //
        // Find the change log entry corresponding to the context.
        //

        ChangeLogEntry = NlFindChangeLogEntry( &NlGlobalChangeLogDesc,
                                               Context.SerialNumber,
                                               FALSE,   // Not downlevel
                                               TRUE,    // Exact match needed
                                               Context.DbIndex );

        if ( ChangeLogEntry == NULL ) {
            Status = STATUS_INVALID_PARAMETER;

            NlPrint((NL_CHANGELOG, "I_NetLogonReadChangeLog: %lx %lx in %ld: Entry no longer exists in change log.\n",
                     Context.SerialNumber.HighPart,
                     Context.SerialNumber.LowPart,
                     Context.DbIndex ));
            goto Cleanup;
        }

        //
        // The next change log entry is the one to return first.
        //

        ChangeLogEntry = NlMoveToNextChangeLogEntry( &NlGlobalChangeLogDesc,
                                                     ChangeLogEntry );
    }

    //
    // Copy a header into the ChangeBuffer.
    //

    if ( ChangeBufferSize <= sizeof(CHANGELOG_BUFFER_HEADER) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto Cleanup;
    }

    ((PCHANGELOG_BUFFER_HEADER)Where)->Size = sizeof(CHANGELOG_BUFFER_HEADER);
    ((PCHANGELOG_BUFFER_HEADER)Where)->Version = CHANGELOG_BUFFER_VERSION;
    ((PCHANGELOG_BUFFER_HEADER)Where)->SequenceNumber = Context.SequenceNumber;
    ((PCHANGELOG_BUFFER_HEADER)Where)->Flags = 0;

    Where += sizeof(CHANGELOG_BUFFER_HEADER);
    BytesCopied += sizeof(CHANGELOG_BUFFER_HEADER);




    //
    // Loop returning change log entries to the caller.
    //
    // ASSERT: ChangeLogEntry is the next entry to return to the caller.
    // ASSERT: ChangeLogEntry is NULL if there are no more change log entries.

    while ( ChangeLogEntry != NULL ) {
        ULONG SizeToCopy;
        PCHANGELOG_BLOCK_HEADER ChangeLogBlock;

        //
        // Skip over any voided log entries.
        //

        while ( ChangeLogEntry != NULL && ChangeLogEntry->DBIndex == VOID_DB ) {

             //
             // Get the next entry to copy.
             //

             ChangeLogEntry = NlMoveToNextChangeLogEntry( &NlGlobalChangeLogDesc,
                                                          ChangeLogEntry );

        }

        if ( ChangeLogEntry == NULL ) {
            break;
        }


        //
        // Compute the size of the change log entry to copy.
        //

        ChangeLogBlock = (PCHANGELOG_BLOCK_HEADER)
            ( (LPBYTE) ChangeLogEntry - sizeof(CHANGELOG_BLOCK_HEADER) );

        SizeToCopy = ChangeLogBlock->BlockSize -
               sizeof(CHANGELOG_BLOCK_HEADER) -
               sizeof(CHANGELOG_BLOCK_TRAILER);
        NlAssert( SizeToCopy == ROUND_UP_COUNT( SizeToCopy, ALIGN_DWORD ));

        //
        // Ensure the entry fits in the buffer.
        //

        if ( BytesCopied + SizeToCopy + sizeof(DWORD) > ChangeBufferSize ) {
            break;
        }

        //
        // Copy this entry into the buffer.
        //

        *((LPDWORD)Where) = SizeToCopy;
        Where += sizeof(DWORD);
        BytesCopied += sizeof(DWORD);

        RtlCopyMemory( Where, ChangeLogEntry, SizeToCopy );
        Where += SizeToCopy;
        BytesCopied += SizeToCopy;
        EntriesCopied += 1;

        //
        // Remember the context of this Entry.
        //

        Context.SerialNumber.QuadPart = ChangeLogEntry->SerialNumber.QuadPart;
        Context.DbIndex = ChangeLogEntry->DBIndex;

        //
        // Get the next entry to copy.
        //

        ChangeLogEntry = NlMoveToNextChangeLogEntry( &NlGlobalChangeLogDesc,
                                                     ChangeLogEntry );

    }

    //
    // Determine the status code to return.
    //

    if ( ChangeLogEntry == NULL ) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_MORE_ENTRIES;

        //
        // If no data was copied,
        //  give a better status.
        //

        if ( EntriesCopied == 0 ) {
            Status = STATUS_BUFFER_TOO_SMALL;
            BytesCopied = 0;
            goto Cleanup;
        }
    }

    //
    // If any data was returned,
    //  return context to the caller.
    //

    if ( EntriesCopied ) {

        *OutContext = NetpMemoryAllocate( sizeof(CHANGELOG_CONTEXT) );

        if ( *OutContext == NULL ) {
            Status = STATUS_NO_MEMORY;
            BytesCopied = 0;
            goto Cleanup;
        }

        *((PCHANGELOG_CONTEXT)*OutContext) = Context;
        *OutContextSize = sizeof(CHANGELOG_CONTEXT);

    }


Cleanup:
    *BytesRead = BytesCopied;
    UNLOCK_CHANGELOG();
    return Status;
}




NTSTATUS
I_NetLogonNewChangeLog(
    OUT HANDLE *ChangeLogHandle
    )
/*++

Routine Description:

    This function opens a new changelog file for writing.  The new changelog
    is a temporary file.  The real change will not be modified until
    I_NetLogonCloseChangeLog is called asking to Comit the changes.

    The caller should follow this call by Zero more calls to
    I_NetLogonAppendChangeLog followed by a call to I_NetLogonCloseChangeLog.

    Only one temporary change log can be active at once.

Arguments:

    ChangeLogHandle - Returns a handle identifying the temporary change log.

Return Value:

    STATUS_SUCCESS - The temporary change log has been successfully opened.

    STATUS_INVALID_DOMAIN_ROLE - DC is neither PDC nor BDC.

    STATUS_NO_MEMORY - Not enough memory to create the change log buffer.

    Sundry file creation errors.

--*/
{
    NTSTATUS Status;

    NlPrint((NL_CHANGELOG, "I_NetLogonNewChangeLog: called\n" ));

    //
    // Ensure the role is right.  Otherwise, all the globals used below
    //  aren't initialized.
    //

    if ( NlGlobalChangeLogRole != ChangeLogPrimary &&
         NlGlobalChangeLogRole != ChangeLogBackup ) {
        NlPrint((NL_CHANGELOG,
                "I_NetLogonNewChangeLog: failed 1\n" ));
        return STATUS_INVALID_DOMAIN_ROLE;
    }

    //
    // Initialize the global context.
    //

    LOCK_CHANGELOG();
    InitChangeLogDesc( &NlGlobalTempChangeLogDesc );
    NlGlobalTempChangeLogDesc.TempLog = TRUE;

    //
    // Create a temporary change log the same size as the real changelog
    //

    Status = NlResetChangeLog( &NlGlobalTempChangeLogDesc,
                               NlGlobalChangeLogDesc.BufferSize );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint((NL_CHANGELOG,
                "I_NetLogonNewChangeLog: cannot reset temp change log 0x%lx\n",
                Status ));
        goto Cleanup;
    }


    NlGlobalChangeLogSequenceNumber = 0;
    *(PULONG)ChangeLogHandle = ++ NlGlobalChangeLogHandle;
Cleanup:
    UNLOCK_CHANGELOG();
    return Status;

}




NTSTATUS
I_NetLogonAppendChangeLog(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    )
/*++

Routine Description:

    This function appends change log information to new changelog file.

    The ChangeBuffer must be a change buffer returned from I_NetLogonReadChangeLog.
    Care should be taken to ensure each call to I_NetLogonReadChangeLog is
    exactly matched by one call to I_NetLogonAppendChangeLog.

Arguments:

    ChangeLogHandle - A handle identifying the temporary change log.

    ChangeBuffer - A buffer describing a set of changes returned from
    I_NetLogonReadChangeLog.

    ChangeBufferSize - Size (in bytes) of ChangeBuffer.

Return Value:

    STATUS_SUCCESS - The temporary change log has been successfully opened.

    STATUS_INVALID_DOMAIN_ROLE - DC is neither PDC nor BDC.

    STATUS_INVALID_HANDLE - ChangeLogHandle is not valid.

    STATUS_INVALID_PARAMETER - ChangeBuffer contains invalid data.

    Sundry disk write errors.

--*/
{
    NTSTATUS Status;
    LPBYTE Where;
    ULONG BytesLeft;
    LPBYTE AllocatedChangeBuffer = NULL;

    //
    // Ensure the role is right.  Otherwise, all the globals used below
    //  aren't initialized.
    //

    if ( NlGlobalChangeLogRole != ChangeLogPrimary &&
         NlGlobalChangeLogRole != ChangeLogBackup ) {
        NlPrint((NL_CHANGELOG,
                "I_NetLogonAppendChangeLog: failed 1\n" ));
        return STATUS_INVALID_DOMAIN_ROLE;
    }

    //
    // Check the handle.
    //

    LOCK_CHANGELOG();
    if ( HandleToUlong(ChangeLogHandle) != NlGlobalChangeLogHandle ) {
        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // Make a properly aligned copy of the buffer.
    //  Sam gets it as a byte array over RPC.  RPC chooses to align it poorly.
    //

    BytesLeft = ChangeBufferSize;

    if ( BytesLeft < sizeof(CHANGELOG_BUFFER_HEADER) ) {
        NlPrint((NL_CRITICAL,
                "I_NetLogonAppendChangeLog: Buffer has no header %ld\n", BytesLeft ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    AllocatedChangeBuffer = LocalAlloc( 0, BytesLeft );

    if ( AllocatedChangeBuffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( AllocatedChangeBuffer, ChangeBuffer, BytesLeft );



    //
    // Validate the buffer header.
    //

    Where = (LPBYTE) AllocatedChangeBuffer;

    if ( ((PCHANGELOG_BUFFER_HEADER)Where)->Size < sizeof(CHANGELOG_BUFFER_HEADER) ||
         ((PCHANGELOG_BUFFER_HEADER)Where)->Size > BytesLeft ) {
        NlPrint((NL_CRITICAL,
                "I_NetLogonAppendChangeLog: Header size is bogus %ld %ld\n",
                ((PCHANGELOG_BUFFER_HEADER)Where)->Size,
                BytesLeft ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( ((PCHANGELOG_BUFFER_HEADER)Where)->Version != CHANGELOG_BUFFER_VERSION ) {
        NlPrint((NL_CRITICAL,
                "I_NetLogonAppendChangeLog: Header version is bogus %ld\n",
                ((PCHANGELOG_BUFFER_HEADER)Where)->Version ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( ((PCHANGELOG_BUFFER_HEADER)Where)->SequenceNumber != NlGlobalChangeLogSequenceNumber + 1 ) {
        NlPrint((NL_CRITICAL,
                "I_NetLogonAppendChangeLog: Header out of sequence %ld %ld\n",
                ((PCHANGELOG_BUFFER_HEADER)Where)->SequenceNumber,
                NlGlobalChangeLogSequenceNumber ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    NlPrint((NL_CHANGELOG, "I_NetLogonAppendChangeLog: called (%ld)\n", NlGlobalChangeLogSequenceNumber ));

    NlGlobalChangeLogSequenceNumber += 1;
    BytesLeft -= ((PCHANGELOG_BUFFER_HEADER)Where)->Size;
    Where += ((PCHANGELOG_BUFFER_HEADER)Where)->Size;


    //
    // Loop through the individual changes
    //

    while ( BytesLeft != 0 ) {
        PCHANGELOG_ENTRY ChangeLogEntry;
        ULONG ChangeLogEntrySize;

        //
        // Ensure that at least the size field is present.
        //
        if ( BytesLeft < sizeof(DWORD) ) {
            NlPrint((NL_CRITICAL,
                    "I_NetLogonAppendChangeLog: Bytes left is too small %ld\n", BytesLeft ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Ensure the entire change log entry is present.
        //

        ChangeLogEntrySize = *((PULONG)Where);
        Where += sizeof(ULONG);
        BytesLeft -= sizeof(ULONG);

        if ( BytesLeft < ChangeLogEntrySize ) {
            NlPrint((NL_CRITICAL,
                    "I_NetLogonAppendChangeLog: Bytes left is smaller than entry size %ld %ld\n",
                    BytesLeft, ChangeLogEntrySize ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        ChangeLogEntry = (PCHANGELOG_ENTRY)Where;
        Where += ChangeLogEntrySize;
        BytesLeft -= ChangeLogEntrySize;


        //
        // Check the structural integrity of the entry.
        //

        if ( !NlValidateChangeLogEntry( ChangeLogEntry, ChangeLogEntrySize)) {
            NlPrint((NL_CRITICAL,
                    "I_NetLogonAppendChangeLog: ChangeLogEntry is bogus\n" ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // If this is not an entry for the LSA database,
        // copy the change log entry into the temporary change log.
        //
        // The rational here is that this routine is called on this
        // DC when this DC is in the process of becoming a PDC.  A
        // new change log is created that is coppied from the one on
        // what is currently the PDC.  Parallel to this, the SAM database
        // is replicated using DS from the current PDC to this DC.
        // However, the LSA database isn't replicated in this process.
        // This is OK since after this machine becomes the PDC, it will
        // change the timestamp of the master database creation forcing
        // BDCs to do a full LSA sync from this PDC next time they send a
        // ssync request.  However, if we were to write LSA entries into
        // the change log, we could potentially have different serial
        // numbers for what we currently have in the LSA database locally
        // on this machine and in the change log we got from what is
        // currently the PDC.  This would potentially produce event log
        // errors next time LSA tries to write into the log file locally.
        // So we choose not to write the LSA entries in the change log at
        // all.
        //

        if ( ChangeLogEntry->DBIndex != LSA_DB ) {
            Status = NlCopyChangeLogEntry(
                            FALSE,   // Entry is NOT version 3
                            ChangeLogEntry,
                            &NlGlobalTempChangeLogDesc );

            if ( !NT_SUCCESS(Status) ) {
                NlPrint((NL_CRITICAL,
                        "I_NetLogonAppendChangeLog: Cannot copy ChangeLogEntry 0x%lx\n",
                        Status ));
                goto Cleanup;
            }
        }


    }

    //
    // Flush the changes to disk.
    //

    Status = NlFlushChangeLog( &NlGlobalTempChangeLogDesc );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint((NL_CRITICAL,
                "I_NetLogonAppendChangeLog: Cannot flush changes 0x%lx\n",
                Status ));
        goto Cleanup;
    }


    Status = STATUS_SUCCESS;
Cleanup:
    UNLOCK_CHANGELOG();

    if ( AllocatedChangeBuffer != NULL ) {
        LocalFree( AllocatedChangeBuffer );
    }
    return Status;
}


NTSTATUS
I_NetLogonCloseChangeLog(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    )
/*++

Routine Description:

    This function closes a new changelog file.

Arguments:

    ChangeLogHandle - A handle identifying the temporary change log.

    Commit - If true, the specified changes are written to the primary change log.
        If false, the specified change are deleted.

Return Value:

    STATUS_SUCCESS - The temporary change log has been successfully opened.

    STATUS_INVALID_DOMAIN_ROLE - DC is neither PDC nor BDC.

    STATUS_INVALID_HANDLE - ChangeLogHandle is not valid.

--*/
{
    NTSTATUS Status;
    LPBYTE Where;
    ULONG BytesLeft;

    NlPrint((NL_CHANGELOG, "I_NetLogonAppendCloseLog: called (%ld)\n", Commit ));

    //
    // Ensure the role is right.  Otherwise, all the globals used below
    //  aren't initialized.
    //

    if ( NlGlobalChangeLogRole != ChangeLogPrimary &&
         NlGlobalChangeLogRole != ChangeLogBackup ) {
        NlPrint((NL_CHANGELOG,
                "I_NetLogonCloseChangeLog: failed 1\n" ));
        return STATUS_INVALID_DOMAIN_ROLE;
    }

    //
    // Check the handle.
    //

    LOCK_CHANGELOG();
    if ( HandleToUlong(ChangeLogHandle) != NlGlobalChangeLogHandle ) {
        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }

    NlGlobalChangeLogHandle ++; // Invalidate this handle

    //
    // If the changes are to be committed,
    //  copy them now.
    //

    if ( Commit ) {

        //
        // Close the existing change log
        //

        NlCloseChangeLogFile( &NlGlobalChangeLogDesc );

        //
        // Clone the temporary change log.
        //

        NlGlobalChangeLogDesc = NlGlobalTempChangeLogDesc;
        NlGlobalChangeLogDesc.FileHandle = INVALID_HANDLE_VALUE;  // Don't use the temporary file
        NlGlobalTempChangeLogDesc.Buffer = NULL; // Don't have two refs to the same buffer
        NlGlobalChangeLogDesc.TempLog = FALSE;  // Log is no longer the temporary log

        //
        // Write the cache to the file.
        //
        // Ignore errors since the log is successfully in memory
        //

        (VOID) NlWriteChangeLogBytes( &NlGlobalChangeLogDesc,
                                        NlGlobalChangeLogDesc.Buffer,
                                        NlGlobalChangeLogDesc.BufferSize,
                                        TRUE ); // Flush the bytes to disk
    }


    //
    // Delete the temporary log file.
    //

    NlCloseChangeLogFile( &NlGlobalTempChangeLogDesc );

#ifdef notdef // Leave it around for debugging purposes.
    {
        WCHAR ChangeLogFile[MAX_PATH+CHANGELOG_FILE_POSTFIX_LENGTH+1];
        wcscpy( ChangeLogFile, NlGlobalChangeLogFilePrefix );
        wcscat( ChangeLogFile, TEMP_CHANGELOG_FILE_POSTFIX );
        if ( !DeleteFile( ChangeLogFile ) ) {
            NlPrint(( NL_CRITICAL,
                      "NlVoidChangeLogEntry: cannot delete temp change log %ld.\n",
                      GetLastError() ));
        }
    }
#endif // notdef

    Status = STATUS_SUCCESS;
Cleanup:
    UNLOCK_CHANGELOG();
    return Status;
}


#if NETLOGONDBG

VOID
PrintChangeLogEntry(
    PCHANGELOG_ENTRY ChangeLogEntry
    )
/*++

Routine Description:

    This routine print the content of the given changelog entry.

Arguments:

    ChangeLogEntry -- pointer to the change log entry to print

Return Value:

    none.

--*/
{
    LPSTR DeltaName;

    switch ( ChangeLogEntry->DeltaType ) {
    case AddOrChangeDomain:
        DeltaName = "AddOrChangeDomain";
        break;
    case AddOrChangeGroup:
        DeltaName = "AddOrChangeGroup";
        break;
    case DeleteGroupByName:
    case DeleteGroup:
        DeltaName = "DeleteGroup";
        break;
    case RenameGroup:
        DeltaName = "RenameGroup";
        break;
    case AddOrChangeUser:
        DeltaName = "AddOrChangeUser";
        break;
    case DeleteUserByName:
    case DeleteUser:
        DeltaName = "DeleteUser";
        break;
    case RenameUser:
        DeltaName = "RenameUser";
        break;
    case ChangeGroupMembership:
        DeltaName = "ChangeGroupMembership";
        break;
    case AddOrChangeAlias:
        DeltaName = "AddOrChangeAlias";
        break;
    case DeleteAlias:
        DeltaName = "DeleteAlias";
        break;
    case RenameAlias:
        DeltaName = "RenameAlias";
        break;
    case ChangeAliasMembership:
        DeltaName = "ChangeAliasMembership";
        break;
    case AddOrChangeLsaPolicy:
        DeltaName = "AddOrChangeLsaPolicy";
        break;
    case AddOrChangeLsaTDomain:
        DeltaName = "AddOrChangeLsaTDomain";
        break;
    case DeleteLsaTDomain:
        DeltaName = "DeleteLsaTDomain";
        break;
    case AddOrChangeLsaAccount:
        DeltaName = "AddOrChangeLsaAccount";
        break;
    case DeleteLsaAccount:
        DeltaName = "DeleteLsaAccount";
        break;
    case AddOrChangeLsaSecret:
        DeltaName = "AddOrChangeLsaSecret";
        break;
    case DeleteLsaSecret:
        DeltaName = "DeleteLsaSecret";
        break;
    case SerialNumberSkip:
        DeltaName = "SerialNumberSkip";
        break;
    case DummyChangeLogEntry:
        DeltaName = "DummyChangeLogEntry";
        break;

    default:
        DeltaName ="(Unknown)";
        break;
    }

    NlPrint((NL_CHANGELOG,
        "DeltaType %s (%ld) SerialNumber: %lx %lx",
        DeltaName,
        ChangeLogEntry->DeltaType,
        ChangeLogEntry->SerialNumber.HighPart,
        ChangeLogEntry->SerialNumber.LowPart ));

    if ( ChangeLogEntry->ObjectRid != 0 ) {
        NlPrint((NL_CHANGELOG," Rid: 0x%lx", ChangeLogEntry->ObjectRid ));
    }
    if ( ChangeLogEntry->Flags & CHANGELOG_PDC_PROMOTION ) {
        NlPrint((NL_CHANGELOG," Promotion" ));
    }

    if( ChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED ) {
        NlPrint(( NL_CHANGELOG, " Name: '" FORMAT_LPWSTR "'",
                (LPWSTR)((PBYTE)(ChangeLogEntry)+ sizeof(CHANGELOG_ENTRY))));
    }

    if( ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED ) {
        NlPrint((NL_CHANGELOG," Sid: "));
        NlpDumpSid( NL_CHANGELOG,
                    (PSID)((PBYTE)(ChangeLogEntry)+ sizeof(CHANGELOG_ENTRY)) );
    } else {
        NlPrint((NL_CHANGELOG,"\n" ));
    }
}
#endif // NETLOGONDBG



NTSTATUS
NlWriteChangeLogEntry(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN PCHANGELOG_ENTRY ChangeLogEntry,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN BOOLEAN FlushIt
    )
/*++

Routine Description:

    This is the actual worker for the I_NetNotifyDelta().  This function
    acquires the sufficient size memory block from the change log
    buffer, writes the fixed and variable portions of the change log
    delta in change log buffer and also writes the delta into change log
    file.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

    ChangeLogEntry - pointer to the fixed portion of the change log.

    ObjectSid - pointer to the variable field SID.

    ObjectName - pointer to the variable field Name.

    FlushIt - True if the written bytes are to be flushed to disk

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/

{
    NTSTATUS Status;
    DWORD LogSize;
    PCHANGELOG_BLOCK_HEADER LogBlock;
    PCHANGELOG_BLOCK_HEADER FreeBlock;
    LPBYTE AllocatedChangeLogEntry;

    //
    // Make sure that the change log cache is available.
    //

    if ( ChangeLogDesc->Buffer == NULL ) {
        return STATUS_INTERNAL_ERROR;
    }



    //
    // Determine the size of this change log entry.
    //

    LogSize = sizeof(CHANGELOG_ENTRY);

    //
    // Ensure we've got the right data for those deltas we care about
    //

    switch (ChangeLogEntry->DeltaType) {
    case AddOrChangeLsaTDomain:
    case DeleteLsaTDomain:
    case AddOrChangeLsaAccount:
    case DeleteLsaAccount:
        NlAssert( ObjectSid != NULL );
        if( ObjectSid != NULL ) {
            ChangeLogEntry->Flags |= CHANGELOG_SID_SPECIFIED;
            LogSize += RtlLengthSid( ObjectSid );
        }
        break;

    case AddOrChangeLsaSecret:
    case DeleteLsaSecret:
    case DeleteGroup:
    case DeleteUser:

        // NlAssert( ObjectName != NULL && ObjectName->Buffer != NULL && ObjectName->Length != 0 );
        if( ObjectName != NULL && ObjectName->Buffer != NULL && ObjectName->Length != 0 ) {
            ChangeLogEntry->Flags |= CHANGELOG_NAME_SPECIFIED;
            LogSize += ObjectName->Length + sizeof(WCHAR);
        }
        break;

    //
    // For all other delta types, save the data if it's there.
    //
    default:

        if( ObjectName != NULL && ObjectName->Buffer != NULL && ObjectName->Length != 0 ) {
            ChangeLogEntry->Flags |= CHANGELOG_NAME_SPECIFIED;
            LogSize += ObjectName->Length + sizeof(WCHAR);
        } else if( ObjectSid != NULL ) {
            ChangeLogEntry->Flags |= CHANGELOG_SID_SPECIFIED;
            LogSize += RtlLengthSid( ObjectSid );
        }
        break;

    }



    //
    // Serialize access to the change log
    //

    LOCK_CHANGELOG();

    //
    // Validate the serial number order of this new entry
    //
    // If we're out of sync with the caller,
    //  clear the change log and start all over again.
    //
    // The global serial number array entry for this database must either
    // be zero (indicating no entries for this database) or one less than
    // the new serial number being added.
    //

    if ( ChangeLogDesc->SerialNumber[ChangeLogEntry->DBIndex].QuadPart != 0 ) {
        LARGE_INTEGER ExpectedSerialNumber;
        LARGE_INTEGER OldSerialNumber;

        ExpectedSerialNumber.QuadPart =
            ChangeLogDesc->SerialNumber[ChangeLogEntry->DBIndex].QuadPart + 1;

        //
        // If the serial number jumped by the promotion increment,
        //  set the flag in the change log entry indicating this is
        //  a promotion to PDC.
        //

        if ( ChangeLogEntry->SerialNumber.QuadPart ==
             ExpectedSerialNumber.QuadPart +
             NlGlobalChangeLogPromotionIncrement.QuadPart ) {

            ChangeLogEntry->Flags |= CHANGELOG_PDC_PROMOTION;
        }

        if ( !IsSerialNumberEqual( ChangeLogDesc,
                                   ChangeLogEntry,
                                   &ExpectedSerialNumber ))  {

            NlPrint((NL_CRITICAL,
                    "NlWriteChangeLogEntry: Serial numbers not contigous %lx %lx and %lx %lx\n",
                     ChangeLogEntry->SerialNumber.HighPart,
                     ChangeLogEntry->SerialNumber.LowPart,
                     ExpectedSerialNumber.HighPart,
                     ExpectedSerialNumber.LowPart ));

            //
            // write event log.
            //

            NlWriteChangeLogCorruptEvent( STATUS_INTERNAL_DB_CORRUPTION,
                                          ChangeLogEntry->DBIndex );

            //
            // If the change log is merely newer than the SAM database,
            //  we truncate entries newer than what exists in SAM.
            //

            OldSerialNumber.QuadPart = ChangeLogEntry->SerialNumber.QuadPart - 1;

            (VOID) NlFixChangeLog( ChangeLogDesc, ChangeLogEntry->DBIndex, OldSerialNumber );
        }

    //
    // If this is the first entry written to the change log for this database,
    //  mark it as a promotion.
    //

    } else {
        //
        // Only mark entries that might possibly be a promotion.
        //
        switch (ChangeLogEntry->DeltaType) {
        case AddOrChangeDomain:
        case AddOrChangeLsaPolicy:
            ChangeLogEntry->Flags |= CHANGELOG_PDC_PROMOTION;
            break;
        }
    }


    //
    // Validate the list before changing anything
    //

#if DBG
    NlAssert( ValidateList( ChangeLogDesc, FALSE) );
#endif // DBG


    //
    // copy fixed portion
    //

    Status = NlAllocChangeLogBlock( ChangeLogDesc, LogSize, &LogBlock );
    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }
    AllocatedChangeLogEntry = ((LPBYTE)LogBlock) + sizeof(CHANGELOG_BLOCK_HEADER);
    RtlCopyMemory( AllocatedChangeLogEntry, ChangeLogEntry, sizeof(CHANGELOG_ENTRY) );


    //
    // copy variable fields
    //

    if( ChangeLogEntry->Flags & CHANGELOG_SID_SPECIFIED ) {

        RtlCopyMemory( AllocatedChangeLogEntry + sizeof(CHANGELOG_ENTRY),
                       ObjectSid,
                       RtlLengthSid( ObjectSid ) );
    } else if( ChangeLogEntry->Flags & CHANGELOG_NAME_SPECIFIED ) {

        if ( ObjectName != NULL ) {
            RtlCopyMemory( AllocatedChangeLogEntry + sizeof(CHANGELOG_ENTRY),
                           ObjectName->Buffer,
                           ObjectName->Length );

            //
            // terminate unicode string
            //

            *(WCHAR *)(AllocatedChangeLogEntry + sizeof(CHANGELOG_ENTRY) +
                            ObjectName->Length) = 0;
        }
    }

    //
    // Be verbose
    //

#if NETLOGONDBG
    PrintChangeLogEntry( (PCHANGELOG_ENTRY)AllocatedChangeLogEntry );
#endif // NETLOGONDBG



    //
    // Write the cache entry to the file.
    //
    // Actually, write this entry plus the header and trailer of the free
    // block that follows.  If the free block is huge, write the free
    // block trailer separately.
    //

    FreeBlock =
        (PCHANGELOG_BLOCK_HEADER)((LPBYTE)LogBlock + LogBlock->BlockSize);

    if ( FreeBlock->BlockSize >= 4096 ) {

        Status = NlWriteChangeLogBytes(
                     ChangeLogDesc,
                     (LPBYTE)LogBlock,
                     LogBlock->BlockSize + sizeof(CHANGELOG_BLOCK_HEADER),
                     FlushIt );

        if ( NT_SUCCESS(Status) ) {
            Status = NlWriteChangeLogBytes(
                         ChangeLogDesc,
                         (LPBYTE)ChangeLogBlockTrailer(FreeBlock),
                         sizeof(CHANGELOG_BLOCK_TRAILER),
                         FlushIt );
        }

    } else {

        Status = NlWriteChangeLogBytes(
                     ChangeLogDesc,
                     (LPBYTE)LogBlock,
                     LogBlock->BlockSize + FreeBlock->BlockSize,
                     FlushIt );
    }


    //
    // Done.
    //

    ChangeLogDesc->SerialNumber[ChangeLogEntry->DBIndex] = ChangeLogEntry->SerialNumber;
    ChangeLogDesc->EntryCount[ChangeLogEntry->DBIndex] ++;

    //
    // Validate the list before returning from here.
    //
Cleanup:

#if DBG
    NlAssert( ValidateList( ChangeLogDesc, FALSE) );
#endif // DBG


    UNLOCK_CHANGELOG();
    return Status;
}



NTSTATUS
NlOpenChangeLogFile(
    IN LPWSTR ChangeLogFileName,
    OUT PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN BOOLEAN ReadOnly
)
/*++

Routine Description:

    Open the change log file (netlogon.chg) for reading or writing one or
    more records.  Create this file if it does not exist or is out of
    sync with the SAM database (see note below).

    This file must be opened for R/W (deny-none share mode) at the time
    the cache is initialized.  If the file already exists when NETLOGON
    service started, its contents will be cached in its entirety
    provided the last change log record bears the same serial number as
    the serial number field in SAM database else this file will be
    removed and a new one created.  If the change log file did not exist
    then it will be created.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogFileName - Name of the changelog file to open.

    ChangeLogDesc -- On success, returns a description of the Changelog buffer
        being used

    ReadOnly -- True if the file should be openned read only.

Return Value:

    NT Status code

--*/
{

    DWORD WinError;
    DWORD BytesRead;
    DWORD MinChangeLogSize;

    //
    // Open change log file if exists
    //

    ChangeLogDesc->FileHandle = CreateFileW(
                        ChangeLogFileName,
                        ReadOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE),
                        ReadOnly ? (FILE_SHARE_READ | FILE_SHARE_WRITE) : FILE_SHARE_READ,        // allow backups and debugging
                        NULL,                   // Supply better security ??
                        OPEN_EXISTING,          // Only open it if it exists
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );                 // No template

    if ( ChangeLogDesc->FileHandle == INVALID_HANDLE_VALUE) {
        WinError = GetLastError();

        NlPrint(( NL_CRITICAL,
                  FORMAT_LPWSTR ": Unable to open. %ld\n",
                  ChangeLogFileName,
                  WinError ));

        goto Cleanup;
    }

    //
    // Get the size of the file.
    //

    ChangeLogDesc->BufferSize = GetFileSize( ChangeLogDesc->FileHandle, NULL );

    if ( ChangeLogDesc->BufferSize == 0xFFFFFFFF ) {

        WinError = GetLastError();
        NlPrint((NL_CRITICAL,
                 "%ws: Unable to GetFileSize: %ld \n",
                 ChangeLogFileName,
                 WinError));
        goto Cleanup;
    }

    // ?? consider aligning to ALIGN_WORST
    MinChangeLogSize = MIN_CHANGELOGSIZE;

    if ( ChangeLogDesc->BufferSize < MinChangeLogSize ||
         ChangeLogDesc->BufferSize > MAX_CHANGELOGSIZE ) {

        WinError = ERROR_INTERNAL_DB_CORRUPTION;

        NlPrint((NL_CRITICAL, FORMAT_LPWSTR ": Changelog size is invalid. %ld.\n",
                  ChangeLogFileName,
                  ChangeLogDesc->BufferSize ));
        goto Cleanup;
    }

    //
    // Allocate and initialize the change log cache.
    //

    ChangeLogDesc->Buffer = NetpMemoryAllocate( ChangeLogDesc->BufferSize );
    if (ChangeLogDesc->Buffer == NULL) {
        NlPrint((NL_CRITICAL, FORMAT_LPWSTR ": Cannot allocate Changelog buffer. %ld.\n",
                  ChangeLogFileName,
                  ChangeLogDesc->BufferSize ));
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    RtlZeroMemory(ChangeLogDesc->Buffer, ChangeLogDesc->BufferSize);


    //
    // Check the signature at the front of the change log.
    //
    //  It won't be there if we just created the file.
    //

    if ( !ReadFile( ChangeLogDesc->FileHandle,
                    ChangeLogDesc->Buffer,
                    ChangeLogDesc->BufferSize,
                    &BytesRead,
                    NULL ) ) {  // Not Overlapped

        WinError = GetLastError();

        NlPrint(( NL_CRITICAL,
                  FORMAT_LPWSTR ": Unable to read from changelog file. %ld\n",
                  ChangeLogFileName,
                  WinError ));

        goto Cleanup;
    }

    if ( BytesRead != ChangeLogDesc->BufferSize ) {

        WinError = ERROR_INTERNAL_DB_CORRUPTION;

        NlPrint(( NL_CRITICAL,
                  FORMAT_LPWSTR ": Couldn't read entire file. %ld\n",
                  ChangeLogFileName,
                  WinError ));


        goto Cleanup;
    }

    if ( strncmp((PCHAR)ChangeLogDesc->Buffer,
                        CHANGELOG_SIG, sizeof(CHANGELOG_SIG)) == 0) {
        ChangeLogDesc->Version3 = FALSE;

    } else if ( strncmp((PCHAR)ChangeLogDesc->Buffer,
                        CHANGELOG_SIG_V3, sizeof(CHANGELOG_SIG_V3)) == 0) {
        ChangeLogDesc->Version3 = TRUE;
    } else {
        WinError = ERROR_INTERNAL_ERROR;

        NlPrint(( NL_CRITICAL,
                  FORMAT_LPWSTR ": Invalid signature. %ld\n",
                  ChangeLogFileName,
                  WinError ));

        goto Cleanup;
    }


    //
    // Find the Head and Tail pointers of the circular log.
    //

    if( !InitChangeLogHeadAndTail( ChangeLogDesc, FALSE ) ) {
        WinError = ERROR_INTERNAL_DB_CORRUPTION;

        NlPrint(( NL_CRITICAL,
                  FORMAT_LPWSTR ": couldn't find head/tail. %ld\n",
                  ChangeLogFileName,
                  WinError ));

        goto Cleanup;
    }



    WinError = NO_ERROR;

    //
    // Free any resources on error.
    //
Cleanup:

    if ( WinError != NO_ERROR ) {
        NlCloseChangeLogFile( ChangeLogDesc );
    } else {
        NlPrint((NL_CHANGELOG, "%ws: Changelog successfully opened.\n",
                  ChangeLogFileName ));
    }

    return NetpApiStatusToNtStatus(WinError);
}





VOID
NlCloseChangeLogFile(
    IN PCHANGELOG_DESCRIPTOR ChangeLogDesc
)
/*++

Routine Description:

    This function closes the change log file and frees up the resources
    consumed by the change log desriptor.

Arguments:

    ChangeLogDesc -- Description of the Changelog buffer being used

Return Value:

    NT Status code

--*/
{

    LOCK_CHANGELOG();

    NlPrint((NL_CHANGELOG, "%s log closed.\n",
              ChangeLogDesc->TempLog ? "TempChange" : "Change" ));

    //
    // free up the change log cache.
    //

    if ( ChangeLogDesc->Buffer != NULL ) {
        NetpMemoryFree( ChangeLogDesc->Buffer );
        ChangeLogDesc->Buffer = NULL;
    }

    ChangeLogDesc->Head = NULL;
    ChangeLogDesc->Tail = NULL;

    ChangeLogDesc->FirstBlock = NULL;
    ChangeLogDesc->BufferEnd = NULL;

    ChangeLogDesc->LastDirtyByte = 0;
    ChangeLogDesc->FirstDirtyByte = 0;

    //
    // Close the change log file
    //

    if ( ChangeLogDesc->FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( ChangeLogDesc->FileHandle );
        ChangeLogDesc->FileHandle = INVALID_HANDLE_VALUE;
    }

    UNLOCK_CHANGELOG();

    return;
}



NTSTATUS
NlResizeChangeLogFile(
    IN OUT PCHANGELOG_DESCRIPTOR ChangeLogDesc,
    IN DWORD NewChangeLogSize
)
/*++

Routine Description:

    The buffer described by ChageLogDesc is converted to
    the size requested by NewChangeLogSize and is converted from any
    old format change log to the latest format.

    NOTE: This function must be called with the change log locked.

Arguments:

    ChangeLogDesc -- a description of the Changelog buffer.

    NewChangeLogSize -- Size (in bytes) of the new change log.

Return Value:

    NT Status code

    On error, the ChangeLogDesc will still be intact.  Merely the size
        changes will not have happened

--*/
{
    CHANGELOG_DESCRIPTOR OutChangeLogDesc;
    NTSTATUS Status;

    //
    // If the current buffer is perfect,
    //  just use it.
    //

    if ( !ChangeLogDesc->Version3 &&
         ChangeLogDesc->BufferSize == NewChangeLogSize ) {
        return STATUS_SUCCESS;
    }

    //
    // Initialize the template change log descriptor
    //

    InitChangeLogDesc( &OutChangeLogDesc );

    //
    // Close the file so we can resize it.
    //

    if ( ChangeLogDesc->FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( ChangeLogDesc->FileHandle );
        ChangeLogDesc->FileHandle = INVALID_HANDLE_VALUE;
    }

    //
    // Start with a newly initialized change log,
    //

    Status = NlResetChangeLog( &OutChangeLogDesc, NewChangeLogSize );

    if ( !NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // We're done if the old change log is empty.
    //

    if ( !ChangeLogIsEmpty(ChangeLogDesc) ) {

        //
        // Loop through the old change log copying it to the new changelog,
        //

        PCHANGELOG_ENTRY SourceChangeLogEntry = (PCHANGELOG_ENTRY)
                                (ChangeLogDesc->Head + 1);

        do {
            Status = NlCopyChangeLogEntry( ChangeLogDesc->Version3,
                                           SourceChangeLogEntry,
                                           &OutChangeLogDesc );

            if ( !NT_SUCCESS(Status) ) {
                NlCloseChangeLogFile( &OutChangeLogDesc );
                return Status;
            }

        } while ( (SourceChangeLogEntry =
            NlMoveToNextChangeLogEntry( ChangeLogDesc, SourceChangeLogEntry )) != NULL );

        //
        // Flsuh all the changes to the change log file now.
        //

        Status = NlFlushChangeLog( &OutChangeLogDesc );

        if ( !NT_SUCCESS(Status) ) {
            NlCloseChangeLogFile( &OutChangeLogDesc );
            return Status;
        }

    }

    //
    // Free the old change log buffer.
    //

    NlCloseChangeLogFile( ChangeLogDesc );

    //
    // Copy the new descriptor over the old descriptor
    //

    *ChangeLogDesc = OutChangeLogDesc;

    return STATUS_SUCCESS;
}


#if NETLOGONDBG

DWORD
NlBackupChangeLogFile(
    )
/*++

Routine Description:

    Backup change log content. Since the cache and the change log file
    content are identical, write cache content to the backup file.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{
    HANDLE BackupChangeLogHandle;

    WCHAR BackupChangelogFile[MAX_PATH+CHANGELOG_FILE_POSTFIX_LENGTH+1];
    DWORD WinError;

    if( NlGlobalChangeLogFilePrefix[0] == L'\0' ) {

        return ERROR_FILE_NOT_FOUND;
    }

    //
    // make backup file name.
    //

    wcscpy( BackupChangelogFile, NlGlobalChangeLogFilePrefix );
    wcscat( BackupChangelogFile, BACKUP_CHANGELOG_FILE_POSTFIX );



    //
    // Create change log file. If it exists already then truncate it.
    //
    // Note : if a valid change log file exists on the system, then we
    // would have opened at initialization time.
    //

    BackupChangeLogHandle = CreateFileW(
                        BackupChangelogFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,        // allow backups and debugging
                        NULL,                   // Supply better security ??
                        CREATE_ALWAYS,          // Overwrites always
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );                 // No template

    if (BackupChangeLogHandle == INVALID_HANDLE_VALUE) {


        NlPrint((NL_CRITICAL,"Unable to create backup changelog file "
                    "WinError = %ld \n", WinError = GetLastError() ));

        return WinError;
    }

    //
    // Write cache in changelog file if the cache is valid.
    //

    if( NlGlobalChangeLogDesc.Buffer != NULL ) {

        OVERLAPPED Overlapped;
        DWORD BytesWritten;

        //
        // Seek to appropriate offset in the file.
        //

        RtlZeroMemory( &Overlapped, sizeof(Overlapped) );

        LOCK_CHANGELOG();

        if ( !WriteFile( BackupChangeLogHandle,
                         NlGlobalChangeLogDesc.Buffer,
                         NlGlobalChangeLogDesc.BufferSize,
                         &BytesWritten,
                         &Overlapped ) ) {

            UNLOCK_CHANGELOG();
            NlPrint((NL_CRITICAL, "Write to Backup ChangeLog failed %ld\n",
                        WinError = GetLastError() ));

            goto Cleanup;
        }

        UNLOCK_CHANGELOG();

        //
        // Ensure all the bytes made it.
        //

        if ( BytesWritten != NlGlobalChangeLogDesc.BufferSize ) {
            NlPrint((NL_CRITICAL,
                    "Write to Backup ChangeLog bad byte count %ld s.b. %ld\n",
                    BytesWritten,
                    NlGlobalChangeLogDesc.BufferSize ));

            goto Cleanup;
        }
    }

Cleanup:

    CloseHandle( BackupChangeLogHandle );
    return ERROR_SUCCESS;
}

#endif // NETLOGONDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\domain.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    domain.c

Abstract:

    Code to manage multiple domains hosted on a DC.

Author:

    Cliff Van Dyke (CliffV) 11-Jan-1995

Revision History:

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//




// Serialized by NlGlobalDomainCritSect
LIST_ENTRY NlGlobalServicedDomains = {0};  // Real domains we service
LIST_ENTRY NlGlobalServicedNdncs = {0};    // Non-domain NCs we service
BOOL NlGlobalDomainsInitialized = FALSE;




NET_API_STATUS
NlGetDomainName(
    OUT LPWSTR *DomainName,
    OUT LPWSTR *DnsDomainName,
    OUT PSID *AccountDomainSid,
    OUT PSID *PrimaryDomainSid,
    OUT GUID **PrimaryDomainGuid,
    OUT PBOOLEAN DnsForestNameChanged OPTIONAL
    )
/*++

Routine Description:

    This routine gets the primary domain name and domain SID from the LSA.

Arguments:

    DomainName - Returns name of the primary domain.  Free this buffer using LocalFree.

    DnsDomainName -  Returns the DNS domain name of the primary domain.
        The returned name has a trailing . since the name is an absolute name.
        The allocated buffer must be freed via LocalFree.
        Returns NO_ERROR and a pointer to a NULL buffer if there is no
        domain name configured.

    AccountDomainSid - Returns Account Domain Sid of this machine.  Free this buffer using LocalFree.

    PrimaryDomainSid - Returns Primary Domain Sid of this machine.  Free this buffer using LocalFree.
        Only return on workstations.

    PrimaryDomainGuid - Returns Primary Domain GUID of this machine.  Free this buffer using LocalFree.

    DnsForestNameChanged: Returns TRUE if the tree name changed.

Return Value:

    Status of the operation.

    Calls NlExit on failures.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    PLSAPR_POLICY_INFORMATION PrimaryDomainInfo = NULL;
    PLSAPR_POLICY_INFORMATION AccountDomainInfo = NULL;
    LSAPR_HANDLE PolicyHandle = NULL;

    ULONG DomainSidSize;
    ULONG DnsDomainNameLength;


    //
    // Initialization
    //

    *DomainName = NULL;
    *DnsDomainName = NULL;
    *AccountDomainSid = NULL;
    *PrimaryDomainSid = NULL;
    *PrimaryDomainGuid = NULL;

    //
    // Open the LSA policy
    //

    // ?? I'll need to identify which trusted domain here.
    Status = LsaIOpenPolicyTrusted( &PolicyHandle );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint((NL_CRITICAL,
                 "NlGetDomainName: Can't LsaIOpenPolicyTrusted: 0x%lx.\n",
                 Status ));
        NetStatus = NetpNtStatusToApiStatus(Status);
        NlExit( SERVICE_UIC_M_DATABASE_ERROR, NetStatus, LogError, NULL);
        goto Cleanup;
    }



    //
    // Get the Account Domain info from the LSA.
    //

    Status = LsarQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                &AccountDomainInfo );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint((NL_CRITICAL,
                 "NlGetDomainName: Can't LsarQueryInformationPolicy (AccountDomain): 0x%lx.\n",
                 Status ));
        NetStatus = NetpNtStatusToApiStatus(Status);
        NlExit( SERVICE_UIC_M_DATABASE_ERROR, NetStatus, LogError, NULL);
        goto Cleanup;
    }

    if ( AccountDomainInfo->PolicyAccountDomainInfo.DomainName.Length == 0 ||
         AccountDomainInfo->PolicyAccountDomainInfo.DomainName.Length >
            DNLEN * sizeof(WCHAR) ||
         AccountDomainInfo->PolicyAccountDomainInfo.DomainSid == NULL ) {

        NlPrint((NL_CRITICAL, "Account domain info from LSA invalid.\n"));

        //
        // Avoid event log error in safe mode where our exit is expected
        //
        NlExit( SERVICE_UIC_M_UAS_INVALID_ROLE,
                NO_ERROR,
                LsaISafeMode() ? DontLogError : LogError,
                NULL );

        NetStatus = SERVICE_UIC_M_UAS_INVALID_ROLE;
        goto Cleanup;
    }



    //
    // Copy the Account domain id into a buffer to return to the caller.
    //

    DomainSidSize =
        RtlLengthSid( (PSID)AccountDomainInfo->PolicyAccountDomainInfo.DomainSid );
    *AccountDomainSid = LocalAlloc( 0, DomainSidSize );

    if ( *AccountDomainSid == NULL ) {
        NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL);
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( *AccountDomainSid,
                   (PSID)AccountDomainInfo->PolicyAccountDomainInfo.DomainSid,
                   DomainSidSize );


    //
    // Get the Primary Domain info from the LSA.
    //

    Status = LsarQueryInformationPolicy(
                PolicyHandle,
                PolicyDnsDomainInformation,
                &PrimaryDomainInfo );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint((NL_CRITICAL,
                 "NlGetDomainName: Can't LsarQueryInformationPolicy (DnsDomain): 0x%lx.\n",
                 Status ));
        NetStatus = NetpNtStatusToApiStatus(Status);
        NlExit( SERVICE_UIC_M_DATABASE_ERROR, NetStatus, LogError, NULL);
        goto Cleanup;
    }

    if ( PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length == 0 ||
         PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length >
            DNLEN * sizeof(WCHAR) ||
         PrimaryDomainInfo->PolicyDnsDomainInfo.Sid == NULL ) {

        NlPrint((NL_CRITICAL, "Primary domain info from LSA invalid.\n"));

        // Ditch the sysvol shares in case this is a repair mode boot
        NlGlobalParameters.SysVolReady = FALSE;
        NlCreateSysvolShares();

        //
        // Avoid event log error in safe mode where our exit is expected
        //
        NlExit( SERVICE_UIC_M_UAS_INVALID_ROLE,
                NO_ERROR,
                LsaISafeMode() ? DontLogError : LogError,
                NULL );

        NetStatus = SERVICE_UIC_M_UAS_INVALID_ROLE;
        goto Cleanup;
    }

    //
    // On a DC, we must have DNS domain name
    //

    if ( !NlGlobalMemberWorkstation &&
         (PrimaryDomainInfo->PolicyDnsDomainInfo.DnsDomainName.Length == 0 ||
          PrimaryDomainInfo->PolicyDnsDomainInfo.DnsDomainName.Length >
            NL_MAX_DNS_LENGTH*sizeof(WCHAR)) ) {

        NlExit( SERVICE_UIC_M_UAS_INVALID_ROLE, NO_ERROR, LogError, NULL );
        NetStatus = SERVICE_UIC_M_UAS_INVALID_ROLE;
        goto Cleanup;
    }

    //
    // Copy the Primary domain id into a buffer to return to the caller.
    //

    if ( NlGlobalMemberWorkstation ) {
        DomainSidSize =
            RtlLengthSid( (PSID)PrimaryDomainInfo->PolicyDnsDomainInfo.Sid );
        *PrimaryDomainSid = LocalAlloc( 0, DomainSidSize );

        if ( *PrimaryDomainSid == NULL ) {
            NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL);
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RtlCopyMemory( *PrimaryDomainSid,
                       (PSID)PrimaryDomainInfo->PolicyDnsDomainInfo.Sid,
                       DomainSidSize );
    }



    //
    // Copy the Primary domain name into a buffer to return to the caller.
    //

    *DomainName = LocalAlloc( 0,
               PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length + sizeof(WCHAR) );

    if ( *DomainName == NULL ) {
        NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL);
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( *DomainName,
                   PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Buffer,
                   PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length );

    (*DomainName)[
       PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length /
            sizeof(WCHAR)] = L'\0';



    //
    // Copy the DNS Primary domain name into a buffer to return to the caller.
    //

    DnsDomainNameLength = PrimaryDomainInfo->PolicyDnsDomainInfo.DnsDomainName.Length / sizeof(WCHAR);

    if ( DnsDomainNameLength != 0 ) {

        *DnsDomainName = LocalAlloc( 0, (DnsDomainNameLength+2) * sizeof(WCHAR));

        if ( *DnsDomainName == NULL ) {
            NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL);
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RtlCopyMemory( *DnsDomainName,
                       PrimaryDomainInfo->PolicyDnsDomainInfo.DnsDomainName.Buffer,
                       DnsDomainNameLength*sizeof(WCHAR) );

        if ( (*DnsDomainName)[DnsDomainNameLength-1] != L'.' ) {
            (*DnsDomainName)[DnsDomainNameLength++] = L'.';
        }
        (*DnsDomainName)[DnsDomainNameLength] = L'\0';
    }


    //
    // Get the GUID of the domain we're a member of
    //

    if ( IsEqualGUID( &PrimaryDomainInfo->PolicyDnsDomainInfo.DomainGuid, &NlGlobalZeroGuid) ) {
        *PrimaryDomainGuid = NULL;
    } else {

        *PrimaryDomainGuid = LocalAlloc( 0, sizeof(GUID) );

        if ( *PrimaryDomainGuid == NULL ) {
            NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL);
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        **PrimaryDomainGuid = PrimaryDomainInfo->PolicyDnsDomainInfo.DomainGuid;
    }

    //
    // Set the name of the tree this domain is in.
    //

    NetStatus = NlSetDnsForestName( (PUNICODE_STRING)&PrimaryDomainInfo->PolicyDnsDomainInfo.DnsForestName,
                                  DnsForestNameChanged );

    if ( NetStatus != NO_ERROR ) {
        NlPrint((NL_CRITICAL, "Can't NlSetDnsForestName %ld\n", NetStatus ));
        NlExit( SERVICE_UIC_RESOURCE, NetStatus, LogError, NULL);
        goto Cleanup;
    }



    NetStatus = NERR_Success;
    //
    // Return
    //
Cleanup:
    if ( NetStatus != NERR_Success ) {
        if ( *PrimaryDomainSid != NULL ) {
            LocalFree (*PrimaryDomainSid);
            *PrimaryDomainSid = NULL;
        }
        if ( *AccountDomainSid != NULL ) {
            LocalFree (*AccountDomainSid);
            *AccountDomainSid = NULL;
        }
        if ( *DomainName != NULL ) {
            LocalFree (*DomainName);
            *DomainName = NULL;
        }
        if ( *DnsDomainName != NULL ) {
            NetApiBufferFree(*DnsDomainName);
            *DnsDomainName = NULL;
        }
        if ( *PrimaryDomainGuid != NULL ) {
            LocalFree (*PrimaryDomainGuid);
            *PrimaryDomainGuid = NULL;
        }

    }

    if ( AccountDomainInfo != NULL ) {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAccountDomainInformation,
            AccountDomainInfo );
    }

    if ( PrimaryDomainInfo != NULL ) {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            PrimaryDomainInfo );
    }

    if ( PolicyHandle != NULL ) {
        Status = LsarClose( &PolicyHandle );
        NlAssert( NT_SUCCESS(Status) );
    }
    return NetStatus;
}

NET_API_STATUS
NlGetDnsHostName(
    OUT LPWSTR *DnsHostName
    )
/*++

Routine Description:

    This routine gets DnsHostName of this machine.

Arguments:

    DnsHostName - Returns the DNS Host Name of the machine.
        Will return a NULL pointer if this machine has no DNS host name.
        Free this buffer using LocalFree.

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;

    WCHAR LocalDnsUnicodeHostName[NL_MAX_DNS_LENGTH+1];
    ULONG LocalDnsUnicodeHostNameLen;

    //
    // Get the DNS host name.
    //

    *DnsHostName = NULL;

    LocalDnsUnicodeHostNameLen = sizeof( LocalDnsUnicodeHostName ) / sizeof(WCHAR);
    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              LocalDnsUnicodeHostName,
                              &LocalDnsUnicodeHostNameLen )) {

        NetStatus = GetLastError();

        //
        // If we're not running TCP,
        //  simply use the Netbios name.
        //

        if ( NetStatus == ERROR_FILE_NOT_FOUND ) {
            *DnsHostName = NULL;
            NetStatus = NO_ERROR;
            goto Cleanup;

        } else {
            NlPrint(( NL_CRITICAL,
                      "Cannot GetComputerNameExW() %ld\n",
                      NetStatus ));
            goto Cleanup;
        }
    }

    //
    // Copy the string into an allocated buffer.
    //

    *DnsHostName = NetpAllocWStrFromWStr( LocalDnsUnicodeHostName );

    if ( *DnsHostName == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    NetStatus = NO_ERROR;

Cleanup:
    return NetStatus;;
}

NTSTATUS
NlGetNdncNames(
    OUT PDS_NAME_RESULTW **NdncNames,
    OUT GUID **NdncGuids,
    OUT PULONG NameCount
    )

/*++

Routine Description:

    Get the names of non-domain NCs we host from the DS

Arguments:

    NdncNames - Returns an array of pointers to DS_NAME_RESULT structures
        describing NDNC names. The number of returned DS_NAME_RESULT structures
        is given by NameCount. Each returned DS_NAME_RESULT structure must be freed
        by calling DsFreeNameResultW after which the NdncNames array itself must be
        freed by calling LocalFree.

    NameCount - Returns the number of DS_NAME_RESULT structures in the NdncNames array

Return Value:

    Status of operation.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG LocalReAllocLoopCount = 0;
    PDSNAME *DnList = NULL;
    ULONG DnListSize = 0;
    ULONG DnListEntryCount = 0;

    HANDLE hDs = NULL;
    LPWSTR NameToCrack;
    PDS_NAME_RESULTW CrackedName = NULL;
    PDS_NAME_RESULTW *LocalNdncNames = NULL;
    GUID *LocalNdncGuids = NULL;
    ULONG  LocalNameCount = 0;
    ULONG Index;

    //
    // Pre-allocate some memory for the list of NDNC DNs.
    //  Let's guess we are going to have 4 DNs of maximum
    //  DNS name size.
    //

    DnListSize = 4 * ( sizeof(DSNAME) + DNS_MAX_NAME_LENGTH*sizeof(WCHAR) );

    DnList = LocalAlloc( 0, DnListSize );
    if ( DnList == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Get the list of NDNC DNs
    //

    Status = NlGetConfigurationNamesList(
                            DSCONFIGNAMELIST_NCS,
                            DSCNL_NCS_NDNCS | DSCNL_NCS_LOCAL_MASTER,
                            &DnListSize,
                            DnList );

    //
    // If the buffer was small, keep reallocating it until
    //  it's big enough
    //

    while( Status == STATUS_BUFFER_TOO_SMALL ) {
        PDSNAME *TmpDnList = NULL;

        //
        // Guard against infinite loop
        //
        NlAssert( LocalReAllocLoopCount < 20 );
        if ( LocalReAllocLoopCount >= 20 ) {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        //
        // Reallocate the memory as much as needed
        //
        TmpDnList = LocalReAlloc( DnList,
                                  DnListSize,
                                  LMEM_MOVEABLE );

        if ( TmpDnList == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        DnList = TmpDnList;

        //
        // Call it again
        //
        Status = NlGetConfigurationNamesList(
                                DSCONFIGNAMELIST_NCS,
                                DSCNL_NCS_NDNCS | DSCNL_NCS_LOCAL_MASTER,
                                &DnListSize,
                                DnList );

        LocalReAllocLoopCount ++;
    }

    //
    // Error out on failure
    //

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Get the number of entries returned
    //

    for ( Index = 0; DnList[Index] != NULL; Index ++ ) {
        DnListEntryCount ++;
    }

    //
    // If there are no entries, we are done
    //

    if ( DnListEntryCount == 0 ) {
        NlPrint(( NL_CRITICAL, "NlGetNdncNames: GetConfigurationNamesList returned 0 entries\n" ));
        goto Cleanup;
    }

    //
    // Allocate a buffer to store the canonical NDNC names
    //

    LocalNdncNames = LocalAlloc( LMEM_ZEROINIT, DnListEntryCount * sizeof(PDS_NAME_RESULTW) );
    if ( LocalNdncNames == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Allocate a buffer to store the NDNC GUIDs
    //

    LocalNdncGuids = LocalAlloc( LMEM_ZEROINIT, DnListEntryCount * sizeof(GUID) );
    if( LocalNdncGuids == NULL ) {
	Status = STATUS_NO_MEMORY;
	goto Cleanup;
    }

    //
    // Crack each DN into canonical form
    //

    for ( Index = 0; DnList[Index] != NULL; Index ++ ) {
        NameToCrack = DnList[Index]->StringName;

        NetStatus = DsCrackNamesW(
                        NULL,     // No need to bind to DS for syntactical mapping
                        DS_NAME_FLAG_SYNTACTICAL_ONLY, // only syntactical mapping
                        DS_FQDN_1779_NAME,             // Translate from DN
                        DS_CANONICAL_NAME,             // Translate to canonical form
                        1,                             // 1 name to translate
                        &NameToCrack,                  // name to translate
                        &CrackedName );                // cracked name

        //
        // Use this name if it was cracked successfully
        //
        if ( NetStatus != NO_ERROR ) {
            NlPrint(( NL_CRITICAL, "NlGetNdncNames: DsCrackNamesW failed for %ws: 0x%lx\n",
                      NameToCrack,
                      NetStatus ));
        } else if ( CrackedName->rItems[0].status != DS_NAME_NO_ERROR ) {
            NlPrint(( NL_CRITICAL, "NlGetNdncNames: DsCrackNamesW substatus error for %ws: 0x%lx\n",
                      NameToCrack,
                      CrackedName->rItems[0].status ));
        } else if ( CrackedName->cItems != 1 ) {
            NlPrint(( NL_CRITICAL, "NlGetNdncNames: DsCrackNamesW returned %lu names for %ws\n",
                      CrackedName->cItems,
                      NameToCrack ));
        } else {
            LocalNdncNames[LocalNameCount] = CrackedName;
	    LocalNdncGuids[LocalNameCount] = DnList[Index]->Guid;
            LocalNameCount ++;
            CrackedName = NULL;
        }

        if ( CrackedName != NULL ) {
            DsFreeNameResultW( CrackedName );
            CrackedName = NULL;
        }
    }

    //
    // Success
    //

    Status = STATUS_SUCCESS;

Cleanup:

    if ( DnList != NULL ) {
        LocalFree( DnList );
    }

    //
    // Return the data on success
    //

    if ( NT_SUCCESS(Status) ) {
        *NdncNames = LocalNdncNames;
	*NdncGuids = LocalNdncGuids;
        *NameCount = LocalNameCount;
    } else {
	if ( LocalNdncNames != NULL ) {
	    for ( Index = 0; Index < LocalNameCount; Index++ ) {
		DsFreeNameResultW( LocalNdncNames[Index] );
	    }
	    LocalFree( LocalNdncNames );
	}
	if ( LocalNdncGuids != NULL ) {
	    LocalFree( LocalNdncGuids );
	}
    }

    return Status;
}

NET_API_STATUS
NlUpdateServicedNdncs(
    IN LPWSTR ComputerName,
    IN LPWSTR DnsHostName,
    IN BOOLEAN CallNlExitOnFailure,
    OUT PBOOLEAN ServicedNdncChanged OPTIONAL
    )

/*++

Routine Description:

    Update the serviced non-domain NC list.

Arguments:

    ComputerName - Name of this computer.

    DnsHostName - DNS Host name of this computer in the specified domain.

    CallNlExitOnFailure - TRUE if NlExit should be called on failure.

    ServicedNdncChanged - Set to TRUE if the list of NDNCs changed.

Return Value:

    Status of operation.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    NTSTATUS Status;

    PDS_NAME_RESULTW *NdncNames = NULL;
    GUID *NdncGuids = NULL;
    ULONG NdncCount = 0;
    ULONG CurrentNdncCount = 0;
    ULONG DeletedNdncCount = 0;
    ULONG NdncIndex;
    BOOLEAN LocalServicedNdncChanged = FALSE;

    PLIST_ENTRY DomainEntry;
    PDOMAIN_INFO DomainInfo;
    PDOMAIN_INFO *DeletedNdncArray = NULL;

    //
    // Avoid this operation in the setup mode when
    // we may not fully function as a DC as in the
    // case of a NT4 to NT5 DC upgrade.
    //

    if ( NlDoingSetup() ) {
        NlPrint(( NL_MISC, "NlUpdateServicedNdncs: avoid NDNC update in setup mode\n" ));
        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    //
    // If for some reason we have no DNS host name,
    // we don't support non-domain NC -- silently
    // ignore this update.
    //

    if ( DnsHostName == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NlUpdateServicedNdncs: Ignoring update since DnsHostName is NULL\n" ));
        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    //
    // Get the NDNC names from the DS
    //

    Status = NlGetNdncNames( &NdncNames,
			     &NdncGuids,
                             &NdncCount );

    if ( !NT_SUCCESS(Status) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        if ( CallNlExitOnFailure ) {
            NlExit( SERVICE_UIC_M_DATABASE_ERROR, NetStatus, LogErrorAndNetStatus, NULL );
        }
        goto Cleanup;
    }

    //
    // Allocate an array to store pointers to NDNCs
    //  that we may delete
    //

    EnterCriticalSection(&NlGlobalDomainCritSect);

    for ( DomainEntry = NlGlobalServicedNdncs.Flink ;
          DomainEntry != &NlGlobalServicedNdncs;
          DomainEntry = DomainEntry->Flink ) {

        CurrentNdncCount ++;
    }

    if ( CurrentNdncCount > 0 ) {
        DeletedNdncArray = LocalAlloc( LMEM_ZEROINIT, CurrentNdncCount * sizeof(PDOMAIN_INFO) );
        if ( DeletedNdncArray == NULL ) {
            LeaveCriticalSection(&NlGlobalDomainCritSect);
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Loop through NDNC entries we have and determine
    // whether the entry should be deleted
    //

    for ( DomainEntry = NlGlobalServicedNdncs.Flink ;
          DomainEntry != &NlGlobalServicedNdncs;
          DomainEntry = DomainEntry->Flink ) {

        DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, DomNext);

        //
        // Skip this entry if it's already marked for deletion
        //
        if ( DomainInfo->DomFlags & DOM_DELETED ) {
            continue;
        }

        //
        // Loop through the DS suplied NDNC names and see if
        // we already have this NDNC in our list
        //
        for ( NdncIndex = 0; NdncIndex < NdncCount; NdncIndex++ ) {
            if ( NlEqualDnsName( (LPCWSTR) DomainInfo->DomUnicodeDnsDomainName,
                                 (LPCWSTR) NdncNames[NdncIndex]->rItems[0].pDomain ) ) {
                break;
            }
        }

        //
        // If this NDNC that we have no longer exists,
        //  mark it for deletion
        //
        if ( NdncIndex == NdncCount ) {
            NlDeleteDomain( DomainInfo );

            //
            // Remember that this entry should be deleted
            //
            DeletedNdncArray[DeletedNdncCount] = DomainInfo;
            DeletedNdncCount ++;

            LocalServicedNdncChanged = TRUE;
        }
    }

    //
    // Add NDNCs that we don't already have
    //

    for ( NdncIndex = 0; NdncIndex < NdncCount; NdncIndex++ ) {

        DomainInfo = NULL;
        for ( DomainEntry = NlGlobalServicedNdncs.Flink ;
              DomainEntry != &NlGlobalServicedNdncs;
              DomainEntry = DomainEntry->Flink ) {

            DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, DomNext);

            //
            // If this entry is not to be deleted,
            //  check it for match
            //
            if ( (DomainInfo->DomFlags & DOM_DELETED) == 0 &&
                 NlEqualDnsName( (LPCWSTR) DomainInfo->DomUnicodeDnsDomainName,
                                 (LPCWSTR) NdncNames[NdncIndex]->rItems[0].pDomain ) ) {
                    break;
            }
            DomainInfo = NULL;
        }

        //
        // Add this NDNC to our list if we don't have it already
        //
        if ( DomainInfo == NULL ) {
            NetStatus = NlCreateDomainPhase1( NULL,              // No Netbios name for NDNC
                                              NdncNames[NdncIndex]->rItems[0].pDomain,
                                              NULL,              // No SID for NDNC
                                              &NdncGuids[NdncIndex],
                                              ComputerName,
                                              DnsHostName,
                                              CallNlExitOnFailure,
                                              DOM_NON_DOMAIN_NC, // This is NDNC
                                              &DomainInfo );

            if ( NetStatus == NO_ERROR ) {
                LocalServicedNdncChanged = TRUE;
                NlDereferenceDomain( DomainInfo );
            } else if ( CallNlExitOnFailure ) {
                // NlExit was already called
                break;
            }
        }
    }
    LeaveCriticalSection(&NlGlobalDomainCritSect);


    //
    // Now that the domain crit sect isn't locked
    //  we can safely unlink and delete the unneeded NDNCs
    //  by removing the last reference
    //

    for ( NdncIndex = 0; NdncIndex < DeletedNdncCount; NdncIndex++ ) {
        NlDereferenceDomain( DeletedNdncArray[NdncIndex] );
    }

Cleanup:

    if ( NdncNames != NULL ) {
        for ( NdncIndex = 0; NdncIndex < NdncCount; NdncIndex++ ) {
            DsFreeNameResultW( NdncNames[NdncIndex] );
        }
        LocalFree( NdncNames );
    }

    if ( NdncGuids != NULL ) {
	LocalFree( NdncGuids );
    }

    if ( DeletedNdncArray != NULL ) {
        LocalFree( DeletedNdncArray );
    }

    if ( NetStatus == NO_ERROR && ServicedNdncChanged != NULL ) {
        *ServicedNdncChanged = LocalServicedNdncChanged;
    }

    return NetStatus;
}

NTSTATUS
NlUpdateDnsRootAlias(
    IN PDOMAIN_INFO DomainInfo,
    OUT PBOOL AliasNamesChanged OPTIONAL
    )

/*++

Routine Description:

    Update the aliases for DNS domain and forest names.

Arguments:

    DomainInfo - Domain whose alias names should be updated.

    AliasNamesChanged - Set to TRUE if either the domain name
        alias or the forest name alias changed.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LPWSTR DnsDomainNameAlias = NULL;
    LPWSTR DnsForestNameAlias = NULL;
    LPSTR Utf8DnsDomainNameAlias = NULL;
    LPSTR Utf8DnsForestNameAlias = NULL;

    //
    // Initialization
    //

    if ( AliasNamesChanged != NULL ) {
        *AliasNamesChanged = FALSE;
    }

    //
    // Avoid this operation in the setup mode when
    // we may not fully function as a DC as in the
    // case of a NT4 to NT5 DC upgrade.
    //

    if ( NlDoingSetup() ) {
        NlPrint(( NL_MISC, "NlUpdateDnsRootAlias: avoid DnsRootAlias update in setup mode\n" ));
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Allocate the buffers
    //

    DnsDomainNameAlias = LocalAlloc( LMEM_ZEROINIT,
                                     DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR) );
    if ( DnsDomainNameAlias == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    DnsForestNameAlias = LocalAlloc( LMEM_ZEROINIT,
                                     DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR) );
    if ( DnsForestNameAlias == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Get the name aliases from the DS
    //

    Status = NlGetDnsRootAlias( DnsDomainNameAlias, DnsForestNameAlias );
    if ( !NT_SUCCESS(Status) ) {
        NlPrint(( NL_CRITICAL,
                  "NlUpdateDnsRootAlias: NlGetDnsRootAlias failed 0x%lx\n",
                  Status ));
        goto Cleanup;
    }

    //
    // Convert the names to UTF-8
    //

    if ( wcslen(DnsDomainNameAlias) > 0  ) {
        Utf8DnsDomainNameAlias = NetpAllocUtf8StrFromWStr( DnsDomainNameAlias );
        if ( Utf8DnsDomainNameAlias == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
    }

    if ( wcslen(DnsForestNameAlias) > 0 ) {
        Utf8DnsForestNameAlias = NetpAllocUtf8StrFromWStr( DnsForestNameAlias );
        if ( Utf8DnsForestNameAlias == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Update the DNS domain name alias
    //

    EnterCriticalSection( &NlGlobalDomainCritSect );

    //
    // Ignore this update if the name alias is same as the active one
    //
    //  Note: NlEqualDnsNameUtf8 checks for NULL on input
    //

    if ( NlEqualDnsNameUtf8(DomainInfo->DomUtf8DnsDomainName,
                            Utf8DnsDomainNameAlias) ) {

        NlPrint(( NL_CRITICAL,
           "NlUpdateDnsRootAlias: Ignoring DnsDomainNameAlias update for same active name: %s %s\n",
           DomainInfo->DomUtf8DnsDomainName,
           Utf8DnsDomainNameAlias ));

    //
    // Ignore this update if the name alias is same as the current name alias
    //

    } else if ( NlEqualDnsNameUtf8(DomainInfo->DomUtf8DnsDomainNameAlias,
                                   Utf8DnsDomainNameAlias) ) {

        NlPrint(( NL_CRITICAL,
           "NlUpdateDnsRootAlias: Ignoring DnsDomainNameAlias update for same alias name: %s %s\n",
           DomainInfo->DomUtf8DnsDomainNameAlias,
           Utf8DnsDomainNameAlias ));

    //
    // Otherwise update the alias
    //

    } else {

        if ( AliasNamesChanged != NULL ) {
            *AliasNamesChanged = TRUE;
        }

        NlPrint(( NL_DOMAIN,
                  "NlUpdateDnsRootAlias: Updating DnsDomainNameAlias from %s to %s\n",
                  DomainInfo->DomUtf8DnsDomainNameAlias,
                  Utf8DnsDomainNameAlias ));

        if ( DomainInfo->DomUtf8DnsDomainNameAlias != NULL ) {
            NetpMemoryFree( DomainInfo->DomUtf8DnsDomainNameAlias );
            DomainInfo->DomUtf8DnsDomainNameAlias = NULL;
        }

        DomainInfo->DomUtf8DnsDomainNameAlias = Utf8DnsDomainNameAlias;
        Utf8DnsDomainNameAlias = NULL;
    }

    LeaveCriticalSection( &NlGlobalDomainCritSect );

    //
    // Update the DNS forest name alias
    //

    EnterCriticalSection( &NlGlobalDnsForestNameCritSect );

    //
    // Ignore this update if the name alias is same as the active one
    //
    //  Note: NlEqualDnsNameUtf8 checks for NULL on input
    //

    if ( NlEqualDnsNameUtf8(NlGlobalUtf8DnsForestName,
                            Utf8DnsForestNameAlias) ) {

        NlPrint(( NL_CRITICAL,
           "NlUpdateDnsRootAlias: Ignoring DnsForestNameAlias update for same active name: %s %s\n",
           NlGlobalUtf8DnsForestName,
           Utf8DnsForestNameAlias));

    //
    // Ignore this update if the name alias is same as the current name alias
    //

    } else if ( NlEqualDnsNameUtf8(NlGlobalUtf8DnsForestNameAlias,
                                   Utf8DnsForestNameAlias) ) {

        NlPrint(( NL_CRITICAL,
           "NlUpdateDnsRootAlias: Ignoring DnsForestNameAlias update for same alias name: %s %s\n",
           NlGlobalUtf8DnsForestNameAlias,
           Utf8DnsForestNameAlias));

    } else {

        if ( AliasNamesChanged != NULL ) {
            *AliasNamesChanged = TRUE;
        }

        NlPrint(( NL_DOMAIN,
                  "NlUpdateDnsRootAlias: Updating DnsForestNameAlias from %s to %s\n",
                  NlGlobalUtf8DnsForestNameAlias,
                  Utf8DnsForestNameAlias ));

        if ( NlGlobalUtf8DnsForestNameAlias != NULL ) {
            NetpMemoryFree( NlGlobalUtf8DnsForestNameAlias );
            NlGlobalUtf8DnsForestNameAlias = NULL;
        }

        NlGlobalUtf8DnsForestNameAlias = Utf8DnsForestNameAlias;
        Utf8DnsForestNameAlias = NULL;
    }

    LeaveCriticalSection( &NlGlobalDnsForestNameCritSect );

    Status = STATUS_SUCCESS;

Cleanup:

    if ( DnsDomainNameAlias != NULL ) {
        LocalFree( DnsDomainNameAlias );
    }

    if ( DnsForestNameAlias != NULL ) {
        LocalFree( DnsForestNameAlias );
    }

    if ( Utf8DnsDomainNameAlias != NULL ) {
        NetpMemoryFree( Utf8DnsDomainNameAlias );
    }

    if ( Utf8DnsForestNameAlias != NULL ) {
        NetpMemoryFree( Utf8DnsForestNameAlias );
    }

    return Status;
}

NET_API_STATUS
NlInitializeDomains(
    VOID
    )

/*++

Routine Description:

    Initialize brdomain.c and create the primary domain.

Arguments:

    None

Return Value:

    Status of operation.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    PDOMAIN_INFO DomainInfo = NULL;
    LPWSTR ComputerName = NULL;
    LPWSTR DnsHostName = NULL;
    LPWSTR DomainName = NULL;
    LPWSTR DnsDomainName = NULL;
    PSID AccountDomainSid = NULL;
    PSID PrimaryDomainSid = NULL;
    GUID *DomainGuid = NULL;

    //
    // Initialize globals
    //

    try {
        InitializeCriticalSection( &NlGlobalDomainCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL );
        goto Cleanup;
    }

    InitializeListHead(&NlGlobalServicedDomains);
    InitializeListHead(&NlGlobalServicedNdncs);
    NlGlobalDomainsInitialized = TRUE;

    //
    // Get the computername and domain name of this machine
    //  (in both the Netbios and DNS forms).
    //

    NetStatus = NetpGetComputerName( &ComputerName );

    if ( NetStatus != NERR_Success ) {
        NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL );
        goto Cleanup;
    }

    NlGlobalUnicodeComputerName = NetpAllocWStrFromWStr( ComputerName );

    if ( NlGlobalUnicodeComputerName == NULL ) {
        NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL);
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    NetStatus = NlGetDomainName( &DomainName,
                                 &DnsDomainName,
                                 &AccountDomainSid,
                                 &PrimaryDomainSid,
                                 &DomainGuid,
                                 NULL );

    if ( NetStatus != NERR_Success ) {
        // NlExit was already called
        goto Cleanup;
    }

    // Be consistent.
    // Avoid getting a DNS Host Name if we have no DNS domain name.
    if ( DnsDomainName != NULL ) {
        NetStatus = NlGetDnsHostName( &DnsHostName );

        if ( NetStatus != NERR_Success ) {
            NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL );
            goto Cleanup;
        }
    }

    //
    // Create the Domain Info struct and initialize it.
    //

    NetStatus = NlCreateDomainPhase1( DomainName,
                                      DnsDomainName,
                                      AccountDomainSid,
                                      DomainGuid,
                                      ComputerName,
                                      DnsHostName,
                                      TRUE,               // Call NlExit on failure
                                      DOM_REAL_DOMAIN | DOM_PRIMARY_DOMAIN, // Primary domain of this machine
                                      &DomainInfo );

    if ( NetStatus != NERR_Success ) {
        // NlExit was already called
        goto Cleanup;
    }

    //
    // Finish workstation initialization.
    //

    if ( NlGlobalMemberWorkstation ) {

        //
        // Ensure the primary and account domain ID are different.
        //

        if ( RtlEqualSid( PrimaryDomainSid, AccountDomainSid ) ) {

            LPWSTR AlertStrings[3];

            //
            // alert admin.
            //

            AlertStrings[0] = DomainInfo->DomUnicodeComputerNameString.Buffer;
            AlertStrings[1] = DomainInfo->DomUnicodeDomainName;
            AlertStrings[2] = NULL;

            //
            // Save the info in the eventlog
            //

            NlpWriteEventlog(
                        ALERT_NetLogonSidConflict,
                        EVENTLOG_ERROR_TYPE,
                        AccountDomainSid,
                        RtlLengthSid( AccountDomainSid ),
                        AlertStrings,
                        2 );

            //
            // This isn't fatal. (Just drop through)
            //
        }


        LOCK_TRUST_LIST( DomainInfo );
        NlAssert( DomainInfo->DomClientSession == NULL );

        //
        //  Allocate the Client Session structure.
        //

        DomainInfo->DomClientSession = NlAllocateClientSession(
                                    DomainInfo,
                                    &DomainInfo->DomUnicodeDomainNameString,
                                    &DomainInfo->DomUnicodeDnsDomainNameString,
                                    PrimaryDomainSid,
                                    DomainInfo->DomDomainGuid,
                                    CS_DIRECT_TRUST |
                                        (DomainInfo->DomUnicodeDnsDomainNameString.Length != 0 ? CS_NT5_DOMAIN_TRUST : 0),
                                    WorkstationSecureChannel,
                                    0 );  //  No trust attributes

        if ( DomainInfo->DomClientSession == NULL ) {
            UNLOCK_TRUST_LIST( DomainInfo );
            NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL);
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Save a copy of the client session for convenience.
        //  A workstation only has one client session.
        //
        NlGlobalClientSession = DomainInfo->DomClientSession;
        UNLOCK_TRUST_LIST( DomainInfo );


    //
    //  Finish DC initialization.
    //

    } else {

        //
        // Do the time intensive portion of creating the domain.
        //

        NetStatus = NlCreateDomainPhase2( DomainInfo,
                                          TRUE );     // Call NlExit on failure

        if ( NetStatus != NERR_Success ) {
            // NlExit was already called
            goto Cleanup;
        }

        //
        // Initialize the list of non-domain NCs we host
        //

        NetStatus = NlUpdateServicedNdncs( ComputerName,
                                           DnsHostName,
                                           TRUE,    // Call NlExit on failure
                                           NULL );  // Don't care if NDNC list changed

        if ( NetStatus != NO_ERROR ) {
            // NlExit was already called
            goto Cleanup;
        }

        //
        // Update the domain and forest name aliases
        //

        Status = NlUpdateDnsRootAlias( DomainInfo,
                                       NULL );  // don't care if name changed

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            NlExit( SERVICE_UIC_M_DATABASE_ERROR, NetStatus, LogErrorAndNetStatus, NULL );
            goto Cleanup;
        }
    }



    NetStatus = NERR_Success;

    //
    // Free locally used resources
    //
Cleanup:
    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }
    if ( ComputerName != NULL ) {
        (VOID)NetApiBufferFree( ComputerName );
    }
    if ( DnsHostName != NULL ) {
        (VOID)LocalFree( DnsHostName );
    }
    if ( DomainName != NULL ) {
        (VOID)LocalFree( DomainName );
    }
    if ( DnsDomainName != NULL ) {
        (VOID)LocalFree( DnsDomainName );
    }
    if ( AccountDomainSid != NULL ) {
        (VOID)LocalFree( AccountDomainSid );
    }
    if ( PrimaryDomainSid != NULL ) {
        (VOID)LocalFree( PrimaryDomainSid );
    }
    if ( DomainGuid != NULL ) {
        (VOID)LocalFree( DomainGuid );
    }

    return NetStatus;
}


VOID
NlFreeComputerName(
    PDOMAIN_INFO DomainInfo
    )

/*++

Routine Description:

    Free the ComputerName fields for this domain.

Arguments:

    DomainInfo - Domain the computername is being defined for.

    ComputerName - Computername of this machine for the domain.

    DnsHostName - DNS Hostname of this machine for the domain.

Return Value:

    Status of operation.


--*/
{
    DomainInfo->DomUncUnicodeComputerName[0] = L'\0';

    RtlInitUnicodeString( &DomainInfo->DomUnicodeComputerNameString,
                          DomainInfo->DomUncUnicodeComputerName );
    if ( DomainInfo->DomUnicodeDnsHostNameString.Buffer != NULL ) {
        RtlFreeUnicodeString( &DomainInfo->DomUnicodeDnsHostNameString );
        RtlInitUnicodeString( &DomainInfo->DomUnicodeDnsHostNameString, NULL );
    }
    if ( DomainInfo->DomUtf8DnsHostName != NULL) {
        NetpMemoryFree( DomainInfo->DomUtf8DnsHostName );
        DomainInfo->DomUtf8DnsHostName = NULL;
    }

    DomainInfo->DomOemComputerName[0] = '\0';
    DomainInfo->DomOemComputerNameLength = 0;

    if ( DomainInfo->DomUtf8ComputerName != NULL ) {
        NetpMemoryFree( DomainInfo->DomUtf8ComputerName );
        DomainInfo->DomUtf8ComputerName = NULL;
    }
    DomainInfo->DomUtf8ComputerNameLength = 0;

}

NET_API_STATUS
NlSetComputerName(
    PDOMAIN_INFO DomainInfo,
    LPWSTR ComputerName,
    LPWSTR DnsHostName OPTIONAL
    )

/*++

Routine Description:

    Set a computed computername for an domain.

Arguments:

    DomainInfo - Domain the computername is being defined for.

    ComputerName - Computername of this machine for the domain.

    DnsHostName - DNS Hostname of this machine for the domain.

Return Value:

    Status of operation.


--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;


    NlPrintDom(( NL_DOMAIN,  DomainInfo,
              "Setting our computer name to %ws %ws\n", ComputerName, DnsHostName ));
    //
    // Copy the netbios computer name into the structure.
    //

    wcscpy( DomainInfo->DomUncUnicodeComputerName, L"\\\\" );
    NetStatus = I_NetNameCanonicalize(
                      NULL,
                      ComputerName,
                      DomainInfo->DomUncUnicodeComputerName+2,
                      sizeof(DomainInfo->DomUncUnicodeComputerName)-2*sizeof(WCHAR),
                      NAMETYPE_COMPUTER,
                      0 );


    if ( NetStatus != NERR_Success ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "ComputerName %ws is invalid\n",
                  ComputerName ));
        goto Cleanup;
    }

    RtlInitUnicodeString( &DomainInfo->DomUnicodeComputerNameString,
                          DomainInfo->DomUncUnicodeComputerName+2 );

    Status = RtlUpcaseUnicodeToOemN( DomainInfo->DomOemComputerName,
                                     sizeof(DomainInfo->DomOemComputerName),
                                     &DomainInfo->DomOemComputerNameLength,
                                     DomainInfo->DomUnicodeComputerNameString.Buffer,
                                     DomainInfo->DomUnicodeComputerNameString.Length);

    if (!NT_SUCCESS(Status)) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "Unable to convert computer name to OEM %ws %lx\n",
                  ComputerName, Status ));
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DomainInfo->DomOemComputerName[DomainInfo->DomOemComputerNameLength] = '\0';

    //
    // Copy the UTF-8 version of the netbios computer name into the structure.
    //

    DomainInfo->DomUtf8ComputerName = NetpAllocUtf8StrFromWStr( ComputerName );

    if (DomainInfo->DomUtf8ComputerName == NULL ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "Unable to convert computer name to UTF8 %ws\n",
                  DnsHostName ));
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DomainInfo->DomUtf8ComputerNameLength = strlen( DomainInfo->DomUtf8ComputerName );

    //
    // Copy the DNS Hostname into the structure.
    //

    if ( DnsHostName != NULL ) {
        if ( !RtlCreateUnicodeString( &DomainInfo->DomUnicodeDnsHostNameString, DnsHostName ) ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "Unable to RtlCreateUnicodeString for host name %ws\n",
                      DnsHostName ));
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        DomainInfo->DomUtf8DnsHostName =
                NetpAllocUtf8StrFromWStr( DnsHostName );
        if (DomainInfo->DomUtf8DnsHostName == NULL ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "Unable to convert host name to UTF8 %ws\n",
                      DnsHostName ));
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    } else {
        RtlInitUnicodeString( &DomainInfo->DomUnicodeDnsHostNameString, NULL );
        DomainInfo->DomUtf8DnsHostName = NULL;
    }





#ifdef _DC_NETLOGON
#ifdef notdef
    // ?? placeholder for telling DS
    //
    // Tell SAM what the computername for this domain is.
    //

    Status = SpmDbSetDomainServerName(
                    &DomainInfo->DomUnicodeDomainNameString,
                    &DomainInfo->DomUnicodeComputerNameString );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "Unable to SpmDbSetDomainServerName to %ws %lx\n",
                  ComputerName, Status ));
        Status = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }
#endif // notdef
#endif // _DC_NETLOGON

    //
    // All done.
    //
    NetStatus = NERR_Success;

Cleanup:
    //
    // On error, clear everything out.
    //
    if ( NetStatus != NERR_Success ) {
        NlFreeComputerName( DomainInfo );
    }
    return NetStatus;
}



#ifdef _DC_NETLOGON
#ifdef MULTIHOSTED_DOMAIN
// Handle DnsHostName too
NET_API_STATUS
NlAssignComputerName(
    PDOMAIN_INFO DomainInfo
    )

/*++

Routine Description:


    Assign a computername to a domain.  Register that computername
    with the SMB server as verification of it's validity.

Arguments:

    DomainInfo - Domain the computername is being defined for.

Return Value:

    Status of operation.


--*/
{
    NET_API_STATUS NetStatus;
    DWORD ComputerOrdinal;

    DWORD DefaultComputerOrdinal;
    DWORD MaximumComputerOrdinal = 0;
    DWORD OrdinalFromRegistry = 0;
    DWORD TotalRetryCount = 0;

    WCHAR ComputerName[CNLEN+1];



#ifdef notdef
    //
    // Compute the default ordinal.
    //

    NlGetDomainIndex( &DefaultComputerOrdinal, &MaximumComputerOrdinal );


    //
    // Get the value of the "EmulatedComputerName".  If the name is specified
    //  in the registry, use that name and don't fall back to any other name.
    //

    DataSize = sizeof(ComputerName);
    // ?? Read DnsNameForm, NetbiosName, and CurrentDnsName from the machine object
    NetStatus = RegQueryValueExW( DomainKeyHandle,
                                  NL_DOMAIN_EMULATED_COMPUTER_NAME,
                                  0,              // Reserved
                                  &KeyType,
                                  (LPBYTE)&ComputerName,
                                  &DataSize );

    if ( NetStatus != ERROR_FILE_NOT_FOUND ) {

        if ( NetStatus != ERROR_SUCCESS || KeyType != REG_SZ ) {
            // ??: write an event.
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "NlAssignComputerName: Cannot read %ws registry key %ld.\n",
                      NL_DOMAIN_EMULATED_COMPUTER_NAME,
                      NetStatus ));
        } else {

            //
            // Register the computer name.
            //

            NetStatus = NlServerComputerNameAdd(
                                                dns too
                            DomainInfo->DomUnicodeDomainName,
                            ComputerName );

            if ( NetStatus != NERR_Success ) {
                // ??: write an event.
                NlPrintDom(( NL_CRITICAL, DomainInfo,
                          "NlAssignComputerName: Cannot register computername %ws with SMB server %ld.\n",
                          ComputerName,
                          NetStatus ));
                goto Cleanup;
            }

            //
            // Save it.
            //

            NetStatus = NlSetComputerName( DomainInfo, ComputerName, DnsHostName );
            goto Cleanup;

        }

    }
#endif // notdef


    //
    // Get the value of the "EmulatedComputerOrdinal" indicating what our first
    //  try as a computername should be.
    //

#ifdef notdef
    DataSize = sizeof(ComputerOrdinal);
    // ?? Read DnsNameForm, NetbiosName, and CurrentDnsName from the machine object
    NetStatus = RegQueryValueExW( DomainKeyHandle,
                                  NL_DOMAIN_EMULATED_COMPUTER_ORDINAL,
                                  0,              // Reserved
                                  &KeyType,
                                  (LPBYTE)&OrdinalFromRegistry,
                                  &DataSize );

    if ( NetStatus != ERROR_SUCCESS ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlAssignComputerName: Cannot query %ws key (using defaults) %ld.\n",
                  NL_DOMAIN_EMULATED_COMPUTER_ORDINAL,
                  NetStatus ));

        ComputerOrdinal = DefaultComputerOrdinal;

    //
    // Validate the returned data.
    //

    } else if ( KeyType != REG_DWORD || DataSize != sizeof(OrdinalFromRegistry) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlAssignComputerName: Key %ws size/type wrong.\n",
                  NL_DOMAIN_EMULATED_COMPUTER_ORDINAL ));

        ComputerOrdinal = DefaultComputerOrdinal;

    //
    // Use the ordinal from the registry
    //

    } else {
        ComputerOrdinal = OrdinalFromRegistry;
    }
#else // notdef
    ComputerOrdinal = OrdinalFromRegistry;
#endif // notdef


    //
    // Loop trying the oridinal number to compute a computer name.
    //

    for (;;) {
        WCHAR OrdinalString[12];

        //
        // Build the computer name to test.
        //
        //  DOMAIN________N
        //
        // where DOMAIN is the domain name, N is the ordinal number, and
        //   there are enough _'s to pad to DNLEN.
        //

        wcscpy( ComputerName, DomainInfo->DomUnicodeDomainName );
        wcsncpy( &ComputerName[DomainInfo->DomUnicodeDomainNameString.Length/sizeof(WCHAR)],
                 L"________________",
                 DNLEN-DomainInfo->DomUnicodeDomainNameString.Length/sizeof(WCHAR) );
        ultow( ComputerOrdinal, OrdinalString, 10 );
        wcscpy( &ComputerName[DNLEN-wcslen(OrdinalString)],
                OrdinalString );

        //
        // Try to register the computer name.
        //

        NetStatus = NlServerComputerNameAdd(
                        DomainInfo->DomUnicodeDomainName,
                        ComputerName );

        if ( NetStatus != NERR_Success ) {

            //
            // If this name is in conflict with an existing name,
            //  try another ordinal.
            //
            //  Simply increment the ordinal to try.
            //  Don't try ordinals that conflict with other existing Domain Controllers.
            //

            if ( NetStatus == NERR_DuplicateName ) {
                NlPrintDom(( NL_CRITICAL, DomainInfo,
                          "NlAssignComputerName: Computername %ws is duplicate (Try another.)\n",
                          ComputerName,
                          NetStatus ));

                //
                // Allow several attempts to add the computername.
                //

                TotalRetryCount ++;

                if ( TotalRetryCount < 100 ) {
                    ComputerOrdinal = max(ComputerOrdinal + 1, MaximumComputerOrdinal*2 );
                    continue;
                }
            }

            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "NlAssignComputerName: Cannot register computername %ws with SMB server %ld.\n",
                      ComputerName,
                      NetStatus ));
            goto Cleanup;
        }

        //
        // If we've made it here, we have a valid computername.
        //

        break;

    }


#ifdef notdef
    //
    // Write the chosen ordinal to the registry so we don't have to work so hard
    //  next time.
    //

    NetStatus = RegSetValueExW( DomainKeyHandle,
                                NL_DOMAIN_EMULATED_COMPUTER_ORDINAL,
                                0,              // Reserved
                                REG_DWORD,
                                (LPBYTE)&ComputerOrdinal,
                                sizeof(ComputerOrdinal) );

    if ( NetStatus != ERROR_SUCCESS ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlAssignComputerName: Cannot set %ws key (ignored) %ld.\n",
                  NL_DOMAIN_EMULATED_COMPUTER_ORDINAL,
                  NetStatus ));
    }


    //
    // Done.
    //

    NetStatus = NlSetComputerName( DomainInfo, ComputerName, DnsHostName );
#endif // notdef

Cleanup:
#ifdef notdef
    if ( DomainKeyHandle != NULL ) {
        RegCloseKey( DomainKeyHandle );
    }
#endif // notdef

    if ( NetStatus == NERR_Success ) {
        NlPrintDom(( NL_DOMAIN, DomainInfo,
                  "Assigned computer name: %ws\n",
                  ComputerName ));
    }

    return NetStatus;

}
#endif // MULTIHOSTED_DOMAIN



VOID
NlDomainThread(
    IN LPVOID DomainInfoParam
)
/*++

Routine Description:

    Perform role change operations that are potentially time consuming.

    As such, this routine runs in a separate thread specific to the domain.

Arguments:

    DomainInfoParam - Domain who's role is to be updated.

Return Value:

    None.

    This routine logs any error it detects, but it doesn't call NlExit.


--*/
{
    NET_API_STATUS NetStatus;

    PDOMAIN_INFO DomainInfo = (PDOMAIN_INFO) DomainInfoParam;
    DWORD DomFlags;

    NlPrintDom(( NL_DOMAIN,  DomainInfo,
              "Domain thread started\n"));


    //
    // Loop forever.
    //
    // We only want one thread per domain.  Therefore, this thread
    //  stays around doing not only what was requested before it started,
    //  but also those tasks that are queued later.
    //

    for (;;) {

        //
        // If we've been asked to terminate,
        //  do so.
        //

        EnterCriticalSection(&NlGlobalDomainCritSect);
        if ( (DomainInfo->DomFlags & DOM_THREAD_TERMINATE) != 0 ||
             NlGlobalTerminate ) {
            NlPrintDom(( NL_DOMAIN,  DomainInfo,
                      "Domain thread asked to terminate\n"));
            DomainInfo->DomFlags &= ~DOM_THREAD_RUNNING;
            LeaveCriticalSection(&NlGlobalDomainCritSect);
            return;
        }

        //
        // If there are things to do,
        //  pick one thing to do and
        //  save it so we can safely drop the crit sect.
        //

        if ( DomainInfo->DomFlags & DOM_CREATION_NEEDED ) {
            DomFlags = DOM_CREATION_NEEDED;

        } else if ( DomainInfo->DomFlags & DOM_ROLE_UPDATE_NEEDED ) {
            DomFlags = DOM_ROLE_UPDATE_NEEDED;

        } else if ( DomainInfo->DomFlags & DOM_TRUST_UPDATE_NEEDED ) {
            DomFlags = DOM_TRUST_UPDATE_NEEDED;

        } else if ( DomainInfo->DomFlags & DOM_API_TIMEOUT_NEEDED ) {
            DomFlags = DOM_API_TIMEOUT_NEEDED;

        //
        // Pick up all work items accociate with the primary announcement
        //
        } else if ( DomainInfo->DomFlags & DOM_PRIMARY_ANNOUNCE_FLAGS ) {
            DomFlags = DomainInfo->DomFlags & DOM_PRIMARY_ANNOUNCE_FLAGS;

        } else {

            NlPrintDom(( NL_DOMAIN,  DomainInfo,
                      "Domain thread exitting\n"));
            DomainInfo->DomFlags &= ~DOM_THREAD_RUNNING;
            LeaveCriticalSection(&NlGlobalDomainCritSect);
            return;
        }

        DomainInfo->DomFlags &= ~DomFlags;
        LeaveCriticalSection(&NlGlobalDomainCritSect);






        //
        // If phase 2 of domain creation is needed,
        //  do it now.
        //

        if ( DomFlags & DOM_CREATION_NEEDED ) {
            NlPrintDom(( NL_DOMAIN,  DomainInfo,
                      "Domain thread started doing create phase 2\n"));

            //
            // Do the time intensive portion of creating the domain.
            //

            (VOID) NlCreateDomainPhase2( DomainInfo, FALSE );

        } else if ( DomFlags & DOM_ROLE_UPDATE_NEEDED ) {

            NlPrintDom(( NL_DOMAIN,  DomainInfo,
                      "Domain thread started doing update role\n"));

            (VOID) NlUpdateRole( DomainInfo );

        } else if ( DomFlags & DOM_TRUST_UPDATE_NEEDED ) {

            NlPrintDom(( NL_DOMAIN,  DomainInfo,
                      "Domain thread started doing update trust list\n"));

            (VOID) NlInitTrustList( DomainInfo );

        } else if ( DomFlags & DOM_API_TIMEOUT_NEEDED ) {

            NlPrintDom(( NL_DOMAIN,  DomainInfo,
                      "Domain thread started doing API timeout\n"));

            NlTimeoutApiClientSession( DomainInfo );

        } else if ( DomFlags & DOM_PRIMARY_ANNOUNCE_FLAGS ) {
            DWORD AnnounceFlags = 0;

            NlPrintDom(( NL_DOMAIN,  DomainInfo,
                      "Domain thread started doing primary announecement 0x%lx\n", DomFlags ));

            //
            // If we need to do immediate announcement,
            //  indicate so to the worker routine
            //
            if ( DomFlags & DOM_PRIMARY_ANNOUNCE_IMMEDIATE ) {
                AnnounceFlags = ANNOUNCE_IMMEDIATE;

            //
            // Otherwise, if we only need to continue announcement,
            //  indicate so to the worker routine
            //
            } else if ( (DomFlags & DOM_PRIMARY_ANNOUNCE_NEEDED) == 0 &&
                        (DomFlags & DOM_PRIMARY_ANNOUNCE_CONTINUE) != 0 ) {
                AnnounceFlags = ANNOUNCE_CONTINUE;
            }

            NlPrimaryAnnouncement( AnnounceFlags );

        //
        // Internal consistency check
        //

        } else {

            NlPrintDom((NL_CRITICAL, DomainInfo,
                     "Invalid DomFlags %lx\n",
                     DomFlags ));
        }
    }

}


VOID
NlStopDomainThread(
    PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Stops the domain thread if it is running and waits for it to
    stop.

Arguments:

    NONE

Return Value:

    NONE

--*/
{

    //
    // Only stop the thread if it's running
    //

    EnterCriticalSection( &NlGlobalDomainCritSect );
    if ( DomainInfo->DomFlags & DOM_THREAD_RUNNING ) {

        //
        // Ask the thread to stop running.
        //

        DomainInfo->DomFlags |= DOM_THREAD_TERMINATE;

        //
        // Loop waiting for it to stop.
        //

        while ( DomainInfo->DomFlags & DOM_THREAD_RUNNING ) {
            LeaveCriticalSection( &NlGlobalDomainCritSect );
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "NlStopDomainThread: Sleeping a second waiting for thread to stop.\n"));
            Sleep( 1000 );
            EnterCriticalSection( &NlGlobalDomainCritSect );
        }

        //
        // Domain thread no longer needs to terminate
        //

        DomainInfo->DomFlags &= ~DOM_THREAD_TERMINATE;

    }
    LeaveCriticalSection( &NlGlobalDomainCritSect );

    return;
}


NET_API_STATUS
NlStartDomainThread(
    PDOMAIN_INFO DomainInfo,
    PDWORD DomFlags
    )
/*++

Routine Description:

    Start the domain thread if it is not already running.

    The domain thread is simply one of the worker threads.  However, we
    ensure that only one worker thread is working on a single domain at once.
    That ensures that slow items (such as NlUpdateRole) don't consume more than
    one worker thread and are themselves serialized.

Arguments:

    DomainInfo - Domain the thread is to be started for.

    DomFlags - Specifies which operations the Domain Thread is to perform

Return Value:

    NO_ERROR

--*/
{
    //
    // Tell the thread what work it has to do.
    //

    EnterCriticalSection( &NlGlobalDomainCritSect );
    DomainInfo->DomFlags |= *DomFlags;

    //
    // If the domain thread is already running, do nothing.
    //

    if ( DomainInfo->DomFlags & DOM_THREAD_RUNNING ) {
        NlPrintDom((NL_DOMAIN,  DomainInfo,
                 "The domain thread is already running %lx.\n",
                 *DomFlags ));
        LeaveCriticalSection( &NlGlobalDomainCritSect );
        return NO_ERROR;
    }

    //
    // Start the thread
    //
    // Make this a high priority thread to avoid 100's of trusted domain discoveries.
    //

    DomainInfo->DomFlags &= ~DOM_THREAD_TERMINATE;

    if ( NlQueueWorkItem( &DomainInfo->DomThreadWorkItem, TRUE, TRUE ) ) {
        DomainInfo->DomFlags |= DOM_THREAD_RUNNING;
    }
    LeaveCriticalSection( &NlGlobalDomainCritSect );

    return NO_ERROR;

}



NTSTATUS
NlUpdateDatabaseRole(
    IN PDOMAIN_INFO DomainInfo,
    IN DWORD Role
    )

/*++

Routine Description:

    Update the role of the Sam database to match the current role of the domain.

    Netlogon sets the role of the domain to be the same as the role in SAM account domain.

Arguments:

    DomainInfo - Hosted Domain this database is for.

    Role - Our new Role.
        RoleInvalid implies the domain is being deleted.

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status;

    POLICY_LSA_SERVER_ROLE DesiredLsaRole;

    //
    // Convert the role to SAM/LSA specific values.
    //

    switch ( Role ) {
    case RolePrimary:
        DesiredLsaRole = PolicyServerRolePrimary;
        break;
    case RoleInvalid:
        Status = STATUS_SUCCESS;
        goto Cleanup;
    case RoleBackup:
        DesiredLsaRole = PolicyServerRoleBackup;
        break;
    default:
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                "NlUpdateDatabaseRole: Netlogon's role isn't valid %ld.\n",
                Role ));
        Status = STATUS_INVALID_DOMAIN_ROLE;
        goto Cleanup;
    }

    //
    // Ensure the changelog knows the current role.
    //  (This is really only needed on startup and if netlogon.dll has
    //  been unloaded.  Otherwise, the LSA will do this notification
    //  when the role is really changed.)
    //

    if ( NlGlobalNetlogonUnloaded &&
         NlGlobalChangeLogRole == ChangeLogUnknown ) {
        NlPrint((NL_INIT,
                "Set changelog role after netlogon.dll unload\n" ));
        Status = NetpNotifyRole ( DesiredLsaRole );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                    "NlUpdateDatabaseRole: Cannot NetpNotifyRole: %lx\n",
                    Status ));
            goto Cleanup;
        }
    }


    Status = STATUS_SUCCESS;

    //
    // Free locally used resources.
    //
Cleanup:

    return Status;

}





PCLIENT_SESSION
NlRefDomClientSession(
    IN PDOMAIN_INFO DomainInfo
    )

/*++

Routine Description:

    Increment the reference count on the ClientSession structure for the domain.
    If the ClientSession structure doesn't exist, this routine will FAIL.

Arguments:

    DomainInfo - Domain whose ClientSession reference count is to be incremented.

Return Value:

    Pointer to the client session structure whose reference count was
        properly incremented.

    NULL - The ClientSession structure doesn't exist

--*/
{
    PCLIENT_SESSION ClientSession;
    LOCK_TRUST_LIST( DomainInfo );
    if ( DomainInfo->DomClientSession != NULL ) {
        ClientSession = DomainInfo->DomClientSession;
        NlRefClientSession( ClientSession );
        UNLOCK_TRUST_LIST( DomainInfo );
        return ClientSession;
    } else {
        UNLOCK_TRUST_LIST( DomainInfo );
        return NULL;
    }

}





PCLIENT_SESSION
NlRefDomParentClientSession(
    IN PDOMAIN_INFO DomainInfo
    )

/*++

Routine Description:

    Increment the reference count on the ParentClientSession structure for the domain.
    If the ParentClientSession structure doesn't exist, this routine will FAIL.

Arguments:

    DomainInfo - Domain whose ParentClientSession reference count is to be incremented.

Return Value:

    Pointer to the client session structure whose reference count was
        properly incremented.

    NULL - The ParentClientSession structure doesn't exist

--*/
{
    PCLIENT_SESSION ClientSession;
    LOCK_TRUST_LIST( DomainInfo );
    if ( DomainInfo->DomParentClientSession != NULL ) {
        ClientSession = DomainInfo->DomParentClientSession;
        NlRefClientSession( ClientSession );
        UNLOCK_TRUST_LIST( DomainInfo );
        return ClientSession;
    } else {
        UNLOCK_TRUST_LIST( DomainInfo );
        return NULL;
    }

}



VOID
NlDeleteDomClientSession(
    IN PDOMAIN_INFO DomainInfo
    )

/*++

Routine Description:

    Delete the domain's ClientSession stucture (If it exists)

Arguments:

    DomainInfo - Domain whose ClientSession is to be deleted

Return Value:

    None.

--*/
{
    PCLIENT_SESSION ClientSession;

    //
    // Delete the client session
    //

    LOCK_TRUST_LIST( DomainInfo );
    if ( DomainInfo->DomClientSession != NULL ) {

        //
        // Don't allow any new references.
        //

        ClientSession = DomainInfo->DomClientSession;
        DomainInfo->DomClientSession = NULL;
        NlFreeClientSession( ClientSession );

        //
        // Don't leave a straggling pointer to the deleted ClientSession
        //
        if ( IsPrimaryDomain(DomainInfo) ) {
            NlGlobalClientSession = NULL;
        }

        //
        // Wait for us to be the last reference.
        //

        while ( ClientSession->CsReferenceCount != 1 ) {
            UNLOCK_TRUST_LIST( DomainInfo );
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "NlDeleteDomClientSession: Sleeping a second waiting for ClientSession RefCount to zero.\n"));
            Sleep( 1000 );
            LOCK_TRUST_LIST( DomainInfo );
        }

        NlUnrefClientSession( ClientSession );

    }
    UNLOCK_TRUST_LIST( DomainInfo );

}


VOID
NlDeleteDomParentClientSession(
    IN PDOMAIN_INFO DomainInfo
    )

/*++

Routine Description:

    Delete the domain's ClientSession stucture (If it exists)

Arguments:

    DomainInfo - Domain whose ClientSession is to be deleted

Return Value:

    None.

--*/
{
    PCLIENT_SESSION ClientSession;

    //
    // Delete the client session
    //

    LOCK_TRUST_LIST( DomainInfo );
    if ( DomainInfo->DomParentClientSession != NULL ) {

        //
        // Don't allow any new references.
        //

        ClientSession = DomainInfo->DomParentClientSession;
        DomainInfo->DomParentClientSession = NULL;
        NlFreeClientSession( ClientSession );


        //
        // Wait for us to be the last reference.
        //

        while ( ClientSession->CsReferenceCount != 1 ) {
            UNLOCK_TRUST_LIST( DomainInfo );
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "NlDeleteDomParentClientSession: Sleeping a second waiting for ClientSession RefCount to zero.\n"));
            Sleep( 1000 );
            LOCK_TRUST_LIST( DomainInfo );
        }

        NlUnrefClientSession( ClientSession );

    }
    UNLOCK_TRUST_LIST( DomainInfo );

}


NET_API_STATUS
NlUpdateRole(
    IN PDOMAIN_INFO DomainInfo
    )

/*++

Routine Description:

    Determines the role of this machine, sets that role in the Netlogon service,
    the server service, and browser.

Arguments:

    DomainInfo - Hosted domain who's role is to be updated.

Return Value:

    Status of operation.

    This routine logs any error it detects, but it doesn't call NlExit.

--*/
{
    LONG NetStatus;
    NTSTATUS Status;

    NETLOGON_ROLE NewRole;
    BOOL NewPdcDoReplication;
    BOOL PdcToConnectTo = FALSE;
    BOOL ReplLocked = FALSE;
    DWORD i;

    LPWSTR AllocatedBuffer = NULL;
    LPWSTR CapturedDnsDomainName;
    LPWSTR CapturedDnsForestName;
    GUID CapturedDomainGuidBuffer;
    GUID *CapturedDomainGuid;
    LPWSTR ChangeLogFile;
    ULONG InternalFlags = 0;

    PNL_DC_CACHE_ENTRY DomainControllerCacheEntry = NULL;
    PLIST_ENTRY ListEntry;

    BOOLEAN ThisIsPdc;
    BOOLEAN Nt4MixedDomain;

    //
    // Allocate a buffer for storage local to this procedure.
    //  (Don't put it on the stack since we don't want to commit a huge stack.)
    //

    AllocatedBuffer = LocalAlloc( 0, sizeof(WCHAR) *
                                        ((NL_MAX_DNS_LENGTH+1) +
                                         (NL_MAX_DNS_LENGTH+1) +
                                         (MAX_PATH+1) ) );

    if ( AllocatedBuffer == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    CapturedDnsDomainName = AllocatedBuffer;
    CapturedDnsForestName = &CapturedDnsDomainName[NL_MAX_DNS_LENGTH+1];
    ChangeLogFile = &CapturedDnsForestName[NL_MAX_DNS_LENGTH+1];


    //
    // Get the information used to determine role from the DS
    //

    NetStatus = NlGetRoleInformation(
                    DomainInfo,
                    &ThisIsPdc,
                    &Nt4MixedDomain );

    if ( NetStatus != ERROR_SUCCESS ) {

        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NlUpdateRole: Failed to NlGetRoleInformation. %ld\n",
                 NetStatus ));
        goto Cleanup;
    }


    //
    // Determine the current role of this machine.
    //

    if ( ThisIsPdc ) {
        NewRole = RolePrimary;
        NewPdcDoReplication = FALSE;

        if ( Nt4MixedDomain || NlGlobalParameters.AllowReplInNonMixed ) {
            NewPdcDoReplication = TRUE;
        }

    } else {
        NewRole = RoleBackup;
        NewPdcDoReplication = FALSE;
    }



    //
    // If the role has changed, tell everybody.
    //

    if ( DomainInfo->DomRole != NewRole ) {

        NlPrintDom((NL_DOMAIN, DomainInfo,
                "Changing role from %s to %s.\n",
                (DomainInfo->DomRole == RolePrimary) ? "PDC" :
                    (DomainInfo->DomRole == RoleBackup ? "BDC" : "NONE" ),
                (NewRole == RolePrimary) ? "PDC" :
                    (NewRole == RoleBackup ? "BDC" : "NONE" ) ));

        // ??: Shouldn't there be some synchronization here.
        DomainInfo->DomRole = NewRole;

        //
        // Create a ClientSession structure.
        //
        // Even the PDC has a client session to itself.  It is used (for instance)
        //  when the PDC changes its own machine account password.
        //

        LOCK_TRUST_LIST( DomainInfo );

        //
        // Allocate the Client Session structure used to talk to the PDC.
        //
        // DomClientSession will only be non-null if a previous promotion
        // to PDC failed.
        //

        if ( DomainInfo->DomClientSession == NULL ) {
            DomainInfo->DomClientSession = NlAllocateClientSession(
                                        DomainInfo,
                                        &DomainInfo->DomUnicodeDomainNameString,
                                        &DomainInfo->DomUnicodeDnsDomainNameString,
                                        DomainInfo->DomAccountDomainId,
                                        DomainInfo->DomDomainGuid,
                                        CS_DIRECT_TRUST |
                                            (DomainInfo->DomUnicodeDnsDomainNameString.Length != 0 ? CS_NT5_DOMAIN_TRUST : 0),
                                        ServerSecureChannel,
                                        0 );  // No trust attributes

            if ( DomainInfo->DomClientSession == NULL ) {
                UNLOCK_TRUST_LIST( DomainInfo );
                NlPrintDom(( NL_CRITICAL, DomainInfo,
                          "Cannot allocate PDC ClientSession\n"));
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;

                goto Cleanup;
            }
        }

        //
        // Save a copy of the client session for convenience.
        //  A BDC has only one client session to its PDC.
        //
        if ( IsPrimaryDomain(DomainInfo) ) {
            NlGlobalClientSession = DomainInfo->DomClientSession;
        }
        UNLOCK_TRUST_LIST( DomainInfo );

        //
        // If this machine is now a PDC,
        //  Perform PDC-specific initialization.
        //

        if ( DomainInfo->DomRole == RolePrimary ) {

            //
            // The first time this machine is promoted to PDC,
            //  Do some "one-time" initialization.

            EnterCriticalSection( &NlGlobalDomainCritSect );
            if ( (DomainInfo->DomFlags & DOM_PROMOTED_BEFORE) == 0 ) {

                //
                // Initialize the server session table to contain all the BDCs.
                // On demotion, we don't delete the table entries.  We just leave
                //  them around until the next promotion.
                //

                Status = NlBuildNtBdcList(DomainInfo);

                if ( !NT_SUCCESS(Status) ) {
                    LeaveCriticalSection( &NlGlobalDomainCritSect );
                    NlPrintDom(( NL_CRITICAL, DomainInfo,
                              "Cannot initialize NT BDC list: 0x%lx\n",
                              Status ));
                    NetStatus = NetpNtStatusToApiStatus( Status );
                    goto Cleanup;
                }

                //
                // Flag that we don't need to run this code again.
                //

                DomainInfo->DomFlags |= DOM_PROMOTED_BEFORE;
            }
            LeaveCriticalSection( &NlGlobalDomainCritSect );

            //
            // Free the list of failed user logons that could
            //  exist if this machine was a BDC
            //

            LOCK_TRUST_LIST( DomainInfo );
            while ( !IsListEmpty(&DomainInfo->DomFailedUserLogonList) ) {
                ListEntry = RemoveHeadList( &DomainInfo->DomFailedUserLogonList );

                //
                // Free the logon structure
                //
                LocalFree( CONTAINING_RECORD(ListEntry, NL_FAILED_USER_LOGON, FuNext) );
            }
            UNLOCK_TRUST_LIST( DomainInfo );
        }


        //
        // Tell the browser and the SMB server about our new role.
        //
        // Do this before the NetpLogonGetDCName since this registers the computer
        //  name of an hosted domain in the browser allowing the response from
        //  the PDC to be heard.
        //

        NlBrowserUpdate( DomainInfo, DomainInfo->DomRole );



        //
        // Check to see if the PDC is up and running.
        //
        // When NetpDcGetName is called from netlogon,
        //  it has both the Netbios and DNS domain name available for the primary
        //  domain.  That can trick DsGetDcName into returning DNS host name of a
        //  DC in the primary domain.  However, on IPX only systems, that won't work.
        //  Avoid that problem by not passing the DNS domain name of the primary domain
        //  if there are no DNS servers.
        //
        // Avoid having anything locked while calling NetpDcGetName.
        // It calls back into Netlogon and locks heaven only knows what.

        CapturedDomainGuid = NlCaptureDomainInfo( DomainInfo,
                                                  CapturedDnsDomainName,
                                                  &CapturedDomainGuidBuffer );
        NlCaptureDnsForestName( CapturedDnsForestName );

        NetStatus = NetpDcGetName(
                        DomainInfo,
                        DomainInfo->DomUnicodeComputerNameString.Buffer,
                        NULL,       // No account name
                        0,          // No account control bits
                        DomainInfo->DomUnicodeDomainName,
                        NlDnsHasDnsServers() ? CapturedDnsDomainName : NULL,
                        CapturedDnsForestName,
                        DomainInfo->DomAccountDomainId,
                        CapturedDomainGuid,
                        NULL,       // Site name not needed for PDC query
                        DS_FORCE_REDISCOVERY |
                            DS_PDC_REQUIRED |
                            DS_AVOID_SELF,      // Avoid responding to this call ourself
                        InternalFlags,
                        NL_DC_MAX_TIMEOUT + NlGlobalParameters.ExpectedDialupDelay*1000,
                        MAX_DC_RETRIES,
                        NULL,
                        &DomainControllerCacheEntry );

        //
        // If we've been asked to terminate,
        //  do so.
        //

        if ( (DomainInfo->DomFlags & DOM_THREAD_TERMINATE) != 0 ||
             NlGlobalTerminate ) {
            NlPrintDom(( NL_DOMAIN,  DomainInfo,
                      "Domain thread asked to terminate\n"));
            NetStatus = ERROR_OPERATION_ABORTED;
            goto Cleanup;
        }

        //
        // Handle the case where the PDC isn't up.
        //

        if ( NetStatus != NERR_Success) {

            //
            // Handle starting a BDC when there is no current primary in
            //  this domain.
            //

            if ( DomainInfo->DomRole == RoleBackup ) {

                // ??: Log hosted domain name with this message
                NlpWriteEventlog( SERVICE_UIC_M_NETLOGON_NO_DC,
                                  EVENTLOG_WARNING_TYPE,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

                //
                // Start normally but defer authentication with the
                //  primary until it starts.
                //

            }


        //
        // There is a primary dc running in this domain
        //

        } else {

            //
            // Since there already is a primary in the domain,
            //  we cannot become the primary.
            //

            if ( DomainInfo->DomRole == RolePrimary) {

                //
                // Don't worry if this is a BDC telling us that we're the PDC.
                //

                if ( (DomainControllerCacheEntry->UnicodeNetbiosDcName != NULL) &&
                     NlNameCompare( DomainInfo->DomUnicodeComputerNameString.Buffer,
                                    DomainControllerCacheEntry->UnicodeNetbiosDcName,
                                    NAMETYPE_COMPUTER) != 0 ){
                    LPWSTR AlertStrings[2];

                    //
                    // alert admin.
                    //

                    AlertStrings[0] = DomainControllerCacheEntry->UnicodeNetbiosDcName;
                    AlertStrings[1] = NULL; // Needed for RAISE_ALERT_TOO

                    // ??: Log hosted domain name with this message
                    // ??: Log the name of the other PDC (Put it in message too)
                    NlpWriteEventlog( SERVICE_UIC_M_NETLOGON_DC_CFLCT,
                                      EVENTLOG_ERROR_TYPE,
                                      NULL,
                                      0,
                                      AlertStrings,
                                      1 | NETP_RAISE_ALERT_TOO );
                    NetStatus = SERVICE_UIC_M_NETLOGON_DC_CFLCT;
                    goto Done;

                }


            //
            // If we're a BDC in the domain,
            //  sanity check the PDC.
            //

            } else {

                //
                // Indicate that there is a primary to connect to.
                //

                PdcToConnectTo = TRUE;

            }

        }


        //
        // Tell SAM/LSA about the new role
        //

        (VOID) NlUpdateDatabaseRole( DomainInfo, DomainInfo->DomRole );

    }



    //
    // Ensure there is only one hosted domain.
    //

    NlAssert( IsPrimaryDomain( DomainInfo ) );

    EnterCriticalSection( &NlGlobalReplicatorCritSect );
    ReplLocked = TRUE;

    //
    // If we're to replicate to NT 4 BDC's,
    //  remember that.
    //

    if ( NewPdcDoReplication != NlGlobalPdcDoReplication ) {
        NlGlobalPdcDoReplication = NewPdcDoReplication;

        if ( NlGlobalPdcDoReplication ) {
            NlPrintDom((NL_DOMAIN, DomainInfo,
                    "Setting this machine to be a PDC that replicates to NT 4 BDCs\n" ));

            //
            // Update the NlGlobalDBInfoArray for the various databases.
            //

            for ( i = 0; i < NUM_DBS; i++ ) {

                if ( i == LSA_DB) {
                    //
                    // Initialize LSA database info.
                    //

                    Status = NlInitLsaDBInfo( DomainInfo, LSA_DB );

                    if ( !NT_SUCCESS(Status) ) {
                        NlPrintDom(( NL_CRITICAL,  DomainInfo,
                                  "Cannot NlInitLsaDBInfo %lx\n",
                                  Status ));
                        NetStatus = NetpNtStatusToApiStatus( Status );
                        goto Cleanup;
                    }
                } else {

                    //
                    // Initialize the Sam domain.
                    //

                    Status = NlInitSamDBInfo( DomainInfo, i );

                    if ( !NT_SUCCESS(Status) ) {
                        NlPrintDom(( NL_CRITICAL,  DomainInfo,
                                  "Cannot NlInitSamDBInfo (%ws) %lx\n",
                                  NlGlobalDBInfoArray[i].DBName,
                                  Status ));
                        NetStatus = NetpNtStatusToApiStatus( Status );
                        goto Cleanup;
                    }
                }

            }
        }
    }


    //
    // If we haven't done so already,
    //  setup a session to the PDC.
    //

    if ( DomainInfo->DomRole == RoleBackup && PdcToConnectTo ) {
        PCLIENT_SESSION ClientSession;

        //
        // On a BDC, set up a session to the PDC now.
        //

        ClientSession = NlRefDomClientSession( DomainInfo );

        if ( ClientSession != NULL ) {

            if ( NlTimeoutSetWriterClientSession(
                    ClientSession,
                    WRITER_WAIT_PERIOD )) {

                if ( ClientSession->CsState != CS_AUTHENTICATED ) {
                    NET_API_STATUS TmpNetStatus;

                    //
                    // Reset the current DC.
                    //

                    NlSetStatusClientSession( ClientSession, STATUS_NO_LOGON_SERVERS );

                    //
                    // Set the PDC info in the Client Session structure.
                    //

                    TmpNetStatus = NlSetServerClientSession(
                                    ClientSession,
                                    DomainControllerCacheEntry,
                                    FALSE,    // was not discovery with account
                                    FALSE );  // not the session refresh

                    if ( TmpNetStatus == NO_ERROR ) {

                        //
                        // NT 5 BDCs only support NT 5 PDCs
                        //
                        EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
                        ClientSession->CsDiscoveryFlags |= CS_DISCOVERY_HAS_DS|CS_DISCOVERY_IS_CLOSE;
                        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

                        //
                        // Setup a session to the PDC.
                        //
                        // Avoid this step if we are in the process of starting
                        //  when we run in the main thread where we don't want to
                        //  hang on indefinitely long RPC calls made during the
                        //  session setup
                        //
                        if ( NlGlobalChangeLogNetlogonState != NetlogonStarting ) {
                            (VOID) NlSessionSetup( ClientSession );
                            // NlSessionSetup logged the error.
                        }
                    }
                }
                NlResetWriterClientSession( ClientSession );

            }

            NlUnrefClientSession( ClientSession );
        }
    }


    //
    // If we're a normal BDC
    //  we delete the change log to prevent confusion if we ever get promoted.
    //

    if ( IsPrimaryDomain(DomainInfo) ) {

        if ( DomainInfo->DomRole == RoleBackup ) {

            wcscpy( ChangeLogFile, NlGlobalChangeLogFilePrefix );
            wcscat( ChangeLogFile, CHANGELOG_FILE_POSTFIX );

            if ( DeleteFileW( ChangeLogFile ) ) {
                NlPrintDom(( NL_DOMAIN,  DomainInfo,
                             "NlUpdateRole: Deleted change log since this is now a BDC.\n" ));
            }
        }

        //
        // Delete the redo log.
        //  (NT 5 doesn't use the redo log any more.  This is simply cleanup.)
        //

        wcscpy( ChangeLogFile, NlGlobalChangeLogFilePrefix );
        wcscat( ChangeLogFile, REDO_FILE_POSTFIX );

        if ( DeleteFileW( ChangeLogFile ) ) {
            NlPrintDom(( NL_DOMAIN,  DomainInfo,
                         "NlUpdateRole: Deleted redo log since NT 5 doesn't use it.\n" ));
        }

    }


    //
    // Register the appropriate DNS names for this role.
    //
    // Avoid this operation at service startup (the appropriate service
    // notifications or timer expire will trigger DNS updates in the
    // main loop instead). These registrations can be lengthy and we
    // don't want to spend too much time on start up. Also, these DNS
    // updates may be secure which will result in calls into Kerberos
    // that may not be started yet on startup.
    //

    if ( NlGlobalChangeLogNetlogonState != NetlogonStarting ) {
        NetStatus = NlDnsAddDomainRecords( DomainInfo, 0 );

        //
        // On success, scavenge through the list
        //  of records and update DNS in a worker thread
        //
        if ( NetStatus != NO_ERROR ) {
            NlPrintDom(( NL_CRITICAL,  DomainInfo,
                         "NlUpdateRole: Couldn't register DNS names %ld\n", NetStatus  ));
            goto Cleanup;
        } else {
            NlDnsForceScavenge( FALSE,   // don't refresh domain records: we've done it already
                                FALSE ); // don't force re-register
        }
    }

    NetStatus = NERR_Success;
    goto Done;

Cleanup: {

    LPWSTR MsgStrings[1];

    NlPrintDom((NL_CRITICAL, DomainInfo,
            "NlUpdateRole Failed %ld",
             NetStatus ));

    MsgStrings[0] = (LPWSTR) ULongToPtr( NetStatus );

    // ??: Log hosted domain name with this message
    NlpWriteEventlog( NELOG_NetlogonSystemError,
                      EVENTLOG_ERROR_TYPE,
                      (LPBYTE)&NetStatus,
                      sizeof(NetStatus),
                      MsgStrings,
                      1 | NETP_LAST_MESSAGE_IS_NETSTATUS );

    }

    //
    // All done
    //

Done:
    //
    // If the operation failed,
    //  indicate that we need to try again periodically.
    //
    if ( NetStatus != NO_ERROR ) {
        DomainInfo->DomRole = RoleInvalid;
    }

    if ( DomainControllerCacheEntry != NULL) {
        NetpDcDerefCacheEntry( DomainControllerCacheEntry );
    }
    if ( ReplLocked ) {
        LeaveCriticalSection( &NlGlobalReplicatorCritSect );
    }

    if ( AllocatedBuffer != NULL ) {
        LocalFree( AllocatedBuffer );
    }

    return NetStatus;

}
#endif // _DC_NETLOGON


NET_API_STATUS
NlCreateDomainPhase1(
    IN LPWSTR DomainName OPTIONAL,
    IN LPWSTR DnsDomainName OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPWSTR ComputerName,
    IN LPWSTR DnsHostName OPTIONAL,
    IN BOOLEAN CallNlExitOnFailure,
    IN ULONG DomainFlags,
    OUT PDOMAIN_INFO *ReturnedDomainInfo
    )

/*++

Routine Description:

    Create a new domain object to the point where the remainder of the object
        can be created asynchronously in a domain specific worker thread.

Arguments:

    DomainName - Netbios Name of the domain to host.

    DnsDomainName - DNS name of the domain to host.
        NULL if the domain has no DNS Domain Name.

    DomainSid - DomainSid of the specified domain.

    DomainGuid - GUID of the specified domain.

    ComputerName - Name of this computer in the specified domain.
        NULL if not the primary domain for the DC.

    DnsHostName - DNS Host name of this computer in the specified domain.
        NULL if the domain has no DNS host name or if not the primary domain
        for the DC.

    CallNlExitOnFailure - TRUE if NlExit should be called on failure.

    DomainFlags - Specifies proporties of this domain such as primary domain,
        non-domain NC, forest entry.

    ReturnedDomainInfo - On success, returns a pointer to a referenced DomainInfo
        structure.  It is the callers responsibility to call NlDereferenceDomain.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    BOOLEAN CanCallNlDeleteDomain = FALSE;

    PDOMAIN_INFO DomainInfo = NULL;
    DWORD DomainSidSize = 0;

    LPBYTE Where;
    ULONG i;
    DWORD DomFlags = 0;

    BOOL DomainCreated = FALSE;

    //
    // Initialization
    //

    EnterCriticalSection(&NlGlobalDomainCritSect);
    NlPrint(( NL_DOMAIN, "%ws: Adding new domain\n",
              (DomainName != NULL) ? DomainName : DnsDomainName ));

    if ( DomainSid != NULL ) {
        DomainSidSize = RtlLengthSid( DomainSid );
    }


    //
    // See if the domain already exists.
    //

    if ( DomainName != NULL ) {
        DomainInfo = NlFindNetbiosDomain( DomainName, FALSE );
    } else if ( DnsDomainName != NULL ) {
        LPSTR Utf8DnsDomainName = NetpAllocUtf8StrFromWStr( DnsDomainName );

        if ( Utf8DnsDomainName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            if ( CallNlExitOnFailure ) {
                NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL );
            }
            goto Cleanup;
        }

        DomainInfo = NlFindDnsDomain( Utf8DnsDomainName,
                                      DomainGuid,
                                      TRUE,   // look up NDNCs too
                                      FALSE,  // don't check alias names
                                      NULL ); // don't care if alias name matched

        NetpMemoryFree( Utf8DnsDomainName );
    }

    if ( DomainInfo != NULL ) {
        DomainCreated = FALSE;
#ifdef _DC_NETLOGON
        DomainInfo->DomFlags &= ~DOM_DOMAIN_REFRESH_PENDING;
#endif // _DC_NETLOGON

    } else {
        DomainCreated = TRUE;

        //
        // Allocate a structure describing the new domain.
        //

        DomainInfo = LocalAlloc(
                        LMEM_ZEROINIT,
                        ROUND_UP_COUNT( sizeof(DOMAIN_INFO), ALIGN_DWORD) +
                            DomainSidSize );

        if ( DomainInfo == NULL ) {
            NetStatus = GetLastError();
            if ( CallNlExitOnFailure ) {
                NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL);
            }
            goto Cleanup;
        }

        //
        // Create an interim reference count for this domain.
        //  (Once for the reference by this routine.)
        //

        DomainInfo->ReferenceCount = 1;
        NlGlobalServicedDomainCount ++;

#ifdef _DC_NETLOGON
        //
        // Set the domain flags
        //

        DomainInfo->DomFlags |= DomainFlags;
        if ( DomainInfo->DomFlags & DOM_PRIMARY_DOMAIN ) {
            NlGlobalDomainInfo = DomainInfo;
        }

        //
        // Set the role we play in this domain
        //

        if ( NlGlobalMemberWorkstation ) {
            DomainInfo->DomRole = RoleMemberWorkstation;
        } else if ( DomainInfo->DomFlags & DOM_NON_DOMAIN_NC ) {
            DomainInfo->DomRole = RoleNdnc;
        } else if ( DomainInfo->DomFlags & DOM_REAL_DOMAIN ) {
            DomainInfo->DomRole = RoleInvalid;  // For real domains, force the role update
        }
#endif // _DC_NETLOGON

        //
        // Initialize other constants.
        //

        RtlInitUnicodeString(  &DomainInfo->DomUnicodeComputerNameString, NULL );

        InitializeListHead(&DomainInfo->DomNext);
#ifdef _DC_NETLOGON
        InitializeListHead( &DomainInfo->DomTrustList );
        InitializeListHead( &DomainInfo->DomServerSessionTable );
        InitializeListHead( &DomainInfo->DomFailedUserLogonList );
#endif // _DC_NETLOGON
        NlInitializeWorkItem(&DomainInfo->DomThreadWorkItem, NlDomainThread, DomainInfo);

        try {
            InitializeCriticalSection( &DomainInfo->DomTrustListCritSect );
#ifdef _DC_NETLOGON
            InitializeCriticalSection( &DomainInfo->DomServerSessionTableCritSect );
#endif // _DC_NETLOGON
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            NlPrint(( NL_CRITICAL, "%ws: Cannot InitializeCriticalSections for domain\n",
                      DomainName ));
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            if ( CallNlExitOnFailure ) {
                NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL );
            }
            goto Cleanup;
        }




        //
        // If the caller passed in a ComputerName,
        //  use it.
        //

        if ( ComputerName != NULL ) {

            NetStatus = NlSetComputerName( DomainInfo, ComputerName, DnsHostName );

            if ( NetStatus != NERR_Success ) {
                NlPrint(( NL_CRITICAL,
                          "%ws: Cannot set ComputerName\n",
                          DomainName ));
                if ( CallNlExitOnFailure ) {
                    NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL );
                }
                goto Cleanup;
            }
        }



        //
        // Copy the domain id onto the end of the allocated buffer.
        //  (ULONG aligned)
        //

        Where = (LPBYTE)(DomainInfo+1);
        Where = ROUND_UP_POINTER( Where, ALIGN_DWORD );
        if ( DomainSid != NULL ) {
            RtlCopyMemory( Where, DomainSid, DomainSidSize );
            DomainInfo->DomAccountDomainId = (PSID) Where;
            Where += DomainSidSize;
        }

        //
        // Set the domain names in the structure.
        //

        NetStatus = NlSetDomainNameInDomainInfo( DomainInfo, DnsDomainName, DomainName, DomainGuid, NULL, NULL, NULL );

        if ( NetStatus != NERR_Success ) {
            NlPrint(( NL_CRITICAL,
                      "%ws: Cannot set DnsDomainName\n",
                      DomainName ));
            if ( CallNlExitOnFailure ) {
                NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL );
            }
            goto Cleanup;
        }



        //
        // Open the LSA for real domain
        //
        // ?? I'll need to identify which hosted domain here.

        if ( DomainInfo->DomFlags & DOM_REAL_DOMAIN ) {

            Status = LsaIOpenPolicyTrusted( &DomainInfo->DomLsaPolicyHandle );

            if ( !NT_SUCCESS(Status) ) {
                NlPrint((NL_CRITICAL,
                         "%ws: Can't LsaIOpenPolicyTrusted: 0x%lx.\n",
                         DomainName,
                         Status ));
                NetStatus = NetpNtStatusToApiStatus(Status);
                if ( CallNlExitOnFailure ) {
                    NlExit( SERVICE_UIC_M_DATABASE_ERROR, NetStatus, LogError, NULL);
                }
                goto Cleanup;
            }

            //
            // Open Sam
            //
            // ?? I'll need to identify which hosted domain here.
            //

            Status = SamIConnect(
                        NULL,       // No server name
                        &DomainInfo->DomSamServerHandle,
                        0,          // Ignore desired access
                        TRUE );     // Trusted client

            if ( !NT_SUCCESS(Status) ) {
                NlPrint((NL_CRITICAL,
                         "%ws: Can't SamIConnect: 0x%lx.\n",
                         DomainName,
                         Status ));
                NetStatus = NetpNtStatusToApiStatus(Status);
                if ( CallNlExitOnFailure ) {
                    NlExit( SERVICE_UIC_M_DATABASE_ERROR, NetStatus, LogError, NULL);
                }
                goto Cleanup;
            }

            //
            // Open the Account domain.
            //

            Status = SamrOpenDomain( DomainInfo->DomSamServerHandle,
                                     DOMAIN_ALL_ACCESS,
                                     DomainInfo->DomAccountDomainId,
                                     &DomainInfo->DomSamAccountDomainHandle );

            if ( !NT_SUCCESS(Status) ) {
                NlPrint(( NL_CRITICAL,
                        "%ws: ACCOUNT: Cannot SamrOpenDomain: %lx\n",
                        DomainName,
                        Status ));
                DomainInfo->DomSamAccountDomainHandle = NULL;
                NetStatus = NetpNtStatusToApiStatus(Status);
                if ( CallNlExitOnFailure ) {
                    NlExit( SERVICE_UIC_M_DATABASE_ERROR, NetStatus, LogError, NULL);
                }
                goto Cleanup;
            }

            //
            // Open the Builtin domain.
            //

            Status = SamrOpenDomain( DomainInfo->DomSamServerHandle,
                                     DOMAIN_ALL_ACCESS,
                                     BuiltinDomainSid,
                                     &DomainInfo->DomSamBuiltinDomainHandle );

            if ( !NT_SUCCESS(Status) ) {
                NlPrint(( NL_CRITICAL,
                        "%ws: BUILTIN: Cannot SamrOpenDomain: %lx\n",
                        DomainName,
                        Status ));
                DomainInfo->DomSamBuiltinDomainHandle = NULL;
                NetStatus = NetpNtStatusToApiStatus(Status);
                if ( CallNlExitOnFailure ) {
                    NlExit( SERVICE_UIC_M_DATABASE_ERROR, NetStatus, LogError, NULL);
                }
                goto Cleanup;
            }
        }
    }


    //
    // Only link the entry in if we just created it.
    //  Wait to link the entry in until it is fully initialized.
    //

    if ( DomainCreated ) {
        //
        // Link the domain into the appropriate list of domains
        //
        // Increment the reference count for being on the global list.
        //

        DomainInfo->ReferenceCount ++;
        if ( DomainInfo->DomFlags & DOM_REAL_DOMAIN ) {
            InsertTailList(&NlGlobalServicedDomains, &DomainInfo->DomNext);
        } else if ( DomainInfo->DomFlags & DOM_NON_DOMAIN_NC ) {
            InsertTailList(&NlGlobalServicedNdncs, &DomainInfo->DomNext);
        }

        CanCallNlDeleteDomain = TRUE;
    }


    NetStatus = NERR_Success;


    //
    // Free Locally used resources
    //
Cleanup:

    //
    // Return a pointer to the DomainInfo struct to the caller.
    //
    if (NetStatus == NERR_Success) {
        *ReturnedDomainInfo = DomainInfo;

    //
    // Cleanup on error.
    //
    } else {


        //
        // If we created the domain,
        //  handle deleting it.
        //

        if ( DomainCreated ) {

            //
            // If we've initialized to the point where we can call
            //  we can call NlDeleteDomain, do so.
            //

            if ( CanCallNlDeleteDomain ) {
                DomainInfo->ReferenceCount --;
                (VOID) NlDeleteDomain( DomainInfo );

            }

        }

        //
        // Dereference the domain on error.
        //
        if (DomainInfo != NULL) {
            NlDereferenceDomain( DomainInfo );
        }

    }

    LeaveCriticalSection(&NlGlobalDomainCritSect);
    return NetStatus;
}

#ifdef _DC_NETLOGON
NET_API_STATUS
NlCreateDomainPhase2(
    IN PDOMAIN_INFO DomainInfo,
    IN BOOLEAN CallNlExitOnFailure
    )

/*++

Routine Description:

    Finish creating a new domain to host.

    Phase 2 of creation is designed to be called from a worker thread.  It
    contains all time intensive portions of domain creation.

Arguments:

    DomainInfo - Pointer to domain to finish creating.

    CallNlExitOnFailure - TRUE if NlExit should be called on failure.

Return Value:

    Status of operation.

    If this is the primary domain for this DC, NlExit is called upon failure.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    ULONG i;

    BOOL DomainCreated;
    ULONG AccountRid = 0;

    //
    // Initialization
    //

    NlPrintDom(( NL_DOMAIN, DomainInfo,
              "Create domain phase 2\n"));

#ifdef MULTIHOSTED_DOMAIN
    //
    // If a new computername is needed for this machine,
    //  assign one.
    //

    if ( DomainInfo->DomOemComputerNameLength == 0 ) {

        NetStatus = NlAssignComputerName( DomainInfo );

        if ( NetStatus != NERR_Success ) {
            // ??: Write event
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "can't NlAssignComputerName %ld.\n",
                    NetStatus ));
            if ( CallNlExitOnFailure ) {
                NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL );
            }
            goto Cleanup;
        }

        //
        // If we've been asked to terminate,
        //  do so.
        //

        if ( (DomainInfo->DomFlags & DOM_THREAD_TERMINATE) != 0 ||
             NlGlobalTerminate ) {
            NlPrintDom(( NL_DOMAIN,  DomainInfo,
                      "Domain thread asked to terminate\n"));
            NetStatus = ERROR_OPERATION_ABORTED;
            goto Cleanup;
        }
    }
#endif // MULTIHOSTED_DOMAIN


    //
    // Determine role from DS
    //

    NetStatus = NlUpdateRole( DomainInfo );

    if ( NetStatus != NERR_Success ) {

        //
        // Having another PDC in the domain isn't fatal.
        //  (Continue running in the RoleInvalid state until the matter is
        //  resolved.)
        //
        if ( NetStatus != SERVICE_UIC_M_NETLOGON_DC_CFLCT ) {
            NlPrintDom((NL_INIT, DomainInfo,
                     "Couldn't NlUpdateRole %ld 0x%lx.\n",
                     NetStatus, NetStatus ));
            // NlUpdateRole logged the error.
            if ( CallNlExitOnFailure ) {
                NlExit( NELOG_NetlogonSystemError, NetStatus, DontLogError, NULL );
            }
            goto Cleanup;
        }
    }

    //
    // Determine the RID for our computer account
    //

    Status = NlSamOpenNamedUser( DomainInfo,
                                 DomainInfo->DomClientSession->CsAccountName,
                                 NULL,
                                 &AccountRid,
                                 NULL );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL,  DomainInfo,
                     "Cannot NlSamOpenNamedUser 0x%lx\n",
                     Status ));
        if ( CallNlExitOnFailure ) {
            NlExit( SERVICE_UIC_M_DATABASE_ERROR, Status, LogErrorAndNtStatus, NULL);
        }
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    NlAssert( AccountRid != 0 );
    DomainInfo->DomDcComputerAccountRid = AccountRid;

    //
    // Determine the trust list from the LSA.
    //

    if ( !GiveInstallHints( FALSE ) ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Status = NlInitTrustList( DomainInfo );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL,  DomainInfo,
                  "Cannot NlInitTrustList %lX\n",
                  Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        if ( CallNlExitOnFailure ) {
            NlExit( NELOG_NetlogonFailedToUpdateTrustList, NetStatus, LogErrorAndNtStatus, NULL);
        }
        goto Cleanup;
    }

    NetStatus = NERR_Success;


    //
    // Free Locally used resources
    //
Cleanup:

    return NetStatus;
}
#endif // _DC_NETLOGON


GUID *
NlCaptureDomainInfo (
    IN PDOMAIN_INFO DomainInfo,
    OUT WCHAR DnsDomainName[NL_MAX_DNS_LENGTH+1] OPTIONAL,
    OUT GUID *DomainGuid OPTIONAL
    )
/*++

Routine Description:

    Captures a copy of the DnsDomainName and domain GUID for a domain

Arguments:

    DomainInfo - Specifies the hosted domain to return the DNS domain name for.

    DnsDomainName - Returns the DNS name of the domain.
        If there is none, an empty string is returned.

    DomainGuid -  Returns the domain GUID of the domain.
        If there is none, a zero GUID is returned.

Return Value:

    If there is a domain GUID, returns a pointer to the passed in DomainGuid buffer.
    If not, returns NULL

--*/
{
    GUID *ReturnGuid;

    LOCK_TRUST_LIST( DomainInfo );
    if ( ARGUMENT_PRESENT( DnsDomainName )) {
        if ( DomainInfo->DomUnicodeDnsDomainName == NULL ) {
            *DnsDomainName = L'\0';
        } else {
            wcscpy( DnsDomainName, DomainInfo->DomUnicodeDnsDomainName );
        }
    }


    //
    // If the caller wants the domain GUID to be returned,
    //  return it.
    //
    if ( ARGUMENT_PRESENT( DomainGuid )) {
        *DomainGuid = DomainInfo->DomDomainGuidBuffer;
        if ( DomainInfo->DomDomainGuid == NULL ) {
            ReturnGuid = NULL;
        } else {
            ReturnGuid = DomainGuid;
        }
    } else {
        ReturnGuid = NULL;
    }
    UNLOCK_TRUST_LIST( DomainInfo );

    return ReturnGuid;
}

VOID
NlFreeDnsDomainDomainInfo(
    IN PDOMAIN_INFO DomainInfo
    )

/*++

Routine Description:

    Frees the DNS domain in the DomainInfo structure.

Arguments:

    DomainInfo - Domain to free the DNS domain name for.

Return Value:

    Status of operation.

--*/
{

    //
    // Free the previous allocated block.
    //

    EnterCriticalSection(&NlGlobalDomainCritSect);
    LOCK_TRUST_LIST( DomainInfo );
    if ( DomainInfo->DomUnicodeDnsDomainName != NULL ) {
        LocalFree( DomainInfo->DomUnicodeDnsDomainName );
    }
    if ( DomainInfo->DomUtf8DnsDomainNameAlias != NULL ) {
        NetpMemoryFree( DomainInfo->DomUtf8DnsDomainNameAlias );
    }
    DomainInfo->DomUnicodeDnsDomainName = NULL;
    DomainInfo->DomUtf8DnsDomainName = NULL;
    DomainInfo->DomUtf8DnsDomainNameAlias = NULL;
    DomainInfo->DomUnicodeDnsDomainNameString.Buffer = NULL;
    DomainInfo->DomUnicodeDnsDomainNameString.MaximumLength = 0;
    DomainInfo->DomUnicodeDnsDomainNameString.Length = 0;
    UNLOCK_TRUST_LIST( DomainInfo );
    LeaveCriticalSection(&NlGlobalDomainCritSect);

}

NET_API_STATUS
NlSetDomainForestRoot(
    IN PDOMAIN_INFO DomainInfo,
    IN PVOID Context
    )
/*++

Routine Description:

    The routine sets the DOM_FOREST_ROOT bit on the DomainInfo.

    It simply compares the name of the domain with the name of the forest and sets the bit.

Arguments:

    DomainInfo - The domain being set

    Context - Not Used

Return Value:

    Success (not used).

--*/
{

    //
    // Only set the bit if netlogon is running,
    //

    if ( NlGlobalDomainsInitialized ) {

        EnterCriticalSection( &NlGlobalDnsForestNameCritSect );
        EnterCriticalSection( &NlGlobalDomainCritSect );

        if ( NlEqualDnsNameU( &NlGlobalUnicodeDnsForestNameString,
                              &DomainInfo->DomUnicodeDnsDomainNameString ) ) {

            DomainInfo->DomFlags |= DOM_FOREST_ROOT;

        } else {
            DomainInfo->DomFlags &= ~DOM_FOREST_ROOT;
        }

        LeaveCriticalSection( &NlGlobalDomainCritSect );
        LeaveCriticalSection( &NlGlobalDnsForestNameCritSect );
    }

    UNREFERENCED_PARAMETER( Context );
    return NO_ERROR;
}

NET_API_STATUS
NlSetDomainNameInDomainInfo(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR DnsDomainName OPTIONAL,
    IN LPWSTR NetbiosDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    OUT PBOOLEAN DnsDomainNameChanged OPTIONAL,
    OUT PBOOLEAN NetbiosDomainNameChanged OPTIONAL,
    OUT PBOOLEAN DomainGuidChanged OPTIONAL
    )

/*++

Routine Description:

    Sets the DNS domain name into the DomainInfo structure.

Arguments:

    DomainInfo - Domain to set the DNS domain name for.

    DnsDomainName - DNS name of the domain to host.
        NULL if the domain has no DNS Domain Name.

    NetbiosDomainName - Netbios name of the domain to host.
        NULL if the domain has no Netbios Domain Name.

    DomainGuid - Guid of the domain to host.
        NULL if the domain has no GUID.

    DnsDomainNameChanged - Returns TRUE if the DNS domain name is different
        than the current value.

    NetbiosDomainNameChanged - Returns TRUE if the Netbios domain name is different
        than the current value.

    DomainGuidChanged - Returns TRUE if the domain GUID is different
        than the current value.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    DWORD UnicodeDnsDomainNameSize;

    LPSTR Utf8DnsDomainName = NULL;

    DWORD Utf8DnsDomainNameSize;
    LPBYTE Where;
    ULONG i;
    LPBYTE AllocatedBlock = NULL;
    BOOLEAN LocalDnsDomainNameChanged = FALSE;

    //
    // Initialization
    //

    if ( ARGUMENT_PRESENT( DnsDomainNameChanged) ) {
        *DnsDomainNameChanged = FALSE;
    }

    if ( ARGUMENT_PRESENT( NetbiosDomainNameChanged) ) {
        *NetbiosDomainNameChanged = FALSE;
    }

    if ( ARGUMENT_PRESENT( DomainGuidChanged ) ) {
        *DomainGuidChanged = FALSE;
    }

    //
    // Copy the Netbios domain name into the structure if it has changed.
    //
    //  ?? The below assumes that for real domains Netbios domain name
    //  cannot change to NULL. This needs to be revisited when/if we go
    //  Netbios-less.
    //

    EnterCriticalSection(&NlGlobalDomainCritSect);
    LOCK_TRUST_LIST( DomainInfo );
    if ( NetbiosDomainName != NULL &&
         NlNameCompare( NetbiosDomainName,
                        DomainInfo->DomUnicodeDomainName,
                        NAMETYPE_DOMAIN ) != 0 ) {

        NlPrintDom(( NL_DOMAIN, DomainInfo,
                    "Setting Netbios domain name to %ws\n", NetbiosDomainName ));

        NetStatus = I_NetNameCanonicalize(
                          NULL,
                          NetbiosDomainName,
                          DomainInfo->DomUnicodeDomainName,
                          sizeof(DomainInfo->DomUnicodeDomainName),
                          NAMETYPE_DOMAIN,
                          0 );


        if ( NetStatus != NERR_Success ) {
            NlPrint(( NL_CRITICAL, "%ws: DomainName is invalid\n", NetbiosDomainName ));
            goto Cleanup;
        }

        RtlInitUnicodeString( &DomainInfo->DomUnicodeDomainNameString,
                              DomainInfo->DomUnicodeDomainName );

        Status = RtlUpcaseUnicodeToOemN( DomainInfo->DomOemDomainName,
                                         sizeof(DomainInfo->DomOemDomainName),
                                         &DomainInfo->DomOemDomainNameLength,
                                         DomainInfo->DomUnicodeDomainNameString.Buffer,
                                         DomainInfo->DomUnicodeDomainNameString.Length);

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL, "%ws: Unable to convert Domain name to OEM 0x%lx\n", DomainName, Status ));
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        DomainInfo->DomOemDomainName[DomainInfo->DomOemDomainNameLength] = '\0';

        //
        // Set the account domain.
        //

        if ( NlGlobalMemberWorkstation ) {
            DomainInfo->DomUnicodeAccountDomainNameString =
                DomainInfo->DomUnicodeComputerNameString;
        } else {
            DomainInfo->DomUnicodeAccountDomainNameString =
                DomainInfo->DomUnicodeDomainNameString;
        }

        //
        // Tell the caller that the name has changed.
        //
        if ( ARGUMENT_PRESENT( NetbiosDomainNameChanged) ) {
            *NetbiosDomainNameChanged = TRUE;
        }
    }



    //
    // If the new name is the same as the old name,
    //  avoid setting the name.
    //

    if ( !NlEqualDnsName( DnsDomainName, DomainInfo->DomUnicodeDnsDomainName )) {

        NlPrintDom(( NL_DOMAIN, DomainInfo,
                     "Setting DNS domain name to %ws\n", DnsDomainName ));


        //
        // Convert the DNS domain name to the various forms.
        //

        if ( DnsDomainName != NULL ) {
            ULONG NameLen = wcslen(DnsDomainName);
            if ( NameLen > NL_MAX_DNS_LENGTH ) {
                NetStatus = ERROR_INVALID_DOMAINNAME;
                goto Cleanup;
            }
            UnicodeDnsDomainNameSize = NameLen * sizeof(WCHAR) + sizeof(WCHAR);

            Utf8DnsDomainName = NetpAllocUtf8StrFromWStr( DnsDomainName );
            if ( Utf8DnsDomainName == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            Utf8DnsDomainNameSize = strlen(Utf8DnsDomainName) + 1;
            if ( (Utf8DnsDomainNameSize-1) > NL_MAX_DNS_LENGTH ) {
                NetStatus = ERROR_INVALID_DOMAINNAME;
                goto Cleanup;
            }

        } else {
            UnicodeDnsDomainNameSize = 0;
            Utf8DnsDomainNameSize = 0;
        }

        //
        // Allocate a new block for the names.
        //

        if ( UnicodeDnsDomainNameSize != 0 ) {
            AllocatedBlock = LocalAlloc(
                                    0,
                                    UnicodeDnsDomainNameSize +
                                        Utf8DnsDomainNameSize );

            if ( AllocatedBlock == NULL ) {
                NetStatus = GetLastError();
                goto Cleanup;
            }

            Where = AllocatedBlock;
        }

        //
        // Free the previous allocated block.
        //
        NlFreeDnsDomainDomainInfo( DomainInfo );


        //
        // Copy the Unicode DNS Domain name after that.
        //  (WCHAR aligned)
        //

        if ( UnicodeDnsDomainNameSize != 0 ) {
            RtlCopyMemory( Where, DnsDomainName, UnicodeDnsDomainNameSize );
            DomainInfo->DomUnicodeDnsDomainName = (LPWSTR) Where;
            DomainInfo->DomUnicodeDnsDomainNameString.Buffer = (LPWSTR) Where;
            DomainInfo->DomUnicodeDnsDomainNameString.MaximumLength = (USHORT) UnicodeDnsDomainNameSize;
            DomainInfo->DomUnicodeDnsDomainNameString.Length = (USHORT)UnicodeDnsDomainNameSize - sizeof(WCHAR);

            Where += UnicodeDnsDomainNameSize;

            //
            // Copy the Utf8 DNS Domain name after that.
            //  (byte aligned)
            //

            if ( Utf8DnsDomainNameSize != 0 ) {
                RtlCopyMemory( Where, Utf8DnsDomainName, Utf8DnsDomainNameSize );
                DomainInfo->DomUtf8DnsDomainName = Where;
                Where += Utf8DnsDomainNameSize;
            }

        }

        //
        // Tell the caller that the name has changed.
        //

        LocalDnsDomainNameChanged = TRUE;
        if ( ARGUMENT_PRESENT( DnsDomainNameChanged) ) {
            *DnsDomainNameChanged = TRUE;
        }
    }

    //
    // Copy the domain GUID if it has changed.
    //

    if ( DomainGuid != NULL || DomainInfo->DomDomainGuid != NULL) {

        if ( (DomainGuid == NULL && DomainInfo->DomDomainGuid != NULL) ||
             (DomainGuid != NULL && DomainInfo->DomDomainGuid == NULL) ||
             !IsEqualGUID( DomainGuid, DomainInfo->DomDomainGuid ) ) {


            //
            // Set the domain GUID.
            //

            NlPrintDom(( NL_DOMAIN, DomainInfo,
                         "Setting Domain GUID to " ));
            NlpDumpGuid( NL_DOMAIN, DomainGuid );
            NlPrint(( NL_DOMAIN, "\n" ));

            if ( DomainGuid != NULL ) {
                DomainInfo->DomDomainGuidBuffer = *DomainGuid;
                DomainInfo->DomDomainGuid = &DomainInfo->DomDomainGuidBuffer;
            } else {
                RtlZeroMemory( &DomainInfo->DomDomainGuidBuffer, sizeof( DomainInfo->DomDomainGuidBuffer ) );
                DomainInfo->DomDomainGuid = NULL;
            }

            //
            // Tell the caller that the GUID has changed.
            //
            if ( ARGUMENT_PRESENT( DomainGuidChanged ) ) {
                *DomainGuidChanged = TRUE;
            }
        }
    }


    NetStatus = NO_ERROR;

    //
    // Free any locally used resources.
    //
Cleanup:
    UNLOCK_TRUST_LIST( DomainInfo );
    LeaveCriticalSection(&NlGlobalDomainCritSect);

    if ( Utf8DnsDomainName != NULL ) {
        NetpMemoryFree( Utf8DnsDomainName );
    }

    //
    // If the DNS domain name changed,
    //  determine if the domain is now at the root of the forest.
    //

    if ( LocalDnsDomainNameChanged ) {
        (VOID) NlSetDomainForestRoot( DomainInfo, NULL );
    }

    return NetStatus;

}

PDOMAIN_INFO
NlFindNetbiosDomain(
    LPCWSTR DomainName,
    BOOLEAN DefaultToPrimary
    )
/*++

Routine Description:

    This routine will look up a domain given a Netbios domain name.

Arguments:

    DomainName - The name of the domain to look up.

    DefaultToPrimary - Return the primary domain if DomainName is NULL or
        can't be found.

Return Value:

    NULL - No such domain exists

    A pointer to the domain found.  The found domain should be dereferenced
    using NlDereferenceDomain.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY DomainEntry;

    PDOMAIN_INFO DomainInfo = NULL;


    EnterCriticalSection(&NlGlobalDomainCritSect);


    //
    // If domain was specified,
    //  try to return primary domain.
    //

    if ( DomainName != NULL ) {
        UNICODE_STRING DomainNameString;

        RtlInitUnicodeString( &DomainNameString, DomainName );


        //
        // Loop trying to find this domain name.
        //

        for (DomainEntry = NlGlobalServicedDomains.Flink ;
             DomainEntry != &NlGlobalServicedDomains;
             DomainEntry = DomainEntry->Flink ) {

            DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, DomNext);

            //
            // If this domain is not to be deleted,
            //  check it for match
            //
            if ( (DomainInfo->DomFlags & DOM_DELETED) == 0 &&
                 RtlEqualDomainName( &DomainInfo->DomUnicodeDomainNameString,
                                     &DomainNameString ) ) {
                break;
            }

            DomainInfo = NULL;

        }
    }

    //
    // If we're to default to the primary domain,
    //  do so.
    //

    if ( DefaultToPrimary && DomainInfo == NULL ) {
        if ( !IsListEmpty( &NlGlobalServicedDomains ) ) {
            DomainInfo = CONTAINING_RECORD(NlGlobalServicedDomains.Flink, DOMAIN_INFO, DomNext);
        }
    }

    //
    // Reference the domain.
    //

    if ( DomainInfo != NULL ) {
        DomainInfo->ReferenceCount ++;
    }

    LeaveCriticalSection(&NlGlobalDomainCritSect);

    return DomainInfo;
}

PDOMAIN_INFO
NlFindDnsDomain(
    IN LPCSTR DnsDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN BOOLEAN DefaultToNdnc,
    IN BOOLEAN CheckAliasName,
    OUT PBOOLEAN AliasNameMatched OPTIONAL
    )
/*++

Routine Description:

    This routine will look up a domain given a DNS domain name.

Arguments:

    DnsDomainName - The name of the DNS domain to look up.

    DomainGuid - If specified (and non-zero), the GUID of the domain to
        match.

    DefaultToNdnc - Return the non-domain NC if domain can't be found.

    CheckAliasName - If TRUE, the DNS domain name aliases of hosted
        domains will be checked for match.

    AliasNameMatched - Set to TRUE if the returned domain was found as
        the result of name alias match; otherwise set to FALSE.

Note:

    The match is first perfomed against real hosted domains in the
    following order: first for the domain name, then for the domain
    alias (if CheckAliasName is TRUE), and lastly for the domain GUID.
    This order is important to set correctly AliasNameMatched.
    Specifically, this is needed to return the right domain name (either
    active or alias) to the old DC locator client that verifies response
    based only on the domain name and not the GUID.

    If none of the real hosted domains satisfy the searh, NDNCs are searched
    if DefaultToNdnc is TRUE.  NDNCs don't have name aliases.

Return Value:

    NULL - No such domain exists

    A pointer to the domain found.  The found domain should be dereferenced
    using NlDereferenceDomain.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY DomainEntry;

    PDOMAIN_INFO DomainInfo = NULL;

    //
    // Initialization
    //

    if ( AliasNameMatched != NULL ) {
        *AliasNameMatched = FALSE;
    }

    //
    // If the specified GUID is zero,
    //  Treat it as though none were specified.
    //

    if ( DomainGuid != NULL &&
         IsEqualGUID( DomainGuid, &NlGlobalZeroGuid) ) {
        DomainGuid = NULL;
    }

    EnterCriticalSection(&NlGlobalDomainCritSect);

    //
    // If parameters were specified,
    //  use them.
    //

    if ( DnsDomainName != NULL || DomainGuid != NULL ) {

        //
        // Loop trying to find this domain name.
        //

        for (DomainEntry = NlGlobalServicedDomains.Flink ;
             DomainEntry != &NlGlobalServicedDomains;
             DomainEntry = DomainEntry->Flink ) {

            DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, DomNext);

            //
            // If this entry is not to be deleted,
            //  check it for match
            //
            if ( (DomainInfo->DomFlags & DOM_DELETED) == 0 ) {

                //
                // Check for the active domain name match
                //
                if ( DomainInfo->DomUtf8DnsDomainName != NULL  &&
                     NlEqualDnsNameUtf8( DomainInfo->DomUtf8DnsDomainName, DnsDomainName ) ) {
                    break;
                }

                //
                // If we are instructed to check the alias name, do it
                //
                if ( CheckAliasName &&
                     DomainInfo->DomUtf8DnsDomainNameAlias != NULL &&
                     NlEqualDnsNameUtf8( DomainInfo->DomUtf8DnsDomainNameAlias, DnsDomainName ) ) {

                    if ( AliasNameMatched != NULL ) {
                        *AliasNameMatched = TRUE;
                    }
                    break;
                }

                //
                // Finally, check for the GUID match
                //
                if ( DomainGuid != NULL && DomainInfo->DomDomainGuid != NULL ) {
                    if ( IsEqualGUID( DomainInfo->DomDomainGuid, DomainGuid ) ) {
                        break;
                    }
                }
            }

            DomainInfo = NULL;
        }
    }

    //
    // If we're to default to non-domain NC,
    //  do so.
    //

    if ( DefaultToNdnc && DomainInfo == NULL ) {
        for (DomainEntry = NlGlobalServicedNdncs.Flink ;
             DomainEntry != &NlGlobalServicedNdncs;
             DomainEntry = DomainEntry->Flink ) {

            DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, DomNext);

            //
            // If this entry is not to be deleted,
            //  check it for match
            //
            if ( (DomainInfo->DomFlags & DOM_DELETED) == 0 &&
                 DomainInfo->DomUtf8DnsDomainName != NULL  &&
                 NlEqualDnsNameUtf8( DomainInfo->DomUtf8DnsDomainName, DnsDomainName ) ) {
                break;
            }

            DomainInfo = NULL;
        }
    }

    //
    // Reference the domain.
    //

    if ( DomainInfo != NULL ) {
        DomainInfo->ReferenceCount ++;
    }

    LeaveCriticalSection(&NlGlobalDomainCritSect);

    return DomainInfo;
}

PDOMAIN_INFO
NlFindDomain(
    LPCWSTR DomainName OPTIONAL,
    GUID *DomainGuid OPTIONAL,
    BOOLEAN DefaultToPrimary
    )
/*++

Routine Description:

    This routine will look up a domain given a either a netbios or DNS domain name.

Arguments:

    DomainName - The name of the domain to look up.
        NULL implies the primary domain (ignoring DefaultToPrimary)

    DomainGuid - If specified (and non-zero), the GUID of the domain to
        match.

    DefaultToPrimary - Return the primary domain if DomainName
        can't be found.

Return Value:

    NULL - No such domain exists

    A pointer to the domain found.  The found domain should be dereferenced
    using NlDereferenceDomain.

--*/
{
    PDOMAIN_INFO DomainInfo;

    //
    // If no specific domain is needed,
    //  use the default.
    //

    if ( DomainName == NULL ) {

        DomainInfo = NlFindNetbiosDomain( NULL, TRUE );

    //
    // See if the requested domain is supported.
    //
    } else {

        //
        // Lookup the domain name as Netbios domain name.
        //

        DomainInfo = NlFindNetbiosDomain(
                        DomainName,
                        FALSE );

        if ( DomainInfo == NULL ) {
            LPSTR LocalDnsDomainName;

            //
            // Lookup the domain name as though it is a DNS domain name.
            //

            LocalDnsDomainName = NetpAllocUtf8StrFromWStr( DomainName );

            if ( LocalDnsDomainName != NULL ) {

                DomainInfo = NlFindDnsDomain(
                                LocalDnsDomainName,
                                DomainGuid,
                                FALSE,  // don't lookup NDNCs
                                FALSE,  // don't check alias names
                                NULL ); // don't care if alias name matched

                NetpMemoryFree( LocalDnsDomainName );

            }

        }

        if ( DomainInfo == NULL && DefaultToPrimary ) {
            DomainInfo = NlFindNetbiosDomain( NULL, TRUE );
        }

    }

    return DomainInfo;
}


NET_API_STATUS
NlEnumerateDomains(
    IN BOOLEAN EnumerateNdncsToo,
    PDOMAIN_ENUM_CALLBACK Callback,
    PVOID Context
    )
/*++

Routine Description:

    This routine enumerates all the hosted domains and calls back the specified
    callback routine with the specified context.

Arguments:

    EnumerateNdncsToo - If TRUE, NDNCs will be enumerated in addition to domains
    Callback - The callback routine to call.
    Context - Context for the routine.

Return Value:

    Status of operation (mostly status of allocations).

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    PLIST_ENTRY DomainEntry;
    PDOMAIN_INFO DomainInfo;
    PDOMAIN_INFO DomainToDereference = NULL;
    PLIST_ENTRY ServicedList;
    ULONG DomainOrNdnc;

    EnterCriticalSection(&NlGlobalDomainCritSect);

    for ( DomainOrNdnc = 0; DomainOrNdnc < 2; DomainOrNdnc++ ) {

        //
        // On the first loop, enumerate real domains
        //
        if ( DomainOrNdnc == 0 ) {
            ServicedList = &NlGlobalServicedDomains;

        //
        // On the second loop, enumerate NDNCs if so requested
        //
        } else {
            if ( EnumerateNdncsToo ) {
                ServicedList = &NlGlobalServicedNdncs;
            } else {
                break;
            }
        }

        //
        // Enumerate domains/NDNCs
        //

        for (DomainEntry = ServicedList->Flink ;
             DomainEntry != ServicedList;
             DomainEntry = DomainEntry->Flink ) {

            //
            // Reference the next domain in the list
            //

            DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, DomNext);

            //
            // Skip this domain if it is to be deleted
            //

            if ( DomainInfo->DomFlags & DOM_DELETED ) {
                continue;
            }

            DomainInfo->ReferenceCount ++;
            LeaveCriticalSection(&NlGlobalDomainCritSect);

            //
            // Dereference any domain previously referenced.
            //
            if ( DomainToDereference != NULL) {
                NlDereferenceDomain( DomainToDereference );
                DomainToDereference = NULL;
            }


            //
            //  Call into the callback routine with this network.
            //

            NetStatus = (Callback)(DomainInfo, Context);

            EnterCriticalSection(&NlGlobalDomainCritSect);

            DomainToDereference = DomainInfo;

            if (NetStatus != NERR_Success) {
                break;
            }

        }
    }

    LeaveCriticalSection(&NlGlobalDomainCritSect);

     //
     // Dereference the last domain
     //
     if ( DomainToDereference != NULL) {
         NlDereferenceDomain( DomainToDereference );
     }

    return NetStatus;

}

PDOMAIN_INFO
NlFindDomainByServerName(
    LPWSTR ServerName
    )
/*++

Routine Description:

    This routine will look up a domain given the assigned server name.

Arguments:

    ServerName - The name of the server for the domain to look up.

Return Value:

    NULL - No such domain exists

    A pointer to the domain found.  The found domain should be dereferenced
    using NlDereferenceDomain.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY DomainEntry;

    PDOMAIN_INFO DomainInfo = NULL;

    EnterCriticalSection(&NlGlobalDomainCritSect);


    //
    // If server wasn't specified,
    //  try to return primary domain.
    //

    if ( ServerName == NULL || *ServerName == L'\0' ) {

        //
        // If we're to default to the primary domain,
        //  do so.
        //

        if ( !IsListEmpty( &NlGlobalServicedDomains ) ) {
            DomainInfo = CONTAINING_RECORD(NlGlobalServicedDomains.Flink, DOMAIN_INFO, DomNext);

            //
            // Ensure that this domain is not to be deleted
            //
            if ( DomainInfo->DomFlags & DOM_DELETED ) {
                DomainInfo = NULL;
            }
        }

    //
    // If a server name was specified,
    //  look it up in the list of domains.
    //

    } else {
        UNICODE_STRING ServerNameString;

        //
        // Remove leading \\'s before conversion.
        //

        if ( IS_PATH_SEPARATOR(ServerName[0]) &&
             IS_PATH_SEPARATOR(ServerName[1]) ) {
            ServerName += 2;
        }

        RtlInitUnicodeString( &ServerNameString, ServerName );

        //
        // Loop trying to find this server name.
        //

        for (DomainEntry = NlGlobalServicedDomains.Flink ;
             DomainEntry != &NlGlobalServicedDomains;
             DomainEntry = DomainEntry->Flink ) {

            DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, DomNext);

            //
            // If this domain is not to be deleted,
            //  check it for match
            //
            if ( (DomainInfo->DomFlags & DOM_DELETED) == 0 &&
                 RtlEqualComputerName( &DomainInfo->DomUnicodeComputerNameString,
                                       &ServerNameString ) ) {
                break;
            }

            DomainInfo = NULL;

        }

        //
        // If the server name wasn't found,
        //  perhaps it was a DNS host name.
        //

        if ( DomainInfo == NULL ) {

            //
            // Loop trying to find this server name.
            //

            for (DomainEntry = NlGlobalServicedDomains.Flink ;
                 DomainEntry != &NlGlobalServicedDomains;
                 DomainEntry = DomainEntry->Flink ) {

                DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, DomNext);

                //
                // If this domain is not to be deleted,
                //  check it for match
                //
                if ( (DomainInfo->DomFlags & DOM_DELETED) == 0 &&
                     DomainInfo->DomUnicodeDnsHostNameString.Length != 0 &&
                     NlEqualDnsName( DomainInfo->DomUnicodeDnsHostNameString.Buffer,
                                     ServerName ) ) {
                    break;
                }

                DomainInfo = NULL;

            }
        }

    }

    //
    // Reference the domain.
    //
//Cleanup:
    if ( DomainInfo != NULL ) {
        DomainInfo->ReferenceCount ++;
    } else {
        NlPrint((NL_CRITICAL,"NlFindDomainByServerName failed %ws\n", ServerName ));
    }

    LeaveCriticalSection(&NlGlobalDomainCritSect);

    return DomainInfo;
}


VOID
NlDereferenceDomain(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Decrement the reference count on a domain.

    If the reference count goes to 0, remove the domain.

    On entry, the global NlGlobalDomainCritSect may not be locked

Arguments:

    DomainInfo - The domain to dereference

Return Value:

    None

--*/
{
    NTSTATUS Status;
    ULONG ReferenceCount;
    ULONG Index;
    PLIST_ENTRY ListEntry;

    //
    // Decrement the reference count
    //

    EnterCriticalSection(&NlGlobalDomainCritSect);
    ReferenceCount = -- DomainInfo->ReferenceCount;

    //
    // If this is not the last reference,
    //  just return
    //

    if ( ReferenceCount != 0 ) {
        LeaveCriticalSection(&NlGlobalDomainCritSect);
        return;
    }

    //
    // Otherwise proceed with delinking
    //  and delete the domain structure
    //

    NlAssert( DomainInfo->DomFlags & DOM_DELETED );

    //
    // Remove the entry from the list of serviced domains
    //

    RemoveEntryList(&DomainInfo->DomNext);
    LeaveCriticalSection(&NlGlobalDomainCritSect);

    NlPrintDom(( NL_DOMAIN,  DomainInfo,
              "Domain RefCount is zero. Domain being rundown.\n"));

#ifdef _DC_NETLOGON
    //
    // Stop the domain thread.
    //

    NlStopDomainThread( DomainInfo );


    //
    // Delete any client session
    //

    LOCK_TRUST_LIST( DomainInfo );
    if ( DomainInfo->DomParentClientSession != NULL ) {
        NlUnrefClientSession( DomainInfo->DomParentClientSession );
        DomainInfo->DomParentClientSession = NULL;
    }
    UNLOCK_TRUST_LIST( DomainInfo );

    NlDeleteDomClientSession( DomainInfo );

    //
    // Tell the browser and the SMB server that this domain is gone.
    //

    if ( !NlGlobalMemberWorkstation &&
         (DomainInfo->DomFlags & DOM_REAL_DOMAIN) != 0 ) {
        NlBrowserUpdate( DomainInfo, RoleInvalid );
    }



    //
    // Close the SAM and LSA handles
    //
    if ( DomainInfo->DomSamServerHandle != NULL ) {
        Status = SamrCloseHandle( &DomainInfo->DomSamServerHandle);
        NlAssert( NT_SUCCESS(Status) || Status == STATUS_INVALID_SERVER_STATE );
    }
    if ( DomainInfo->DomSamAccountDomainHandle != NULL ) {
        Status = SamrCloseHandle( &DomainInfo->DomSamAccountDomainHandle);
        NlAssert( NT_SUCCESS(Status) || Status == STATUS_INVALID_SERVER_STATE );
    }
    if ( DomainInfo->DomSamBuiltinDomainHandle != NULL ) {
        Status = SamrCloseHandle( &DomainInfo->DomSamBuiltinDomainHandle);
        NlAssert( NT_SUCCESS(Status) || Status == STATUS_INVALID_SERVER_STATE );
    }
    if ( DomainInfo->DomLsaPolicyHandle != NULL ) {
        Status = LsarClose( &DomainInfo->DomLsaPolicyHandle );
        NlAssert( NT_SUCCESS(Status) );
    }

    //
    // Free the server session table.
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );

    while ( (ListEntry = DomainInfo->DomServerSessionTable.Flink) !=
            &DomainInfo->DomServerSessionTable ) {

        PSERVER_SESSION ServerSession;

        ServerSession =
            CONTAINING_RECORD(ListEntry, SERVER_SESSION, SsSeqList);

        // Indicate we no longer need the server session anymore.
        if ( ServerSession->SsFlags & SS_BDC ) {
            ServerSession->SsFlags |= SS_BDC_FORCE_DELETE;
        }

        NlFreeServerSession( ServerSession );
    }


    if ( DomainInfo->DomServerSessionHashTable != NULL ) {
        NetpMemoryFree( DomainInfo->DomServerSessionHashTable );
        DomainInfo->DomServerSessionHashTable = NULL;
    }
    if ( DomainInfo->DomServerSessionTdoNameHashTable != NULL ) {
        NetpMemoryFree( DomainInfo->DomServerSessionTdoNameHashTable );
        DomainInfo->DomServerSessionTdoNameHashTable = NULL;
    }
    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
    DeleteCriticalSection( &DomainInfo->DomServerSessionTableCritSect );


    //
    // Timeout any async discoveries.
    //
    //  The MainLoop thread may no longer be running to complete them.
    //  ?? Walk pool of async discovery thread here.  Perhaps ref count didn't
    //      reach 0 and we didn't even get this far.




    //
    // Free the Trust List
    //

    LOCK_TRUST_LIST( DomainInfo );

    while ( (ListEntry = DomainInfo->DomTrustList.Flink) != &DomainInfo->DomTrustList ) {
        PCLIENT_SESSION ClientSession;

        ClientSession =
            CONTAINING_RECORD(ListEntry, CLIENT_SESSION, CsNext );

        //
        // Free the session.
        //
        NlFreeClientSession( ClientSession );
    }

    //
    // Free the list of failed user logons
    //

    while ( !IsListEmpty(&DomainInfo->DomFailedUserLogonList) ) {
        PNL_FAILED_USER_LOGON FailedUserLogon;

        ListEntry = RemoveHeadList( &DomainInfo->DomFailedUserLogonList );
        FailedUserLogon = CONTAINING_RECORD(ListEntry, NL_FAILED_USER_LOGON, FuNext );

        //
        // Free the logon structure
        //
        LocalFree( FailedUserLogon );
    }

#endif // _DC_NETLOGON

    //
    // Free the Forest Trust List
    //

    if ( DomainInfo->DomForestTrustList != NULL ) {
        MIDL_user_free( DomainInfo->DomForestTrustList );
        DomainInfo->DomForestTrustList = NULL;
    }

    UNLOCK_TRUST_LIST( DomainInfo );

    //
    // Mark all DNS names we still have registered for
    //  deregistration. However, avoid this on shutdown,
    //  let the DNS shutdown routine do the cleanup as
    //  appropriate.
    //

    if ( !NlGlobalTerminate ) {
        (VOID) NlDnsAddDomainRecords( DomainInfo, 0 );
    }

    //
    // Dereference all covered sites
    // Free the covered sites lists
    //
    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( DomainInfo->CoveredSites != NULL ) {
        for ( Index = 0; Index < DomainInfo->CoveredSitesCount; Index++ ) {
            NlDerefSiteEntry( (DomainInfo->CoveredSites)[Index].CoveredSite );
        }
        LocalFree( DomainInfo->CoveredSites );
        DomainInfo->CoveredSites = NULL;
        DomainInfo->CoveredSitesCount = 0;
    }
    if ( DomainInfo->GcCoveredSites != NULL ) {
        for ( Index = 0; Index < DomainInfo->GcCoveredSitesCount; Index++ ) {
            NlDerefSiteEntry( (DomainInfo->GcCoveredSites)[Index].CoveredSite );
        }
        LocalFree( DomainInfo->GcCoveredSites );
        DomainInfo->GcCoveredSites = NULL;
        DomainInfo->GcCoveredSitesCount = 0;
    }
    LeaveCriticalSection( &NlGlobalSiteCritSect );

    //
    // Free the computer name.
    //

    NlFreeComputerName( DomainInfo );

    //
    // Free the DnsDomain name.
    //
    NlFreeDnsDomainDomainInfo( DomainInfo );


    //
    // Free the Domain Info structure.
    //
    DeleteCriticalSection( &DomainInfo->DomTrustListCritSect );

    if ( IsPrimaryDomain(DomainInfo ) ) {
        NlGlobalDomainInfo = NULL;
    }
    (VOID) LocalFree( DomainInfo );

    NlGlobalServicedDomainCount --;

}

VOID
NlDeleteDomain(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Force a domain to be deleted.

Arguments:

    DomainInfo - The domain to delete

Return Value:

    None

--*/
{
    NlPrintDom(( NL_DOMAIN,  DomainInfo, "NlDeleteDomain called\n"));

    //
    // Indicate that the domain is to be deleted.
    //
    //  Don't remove it from the list of serviced
    //  domains because we may walk the list in
    //  NlEnumerateDomains which temporarily
    //  releases the crit sect.
    //

    EnterCriticalSection(&NlGlobalDomainCritSect);
    NlAssert( (DomainInfo->DomFlags & DOM_DELETED) == 0 );
    DomainInfo->DomFlags |= DOM_DELETED;
    LeaveCriticalSection(&NlGlobalDomainCritSect);
}

VOID
NlUninitializeDomains(
    VOID
    )
/*++

Routine Description:

    Delete all of the domains.

Arguments:

    None.

Return Value:

    None

--*/
{
    ULONG LoopIndex;
    PLIST_ENTRY ServicedList;

    if ( NlGlobalDomainsInitialized ) {
        NlGlobalDomainsInitialized = FALSE;
        //
        // Loop through the domains deleting each of them
        //

        EnterCriticalSection(&NlGlobalDomainCritSect);

        for ( LoopIndex = 0; LoopIndex < 2; LoopIndex++ ) {
            if ( LoopIndex == 0 ) {
                ServicedList = &NlGlobalServicedDomains;
            } else {
                ServicedList = &NlGlobalServicedNdncs;
            }

            while (!IsListEmpty(ServicedList)) {

                PDOMAIN_INFO DomainInfo = CONTAINING_RECORD(ServicedList->Flink, DOMAIN_INFO, DomNext);

                //
                // If domain is already marked for deletion,
                //  add our reference so that we can wait
                //  until only our reference remains
                //
                if ( DomainInfo->DomFlags & DOM_DELETED ) {
                    DomainInfo->ReferenceCount ++;

                //
                // Otherwise, mark the domain for deletion
                //
                } else {
                    NlDeleteDomain( DomainInfo );
                }
                LeaveCriticalSection(&NlGlobalDomainCritSect);

                //
                // Wait for any other references to disappear
                //

                if ( DomainInfo->ReferenceCount != 1 ) {
                    EnterCriticalSection(&NlGlobalDomainCritSect);
                    while ( DomainInfo->ReferenceCount != 1 ) {
                        LeaveCriticalSection(&NlGlobalDomainCritSect);
                        NlPrintDom(( NL_CRITICAL, DomainInfo,
                                  "NlUnitializeDomains: Sleeping a second waiting for Domain RefCount to zero.\n"));
                        Sleep( 1000 );
                        EnterCriticalSection(&NlGlobalDomainCritSect);
                    }
                    LeaveCriticalSection(&NlGlobalDomainCritSect);
                }

                //
                // Actually delink and delete structure by removing the last reference
                //

                NlAssert( DomainInfo->ReferenceCount == 1 );
                NlDereferenceDomain( DomainInfo );


                EnterCriticalSection(&NlGlobalDomainCritSect);

            }

        }

        LeaveCriticalSection(&NlGlobalDomainCritSect);
        DeleteCriticalSection( &NlGlobalDomainCritSect );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\ds.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ds.c

Abstract:

    Interface from netlogon to the DS.

Author:

    Cliff Van Dyke (CliffV) 24-Apr-1996

Revision History:

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//

NET_API_STATUS
NlGetRoleInformation(
    PDOMAIN_INFO DomainInfo,
    PBOOLEAN IsPdc,
    PBOOLEAN Nt4MixedDomain
    )
/*++

Routine Description:

    This routine gets the information from the DS we need to determine our
    role.

Arguments:

    DomainInfo - Domain the role is being determined for

    IsPdc - TRUE if this machine is the PDC

    Nt4MixedDomain - TRUE if there are NT 4 DCs in this domain.

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    PSAMPR_DOMAIN_INFO_BUFFER DomainServerRole = NULL;


    //
    // Ask Sam if this is a mixed domain.
    //

    *Nt4MixedDomain = SamIMixedDomain( DomainInfo->DomSamServerHandle );


    //
    // The SAM account domain has the authoritative copy of the machine's role
    //

    Status = SamrQueryInformationDomain( DomainInfo->DomSamAccountDomainHandle,
                                         DomainServerRoleInformation,
                                         &DomainServerRole );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                "NlGetRoleInformation: Cannot SamQueryInformationDomain (Role): %lx\n",
                Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        DomainServerRole = NULL;
        goto Cleanup;
    }

    if ( DomainServerRole->Role.DomainServerRole == DomainServerRolePrimary ) {
        *IsPdc = TRUE;
    } else {
        *IsPdc = FALSE;
    }

    NetStatus = NERR_Success;

Cleanup:

    //
    // Free locally used resources.
    //

    if ( DomainServerRole != NULL ) {
        SamIFree_SAMPR_DOMAIN_INFO_BUFFER( DomainServerRole,
                                           DomainServerRoleInformation);
    }

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\domain.h ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    domain.h

Abstract:

    Header file for Code to manage multiple domains hosted on a DC.

Author:

    Cliff Van Dyke (CliffV) 20-Feb-1995

Revision History:

--*/


//
// Role that a particular domain is playing
//
typedef enum _NETLOGON_ROLE {
    RoleInvalid = 0,
    RolePrimary,
    RoleBackup,
    RoleMemberWorkstation,
    RoleNdnc
} NETLOGON_ROLE, * PNETLOGON_ROLE;


/////////////////////////////////////////////////////////////////////////////
//
// Description of a single hosted domain. (size of this struct is 0x164)
//
/////////////////////////////////////////////////////////////////////////////

typedef struct _DOMAIN_INFO {

    //
    // Link to next domain in 'NlGlobalServicedDomains'
    //  (Serialized by NlGlobalDomainCritSect)
    //

    LIST_ENTRY DomNext;

    //
    // DomainThread WorkItem
    //  (Serialized by NlGlobalDomainCritSect)
    //

    WORKER_ITEM DomThreadWorkItem;

    //
    // Name of the domain being handled
    //
    // On a Workstation, this is the Domain the workstation is a member of.
    //

    UNICODE_STRING DomUnicodeDomainNameString;
    WCHAR DomUnicodeDomainName[DNLEN+1];

    CHAR DomOemDomainName[DNLEN+1];
    DWORD DomOemDomainNameLength;

    //
    // DNS domain name of the domain being handled.
    //  These fields will be null if there is no DNS domain name for the
    //  domain.
    //
    // Access serialized by either NlGlobalDomainCritSect or DomTrustListCritSect
    // Modifications must lock both.
    //

    UNICODE_STRING DomUnicodeDnsDomainNameString;
    LPWSTR DomUnicodeDnsDomainName;
    LPSTR DomUtf8DnsDomainName;

    //
    // DNS domain name alias of the domain being handled.
    // Access serialized by NlGlobalDomainCritSect
    //
    LPSTR DomUtf8DnsDomainNameAlias;


    //
    // Name of the "Account Domain" of the current machine.
    //  On a DC, this is the same as above.
    //  On a workstation, this is the name of the workstation.

    UNICODE_STRING DomUnicodeAccountDomainNameString;

    //
    // Domain SID of the domain being handled.
    //
    // On a Workstation, this is the DomainId of the workstation SAM itself.
    //
    PSID DomAccountDomainId;

    //
    // Instance GUID of the domain object representing this hosted domain.
    //
    // Access serialized by either NlGlobalDomainCritSect or DomTrustListCritSect
    // Modifications must lock both.

    GUID DomDomainGuidBuffer;
    GUID *DomDomainGuid;    // NULL if there is no GUID

    //
    // Computer name of this computer in this domain.
    //
    WCHAR DomUncUnicodeComputerName[UNCLEN+1];
    UNICODE_STRING DomUnicodeComputerNameString;
    UNICODE_STRING DomUnicodeDnsHostNameString;
    LPSTR DomUtf8DnsHostName;

    CHAR  DomOemComputerName[CNLEN+1];
    DWORD DomOemComputerNameLength;

    LPSTR DomUtf8ComputerName;
    DWORD DomUtf8ComputerNameLength;  // length in bytes

#ifdef _DC_NETLOGON

    //
    // The RID of the computer account for DC.
    //  Will be set to zero for workstations.
    //

    ULONG DomDcComputerAccountRid;

    //
    // Handle to SAM database
    //

    SAMPR_HANDLE DomSamServerHandle;
    SAMPR_HANDLE DomSamAccountDomainHandle;
    SAMPR_HANDLE DomSamBuiltinDomainHandle;

    //
    // Handle to LSA database
    //

    LSAPR_HANDLE DomLsaPolicyHandle;
#endif // _DC_NETLOGON


    //
    // To serialize access to DomTrustList and DomClientSession
    //

    CRITICAL_SECTION DomTrustListCritSect;

#ifdef _DC_NETLOGON
    //
    // The list of domains trusted by this domain.
    //

    LIST_ENTRY DomTrustList;
    DWORD DomTrustListLength;  // Number of entries in DomTrustList

    //
    // The list of all trusted domains in the forest.
    //  (Serialized by DomTrustListCritSect)
    //

    PDS_DOMAIN_TRUSTSW DomForestTrustList;
    DWORD DomForestTrustListSize;
    ULONG DomForestTrustListCount;

    //
    // On BDC, our secure channel to PDC of the domain.
    // On workstations, our secure channel to a DC in the domain.
    //  (Serialized by DomTrustListCritSect)
    //

    struct _CLIENT_SESSION *DomClientSession;

    //
    // On a DC, our secure channel to our 'parent' domain.
    // NULL: if we have no parent.
    //  (Serialized by DomTrustListCritSect)
    //

    struct _CLIENT_SESSION *DomParentClientSession;


    //
    // Table of all Server Sessions
    //  The size of the hash table must be a power-of-2.
    //
#define SERVER_SESSION_HASH_TABLE_SIZE 128
#define SERVER_SESSION_TDO_NAME_HASH_TABLE_SIZE 128

#define LOCK_SERVER_SESSION_TABLE(_DI) \
     EnterCriticalSection( &(_DI)->DomServerSessionTableCritSect )
#define UNLOCK_SERVER_SESSION_TABLE(_DI) \
     LeaveCriticalSection( &(_DI)->DomServerSessionTableCritSect )

    CRITICAL_SECTION DomServerSessionTableCritSect;
    PLIST_ENTRY DomServerSessionHashTable;
    PLIST_ENTRY DomServerSessionTdoNameHashTable;
    LIST_ENTRY DomServerSessionTable;
#endif // _DC_NETLOGON


    //
    // Number of outstanding pointers to the domain structure.
    //  (Serialized by NlGlobalDomainCritSect)
    //

    DWORD ReferenceCount;

    //
    // Role: (PDC, BDC, or workstation) of this machine in the hosted domain
    //
    NETLOGON_ROLE DomRole;

#ifdef _DC_NETLOGON
    //
    // Misc flags.
    //  (Serialized by NlGlobalDomainCritSect)
    //

    DWORD DomFlags;

#define DOM_CREATION_NEEDED      0x00000001  // TRUE if async phase 2 create needed
#define DOM_ROLE_UPDATE_NEEDED   0x00000002  // TRUE if role of the machine needs update
#define DOM_TRUST_UPDATE_NEEDED  0x00000004  // TRUE if trust list needs to be updated

#define DOM_PROMOTED_BEFORE      0x00000010  // TRUE if this machine has been promoted to PDC before.
#define DOM_THREAD_RUNNING       0x00000020  // TRUE if domain worker thread is queued or running
#define DOM_THREAD_TERMINATE     0x00000040  // TRUE if domain worker thread should be terminated
#define DOM_DELETED              0x00000080  // TRUE if domain is being deleted.

#define DOM_ADDED_1B_NAME            0x00000100  // True if Domain<1B> name has been added
#define DOM_ADD_1B_NAME_EVENT_LOGGED 0x00000200  // True if Domain<1B> name add failed at least once
#define DOM_RENAMED_1B_NAME          0x00000400  // True if Domain<1B> name should be renamed
#define DOM_DOMAIN_REFRESH_PENDING   0x00000800  // True if this Domain needs refreshing

#define DOM_PRIMARY_DOMAIN       0x00001000  // True if this is the primary domain of the machine
#define DOM_REAL_DOMAIN          0x00002000  // This is a real domain (as opposed to NDNC or forest)
#define DOM_NON_DOMAIN_NC        0x00004000  // This is NDNC
#define DOM_FOREST               0x00008000  // This is a forest entry (not currently used)

#define DOM_FOREST_ROOT          0x00010000  // This domain is at the root of the forest.
#define DOM_API_TIMEOUT_NEEDED   0x00040000  // TRUE if client session API timeout is needed

#define DOM_PRIMARY_ANNOUNCE_NEEDED    0x00080000 // Primary announcement is needed
#define DOM_PRIMARY_ANNOUNCE_CONTINUE  0x00100000 // Continuation of Primary announcement is needed
#define DOM_PRIMARY_ANNOUNCE_IMMEDIATE 0x00200000 // Immediate Primary announcement is needed
#define DOM_PRIMARY_ANNOUNCE_FLAGS ( \
            DOM_PRIMARY_ANNOUNCE_NEEDED | \
            DOM_PRIMARY_ANNOUNCE_CONTINUE | \
            DOM_PRIMARY_ANNOUNCE_IMMEDIATE )

    //
    // The lists of covered sites. Both lists protected by NlGlobalSiteCritSect.
    //
    // If this is a real domain, CoveredSites is a list of sites we cover as a DC.
    // If this is a non-domain NC, CoveredSites is a list of sites we cover as an NDNC.
    //
    struct _NL_COVERED_SITE *CoveredSites;
    ULONG CoveredSitesCount;

    //
    // If this is a real (primary) domain, GcCoveredSites is a list of sites we cover as a GC
    //  in the forest which the primary domain belongs to. Otherwise, GcCoveredSites is NULL.
    //
    // ??: When we go multihosted, we will have a separate DOMAIN_INFO entry for each of the
    //  hosted forests, so only one list of covered sites will be associated with DOMAIN_INFO
    //  corresponding to the role we play in a given domain/forest/NDNC.
    //
    struct _NL_COVERED_SITE *GcCoveredSites;
    ULONG GcCoveredSitesCount;

    //
    // List of failed user logons with bad password.
    //  Used on BDC to maintain the list of bad password
    //  logons forwarded to the PDC.
    //
    LIST_ENTRY DomFailedUserLogonList;

#endif // _DC_NETLOGON

} DOMAIN_INFO, *PDOMAIN_INFO;


#ifdef _DC_NETLOGON
#define IsPrimaryDomain( _DomainInfo ) \
    (((_DomainInfo)->DomFlags & DOM_PRIMARY_DOMAIN) != 0 )
#else // _DC_NETLOGON
#define IsPrimaryDomain( _DomainInfo ) TRUE
#endif // _DC_NETLOGON

//
//  The DOMAIN_ENUM_CALLBACK is a callback for NlEnumerateDomains.
//
//  It defines a routine that takes two parameters, the first is a DomainInfo
//  structure, the second is a context for that Domain.
//


typedef
NET_API_STATUS
(*PDOMAIN_ENUM_CALLBACK)(
    PDOMAIN_INFO DomainInfo,
    PVOID Context
    );


//
// domain.c procedure forwards.
//

NET_API_STATUS
NlGetDomainName(
    OUT LPWSTR *DomainName,
    OUT LPWSTR *DnsDomainName,
    OUT PSID *AccountDomainSid,
    OUT PSID *PrimaryDomainSid,
    OUT GUID **PrimaryDomainGuid,
    OUT PBOOLEAN DnsForestNameChanged OPTIONAL
    );

NET_API_STATUS
NlInitializeDomains(
    VOID
    );

NET_API_STATUS
NlCreateDomainPhase1(
    IN LPWSTR DomainName OPTIONAL,
    IN LPWSTR DnsDomainName OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPWSTR ComputerName,
    IN LPWSTR DnsHostName OPTIONAL,
    IN BOOLEAN CallNlExitOnFailure,
    IN ULONG DomainFlags,
    OUT PDOMAIN_INFO *ReturnedDomainInfo
    );

#ifdef _DC_NETLOGON
NET_API_STATUS
NlCreateDomainPhase2(
    IN PDOMAIN_INFO DomainInfo,
    IN BOOLEAN CallNlExitOnFailure
    );
#endif // _DC_NETLOGON

PDOMAIN_INFO
NlFindDomain(
    LPCWSTR DomainName OPTIONAL,
    GUID *DomainGuid OPTIONAL,
    BOOLEAN DefaultToPrimary
    );

PDOMAIN_INFO
NlFindNetbiosDomain(
    LPCWSTR DomainName,
    BOOLEAN DefaultToPrimary
    );

PDOMAIN_INFO
NlFindDnsDomain(
    IN LPCSTR DnsDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN BOOLEAN DefaultToNdnc,
    IN BOOLEAN CheckAliasName,
    OUT PBOOLEAN AliasNameMatched OPTIONAL
    );

#ifdef _DC_NETLOGON
NET_API_STATUS
NlStartDomainThread(
    PDOMAIN_INFO DomainInfo,
    PDWORD DomFlags
    );

NET_API_STATUS
NlUpdateRole(
    IN PDOMAIN_INFO DomainInfo
    );

NET_API_STATUS
NlUpdateServicedNdncs(
    IN LPWSTR ComputerName,
    IN LPWSTR DnsHostName,
    IN BOOLEAN CallNlExitOnFailure,
    OUT PBOOLEAN ServicedNdncChanged OPTIONAL
    );

NTSTATUS
NlUpdateDnsRootAlias(
    IN PDOMAIN_INFO DomainInfo,
    OUT PBOOL AliasNamesChanged OPTIONAL
    );
#endif // _DC_NETLOGON

struct _CLIENT_SESSION *
NlRefDomClientSession(
    IN PDOMAIN_INFO DomainInfo
    );

struct _CLIENT_SESSION *
NlRefDomParentClientSession(
    IN PDOMAIN_INFO DomainInfo
    );

VOID
NlDeleteDomClientSession(
    IN PDOMAIN_INFO DomainInfo
    );

PDOMAIN_INFO
NlFindDomainByServerName(
    LPWSTR ServerName
    );

NET_API_STATUS
NlEnumerateDomains(
    IN BOOLEAN EnumerateNdncsToo,
    PDOMAIN_ENUM_CALLBACK Callback,
    PVOID Context
    );

NET_API_STATUS
NlSetDomainForestRoot(
    IN PDOMAIN_INFO DomainInfo,
    IN PVOID Context
    );

GUID *
NlCaptureDomainInfo (
    IN PDOMAIN_INFO DomainInfo,
    OUT WCHAR DnsDomainName[NL_MAX_DNS_LENGTH+1] OPTIONAL,
    OUT GUID *DomainGuid OPTIONAL
    );

NET_API_STATUS
NlSetDomainNameInDomainInfo(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR DnsDomainName OPTIONAL,
    IN LPWSTR NetbiosDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    OUT PBOOLEAN DnsDomainNameChanged OPTIONAL,
    OUT PBOOLEAN NetbiosDomainNameChanged OPTIONAL,
    OUT PBOOLEAN DomainGuidChanged OPTIONAL
    );

VOID
NlDereferenceDomain(
    IN PDOMAIN_INFO DomainInfo
    );

VOID
NlDeleteDomain(
    IN PDOMAIN_INFO DomainInfo
    );

VOID
NlUninitializeDomains(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\dsgetdc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dsgetdc.c

Abstract:

    Routines shared by logonsrv\server and logonsrv\client

Author:

    Cliff Van Dyke (cliffv) 20-July-1996

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include the actual .c file for the NetpDc* routines.
//  This allows us to supply netlogon specific versions of the NlPrint and
//  mailslot send routines.
//

#include "netpdc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\iniparm.h ===
/*++

Copyright (c) 1987-1996 Microsoft Corporation

Module Name:

    iniparm.h

Abstract:

    Initiail values of startup parameters.

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.
    07-May-1992 JohnRo
        Use net config helpers for NetLogon.

--*/


#ifndef _INIPARM_
#define _INIPARM_

//
// Upon RegistryChangeNotify, all registry values take effect immediately execpt
// as noted below.
//

//
// Pulse period (in seconds):
//
// Defines the typical pulse frequency.  All SAM/LSA changes made within this
// time are collected together.  After this time, a pulse is sent to each BDC
// needing the changes.  No pulse is sent to a BDC that is up to date.
//
#define DEFAULT_PULSE           (5*60)     // 5 mins
#define MAX_PULSE           (48*60*60)     // 2 days
#define MIN_PULSE                  60      // 1 min

//
// Pulse concurrency (in number of concurrent mailslot messages).
//
// Netlogon sends pulses to individual BDCs.  The BDCs respond asking for any
// database changes.  To control the maximum load these responses place on the
// PDC, the PDC will only have this many pulses "pending" at once.  The PDC
// should be sufficiently powerful to support this many concurrent replication
// RPC calls.
//
// Increasing this number increases the load on the PDC.
// Decreasing this number increases the time it takes for a domain with a
//    large number of BDC to get a SAM/LSA change.

#define DEFAULT_PULSECONCURRENCY   10
#define MAX_PULSECONCURRENCY      500
#define MIN_PULSECONCURRENCY        1

//
// Maximum pulse period (in seconds):
//
// Defines the maximum pulse frequency.  Every BDC will be sent at least one
// pulse at this frequency regardless of whether its database is up to date.
//

#define DEFAULT_PULSEMAXIMUM (2*60*60)     // 2 hours
#define MAX_PULSEMAXIMUM    (48*60*60)     // 2 days
#define MIN_PULSEMAXIMUM           60      // 1 min

//
// Pulse timeout period (in seconds):
//
// When a BDC is sent a pulse, it must respond within this time period.  If
// not, the BDC is considered to be non-responsive.  A non-responsive BDC is
// not counted against the "Pulse Concurrency" limit allowing the PDC to
// send a pulse to another BDC in the domain.
//
// If this number is too large, a domain with a large number of non-responsive
//  BDCs will take a long time to complete a partial replication.
//
// If this number is too small, a slow BDC may be falsely accused of being
// non-responsive.  When the BDC finally does respond, it will partial
// replicate from the PDC unduly increasing the load on the PDC.
//
#define DEFAULT_PULSETIMEOUT1      10      // 10 seconds
#define MAX_PULSETIMEOUT1      (2*60)      // 2 min
#define MIN_PULSETIMEOUT1           1      // 1 second

//
// Maximum Partial replication timeout (in seconds):
//
// Even though a BDC initially responds to a pulse (as described for
// PULSETIMEOUT1), it must continue making replication progress or the
// BDC will be considered non-responsive.  Each time the BDC calls the PDC,
// the BDC is given another PULSETIMEOUT2 seconds to be considered responsive.
//
// If this number is too large, a slow BDC (or one which has its replication
// rate artificially governed) will consume one of the PULSECONCURRENCY slots.
//
// If this number is too small, the load on the PDC will be unduly increased
// because of the large number of BDC doing a partial sync.
//
// NOTE: This parameter only affect the cases where a BDC cannot retrieve all the
// changes to the SAM/LSA database in a single RPC call.  This will only
// happen if a large number of changes are made to the database.

#define DEFAULT_PULSETIMEOUT2  (5*60)      // 5 minutes
#define MAX_PULSETIMEOUT2   (1*60*60)      // 1 hour
#define MIN_PULSETIMEOUT2      (1*60)      // 1 minute

//
// BDC random backoff (in seconds):
//
// When the BDC receives a pulse, it will back off between zero and RANDOMIZE
// seconds before calling the PDC.  In Lanman and NT 3.1, the pulse was
// broadcast to all BDCs simultaneously and the BDCs used this mechanism to
// ensure they didn't overload the PDC.  As of NT 3.5x, the pulse is sent
// to individual BDCs so this parameter should be minimized.
//
// This parameter should be smaller than PULSETIMEOUT1.
//
// Consider that the time to replicate a SAM/LSA change to all the BDCs in a
// domain will be greater than:
//
//  ((RANDOMIZE/2) * NumberOfBdcsInDomain) / PULSECONCURRENCY
//
#define DEFAULT_RANDOMIZE           1      // 1 secs
#define MAX_RANDOMIZE             120      // 2  mins
#define MIN_RANDOMIZE               0      // 0  secs


//
// ChangeLogSize (in bytes)  [NOTE: This parameter is NOT read from the GP section]
//
// This is the size of the Change Log file.  Each change to the SAM/LSA database
// is represented by an entry in the change log.  The changelog is maintained
// as a circular buffer with the oldest entry being overwritten by the newest
// entry.  If a BDC does a partial sync and requests an entry that has been
// overwritten, the BDC is forced to do a full sync.
//
// The minimum (and typical) size of an entry is 32 bytes.  Some entries are
// larger. (e.g., a 64K changelog holds about 2000 changes)
//
// This parameter need only be set larger if:
//
// a) full syncs are prohibitively expensive, AND
// b) one or more BDCs are expected to not request a partial sync within 2000
//    changes.
//
// For instance, if a BDC dials in nightly to do a partial sync and on some
// days 4000 changes are made to the SAM/LSA database, this parameter should
// be set to 128K.
//
// This parameter need only be set on the PDC.  If a different PDC is promoted,
// it should be set on that PDC also.
//

#define DEFAULT_CHANGELOGSIZE    (64*1024)
#define MAX_CHANGELOGSIZE    (4*1024*1024)
#define MIN_CHANGELOGSIZE        (64*1024)

//
// MaximumMailslotMessages (in number of messages)
//
// This parameter determines the maximum number of mailslot messages that will
// be queued to the netlogon service.  Even though the Netlogon service is
// designed to process incoming mailslot messages immediately, the netlogon
// service can get backed up processing requests.
//
// Each mailslot message consumes about 1500 bytes of non-paged pool until it
// is process.  By setting this parameter low, you can govern the maximum
// amount of non-paged pool that can be consumed.
//
// If you set this parameter too low, netlogon may miss important incoming
// mailslot messages.
//
// Upon RegistryChangeNotify, changes to this value are ignored.

#define DEFAULT_MAXIMUMMAILSLOTMESSAGES 500
#define MAX_MAXIMUMMAILSLOTMESSAGES     0xFFFFFFFF
#define MIN_MAXIMUMMAILSLOTMESSAGES     1

//
// MailslotMessageTimeout (in seconds)
//
// This parameter specifies the maximum acceptable age of an incoming
// mailslot message.  If netlogon receives a mailslot messages that arrived
// longer ago than this, it will ignore the message.  This allows netlogon
// to process messages that are more recent.  The theory is that the client
// that originally sent the older mailslot message is no longer waiting for
// the response so we shouldn't bother sending a response.
//
// If you set this parameter too low, netlogon will ignore important incoming
// mailslot messages.
//
// Ideally, netlogon processes each mailslot message in a fraction of a second.
// This parameter is only significant if the NTAS server is overloaded.
//

#define DEFAULT_MAILSLOTMESSAGETIMEOUT 10
#define MAX_MAILSLOTMESSAGETIMEOUT     0xFFFFFFFF
#define MIN_MAILSLOTMESSAGETIMEOUT     5

//
// MailslotDuplicateTimeout (in seconds)
//
// This parameter specifies the interval over which duplicate incoming
// mailslot messages will be ignored.  Netlogon compares each mailslot
// message received with the previous mailslot message received.  If the
// previous message was received within this many seconds and the messages
// are identical, this message will be ignored.  The theory is that the
// duplicate messages are caused by clients sending on multiple transports and
// that netlogon needs to only reply on one of those transports saving network
// bandwidth.
//
// Set this parameter to zero to disable this feature.  You should disable this
// feature if your network is configured such that this machine can see
// certain incoming mailslot messages but can't respond to them.  For instance,
// a PDC may be separated from an NT workstation by a bridge/router.
// The bridge/router might filter outgoing NBF broadcasts, but allow incoming
// one.  As such, netlogon might respond to an NBF mailslot message (only to
// be filtered out by the bridge/router) and not respond to a subsequent NBT
// mailslot message.  Disabling this feature (or preferably reconfiguring the
// bridge/router) solves this problem.
//
// If you set this parameter too high, netlogon will ignore retry attempts
// from a client.
//

#define DEFAULT_MAILSLOTDUPLICATETIMEOUT 2
#define MAX_MAILSLOTDUPLICATETIMEOUT     5
#define MIN_MAILSLOTDUPLICATETIMEOUT     0

//
// ExpectedDialupDelay (in seconds)
//
// This parameter specifies the time it takes for a dialup router to dial when
// sending a message from this client machine to a domain trusted by this client
// machine.  Typically, netlogon assumes a domain controller is reachable in a
// short (e.g., 15 seconds) time period.  Setting ExpectedDialupDelay informs
// Netlogon to expect an ADDITIONAL delay of the time specified.
//
// Currently, netlogon adjusts the following two times based on the
// ExpectedDialupDelay:
//
// 1) When discovering a DC in a trusted domain, Netlogon sends a 3 mailslot
//    messages to the trusted domain at ( 5 + ExpectedDialupDelay/3 ) second
//    intervals  Synchronous discoveries will not be timed out for 3 times that
//    interval.
// 2) An API call over a secure channel to a discovered DC will timeout only
//    after (45 + ExpectedDialupDelay) seconds.
//
// This parameter should remain zero unless a dialup router exists between this
// machine and its trusted domain.
//
// If this parameter is set too high, legitimate cases where no DC is available in
// a trusted domain will take an extraordinary amount of time to detect.
//


#define DEFAULT_EXPECTEDDIALUPDELAY 0
#define MAX_EXPECTEDDIALUPDELAY     (10*60) // 10 minutes
#define MIN_EXPECTEDDIALUPDELAY     0

//
// ScavengeInterval (in seconds)
//
// This parameter adjusts the interval at which netlogon performs the following
// scavenging operations:
//
// * Checks to see if a password on a secure channel needs to be changed.
//
// * Checks to see if a secure channel has been idle for a long time.
//
// * On DCs, sends a mailslot message to each trusted domain for a DC hasn't been
//   discovered.
//
// * On PDC, attempts to add the <DomainName>[1B] netbios name if it hasn't
//   already been successfully added.
//
// * On PDC, refreshes forest trust info for all forest trusts if enough time
//   has passed since the last refresh. (See FtInfoUpdateInterval)
//
// None of these operations are critical. 15 minutes is optimal in all but extreme
// cases.  For instance, if a DC is separated from a trusted domain by an
// expensive (e.g., ISDN) line, this parameter might be adjusted upward to avoid
// frequent automatic discovery of DCs in a trusted domain.
//

#define DEFAULT_SCAVENGEINTERVAL (15*60)    // 15 minutes
#define MAX_SCAVENGEINTERVAL     (48*60*60) // 2 days
#define MIN_SCAVENGEINTERVAL     60         // 1 minute

//
// LdapSrvPriority
//
// This parameter specifies the "priority" of this DC.  A client trying to
// discover a DC in this domain MUST attempt to contact the target DC with the
// lowest-numbered priority.  DCs with the same priority SHOULD be tried in
// pseudorandom order.
//
// This value is published on all LDAP SRV records written by the Netlogon service.
//

#define DEFAULT_LDAPSRVPRIORITY 0
#define MAX_LDAPSRVPRIORITY     65535
#define MIN_LDAPSRVPRIORITY     0

//
// LdapSrvWeight
//
// This parameter specifies the "Weight" of this DC.  When selecting a DC among
// those that have the same priority, the chance of trying this one first SHOULD
// be proportional to its weight.  By convention, a weight of 100 should be used
// if all DCs have the same weight.
//
// This value is published on all LDAP SRV records written by the Netlogon service.
//

#define DEFAULT_LDAPSRVWEIGHT 100
#define MAX_LDAPSRVWEIGHT     65535
#define MIN_LDAPSRVWEIGHT     0



//
// LdapSrvPort
//
// This parameter specifies the TCP and UDP port number the LDAP server listens on.
//
// This value is published on all LDAP SRV records written by the Netlogon service.
//

#define DEFAULT_LDAPSRVPORT 389
#define MAX_LDAPSRVPORT     65535
#define MIN_LDAPSRVPORT     0



//
// LdapGcSrvPort
//
// This parameter specifies the TCP and UDP port number the LDAP server listens
//  on for Global Catalog queries.
//
// This value is published on all LDAP SRV records written by the Netlogon service.
//

#define DEFAULT_LDAPGCSRVPORT 3268
#define MAX_LDAPGCSRVPORT     65535
#define MIN_LDAPGCSRVPORT     0



//
// KdcSrvPort
//
// This parameter specifies the TCP port number the KDC server listens on.
//
// This value is published on all KDC SRV records written by the Netlogon service.
//

#define DEFAULT_KDCSRVPORT 88
#define MAX_KDCSRVPORT     65535
#define MIN_KDCSRVPORT     0

//
// KerbIsDoneWithJoinDomainEntry (dword)  [NOTE: This parameter is NOT read from the GP section]
//
// This is a private registry between joindomain, kerberos and netlogon.
// IF set to 1, it specifies that Kerberos is done reading the join domain
// entry dumped by join domain and netlogon should delete it.
//
// Defaults to 0

#define DEFAULT_KERBISDDONEWITHJOIN 0
#define MAX_KERBISDDONEWITHJOIN     1
#define MIN_KERBISDDONEWITHJOIN     0

//
// DnsTtl (in seconds)
//
// This parameter specifies the "Time To Live" for all DNS records registered
// by Netlogon.  The "Time To Live" specifies the amount of time a client
// can safely cache the DNS record.
//
// A value of zero indicates that the record will not be cached on the client.
//
// One should not pick a value that is too large.  Consider a client that gets
// the DNS records for the DCs in a domain.  If a particular DC is down at the
// time of the query, the client will not become aware of that DC even if all
// the other DCs become unavailable.
//

#define DEFAULT_DNSTTL (10 * 60)   // 10 minutes
#define MAX_DNSTTL     0x7FFFFFFF
#define MIN_DNSTTL     0



//
// DnsRefreshInterval (in seconds)
//
// This parameter specifies how frequently Netlogon will re-register DNS
// names that have already been registered.
//
// DNS is a distributed service.  There are certain failure conditions where a
// dynamically registered name gets lost.
//
// The actual refresh interval starts at 5 minutes then doubles until it
// reaches DnsRefreshInterval.
//

#define DEFAULT_DNSREFRESHINTERVAL (24 * 60 * 60)   // 24 hours
#define MAX_DNSREFRESHINTERVAL     (0xFFFFFFFF / 1000)  // 49 days
#define MIN_DNSREFRESHINTERVAL     (5 * 60)    // 5 minutes


//
// DnsFailedDeregisterTimeout (in seconds)
//
// Netlogon tries to deregister DNS records which were registered in the past
// but are no longer needed. If a failure occurs to deregister, Netlogon will
// retry to deregister at the scavenging time. This parameter specifies the
// timeout when Netlogon should give up deregistering a particular DNS record
// after a consecutive series of failed deregistrations on a given service start.
//

#define DEFAULT_DNSFAILEDDEREGTIMEOUT (48 * 60 * 60)  // 48 hours.
#define MAX_DNSFAILEDDEREGTIMEOUT     0xFFFFFFFF      // Infinite (never give up).
                                                      //  Any period larger than
                                                      //  0xFFFFFFFF/1000 sec = 49 days
                                                      //  will be treated as infinity.
#define MIN_DNSFAILEDDEREGTIMEOUT     0               // Give up after the first failure


//
// MaximumPasswordAge (in days)
//
// This parameter gives the maximum amount of time that can pass
// before a machine account's password must be changed on the PDC.
//

#define DEFAULT_MAXIMUMPASSWORDAGE  (30)     // 30 days
#define MIN_MAXIMUMPASSWORDAGE      (1)     // 1 day
#define MAX_MAXIMUMPASSWORDAGE      (1000000)  // 1,000,000 days

//
// SiteName
//
// This parameter specifies the name of the site this machine is in.  This
// value overrides any dynamically determined value.
//
// This parameter is only used on Member Workstations and Member Servers.
//

//
// DynamicSiteName  [NOTE: This parameter is NOT read from the GP section]
//
// This parameter specifies the name of the site this machine is in.  This
// value is dynamically determined and should not be changed.
//
// This parameter is only used on Member Workstations and Member Servers.
//

//
// SiteCoverage
//
// A multivalued property listing the sites that this DC registers itself for.
// This DC considers itself 'close' to the sites listed.
//
// This list is in addition to:
//  the site this DC is actually in.
//  the list of sites determined as described by the AutoSiteCoverage parameter.
//

//
// GcSiteCoverage
//
// A multivalued property listing the sites that this DC registers itself for in
//  its role as a GC
// This DC considers itself 'close' to the sites listed.
//
// This list is in addition to:
//  the site this DC is actually in.
//

//
// NdncSiteCoverage
//
// A multivalued property listing the sites that this LDAP server registers itself for in
//  its role as a non-domain NC (NDNC)
// This LDAP server considers itself 'close' to the sites listed.
//
// This list is in addition to:
//  the site this LDAP server is actually in.
//
// To specify for which NDNC a given site is covered, the site name should contain
//  backslash so that the name preceding the backslash is the NDNC name and the name
//  following the backslash is the name of the site that is covered for the given NDNC.
//  For example:
//
//      Ndnc1\Site1A
//      Ndnc1\Site1B
//      Ndnc2\Site2A
//      Ndnc2\Site2B
//
//  In this example this LDAP server will cover Site1A and Site1B for clients from NDNC
//  Ndnc1. Similarly, it will cover Site2A and Site2B for clients from NDNC Ndnc2.
//  If the backslash is absent, it will be assumed that the given site is covered
//  for all NDNCs this LDAP server services.
//

//
// AutoSiteCoverage (Boolean)
//
// Specifies whether the site coverage for this DC should be automatically
// determined
//
// If TRUE, the sites this DC covers is determined by the following algorithm.
// For each site that has no DCs for this domain (the target site), the site
// this DC // is in might be chosen to "cover" the site.  The following
// criteria is used:
//
//    * Smaller site link cost.
//    * For sites where the above is equal, the site having the most DCs is chosen.
//    * For sites where the above is equal, the site having the alphabetically least
//      name is chosen.
//
// If the site this DC is in is chosen to "cover" the target site, then this DC
// will cover the target site.  The above algorithm is repeated for each target site.
//
// The computed list augments the list of covered sites specified by the
// SiteCoverage parameter.
//
// Defaults to TRUE.
//

//
// SiteCoverageRefreshInterval (in seconds)
//
// Specifies how often a DC will refresh its site coverage by reading the info from
// the DS. This value is ignored if automatic site coverage is turned off (i.e. when
// AutoSiteCoverage is set to FALSE). If site coverage changes, the DC will update
// its DNS records acordingly.
//
// Upon registry change, the first site coverage refresh will happen within the
// interval specified.
//

#define DEFAULT_SITECOVERAGEREFRESHINTERVAL    (60 * 60)   // 1 hour
#define MAX_SITECOVERAGEREFRESHINTERVAL        (0xFFFFFFFF / 1000)  // 49 days
#define MIN_SITECOVERAGEREFRESHINTERVAL        (5 * 60)    // 5 minutes

//
// AllowReplInNonMixed
//
// This boolean allows an NT 4.0 (or 3.x) BDC to replicate from this NT 5.0 PDC
// even though this DC is in NonMixed mode.
//
// Upon RegistryChangeNotify, changes to this value are ignored.

#define DEFAULT_ALLOWREPLINNONMIXED 0

//
// SignSecureChannel (Boolean)
//
// Specifies that all outgoing secure channel traffic should be signed.
//
// Defaults to TRUE.  If SealSecureChannel is also TRUE, Seal overrides.
//
// Upon RegistryChangeNotify, changes to this value on affect secure channels that
// are setup after the notification is received.

//
// SealSecureChannel (Boolean)
//
// Specifies that all outgoing secure channel traffic should be sealed (encrypted)
//
// Defaults to TRUE.
//
// Upon RegistryChangeNotify, changes to this value on affect secure channels that
// are setup after the notification is received.

//
// RequireSignOrSeal (Boolean)
//
// Requires that all outgoing secure channel traffic should be signed or sealed.
// Without this flag, the ability is negotiated with the DC.
//
// This flag should only be set if ALL of the DCs in ALL trusted domains support
// signing and sealing.
//
// The SignSecureChannel and SealSecureChannel parameters are used to determine
// whether signing or sealing are actually done.  It this parameter is true,
// SignSecureChannel is implied to be TRUE.
//
// Defaults to FALSE.
//
// Upon RegistryChangeNotify, changes to this value on affect secure channels that
// are setup after the notification is received.

//
// RequireStrongKey (Boolean)
//
// Requires that all outgoing secure channel traffic should require a strong key.
// Without this flag, the key strength is negotiate with the DC.
//
// This flag should only be set if ALL of the DCs in ALL trusted domains support
// strong keys.
//
// Defaults to FALSE.
//
// Upon RegistryChangeNotify, changes to this value on affect secure channels that
// are setup after the notification is received.

//
// CloseSiteTimeout (in seconds):
//
// If a client cannot find a DC in a site that is close to it, Netlogon will
// periodically try to find a close DC.  It will try to find a close DC when:
//
// * An interactive logon uses pass through authentication on the secure channel.
// * CloseSiteTimeout has elapsed since the last attempt, and any other attempt
//   is made to use the secure channel (e.g., pass through authentication of
//   network logons)
//
// That means that Netlogon only attempts to find a close DC "on demand".
//
// If this number is too large, a client will never try to find a close DC if
//  one is not available on boot.
//
// If this number is too small, secure channel traffic will be un-necessarily
// be slowed down by discovery attempts.
//

#define DEFAULT_CLOSESITETIMEOUT    (15*60)     // 15 minutes
#define MAX_CLOSESITETIMEOUT        (0xFFFFFFFF/1000)  // 49 days
#define MIN_CLOSESITETIMEOUT        (1*60)      // 1 minute

//
// SiteNameTimeout (in seconds):
//
// If the age of the site name is more than SiteNameTimeout on the client,
// the client will attempt to synchronize the site name with the server.
// This will be done only when the site name needs to be returned, i.e. on
// demand.
//

#define DEFAULT_SITENAMETIMEOUT    (5*60)     // 5 minutes
#define MAX_SITENAMETIMEOUT        (0xFFFFFFFF/1000)  // 49 days
#define MIN_SITENAMETIMEOUT        (0)      // 0 minutes

//
// Sundry flags
//

#define DEFAULT_DISABLE_PASSWORD_CHANGE 0
#define DEFAULT_REFUSE_PASSWORD_CHANGE 0

#define DEFAULT_SYSVOL      L"SYSVOL\\SYSVOL"
#define DEFAULT_SCRIPTS     L"\\SCRIPTS"

//
// DuplicateEventlogTimeout (in seconds):
//
// The Netlogon service keeps track of eventlog messages it has logged in the
// past.  Any duplicate eventlog message logged within DuplicateEventlogMessage
// seconds will not be logged.
//
// Set this value to zero to have all messages be logged.
//

#define DEFAULT_DUPLICATEEVENTLOGTIMEOUT  (4*60*60)         // 4 hours
#define MAX_DUPLICATEEVENTLOGTIMEOUT      (0xFFFFFFFF/1000) // 49 days
#define MIN_DUPLICATEEVENTLOGTIMEOUT      (0)               // 0 seconds

//
// SysVolReady (Boolean)
//
// This is a private registry entry that indicates whether the SYSVOL share is
// ready to be shared.  It is set by DcPromo, Backup, and FRS at appropriate times
// to inidcate the replication state of the SYSVOL share.
//
// This boolean is only used on a DC.
//
// If 0, the SYSVOL share will not be shared and this DC will not indicate it is
//  a DC to DsGetDcName calls.
//
// If non-zero, the SYSVOL share will be shared.
//

//
// UseDynamicDns (Boolean)
//
// Specifies that a DC is to dynamically register DNS names in DNS using
// dynamic DNS.  If FALSE, Dynamic DNS is avoided and the records specified
// in %windir%\system32\config\netlogon.dns should be manually registered in DNS.
//
// Defaults to TRUE

//
// RegisterDnsARecords (Boolean)
//
// Specifies that the DC is to register DNS A records for the domain.
//  If the DC is a GC, specifies that the DC is to register DNS A records for
//  the GC.
//
// If FALSE, the records will not be registered and older LDAP implementations
//  (ones that do not support SRV records) will not be able to locate the LDAP
//  server on this DC.
//
// Defaults to TRUE

//
// AvoidPdcOnWan (Boolean)
//
// This parameter specifies if BDC should send any validation/synchronization
// requests to PDC.  The validation against PDC is normally performed if the
// user does not validate on BDC.  This validation will be avoided if AvoidPdcOnWan
// is set to TRUE and PDC and BDC are on different sites. Likewise, if this key is
// set to TRUE and a BDC and the PDC are in different sites, then the new password
// info being updated on a BDC will not be immediately propagated to the PDC. (The
// new password will be replicated on the PDC by DS replication, not by Netlogon.)
//
// Defaults to FALSE.

//
// MaxConcurrentApi (Number of calls)
//
// This parameter specifies the maximum number of concurrent API calls that can
// be active over the secure channel at any one time.
//
// Increasing this parameter may improve throughput on the secure channel.
//
// This parameter currently only affect Logon APIs.  They may affect other secure
// channel operations in the future.
//
// Concurrent API calls are only possible if the secure channel is signed or sealed.
//
// If this parameter is set too large, this machine will place an excessive load
// on the DC the secure channel is to.
//
// The default value is 0.  Zero will use 1 concurrent API call on member workstations
// and DCs.  Zero implies 2 concurrent API calls on member servers
//
//
#define DEFAULT_MAXCONCURRENTAPI 0
#define MAX_MAXCONCURRENTAPI     10
#define MIN_MAXCONCURRENTAPI     0

//
// AvoidDnsDeregOnShutdown (Boolean)
//
// This parameter specifies if DNS record deregistration should be avoided on shutting
// down netlogon. If set to FALSE, it can be used to force such deregistrations for
// debugging or some other purposes. However, setting this value to FALSE may brake the
// DS replication, as the following example shows. Suppose we have two DS intergrated
// DNS servers, A and B which are authoritative for a particular zone and use each other
// as secondary DNS servers for that zone. Suppose Netlogon shuts down on B and deregisters
// its records. That gets propagated to A. Then netlogon is started on B and the records
// are re-registered on B. Now A needs to do its pull ssync from B. To do that, the DS uses
// B's DsaGuid record (of the form <DsaGuid>._msdcs.<DnsForestName>). But the record is
// missing on A and A is authoritative for that zone, so A is not going to find B and cannot
// pull from B.
//
// Defaults to TRUE.

//
// DnsUpdateOnAllAdapters (Boolean)
//
// This parameter specifies whether DNS updates should be sent over all available
// adapters including those where dynamic DNS updates are normally disabled.
// DHCP initiated A record updates are not sent through such adapters.
// An adapter that is connected to external network (e.g. Internet) is normally
// marked as such through the UI.
// However, there may be a need to update Netlogon SRV records through such adapters,
// hence the need for this parameter. Note that not only SRV records, but Netlogon's
// A records as well will be updated through all adapters if this parameter is TRUE,
// but it should not cause any significantly undesired behavior since Netlogon's A
// records are rarely used.
//
// Defaults to FALSE.

//
// DnsAvoidRegisterRecords
//
// A multivalued property listing the mnemonics for names of DNS records which
// this DC should not register. The mnemonics uses the convention for descriptive
// names of records used in the table of all records for this server (see
// NlDcDnsNameTypeDesc[] in nlcommon.h). The descriptive name of each record is
// prefixed by "NlDns".  For example, "NlDnsLdapIpAddress", "NlDnsLdapAtSite", etc.
// To avoid registering one of the records, one should use the suffix following
// "NlDns" in the descriptive name of that record. For instance, to skip registering
// the NlDnsLdapIpAddress record, one should enter "LdapIpAddress" as one of the
// values for this maltivalued property.
//
//  This is the most flexible way of avoiding DNS registrations for particular
// records. It superceeds all other ways which enable DNS registrations through
// the registry. For instance, if RegisterDnsARecords is expicitly set to 1
// while the A record mnemonic is listed for DnsAvoidRegisterRecords, no A record
// will be registered.
//

//
// NegativeCachePeriod (in seconds):
//
// Specifies the amount of time that DsGetDcName will remember that a DC couldn't
// be found in a domain.  If a subsequent attempt is made within this time,
// the DsGetDcName call will immediately fail without attempting to find a DC again.
//
// If this number is too large, a client will never try to find a DC again if the
// DC is initially unavailable
//
// If this number is too small, every call to DsGetDcName will have to attempt
//  to find a DC even when none is available.
//

#define DEFAULT_NEGATIVECACHEPERIOD             45            // 45 seconds
#define MIN_NEGATIVECACHEPERIOD                 0             // No minimum
#define MAX_NEGATIVECACHEPERIOD                 (7*24*60*60)  // 7 days


//
// BackgroundRetryInitialPeriod (in seconds):
//
// Some applications periodically try to find a DC.  If the DC isn't available, these
// periodic retries can be costly in dial-on-demand scenarios.  This registry value
// defines the minimum amount of elapsed time before the first retry will occur.
//
// The value only affects callers of DsGetDcName that have specified the
// DS_BACKGROUND_ONLY flag.
//
// If a value smaller than NegativeCachePeriod is specified, NegativeCachePeriod will
// be used.
//
// If this number is too large, a client will never try to find a DC again if the
// DC is initially unavailable
//
// If this number is too small, periodic DC discovery traffic may be excessive in
// cases where the DC will never become available.
//

#define DEFAULT_BACKGROUNDRETRYINITIALPERIOD    (10*60)           // 10 minutes
#define MIN_BACKGROUNDRETRYINITIALPERIOD        0                 // NegativeCachePeriod
#define MAX_BACKGROUNDRETRYINITIALPERIOD        (0xFFFFFFFF/1000) // 49 days


//
// BackgroundRetryMaximumPeriod (in seconds):
//
// Some applications periodically try to find a DC.  If the DC isn't available, these
// periodic retries can be costly in dial-on-demand scenarios.  This registry value
// defines the maximum interval the retries will be backed off to.  That is, if
// the first retry is after 10 minutes, the second will be after 20 minutes, then after 40.
// This continues until the retry interval is BackgroundRetryMaximumPeriod.  That interval
// will continue until BackgroundRetryQuitTime is reached.
//
// The value only affects callers of DsGetDcName that have specified the
// DS_BACKGROUND_ONLY flag.
//
// If a value smaller that BackgroundRetryInitialPeriod is specified,
// BackgroundRetryInitialPeriod will be used.
//
// If this number is too large, a client will try very infrequently after
// sufficient consecutive failures resulting in a backoff to BackgroundRetryMaximumPeriod.
//
// If this number is too small, periodic DC discovery traffic may be excessive in
// cases where the DC will never become available.
//

#define DEFAULT_BACKGROUNDRETRYMAXIMUMPERIOD    (60*60)           // 60 minutes
#define MIN_BACKGROUNDRETRYMAXIMUMPERIOD        0                 // BackgroundRetryInitialPeriod
#define MAX_BACKGROUNDRETRYMAXIMUMPERIOD        (0xFFFFFFFF/1000) // 49 days

//
// BackgroundRetryQuitTime (in seconds):
//
// Some applications periodically try to find a DC.  If the DC isn't available, these
// periodic retries can be costly in dial-on-demand scenarios.  This registry value
// defines the maximum interval the retries will be backed off to.  That is, if
// the first retry is after 10 minutes, the second will be after 20 minutes, then after 40.
// This continues until the retry interval is BackgroundRetryMaximumPeriod.  That interval
// will continue until BackgroundRetryQuitTime is reached.
//
// The value only affects callers of DsGetDcName that have specified the
// DS_BACKGROUND_ONLY flag.
//
// If a value smaller that BackgroundRetryMaximumPeriod is specified,
// BackgroundRetryMaximumPeriod will be used.
//
// 0 means to never quit retrying.
//
// If this number is too small, a client will eventually stop trying to find a DC
//

#define DEFAULT_BACKGROUNDRETRYQUITTIME    0                 // Infinite
#define MIN_BACKGROUNDRETRYQUITTIME        0                 // BackgroundRetryMaximumPeriod
#define MAX_BACKGROUNDRETRYQUITTIME        (0xFFFFFFFF/1000) // 49 days

//
// BackgroundSuccessfulRefreshPeriod (in seconds):
//
// When a positive cache entry is old (older than the successful refresh interval),
// the DC discovery routine will ping the cached DC to refresh its info before
// returning that DC to the caller. Here we distiguish between background
// callers which periodically perform DC discovery and the rest of the callers
// because they have different characteristics. Namely, for background callers
// which call the DC locator frequently, the cache refresh shouldn't happen
// frequently to avoid extensive network overhead and load on DCs. In fact,
// the default for background callers is to never refresh the info. If the cached
// DC no longer plays the same role, a background caller will detect this change
// when it performs its operation on that DC in which case it will call us back
// with forced rediscovery bit set.
//

#define DEFAULT_BACKGROUNDREFRESHPERIOD    0xFFFFFFFF        // Infinite - never refresh
#define MIN_BACKGROUNDREFRESHPERIOD        0                 // Always refresh
#define MAX_BACKGROUNDREFRESHPERIOD        0xFFFFFFFF        // Infinite. Any period larger than
                                                             //   0xFFFFFFFF/1000 sec = 49 days
                                                             //   will be treated as infinity
//
// NonBackgroundSuccessfulRefreshPeriod (in seconds):
//
// See the description of BackgroundSuccessfulRefreshPeriod
//

#define DEFAULT_NONBACKGROUNDREFRESHPERIOD 1800              // 30 minutes
#define MIN_NONBACKGROUNDREFRESHPERIOD     0                 // Always refresh
#define MAX_NONBACKGROUNDREFRESHPERIOD     0xFFFFFFFF        // Infinite. Any period larger than
                                                             //   0xFFFFFFFF/1000 sec = 49 days
                                                             //   will be treated as infinity
//
// MaxLdapServersPinged (DWORD)
//
// This parameter specifies the maximum number of DCs that should be
// pinged using LDAP during a DC discovery attempt. If this value is
// too large, a greater network traffic may be imposed and the DC discovery
// may take longer to return.  If this number is too small, it may decrease
// chances for successful DC discovery if none of the pinged DCs responds
// in a timely manner.
//
// The default value of 55 has been chosen so that the discovery attempt
// takes roughly 15 seconds max. We make up to 2 loops through DC addresses
// pinging each address on the list with the following distribution for
// response wait time:
//
//      For the first 5 DCs the wait time is 0.4 seconds per ping
//      For the next  5 DCs the wait time is 0.2 seconds per ping
//      For the rest of 45 DCs the wait time is 0.1 seconds per ping
//
// This will take (5*0.4 + 5*0.2 + 45*0.1) = 7.5 seconds per loop assuming
// that each DC has just one IP address. It will take longer if some DCs have
// more than one IP address.
//
// The rational behind this distribution is that we want to reduce the network
// traffic and reduce chances for network flooding (that is harmful for DCs)
// in case all DCs are slow to respond due to high load. Thus, the first 10 DCs
// have higher chances to be discovered before we impose greater network traffic
// by pinging the rest of DCs. If the first 10 DCs happen to be slow we have to
// reduce the wait timeout to a minimum as we want to cover a reasonable number
// of DCs in the time left.
//

#define DEFAULT_MAXLDAPSERVERSPINGED       55
#define MIN_MAXLDAPSERVERSPINGED           1
#define MAX_MAXLDAPSERVERSPINGED           0xFFFFFFFF

//
// AllowSingleLabelDnsDomain (Boolean)
//
// By default, the DC locator will not attempt DNS specific discovery for single
// labeled domain names.  This is done to avoid spurious DNS queries since DNS
// domain names are usually multi labeled. However, this parameter may be used to
// allow DNS specific discoveries for single labeled domain names which may exist
// in a specific customer deployment.
//
// Defaults to FALSE.
//

//
// Nt4Emulator (Boolean)
//
// This parameter specifies whether this DC should emulate the behavior of an NT4.0 DC.
// Emulation of the NT4.0 behavior is desirable when the first Windows 2000 or newer
// DC is promoted to the PDC in an NT4.0 domain with a huge number of alredy existing
// Windows 2000 clients. Unless we emulate the NT4.0 behavior, all the Windows 2000
// clients will stick with the Windows 2000 or newer DC upon learning about the domain
// upgrade thereby potentially overloading the DC.
//
// This parameter is ignored on non-DC. If this parameter is set to TRUE, the following
// takes place on a DC:
//
//  * Incoming LDAP locator pings are ignored unless the ping comes
//    from an admin machine (see NeutralizeNt4Emulator description below).
//
//  * The flags negotiated during the incoming secure channel setup
//    will be set to at most what an NT4.0 DC would support unless
//    the channel setup comes form an admind machine (see NeutralizeNt4Emulator
//    description below).
//
// Defaults to FALSE.
//

//
// NeutralizeNt4Emulator (Boolean)
//
// This parameter specifies whether this machine should indicate in the relevant
// communication with a DC that the DC should avoid the NT4.0 emulation mode (see
// Nt4Emulator description above). If this parameter is TRUE, the machine is said
// to be an admin machine.
//
// Defaults to FALSE on a non-DC.  Defaults to TRUE on a DC.
//

//
// DcTcpipPort (DWORD)
//
// This parameter specifies the port number that the netlogon server on the DC
//  should register with the RPC endpoint mapper for the TCPIP protocol sequence.
//  If this value doesn't exist, netlogon will not specify the port number in
//  which case the port will be chosen dynamically by the end point mapper at the
//  time a client makes an RPC call to netlogon on the DC.
//
// Note that netlogon registers the port number only on service start up, so registry
//  change notifications are ignored for this parameter. Also note that this parameter
//  is not stored in the NlGlobalParameters structure. Rather, it is read from the
//  registry once at the netlogon service start.
//
// By default, this parameter does not exist. It is ignored on non-DCs.
//

//
// AllowExclusiveSysvolShareAccess
//
// This parameter specifies whether the exclusive access to the Sysvol share
//  is allowed. If the exclusive access is allowed, an app with only read
//  permission to files on the sysvol share can lock the files by requesting
//  exclusive read access, which might prevent Group Policy settings from being
//  updated on other clients in the domain. When the exclsuve access needs to
//  be allowed because some critical app relies on it, domain administrators
//  should ensure that the only applications using the exclusive read capability
//  in the domain are those approved by the administrator.
//
// Defaults to FALSE.
//

//
// AllowExclusiveScriptsShareAccess
//
// This parameter specifies whether the exclusive access to the Scripts share
//  is allowed. If the exclusive access is allowed, an app with only read
//  permission to files on the NETLOGON share can lock the files by requesting
//  exclusive read access, which might prevent client machines or users in the
//  domain from conforming to administrator specified settings and actions such
//  as logon scripts. When the exclsuve access needs to be allowed because some
//  critical app relies on it, domain administrators should ensure that the only
//  applications using the exclusive read capability in the domain are those
//  approved by the administrator.
//
// Defaults to FALSE.
//

//
// FtInfoUpdateInterval (in seconds)
//
// This parameter defines how often forest trust info is to be refreshed on PDC.
// If forest trust info on PDC is older than this time interval, the forest trust
// info will be refreshed at the next scavenging. See ScavengeInterval that defines
// how often scavenging is performed.
//
#define DEFAULT_FTINFO_UPDATE_INTERVAL     (24*3600)         // 1 day
#define MIN_FTINFO_UPDATE_INTERVAL         (3600)            // 1 hour
#define MAX_FTINFO_UPDATE_INTERVAL         0xFFFFFFFF        // Infinite. Any period larger than
                                                             //   0xFFFFFFFF/1000 sec = 49 days
                                                             //   will be treated as infinity
//
// AvoidLocatorAccountLookup (Boolean)
//
// This parameter specifies whether this DC should perform account lookups
// during DC discovery response processing for queries with account. Excessive
// account lookups may be expensive and can affect the DC performance. Also,
// malicious user can take advantage of this and cause a DoS attack by bombing
// the DC with discoveries with account. In any case, if the performance is
// determined to be affected, account lookups can be avoided by temporarily
// setting this parameter to 1 on the DC in which case the DC will respond to
// the discovery even if the specified account does not exist on the DC. While
// this setting is chosen, clients which legitimately require DC with a particular
// account may get denied service on this DC. After the problem is rectified, the
// setting should be reverted to the default.
//
// Defaults to FALSE
//

//
// Structure to hold all of the parameters.
//
typedef struct _NETLOGON_PARAMETERS {
    ULONG   DbFlag;
    ULONG   LogFileMaxSize;
    ULONG   Pulse;
    ULONG   PulseMaximum;

    ULONG   PulseConcurrency;
    ULONG   PulseTimeout1;
    ULONG   PulseTimeout2;
    BOOL    DisablePasswordChange;

    BOOL    RefusePasswordChange;
    ULONG   Randomize;
    ULONG   MaximumMailslotMessages;
    ULONG   MailslotMessageTimeout;

    ULONG   MailslotDuplicateTimeout;
    ULONG   ExpectedDialupDelay;
    ULONG   ScavengeInterval;
    ULONG   LdapSrvPriority;

    ULONG   LdapSrvWeight;
    ULONG   LdapSrvPort;
    ULONG   LdapGcSrvPort;
    ULONG   KdcSrvPort;

    ULONG   DnsTtl;
    ULONG   DnsRefreshInterval;
    ULONG   CloseSiteTimeout;
    ULONG   SiteNameTimeout;
    ULONG   DnsFailedDeregisterTimeout;
    ULONG   SiteCoverageRefreshInterval;

    ULONG   DuplicateEventlogTimeout;
    ULONG   KerbIsDoneWithJoinDomainEntry;
    ULONG   MaxConcurrentApi;
    ULONG   MaximumPasswordAge;

    ULONG   NegativeCachePeriod;
    ULONG   BackgroundRetryInitialPeriod;
    ULONG   BackgroundRetryMaximumPeriod;
    ULONG   BackgroundRetryQuitTime;

    ULONG   BackgroundSuccessfulRefreshPeriod;
    ULONG   NonBackgroundSuccessfulRefreshPeriod;

    ULONG   MaxLdapServersPinged;

    ULONG   FtInfoUpdateInterval;

    LPWSTR UnicodeSysvolPath;
    LPWSTR UnicodeScriptPath;
    LPWSTR SiteName;

    BOOL SiteNameConfigured;
    LPWSTR SiteCoverage;
    LPWSTR GcSiteCoverage;
    LPWSTR NdncSiteCoverage;
    BOOL AutoSiteCoverage;
    LPWSTR DnsAvoidRegisterRecords;

    BOOL AvoidSamRepl;
    BOOL AvoidLsaRepl;
    BOOL AllowReplInNonMixed;
    BOOL SignSecureChannel;
    BOOL SealSecureChannel;
    BOOL RequireSignOrSeal;
    BOOL RequireStrongKey;
    BOOL SysVolReady;
    BOOL UseDynamicDns;
    BOOL RegisterBeta2Dns;
    BOOL RegisterDnsARecords;
    BOOL AvoidPdcOnWan;
    BOOL AvoidDnsDeregOnShutdown;
    BOOL DnsUpdateOnAllAdapters;
    BOOL Nt4Emulator;
    BOOL NeutralizeNt4Emulator;
    BOOL AllowSingleLabelDnsDomain;
    BOOL AllowExclusiveSysvolShareAccess;
    BOOL AllowExclusiveScriptsShareAccess;
    BOOL AvoidLocatorAccountLookup;

    //
    // Parameters converted to 100ns units
    //
    LARGE_INTEGER PulseMaximum_100ns;
    LARGE_INTEGER PulseTimeout1_100ns;
    LARGE_INTEGER PulseTimeout2_100ns;
    LARGE_INTEGER MailslotMessageTimeout_100ns;
    LARGE_INTEGER MailslotDuplicateTimeout_100ns;
    LARGE_INTEGER MaximumPasswordAge_100ns;
    LARGE_INTEGER BackgroundRetryQuitTime_100ns;

    //
    // Other computed parameters
    //
    ULONG ShortApiCallPeriod;
    ULONG DnsRefreshIntervalPeriod;
} NETLOGON_PARAMETERS, *PNETLOGON_PARAMETERS;

#endif // _INIPARM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\error.c ===
/*++

Copyright (c) 1987-1996 Microsoft Corporation

Module Name:

    error.c

Abstract:

    Error routines for Netlogon service

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    29-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.

--*/

//
// Common include files.
//
#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//

#include <lmalert.h>    // LAN Manager alert routines

#include <Secobj.h>     // need for NetpDeleteSecurityObject



NET_API_STATUS
NlCleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup all global resources.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    PLIST_ENTRY ListEntry;
    DWORD i;
    BOOLEAN WaitForMsv;

    //
    // Let the ChangeLog routines know that Netlogon is not started.
    //

    NlGlobalChangeLogNetlogonState = NetlogonStopped;

    //
    // Let everybody know we are to terminate
    //

    NlGlobalTerminate = TRUE;

    //
    // Indicate to external waiters that we're not running.
    //

    if ( NlGlobalStartedEvent != NULL ) {
        //
        // Reset it first in case some other process is preventing its deletion.
        //
        (VOID) ResetEvent( NlGlobalStartedEvent );
        (VOID) CloseHandle( NlGlobalStartedEvent );
        NlGlobalStartedEvent = NULL;
    }


    //
    // Stop the RPC server (Wait for outstanding calls to complete)
    //

    if ( NlGlobalRpcServerStarted ) {
        Status = RpcServerUnregisterIf ( logon_ServerIfHandle, 0, TRUE );
        NlAssert( Status == RPC_S_OK );
        NlGlobalRpcServerStarted = FALSE;
    }


    //
    // Tell all the MSV threads to leave netlogon.dll.
    //

    EnterCriticalSection( &NlGlobalMsvCritSect );
    if ( NlGlobalMsvEnabled ) {
        NlGlobalMsvEnabled = FALSE;
        WaitForMsv = (NlGlobalMsvThreadCount > 0 );
    } else {
        WaitForMsv = FALSE;
    }
    LeaveCriticalSection( &NlGlobalMsvCritSect );

    //
    // Wait for the MSV threads to leave netlogon.dll
    //

    if ( NlGlobalMsvTerminateEvent != NULL ) {

        if ( WaitForMsv ) {
            WaitForSingleObject( NlGlobalMsvTerminateEvent, INFINITE );
        }

        (VOID) CloseHandle( NlGlobalMsvTerminateEvent );
        NlGlobalMsvTerminateEvent = NULL;

    }




    //
    // Shut down the worker threads.
    //
    NlWorkerTermination();

    //
    // Clean up hosted domains.
    //

    NlUninitializeDomains();

    NlAssert( IsListEmpty( &NlGlobalBdcServerSessionList ) );
    NlAssert( IsListEmpty( &NlGlobalPendingBdcList ) );




    //
    // Close the browser
    //

    NlBrowserClose();


    //
    // Free the transport list
    //

    NlTransportClose();
    DeleteCriticalSection( &NlGlobalTransportCritSect );


    //
    // Free the DNS name list
    //

    NlDnsShutdown();
    DeleteCriticalSection( &NlGlobalDnsCritSect );

    //
    // Free the DNS tree name.
    //

    NlSetDnsForestName( NULL, NULL );

    //
    // Free the DNS tree name alias
    //

    EnterCriticalSection( &NlGlobalDnsForestNameCritSect );
    if ( NlGlobalUtf8DnsForestNameAlias != NULL ) {
        NetpMemoryFree( NlGlobalUtf8DnsForestNameAlias );
        NlGlobalUtf8DnsForestNameAlias = NULL;
    }
    LeaveCriticalSection( &NlGlobalDnsForestNameCritSect );
    DeleteCriticalSection( &NlGlobalDnsForestNameCritSect );

    //
    // Free the Site list
    //

    NlSiteTerminate();

    NlParseFree( &NlGlobalParameters );

    //
    // Free the list of outstanding challenges
    //

    NlRemoveChallengeForClient( NULL, NULL, FALSE );
    NlAssert( IsListEmpty( &NlGlobalChallengeList ) );
    NlAssert( NlGlobalChallengeCount == 0 );
    DeleteCriticalSection( &NlGlobalChallengeCritSect );

    //
    // Free the Trusted Domain List
    //

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );

    if ( NlGlobalTrustedDomainList != NULL ) {
        NetpMemoryFree( NlGlobalTrustedDomainList );
        NlGlobalTrustedDomainList = NULL;
        NlGlobalTrustedDomainCount = 0;
        NlGlobalTrustedDomainListTime.QuadPart = 0;
    }

    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
    DeleteCriticalSection( &NlGlobalDcDiscoveryCritSect );

    //
    // Delete any notifications we didn't get to.
    //

    LOCK_CHANGELOG();
    while ( !IsListEmpty( &NlGlobalChangeLogNotifications ) ) {
        PCHANGELOG_NOTIFICATION Notification;

        ListEntry = RemoveHeadList( &NlGlobalChangeLogNotifications );
        Notification = CONTAINING_RECORD( ListEntry, CHANGELOG_NOTIFICATION, Next );

        NetpMemoryFree( Notification );
    }
    UNLOCK_CHANGELOG();



    //
    // Free up resources
    //

    if ( NlGlobalNetlogonSecurityDescriptor != NULL ) {
        NetpDeleteSecurityObject( &NlGlobalNetlogonSecurityDescriptor );
        NlGlobalNetlogonSecurityDescriptor = NULL;
    }

    if ( NlGlobalUnicodeComputerName != NULL ) {
        NetApiBufferFree( NlGlobalUnicodeComputerName );
        NlGlobalUnicodeComputerName = NULL;
    }




    //
    // delete well known SIDs if they are allocated already.
    //

    NetpFreeWellKnownSids();



    //
    // Clean up the scavenger crit sect
    //
    DeleteCriticalSection( &NlGlobalScavengerCritSect );

    //
    // Clean up the replicator crit sect
    //
    DeleteCriticalSection( &NlGlobalReplicatorCritSect );

    //
    // Delete the timer event
    //

    if ( NlGlobalTimerEvent != NULL ) {
        (VOID) CloseHandle( NlGlobalTimerEvent );
        NlGlobalTimerEvent = NULL;
    }

    //
    // Cleanup Winsock.
    //

    if ( NlGlobalWinSockInitialized ) {
        WSACleanup();
    }

    //
    // Unregister WMI trace Guids
    //

    if ( NlpTraceRegistrationHandle != (TRACEHANDLE)0 ) {
        UnregisterTraceGuids( NlpTraceRegistrationHandle );
        NlpEventTraceFlag = FALSE;
        NlpTraceRegistrationHandle = (TRACEHANDLE) 0;
        NlpTraceLoggerHandle = (TRACEHANDLE) 0;
    }

    //
    // Free the Authz resource manager
    //

    NlFreeAuthzRm();

    //
    // Free the list of events that have already been logged.
    //

    NetpEventlogSetTimeout ( NlGlobalEventlogHandle, 0 );   // Set timeout back to zero seconds
    NetpEventlogClearList ( NlGlobalEventlogHandle );

    //
    // Unload ntdsa.dll
    //

    if ( NlGlobalNtDsaHandle != NULL ) {
        FreeLibrary( NlGlobalNtDsaHandle );
        NlGlobalNtDsaHandle = NULL;
    }

    if ( NlGlobalIsmDllHandle != NULL ) {
        FreeLibrary( NlGlobalIsmDllHandle );
        NlGlobalIsmDllHandle = NULL;
    }

    if ( NlGlobalDsApiDllHandle != NULL ) {
        FreeLibrary( NlGlobalDsApiDllHandle );
        NlGlobalDsApiDllHandle = NULL;
    }


    //
    // Unload the DLL if requested.
    //

    if ( NlGlobalUnloadNetlogon ) {
        NetStatus = NlpFreeNetlogonDllHandles();
        NlPrint((NL_MISC, "Netlogon.dll unloaded (%ld).\n", NetStatus ));
    }

    //
    // Delete the Event used to ask Netlogon to exit.
    //

    if( !CloseHandle( NlGlobalTerminateEvent ) ) {
        NlPrint((NL_CRITICAL,
                "CloseHandle NlGlobalTerminateEvent error: %lu\n",
                GetLastError() ));
    }

    //
    // Remove the wait routine for the DS paused event
    //

    if ( NlGlobalDsPausedWaitHandle != NULL ) {

        UnregisterWaitEx( NlGlobalDsPausedWaitHandle,
                          INVALID_HANDLE_VALUE ); // Wait until routine finishes execution

        NlGlobalDsPausedWaitHandle = NULL;
    }

    //
    // Free the event used to see if the DS is paused.
    //

    if ( NlGlobalDsPausedEvent != NULL ) {
        CloseHandle( NlGlobalDsPausedEvent );
        NlGlobalDsPausedEvent = NULL;
    }

    //
    // free cryptographic service provider.
    //
    if ( NlGlobalCryptProvider ) {
        CryptReleaseContext( NlGlobalCryptProvider, 0 );
        NlGlobalCryptProvider = (HCRYPTPROV)NULL;
    }


    //
    // Close the handle to the debug file.
    //

#if NETLOGONDBG
    EnterCriticalSection( &NlGlobalLogFileCritSect );
    if ( NlGlobalLogFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( NlGlobalLogFile );
        NlGlobalLogFile = INVALID_HANDLE_VALUE;
    }
    if ( NlGlobalLogFileOutputBuffer != NULL ) {
        LocalFree( NlGlobalLogFileOutputBuffer );
        NlGlobalLogFileOutputBuffer = NULL;
    }
    LeaveCriticalSection( &NlGlobalLogFileCritSect );

    if( NlGlobalDebugSharePath != NULL ) {
        NetpMemoryFree( NlGlobalDebugSharePath );
        NlGlobalDebugSharePath = NULL;
    }
#endif // NETLOGONDBG

    //
    // Clean up the global parameters crit sect
    //

    DeleteCriticalSection( &NlGlobalParametersCritSect );

    //
    // Set the service state to uninstalled, and tell the service controller.
    //  Do this as the last step to prevent the service controller from
    //  starting netlogon while we are in the middle of shutdown.
    //

    NlGlobalServiceStatus.dwCurrentState = SERVICE_STOPPED;
    NlGlobalServiceStatus.dwCheckPoint = 0;
    NlGlobalServiceStatus.dwWaitHint = 0;

#ifdef _DC_NETLOGON
    if( !SetServiceStatus( NlGlobalServiceHandle,
                           &NlGlobalServiceStatus ) ) {

        IF_NL_DEBUG( CRITICAL ) {
            NetpKdPrint(( "[NETLOGON] NlCleanup: SetServiceStatus failed: %lu\n",
                          GetLastError() ));
        }
    }
#endif // _DC_NETLOGON

    //
    // Return an exit status to our caller.
    //
    return (NET_API_STATUS)
        ((NlGlobalServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR) ?
          NlGlobalServiceStatus.dwServiceSpecificExitCode :
          NlGlobalServiceStatus.dwWin32ExitCode);

}




VOID
NlExit(
    IN DWORD ServiceError,
    IN NET_API_STATUS Data,
    IN NL_EXIT_CODE ExitCode,
    IN LPWSTR ErrorString
    )
/*++

Routine Description:

    Registers service as uninstalled with error code.

Arguments:

    ServiceError - Service specific error code

    Data - a DWORD of data to be logged with the message.
        No data is logged if this is zero.

    ExitCode - Indicates whether the message should be logged to the eventlog
        and whether Data is a status code that should be appended to the bottom
        of the message:

    ErrorString - Error string, used to print it on debugger.

Return Value:

    None.

--*/

{
    IF_NL_DEBUG( MISC ) {

        NlPrint((NL_MISC, "NlExit: Netlogon exiting %lu 0x%lx",
                      ServiceError,
                      ServiceError ));

        if ( Data ) {
            NlPrint((NL_MISC, " Data: %lu 0x%lx", Data, Data ));
        }

        if( ErrorString != NULL ) {
            NlPrint((NL_MISC, " '%ws'", ErrorString ));
        }

        NlPrint(( NL_MISC, "\n"));

    }

    //
    // Record our exit in the event log.
    //

    if ( ExitCode != DontLogError ) {
        LPWSTR MsgStrings[2];
        ULONG MessageCount = 0;

        if ( ErrorString != NULL ) {
            MsgStrings[MessageCount] = ErrorString;
            MessageCount ++;
        }

        if ( ExitCode == LogErrorAndNtStatus ) {
            MsgStrings[MessageCount] = (LPWSTR) ULongToPtr( Data );
            MessageCount ++;
            MessageCount |= NETP_LAST_MESSAGE_IS_NTSTATUS;
        } else if ( ExitCode == LogErrorAndNetStatus ) {
            MsgStrings[MessageCount] = (LPWSTR) ULongToPtr( Data );
            MessageCount ++;
            MessageCount |= NETP_LAST_MESSAGE_IS_NETSTATUS;
        }


        NlpWriteEventlog( ServiceError,
                          EVENTLOG_ERROR_TYPE,
                          (Data) ? (LPBYTE) &Data : NULL,
                          (Data) ? sizeof(Data) : 0,
                          (MessageCount != 0) ? MsgStrings : NULL,
                          MessageCount );
    }

    //
    // Set the service state to stop pending.
    //

    NlGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    NlGlobalServiceStatus.dwWaitHint = NETLOGON_INSTALL_WAIT;
    NlGlobalServiceStatus.dwCheckPoint = 1;

    SET_SERVICE_EXITCODE(
        Data,
        NlGlobalServiceStatus.dwWin32ExitCode,
        NlGlobalServiceStatus.dwServiceSpecificExitCode
        );

#ifdef _DC_NETLOGON
    //
    // Tell the service controller what our state is.
    //

    if( !SetServiceStatus( NlGlobalServiceHandle,
                &NlGlobalServiceStatus ) ) {

        NlPrint((NL_CRITICAL, "SetServiceStatus error: %lu\n",
                          GetLastError() ));
    }
#endif // _DC_NETLOGON

    //
    // Indicate that all threads should exit.
    //

    NlGlobalTerminate = TRUE;

    if ( !SetEvent( NlGlobalTerminateEvent ) ) {
        NlPrint((NL_CRITICAL, "Cannot set termination event: %lu\n",
                          GetLastError() ));
    }

}



BOOL
GiveInstallHints(
    IN BOOL Started
    )
/*++

Routine Description:

    Give hints to the installer of the service that installation is progressing.

Arguments:

    Started -- Set true to tell the service controller that we're done starting.

Return Value:

    TRUE -- iff install hint was accepted.

--*/
{
    static DWORD LastHintTime = 0;

    //
    // Previous incarnations of this routine attempted to return FALSE if
    //  NlGlobalTerminate was set.  That's bogus.  There's no way to
    //  differentiate whether the caller is trying to start the netlogon service
    //  (and we should return FALSE) or whether the caller is trying to
    //  stop the netlogon service (and we should give a shutdown hint).
    //


    //
    // Don't do anything unless we're currently starting or stopping.
    //

    if ( NlGlobalServiceStatus.dwCurrentState != SERVICE_START_PENDING &&
         NlGlobalServiceStatus.dwCurrentState != SERVICE_STOP_PENDING ) {
        return TRUE;
    }

    //
    // Tell the service controller our current state.
    //

    if ( Started ) {

        if ( NlGlobalServiceStatus.dwCurrentState != SERVICE_START_PENDING ) {
            NlPrint((NL_CRITICAL,
                    "Tried to set a STOP_PENDING service to RUNNING\n" ));
            NlExit( NELOG_NetlogonSystemError, GetLastError(), LogErrorAndNetStatus, NULL);
            return FALSE;
        }

        NlGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
        NlGlobalServiceStatus.dwCheckPoint = 0;
        NlGlobalServiceStatus.dwWaitHint = 0;
    } else {

        //
        // If it has been less than 1 second since the last time we gave a hint,
        //  avoid giving a superfluous hint.
        //

        if ( NetpDcElapsedTime( LastHintTime ) < 1000 ) {
            NlPrint((NL_SITE_MORE, "Hint avoided. %ld\n", NetpDcElapsedTime( LastHintTime ) ));
            return TRUE;
        }

        LastHintTime = GetTickCount();
        NlGlobalServiceStatus.dwCheckPoint++;
    }

    if( !SetServiceStatus( NlGlobalServiceHandle, &NlGlobalServiceStatus ) ) {
        NlExit( NELOG_NetlogonSystemError, GetLastError(), LogErrorAndNetStatus, NULL);
        return FALSE;
    }

    return TRUE;

}


VOID
NlControlHandler(
    IN DWORD opcode
    )
/*++

Routine Description:

    Process and respond to a control signal from the service controller.

Arguments:

    opcode - Supplies a value which specifies the action for the Netlogon
        service to perform.

Return Value:

    None.

--*/
{

    NlPrint((NL_MISC, "In control handler (Opcode: %ld)\n", opcode ));

    //
    // Handle an uninstall request.
    //

    switch (opcode) {
    case SERVICE_CONTROL_STOP:    /* Uninstall required */

        //
        // Request the service to exit.
        //
        // NlExit also sets the service status to UNINSTALL_PENDING
        // and tells the service controller.
        //

        NlExit( NERR_Success, NO_ERROR, DontLogError, NULL);
        return;

    //
    // Pause the service.
    //

    case SERVICE_CONTROL_PAUSE:

        NlGlobalServiceStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    //
    // Continute the service.
    //

    case SERVICE_CONTROL_CONTINUE:

        NlGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
        break;


    //
    // Dns changes
    //
    case SERVICE_CONTROL_DNS_SERVER_START:   // Dns telling us that the DNS server has started on this machine
        (VOID) NlSendChangeLogNotification( ChangeDnsNames,
                                              NULL,
                                              NULL,
                                              1,    // Force names to re-register
                                              NULL, // Object GUID,
                                              NULL, // Domain GUID,
                                              NULL );   // Domain Name
        break;

    //
    // By default, just return the current status.
    //

    case SERVICE_CONTROL_INTERROGATE:
    default:
        break;
    }

    //
    // Always respond with the current status.
    //

    if( !SetServiceStatus( NlGlobalServiceHandle,
                &NlGlobalServiceStatus ) ) {

        NlPrint((NL_CRITICAL, "SetServiceStatus error: %lu\n",
                          GetLastError() ));
    }

    return;
}

#ifdef notdef

BOOL
NlMessageBox(
    IN LPSTR MessageText,
    IN LPSTR Caption,
    UINT Type
    )
/*++

Routine Description:


    Raise a hard error popup.

Arguments:

    MessageText - Message to display in the popup.

    Caption - Caption for the message box.

    Type - Type of message. MB_SERVICE_NOTIFICATION is implied.  Other flags are as defined
        for the MessageBox API.


Return Value:

    TRUE - Box was displayed successfully.

    FALSE - Box could not be displayed for some reason.

--*/
{
    int Status;

    Status = MessageBoxA( NULL,
                          MessageText,
                          Caption,
                          MB_SERVICE_NOTIFICATION | Type );

    return ( Status == IDOK );

}
#endif // notdef
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\logon_s_stub.c ===
#include "logonsrv.h"
#pragma hdrstop

#include "logon_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\ftinfo.c ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    ftinfo.c

Abstract:

    Utilities routine to manage the forest trust info list

Author:

    27-Jul-00 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop
#include <ftnfoctx.h>



NTSTATUS
NlpUpdateFtinfo(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR TrustedDomainName,
    IN BOOLEAN ImpersonateCaller,
    IN PLSA_FOREST_TRUST_INFORMATION NewForestTrustInfo
    )
/*++

Routine Description:

    This function write the specified NewForestTrustInfo onto the named TDO.

    The NewForestTrustInfo is merged with the exsiting information using the following algorithm:

    The FTinfo records written are described in the NetpMergeFTinfo routine.

Arguments:

    DomainInfo - Hosted Domain that trusts the domain to query.

    TrustedDomainName - Trusted domain that is to be updated.  This domain must have the
        TRUST_ATTRIBUTE_FOREST_TRANSITIVE bit set.

    ImpersonateCaller - TRUE if the caller is to be impersonated.
        FALSE, if the trusted policy handle should be used to write the local LSA.

    NewForestTrustInfo - Specified the new array of FTinfo records as returned from the
        trusted domain.

Return Value:

    STATUS_SUCCESS: Success.

--*/
{
    NTSTATUS Status;

    LSAPR_HANDLE PolicyHandle = NULL;

    UNICODE_STRING TrustedDomainNameString;

    //
    // Open a handle to the LSA.
    //

    if ( ImpersonateCaller ) {

        OBJECT_ATTRIBUTES ObjectAttributes;

        //
        // Get some handle to LSA. Note that this
        //  handle will not be trusted even though
        //  we open it as LocalSystem.
        //
        InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);

        Status = LsarOpenPolicy( NULL,  // local server
                                 (PLSAPR_OBJECT_ATTRIBUTES) &ObjectAttributes,
                                 POLICY_TRUST_ADMIN,
                                 &PolicyHandle );

        if ( !NT_SUCCESS(Status) ) {
            NlPrint(( NL_CRITICAL,
                     "NlpUpdateTdo: %ws: Cannot LsarOpenPolicy 0x%lx\n",
                     TrustedDomainName,
                     Status ));
            goto Cleanup;
        }

    } else {
        PolicyHandle = DomainInfo->DomLsaPolicyHandle;
    }

    //
    // Set FTINFO
    //
    // Note that, if ImpersonateCaller is TRUE, the handle
    //  we pass is not trusted. In this case, the LSA will
    //  impersonate the caller and do the access check.
    //

    RtlInitUnicodeString( &TrustedDomainNameString, TrustedDomainName );

    Status = LsaIUpdateForestTrustInformation(
                 PolicyHandle,
                 &TrustedDomainNameString,
                 NewForestTrustInfo
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

Cleanup:

    if ( PolicyHandle != NULL ) {

        if ( ImpersonateCaller ) {
            (VOID) LsarClose( &PolicyHandle );
        }
    }

    return Status;
}




NTSTATUS
NlpGetForestTrustInfoHigher(
    IN PCLIENT_SESSION ClientSession,
    IN DWORD Flags,
    IN BOOLEAN ImpersonateCaller,
    IN BOOLEAN SessionAlreadyAuthenticated,
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    )
/*++

Routine Description:


    This function is the client side stub for getting the forest trust info from a
    trusted forest.

Arguments:

    ClientSession - Trusted domain that is to be queried.  This domain must have the
        TRUST_ATTRIBUTE_FOREST_TRANSITIVE bit set.

    Flags - Specifies a set of bits that modify the behavior of the API.
        Valid bits are:

        DS_GFTI_UPDATE_TDO - If this bit is set, the API will update
            the FTinfo attribute of the TDO named by the ClientSession
            parameter.
            The caller must have access to modify the FTinfo attribute or
            ERROR_ACCESS_DENIED will be returned.  The algorithm describing
            how the FTinfo from the trusted domain is merged with the FTinfo
            from the TDO is described below.

            This bit in only valid if ServerName specifies the PDC of its domain.

    ImpersonateCaller - TRUE if the caller is to be impersonated.
        FALSE, if the trusted policy handle should be used to write the local LSA.

    SessionAlreadyAuthenticated - If TRUE, the caller already authenticated
        the session, so there is no need to check or to reauthenticate.

    ForestTrustInfo - Returns a pointer to a structure containing a count and an
        array of FTInfo records describing the namespaces claimed by the
        domain specified by ClientSession. The Accepted field and Time
        field of all returned records will be zero.  The buffer should be freed
        by calling NetApiBufferFree.

Return Value:

    STATUS_SUCCESS: Message successfully sent

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    NETLOGON_AUTHENTICATOR OurAuthenticator;
    NETLOGON_AUTHENTICATOR ReturnAuthenticator;
    SESSION_INFO SessionInfo;
    BOOLEAN FirstTry = TRUE;

    NlAssert( ClientSession->CsReferenceCount > 0 );
    NlAssert( ClientSession->CsFlags & CS_WRITER );

    //
    // Only allow TDO update on the PDC.
    //

    if ( (Flags & DS_GFTI_UPDATE_TDO) != 0 &&
         ClientSession->CsDomainInfo->DomRole != RolePrimary ) {
        Status = STATUS_BACKUP_CONTROLLER;
        goto Cleanup;
    }

    //
    // Ensure the F bit is set.
    //

    if ( (ClientSession->CsTrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) == 0 ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
            "NlpGetForestTrustInfoHigher: trust isn't marked as cross forest trust: 0x%lX\n",
            ClientSession->CsTrustAttributes ));

        Status =  STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // If the session isn't authenticated,
    //  do so now.
    //

FirstTryFailed:

    if ( !SessionAlreadyAuthenticated ) {
        Status = NlEnsureSessionAuthenticated( ClientSession, 0 );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }
    }

    SessionInfo.SessionKey = ClientSession->CsSessionKey;
    SessionInfo.NegotiatedFlags = ClientSession->CsNegotiatedFlags;

    //
    // If the DC doesn't support the new function,
    //  fail now.
    //

    if ( (SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_CROSS_FOREST) == 0 ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlpGetForestTrustInfoHigher: remote DC doesn't support this function.\n" ));
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Build the Authenticator for this request to the PDC.
    //

    NlBuildAuthenticator(
                    &ClientSession->CsAuthenticationSeed,
                    &ClientSession->CsSessionKey,
                    &OurAuthenticator);


    //
    // Remote the request to the trusted DC.
    //

    NL_API_START( Status, ClientSession, TRUE ) {

        NlAssert( ClientSession->CsUncServerName != NULL );
        Status = I_NetGetForestTrustInformation(
                                      ClientSession->CsUncServerName,
                                      ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                                      &OurAuthenticator,
                                      &ReturnAuthenticator,
                                      0,    // No flags yet
                                      ForestTrustInfo );
        if ( !NT_SUCCESS(Status) ) {
            NlPrintRpcDebug( "I_NetGetForestTrustInformation", Status );
        }

    // NOTE: This call may drop the secure channel behind our back
    } NL_API_ELSE( Status, ClientSession, TRUE ) {

          //
          // We might have been called from NlSessionSetup,
          //  So we have to indicate the failure to our caller.
          //

          if ( NT_SUCCESS(Status) ) {
              Status = ClientSession->CsConnectionStatus;
              goto Cleanup;
          }

    } NL_API_END;


    //
    // Now verify authenticator and update our seed
    //

    if ( NlpDidDcFail( Status ) ||
         !NlUpdateSeed( &ClientSession->CsAuthenticationSeed,
                        &ReturnAuthenticator.Credential,
                        &ClientSession->CsSessionKey) ) {

        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlpDidDcFail: denying access after status: 0x%lx\n",
                    Status ));

        //
        // Preserve any status indicating a communication error.
        //

        if ( NT_SUCCESS(Status) ) {
            Status = STATUS_ACCESS_DENIED;
        }
        NlSetStatusClientSession( ClientSession, Status );

        //
        // Perhaps the netlogon service on the server has just restarted.
        //  Try just once to set up a session to the server again.
        //  However, if the caller set up the session, there is
        //  no need for a new session setup.
        //

        if ( FirstTry && !SessionAlreadyAuthenticated ) {
            FirstTry = FALSE;
            goto FirstTryFailed;
        }

    }

    //
    // Handle failures
    //

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Handle updating the FTINFO on the TDO
    //

    if ( (Flags & DS_GFTI_UPDATE_TDO) != 0 ) {

        LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
        Status = NlpUpdateFtinfo( ClientSession->CsDomainInfo,
                                  ClientSession->CsDnsDomainName.Buffer,
                                  ImpersonateCaller,
                                  *ForestTrustInfo );

        if ( !NT_SUCCESS(Status) ) {
            UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
            goto Cleanup;
        }

        //
        // Set the FTInfo refresh timestamp
        //

        NlQuerySystemTime( &ClientSession->CsLastFtInfoRefreshTime );
        UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    }

    Status = STATUS_SUCCESS;

    //
    // Common exit
    //

Cleanup:

    if ( !NT_SUCCESS(Status) ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlpGetForestTrustInfoHigher: failed %lX\n",
                Status));
    }

    return Status;
}



NET_API_STATUS
DsrGetForestTrustInformation (
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR TrustedDomainName OPTIONAL,
    IN ULONG Flags,
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    )

/*++

Routine Description:

    This is the server side stub for DsGetForestTrustInformationW.  See that routine
    for documentation.

Arguments:

    See DsGetForestTrustInformationW

Return Value:


    See DsGetForestTrustInformationW

--*/
{
    NET_API_STATUS NetStatus;
    PDOMAIN_INFO DomainInfo = NULL;
    PCLIENT_SESSION ClientSession = NULL;
    BOOLEAN AmWriter = FALSE;

    //
    // Perform access validation on the caller
    //

    NetStatus = NetpAccessCheck(
            NlGlobalNetlogonSecurityDescriptor,   // Security descriptor
            NETLOGON_FTINFO_ACCESS,               // Desired access
            &NlGlobalNetlogonInfoMapping );       // Generic mapping

    if ( NetStatus != NERR_Success) {
        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Validate the Flags parameter
    //

    if ((Flags & ~DS_GFTI_VALID_FLAGS) != 0 ) {
        NetStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }


    //
    // Find the referenced domain
    //

    DomainInfo = NlFindDomainByServerName( ServerName );    // Primary domain

    if ( DomainInfo == NULL ) {
        // Default to primary domain to handle the case where the ComputerName
        // is an IP address.

        DomainInfo = NlFindNetbiosDomain( NULL, TRUE );

        if ( DomainInfo == NULL ) {
            NetStatus = ERROR_INVALID_COMPUTERNAME;
            goto Cleanup;
        }
    }

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "DsrGetForestTrustInformation: %ws called: 0x%lx\n", TrustedDomainName, Flags ));



    //
    // Get the ForestTrustInformation for a particular TDO
    //

    if ( TrustedDomainName != NULL &&
         *TrustedDomainName != L'\0' ) {

        NTSTATUS Status;
        UNICODE_STRING TrustedDomainNameString;

        //
        // Only allow TDO update on the PDC.
        //

        if ( (Flags & DS_GFTI_UPDATE_TDO) != 0 &&
             DomainInfo->DomRole != RolePrimary ) {
            NetStatus = NERR_NotPrimary;
            goto Cleanup;
        }


        //
        // Find the client session to the trusted domain.
        //


        RtlInitUnicodeString(&TrustedDomainNameString, TrustedDomainName );

        ClientSession = NlFindNamedClientSession( DomainInfo,
                                                  &TrustedDomainNameString,
                                                  NL_DIRECT_TRUST_REQUIRED,
                                                  NULL );

        if( ClientSession == NULL ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                "DsrGetForestTrustInformation: %ws: can't find the client structure of the domain specified.\n",
                TrustedDomainName ));

            NetStatus =  ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        //
        // Become a Writer of the ClientSession.
        //

        if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                     "NlpGetForestTrustInfoHigher: Can't become writer of client session.\n" ));

            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        AmWriter = TRUE;


        //
        // Call the DC in the trusted domain.
        //

        Status = NlpGetForestTrustInfoHigher( ClientSession,
                                              Flags,
                                              TRUE,     // Impersonate caller
                                              FALSE,    // We didn't set up the session
                                              ForestTrustInfo );

        if ( !NT_SUCCESS(Status ) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

    //
    // Get the local ForestTrustInformation.
    //

    } else {

        NTSTATUS Status;

        //
        // Don't allow an Update TDO request if there is no TDO.
        //

        if ( Flags & DS_GFTI_UPDATE_TDO ) {
            NetStatus = ERROR_INVALID_FLAGS;
            goto Cleanup;
        }


        //
        // Simply grab the local ForestTrustInformation
        //

        Status = LsaIGetForestTrustInformation( ForestTrustInfo );

        if ( !NT_SUCCESS( Status )) {

            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
    }

    NetStatus = NO_ERROR;

Cleanup:
    if ( ClientSession != NULL ) {
        if ( AmWriter ) {
            NlResetWriterClientSession( ClientSession );
        }
        NlUnrefClientSession( ClientSession );
    }

    NlPrintDom(( NL_SESSION_SETUP, DomainInfo,
                 "DsrGetForestTrustInformation: %ws returns %ld\n",
                 TrustedDomainName,
                 NetStatus ));

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }
    return NetStatus;
}


NTSTATUS
NetrGetForestTrustInformation (
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD Flags,
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    )
/*++

Routine Description:

    The server side of the secure channel version of DsGetForestTrustInformation.

    The inbound secure channel identified by ComputerName must be for an interdomain trust
    and the inbound TDO must have the TRUST_ATTRIBUTE_FOREST_TRANSITIVE bit set.


Arguments:

    ServerName - The name of the domain controller this API is remoted to.

    ComputerName -- Name of the DC server making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    Flags - Specifies a set of bits that modify the behavior of the API.
        No values are currently defined.  The caller should pass zero.

    ForestTrustInfo - Returns a pointer to a structure containing a count and an
        array of FTInfo records describing the namespaces claimed by the
        domain specified by TrustedDomainName. The Accepted field and Time
        field of all returned records will be zero.  The buffer should be freed
        by calling NetApiBufferFree.


Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_ACCESS_DENIED -- The replicant should re-authenticate with
        the PDC.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    PDOMAIN_INFO DomainInfo = NULL;
    PSERVER_SESSION ServerSession;
    NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType;


    //
    // Lookup which domain this call pertains to.
    //
    *ForestTrustInfo = NULL;

    DomainInfo = NlFindDomainByServerName( ServerName );

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrGetForestTrustInformation: %ws called: 0x%lx\n", ComputerName, Flags ));

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }


    //
    // Find the server session entry for this secure channel.
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );
    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

    if (ServerSession == NULL) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Now verify the Authenticator and update seed if OK
    //

    Status = NlCheckAuthenticator(
                 ServerSession,
                 Authenticator,
                 ReturnAuthenticator);

    if ( !NT_SUCCESS(Status) ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        goto Cleanup;
    }

    SecureChannelType = ServerSession->SsSecureChannelType;

    //
    // This call is only valid on FOREST_TRANSITIVE trusts
    //

    if ( (ServerSession->SsFlags & SS_FOREST_TRANSITIVE) == 0 ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

        NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                "NetrGetForestTrustInformation: %ws failed because F bit isn't set on the TDO\n",
                ComputerName ));
        Status = STATUS_NOT_IMPLEMENTED;
        goto Cleanup;
    }


    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

    if ( !IsDomainSecureChannelType( SecureChannelType ) ) {

        NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                "NetrGetForestTrustInformation: %ws failed because secure channel isn't a domain secure channel\n",
                ComputerName ));

        Status = STATUS_NOT_IMPLEMENTED;
        goto Cleanup;
    }

    //
    // Get the forest trust information for the local machine
    //

    Status = LsaIGetForestTrustInformation( ForestTrustInfo );

    if ( !NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // If the request failed, be carefull to not leak authentication
    // information.
    //

    if ( Status == STATUS_ACCESS_DENIED )  {
        if ( ReturnAuthenticator != NULL ) {
            RtlSecureZeroMemory( ReturnAuthenticator, sizeof(*ReturnAuthenticator) );
        }

    }


    NlPrintDom(( NL_SESSION_SETUP, DomainInfo,
                 "NetrGetForestTrustInformation: %ws returns %lX\n",
                 ComputerName,
                 Status ));

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\logonapi.c ===
/*++

Copyright (c) 1987-1996 Microsoft Corporation

Module Name:

    logonapi.c

Abstract:

    Remote Logon  API routines.

Author:

    Cliff Van Dyke (cliffv) 28-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    Madana - Fixed several bugs.

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//


#include <accessp.h>    // Routines shared with NetUser Apis
#include <rpcutil.h>    // NetpRpcStatusToApiStatus()
#include <stdio.h>      // sprintf().
#ifdef ROGUE_DC
#include <sddl.h>
#endif

LPSTR
NlpLogonTypeToText(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel
    )
/*++

Routine Description:

    Returns a text string corresponding to LogonLevel

Arguments:

    LogonLevel - Type of logon

Return Value:

    Printable text string

    None

--*/
{
    LPSTR LogonType;

    //
    // Compute the string describing the logon type
    //

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
        LogonType = "Interactive"; break;
    case NetlogonNetworkInformation:
        LogonType = "Network"; break;
    case NetlogonServiceInformation:
        LogonType = "Service"; break;
    case NetlogonInteractiveTransitiveInformation:
        LogonType = "Transitive Interactive"; break;
    case NetlogonNetworkTransitiveInformation:
        LogonType = "Transitive Network"; break;
    case NetlogonServiceTransitiveInformation:
        LogonType = "Transitive Service"; break;
    case NetlogonGenericInformation:
        LogonType = "Generic"; break;
    default:
        LogonType = "[Unknown]";
    }

    return LogonType;

}


#ifdef _DC_NETLOGON

NET_API_STATUS
NlEnsureClientIsNamedUser(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR UserName
    )
/*++

Routine Description:

    Ensure the client is the named user.

Arguments:

    UserName - name of the user to check.

Return Value:

    NT status code.

--*/
{
    NET_API_STATUS NetStatus;
    RPC_STATUS RpcStatus;
    NTSTATUS Status;
    HANDLE TokenHandle = NULL;
    PTOKEN_USER TokenUserInfo = NULL;
    ULONG TokenUserInfoSize;
    ULONG UserId;
    PSID UserSid;

    //
    // Get the relative ID of the specified user.
    //

    Status = NlSamOpenNamedUser( DomainInfo, UserName, NULL, &UserId, NULL );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlEnsureClientIsNamedUser: %ws: NlSamOpenNamedUser failed 0x%lx\n",
                   UserName,
                   Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    //
    // Impersonate the client while we check him out.
    //

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlEnsureClientIsNamedUser: %ws: RpcImpersonateClient failed 0x%lx\n",
                   UserName,
                   RpcStatus ));
        NetStatus = NetpRpcStatusToApiStatus( RpcStatus );
        goto Cleanup;
    }

    //
    // Compare the username specified with that in
    // the impersonation token to ensure the caller isn't bogus.
    //
    // Do this by opening the token,
    //   querying the token user info,
    //   and ensuring the returned SID is for this user.
    //

    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_QUERY,
                (BOOLEAN) TRUE, // Use the logon service's security context
                                // to open the token
                &TokenHandle );

    if ( !NT_SUCCESS( Status )) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlEnsureClientIsNamedUser: %ws: NtOpenThreadToken failed 0x%lx\n",
                   UserName,
                   Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Get the user's SID for the token.
    //

    Status = NtQueryInformationToken(
                TokenHandle,
                TokenUser,
                &TokenUserInfo,
                0,
                &TokenUserInfoSize );

    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlEnsureClientIsNamedUser: %ws: NtOpenQueryInformationThread failed 0x%lx\n",
                   UserName,
                   Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    TokenUserInfo = NetpMemoryAllocate( TokenUserInfoSize );

    if ( TokenUserInfo == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Status = NtQueryInformationToken(
                TokenHandle,
                TokenUser,
                TokenUserInfo,
                TokenUserInfoSize,
                &TokenUserInfoSize );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlEnsureClientIsNamedUser: %ws: NtOpenQueryInformationThread (again) failed 0x%lx\n",
                   UserName,
                   Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    UserSid = TokenUserInfo->User.Sid;


    //
    // Ensure the last subauthority matches the UserId
    //

    if ( UserId !=
         *RtlSubAuthoritySid( UserSid, (*RtlSubAuthorityCountSid(UserSid))-1 )){

        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlEnsureClientIsNamedUser: %ws: UserId mismatch 0x%lx\n",
                   UserName,
                   UserId ));

        NlpDumpSid( NL_CRITICAL, UserSid );

        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Convert the User's sid to a DomainId and ensure it is our domain Id.
    //

    (*RtlSubAuthorityCountSid(UserSid)) --;
    if ( !RtlEqualSid( (PSID) DomainInfo->DomAccountDomainId, UserSid ) ) {

        NlPrintDom(( NL_CRITICAL, DomainInfo,
                  "NlEnsureClientIsNamedUser: %ws: DomainId mismatch 0x%lx\n",
                   UserName,
                   UserId ));

        NlpDumpSid( NL_CRITICAL, UserSid );
        NlpDumpSid( NL_CRITICAL, (PSID) DomainInfo->DomAccountDomainId );

        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Done
    //

    NetStatus = NERR_Success;
Cleanup:

    //
    // Clean up locally used resources.
    //

    if ( TokenHandle != NULL ) {
        (VOID) NtClose( TokenHandle );
    }

    if ( TokenUserInfo != NULL ) {
        NetpMemoryFree( TokenUserInfo );
    }

    //
    // revert to system, so that we can close
    // the user handle properly.
    //

    (VOID) RpcRevertToSelf();

    return NetStatus;
}
#endif // _DC_NETLOGON


NET_API_STATUS
NetrLogonUasLogon (
    IN LPWSTR ServerName,
    IN LPWSTR UserName,
    IN LPWSTR Workstation,
    OUT PNETLOGON_VALIDATION_UAS_INFO *ValidationInformation
)
/*++

Routine Description:

    Server side of I_NetLogonUasLogon.

    This function is called by the XACT server when processing a
    I_NetWkstaUserLogon XACT SMB.  This feature allows a UAS client to
    logon to a SAM domain controller.

Arguments:

    ServerName -- Server to perform this operation on.  Must be NULL.

    UserName -- Account name of the user logging on.

    Workstation -- The workstation from which the user is logging on.

    ValidationInformation -- Returns the requested validation
        information.


Return Value:

    NERR_SUCCESS if there was no error. Otherwise, the error code is
    returned.


--*/
{
#ifdef _WKSTA_NETLOGON
    return ERROR_NOT_SUPPORTED;
    UNREFERENCED_PARAMETER( ServerName );
    UNREFERENCED_PARAMETER( UserName );
    UNREFERENCED_PARAMETER( Workstation );
    UNREFERENCED_PARAMETER( ValidationInformation );
#endif // _WKSTA_NETLOGON
#ifdef _DC_NETLOGON
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    NETLOGON_INTERACTIVE_INFO LogonInteractive;
    PNETLOGON_VALIDATION_SAM_INFO SamInfo = NULL;


    PNETLOGON_VALIDATION_UAS_INFO usrlog1 = NULL;
    DWORD ValidationSize;
    LPWSTR EndOfVariableData;
    BOOLEAN Authoritative;
    BOOLEAN BadPasswordCountZeroed;

    LARGE_INTEGER TempTime;
    PDOMAIN_INFO DomainInfo = NULL;



    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // This API can only be called locally. (By the XACT server).
    //
    // ??: Modify xactsrv to pass this information along
    if ( ServerName != NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialization
    //

    *ValidationInformation = NULL;

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ServerName );

    if ( DomainInfo == NULL ) {
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }


    //
    // Perform access validation on the caller.
    //

    NetStatus = NetpAccessCheck(
            NlGlobalNetlogonSecurityDescriptor,     // Security descriptor
            NETLOGON_UAS_LOGON_ACCESS,              // Desired access
            &NlGlobalNetlogonInfoMapping );         // Generic mapping

    if ( NetStatus != NERR_Success) {

        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonUasLogon of %ws from %ws failed NetpAccessCheck\n",
                UserName, Workstation));
        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }



    //
    // Ensure the client is actually the named user.
    //
    // The server has already validated the password.
    // The XACT server has already verified that the workstation name is
    // correct.
    //

    NetStatus = NlEnsureClientIsNamedUser( DomainInfo, UserName );

    if ( NetStatus != NERR_Success ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NetrLogonUasLogon of %ws from %ws failed NlEnsureClientIsNamedUser\n",
                 UserName, Workstation));
        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }


    //
    // Validate the user against the local SAM database.
    //

    RtlInitUnicodeString( &LogonInteractive.Identity.LogonDomainName, NULL );
    LogonInteractive.Identity.ParameterControl = 0;
    RtlZeroMemory( &LogonInteractive.Identity.LogonId,
                   sizeof(LogonInteractive.Identity.LogonId) );
    RtlInitUnicodeString( &LogonInteractive.Identity.UserName, UserName );
    RtlInitUnicodeString( &LogonInteractive.Identity.Workstation, Workstation );

    Status = MsvSamValidate( DomainInfo->DomSamAccountDomainHandle,
                             TRUE,
                             NullSecureChannel,     // Skip password check
                             &DomainInfo->DomUnicodeComputerNameString,
                             &DomainInfo->DomUnicodeAccountDomainNameString,
                             DomainInfo->DomAccountDomainId,
                             NetlogonInteractiveInformation,
                             &LogonInteractive,
                             NetlogonValidationSamInfo,
                             (PVOID *)&SamInfo,
                             &Authoritative,
                             &BadPasswordCountZeroed,
                             MSVSAM_SPECIFIED );

    if ( !NT_SUCCESS( Status )) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    //
    // Allocate a return buffer
    //

    ValidationSize = sizeof( NETLOGON_VALIDATION_UAS_INFO ) +
        SamInfo->EffectiveName.Length + sizeof(WCHAR) +
        (wcslen( DomainInfo->DomUncUnicodeComputerName ) +1) * sizeof(WCHAR) +
        DomainInfo->DomUnicodeDomainNameString.Length + sizeof(WCHAR) +
        SamInfo->LogonScript.Length + sizeof(WCHAR);

    ValidationSize = ROUND_UP_COUNT( ValidationSize, ALIGN_WCHAR );

    usrlog1 = MIDL_user_allocate( ValidationSize );

    if ( usrlog1 == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Convert the SAM information to the right format for LM 2.0
    //

    EndOfVariableData = (LPWSTR) (((PCHAR)usrlog1) + ValidationSize);

    if ( !NetpCopyStringToBuffer(
                SamInfo->EffectiveName.Buffer,
                SamInfo->EffectiveName.Length / sizeof(WCHAR),
                (LPBYTE) (usrlog1 + 1),
                &EndOfVariableData,
                &usrlog1->usrlog1_eff_name ) ) {

        NetStatus = NERR_InternalError ;
        goto Cleanup;
    }

    Status = NlGetUserPriv(
                 DomainInfo,
                 SamInfo->GroupCount,
                 (PGROUP_MEMBERSHIP) SamInfo->GroupIds,
                 SamInfo->UserId,
                 &usrlog1->usrlog1_priv,
                 &usrlog1->usrlog1_auth_flags );

    if ( !NT_SUCCESS( Status )) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    usrlog1->usrlog1_num_logons =  0;
    usrlog1->usrlog1_bad_pw_count = SamInfo->BadPasswordCount;

    OLD_TO_NEW_LARGE_INTEGER( SamInfo->LogonTime, TempTime);

    if ( !RtlTimeToSecondsSince1970( &TempTime,
                                     &usrlog1->usrlog1_last_logon) ) {
        usrlog1->usrlog1_last_logon = 0;
    }

    OLD_TO_NEW_LARGE_INTEGER( SamInfo->LogoffTime, TempTime);

    if ( !RtlTimeToSecondsSince1970( &TempTime,
                                     &usrlog1->usrlog1_last_logoff) ) {
        usrlog1->usrlog1_last_logoff = TIMEQ_FOREVER;
    }

    OLD_TO_NEW_LARGE_INTEGER( SamInfo->KickOffTime, TempTime);

    if ( !RtlTimeToSecondsSince1970( &TempTime,
                                     &usrlog1->usrlog1_logoff_time) ) {
        usrlog1->usrlog1_logoff_time = TIMEQ_FOREVER;
    }

    if ( !RtlTimeToSecondsSince1970( &TempTime,
                                     &usrlog1->usrlog1_kickoff_time) ) {
        usrlog1->usrlog1_kickoff_time = TIMEQ_FOREVER;
    }

    OLD_TO_NEW_LARGE_INTEGER( SamInfo->PasswordLastSet, TempTime);

    usrlog1->usrlog1_password_age =
        NetpGetElapsedSeconds( &TempTime );

    OLD_TO_NEW_LARGE_INTEGER( SamInfo->PasswordCanChange, TempTime);

    if ( !RtlTimeToSecondsSince1970( &TempTime,
                                     &usrlog1->usrlog1_pw_can_change) ) {
        usrlog1->usrlog1_pw_can_change = TIMEQ_FOREVER;
    }

    OLD_TO_NEW_LARGE_INTEGER( SamInfo->PasswordMustChange, TempTime);

    if ( !RtlTimeToSecondsSince1970( &TempTime,
                                     &usrlog1->usrlog1_pw_must_change) ) {
        usrlog1->usrlog1_pw_must_change = TIMEQ_FOREVER;
    }


    usrlog1->usrlog1_computer = DomainInfo->DomUncUnicodeComputerName;
    if ( !NetpPackString(
                &usrlog1->usrlog1_computer,
                (LPBYTE) (usrlog1 + 1),
                &EndOfVariableData )) {

        NetStatus = NERR_InternalError ;
        goto Cleanup;
    }

    if ( !NetpCopyStringToBuffer(
                DomainInfo->DomUnicodeDomainNameString.Buffer,
                DomainInfo->DomUnicodeDomainNameString.Length / sizeof(WCHAR),
                (LPBYTE) (usrlog1 + 1),
                &EndOfVariableData,
                &usrlog1->usrlog1_domain ) ) {

        NetStatus = NERR_InternalError ;
        goto Cleanup;
    }

    if ( !NetpCopyStringToBuffer(
                SamInfo->LogonScript.Buffer,
                SamInfo->LogonScript.Length / sizeof(WCHAR),
                (LPBYTE) (usrlog1 + 1),
                &EndOfVariableData,
                &usrlog1->usrlog1_script_path ) ) {

        NetStatus = NERR_InternalError ;
        goto Cleanup;
    }

    NetStatus = NERR_Success;

    //
    // Done
    //

Cleanup:

    //
    // Clean up locally used resources.
    //

    if ( SamInfo != NULL ) {

        //
        // Zero out sensitive data
        //
        RtlSecureZeroMemory( &SamInfo->UserSessionKey, sizeof(SamInfo->UserSessionKey) );
        RtlSecureZeroMemory( &SamInfo->ExpansionRoom, sizeof(SamInfo->ExpansionRoom) );

        MIDL_user_free( SamInfo );
    }

    if ( NetStatus != NERR_Success ) {
        if ( usrlog1 != NULL ) {
            MIDL_user_free( usrlog1 );
            usrlog1 = NULL;
        }
    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    NlPrint((NL_LOGON,
            "%ws: NetrLogonUasLogon of %ws from %ws returns %lu\n",
            DomainInfo == NULL ? L"[Unknown]" : DomainInfo->DomUnicodeDomainName,
            UserName, Workstation, NetStatus ));

    *ValidationInformation = usrlog1;

    return(NetStatus);
#endif // _DC_NETLOGON
}


NET_API_STATUS
NetrLogonUasLogoff (
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR UserName,
    IN LPWSTR Workstation,
    OUT PNETLOGON_LOGOFF_UAS_INFO LogoffInformation
)
/*++

Routine Description:

    This function is called by the XACT server when processing a
    I_NetWkstaUserLogoff XACT SMB.  This feature allows a UAS client to
    logoff from a SAM domain controller.  The request is authenticated,
    the entry is removed for this user from the logon session table
    maintained by the Netlogon service for NetLogonEnum, and logoff
    information is returned to the caller.

    The server portion of I_NetLogonUasLogoff (in the Netlogon service)
    compares the user name and workstation name specified in the
    LogonInformation with the user name and workstation name from the
    impersonation token.  If they don't match, I_NetLogonUasLogoff fails
    indicating the access is denied.

    Group SECURITY_LOCAL is refused access to this function.  Membership
    in SECURITY_LOCAL implies that this call was made locally and not
    through the XACT server.

    The Netlogon service cannot be sure that this function was called by
    the XACT server.  Therefore, the Netlogon service will not simply
    delete the entry from the logon session table.  Rather, the logon
    session table entry will be marked invisible outside of the Netlogon
    service (i.e., it will not be returned by NetLogonEnum) until a valid
    LOGON_WKSTINFO_RESPONSE is received for the entry.  The Netlogon
    service will immediately interrogate the client (as described above
    for LOGON_WKSTINFO_RESPONSE) and temporarily increase the
    interrogation frequency to at least once a minute.  The logon session
    table entry will reappear as soon as a function of interrogation if
    this isn't a true logoff request.

Arguments:

    ServerName -- Reserved. Must be NULL.

    UserName -- Account name of the user logging off.

    Workstation -- The workstation from which the user is logging
        off.

    LogoffInformation -- Returns the requested logoff information.

Return Value:

    The Net status code.

--*/
{
#ifdef _WKSTA_NETLOGON
    return ERROR_NOT_SUPPORTED;
    UNREFERENCED_PARAMETER( ServerName );
    UNREFERENCED_PARAMETER( UserName );
    UNREFERENCED_PARAMETER( Workstation );
    UNREFERENCED_PARAMETER( LogoffInformation );
#endif // _WKSTA_NETLOGON
#ifdef _DC_NETLOGON
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    PDOMAIN_INFO DomainInfo = NULL;
    NETLOGON_INTERACTIVE_INFO LogonInteractive;

    PNETLOGON_LOGOFF_UAS_INFO usrlog1 = NULL;



    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // This API can only be called locally. (By the XACT server).
    //

    if ( ServerName != NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ServerName );

    if ( DomainInfo == NULL ) {
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }



    //
    // Perform access validation on the caller.
    //

    NetStatus = NetpAccessCheck(
            NlGlobalNetlogonSecurityDescriptor, // Security descriptor
            NETLOGON_UAS_LOGOFF_ACCESS,         // Desired access
            &NlGlobalNetlogonInfoMapping );     // Generic mapping

    if ( NetStatus != NERR_Success) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NetrLogonUasLogoff of %ws from %ws failed NetpAccessCheck\n",
                 UserName, Workstation));
        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }



    //
    // Ensure the client is actually the named user.
    //
    // The server has already validated the password.
    // The XACT server has already verified that the workstation name is
    // correct.
    //

#ifdef notdef // Some clients (WFW 3.11) can call this over the null session
    NetStatus = NlEnsureClientIsNamedUser( DomainInfo, UserName );

    if ( NetStatus != NERR_Success ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonUasLogoff of %ws from %ws failed NlEnsureClientIsNamedUser\n",
                UserName, Workstation));
        NetStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }
#endif // notdef



    //
    // Build the LogonInformation to return
    //

    LogoffInformation->Duration = 0;
    LogoffInformation->LogonCount = 0;


    //
    // Update the LastLogoff time in the SAM database.
    //

    RtlInitUnicodeString( &LogonInteractive.Identity.LogonDomainName, NULL );
    LogonInteractive.Identity.ParameterControl = 0;
    RtlZeroMemory( &LogonInteractive.Identity.LogonId,
                   sizeof(LogonInteractive.Identity.LogonId) );
    RtlInitUnicodeString( &LogonInteractive.Identity.UserName, UserName );
    RtlInitUnicodeString( &LogonInteractive.Identity.Workstation, Workstation );

    Status = MsvSamLogoff(
                DomainInfo->DomSamAccountDomainHandle,
                NetlogonInteractiveInformation,
                &LogonInteractive );

    if (!NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Cleanup
    //

Cleanup:

    //
    // Clean up locally used resources.
    //

    NlPrint((NL_LOGON,
             "%ws: NetrLogonUasLogoff of %ws from %ws returns %lu\n",
             DomainInfo == NULL ? L"[Unknown]" : DomainInfo->DomUnicodeDomainName,
             UserName, Workstation, NetStatus));

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }
    return NetStatus;
#endif // _DC_NETLOGON
}


VOID
NlpDecryptLogonInformation (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN OUT LPBYTE LogonInformation,
    IN PSESSION_INFO SessionInfo
)
/*++

Routine Description:

    This function decrypts the sensitive information in the LogonInformation
    structure.  The decryption is done in place.

Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.

    SessionInfo -- The session key to encrypt with and negotiate flags


Return Value:

    None.

--*/
{

    //
    // Only the interactive and service logon information is encrypted.
    //

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonInteractiveTransitiveInformation:
    case NetlogonServiceInformation:
    case NetlogonServiceTransitiveInformation:
    {

        PNETLOGON_INTERACTIVE_INFO LogonInteractive;

        LogonInteractive =
            (PNETLOGON_INTERACTIVE_INFO) LogonInformation;


        //
        // If both sides support RC4 encryption,
        //  decrypt both the LM OWF and NT OWF passwords using RC4.
        //

        if ( SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_RC4_ENCRYPTION ) {

            NlDecryptRC4( &LogonInteractive->LmOwfPassword,
                          sizeof(LogonInteractive->LmOwfPassword),
                          SessionInfo );

            NlDecryptRC4( &LogonInteractive->NtOwfPassword,
                          sizeof(LogonInteractive->NtOwfPassword),
                          SessionInfo );


        //
        // If the other side is running NT 3.1,
        //  use the slower DES based encryption.
        //

        } else {

            NTSTATUS Status;
            ENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword;
            ENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword;

            //
            // Decrypt the LM_OWF password.
            //

            NlAssert( ENCRYPTED_LM_OWF_PASSWORD_LENGTH ==
                    LM_OWF_PASSWORD_LENGTH );
            NlAssert(LM_OWF_PASSWORD_LENGTH == sizeof(SessionInfo->SessionKey));
            EncryptedLmOwfPassword =
                * ((PENCRYPTED_LM_OWF_PASSWORD) &LogonInteractive->LmOwfPassword);

            Status = RtlDecryptLmOwfPwdWithLmOwfPwd(
                        &EncryptedLmOwfPassword,
                        (PLM_OWF_PASSWORD) &SessionInfo->SessionKey,
                        &LogonInteractive->LmOwfPassword );
            NlAssert( NT_SUCCESS(Status) );

            //
            // Decrypt the NT_OWF password.
            //

            NlAssert( ENCRYPTED_NT_OWF_PASSWORD_LENGTH ==
                    NT_OWF_PASSWORD_LENGTH );
            NlAssert(NT_OWF_PASSWORD_LENGTH == sizeof(SessionInfo->SessionKey));
            EncryptedNtOwfPassword =
                * ((PENCRYPTED_NT_OWF_PASSWORD) &LogonInteractive->NtOwfPassword);

            Status = RtlDecryptNtOwfPwdWithNtOwfPwd(
                        &EncryptedNtOwfPassword,
                        (PNT_OWF_PASSWORD) &SessionInfo->SessionKey,
                        &LogonInteractive->NtOwfPassword );
            NlAssert( NT_SUCCESS(Status) );
        }
        break;
    }

    case NetlogonGenericInformation:
    {
        PNETLOGON_GENERIC_INFO LogonGeneric;

        LogonGeneric =
            (PNETLOGON_GENERIC_INFO) LogonInformation;


        NlAssert( SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_RC4_ENCRYPTION );

        if ( LogonGeneric->LogonData != NULL ) {
            NlDecryptRC4( LogonGeneric->LogonData,
                          LogonGeneric->DataLength,
                          SessionInfo );
        }
        break;
    }

    }

    return;
}


VOID
NlpEncryptLogonInformation (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN OUT LPBYTE LogonInformation,
    IN PSESSION_INFO SessionInfo
)
/*++

Routine Description:

    This function encrypts the sensitive information in the LogonInformation
    structure.  The encryption is done in place.

Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.

    SessionInfo -- The session key to encrypt with and negotiate flags


Return Value:

    None.

--*/
{
    NTSTATUS Status;


    //
    // Only the interactive and service logon information is encrypted.
    //

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonInteractiveTransitiveInformation:
    case NetlogonServiceInformation:
    case NetlogonServiceTransitiveInformation:
    {

        PNETLOGON_INTERACTIVE_INFO LogonInteractive;

        LogonInteractive =
            (PNETLOGON_INTERACTIVE_INFO) LogonInformation;


        //
        // If both sides support RC4 encryption, use it.
        //  encrypt both the LM OWF and NT OWF passwords using RC4.
        //

        if ( SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_RC4_ENCRYPTION ) {

            NlEncryptRC4( &LogonInteractive->LmOwfPassword,
                          sizeof(LogonInteractive->LmOwfPassword),
                          SessionInfo );

            NlEncryptRC4( &LogonInteractive->NtOwfPassword,
                          sizeof(LogonInteractive->NtOwfPassword),
                          SessionInfo );


        //
        // If the other side is running NT 3.1,
        //  use the slower DES based encryption.
        //

        } else {
            ENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword;
            ENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword;

            //
            // Encrypt the LM_OWF password.
            //

            NlAssert( ENCRYPTED_LM_OWF_PASSWORD_LENGTH ==
                    LM_OWF_PASSWORD_LENGTH );
            NlAssert(LM_OWF_PASSWORD_LENGTH == sizeof(SessionInfo->SessionKey));

            Status = RtlEncryptLmOwfPwdWithLmOwfPwd(
                        &LogonInteractive->LmOwfPassword,
                        (PLM_OWF_PASSWORD) &SessionInfo->SessionKey,
                        &EncryptedLmOwfPassword );

            NlAssert( NT_SUCCESS(Status) );

            *((PENCRYPTED_LM_OWF_PASSWORD) &LogonInteractive->LmOwfPassword) =
                EncryptedLmOwfPassword;

            //
            // Encrypt the NT_OWF password.
            //

            NlAssert( ENCRYPTED_NT_OWF_PASSWORD_LENGTH ==
                    NT_OWF_PASSWORD_LENGTH );
            NlAssert(NT_OWF_PASSWORD_LENGTH == sizeof(SessionInfo->SessionKey));

            Status = RtlEncryptNtOwfPwdWithNtOwfPwd(
                        &LogonInteractive->NtOwfPassword,
                        (PNT_OWF_PASSWORD) &SessionInfo->SessionKey,
                        &EncryptedNtOwfPassword );

            NlAssert( NT_SUCCESS(Status) );

            *((PENCRYPTED_NT_OWF_PASSWORD) &LogonInteractive->NtOwfPassword) =
                EncryptedNtOwfPassword;
        }
        break;
    }

    case NetlogonGenericInformation:
    {
        PNETLOGON_GENERIC_INFO LogonGeneric;

        LogonGeneric =
            (PNETLOGON_GENERIC_INFO) LogonInformation;


        //
        // If both sides support RC4 encryption, use it.
        //  encrypt both the LM OWF and NT OWF passwords using RC4.
        //

        NlAssert( SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_RC4_ENCRYPTION );

        NlEncryptRC4( LogonGeneric->LogonData,
                      LogonGeneric->DataLength,
                      SessionInfo );

        break;
    }
    }

    return;

}



VOID
NlpDecryptValidationInformation (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT LPBYTE ValidationInformation,
    IN PSESSION_INFO SessionInfo
)
/*++

Routine Description:

    This function decrypts the sensitive information in the
    ValidationInformation structure.  The decryption is done in place.

Arguments:

    LogonLevel -- Specifies the Logon level used to obtain
        ValidationInformation.

    ValidationLevel -- Specifies the level of information given in
        ValidationInformation.

    ValidationInformation -- Specifies the description for the user
        logging on.

    SessionInfo -- The session key to encrypt with and negotiated flags.


Return Value:

    None.

--*/
{
    PNETLOGON_VALIDATION_SAM_INFO ValidationInfo;
    PNETLOGON_VALIDATION_GENERIC_INFO GenericInfo;

    //
    // Only network logons and generic contain information which is sensitive.
    //
    // NetlogonValidationSamInfo4 isn't encrypted on purpose. NlEncryptRC4 has the problem
    // described in its header.  Couple that with the fact that the entire session is
    // now encrypted.
    //

    if ( (LogonLevel != NetlogonNetworkInformation) &&
         (LogonLevel != NetlogonNetworkTransitiveInformation) &&
         (LogonLevel != NetlogonGenericInformation) ) {
        return;
    }

    if ( ValidationLevel == NetlogonValidationSamInfo ||
         ValidationLevel == NetlogonValidationSamInfo2 ) {

        ValidationInfo = (PNETLOGON_VALIDATION_SAM_INFO) ValidationInformation;



        //
        // If we're suppossed to use RC4,
        //  Decrypt both the NT and LM session keys using RC4.
        //

        if ( SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_RC4_ENCRYPTION ) {

            NlDecryptRC4( &ValidationInfo->UserSessionKey,
                          sizeof(ValidationInfo->UserSessionKey),
                          SessionInfo );

            NlDecryptRC4( &ValidationInfo->ExpansionRoom[SAMINFO_LM_SESSION_KEY],
                          SAMINFO_LM_SESSION_KEY_SIZE,
                          SessionInfo );

        //
        // If the other side is running NT 3.1,
        //  be compatible.
        //
        } else {

            NTSTATUS Status;
            CLEAR_BLOCK ClearBlock;
            DWORD i;
            LPBYTE DataBuffer =
                (LPBYTE) &ValidationInfo->ExpansionRoom[SAMINFO_LM_SESSION_KEY];

            //
            // Decrypt the LmSessionKey
            //

            NlAssert( CLEAR_BLOCK_LENGTH == CYPHER_BLOCK_LENGTH );
            NlAssert( (SAMINFO_LM_SESSION_KEY_SIZE % CLEAR_BLOCK_LENGTH) == 0  );

            //
            // Loop decrypting a block at a time
            //

            for (i=0; i<SAMINFO_LM_SESSION_KEY_SIZE/CLEAR_BLOCK_LENGTH; i++ ) {
                Status = RtlDecryptBlock(
                            (PCYPHER_BLOCK)DataBuffer,
                            (PBLOCK_KEY)&SessionInfo->SessionKey,
                            &ClearBlock );
                NlAssert( NT_SUCCESS( Status ) );

                //
                // Copy the clear text back into the original buffer.
                //

                RtlCopyMemory( DataBuffer, &ClearBlock, CLEAR_BLOCK_LENGTH );
                DataBuffer += CLEAR_BLOCK_LENGTH;
            }

        }

    } else if ( ValidationLevel == NetlogonValidationGenericInfo ||
                ValidationLevel == NetlogonValidationGenericInfo2 ) {

        //
        // Decrypt all the data in the generic info
        //

        GenericInfo = (PNETLOGON_VALIDATION_GENERIC_INFO) ValidationInformation;

        if (GenericInfo->DataLength != 0) {
            NlDecryptRC4( GenericInfo->ValidationData,
                          GenericInfo->DataLength,
                          SessionInfo );

        }

    }

    return;
}


VOID
NlpEncryptValidationInformation (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT LPBYTE ValidationInformation,
    IN PSESSION_INFO SessionInfo
)
/*++

Routine Description:

    This function encrypts the sensitive information in the
    ValidationInformation structure.  The encryption is done in place.

Arguments:

    LogonLevel -- Specifies the Logon level used to obtain
        ValidationInformation.

    ValidationLevel -- Specifies the level of information given in
        ValidationInformation.

    ValidationInformation -- Specifies the description for the user
        logging on.

    SessionInfo -- The session key to encrypt with and negotiated flags.


Return Value:

    None.

--*/
{
    PNETLOGON_VALIDATION_SAM_INFO ValidationInfo;
    PNETLOGON_VALIDATION_GENERIC_INFO GenericInfo;


    //
    // Only network logons and generic contain information which is sensitive.
    //
    // NetlogonValidationSamInfo4 isn't encrypted on purpose. NlEncryptRC4 has the problem
    // described in its header.  Couple that with the fact that the entire session is
    // now encrypted.
    //

    if ( (LogonLevel != NetlogonNetworkInformation) &&
         (LogonLevel != NetlogonNetworkTransitiveInformation) &&
         (LogonLevel != NetlogonGenericInformation) ) {
        return;
    }


    if ( ValidationLevel == NetlogonValidationSamInfo ||
         ValidationLevel == NetlogonValidationSamInfo2 ) {
        ValidationInfo = (PNETLOGON_VALIDATION_SAM_INFO) ValidationInformation;


        //
        // If we're suppossed to use RC4,
        //  Encrypt both the NT and LM session keys using RC4.
        //

        if ( SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_RC4_ENCRYPTION ) {

            NlEncryptRC4( &ValidationInfo->UserSessionKey,
                          sizeof(ValidationInfo->UserSessionKey),
                          SessionInfo );

            NlEncryptRC4( &ValidationInfo->ExpansionRoom[SAMINFO_LM_SESSION_KEY],
                          SAMINFO_LM_SESSION_KEY_SIZE,
                          SessionInfo );

        //
        // If the other side is running NT 3.1,
        //  be compatible.
        //
        } else {

            NTSTATUS Status;
            CLEAR_BLOCK ClearBlock;
            DWORD i;
            LPBYTE DataBuffer =
                    (LPBYTE) &ValidationInfo->ExpansionRoom[SAMINFO_LM_SESSION_KEY];


            //
            // Encrypt the LmSessionKey
            //
            // Loop decrypting a block at a time
            //

            for (i=0; i<SAMINFO_LM_SESSION_KEY_SIZE/CLEAR_BLOCK_LENGTH; i++ ) {

                //
                // Copy the clear text onto the stack
                //

                RtlCopyMemory( &ClearBlock, DataBuffer, CLEAR_BLOCK_LENGTH );

                Status = RtlEncryptBlock(
                            &ClearBlock,
                            (PBLOCK_KEY)&SessionInfo->SessionKey,
                            (PCYPHER_BLOCK)DataBuffer );

                NlAssert( NT_SUCCESS( Status ) );

                DataBuffer += CLEAR_BLOCK_LENGTH;
            }

        }

    } else if ( ValidationLevel == NetlogonValidationGenericInfo ||
                ValidationLevel == NetlogonValidationGenericInfo2 ) {
        //
        // Encrypt all the data in the generic info
        //

        GenericInfo = (PNETLOGON_VALIDATION_GENERIC_INFO) ValidationInformation;

        if (GenericInfo->DataLength != 0) {
            NlEncryptRC4( GenericInfo->ValidationData,
                          GenericInfo->DataLength,
                          SessionInfo );

        }

    }
    return;

}




NTSTATUS
NlpUserValidateHigher (
    IN PCLIENT_SESSION ClientSession,
    IN BOOLEAN DoingIndirectTrust,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags
)
/*++

Routine Description:

    This function sends a user validation request to a higher authority.

Arguments:

    ClientSession -- Secure channel to send this request over.  The Client
        Session should be referenced.

    DoingIndirectTrust -- If TRUE, the Client Session merely represents the
        next closer hop and is not the final destination.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.  Has already been validated.

    LogonInformation -- Specifies the description for the user
        logging on.

    ValidationLevel -- Specifies the level of information returned in
        ValidationInformation.  Must be NetlogonValidationSamInfo,
        NetlogonValidationSamInfo2 or NetlogonValidationSamInfo4

    ValidationInformation -- Returns the requested validation
        information.  This buffer must be freed using MIDL_user_free.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    ExtraFlags -- Accepts and returns a DWORD to the caller.
        The DWORD contains NL_EXFLAGS_* values.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_LOGON_SERVERS: cannot connect to the higher authority.

    STATUS_NO_TRUST_LSA_SECRET:
    STATUS_TRUSTED_DOMAIN_FAILURE:
    STATUS_TRUSTED_RELATIONSHIP_FAILURE:
            can't authenticate with higer authority

    Otherwise, the error code is returned.


--*/
{
    NTSTATUS Status;
    NETLOGON_AUTHENTICATOR OurAuthenticator;
    NETLOGON_AUTHENTICATOR ReturnAuthenticator;
    BOOLEAN FirstTry = TRUE;
    BOOLEAN TryForDs = TRUE;
    BOOLEAN AmWriter = FALSE;
    BOOLEAN DoingGeneric;
    SESSION_INFO SessionInfo;
    NETLOGON_VALIDATION_INFO_CLASS RemoteValidationLevel;
    PCLIENT_API OrigClientApi = NULL;
    PCLIENT_API ClientApi;
    BOOLEAN RpcFailed;
    ULONG MaxExtraFlags;

    //
    // Allocate a slot for doing a concurrent API call
    //
    // Do this before grabbing the write lock since the threads
    // using the slots need to grab the write lock to free the slot.
    //
    // We may end up not using this slot if concurrent API isn't supported.
    // But in that case, this isn't a valuable resource so allocating one
    // doesn't hurt.
    //

    NlAssert( ClientSession->CsReferenceCount > 0 );
    OrigClientApi = NlAllocateClientApi(
                            ClientSession,
                            WRITER_WAIT_PERIOD );

    if ( OrigClientApi == NULL ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                 "NlpUserValidateHigher: Can't allocate Client API slot.\n" ));
        *Authoritative = TRUE;
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    //
    // Mark us as a writer of the ClientSession
    //

    if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                 "NlpUserValidateHigher: Can't become writer of client session.\n" ));
        *Authoritative = TRUE;
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    AmWriter = TRUE;

    //
    // Determine if we're doing a generic logon.
    //

    DoingGeneric = (LogonLevel == NetlogonGenericInformation ||
                    ValidationLevel == NetlogonValidationGenericInfo ||
                    ValidationLevel == NetlogonValidationGenericInfo2);

    //
    // If we don't currently have a session set up to the higher authority,
    //  set one up.
    //
    // For generic passthrough or indirect trust, ask for an NT 5 DC.
    // For Interactive logon, ask for a close DC.
    //

FirstTryFailed:
    Status = NlEnsureSessionAuthenticated(
                    ClientSession,
                    (( DoingGeneric || DoingIndirectTrust || *ExtraFlags != 0 ) ? CS_DISCOVERY_HAS_DS : 0) |
                        ((LogonLevel == NetlogonInteractiveInformation || LogonLevel == NetlogonInteractiveTransitiveInformation )? CS_DISCOVERY_IS_CLOSE : 0) );

    if ( !NT_SUCCESS(Status) ) {

        switch(Status) {

        case STATUS_NO_TRUST_LSA_SECRET:
        case STATUS_NO_TRUST_SAM_ACCOUNT:
        case STATUS_ACCESS_DENIED:
        case STATUS_NO_LOGON_SERVERS:
            break;

        default:
            if ( !NlpIsNtStatusResourceError( Status )) {
                Status = STATUS_NO_LOGON_SERVERS;
            }

            break;
        }

        NlAssert( !NT_SUCCESS(Status) || Status == STATUS_SUCCESS );
        NlAssert( !NT_SUCCESS(Status) || *ValidationInformation != NULL );
        *Authoritative = TRUE;
        goto Cleanup;
    }

    SessionInfo.SessionKey = ClientSession->CsSessionKey;
    SessionInfo.NegotiatedFlags = ClientSession->CsNegotiatedFlags;



    //
    // Ensure the DC supports the ExtraFlags we're passing it.
    //

    if ( SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_CROSS_FOREST ) {
        MaxExtraFlags = NL_EXFLAGS_EXPEDITE_TO_ROOT | NL_EXFLAGS_CROSS_FOREST_HOP;
    } else {
        MaxExtraFlags = 0;
    }

    if ( (*ExtraFlags & ~MaxExtraFlags) != 0 ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                 "NlpUserValidateHigher: Can't pass these ExtraFlags to old DC: %lx %lx\n",
                 *ExtraFlags,
                 MaxExtraFlags ));
        Status = STATUS_NO_LOGON_SERVERS;
        *Authoritative = TRUE;
        goto Cleanup;
    }





    //
    // If the target is an NT 4.0 (or lower) DC,
    //  check to see if an NT 5.0 DC would be better.
    //

    if ((SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_GENERIC_PASSTHRU) == 0 &&
        ( DoingGeneric || DoingIndirectTrust ) ) {

        //
        // Simply fail if only an NT 4 DC is available.
        //
        *Authoritative = TRUE;
        if ( DoingGeneric ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                     "NlpUserValidateHigher: Can't do generic passthru to NT 4 DC.\n" ));
            Status = STATUS_INVALID_INFO_CLASS;
        } else {
            NlPrintCs((NL_CRITICAL, ClientSession,
                     "NlpUserValidateHigher: Can't do transitive trust to NT 4 DC.\n" ));
            Status = STATUS_NO_LOGON_SERVERS;
        }
        goto Cleanup;
    }

    //
    // Convert the validation level to one the remote DC understands.
    //

    if ( !DoingGeneric ) {

        //
        //  DCs that don't understand extra SIDs require NetlogonValidationSamInfo
        //
        if (!(SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_MULTIPLE_SIDS)) {
            RemoteValidationLevel = NetlogonValidationSamInfo;


        //
        //  DCs that don't understand cross forest trust don't understand NetlogonValidationSamInfo4
        //
        // Info4 doesn't have sensitive information encrytped (since NlEncryptRC4 is
        //  buggy and there are many more field that need encryption).  So, avoid info4
        //  unless the entire traffic is encrypted.
        //

        } else if ( (SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_CROSS_FOREST) == 0 ||
                    (SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_AUTH_RPC) == 0 ||
                    !NlGlobalParameters.SealSecureChannel ) {

            RemoteValidationLevel = NetlogonValidationSamInfo2;

        } else {
            RemoteValidationLevel = ValidationLevel;
        }
    } else {
        RemoteValidationLevel = ValidationLevel;
    }

    //
    // If this DC supports concurrent RPC calls,
    //  and we're signing or sealing,
    //  then we're OK to do concurrent RPC.
    //
    // Otherwise, use the shared RPC slot.
    //

    if ( (SessionInfo.NegotiatedFlags &
            (NETLOGON_SUPPORTS_CONCURRENT_RPC|NETLOGON_SUPPORTS_AUTH_RPC)) ==
            (NETLOGON_SUPPORTS_CONCURRENT_RPC|NETLOGON_SUPPORTS_AUTH_RPC)) {

        ClientApi = OrigClientApi;
    } else {
        ClientApi = &ClientSession->CsClientApi[0];
    }


    //
    // Build the Authenticator for this request on the secure channel
    //
    // Concurrent RPC uses a signed and sealed secure channel so it doesn't need
    // an authenticator.
    //

    if ( !UseConcurrentRpc( ClientSession, ClientApi ) ) {
        NlBuildAuthenticator(
             &ClientSession->CsAuthenticationSeed,
             &ClientSession->CsSessionKey,
             &OurAuthenticator );
    }


    //
    // Make the request across the secure channel.
    //

    NlpEncryptLogonInformation( LogonLevel, LogonInformation, &SessionInfo );

    RpcFailed = FALSE;
    NL_API_START_EX( Status, ClientSession, TRUE, ClientApi ) {

        //
        // If the called DC doesn't support the new transitive opcodes,
        //  map the opcodes back to do the best we can.
        //

        RpcFailed = FALSE;
        if ( (SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_TRANSITIVE) == 0 ) {

            switch (LogonLevel ) {
            case NetlogonInteractiveTransitiveInformation:
                LogonLevel = NetlogonInteractiveInformation; break;
            case NetlogonServiceTransitiveInformation:
                LogonLevel = NetlogonServiceInformation; break;
            case NetlogonNetworkTransitiveInformation:
                LogonLevel = NetlogonNetworkInformation; break;
            }
        }

        NlAssert( ClientSession->CsUncServerName != NULL );
        if ( UseConcurrentRpc( ClientSession, ClientApi ) ) {
            LPWSTR UncServerName;

            //
            // Drop the write lock to allow other concurrent callers to proceed.
            //

            NlResetWriterClientSession( ClientSession );
            AmWriter = FALSE;


            //
            // Since we have no locks locked,
            //  grab the name of the DC to remote to.
            //

            Status = NlCaptureServerClientSession (
                        ClientSession,
                        &UncServerName,
                        NULL );

            if ( !NT_SUCCESS(Status) ) {
                *Authoritative = TRUE;
                if ( !NlpIsNtStatusResourceError( Status )) {
                    Status = STATUS_NO_LOGON_SERVERS;
                }

            } else {

                //
                // Do the RPC call with no locks locked.
                //
                Status = I_NetLogonSamLogonEx(
                            ClientApi->CaRpcHandle,
                            UncServerName,
                            ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                            LogonLevel,
                            LogonInformation,
                            RemoteValidationLevel,
                            ValidationInformation,
                            Authoritative,
                            ExtraFlags,
                            &RpcFailed );

                NetApiBufferFree( UncServerName );

                if ( !NT_SUCCESS(Status) ) {
                    NlPrintRpcDebug( "I_NetLogonSamLogonEx", Status );
                }
            }

            //
            // Become a writer again
            //

            if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
                NlPrintCs((NL_CRITICAL, ClientSession,
                         "NlpUserValidateHigher: Can't become writer (again) of client session.\n" ));

                // Don't leak validation information
                if ( *ValidationInformation ) {
                    MIDL_user_free( *ValidationInformation );
                    *ValidationInformation = NULL;
                }
                *Authoritative = TRUE;
                Status = STATUS_NO_LOGON_SERVERS;
            } else {
                AmWriter = TRUE;
            }



        //
        // Do non-concurrent RPC
        //
        } else {

            //
            // If the DC supports the new 'WithFlags' API,
            //  use it.
            //
            if ( SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_CROSS_FOREST ) {

                Status = I_NetLogonSamLogonWithFlags(
                            ClientSession->CsUncServerName,
                            ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                            &OurAuthenticator,
                            &ReturnAuthenticator,
                            LogonLevel,
                            LogonInformation,
                            RemoteValidationLevel,
                            ValidationInformation,
                            Authoritative,
                            ExtraFlags );

                if ( !NT_SUCCESS(Status) ) {
                    NlPrintRpcDebug( "I_NetLogonSamLogonWithFlags", Status );
                }

            //
            // Otherwise use the old API.
            //
            } else {

                Status = I_NetLogonSamLogon(
                            ClientSession->CsUncServerName,
                            ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                            &OurAuthenticator,
                            &ReturnAuthenticator,
                            LogonLevel,
                            LogonInformation,
                            RemoteValidationLevel,
                            ValidationInformation,
                            Authoritative );

                if ( !NT_SUCCESS(Status) ) {
                    NlPrintRpcDebug( "I_NetLogonSamLogon", Status );
                }
            }
        }
        NlAssert( !NT_SUCCESS(Status) || Status == STATUS_SUCCESS );
        NlAssert( !NT_SUCCESS(Status) || *ValidationInformation != NULL );

    // NOTE: This call may drop the secure channel behind our back
    } NL_API_ELSE_EX( Status, ClientSession, TRUE, AmWriter, ClientApi ) {
    } NL_API_END;

    NlpDecryptLogonInformation( LogonLevel, LogonInformation, &SessionInfo );

    if ( NT_SUCCESS(Status) ) {
        NlAssert( *ValidationInformation != NULL );
    }

    //
    // If we couldn't become writer again after the remote call,
    //  early out to avoid use the ClientSession.
    //

    if ( !AmWriter ) {
        goto Cleanup;
    }


    //
    // Verify authenticator of the server on the other side and update our seed.
    //
    // If the server denied access or the server's authenticator is wrong,
    //      Force a re-authentication.
    //
    //

    NlPrint((NL_CHALLENGE_RES,"NlpUserValidateHigher: Seed = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &ClientSession->CsAuthenticationSeed, sizeof(ClientSession->CsAuthenticationSeed) );

    NlPrint((NL_CHALLENGE_RES,"NlpUserValidateHigher: SessionKey = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &ClientSession->CsSessionKey, sizeof(ClientSession->CsSessionKey) );

    if ( !UseConcurrentRpc( ClientSession, ClientApi ) ) {
        NlPrint((NL_CHALLENGE_RES,"NlpUserValidateHigher: Return Authenticator = " ));
        NlpDumpBuffer(NL_CHALLENGE_RES, &ReturnAuthenticator.Credential, sizeof(ReturnAuthenticator.Credential) );
    }

    if ( NlpDidDcFail( Status ) ||
         RpcFailed ||
         (!UseConcurrentRpc( ClientSession, ClientApi ) &&
          !NlUpdateSeed(
            &ClientSession->CsAuthenticationSeed,
            &ReturnAuthenticator.Credential,
            &ClientSession->CsSessionKey) ) ) {

        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlpUserValidateHigher: denying access after status: 0x%lx %lx\n",
                    Status,
                    RpcFailed ));

        //
        // Preserve any status indicating a communication error.
        //
        // If another thread already dropped the secure channel,
        //  don't do it again now.
        //

        if ( NT_SUCCESS(Status) ) {
            Status = STATUS_ACCESS_DENIED;
        }
        if ( ClientApi->CaSessionCount == ClientSession->CsSessionCount ) {
            NlSetStatusClientSession( ClientSession, Status );
        }

        //
        // Perhaps the netlogon service on the server has just restarted.
        //  Try just once to set up a session to the server again.
        //
        if ( FirstTry ) {
            FirstTry = FALSE;
            goto FirstTryFailed;
        }

        *Authoritative = TRUE;
        NlAssert( !NT_SUCCESS(Status) || Status == STATUS_SUCCESS );
        NlAssert( !NT_SUCCESS(Status) || *ValidationInformation != NULL );
        goto Cleanup;
    }

    //
    // Clean up after a successful call to higher authority.
    //

    if ( NT_SUCCESS(Status) ) {


        //
        // The server encrypted the validation information before sending it
        //  over the wire.  Decrypt it.
        //

        NlpDecryptValidationInformation (
                LogonLevel,
                RemoteValidationLevel,
                *ValidationInformation,
                &SessionInfo );


        //
        // If the caller wants a newer info level than we got from the remote side,
        //  convert it to VALIDATION_SAM_INFO4 (which is a superset of what our caller wants).
        //

        if ( RemoteValidationLevel != ValidationLevel) {

            if ( (RemoteValidationLevel == NetlogonValidationSamInfo2  ||
                  RemoteValidationLevel == NetlogonValidationSamInfo ) &&
                 (ValidationLevel == NetlogonValidationSamInfo2 ||
                  ValidationLevel == NetlogonValidationSamInfo4) ) {

                NTSTATUS TempStatus;

                TempStatus = NlpAddResourceGroupsToSamInfo (
                                    RemoteValidationLevel,
                                    (PNETLOGON_VALIDATION_SAM_INFO4 *) ValidationInformation,
                                    NULL );        // No resource groups to add

                if ( !NT_SUCCESS( TempStatus )) {
                    *ValidationInformation = NULL;
                    *Authoritative = FALSE;
                    Status = TempStatus;
                    goto Cleanup;
                }

            } else {
                NlAssert(!"Bad validation level");
            }
        }

        //
        // Ensure the returned SID and domain name are correct.
        // Filter out SIDs for quarantined domains.
        //

        if ((ValidationLevel == NetlogonValidationSamInfo4) ||
            (ValidationLevel == NetlogonValidationSamInfo2) ||
            (ValidationLevel == NetlogonValidationSamInfo)) {

            PNETLOGON_VALIDATION_SAM_INFO ValidationInfo;

            ValidationInfo =
                (PNETLOGON_VALIDATION_SAM_INFO) *ValidationInformation;

            //
            // If we validated on a trusted domain,
            //  the higher authority must have returned his own domain name,
            //  and must have returned his own domain sid.
            //

            if ( ClientSession->CsSecureChannelType == TrustedDomainSecureChannel ||
                 ClientSession->CsSecureChannelType == TrustedDnsDomainSecureChannel ||
                 ClientSession->CsSecureChannelType == WorkstationSecureChannel ) {

                //
                // If we validated on our primary domain,
                //  only verify the domain sid if the primary domain itself validated
                //  the logon.
                //

                if ( (ClientSession->CsNetbiosDomainName.Buffer != NULL &&
                      RtlEqualDomainName( &ValidationInfo->LogonDomainName,
                                          &ClientSession->CsNetbiosDomainName )) &&
                     !RtlEqualSid( ValidationInfo->LogonDomainId,
                                   ClientSession->CsDomainId ) ) {

                    Status = STATUS_DOMAIN_TRUST_INCONSISTENT;
                    MIDL_user_free( *ValidationInformation );
                    *ValidationInformation = NULL;
                    *Authoritative = TRUE;
                    NlAssert( !NT_SUCCESS(Status) || Status == STATUS_SUCCESS );
                    NlAssert( !NT_SUCCESS(Status) || *ValidationInformation != NULL );
                }
            }

            //
            // Do interdomain trust specific processing with the validation data
            //

            if ( IsDomainSecureChannelType(ClientSession->CsSecureChannelType) &&
                 *ValidationInformation != NULL ) {

                //
                // First, if this is Other Organization trust type,
                //  add the OtherOrg SID to the extra SIDs in validation info.
                //  This SID is used later in the check to determine whether the specified
                //  user from Other Org can logon to the specified workstation.
                //
                if ( (ClientSession->CsTrustAttributes & TRUST_ATTRIBUTE_CROSS_ORGANIZATION) &&
                     (ValidationLevel == NetlogonValidationSamInfo2 ||
                      ValidationLevel == NetlogonValidationSamInfo4) ) {

                    NTSTATUS TmpStatus = NlpAddOtherOrganizationSid(
                                            ValidationLevel,
                                            (PNETLOGON_VALIDATION_SAM_INFO4 *) ValidationInformation );

                    if ( !NT_SUCCESS(TmpStatus) ) {
                        *ValidationInformation = NULL;
                        *Authoritative = TRUE;
                        Status = TmpStatus;
                        goto Cleanup;
                    }
                }

                //
                // Filter out SIDs for quarantined domains and interforest domains as needed
                //
                LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
                Status = LsaIFilterSids( ClientSession->CsDnsDomainName.Length ?
                                            &ClientSession->CsDnsDomainName :
                                            NULL,
                                         TRUST_DIRECTION_OUTBOUND,
                                         (ClientSession->CsFlags & CS_NT5_DOMAIN_TRUST) ?
                                            TRUST_TYPE_UPLEVEL : TRUST_TYPE_DOWNLEVEL,
                                         ClientSession->CsTrustAttributes,
                                         ClientSession->CsDomainId,
                                         ValidationLevel,
                                         *ValidationInformation,
                                         NULL,
                                         NULL,
                                         NULL );
                UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

            } else if ( ClientSession->CsSecureChannelType == WorkstationSecureChannel &&
                        *ValidationInformation != NULL ) {

                //
                // This is the "workstation talking to DC" mode
                // Filter SIDs in the "member workstation trust boundary" mode
                // (passing NULL trust SID)
                //

                Status = LsaIFilterSids(
                             NULL,
                             0,
                             0,
                             0,
                             NULL,
                             ValidationLevel,
                             *ValidationInformation,
                             NULL,
                             NULL,
                             NULL
                             );
            }

            if ( !NT_SUCCESS(Status) ) {
                NlAssert( !"[NETLOGON] LsaIFilterSids failed" );
                NlPrint(( NL_CRITICAL, "NlpUserValidateHigher: LsaIFilterSids failed 0x%lx\n", Status ));
                MIDL_user_free( *ValidationInformation );
                *ValidationInformation = NULL;
                *Authoritative = TRUE;
            }
        }
    }

Cleanup:

    NlAssert( !NT_SUCCESS(Status) || Status == STATUS_SUCCESS );
    NlAssert( !NT_SUCCESS(Status) || *ValidationInformation != NULL );

    //
    // We are no longer a writer of the client session.
    //
    if ( AmWriter ) {
        NlResetWriterClientSession( ClientSession );
    }

    //
    // Free the concurrent API slot
    //

    if ( OrigClientApi ) {
        NlFreeClientApi( ClientSession, OrigClientApi );
    }

    return Status;
}


NTSTATUS
NlpUserLogoffHigher (
    IN PCLIENT_SESSION ClientSession,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation
)
/*++

Routine Description:

    This function sends a user validation request to a higher authority.

Arguments:

    ClientSession -- Secure channel to send this request over.  The Client
        Session should be referenced.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.  Has already been validated.

    LogonInformation -- Specifies the description for the user
        logging on.

Return Value:

    STATUS_SUCCESS: if there was no error.
    STATUS_NO_LOGON_SERVERS: cannot connect to the higher authority.

    STATUS_NO_TRUST_LSA_SECRET:
    STATUS_TRUSTED_DOMAIN_FAILURE:
    STATUS_TRUSTED_RELATIONSHIP_FAILURE:
            can't authenticate with higer authority

    Otherwise, the error code is returned.


--*/
{
    NTSTATUS Status;
    NETLOGON_AUTHENTICATOR OurAuthenticator;
    NETLOGON_AUTHENTICATOR ReturnAuthenticator;
    BOOLEAN FirstTry = TRUE;

    //
    // Mark us as a writer of the ClientSession
    //

    NlAssert( ClientSession->CsReferenceCount > 0 );
    if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                 "NlpUserLogoffHigher: Can't become writer of client session.\n"));
        return STATUS_NO_LOGON_SERVERS;
    }

    //
    // If we don't currently have a session set up to the higher authority,
    //  set one up.
    //

FirstTryFailed:
    Status = NlEnsureSessionAuthenticated( ClientSession, 0 );

    if ( !NT_SUCCESS(Status) ) {

        switch(Status) {

        case STATUS_NO_TRUST_LSA_SECRET:
        case STATUS_NO_TRUST_SAM_ACCOUNT:
        case STATUS_ACCESS_DENIED:
        case STATUS_NO_LOGON_SERVERS:
            break;

        default:
            if ( !NlpIsNtStatusResourceError( Status )) {
                Status = STATUS_NO_LOGON_SERVERS;
            }
            break;
        }

        goto Cleanup;
    }

    //
    // Build the Authenticator for this request on the secure channel
    //

    NlBuildAuthenticator(
         &ClientSession->CsAuthenticationSeed,
         &ClientSession->CsSessionKey,
         &OurAuthenticator );

    //
    // Make the request across the secure channel.
    //

    NL_API_START( Status, ClientSession, TRUE ) {

        NlAssert( ClientSession->CsUncServerName != NULL );
        Status = I_NetLogonSamLogoff(
                    ClientSession->CsUncServerName,
                    ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                    &OurAuthenticator,
                    &ReturnAuthenticator,
                    LogonLevel,
                    LogonInformation );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintRpcDebug( "I_NetLogonSamLogoff", Status );
        }

    // NOTE: This call may drop the secure channel behind our back
    } NL_API_ELSE( Status, ClientSession, TRUE ) {
    } NL_API_END;



    //
    // Verify authenticator of the server on the other side and update our seed.
    //
    // If the server denied access or the server's authenticator is wrong,
    //      Force a re-authentication.
    //
    //

    if ( NlpDidDcFail( Status ) ||
         !NlUpdateSeed(
            &ClientSession->CsAuthenticationSeed,
            &ReturnAuthenticator.Credential,
            &ClientSession->CsSessionKey) ) {

        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlpUserLogoffHigher: denying access after status: 0x%lx\n",
                    Status ));

        //
        // Preserve any status indicating a communication error.
        //

        if ( NT_SUCCESS(Status) ) {
            Status = STATUS_ACCESS_DENIED;
        }
        NlSetStatusClientSession( ClientSession, Status );

        //
        // Perhaps the netlogon service in the server has just restarted.
        //  Try just once to set up a session to the server again.
        //
        if ( FirstTry ) {
            FirstTry = FALSE;
            goto FirstTryFailed;
        }
        goto Cleanup;
    }

Cleanup:

    //
    // We are no longer a writer of the client session.
    //
    NlResetWriterClientSession( ClientSession );
    return Status;

}

#ifdef _DC_NETLOGON
VOID
NlScavengeOldFailedLogons(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    This function removes all expired failed user logon entries
    from the list of expired logons for the specified domain.

Arguments:

    DomainInfo - Domain this BDC is a member of.

Return Value:

    None

--*/

{
    PLIST_ENTRY UserLogonEntry = NULL;
    PNL_FAILED_USER_LOGON UserLogon = NULL;
    ULONG CurrentTime;
    ULONG ElapsedTime;

    CurrentTime = GetTickCount();

    LOCK_TRUST_LIST( DomainInfo );

    UserLogonEntry = DomainInfo->DomFailedUserLogonList.Flink;
    while ( UserLogonEntry != &DomainInfo->DomFailedUserLogonList ) {
        UserLogon = CONTAINING_RECORD( UserLogonEntry, NL_FAILED_USER_LOGON, FuNext );
        UserLogonEntry = UserLogonEntry->Flink;

        //
        // If time has wrapped, account for it
        //
        if ( CurrentTime >= UserLogon->FuLastTimeSentToPdc ) {
            ElapsedTime = CurrentTime - UserLogon->FuLastTimeSentToPdc;
        } else {
            ElapsedTime = (0xFFFFFFFF - UserLogon->FuLastTimeSentToPdc) + CurrentTime;
        }

        //
        // If this entry hasn't been touched in 3 update timeouts, remove it
        //
        if ( ElapsedTime >= (3 * NL_FAILED_USER_FORWARD_LOGON_TIMEOUT) ) {
            RemoveEntryList( &UserLogon->FuNext );
            LocalFree( UserLogon );
        }
    }

    UNLOCK_TRUST_LIST( DomainInfo );
}

VOID
NlpRemoveBadPasswordCacheEntry(
    IN PDOMAIN_INFO DomainInfo,
    IN LPBYTE LogonInformation
    )
/*++

Routine Description:

    This function removes a negative cache entry for the specified user.
    The cache is maintained on BDC for user logons that failed with a
    bad password status.

Arguments:

    DomainInfo - Domain this BDC is a member of.

    LogonInformation -- Specifies the description for the user
        logging on.

Return Value:

    None

--*/
{
    PLIST_ENTRY FailedUserEntry = NULL;
    PNL_FAILED_USER_LOGON FailedUser = NULL;
    LPWSTR UserName = NULL;
    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

    //
    // If this isn't a BDC,
    //  There's nothing to do here.
    //

    if ( DomainInfo->DomRole != RoleBackup ) {
        return;
    }

    //
    // Get the user  name from the logon info
    //  UserName might be a SamAccountName or a UPN
    //

    UserName = LocalAlloc( 0, LogonInfo->UserName.Length + sizeof(WCHAR) );
    if ( UserName == NULL ) {
        return;
    }

    RtlCopyMemory( UserName, LogonInfo->UserName.Buffer, LogonInfo->UserName.Length );
    UserName[ LogonInfo->UserName.Length/sizeof(WCHAR) ] = UNICODE_NULL;

    //
    // Loop through the cache searching for this user entry
    //

    LOCK_TRUST_LIST( DomainInfo );
    for ( FailedUserEntry = DomainInfo->DomFailedUserLogonList.Flink;
          FailedUserEntry != &DomainInfo->DomFailedUserLogonList;
          FailedUserEntry = FailedUserEntry->Flink ) {

        FailedUser = CONTAINING_RECORD( FailedUserEntry, NL_FAILED_USER_LOGON, FuNext );

        if ( _wcsicmp(UserName, FailedUser->FuUserName) == 0 ) {
            RemoveEntryList( &FailedUser->FuNext );
            LocalFree( FailedUser );
            break;
        }
    }
    UNLOCK_TRUST_LIST( DomainInfo );

    LocalFree( UserName );
    return;
}


NTSTATUS
NlpUserValidateOnPdc (
    IN PDOMAIN_INFO DomainInfo,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN BOOL UseNegativeCache,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative
)
/*++

Routine Description:

    This function normally sends a user validation request to the PDC in this
    same domain.  Currently, this is called from a BDC after getting a password
    mismatch.  The theory is that the password might be right on the PDC but
    it merely hasn't replicated yet.

    However, once the number of logon failures for the given user reaches a
    certain threshold, we refrain from this forwarding for some period of time
    to avoid PDC overload. We then retry the forwarding once every so often.
    This scheme ensures that we accomodate a certain number of mistyped user
    passwords and we then periodically retry to authenticate the user on the PDC.

    No validation request will be sent if the registry value of AvoidPdcOnWan has
    been set to TRUE and PDC and BDC are on different sites. In this case the
    function returns with STATUS_NO_SUCH_USER error.


Arguments:

    DomainInfo - Domain this BDC is a member of.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.  Has already been validated.

    LogonInformation -- Specifies the description for the user
        logging on.

    ValidationLevel -- Specifies the level of information returned in
        ValidationInformation.  Must be NetlogonValidationSamInfo,
        NetlogonValidationSamInfo2 or NetlogonValidationSamInfo4

    UseNegativeCache -- If TRUE, the negative cache of failed user
        logons forwarded to the PDC will be used to decide whether
        it's time to retry to forward this logon.

    ValidationInformation -- Returns the requested validation
        information.  This buffer must be freed using MIDL_user_free.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.


Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_LOGON_SERVERS: cannot connect to the higher authority.

    STATUS_NO_SUCH_USER: won't validate a user against info on PDC
            on a remote site provided the registry value of AvoidPdcOnWan
            is TRUE.

    STATUS_NO_TRUST_LSA_SECRET:
    STATUS_TRUSTED_DOMAIN_FAILURE:
    STATUS_TRUSTED_RELATIONSHIP_FAILURE:
            can't authenticate with higer authority

    Otherwise, the error code is returned.


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCLIENT_SESSION ClientSession = NULL;
    BOOLEAN IsSameSite;
    DWORD ExtraFlags = 0;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;
    PSAMPR_DOMAIN_INFO_BUFFER DomainLockout = NULL;
    PLIST_ENTRY FailedUserEntry;

    BOOL UpdateCache = FALSE;

    PNL_FAILED_USER_LOGON FailedUser = NULL;
    LPWSTR UserName = NULL;
    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

    //
    // If this isn't a BDC,
    //  There's nothing to do here.
    //

    if ( DomainInfo->DomRole != RoleBackup ) {
        return STATUS_INVALID_DOMAIN_ROLE;
    }

    //
    // If the registry value of AvoidPdcOnWan is TRUE and PDC is on
    // a remote site, do not send anything to PDC and return with
    // STATUS_NO_SUCH_USER error.
    //

    if ( NlGlobalParameters.AvoidPdcOnWan ) {

        //
        // Determine whether the PDC is on the same site
        //

        Status = SamISameSite( &IsSameSite );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom(( NL_CRITICAL,  DomainInfo,
                         "NlpUserValidateOnPdc: Cannot SamISameSite.\n" ));
            goto Cleanup;
        }

        if ( !IsSameSite ) {
            NlPrintDom((NL_LOGON, DomainInfo,
                    "NlpUserValidateOnPdc: Ignored a user validation on a PDC in remote site.\n"));
            *Authoritative = FALSE;
            Status = STATUS_NO_SUCH_USER;
            goto Cleanup;
        } else {
            NlPrintDom((NL_LOGON, DomainInfo,
                    "NlpUserValidateOnPdc: BDC and PDC are in the same site.\n"));
        }
    }

    //
    // See if it's time to send this user logon to PDC.
    //

    if ( UseNegativeCache ) {
        BOOL AvoidSend = FALSE;

        UserName = LocalAlloc( 0, LogonInfo->UserName.Length + sizeof(WCHAR) );
        if ( UserName == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        RtlCopyMemory( UserName, LogonInfo->UserName.Buffer, LogonInfo->UserName.Length );
        UserName[ LogonInfo->UserName.Length/sizeof(WCHAR) ] = UNICODE_NULL;

        LOCK_TRUST_LIST( DomainInfo );
        for ( FailedUserEntry = DomainInfo->DomFailedUserLogonList.Flink;
              FailedUserEntry != &DomainInfo->DomFailedUserLogonList;
              FailedUserEntry = FailedUserEntry->Flink ) {

            FailedUser = CONTAINING_RECORD( FailedUserEntry, NL_FAILED_USER_LOGON, FuNext );

            //
            // If this is the entry for this user, check if it's time to forward
            // this logon to the PDC. In any case, remove this entry from the list
            // and then insert it at the front so that the list stays sorted by the
            // entry access time.
            //
            if ( NlNameCompare(UserName, FailedUser->FuUserName, NAMETYPE_USER) == 0 ) {
                ULONG TimeElapsed = NetpDcElapsedTime( FailedUser->FuLastTimeSentToPdc );

                //
                // If we have exceeded the threshold for failed forwarded logon count
                //  and we recently sent this failed logon to the PDC,
                //  avoid forwarding this logon to the PDC
                //
                if ( FailedUser->FuBadLogonCount > NL_FAILED_USER_MAX_LOGON_COUNT &&
                     TimeElapsed < NL_FAILED_USER_FORWARD_LOGON_TIMEOUT ) {
                    AvoidSend = TRUE;
                }

                RemoveEntryList( &FailedUser->FuNext );
                break;
            }

            FailedUser = NULL;
        }

        //
        // Insert the entry at the front of the list
        //
        if ( FailedUser != NULL ) {
            InsertHeadList( &DomainInfo->DomFailedUserLogonList, &FailedUser->FuNext );
        }
        UNLOCK_TRUST_LIST( DomainInfo );

        //
        // If this user logon failed recently, avoid sending it to PDC
        //
        if ( AvoidSend ) {
            NlPrintDom(( NL_LOGON, DomainInfo,
                         "Avoid send to PDC since user %ws failed recently\n",
                         UserName ));
            Status = STATUS_NO_SUCH_USER;
            goto Cleanup;
        }
    }


    //
    // We are sending this logon to the PDC ....
    //

    ClientSession = NlRefDomClientSession( DomainInfo );

    if ( ClientSession == NULL ) {
        Status = STATUS_INVALID_DOMAIN_ROLE;
        goto Cleanup;
    }

    //
    // The normal pass-thru authentication logic handles this quite nicely.
    //

    Status = NlpUserValidateHigher(
                ClientSession,
                FALSE,
                LogonLevel,
                LogonInformation,
                ValidationLevel,
                ValidationInformation,
                Authoritative,
                &ExtraFlags );

#if NETLOGONDBG
    if ( NT_SUCCESS(Status) ) {

        IF_NL_DEBUG( LOGON ) {
            PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;

            LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO)
                &((PNETLOGON_LEVEL)LogonInformation)->LogonInteractive;

            NlPrintDom((NL_LOGON, DomainInfo,
                    "SamLogon: %s logon of %wZ\\%wZ from %wZ successfully handled on PDC.\n",
                    NlpLogonTypeToText( LogonLevel ),
                    &LogonInfo->LogonDomainName,
                    &LogonInfo->UserName,
                    &LogonInfo->Workstation ));
        }
    }
#endif // NETLOGONDBG

    //
    // If the PDC returned a bad password status,
    //  we should icncrease bad pasword count on
    //  the negative cache entry for this user.
    //
    // We have to special case the lockout policy.
    //  If it is enabled, we should continue forwarding to
    //  the PDC until the account becomes locked out there
    //  so that we keep the right "master" lockout count.
    //

    if ( UseNegativeCache && BAD_PASSWORD(Status) ) {

        //
        // If the PDC says the account is locked out,
        //  no need to check wether the lockout policy is enabled
        //

        if ( Status == STATUS_ACCOUNT_LOCKED_OUT ) {
            UpdateCache = TRUE;

        //
        // Otherwise, check wether the lockout is enabled
        //

        } else {
            NTSTATUS TmpStatus = SamrQueryInformationDomain(
                          DomainInfo->DomSamAccountDomainHandle,
                          DomainLockoutInformation,
                          &DomainLockout );

            if ( !NT_SUCCESS(TmpStatus) ) {
                NlPrintDom(( NL_CRITICAL, DomainInfo,
                             "NlpUserValidateOnPdc: SamrQueryInformationDomain failed: 0x%lx\n",
                             TmpStatus ));
            } else if ( ((DOMAIN_LOCKOUT_INFORMATION *)DomainLockout)->LockoutThreshold == 0 ) {

                //
                // OK lockout is not enabled, so we should update the cache
                //
                UpdateCache = TRUE;
            }
        }
    }

    //
    // Increase the bad password count for this user
    //

    FailedUser = NULL;

    if ( UpdateCache ) {
        ULONG FailedUserCount = 0;

        LOCK_TRUST_LIST( DomainInfo );

        for ( FailedUserEntry = DomainInfo->DomFailedUserLogonList.Flink;
              FailedUserEntry != &DomainInfo->DomFailedUserLogonList;
              FailedUserEntry = FailedUserEntry->Flink ) {

            FailedUser = CONTAINING_RECORD( FailedUserEntry, NL_FAILED_USER_LOGON, FuNext );

            //
            // If this is the entry for this user, remove it from the list.
            //  If it stays on the list, we will re-insert it at the front
            //  so that the list stays sorted by the entry access time.
            //
            if ( NlNameCompare(UserName, FailedUser->FuUserName, NAMETYPE_USER) == 0 ) {
                RemoveEntryList( &FailedUser->FuNext );
                break;
            }

            FailedUserCount ++;
            FailedUser = NULL;
        }

        //
        // If there is no entry for this user, allocate one
        //

        if ( FailedUser == NULL ) {
            ULONG UserNameSize;

            UserNameSize = (wcslen(UserName) + 1) * sizeof(WCHAR);
            FailedUser = LocalAlloc( LMEM_ZEROINIT, sizeof(NL_FAILED_USER_LOGON) +
                                          UserNameSize );
            if ( FailedUser == NULL ) {
                UNLOCK_TRUST_LIST( DomainInfo );

                //
                // Do not destroy Status.
                //  Return whatever NlpUserValidateHigher returned.
                //
                goto Cleanup;
            }

            //
            // Fill it in
            //
            RtlCopyMemory( &FailedUser->FuUserName, UserName, UserNameSize );

            //
            // If we have too many entries,
            //  remove the least recently used one and free it.
            //
            if ( FailedUserCount >= NL_MAX_FAILED_USER_LOGONS ) {
                PLIST_ENTRY LastEntry = RemoveTailList( &DomainInfo->DomFailedUserLogonList );
                LocalFree( CONTAINING_RECORD(LastEntry, NL_FAILED_USER_LOGON, FuNext) );
            }
        }

        //
        // Remember when this user logon was sent to PDC last time
        //

        FailedUser->FuLastTimeSentToPdc = GetTickCount();

        //
        // Increment the bad logon count for this user
        //

        FailedUser->FuBadLogonCount ++;

        //
        // Insert the entry at the front of the list
        //

        InsertHeadList( &DomainInfo->DomFailedUserLogonList, &FailedUser->FuNext );

        UNLOCK_TRUST_LIST( DomainInfo );
    }

Cleanup:

    if ( ClientSession != NULL ) {
        NlUnrefClientSession( ClientSession );
    }

    if ( UserName != NULL ) {
        LocalFree( UserName );
    }

    if ( DomainLockout != NULL ) {
        SamIFree_SAMPR_DOMAIN_INFO_BUFFER( DomainLockout,
                                           DomainLockoutInformation );
    }

    return Status;

}




NTSTATUS
NlpResetBadPwdCountOnPdc(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING LogonUser
    )
/*++

Routine Description:

    This function zeros the BadPasswordCount field for the specified user
    on the PDC through NetLogon Secure Channel.

Arguments:

    DomainInfo - Domain this BDC is a member of.

    LogonUse -- The user whose BadPasswordCount is to be zeroed.

Return Value:

    NTSTATUS code .
    it may fail with STATUS_UNKNOWN_REVISION, which means the PDC doesn't
    know how to handle the new OP code, in this case, we should fail back
    to the old fashion.

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    SAMPR_HANDLE    UserHandle = 0;
    LPWSTR          pUserNameStr = NULL;

    //
    // If this isn't a BDC,
    // There's nothing to do here.
    //

    if ( DomainInfo->DomRole != RoleBackup ) {
        return STATUS_INVALID_DOMAIN_ROLE;
    }

    //
    // Allocate the user name string
    //
    pUserNameStr = LocalAlloc( 0, LogonUser->Length + sizeof(WCHAR) );
    if (NULL == pUserNameStr)
    {
        return( STATUS_NO_MEMORY );
    }

    RtlCopyMemory( pUserNameStr, LogonUser->Buffer, LogonUser->Length );
    pUserNameStr[ LogonUser->Length/sizeof(WCHAR) ] = L'\0';

    //
    // Get the user's handle to the local SAM database
    //
    NtStatus = NlSamOpenNamedUser( DomainInfo,
                                   pUserNameStr,
                                   &UserHandle,
                                   NULL,
                                   NULL
                                   );
    //
    // Reset the bad password count on PDC
    //
    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SamIResetBadPwdCountOnPdc(UserHandle);
    }

    if ( NULL != pUserNameStr) {
        LocalFree( pUserNameStr );
    }

    if ( 0 != UserHandle ) {
        SamrCloseHandle( &UserHandle );
    }

    return( NtStatus );

}


VOID
NlpZeroBadPasswordCountOnPdc (
    IN PDOMAIN_INFO DomainInfo,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation
)
/*++

Routine Description:

    This function zeros the BadPasswordCount field for the specified user
    on the PDC.

Arguments:

    DomainInfo - Domain this BDC is a member of.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.  Has already been validated.

    LogonInformation -- Specifies the description for the user
        logging on.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    BOOLEAN Authoritative;
    LPBYTE ValidationInformation = NULL;

    //
    // If this isn't a BDC,
    //  There's nothing to do here.
    //

    if ( DomainInfo->DomRole != RoleBackup ) {
        return;
    }

    //
    // We only call this function on a BDC and if the BDC has just zeroed
    // the BadPasswordCount because of successful logon.
    // First, try to zero bad pwd count directly through NetLogon
    // Secure Channel, if it fails with UNKNOWN_REVISION, which means
    // PDC doesn't know how to handle the new OP code, will try to
    // do the logon over again on the PDC, thus that bad pwd count get
    // zero'ed.
    //

    Status = NlpResetBadPwdCountOnPdc(
                    DomainInfo,
                    &((PNETLOGON_LOGON_IDENTITY_INFO)LogonInformation)->UserName
                    );

    if (!NT_SUCCESS(Status) &&
        (STATUS_UNKNOWN_REVISION == Status) )
    {
        Status = NlpUserValidateOnPdc (
                        DomainInfo,
                        LogonLevel,
                        LogonInformation,
                        NetlogonValidationSamInfo,
                        FALSE,   // avoid negative cache of failed user logons
                        &ValidationInformation,
                        &Authoritative );

        if ( NT_SUCCESS(Status) ) {
            MIDL_user_free( ValidationInformation );
        }
    }
}
#endif // _DC_NETLOGON

NTSTATUS
NlpZeroBadPasswordCountLocally (
    IN PDOMAIN_INFO DomainInfo,
    PUNICODE_STRING LogonUser
)
/*++

Routine Description:

    This function zeros the BadPasswordCount field for the specified user
    on this BDC.

Arguments:

    DomainInfo - Domain this BDC is a member of.

    LogonUser -- The user whose BadPasswordCount is to be zeroed.
        This parameter may be a SamAccountName or a UPN

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_HANDLE UserHandle = 0;
    SAMPR_USER_INFO_BUFFER UserInfo;
    PUSER_INTERNAL6_INFORMATION LocalUserInfo = NULL;
    SID_AND_ATTRIBUTES_LIST LocalMembership = {0};

    //
    // If this isn't a BDC,
    //  There's nothing to do here.
    //

    if ( DomainInfo->DomRole != RoleBackup ) {
        return STATUS_INVALID_DOMAIN_ROLE;
    }


    //
    // Get the user's handle to the local SAM database
    //

    Status = SamIGetUserLogonInformation2(
                  DomainInfo->DomSamAccountDomainHandle,
                  SAM_NO_MEMBERSHIPS |  // Don't need group memberships
                    SAM_OPEN_BY_UPN_OR_ACCOUNTNAME, // Next parameter might be a UPN
                  LogonUser,
                  0,                    // No regular fields
                  0,                    // no extended fields
                  &LocalUserInfo,
                  &LocalMembership,
                  &UserHandle );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint(( NL_CRITICAL,
                  "NlpZeroBadPasswordCountLocally: SamIGetUserLogonInformation2 failed 0x%lx",
                  Status ));
        goto Cleanup;
    }

    //
    // Prepare the user info
    //

    RtlZeroMemory(&(UserInfo.Internal2), sizeof(USER_INTERNAL2_INFORMATION));

    UserInfo.Internal2.StatisticsToApply |= USER_LOGON_STAT_BAD_PWD_COUNT;

    //
    // Indicate that the authentication succeed at the PDC
    //  (while the logon may have failed)
    //

    UserInfo.Internal2.StatisticsToApply |= USER_LOGON_PDC_RETRY_SUCCESS;

    //
    // Reset the bad password count
    //

    Status = SamrSetInformationUser( UserHandle,
                                     UserInternal2Information,
                                     &UserInfo);

    if ( !NT_SUCCESS(Status) ) {
        NlPrint(( NL_CRITICAL,
                  "NlpZeroBadPasswordCountLocally: SamrSetInformationUser failed 0x%lx",
                  Status ));
        goto Cleanup;
    }

Cleanup:
    if ( LocalUserInfo != NULL ) {
        SamIFree_UserInternal6Information( LocalUserInfo );
    }

    SamIFreeSidAndAttributesList( &LocalMembership );

    if ( UserHandle != 0 ) {
        SamrCloseHandle(&UserHandle);
    }

    return Status;
}

#ifdef ROGUE_DC

#pragma message( "COMPILING A ROGUE DC!!!" )
#pragma message( "MUST NOT SHIP THIS BUILD!!!" )

#undef MAX_SID_LEN
#define MAX_SID_LEN (sizeof(SID) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)

HKEY NlGlobalRogueKey;

NTSTATUS
NlpBuildRogueValidationInfo(
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT PNETLOGON_VALIDATION_SAM_INFO4 * UserInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNETLOGON_VALIDATION_SAM_INFO ValidationInfo;
    PNETLOGON_VALIDATION_SAM_INFO2 ValidationInfo2;
    PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo4;

    //
    // Substitution data
    //

    PSID LogonDomainId = NULL;
    PSID ResourceGroupDomainSid = NULL;
    PGROUP_MEMBERSHIP GroupIds = NULL;
    PGROUP_MEMBERSHIP ResourceGroupIds = NULL;
    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids = NULL;
    BYTE FullUserSidBuffer[MAX_SID_LEN];
    SID * FullUserSid = ( SID * )FullUserSidBuffer;
    CHAR * FullUserSidText = NULL;
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG SidCount = 0;
    ULONG GroupCount = 0;
    ULONG ResourceGroupCount = 0;

    DWORD dwType;
    DWORD cbData = 0;
    PCHAR Buffer;
    PCHAR Value = NULL;

    BOOL InfoChanged = FALSE;

    //
    // Marshaling variables
    //

    ULONG Index, GroupIndex;
    ULONG Length;
    ULONG TotalNumberOfSids = 0;
    PNETLOGON_VALIDATION_SAM_INFO4 SamInfo4 = NULL;
    PBYTE Where;
    ULONG SidLength;

    //
    // Reject unrecognized validation levels
    //

    if ( ValidationLevel != NetlogonValidationSamInfo &&
         ValidationLevel != NetlogonValidationSamInfo2 &&
         ValidationLevel != NetlogonValidationSamInfo4 )
    {
        return STATUS_INVALID_PARAMETER;
    }

    if ( UserInfo == NULL )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Optimization: if the rogue key is not present, there's nothing for us to do
    //

    if ( NlGlobalRogueKey == NULL )
    {
        return STATUS_SUCCESS;
    }

    ValidationInfo = ( PNETLOGON_VALIDATION_SAM_INFO )( *UserInfo );
    ValidationInfo2 = ( PNETLOGON_VALIDATION_SAM_INFO2 )( *UserInfo );
    ValidationInfo4 = ( PNETLOGON_VALIDATION_SAM_INFO4 )( *UserInfo );

    UserId = ValidationInfo->UserId;
    PrimaryGroupId = ValidationInfo->PrimaryGroupId;

    //
    // Construct the text form of the full user's SID (logon domain ID + user ID)
    //

    NlAssert( sizeof( FullUserSidBuffer ) >= MAX_SID_LEN );

    RtlCopySid(
        sizeof( FullUserSidBuffer ),
        FullUserSid,
        ValidationInfo->LogonDomainId
        );

    FullUserSid->SubAuthority[FullUserSid->SubAuthorityCount] = ValidationInfo->UserId;
    FullUserSid->SubAuthorityCount += 1;

    if ( FALSE == ConvertSidToStringSidA(
                      FullUserSid,
                      &FullUserSidText ))
    {
        NlPrint((NL_CRITICAL, "ROGUE: Unable to convert user's SID\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Now look in the registry for the SID matching the validation info
    //

    if ( ERROR_SUCCESS != RegQueryValueExA(
                              NlGlobalRogueKey,
                              FullUserSidText,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData ) ||
         dwType != REG_MULTI_SZ ||
         cbData <= 1 )
    {
        NlPrint((NL_CRITICAL, "ROGUE: No substitution info available for %s\n", FullUserSidText));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    Value = ( PCHAR )HeapAlloc(
                         GetProcessHeap(),
                         0,
                         cbData
                         );

    if ( Value == NULL )
    {
        NlPrint((NL_CRITICAL, "ROGUE: Out of memory allocating substitution buffer\n", FullUserSidText));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    if ( ERROR_SUCCESS != RegQueryValueExA(
                              NlGlobalRogueKey,
                              FullUserSidText,
                              NULL,
                              &dwType,
                              (PBYTE)Value,
                              &cbData ) ||
         dwType != REG_MULTI_SZ ||
         cbData <= 1 )
    {
        NlPrint((NL_CRITICAL, "ROGUE: Error reading from registry\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    NlPrint((NL_CRITICAL, "ROGUE: Substituting the validation info for %s\n", FullUserSidText));

    Buffer = Value;

    //
    // Read the input file one line at a time
    //

    while ( *Buffer != '\0' )
    {
        switch( Buffer[0] )
        {
        case 'l':
        case 'L': // logon domain ID

            if ( LogonDomainId != NULL )
            {
                NlPrint((NL_CRITICAL, "ROGUE: Logon domain ID specified more than once - only first one kept\n"));
                break;
            }

            NlPrint((NL_CRITICAL, "ROGUE: Substituting logon domain ID by %s\n", &Buffer[1]));

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &LogonDomainId ))
            {
                NlPrint((NL_CRITICAL, "ROGUE: Unable to convert SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            if ( LogonDomainId == NULL )
            {
                NlPrint((NL_CRITICAL, "ROGUE: Out of memory allocating LogonDomainId\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            InfoChanged = TRUE;
            break;

        case 'd':
        case 'D': // resource group domain SID

            if ( ResourceGroupDomainSid != NULL )
            {
                NlPrint((NL_CRITICAL, "ROGUE: Resource group domain SID specified more than once - only first one kept\n"));
                break;
            }

            NlPrint((NL_CRITICAL, "ROGUE: Substituting resource group domain SID by %s\n", &Buffer[1]));

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &ResourceGroupDomainSid ))
            {
                NlPrint((NL_CRITICAL, "ROGUE: Unable to convert SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            if ( ResourceGroupDomainSid == NULL )
            {
                NlPrint((NL_CRITICAL, "ROGUE: Out of memory allocating ResourceGroupDomainSid\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            InfoChanged = TRUE;
            break;

        case 'p':
        case 'P': // primary group ID

            NlPrint((NL_CRITICAL, "ROGUE: Substituting primary group ID by %s\n", &Buffer[1]));

            PrimaryGroupId = atoi(&Buffer[1]);
            InfoChanged = TRUE;

            break;

        case 'u':
        case 'U': // User ID

            NlPrint((NL_CRITICAL, "ROGUE: Substituting user ID by %s\n", &Buffer[1]));

            UserId = atoi(&Buffer[1]);
            InfoChanged = TRUE;

            break;

        case 'e':
        case 'E': // Extra SID
            {
            PNETLOGON_SID_AND_ATTRIBUTES ExtraSidsT;

            if ( ValidationLevel == NetlogonValidationSamInfo )
            {
                NlPrint((NL_CRITICAL, "ROGUE: Extra SIDs skipped; not supported for this validation level\n" ));
                break;
            }

            NlPrint((NL_CRITICAL, "ROGUE: Adding an ExtraSid: %s\n", &Buffer[1]));

            if ( ExtraSids == NULL )
            {
                ExtraSidsT = ( PNETLOGON_SID_AND_ATTRIBUTES )HeapAlloc(
                                 GetProcessHeap(),
                                 0,
                                 sizeof( NETLOGON_SID_AND_ATTRIBUTES )
                                 );
            }
            else
            {
                ExtraSidsT = ( PNETLOGON_SID_AND_ATTRIBUTES )HeapReAlloc(
                                 GetProcessHeap(),
                                 0,
                                 ExtraSids,
                                 ( SidCount + 1 ) * sizeof( NETLOGON_SID_AND_ATTRIBUTES )
                                 );
            }

            if ( ExtraSidsT == NULL )
            {
                NlPrint((NL_CRITICAL, "ROGUE: Out of memory allocating ExtraSids\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Read the actual SID
            //

            ExtraSids = ExtraSidsT;

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &ExtraSids[SidCount].Sid ))
            {
                NlPrint((NL_CRITICAL, "ROGUE: Unable to convert SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            if ( ExtraSids[SidCount].Sid == NULL )
            {
                NlPrint((NL_CRITICAL, "ROGUE: Out of memory allocating an extra SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            ExtraSids[SidCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;

            SidCount += 1;
            InfoChanged = TRUE;
            }
            break;

        case 'g':
        case 'G': // Group ID
            {
            PGROUP_MEMBERSHIP GroupIdsT;
            NlPrint((NL_CRITICAL, "ROGUE: Adding a GroupId: %s\n", &Buffer[1]));

            if ( GroupIds == NULL )
            {
                GroupIdsT = ( PGROUP_MEMBERSHIP )HeapAlloc(
                                GetProcessHeap(),
                                0,
                                sizeof( GROUP_MEMBERSHIP )
                                );
            }
            else
            {
                GroupIdsT = ( PGROUP_MEMBERSHIP )HeapReAlloc(
                                GetProcessHeap(),
                                0,
                                GroupIds,
                                ( GroupCount + 1 ) * sizeof( GROUP_MEMBERSHIP )
                                );
            }

            if ( GroupIdsT == NULL )
            {
                NlPrint((NL_CRITICAL, "ROGUE: Out of memory allocating Group IDs\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Read the actual ID
            //

            GroupIds = GroupIdsT;
            GroupIds[GroupCount].RelativeId = atoi(&Buffer[1]);
            GroupIds[GroupCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;
            GroupCount += 1;
            InfoChanged = TRUE;
            }
            break;

        case 'r':
        case 'R': // Resource groups
            {
            PGROUP_MEMBERSHIP ResourceGroupIdsT;
            NlPrint((NL_CRITICAL, "ROGUE: Adding a ResourceGroupId: %s\n", &Buffer[1]));

            if ( ResourceGroupIds == NULL )
            {
                ResourceGroupIdsT = ( PGROUP_MEMBERSHIP )HeapAlloc(
                                        GetProcessHeap(),
                                        0,
                                        sizeof( GROUP_MEMBERSHIP )
                                        );
            }
            else
            {
                ResourceGroupIdsT = ( PGROUP_MEMBERSHIP )HeapReAlloc(
                                        GetProcessHeap(),
                                        0,
                                        ResourceGroupIds,
                                        ( ResourceGroupCount + 1 ) * sizeof( GROUP_MEMBERSHIP )
                                        );
            }

            if ( ResourceGroupIdsT == NULL )
            {
                NlPrint((NL_CRITICAL, "ROGUE: Out of memory allocating Resource Group IDs\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Read the actual ID
            //

            ResourceGroupIds[ResourceGroupCount].RelativeId = atoi(&Buffer[1]);
            ResourceGroupIds[ResourceGroupCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;
            ResourceGroupCount += 1;
            InfoChanged = TRUE;
            }
            break;

        default:   // unrecognized

            NlPrint((NL_CRITICAL, "ROGUE: Entry \'%c\' unrecognized\n", Buffer[0]));
            break;
        }

        //
        // Move to the next line
        //

        while (*Buffer++ != '\0');
    }

    if ( !InfoChanged )
    {
        NlPrint((NL_CRITICAL, "ROGUE: Nothing to substitute for %s\n", FullUserSidText));
        Status = STATUS_SUCCESS;
        goto Error;
    }

    //
    // Ok, now that we have our substitution info, build the new validation struct
    //

    //
    // Calculate the size of the new structure
    //

    Length = sizeof( NETLOGON_VALIDATION_SAM_INFO4 );

    if ( GroupCount > 0 )
    {
        Length += GroupCount * sizeof( GROUP_MEMBERSHIP );
    }
    else
    {
        Length += ValidationInfo->GroupCount * sizeof( GROUP_MEMBERSHIP );
    }

    if ( LogonDomainId != NULL )
    {
        Length += RtlLengthSid( LogonDomainId );
    }
    else
    {
        Length += RtlLengthSid( ValidationInfo->LogonDomainId );
    }

    //
    // Add space for extra sids & resource groups
    //

    if ( ExtraSids )
    {
        for ( Index = 0 ; Index < SidCount ; Index++ )
        {
            Length += sizeof( NETLOGON_SID_AND_ATTRIBUTES ) + RtlLengthSid( ExtraSids[Index].Sid );
        }
        TotalNumberOfSids += SidCount;
    }
    else if ( ValidationLevel != NetlogonValidationSamInfo &&
              ( ValidationInfo->UserFlags & LOGON_EXTRA_SIDS ) != 0 )
    {
        for (Index = 0; Index < ValidationInfo2->SidCount ; Index++ ) {
            Length += sizeof(NETLOGON_SID_AND_ATTRIBUTES) + RtlLengthSid(ValidationInfo2->ExtraSids[Index].Sid);
        }
        TotalNumberOfSids += ValidationInfo2->SidCount;
    }

    if ( ResourceGroupIds != NULL && ResourceGroupDomainSid != NULL )
    {
        Length += ResourceGroupCount * ( sizeof( NETLOGON_SID_AND_ATTRIBUTES ) + RtlLengthSid( ResourceGroupDomainSid ) + sizeof( ULONG ));
        TotalNumberOfSids += ResourceGroupCount;
    }

    //
    // Round up now to take into account the round up in the
    // middle of marshalling
    //

    Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo->LogonDomainName.Length + sizeof(WCHAR)
            + ValidationInfo->LogonServer.Length + sizeof(WCHAR)
            + ValidationInfo->EffectiveName.Length + sizeof(WCHAR)
            + ValidationInfo->FullName.Length + sizeof(WCHAR)
            + ValidationInfo->LogonScript.Length + sizeof(WCHAR)
            + ValidationInfo->ProfilePath.Length + sizeof(WCHAR)
            + ValidationInfo->HomeDirectory.Length + sizeof(WCHAR)
            + ValidationInfo->HomeDirectoryDrive.Length + sizeof(WCHAR);

    if ( ValidationLevel == NetlogonValidationSamInfo4 ) {
        Length += ValidationInfo4->DnsLogonDomainName.Length + sizeof(WCHAR)
            + ValidationInfo4->Upn.Length + sizeof(WCHAR);

        //
        // The ExpansionStrings may be used to transport byte aligned data
        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo4->ExpansionString1.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo4->ExpansionString2.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo4->ExpansionString3.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo4->ExpansionString4.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo4->ExpansionString5.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo4->ExpansionString6.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo4->ExpansionString7.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo4->ExpansionString8.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo4->ExpansionString9.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + ValidationInfo4->ExpansionString10.Length + sizeof(WCHAR);
    }

    Length = ROUND_UP_COUNT( Length, sizeof(WCHAR) );

    SamInfo4 = (PNETLOGON_VALIDATION_SAM_INFO4)MIDL_user_allocate( Length );

    if ( !SamInfo4 )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        NlPrint((NL_CRITICAL, "ROGUE: Out of memory allocating SamInfo4\n"));
        goto Error;
    }

    //
    // First copy the whole structure, since most parts are the same
    //

    RtlCopyMemory( SamInfo4, ValidationInfo, sizeof(NETLOGON_VALIDATION_SAM_INFO));
    RtlZeroMemory( &((LPBYTE)SamInfo4)[sizeof(NETLOGON_VALIDATION_SAM_INFO)],
                   sizeof(NETLOGON_VALIDATION_SAM_INFO4) - sizeof(NETLOGON_VALIDATION_SAM_INFO) );

    //
    // See if these need to be added (later)
    //

    SamInfo4->UserFlags &= ~LOGON_EXTRA_SIDS;

    //
    // Substitute the UserId and PrimaryGroupId
    //

    SamInfo4->UserId = UserId;
    SamInfo4->PrimaryGroupId = PrimaryGroupId;

    //
    // Copy all the variable length data
    //

    Where = (PBYTE) (SamInfo4 + 1);

    if ( GroupIds != NULL )
    {
        RtlCopyMemory(
            Where,
            GroupIds,
            GroupCount * sizeof( GROUP_MEMBERSHIP )
            );

        SamInfo4->GroupIds = (PGROUP_MEMBERSHIP) Where;
        SamInfo4->GroupCount = GroupCount;
        Where += GroupCount * sizeof( GROUP_MEMBERSHIP );
    }
    else
    {
        RtlCopyMemory(
            Where,
            ValidationInfo->GroupIds,
            ValidationInfo->GroupCount * sizeof( GROUP_MEMBERSHIP )
            );

        SamInfo4->GroupIds = (PGROUP_MEMBERSHIP) Where;
        SamInfo4->GroupCount = ValidationInfo->GroupCount;
        Where += ValidationInfo->GroupCount * sizeof( GROUP_MEMBERSHIP );
    }

    //
    // Copy the extra groups
    //

    if ( TotalNumberOfSids > 0 )
    {
        PNETLOGON_SID_AND_ATTRIBUTES ExtraSidsArray = NULL;
        ULONG ExtraSidsCount = 0;

        SamInfo4->ExtraSids = (PNETLOGON_SID_AND_ATTRIBUTES) Where;
        Where += sizeof(NETLOGON_SID_AND_ATTRIBUTES) * TotalNumberOfSids;

        GroupIndex = 0;

        if ( ExtraSids != NULL )
        {
            ExtraSidsArray = ExtraSids;
            ExtraSidsCount = SidCount;

        }
        else if ( ValidationLevel != NetlogonValidationSamInfo &&
                  (ValidationInfo->UserFlags & LOGON_EXTRA_SIDS) != 0 )
        {
            ExtraSidsArray = ValidationInfo2->ExtraSids;
            ExtraSidsCount = ValidationInfo2->SidCount;
        }

        for ( Index = 0 ; Index < ExtraSidsCount ; Index++ )
        {
            SamInfo4->ExtraSids[GroupIndex].Attributes = ExtraSidsArray[Index].Attributes;
            SamInfo4->ExtraSids[GroupIndex].Sid = (PSID) Where;
            SidLength = RtlLengthSid(ExtraSidsArray[Index].Sid);
            RtlCopyMemory(
                Where,
                ExtraSidsArray[Index].Sid,
                SidLength
                );

            Where += SidLength;
            GroupIndex++;
        }

        //
        // Add the resource groups
        //

        for ( Index = 0 ; Index < ResourceGroupCount ; Index++ )
        {
            SamInfo4->ExtraSids[GroupIndex].Attributes = ResourceGroupIds[Index].Attributes;

            SamInfo4->ExtraSids[GroupIndex].Sid = (PSID) Where;
            SidLength = RtlLengthSid(ResourceGroupDomainSid);
            RtlCopyMemory(
                Where,
                ResourceGroupDomainSid,
                SidLength
                );
            ((SID *)(Where))->SubAuthorityCount += 1;
            Where += SidLength;
            RtlCopyMemory(
                Where,
                &ResourceGroupIds[Index].RelativeId,
                sizeof(ULONG)
                );
            Where += sizeof(ULONG);
            GroupIndex++;
        }

        SamInfo4->UserFlags |= LOGON_EXTRA_SIDS;
        SamInfo4->SidCount = GroupIndex;
        NlAssert(GroupIndex == TotalNumberOfSids);
    }

    if ( LogonDomainId != NULL )
    {
        SidLength = RtlLengthSid( LogonDomainId );
        RtlCopyMemory(
            Where,
            LogonDomainId,
            SidLength
            );
        SamInfo4->LogonDomainId = (PSID) Where;
        Where += SidLength;
    }
    else
    {
        SidLength = RtlLengthSid( ValidationInfo->LogonDomainId );
        RtlCopyMemory(
            Where,
            ValidationInfo->LogonDomainId,
            SidLength
            );
        SamInfo4->LogonDomainId = (PSID) Where;
        Where += SidLength;
    }

    //
    // Copy the WCHAR-aligned data
    //

    Where = ROUND_UP_POINTER(Where, sizeof(WCHAR));

    NlpPutString(
        &SamInfo4->EffectiveName,
        &ValidationInfo->EffectiveName,
        &Where );

    NlpPutString(
        &SamInfo4->FullName,
        &ValidationInfo->FullName,
        &Where );

    NlpPutString(
        &SamInfo4->LogonScript,
        &ValidationInfo->LogonScript,
        &Where );

    NlpPutString(
        &SamInfo4->ProfilePath,
        &ValidationInfo->ProfilePath,
        &Where );

    NlpPutString(
        &SamInfo4->HomeDirectory,
        &ValidationInfo->HomeDirectory,
        &Where );

    NlpPutString(
        &SamInfo4->HomeDirectoryDrive,
        &ValidationInfo->HomeDirectoryDrive,
        &Where );

    NlpPutString(
        &SamInfo4->LogonServer,
        &ValidationInfo->LogonServer,
        &Where );

    NlpPutString(
        &SamInfo4->LogonDomainName,
        &ValidationInfo->LogonDomainName,
        &Where );

    if ( ValidationLevel == NetlogonValidationSamInfo4 )
    {
        NlpPutString(
            &SamInfo4->DnsLogonDomainName,
            &ValidationInfo4->DnsLogonDomainName,
            &Where );

        NlpPutString(
            &SamInfo4->Upn,
            &ValidationInfo4->Upn,
            &Where );

        NlpPutString(
            &SamInfo4->ExpansionString1,
            &ValidationInfo4->ExpansionString1,
            &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(
            &SamInfo4->ExpansionString2,
            &ValidationInfo4->ExpansionString2,
            &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR));

        NlpPutString(
            &SamInfo4->ExpansionString3,
            &ValidationInfo4->ExpansionString3,
            &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR));

        NlpPutString(
            &SamInfo4->ExpansionString4,
            &ValidationInfo4->ExpansionString4,
            &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR));

        NlpPutString(
            &SamInfo4->ExpansionString5,
            &ValidationInfo4->ExpansionString5,
            &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR));

        NlpPutString(
            &SamInfo4->ExpansionString6,
            &ValidationInfo4->ExpansionString6,
            &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR));

        NlpPutString(
            &SamInfo4->ExpansionString7,
            &ValidationInfo4->ExpansionString7,
            &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR));

        NlpPutString(
            &SamInfo4->ExpansionString8,
            &ValidationInfo4->ExpansionString8,
            &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR));

        NlpPutString(
            &SamInfo4->ExpansionString9,
            &ValidationInfo4->ExpansionString9,
            &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR));

        NlpPutString(
            &SamInfo4->ExpansionString10,
            &ValidationInfo4->ExpansionString10,
            &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR));
    }

    MIDL_user_free(ValidationInfo);

    *UserInfo = SamInfo4;

Cleanup:

    LocalFree( FullUserSidText );
    LocalFree( ResourceGroupDomainSid );
    LocalFree( LogonDomainId );
    HeapFree( GetProcessHeap(), 0, ResourceGroupIds );
    HeapFree( GetProcessHeap(), 0, GroupIds );

    if ( ExtraSids )
    {
        for ( Index = 0; Index < SidCount; Index++ )
        {
            HeapFree( GetProcessHeap(), 0, ExtraSids[Index].Sid );
        }

        HeapFree( GetProcessHeap(), 0, ExtraSids );
    }

    HeapFree( GetProcessHeap(), 0, Value );

    return Status;

Error:

    goto Cleanup;
}

#endif

NTSTATUS
NlpSamValidate (
    IN SAM_HANDLE DomainHandle,
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PUNICODE_STRING LogonServer,
    IN PUNICODE_STRING LogonDomainName,
    IN PSID LogonDomainId,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PVOID * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    OUT PBOOLEAN BadPasswordCountZeroed,
    IN DWORD AccountsToTry
)
/*++

Routine Description:

    This is a thin wrapper around MsvSamValidate.  It normalizes
    some of parameters to a form that MSV recognizes.

Arguments:

    Same as for MsvSamValidate.

Return Value:

    Same as for MsvSamValidate.

--*/
{
    NTSTATUS Status;

    NETLOGON_LOGON_INFO_CLASS LogonLevelToUse;
    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;
    ULONG SavedParameterControl;
    UNICODE_STRING SavedDomainName;

    //
    // Initialization
    //
    LogonLevelToUse = LogonLevel;
    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;


    //
    // Don't confuse MSV with the transitive LogonLevels
    //
    switch (LogonLevel ) {
    case NetlogonInteractiveTransitiveInformation:
        LogonLevelToUse = NetlogonInteractiveInformation; break;
    case NetlogonServiceTransitiveInformation:
        LogonLevelToUse = NetlogonServiceInformation; break;
    case NetlogonNetworkTransitiveInformation:
        LogonLevelToUse = NetlogonNetworkInformation; break;
    }

    //
    // Don't confuse MSV with domains used for routing only
    //

    SavedDomainName = LogonInfo->LogonDomainName;
    SavedParameterControl = LogonInfo->ParameterControl;

    if ( LogonInfo->ParameterControl & MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY ) {

        //
        // Clear the routing information
        //

        RtlInitUnicodeString( &LogonInfo->LogonDomainName, NULL );
        LogonInfo->ParameterControl &= ~ MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY;
    }

    //
    // Now that we've normalized the parameters, call MSV
    //

    Status = MsvSamValidate (
             DomainHandle,
             UasCompatibilityRequired,
             SecureChannelType,
             LogonServer,
             LogonDomainName,
             LogonDomainId,
             LogonLevelToUse,
             LogonInfo,
             ValidationLevel,
             ValidationInformation,
             Authoritative,
             BadPasswordCountZeroed,
             AccountsToTry );

    //
    // Restore the saved data
    //

    LogonInfo->LogonDomainName = SavedDomainName;
    LogonInfo->ParameterControl = SavedParameterControl;

    return Status;
}


NTSTATUS
NlpUserValidate (
    IN PDOMAIN_INFO DomainInfo,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN ULONG ComputerAccountRid,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags,
    IN BOOLEAN Recursed
)
/*++

Routine Description:

    This function processes an interactive or network logon.
    It is a worker routine for I_NetSamLogon.  I_NetSamLogon handles the
    details of validating the caller.  This function handles the details
    of whether to validate locally or pass the request on.  MsvValidateSam
    does the actual local validation.

    session table only in the domain defining the specified user's
    account.

    This service is also used to process a re-logon request.


Arguments:

    DomainInfo - Hosted domain this logon is for.

    SecureChannelType -- Type of secure channel this request was made over.

    ComputerAccountRid - The RID of the computer account for the workstation
        that passed the logon to this domain controller.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.  Has already been validated.

    LogonInformation -- Specifies the description for the user
        logging on.

    ValidationLevel -- Specifies the level of information returned in
        ValidationInformation.  Must be NetlogonValidationSamInfo,
        NetlogonValidationSamInfo2, or NetlogonValidationSamInfo4.

    ValidationInformation -- Returns the requested validation
        information.  This buffer must be freed using MIDL_user_free.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    ExtraFlags -- Accepts and returns a DWORD to the caller.
        The DWORD contains NL_EXFLAGS_* values.

    Recursed - TRUE if this is a recursive call. This routine sometimes translates
        the account name in the logon information to a more explicit form (e.g., from a
        UPN to a <DnsDomainName>\<SamAccountName> form).  After it does that, it simply
        calls this routine again.  This boolean is TRUE on that second call.

Return Value:

    STATUS_SUCCESS: if there was no error.
    Otherwise, the error code is
    returned.


--*/
{
    NTSTATUS Status;
    NTSTATUS DefaultStatus = STATUS_NO_SUCH_USER;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;
    PCLIENT_SESSION ClientSession = NULL;

    DWORD AccountsToTry = MSVSAM_SPECIFIED | MSVSAM_GUEST;
    BOOLEAN BadPasswordCountZeroed;
    BOOLEAN LogonToLocalDomain;
    LPWSTR RealSamAccountName = NULL;
    LPWSTR RealDomainName = NULL;
    ULONG RealExtraFlags = 0;   // Flags to pass to the next hop

    BOOLEAN ExpediteToRoot = ((*ExtraFlags) & NL_EXFLAGS_EXPEDITE_TO_ROOT) != 0;
    BOOLEAN CrossForestHop = ((*ExtraFlags) & NL_EXFLAGS_CROSS_FOREST_HOP) != 0;

    //
    // Initialization
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;
    *Authoritative = FALSE;

    //
    // The DNS domain for a workstation is the domain its a member of, so
    // don't match based on that.
    //

    LogonToLocalDomain = RtlEqualDomainName( &LogonInfo->LogonDomainName,
                                             &DomainInfo->DomUnicodeAccountDomainNameString ) ||
                         ((DomainInfo->DomRole != RoleMemberWorkstation ) &&
                          NlEqualDnsNameU( &LogonInfo->LogonDomainName,
                                           &DomainInfo->DomUnicodeDnsDomainNameString ) ) ;




    //
    // Check to see if the account is in the local SAM database.
    //
    // The Theory:
    //  If a particular database is absolutely requested,
    //      we only try the account in the requested database.
    //
    //  In the event that an account exists in multiple places in the hierarchy,
    //  we want to find the version of the account that is closest to the
    //  logged on machine (i.e., workstation first, primary domain, then
    //  trusted domain.).  So we always try to local database before going
    //  to a higher authority.
    //
    // Finally, handle the case that this call is from a BDC in our own domain
    // just checking to see if the PDC (us) has a better copy of the account
    // than it does.
    //

    if ( !ExpediteToRoot &&
         ( (LogonInfo->LogonDomainName.Length == 0 && !CrossForestHop ) ||
           LogonToLocalDomain ||
           SecureChannelType == ServerSecureChannel )) {

        //
        // If we are not doing a generic passthrough, just call SAM
        //


        if ( LogonLevel != NetlogonGenericInformation ) {

            //
            // Indicate we've already tried the specified account and
            // we won't need to try it again locally.
            //

            AccountsToTry &= ~MSVSAM_SPECIFIED;


            Status = NlpSamValidate( DomainInfo->DomSamAccountDomainHandle,
                                     TRUE,  // UasCompatibilityMode,
                                     SecureChannelType,
                                     &DomainInfo->DomUnicodeComputerNameString,
                                     &DomainInfo->DomUnicodeAccountDomainNameString,
                                     DomainInfo->DomAccountDomainId,
                                     LogonLevel,
                                     LogonInformation,
                                     ValidationLevel,
                                     (PVOID *)ValidationInformation,
                                     Authoritative,
                                     &BadPasswordCountZeroed,
                                     MSVSAM_SPECIFIED );

            //
            // If this is a BDC and we zeroed the BadPasswordCount field,
            //  allow the PDC to do the same thing.
            //

            if ( BadPasswordCountZeroed ) {
                NlpZeroBadPasswordCountOnPdc ( DomainInfo, LogonLevel, LogonInformation );
            }


            //
            // If the request is explicitly for this domain,
            //  The STATUS_NO_SUCH_USER answer is authoritative.
            //

            if ( LogonToLocalDomain && Status == STATUS_NO_SUCH_USER ) {
                *Authoritative = TRUE;
            }


            //
            // If this is one of our BDCs calling,
            //  return with whatever answer we got locally.
            //

            if ( SecureChannelType == ServerSecureChannel ) {
                DefaultStatus = Status;
                goto Cleanup;
            }

        } else {

            PNETLOGON_GENERIC_INFO GenericInfo;
            NETLOGON_VALIDATION_GENERIC_INFO GenericValidation;
            NTSTATUS ProtocolStatus;

            GenericInfo = (PNETLOGON_GENERIC_INFO) LogonInformation;
            GenericValidation.ValidationData = NULL;
            GenericValidation.DataLength = 0;

            //
            // We are doing generic passthrough, so call the LSA
            //
            // LogonData is opaque to Netlogon.  The caller made sure that any
            //  pointers within LogonData are actually offsets within LogonData.
            //  So, tell the package that the Client's buffer base is 0.
            //

            Status = LsaICallPackagePassthrough(
                        &GenericInfo->PackageName,
                        0,  // Indicate pointers are relative.
                        GenericInfo->LogonData,
                        GenericInfo->DataLength,
                        (PVOID *) &GenericValidation.ValidationData,
                        &GenericValidation.DataLength,
                        &ProtocolStatus
                        );

            if (NT_SUCCESS(Status)) {
                Status = ProtocolStatus;
            }


            //
            // This is always authoritative.
            //

            *Authoritative = TRUE;

            //
            // If the call succeeded, allocate the return message.
            //

            if (NT_SUCCESS(Status)) {
                PNETLOGON_VALIDATION_GENERIC_INFO ReturnInfo;
                ULONG ValidationLength;

                ValidationLength = sizeof(*ReturnInfo) + GenericValidation.DataLength;

                ReturnInfo = (PNETLOGON_VALIDATION_GENERIC_INFO) MIDL_user_allocate(
                                ValidationLength
                                );

                if (ReturnInfo != NULL) {
                    if ( GenericValidation.DataLength == 0 ||
                         GenericValidation.ValidationData == NULL ) {
                        ReturnInfo->DataLength = 0;
                        ReturnInfo->ValidationData = NULL;
                    } else {

                        ReturnInfo->DataLength = GenericValidation.DataLength;
                        ReturnInfo->ValidationData = (PUCHAR) (ReturnInfo + 1);

                        RtlCopyMemory(
                            ReturnInfo->ValidationData,
                            GenericValidation.ValidationData,
                            ReturnInfo->DataLength );

                    }

                    *ValidationInformation = (PBYTE) ReturnInfo;

                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                if (GenericValidation.ValidationData != NULL) {
                    LsaIFreeReturnBuffer(GenericValidation.ValidationData);
                }

            }

            DefaultStatus = Status;


            goto Cleanup;

        }


        //
        // If the local SAM database authoritatively handled the logon attempt,
        //  just return.
        //

        if ( *Authoritative ) {
            DefaultStatus = Status;

#ifdef _DC_NETLOGON
            //
            // If the problem is just that the password is wrong,
            //  try again on the PDC where the password may already be changed.
            //

            if ( BAD_PASSWORD(Status) ) {

                BOOLEAN TempAuthoritative;

                Status = NlpUserValidateOnPdc (
                                DomainInfo,
                                LogonLevel,
                                LogonInformation,
                                ValidationLevel,
                                TRUE,   // use negative cache of failed user logons
                                ValidationInformation,
                                &TempAuthoritative );

                // Ignore failures from the PDC (except where it has newer information)
                if ( NT_SUCCESS(Status) || BAD_PASSWORD(Status) ) {
                    DefaultStatus = Status;
                    *Authoritative = TempAuthoritative;
                }

                // If appropriate, zero bad password locally on this BDC.
                // Ignore error as it's not critical operation.
                if ( (NT_SUCCESS(Status) || ZERO_BAD_PWD_COUNT(Status)) &&
                     !NlGlobalMemberWorkstation ) {
                    NlpZeroBadPasswordCountLocally( DomainInfo, &LogonInfo->UserName );
                }
            }

            //
            // If the result of local validation or validation on
            //  the PDC is anything other than the bad password status,
            //  remove this user from the bad password negative cache
            //

            if ( !BAD_PASSWORD(DefaultStatus) ) {
                NlpRemoveBadPasswordCacheEntry( DomainInfo, LogonInformation );
            }
#endif // _DC_NETLOGON

            goto Cleanup;
        }

        DefaultStatus = Status;
    }


    //
    // If the request in not for this domain,
    // or the domain name isn't specified (and we haven't found the account yet)
    // or our caller asked us to send the request to the root of the forest,
    //  send the request to a higher authority.
    //

    if ( !LogonToLocalDomain ||
         LogonInfo->LogonDomainName.Length == 0 ||
         ExpediteToRoot ) {


        //
        // If this machine is a workstation,
        //  send the request to the Primary Domain.
        //

        if ( NlGlobalMemberWorkstation ) {

            NlAssert( !ExpediteToRoot );
            NlAssert( !CrossForestHop );

            ClientSession = NlRefDomClientSession( DomainInfo);

            if ( ClientSession == NULL ) {
                *Authoritative = FALSE;
                Status = STATUS_TRUSTED_RELATIONSHIP_FAILURE;
                goto Cleanup;
            }

            Status = NlpUserValidateHigher(
                        ClientSession,
                        FALSE,
                        LogonLevel,
                        LogonInformation,
                        ValidationLevel,
                        ValidationInformation,
                        Authoritative,
                        &RealExtraFlags );

            NlUnrefClientSession( ClientSession );
            ClientSession = NULL;

            NlAssert( !NT_SUCCESS(Status) || Status == STATUS_SUCCESS );
            NlAssert( !NT_SUCCESS(Status) || *ValidationInformation != NULL );


            //
            // return more appropriate error
            //

            if( (Status == STATUS_NO_TRUST_SAM_ACCOUNT) ||
                (Status == STATUS_ACCESS_DENIED) ) {

                Status = STATUS_TRUSTED_RELATIONSHIP_FAILURE;
            }

            //
            // If the primary domain authoritatively handled the logon attempt,
            //  just return.
            //

            if ( *Authoritative ) {

                //
                // If we didn't actually talk to the primary domain,
                //  check locally if the domain requested is a trusted domain.
                //  (This list is only a cache so we had to try to contact the
                //  primary domain.)
                //
                // Note: I can't differentiate between there not being a logon server
                // in my primary domain and there not being a logon sever in
                // a trusted domain.  So, both cases go into the code below.
                //

                if ( Status == STATUS_NO_LOGON_SERVERS ) {

                    //
                    // If no domain name was specified,
                    //  check if the user name is a UPN.
                    //

                    if ( LogonLevel != NetlogonGenericInformation &&
                         LogonInfo->LogonDomainName.Length == 0 ) {

                        ULONG i;

                        for ( i=0; i<LogonInfo->UserName.Length/sizeof(WCHAR); i++) {

                            //
                            // If this is a UPN logon,
                            //  assume that the domain is a trusted domain.
                            //
                            // ???: it isn't sufficient to check for an @.
                            //  This might be a user account with an @ in it.
                            //
                            // This makes UPNs eligible for cached logon.
                            // But it doesn't make UPNs eligible for guest
                            // account logon.
                            if ( LogonInfo->UserName.Buffer[i] == L'@') {
                                DefaultStatus = Status;
                                goto Cleanup;
                            }
                        }
                    }

                    //
                    // If the domain specified is trusted,
                    //  then return the status to the caller.
                    //  otherwise just press on.

                    if ( NlIsDomainTrusted ( &LogonInfo->LogonDomainName ) ) {
                        DefaultStatus = Status;
                        goto Cleanup;
                    } else {
                        //
                        // Set the return codes to look as though the primary
                        //  determined this is an untrusted domain.
                        //
                        *Authoritative = FALSE;
                        Status = STATUS_NO_SUCH_USER;
                    }
                } else {
                    DefaultStatus = Status;
                    goto Cleanup;
                }
            }


            if ( Status != STATUS_NO_SUCH_USER ) {
                DefaultStatus = Status;
            }


        //
        // This machine is a Domain Controller.
        //
        // This request is either a pass-thru request by a workstation in
        // our domain, or this request came directly from the MSV
        // authentication package.
        //
        // In either case, pass the request to the trusted domain.
        //

        } else {
            BOOLEAN TransitiveUsed;

            //
            // If the request was passed to us from a trusting domain DC,
            //  and the caller doesn't want transitive trust to be used,
            //  then avoid using transitive trust. (Generic passthrough
            //  may always be transitive (it was introduced in NT5).)
            //

            if ( IsDomainSecureChannelType(SecureChannelType) &&
                  LogonLevel != NetlogonInteractiveTransitiveInformation &&
                  LogonLevel != NetlogonServiceTransitiveInformation &&
                  LogonLevel != NetlogonNetworkTransitiveInformation &&
                  LogonLevel != NetlogonGenericInformation ) {
                DefaultStatus = STATUS_NO_SUCH_USER;
                goto Cleanup;
            }


            //
            // If our caller asked us to expedite this request to the domain at the forest root,
            //  find the client session to our parent.
            //

            if ( ExpediteToRoot ) {

                //
                // Only do this if we're not already at the root
                //

                if ( (DomainInfo->DomFlags & DOM_FOREST_ROOT) == 0  ) {

                    ClientSession = NlRefDomParentClientSession( DomainInfo );

                    if ( ClientSession == NULL ) {
                        NlPrintDom((NL_LOGON, DomainInfo,
                                    "NlpUserValidate: Can't find parent domain in forest '%wZ'\n",
                                    &NlGlobalUnicodeDnsForestNameString ));
                        DefaultStatus = STATUS_NO_SUCH_USER;
                        goto Cleanup;
                    }

                    //
                    // Tell the DC we're calling to continue expediting to root.
                    //

                    RealExtraFlags |= NL_EXFLAGS_EXPEDITE_TO_ROOT;

                }

            //
            // It the domain is explicitly given,
            //  simply find the client session for that domain.
            //

            } else {
                if ( LogonInfo->LogonDomainName.Length != 0 ) {

                    //
                    // Find a client session for the domain.
                    //
                    // If we just hopped from another forest,
                    //  require that LogonDomainName be a domain in the forest.
                    //
                    ClientSession = NlFindNamedClientSession(
                                                  DomainInfo,
                                                  &LogonInfo->LogonDomainName,
                                                  NL_RETURN_CLOSEST_HOP |
                                                  (CrossForestHop ?
                                                        NL_REQUIRE_DOMAIN_IN_FOREST : 0),
                                                  &TransitiveUsed );


                }
            }



            //
            // If the client session hasn't yet been found,
            //  Try to find the domain name by ask the GC.
            //
            // Avoid this step if the call came from a DC.  It should have done the GC lookup.
            //      Even that's OK if the caller was expediting to root or
            //      hopping into this forest from a trusting forest.
            // Avoid this step if this machine already did the GC lookup.
            //

            if ( LogonLevel != NetlogonGenericInformation &&
                 ClientSession == NULL &&
                 ( !IsDomainSecureChannelType(SecureChannelType) ||
                 (ExpediteToRoot || CrossForestHop) ) &&
                 !Recursed ) {



                //
                // Find the domain the account is in from one of the following sources:
                //    The LSA FTinfo match routine if this is a DC at the root of the forest.
                //    The local DS for UPN lookup.
                //    The GC form UPN lookup or unqualified SAM account names.
                //    By datagram send to all directly trusted domains not in this forest.
                //

                Status = NlPickDomainWithAccount (
                                    DomainInfo,
                                    &LogonInfo->UserName,
                                    &LogonInfo->LogonDomainName,
                                    USER_NORMAL_ACCOUNT,
                                    SecureChannelType,
                                    ExpediteToRoot,
                                    CrossForestHop,
                                    &RealSamAccountName,
                                    &RealDomainName,
                                    &RealExtraFlags );


                //
                // If we're a DC at the root of the forest
                //  and the account is in a trusted forest,
                //  send the request to the other forest.
                //

                if ( NT_SUCCESS(Status) &&
                     (RealExtraFlags & NL_EXFLAGS_CROSS_FOREST_HOP) != 0 ) {

                    UNICODE_STRING RealDomainNameString;

                    RtlInitUnicodeString( &RealDomainNameString, RealDomainName );

                    ClientSession = NlFindNamedClientSession(
                                                  DomainInfo,
                                                  &RealDomainNameString,
                                                  NL_DIRECT_TRUST_REQUIRED,
                                                  &TransitiveUsed );

                    //
                    // Further qualify the ClientSession by ensure the found domain isn't
                    //  in our forest and that the F bit is set.
                    //

                    if ( ClientSession != NULL ) {

                        if ( (ClientSession->CsTrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) == 0 ) {

                            NlPrintCs((NL_CRITICAL, ClientSession,
                                        "NlpUserValidate: %wZ\\%wZ: trusted forest '%wZ' doesn't have F bit set.\n",
                                        &LogonInfo->LogonDomainName,
                                        &LogonInfo->UserName,
                                        &RealDomainNameString ));

                            DefaultStatus = STATUS_NO_SUCH_USER;
                            goto Cleanup;

                        }

                        if (ClientSession->CsFlags & CS_DOMAIN_IN_FOREST) {

                            NlPrintCs((NL_CRITICAL, ClientSession,
                                        "NlpUserValidate: %wZ\\%wZ: trusted forest '%wZ' is in my forest\n",
                                        &LogonInfo->LogonDomainName,
                                        &LogonInfo->UserName,
                                        &RealDomainNameString ));

                            DefaultStatus = STATUS_NO_SUCH_USER;
                            goto Cleanup;

                        }

                    } else {

                        NlPrintDom((NL_CRITICAL, DomainInfo,
                                    "NlpUserValidate: %wZ\\%wZ: Can't find trusted forest '%wZ'\n",
                                    &LogonInfo->LogonDomainName,
                                    &LogonInfo->UserName,
                                    &RealDomainNameString ));

                            DefaultStatus = STATUS_NO_SUCH_USER;
                            goto Cleanup;

                    }



                //
                // Fill in the account name and domain name and try again
                //
                } else if ( NT_SUCCESS(Status) ) {
                    PNETLOGON_LOGON_IDENTITY_INFO NewLogonInfo = NULL;
                    PNETLOGON_LOGON_IDENTITY_INFO LogonInfoToUse;


                    //
                    // If we found the real account name,
                    //  and it is in the local forest,
                    //  allocate a copy of the logon info to put the new information in.
                    //
                    //  Some pointers will continue to point to the old buffer.
                    //

                    if ( RealSamAccountName != NULL &&
                         RealDomainName != NULL &&
                        (RealExtraFlags & NL_EXFLAGS_EXPEDITE_TO_ROOT) == 0 ) {
                        ULONG BytesToCopy;
                        ULONG ExtraParameterControl = 0;
                        UNICODE_STRING UserNameToUse;

                        //
                        // By default, update the logon info to contain the RealSamAccountName
                        //

                        RtlInitUnicodeString( &UserNameToUse,
                                              RealSamAccountName );


                        //
                        // Determine the buffer size based on LogonLevel
                        //
                        switch ( LogonLevel ) {
                        case NetlogonInteractiveInformation:
                        case NetlogonInteractiveTransitiveInformation:
                            BytesToCopy = sizeof(NETLOGON_INTERACTIVE_INFO);break;
                        case NetlogonNetworkInformation:
                        case NetlogonNetworkTransitiveInformation: {
                            PNETLOGON_NETWORK_INFO NetworkLogonInfo = (PNETLOGON_NETWORK_INFO) LogonInfo;

                            BytesToCopy = sizeof(NETLOGON_NETWORK_INFO);

                            //
                            // Handle NTLM3 specially.
                            //
                            // Be conservative.  The trick described below causes the
                            // authentication to fail if the account domain
                            // doesn't recognize the MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY bit
                            // and the passed in account name is a UPN. For NTLM3,
                            // the authentication is already broken in that case.  However,
                            // older versions of NTLM work in that case today.  So we want
                            // to avoid the trick for older versions of NTLM.
                            //
                            // The unhandled case is for the subset of NTLM3 calls
                            // not detected below.  Those clients are those where
                            // NtChallengeResponse.Length is 0 and the response in
                            // LmChallengeResponse is NTLM3.  We think only WIN 9x and RIS
                            // generate such logons.  Neither support UPNs.
                            //

                            if ( NetworkLogonInfo->NtChallengeResponse.Length >= MSV1_0_NTLM3_MIN_NT_RESPONSE_LENGTH  &&
                                 NetworkLogonInfo->LmChallengeResponse.Length == NT_RESPONSE_LENGTH && // avoid down level altogether?
                                 NetworkLogonInfo->LmChallengeResponse.Length != (NetworkLogonInfo->NtChallengeResponse.Length / 2)) { // Avoid clear text passwords

                                //
                                // NTLM3 includes the UserName and DomainName in the response hash.
                                // So we can't change permanently change the DomainName or username
                                // Set a bit in the parameter control to tell the account domain to set
                                //  the DomainName back to NULL.
                                //

                                if ( LogonInfo->LogonDomainName.Length == 0 ) {

                                    ExtraParameterControl |= MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY;

                                    //
                                    // .. and retain the original user name
                                    //

                                    UserNameToUse = LogonInfo->UserName;
                                }
                            }

                            break;
                        }

                        case NetlogonServiceInformation:
                        case NetlogonServiceTransitiveInformation:
                            BytesToCopy = sizeof(NETLOGON_SERVICE_INFO);break;
                        default:
                            *Authoritative = FALSE;
                            DefaultStatus = STATUS_INVALID_PARAMETER;
                            goto Cleanup;
                        }

                        NewLogonInfo = LocalAlloc( 0, BytesToCopy );

                        if ( NewLogonInfo == NULL ) {
                            *Authoritative = FALSE;
                            DefaultStatus = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }

                        RtlCopyMemory( NewLogonInfo, LogonInfo, BytesToCopy );
                        LogonInfoToUse = NewLogonInfo;

                        //
                        // Put the newly found domain name and user name
                        //  into the NewLogonInfo.
                        //

                        RtlInitUnicodeString( &NewLogonInfo->LogonDomainName,
                                              RealDomainName );
                        NewLogonInfo->UserName = UserNameToUse;
                        NewLogonInfo->ParameterControl |= ExtraParameterControl;

                    //
                    // Otherwise, continue with the current account name
                    //

                    } else {
                        LogonInfoToUse = LogonInfo;
                    }


                    //
                    // Call this routine again now that we have better information.
                    //

                    DefaultStatus = NlpUserValidate(
                                       DomainInfo,
                                       SecureChannelType,
                                       ComputerAccountRid,
                                       LogonLevel,
                                       (LPBYTE)LogonInfoToUse,
                                       ValidationLevel,
                                       ValidationInformation,
                                       Authoritative,
                                       &RealExtraFlags,
                                       TRUE );  // A recursive call

                    if ( NewLogonInfo != NULL ) {
                        LocalFree( NewLogonInfo );
                    }



                    // Don't let this routine try again
                    AccountsToTry = 0;

                    goto Cleanup;

                }
            }

            //
            // If a trusted domain was determined,
            //  pass the logon request to the trusted domain.
            //

            if ( ClientSession != NULL ) {

                //
                // If this request was passed to us from a trusted domain,
                //  Check to see if it is OK to pass the request further.
                //

                if ( IsDomainSecureChannelType( SecureChannelType ) ) {

                    //
                    // If the trust isn't an NT 5.0 trust,
                    //  avoid doing the trust transitively.
                    //
                    LOCK_TRUST_LIST( DomainInfo );
                    if ( (ClientSession->CsFlags & CS_NT5_DOMAIN_TRUST ) == 0 ) {
                        UNLOCK_TRUST_LIST( DomainInfo );
                        NlPrintCs((NL_LOGON, ClientSession,
                            "SamLogon: Avoid transitive trust on NT 4 trust." ));
                        DefaultStatus = STATUS_NO_SUCH_USER;
                        goto Cleanup;
                    }
                    UNLOCK_TRUST_LIST( DomainInfo );

                }

                Status = NlpUserValidateHigher(
                            ClientSession,
                            TransitiveUsed,
                            LogonLevel,
                            LogonInformation,
                            ValidationLevel,
                            ValidationInformation,
                            Authoritative,
                            &RealExtraFlags );


                NlAssert( !NT_SUCCESS(Status) || Status == STATUS_SUCCESS );
                NlAssert( !NT_SUCCESS(Status) || *ValidationInformation != NULL );


                //
                // return more appropriate error
                //

                if( (Status == STATUS_NO_TRUST_LSA_SECRET) ||
                    (Status == STATUS_NO_TRUST_SAM_ACCOUNT) ||
                    (Status == STATUS_ACCESS_DENIED) ) {

                    Status = STATUS_TRUSTED_DOMAIN_FAILURE;
                }

                //
                // Since the request is explicitly for a trusted domain,
                //  The STATUS_NO_SUCH_USER answer is authoritative.
                //

                if ( Status == STATUS_NO_SUCH_USER ) {
                    *Authoritative = TRUE;
                }

                //
                // If the trusted domain authoritatively handled the
                //  logon attempt, just return.
                //

                if ( *Authoritative ) {
                    DefaultStatus = Status;
                    goto Cleanup;
                }

                DefaultStatus = Status;

            }

        }
    }


    //
    // We have no authoritative answer from a higher authority and
    // DefaultStatus is the higher authority's response.
    //

    NlAssert( ! *Authoritative );


Cleanup:
    NlAssert( !NT_SUCCESS(DefaultStatus) || DefaultStatus == STATUS_SUCCESS );
    NlAssert( !NT_SUCCESS(DefaultStatus) || *ValidationInformation != NULL );

    //
    // Dereference any client session
    //

    if ( ClientSession != NULL ) {
        NlUnrefClientSession( ClientSession );
        ClientSession = NULL;
    }
    //
    // If this is a network logon and this call is non-passthru,
    //  Try one last time to log on.
    //

    if ( (LogonLevel == NetlogonNetworkInformation ||
          LogonLevel == NetlogonNetworkTransitiveInformation ) &&
         SecureChannelType == MsvApSecureChannel ) {

        //
        // If the only reason we can't log the user on is that he has
        //  no user account, logging him on as guest is OK.
        //
        // There are actaully two cases here:
        //  * If the response is Authoritative, then the specified domain
        //    is trusted but the user has no account in the domain.
        //
        //  * If the response in non-authoritative, then the specified domain
        //    is an untrusted domain.
        //
        // In either case, then right thing to do is to try the guest account.
        //

        if ( DefaultStatus != STATUS_NO_SUCH_USER &&
             DefaultStatus != STATUS_ACCOUNT_DISABLED ) {
            AccountsToTry &= ~MSVSAM_GUEST;
        }

        //
        // If this is not an authoritative response,
        //  then the domain specified isn't a trusted domain.
        //  try the specified account name too.
        //
        // The specified account name will probably be a remote account
        // with the same username and password.
        //

        if ( *Authoritative ) {
            AccountsToTry &= ~MSVSAM_SPECIFIED;
        }


        //
        // Validate against the Local Sam database.
        //

        if ( AccountsToTry != 0 ) {
            BOOLEAN TempAuthoritative;

            Status = NlpSamValidate(
                                 DomainInfo->DomSamAccountDomainHandle,
                                 TRUE,  // UasCompatibilityMode,
                                 SecureChannelType,
                                 &DomainInfo->DomUnicodeComputerNameString,
                                 &DomainInfo->DomUnicodeAccountDomainNameString,
                                 DomainInfo->DomAccountDomainId,
                                 LogonLevel,
                                 LogonInformation,
                                 ValidationLevel,
                                 (PVOID *)ValidationInformation,
                                 &TempAuthoritative,
                                 &BadPasswordCountZeroed,
                                 AccountsToTry );
            NlAssert( !NT_SUCCESS(Status) || Status == STATUS_SUCCESS );
            NlAssert( !NT_SUCCESS(Status) || *ValidationInformation != NULL );

            //
            // If this is a BDC and we zeroed the BadPasswordCount field,
            //  allow the PDC to do the same thing.
            //

            if ( BadPasswordCountZeroed ) {
                NlpZeroBadPasswordCountOnPdc ( DomainInfo, LogonLevel, LogonInformation );
            }

            //
            // If the local SAM database authoritatively handled the
            //  logon attempt,
            //  just return.
            //

            if ( TempAuthoritative ) {
                DefaultStatus = Status;
                *Authoritative = TRUE;

                //
                // If the problem is just that the password is wrong,
                //  try again on the PDC where the password may already be
                //      changed.
                //

                if ( BAD_PASSWORD(Status) ) {

                    Status = NlpUserValidateOnPdc (
                                    DomainInfo,
                                    LogonLevel,
                                    LogonInformation,
                                    ValidationLevel,
                                    TRUE,   // use negative cache of failed user logons
                                    ValidationInformation,
                                    &TempAuthoritative );

                    // Ignore failures from the PDC (except where it has newer information)
                    if ( NT_SUCCESS(Status) || BAD_PASSWORD(Status) ) {
                        DefaultStatus = Status;
                        *Authoritative = TempAuthoritative;
                    }

                    // If appropriate, zero bad password locally on this BDC.
                    // Ignore error as it's not critical operation.
                    if ( (NT_SUCCESS(Status) || ZERO_BAD_PWD_COUNT(Status)) &&
                         !NlGlobalMemberWorkstation ) {
                        NlpZeroBadPasswordCountLocally( DomainInfo, &LogonInfo->UserName );
                    }
                }

                //
                // If the result of local validation or validation on
                //  the PDC is anything other than the bad password status,
                //  remove this user from the bad password negative cache
                //

                if ( !BAD_PASSWORD(DefaultStatus) ) {
                    NlpRemoveBadPasswordCacheEntry( DomainInfo, LogonInformation );
                }

            //
            // Here we must choose between the non-authoritative status in
            // DefaultStatus and the non-authoritative status from the local
            // SAM lookup.  Use the one from the higher authority unless it
            // isn't interesting.
            //

            } else {
                if ( DefaultStatus == STATUS_NO_SUCH_USER ) {
                    DefaultStatus = Status;
                }
            }
        }
    }

    if ( RealSamAccountName != NULL ) {
        NetApiBufferFree( RealSamAccountName );
    }
    if ( RealDomainName != NULL ) {
        NetApiBufferFree( RealDomainName );
    }

    //
    // Add in the resource groups if the caller is expecting them -
    // if this is the last domain controller on the authentication path
    // before returning to the machine being logged on to.
    //
    // This will also perform the Other Organization check that determines
    //  whether the specified user can logon to the specified workstation.
    //

    if (((SecureChannelType == WorkstationSecureChannel) ||
         (SecureChannelType == MsvApSecureChannel)) &&
        (SecureChannelType != UasServerSecureChannel) &&
        (ValidationLevel == NetlogonValidationSamInfo2  || ValidationLevel == NetlogonValidationSamInfo4 ) &&
        !NlGlobalMemberWorkstation &&
        NT_SUCCESS(DefaultStatus) &&
        !Recursed ) {  // do this only once

        Status = NlpExpandResourceGroupMembership(
                    ValidationLevel,
                    (PNETLOGON_VALIDATION_SAM_INFO4 *) ValidationInformation,
                    DomainInfo,
                    ComputerAccountRid
                    );
        if (!NT_SUCCESS(Status)) {
            DefaultStatus = Status;
        }
    }

#ifdef ROGUE_DC

    if ( NT_SUCCESS( Status )) {

        NlpBuildRogueValidationInfo(
            ValidationLevel,
            (PNETLOGON_VALIDATION_SAM_INFO4 *)ValidationInformation
            );
    }

#endif

    return DefaultStatus;

}


#if NETLOGONDBG

VOID
NlPrintLogonParameters(
    IN PDOMAIN_INFO DomainInfo OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PNETLOGON_LEVEL LogonInformation,
    IN ULONG ExtraFlags,
    IN PULONG NtStatusPointer OPTIONAL
)
/*++

Routine Description:

    Prints the parameters to NlpLogonSamLogon.


Arguments:

    Same as NlpLogonSamLogon except:

    NtStatusPointer - If NULL, call is being entered.
        If not NULL, points to the return status of the API.


Return Value:

    None

--*/
{
    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;

    //
    // Print the entire text on a single line
    //

    EnterCriticalSection( &NlGlobalLogFileCritSect );



    //
    // Print the common information
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation->LogonInteractive;

    NlPrintDom(( NL_LOGON, DomainInfo,
                 "SamLogon: %s logon of %wZ\\%wZ from %wZ",
                 NlpLogonTypeToText( LogonLevel ),
                 &LogonInfo->LogonDomainName,
                 &LogonInfo->UserName,
                 &LogonInfo->Workstation ));

    //
    // Print the computer name
    //

    if ( ComputerName != NULL ) {
        NlPrint(( NL_LOGON, " (via %ws%)", ComputerName ));
    }

    //
    // Print the PackageName
    //

    if ( LogonLevel == NetlogonGenericInformation ) {
        NlPrint(( NL_LOGON, " Package:%wZ", &LogonInformation->LogonGeneric->PackageName ));
    }

    //
    // Print the ExtraFlags
    //

    if ( ExtraFlags != 0 ) {
        NlPrint(( NL_LOGON, " ExFlags:%lx", ExtraFlags ));
    }

    //
    // Print the status code
    //

    if ( NtStatusPointer == NULL ) {
        NlPrint(( NL_LOGON, " Entered\n" ));
    } else {
        NlPrint(( NL_LOGON, " Returns 0x%lX\n", *NtStatusPointer ));
    }

    LeaveCriticalSection( &NlGlobalLogFileCritSect );

}
#else // NETLOGONDBG
#define NlPrintLogonParameters(_a, _b, _c, _d, _e, _f )
#endif // NETLOGONDBG


NTSTATUS
NlpLogonSamLogon (
    IN handle_t ContextHandle OPTIONAL,
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PNETLOGON_LEVEL LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PNETLOGON_VALIDATION ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags,
    IN BOOL InProcessCall
)
/*++

Routine Description:

    This function is called by an NT client to process an interactive or
    network logon.  This function passes a domain name, user name and
    credentials to the Netlogon service and returns information needed to
    build a token.  It is called in three instances:

      *  It is called by the LSA's MSV1_0 authentication package for any
         NT DC.  The MSV1_0 authentication
         package calls SAM directly on workstations.  In this
         case, this function is a local function and requires the caller
         to have SE_TCB privilege.  The local Netlogon service will
         either handle this request directly (validating the request with
         the local SAM database) or will forward this request to the
         appropriate domain controller as documented in sections 2.4 and
         2.5.

      *  It is called by a Netlogon service on a workstation to a DC in
         the Primary Domain of the workstation as documented in section
         2.4.  In this case, this function uses a secure channel set up
         between the two Netlogon services.

      *  It is called by a Netlogon service on a DC to a DC in a trusted
         domain as documented in section 2.5.  In this case, this
         function uses a secure channel set up between the two Netlogon
         services.

    The Netlogon service validates the specified credentials.  If they
    are valid, adds an entry for this LogonId, UserName, and Workstation
    into the logon session table.  The entry is added to the logon
    session table only in the domain defining the specified user's
    account.

    This service is also used to process a re-logon request.


Arguments:

    LogonServer -- Supplies the name of the logon server to process
        this logon request.  This field should be null to indicate
        this is a call from the MSV1_0 authentication package to the
        local Netlogon service.

    ComputerName -- Name of the machine making the call.  This field
        should be null to indicate this is a call from the MSV1_0
        authentication package to the local Netlogon service.

    Authenticator -- supplied by the client.  This field should be
        null to indicate this is a call from the MSV1_0
        authentication package to the local Netlogon service.

    ReturnAuthenticator -- Receives an authenticator returned by the
        server.  This field should be null to indicate this is a call
        from the MSV1_0 authentication package to the local Netlogon
        service.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.

    ValidationLevel -- Specifies the level of information returned in
        ValidationInformation.  Must be NetlogonValidationSamInfo,
        NetlogonValidationSamInfo2 or NetlogonValidationSamInfo4.

    ValidationInformation -- Returns the requested validation
        information.  This buffer must be freed using MIDL_user_free.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    ExtraFlags -- Accepts and returns a DWORD to the caller.
        The DWORD contains NL_EXFLAGS_* values.

    InProcessCall - TRUE if the call is done in process (from msv1_0).
        FALSE otherwise.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_LOGON_SERVERS -- no domain controller in the requested
        domain is currently available to validate the logon request.

    STATUS_NO_TRUST_LSA_SECRET -- there is no secret account in the
        local LSA database to establish a secure channel to a DC.

    STATUS_TRUSTED_DOMAIN_FAILURE -- the secure channel setup between
        the domain controllers of the trust domains to pass-through
        validate the logon request failed.

    STATUS_TRUSTED_RELATIONSHIP_FAILURE -- the secure channel setup
        between the workstation and the DC failed.

    STATUS_INVALID_INFO_CLASS -- Either LogonLevel or ValidationLevel is
        invalid.

    STATUS_INVALID_PARAMETER -- Another Parameter is invalid.

    STATUS_ACCESS_DENIED -- The caller does not have access to call this
        API.

    STATUS_NO_SUCH_USER -- Indicates that the user specified in
        LogonInformation does not exist.  This status should not be returned
        to the originally caller.  It should be mapped to STATUS_LOGON_FAILURE.

    STATUS_WRONG_PASSWORD -- Indicates that the password information in
        LogonInformation was incorrect.  This status should not be returned
        to the originally caller.  It should be mapped to STATUS_LOGON_FAILURE.

    STATUS_INVALID_LOGON_HOURES -- The user is not authorized to logon
        at this time.

    STATUS_INVALID_WORKSTATION -- The user is not authorized to logon
        from the specified workstation.

    STATUS_PASSWORD_EXPIRED -- The password for the user has expired.

    STATUS_ACCOUNT_DISABLED -- The user's account has been disabled.

    .
    .
    .

--*/
{
    NTSTATUS Status;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;
    PDOMAIN_INFO DomainInfo = NULL;

    PSERVER_SESSION ServerSession;
    ULONG ServerSessionRid = 0;
    NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType;
    SESSION_INFO SessionInfo;
    NETLOGON_LOGON_INFO_CLASS OrigLogonLevel = LogonLevel;


    //
    // Initialization
    //

    *Authoritative = TRUE;
    ValidationInformation->ValidationSam = NULL;

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO)
        LogonInformation->LogonInteractive;



    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return STATUS_NETLOGON_NOT_STARTED;
    }

    //
    // Check if LogonInfo is valid.  It should be, otherwise it is
    // an unappropriate use of this function.
    //

    if ( LogonInfo == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( LogonServer );

    IF_NL_DEBUG( LOGON ) {
        NlPrintLogonParameters( DomainInfo, ComputerName, OrigLogonLevel, LogonInformation, *ExtraFlags, NULL );
    }

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Check the ValidationLevel
    //

    switch (ValidationLevel) {
    case NetlogonValidationSamInfo:
    case NetlogonValidationSamInfo2:
    case NetlogonValidationSamInfo4:
    case NetlogonValidationGenericInfo:
    case NetlogonValidationGenericInfo2:
        break;

    default:
        *Authoritative = TRUE;
        Status = STATUS_INVALID_INFO_CLASS;
        goto Cleanup;
    }

    //
    // Check the LogonLevel
    //

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonInteractiveTransitiveInformation:
    case NetlogonNetworkInformation:
    case NetlogonNetworkTransitiveInformation:
    case NetlogonServiceInformation:
    case NetlogonServiceTransitiveInformation:

        //
        // Check that the ValidationLevel is consistent with the LogonLevel
        //
        switch (ValidationLevel) {
        case NetlogonValidationSamInfo:
        case NetlogonValidationSamInfo2:
        case NetlogonValidationSamInfo4:
            break;

        default:
            *Authoritative = TRUE;
            Status = STATUS_INVALID_INFO_CLASS;
            goto Cleanup;
        }

        break;

    case NetlogonGenericInformation:

        //
        // Check that the ValidationLevel is consistent with the LogonLevel
        //

        switch (ValidationLevel) {
        case NetlogonValidationGenericInfo:
        case NetlogonValidationGenericInfo2:
            break;

        default:
            *Authoritative = TRUE;
            Status = STATUS_INVALID_INFO_CLASS;
            goto Cleanup;
        }

        break;

    default:
        *Authoritative = TRUE;
        Status = STATUS_INVALID_INFO_CLASS;
        goto Cleanup;
    }


    //
    // If we're being called from the MSV Authentication Package,
    //  require SE_TCB privilege.
    //

    if ( InProcessCall ) {

        //
        // ??: Do as I said
        //

        SecureChannelType = MsvApSecureChannel;
        SessionInfo.NegotiatedFlags = NETLOGON_SUPPORTS_MASK;
        ServerSessionRid = DomainInfo->DomDcComputerAccountRid;


    //
    // If we're being called from another Netlogon Server,
    //  Verify the secure channel information.
    //

    } else {

        //
        // This API is not supported on workstations.
        //

        if ( NlGlobalMemberWorkstation ) {
            Status = STATUS_NOT_SUPPORTED;
            goto Cleanup;
        }

        //
        // Arguments are no longer optional.
        //
        // Either the authenticators must be present or the Context handle must be.
        //

        if ( LogonServer == NULL ||
             ComputerName == NULL ||
             (( Authenticator == NULL || ReturnAuthenticator == NULL ) &&
                ContextHandle == NULL ) ) {

            *Authoritative = TRUE;
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Find the server session entry for this session.
        //

        LOCK_SERVER_SESSION_TABLE( DomainInfo );
        ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

        if (ServerSession == NULL) {
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
            *Authoritative = FALSE;
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        //
        // now verify the Authenticator and update seed if OK
        //

        if ( Authenticator != NULL ) {

            Status = NlCheckAuthenticator( ServerSession,
                                           Authenticator,
                                           ReturnAuthenticator);

            if ( !NT_SUCCESS(Status) ) {
                UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
                *Authoritative = FALSE;
                goto Cleanup;
            }

        //
        // If no authenticator,
        //  ensure the caller used secure RPC.
        //
        } else {
            NET_API_STATUS NetStatus;

            ULONG AuthnLevel;
            ULONG AuthnSvc;

            //
            // Determine the client binding info.
            //
            // Don't ask for RPC priviledges (second argument).
            //  If you ever need to, support SECPKG_ATTR_DCE_INFO
            //  in QueryContextAttributesW as this is what
            //  RpcBindingInqAuthClient will query for.
            //

            NetStatus = RpcBindingInqAuthClient(
                                ContextHandle,
                                NULL,   // Priviledges not needed
                                NULL,   // SPN not needed
                                &AuthnLevel,
                                &AuthnSvc,
                                NULL );

            if ( NetStatus != NO_ERROR ) {
                UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
                *Authoritative = FALSE;
                NlPrintDom((NL_CRITICAL, DomainInfo,
                    "SamLogon: %s logon of %wZ\\%wZ from %wZ: Cannot RpcBindingInqAuthClient %ld\n",
                    NlpLogonTypeToText( OrigLogonLevel ),
                    &LogonInfo->LogonDomainName,
                    &LogonInfo->UserName,
                    &LogonInfo->Workstation,
                    NetStatus ));
                Status = NetpApiStatusToNtStatus( NetStatus );
                goto Cleanup;
            }

            //
            // Ensure we're using the netlogon SSPI and
            //  are signing or sealing.
            //

            if ( AuthnSvc != RPC_C_AUTHN_NETLOGON ) {
                UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
                NlPrintDom((NL_CRITICAL, DomainInfo,
                    "SamLogon: %s logon of %wZ\\%wZ from %wZ: Not using Netlogon SSPI: %ld\n",
                    NlpLogonTypeToText( OrigLogonLevel ),
                    &LogonInfo->LogonDomainName,
                    &LogonInfo->UserName,
                    &LogonInfo->Workstation,
                    AuthnSvc ));
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }

            if ( AuthnLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY &&
                 AuthnLevel != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY ) {

                UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

                NlPrintDom((NL_CRITICAL, DomainInfo,
                    "SamLogon: %s logon of %wZ\\%wZ from %wZ: Not signing or sealing: %ld\n",
                    NlpLogonTypeToText( OrigLogonLevel ),
                    &LogonInfo->LogonDomainName,
                    &LogonInfo->UserName,
                    &LogonInfo->Workstation,
                    AuthnLevel ));
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }

        }


        SecureChannelType = ServerSession->SsSecureChannelType;
        SessionInfo.SessionKey = ServerSession->SsSessionKey;
        SessionInfo.NegotiatedFlags = ServerSession->SsNegotiatedFlags;
        ServerSessionRid = ServerSession->SsAccountRid;

        //
        // The cross forest hop bit is only valid if this TDO on FOREST_TRANSITIVE trusts
        //


        if ( ((*ExtraFlags) & NL_EXFLAGS_CROSS_FOREST_HOP) != 0 &&
             (ServerSession->SsFlags & SS_FOREST_TRANSITIVE) == 0 ) {

            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

            NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                    "NlpLogonSamLogon: %ws failed because F bit isn't set on the TDO\n",
                    ComputerName ));
            *Authoritative = TRUE;
            Status = STATUS_NO_SUCH_USER;
            goto Cleanup;
        }
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

        //
        // Decrypt the password information
        //

        NlpDecryptLogonInformation ( LogonLevel, (LPBYTE) LogonInfo, &SessionInfo );
    }





#ifdef _DC_NETLOGON
    //
    // If the logon service is paused then don't process this logon
    // request any further.
    //

    if ( NlGlobalServiceStatus.dwCurrentState == SERVICE_PAUSED ||
         !NlGlobalParameters.SysVolReady ||
         NlGlobalDsPaused ) {

        //
        // Don't reject logons originating inside this
        // machine.  Such requests aren't really pass-thru requests.
        //
        // Don't reject logons from a BDC in our own domain.  These logons
        // support account lockout and authentication of users whose password
        // has been updated on the PDC but not the BDC.  Such pass-thru
        // requests can only be handled by the PDC of the domain.
        //

        if ( SecureChannelType != MsvApSecureChannel &&
             SecureChannelType != ServerSecureChannel ) {

            //
            // Return STATUS_ACCESS_DENIED to convince the caller to drop the
            // secure channel to this logon server and reconnect to some other
            // logon server.
            //
            *Authoritative = FALSE;
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

    }
#endif // _DC_NETLOGON

    //
    // If this is a workstation or MSV secure channel,
    //  and the caller isn't NT 4 in a mixed mode domain
    //  ask the DC to do transitive trust.
    //
    // For NT 4 in mixed mode, avoid transitive trust since that's what they'd
    //  get if they'd stumbled upon an NT 4 BDC.
    // For NT 4 in native mode, give NT 4 the full capability.
    // For NT 5 in mixed mode, we "prefer" an NT 5 DC so do transitive trust to
    //  be as compatible with kerberos as possible.
    //

    if ( (SecureChannelType == MsvApSecureChannel || SecureChannelType == WorkstationSecureChannel) &&
         !((SessionInfo.NegotiatedFlags & ~NETLOGON_SUPPORTS_NT4_MASK) == 0 &&
           SamIMixedDomain( DomainInfo->DomSamServerHandle ) ) ) {
        switch (LogonLevel ) {
        case NetlogonInteractiveInformation:
            LogonLevel = NetlogonInteractiveTransitiveInformation; break;
        case NetlogonServiceInformation:
            LogonLevel = NetlogonServiceTransitiveInformation; break;
        case NetlogonNetworkInformation:
            LogonLevel = NetlogonNetworkTransitiveInformation; break;
        }
    }

    //
    // Validate the Request.
    //

    Status = NlpUserValidate( DomainInfo,
                              SecureChannelType,
                              ServerSessionRid,
                              LogonLevel,
                              (LPBYTE) LogonInfo,
                              ValidationLevel,
                              (LPBYTE *)&ValidationInformation->ValidationSam,
                              Authoritative,
                              ExtraFlags,
                              FALSE );  // Not a recursive call

    if ( !NT_SUCCESS(Status) ) {
        //
        // If this is an NT 3.1 client,
        //  map NT 3.5 status codes to their NT 3.1 equivalents.
        //
        // The NETLOGON_SUPPORTS_ACCOUNT_LOCKOUT bit is really the wrong bit
        // to be using, but all NT3.5 clients have it set and all NT3.1 clients
        // don't, so it'll work for our purposes.
        //

        if ( (SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_ACCOUNT_LOCKOUT) == 0 ) {
            switch ( Status ) {
            case STATUS_PASSWORD_MUST_CHANGE:
                Status = STATUS_PASSWORD_EXPIRED;
                break;
            case STATUS_ACCOUNT_LOCKED_OUT:
                Status = STATUS_ACCOUNT_DISABLED;
                break;
            }
        }

        //
        // STATUS_AUTHENTICATION_FIREWALL_FAILED was introduced for .NET (Whistler server).
        //  If this is an older client (XP (Whistler client) or older), return a generic
        //  STATUS_NO_SUCH_USER.
        //
        // Note that this code is currently not quite working because there have been
        //  no new negotiated flag added for .NET so far. So, XP client may still get
        //  the new status code. If a new .NET flag is added, this problem will be solved.
        //  Otherwise, if this is a critical issue, it can be solved by adding a new
        //  negotiated flag in .NET just for this (seems like a overkill, though).
        //
        if ( Status == STATUS_AUTHENTICATION_FIREWALL_FAILED ) {
            if ( (SessionInfo.NegotiatedFlags & ~NETLOGON_SUPPORTS_XP_MASK) == 0 ) {
                Status = STATUS_NO_SUCH_USER;
            }
        }
        goto Cleanup;
    }

    NlAssert( !NT_SUCCESS(Status) || Status == STATUS_SUCCESS );
    NlAssert( !NT_SUCCESS(Status) || ValidationInformation->ValidationSam != NULL );



    //
    // If the validation information is being returned to a client on another
    // machine, encrypt it before sending it over the wire.
    //

    if ( SecureChannelType != MsvApSecureChannel ) {
        NlpEncryptValidationInformation (
                LogonLevel,
                ValidationLevel,
                *((LPBYTE *) ValidationInformation),
                &SessionInfo  );
    }


    Status = STATUS_SUCCESS;

    //
    // Cleanup up before returning.
    //

Cleanup:
    if ( !NT_SUCCESS(Status) ) {
        if (ValidationInformation->ValidationSam != NULL) {
            MIDL_user_free( ValidationInformation->ValidationSam );
            ValidationInformation->ValidationSam = NULL;
        }
    }


    IF_NL_DEBUG( LOGON ) {
        NlPrintLogonParameters( DomainInfo, ComputerName, OrigLogonLevel, LogonInformation, *ExtraFlags, &Status );
    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    //
    // Indicate that the calling thread has left netlogon.dll
    //

    NlEndNetlogonCall();

    return Status;
}


NTSTATUS
NetrLogonSamLogon (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PNETLOGON_LEVEL LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PNETLOGON_VALIDATION ValidationInformation,
    OUT PBOOLEAN Authoritative
)
/*++

Routine Description:

    Non_concurrent implementation of NTLM passthrough logon API.

Arguments:

    See NlpLogonSamLogon.

Return Value:

    See NlpLogonSamLogon.

--*/
{
    ULONG ExtraFlags = 0;

    return NlpLogonSamLogon( NULL,  // No ContextHandle,
                             LogonServer,
                             ComputerName,
                             Authenticator,
                             ReturnAuthenticator,
                             LogonLevel,
                             LogonInformation,
                             ValidationLevel,
                             ValidationInformation,
                             Authoritative,
                             &ExtraFlags,
                             FALSE );  // in-proc call?

}


NTSTATUS
NetILogonSamLogon (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PNETLOGON_LEVEL LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PNETLOGON_VALIDATION ValidationInformation,
    OUT PBOOLEAN Authoritative
)
/*++

Routine Description:

    In-process version of NetrLogonSamLogon

Arguments:

    See NlpLogonSamLogon.

Return Value:

    See NlpLogonSamLogon.

--*/
{
    ULONG ExtraFlags = 0;

    return NlpLogonSamLogon( NULL,  // No ContextHandle,
                             LogonServer,
                             ComputerName,
                             Authenticator,
                             ReturnAuthenticator,
                             LogonLevel,
                             LogonInformation,
                             ValidationLevel,
                             ValidationInformation,
                             Authoritative,
                             &ExtraFlags,
                             TRUE );  // in-proc call?

}


NTSTATUS
NetrLogonSamLogonWithFlags (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PNETLOGON_LEVEL LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PNETLOGON_VALIDATION ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags
)
/*++

Routine Description:

    Non_concurrent implementation of NTLM passthrough logon API (with flags)

Arguments:

    See NlpLogonSamLogon.

Return Value:

    See NlpLogonSamLogon.

--*/
{

    return NlpLogonSamLogon( NULL,  // No ContextHandle,
                             LogonServer,
                             ComputerName,
                             Authenticator,
                             ReturnAuthenticator,
                             LogonLevel,
                             LogonInformation,
                             ValidationLevel,
                             ValidationInformation,
                             Authoritative,
                             ExtraFlags,
                             FALSE );  // in-proc call?

}


NTSTATUS
NetrLogonSamLogonEx (
    IN handle_t ContextHandle,
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PNETLOGON_LEVEL LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PNETLOGON_VALIDATION ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags
)
/*++

Routine Description:

    Concurrent implementation of NTLM passthrough logon API.

Arguments:

    See NlpLogonSamLogon.

Return Value:

    See NlpLogonSamLogon.

--*/
{

    //
    // Sanity check to ensure we don't lead the common routine astray.
    //

    if ( ContextHandle == NULL ) {
        return STATUS_ACCESS_DENIED;
    }

    return NlpLogonSamLogon( ContextHandle,
                             LogonServer,
                             ComputerName,
                             NULL,  // Authenticator
                             NULL,  // ReturnAuthenticator
                             LogonLevel,
                             LogonInformation,
                             ValidationLevel,
                             ValidationInformation,
                             Authoritative,
                             ExtraFlags,
                             FALSE );  // in-proc call?

}


NTSTATUS
NetrLogonSamLogoff (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PNETLOGON_LEVEL LogonInformation
)
/*++

Routine Description:

    This function is called by an NT client to process an interactive
    logoff.  It is not called for the network logoff case since the
    Netlogon service does not maintain any context for network logons.

    This function does the following.  It authenticates the request.  It
    updates the logon statistics in the SAM database on whichever machine
    or domain defines this user account.  It updates the logon session
    table in the primary domain of the machine making the request.  And
    it returns logoff information to the caller.

    This function is called in same scenarios that I_NetLogonSamLogon is
    called:

      *  It is called by the LSA's MSV1_0 authentication package to
         support LsaApLogonTerminated.  In this case, this function is a
         local function and requires the caller to have SE_TCB privilege.
         The local Netlogon service will either handle this request
         directly (if LogonDomainName indicates this request was
         validated locally) or will forward this request to the
         appropriate domain controller as documented in sections 2.4 and
         2.5.

      *  It is called by a Netlogon service on a workstation to a DC in
         the Primary Domain of the workstation as documented in section
         2.4.  In this case, this function uses a secure channel set up
         between the two Netlogon services.

      *  It is called by a Netlogon service on a DC to a DC in a trusted
         domain as documented in section 2.5.  In this case, this
         function uses a secure channel set up between the two Netlogon
         services.

    When this function is a remote function, it is sent to the DC over a
    NULL session.

Arguments:

    LogonServer -- Supplies the name of the logon server which logged
        this user on.  This field should be null to indicate this is
        a call from the MSV1_0 authentication package to the local
        Netlogon service.

    ComputerName -- Name of the machine making the call.  This field
        should be null to indicate this is a call from the MSV1_0
        authentication package to the local Netlogon service.

    Authenticator -- supplied by the client.  This field should be
        null to indicate this is a call from the MSV1_0
        authentication package to the local Netlogon service.

    ReturnAuthenticator -- Receives an authenticator returned by the
        server.  This field should be null to indicate this is a call
        from the MSV1_0 authentication package to the local Netlogon
        service.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the logon domain name, logon Id,
        user name and workstation name of the user logging off.

Return Value:

--*/
{
    NTSTATUS Status;
    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;

    PDOMAIN_INFO DomainInfo = NULL;
#ifdef _DC_NETLOGON
    PSERVER_SESSION ServerSession;
#endif // _DC_NETLOGON
    NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType;
    PCLIENT_SESSION ClientSession;

    //
    // Initialization
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO)
        LogonInformation->LogonInteractive;

    //
    // Check if LogonInfo is valid.  It should be, otherwise it is
    // an unappropriate use of this function.
    //

    if ( LogonInfo == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }


    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return STATUS_NETLOGON_NOT_STARTED;
    }


    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( LogonServer );

#if NETLOGONDBG
    NlPrintDom((NL_LOGON, DomainInfo,
            "NetrLogonSamLogoff: %s logoff of %wZ\\%wZ from %wZ Entered\n",
            NlpLogonTypeToText( LogonLevel ),
            &LogonInfo->LogonDomainName,
            &LogonInfo->UserName,
            &LogonInfo->Workstation ));
#endif // NETLOGONDBG

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Check the LogonLevel
    //

    if ( LogonLevel != NetlogonInteractiveInformation ) {
        Status = STATUS_INVALID_INFO_CLASS;
        goto Cleanup;
    }


    //
    //  Sanity check the username and domain name.
    //

    if ( LogonInfo->UserName.Length == 0 ||
         LogonInfo->UserName.Buffer == NULL ||
         LogonInfo->LogonDomainName.Length == 0 ||
         LogonInfo->LogonDomainName.Buffer == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }



    //
    // If we've been called from the local msv1_0,
    //  special case the secure channel type.
    //

    if ( LogonServer == NULL &&
         ComputerName == NULL &&
         Authenticator == NULL &&
         ReturnAuthenticator == NULL ) {

        //
        // msv1_0 no longer calls this routine, so
        // disable this code path.
        //
        // SecureChannelType = MsvApSecureChannel;
        //

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;


    //
    // If we're being called from another Netlogon Server,
    //  Verify the secure channel information.
    //

    } else {

        //
        // This API is not supported on workstations.
        //

        if ( NlGlobalMemberWorkstation ) {
            Status = STATUS_NOT_SUPPORTED;
            goto Cleanup;
        }

        //
        // Arguments are no longer optional.
        //

        if ( LogonServer == NULL ||
             ComputerName == NULL ||
             Authenticator == NULL ||
             ReturnAuthenticator == NULL ) {

            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Find the server session entry for this secure channel.
        //

        LOCK_SERVER_SESSION_TABLE( DomainInfo );
        ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

        if (ServerSession == NULL) {
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        //
        // Now verify the Authenticator and update seed if OK
        //

        Status = NlCheckAuthenticator(
                     ServerSession,
                     Authenticator,
                     ReturnAuthenticator);

        if ( !NT_SUCCESS(Status) ) {
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
            goto Cleanup;
        }

        SecureChannelType = ServerSession->SsSecureChannelType;

        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

    }


    //
    // If this is the domain that logged this user on,
    //  update the logon statistics.
    //

    if ( RtlEqualDomainName( &LogonInfo->LogonDomainName,
                             &DomainInfo->DomUnicodeAccountDomainNameString ) ) {

        Status = MsvSamLogoff(
                    DomainInfo->DomSamAccountDomainHandle,
                    LogonLevel,
                    LogonInfo );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

    //
    // If this is not the domain that logged this user on,
    //  pass the request to a higher authority.
    //

    } else {

        //
        // If this machine is a workstation,
        //  send the request to the Primary Domain.
        //

        if ( NlGlobalMemberWorkstation ) {

            ClientSession = NlRefDomClientSession( DomainInfo );

            if ( ClientSession == NULL  ) {
                Status = STATUS_TRUSTED_RELATIONSHIP_FAILURE;
                goto Cleanup;
            }

            Status = NlpUserLogoffHigher(
                        ClientSession,
                        LogonLevel,
                        (LPBYTE) LogonInfo );

            NlUnrefClientSession( ClientSession );

            //
            // return more appropriate error
            //

            if( (Status == STATUS_NO_TRUST_SAM_ACCOUNT) ||
                (Status == STATUS_ACCESS_DENIED) ) {

                Status = STATUS_TRUSTED_RELATIONSHIP_FAILURE;
            }

            goto Cleanup;


        //
        // This machine is a Domain Controller.
        //
        // This request is either a pass-thru request by a workstation in
        // our domain, or this request came directly from the MSV
        // authentication package.
        //
        // In either case, pass the request to the trusted domain.
        //

        } else {
            BOOLEAN TransitiveUsed;


            //
            // Send the request to the appropriate Trusted Domain.
            //
            // Find the ClientSession structure for the domain.
            //

            ClientSession =
                    NlFindNamedClientSession( DomainInfo,
                                              &LogonInfo->LogonDomainName,
                                              NL_RETURN_CLOSEST_HOP,
                                              &TransitiveUsed );

            if ( ClientSession == NULL ) {
                Status = STATUS_NO_SUCH_DOMAIN;
                goto Cleanup;
            }

            //
            // If this request was passed to us from a trusted domain,
            //  Check to see if it is OK to pass the request further.
            //

            if ( IsDomainSecureChannelType( SecureChannelType ) ) {

                //
                // If the trust isn't an NT 5.0 trust,
                //  avoid doing the trust transitively.
                //
                LOCK_TRUST_LIST( DomainInfo );
                if ( (ClientSession->CsFlags & CS_NT5_DOMAIN_TRUST ) == 0 ) {
                    UNLOCK_TRUST_LIST( DomainInfo );
                    NlPrintCs((NL_LOGON, ClientSession,
                        "SamLogoff: Avoid transitive trust on NT 4 trust." ));
                    NlUnrefClientSession( ClientSession );
                    Status = STATUS_NO_SUCH_USER;
                    goto Cleanup;
                }
                UNLOCK_TRUST_LIST( DomainInfo );

            }

            Status = NlpUserLogoffHigher(
                            ClientSession,
                            LogonLevel,
                            (LPBYTE) LogonInfo );

            NlUnrefClientSession( ClientSession );

            //
            // return more appropriate error
            //

            if( (Status == STATUS_NO_TRUST_LSA_SECRET) ||
                (Status == STATUS_NO_TRUST_SAM_ACCOUNT) ||
                (Status == STATUS_ACCESS_DENIED) ) {

                Status = STATUS_TRUSTED_DOMAIN_FAILURE;
            }

        }
    }

Cleanup:

    //
    // If the request failed, be carefull to not leak authentication
    // information.
    //

    if ( Status == STATUS_ACCESS_DENIED )  {
        if ( ReturnAuthenticator != NULL ) {
            RtlSecureZeroMemory( ReturnAuthenticator, sizeof(*ReturnAuthenticator) );
        }

    }


#if NETLOGONDBG
    NlPrintDom((NL_LOGON, DomainInfo,
            "NetrLogonSamLogoff: %s logoff of %wZ\\%wZ from %wZ returns %lX\n",
            NlpLogonTypeToText( LogonLevel ),
            &LogonInfo->LogonDomainName,
            &LogonInfo->UserName,
            &LogonInfo->Workstation,
            Status ));
#endif // NETLOGONDBG
    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    //
    // Indicate that the calling thread has left netlogon.dll
    //

    NlEndNetlogonCall();

    return Status;
}

NTSTATUS NET_API_FUNCTION
NetrLogonSendToSam (
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN LPBYTE OpaqueBuffer,
    IN ULONG OpaqueBufferSize
)
/*++

Routine Description:

    This function sends an opaque buffer from SAM on a BDC to SAM on the PDC.

    The original use of this routine will be to allow the BDC to forward user
    account password changes to the PDC.


Arguments:

    PrimaryName -- Computer name of the PDC to remote the call to.

    ComputerName -- Name of the machine making the call.

    Authenticator -- supplied by the client.

    ReturnAuthenticator -- Receives an authenticator returned by the
        server.

    OpaqueBuffer - Buffer to be passed to the SAM service on the PDC.
        The buffer will be encrypted on the wire.

    OpaqueBufferSize - Size (in bytes) of OpaqueBuffer.

Return Value:

    STATUS_SUCCESS: Message successfully sent to PDC

    STATUS_NO_MEMORY: There is not enough memory to complete the operation

    STATUS_NO_SUCH_DOMAIN: DomainName does not correspond to a hosted domain

    STATUS_NO_LOGON_SERVERS: PDC is not currently available

    STATUS_NOT_SUPPORTED: PDC does not support this operation

--*/
{
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;

    PSERVER_SESSION ServerSession;
    SESSION_INFO SessionInfo;


    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        return STATUS_NOT_SUPPORTED;
    }


    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( PrimaryName );

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrLogonSendToSam: %ws: Entered\n",
            ComputerName ));

    if ( DomainInfo == NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // This call is only allowed to a PDC.
    //

    if ( DomainInfo->DomRole != RolePrimary ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NetrLogonSendToSam: Call only valid to a PDC.\n" ));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Get the Session key for this session.
    //

    LOCK_SERVER_SESSION_TABLE( DomainInfo );
    ServerSession = NlFindNamedServerSession( DomainInfo, ComputerName );

    if (ServerSession == NULL) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    SessionInfo.SessionKey = ServerSession->SsSessionKey;
    SessionInfo.NegotiatedFlags = ServerSession->SsNegotiatedFlags;


    //
    // now verify the Authenticator and update seed if OK
    //

    Status = NlCheckAuthenticator( ServerSession,
                                   Authenticator,
                                   ReturnAuthenticator);

    if ( !NT_SUCCESS(Status) ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        goto Cleanup;
    }


    //
    // Call is only allowed from a BDC.
    //

    if ( ServerSession->SsSecureChannelType != ServerSecureChannel ) {
        UNLOCK_SERVER_SESSION_TABLE( DomainInfo );
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NetrLogonSendToSam: Call only valid from a BDC.\n" ));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }
    UNLOCK_SERVER_SESSION_TABLE( DomainInfo );


    //
    // Decrypt the message before passing it to SAM
    //

    NlDecryptRC4( OpaqueBuffer,
                  OpaqueBufferSize,
                  &SessionInfo );


// #ifdef notdef
    Status = SamISetPasswordInfoOnPdc(
                           DomainInfo->DomSamAccountDomainHandle,
                           OpaqueBuffer,
                           OpaqueBufferSize );
// #endif // notdef

    if ( !NT_SUCCESS( Status )) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NetrLogonSendToSam: Cannot NewCallToSam %lX\n",
                Status));
        goto Cleanup;
    }


    Status = STATUS_SUCCESS;

    //
    // Common exit point
    //

Cleanup:

    //
    // If the request failed, be carefull to not leak authentication
    // information.
    //

    if ( Status == STATUS_ACCESS_DENIED )  {
        RtlSecureZeroMemory( ReturnAuthenticator, sizeof(*ReturnAuthenticator) );
    }

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NetrLogonSendToSam: %ws: returns 0x%lX\n",
            ComputerName,
            Status ));

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return Status;
}




NTSTATUS
I_NetLogonSendToSamOnPdc(
    IN LPWSTR DomainName,
    IN LPBYTE OpaqueBuffer,
    IN ULONG OpaqueBufferSize
    )
/*++

Routine Description:

    This function sends an opaque buffer from SAM on a BDC to SAM on the PDC of
    the specified domain.

    The original use of this routine will be to allow the BDC to forward user
    account password changes to the PDC.

    The function will not send any buffer from BDC to PDC which are on different
    sites provided the registry value of AvoidPdcOnWan has been set to TRUE.


Arguments:

    DomainName - Identifies the hosted domain that this request applies to.
        DomainName may be the Netbios domain name or the DNS domain name.
        NULL implies the primary domain hosted by this DC.

    OpaqueBuffer - Buffer to be passed to the SAM service on the PDC.
        The buffer will be encrypted on the wire.

    OpaqueBufferSize - Size (in bytes) of OpaqueBuffer.

Return Value:

    STATUS_SUCCESS: Message successfully sent to PDC

    STATUS_NO_MEMORY: There is not enough memory to complete the operation

    STATUS_NO_SUCH_DOMAIN: DomainName does not correspond to a hosted domain

    STATUS_NO_LOGON_SERVERS: PDC is not currently available

    STATUS_NOT_SUPPORTED: PDC does not support this operation

--*/
{
    NTSTATUS Status;
    NETLOGON_AUTHENTICATOR OurAuthenticator;
    NETLOGON_AUTHENTICATOR ReturnAuthenticator;
    PDOMAIN_INFO DomainInfo = NULL;
    PCLIENT_SESSION ClientSession = NULL;
    SESSION_INFO SessionInfo;
    BOOLEAN FirstTry = TRUE;
    BOOLEAN AmWriter = FALSE;
    BOOLEAN IsSameSite;
    LPBYTE EncryptedBuffer = NULL;
    ULONG EncryptedBufferSize;


    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return STATUS_NETLOGON_NOT_STARTED;
    }

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "I_NetLogonSendToSamOnPdc: Sending buffer to PDC of %ws\n",
            DomainName ));
    NlpDumpBuffer( NL_SESSION_MORE, OpaqueBuffer, OpaqueBufferSize );

    //
    // Find the Hosted domain.
    //

    DomainInfo = NlFindDomain( DomainName, NULL, FALSE );

    if ( DomainInfo == NULL ) {
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Ensure this is a BDC.
    //

    if ( DomainInfo->DomRole != RoleBackup ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "I_NetLogonSendToSamOnPdc: not allowed on PDC.\n"));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    //
    // If the registry value of AvoidPdcOnWan is TRUE and PDC is on a remote site,
    // do not send anything and return with a success.
    //

    if ( NlGlobalParameters.AvoidPdcOnWan ) {

        //
        // Determine whether the PDC is in the same site
        //

        Status = SamISameSite( &IsSameSite );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom(( NL_CRITICAL,  DomainInfo,
                         "I_NetLogonSendToSamOnPdc: Cannot SamISameSite.\n" ));
            goto Cleanup;
        }

        if ( !IsSameSite ) {
            NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                    "I_NetLogonSendToSamOnPdc: Ignored sending to a PDC on a remote site.\n"));
            Status = STATUS_SUCCESS;
            goto Cleanup;
        } else {
            NlPrintDom((NL_SESSION_SETUP, DomainInfo,
                    "I_NetLogonSendToSamOnPdc: BDC and PDC are on the same site.\n"));
        }

    }


    //
    // Reference the client session.
    //

    ClientSession = NlRefDomClientSession( DomainInfo );

    if ( ClientSession == NULL ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "I_NetLogonSendToSamOnPdc: This BDC has no client session with the PDC.\n"));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }



    //
    // Become a Writer of the ClientSession.
    //

    if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "I_NetLogonSendToSamOnPdc: Can't become writer of client session.\n"));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    AmWriter = TRUE;



    //
    // If the session isn't authenticated,
    //  do so now.
    //
FirstTryFailed:
    Status = NlEnsureSessionAuthenticated( ClientSession, 0 );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    SessionInfo.SessionKey = ClientSession->CsSessionKey;
    SessionInfo.NegotiatedFlags = ClientSession->CsNegotiatedFlags;

    //
    // If the PDC doesn't support the new function,
    //  fail now.
    //

    if ( (SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_PDC_PASSWORD) == 0 ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "I_NetLogonSendToSamOnPdc: %ws: PDC doesn't support this function.\n",
                DomainName ));
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }


    //
    // Build the Authenticator for this request to the PDC.
    //

    NlBuildAuthenticator(
                    &ClientSession->CsAuthenticationSeed,
                    &ClientSession->CsSessionKey,
                    &OurAuthenticator);

    //
    // Encrypt the data before we send it on the wire.
    //

    if ( EncryptedBuffer != NULL ) {
        LocalFree( EncryptedBuffer );
        EncryptedBuffer = NULL;
    }

    EncryptedBufferSize = OpaqueBufferSize;
    EncryptedBuffer = LocalAlloc( 0, OpaqueBufferSize );

    if ( EncryptedBuffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( EncryptedBuffer, OpaqueBuffer, OpaqueBufferSize );

    NlEncryptRC4( EncryptedBuffer,
                  EncryptedBufferSize,
                  &SessionInfo );



    //
    // Change the password on the machine our connection is to.
    //

    NL_API_START( Status, ClientSession, TRUE ) {

        NlAssert( ClientSession->CsUncServerName != NULL );
        Status = I_NetLogonSendToSam( ClientSession->CsUncServerName,
                                      ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                                      &OurAuthenticator,
                                      &ReturnAuthenticator,
                                      EncryptedBuffer,
                                      EncryptedBufferSize );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintRpcDebug( "I_NetLogonSendToSam", Status );
        }

    // NOTE: This call may drop the secure channel behind our back
    } NL_API_ELSE( Status, ClientSession, TRUE ) {
    } NL_API_END;


    //
    // Now verify primary's authenticator and update our seed
    //

    if ( NlpDidDcFail( Status ) ||
         !NlUpdateSeed( &ClientSession->CsAuthenticationSeed,
                        &ReturnAuthenticator.Credential,
                        &ClientSession->CsSessionKey) ) {

        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "I_NetLogonSendToSamOnPdc: denying access after status: 0x%lx\n",
                    Status ));

        //
        // Preserve any status indicating a communication error.
        //

        if ( NT_SUCCESS(Status) ) {
            Status = STATUS_ACCESS_DENIED;
        }
        NlSetStatusClientSession( ClientSession, Status );

        //
        // Perhaps the netlogon service on the server has just restarted.
        //  Try just once to set up a session to the server again.
        //
        if ( FirstTry ) {
            FirstTry = FALSE;
            goto FirstTryFailed;
        }
    }


    //
    // Common exit
    //

Cleanup:
    if ( ClientSession != NULL ) {
        if ( AmWriter ) {
            NlResetWriterClientSession( ClientSession );
        }
        NlUnrefClientSession( ClientSession );
    }

    if ( EncryptedBuffer != NULL ) {
        LocalFree( EncryptedBuffer );
        EncryptedBuffer = NULL;
    }

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "I_NetLogonSendToSamOnPdc: %ws: failed %lX\n",
                DomainName,
                Status));
    }
    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    //
    // Indicate that the calling thread has left netlogon.dll
    //

    NlEndNetlogonCall();

    return Status;
}




NTSTATUS
I_NetLogonGetDirectDomain(
    IN LPWSTR HostedDomainName,
    IN LPWSTR TrustedDomainName,
    OUT LPWSTR *DirectDomainName
    )
/*++

Routine Description:

    This function returns the name of a domain in the enterprise and returns
    the name of a domain that is one hop closer.

Arguments:

    HostedDomainName - Identifies the hosted domain that this request applies to.
        DomainName may be the Netbios domain name or the DNS domain name.
        NULL implies the primary domain hosted by this machine.

    TrustedDomainName - Identifies the domain the trust relationship is to.
        DomainName may be the Netbios domain name or the DNS domain name.

    DirectDomainName - Returns the DNS domain name of the domain that is
        one hop closer to TrustedDomainName.  If there is a direct trust to
        TrustedDomainName, NULL is returned.
        The buffer must be freed using I_NetLogonFree.


Return Value:

    STATUS_SUCCESS: The auth data was successfully returned.

    STATUS_NO_MEMORY: There is not enough memory to complete the operation

    STATUS_NETLOGON_NOT_STARTED: Netlogon is not running

    STATUS_NO_SUCH_DOMAIN: HostedDomainName does not correspond to a hosted domain, OR
        TrustedDomainName is not a trusted domain.

--*/
{
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;
    PCLIENT_SESSION ClientSession = NULL;
    BOOLEAN TransitiveUsed;

    UNICODE_STRING TrustedDomainNameString;



    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    *DirectDomainName = NULL;
    if ( !NlStartNetlogonCall() ) {
        return STATUS_NETLOGON_NOT_STARTED;
    }



    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "I_NetLogonDirectDomainName: %ws %ws\n",
            HostedDomainName,
            TrustedDomainName ));

    //
    // Find the Hosted domain.
    //

    DomainInfo = NlFindDomain( HostedDomainName, NULL, FALSE );

    if ( DomainInfo == NULL ) {
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }



    //
    // Reference the client session.
    //

    RtlInitUnicodeString( &TrustedDomainNameString, TrustedDomainName );
    ClientSession = NlFindNamedClientSession( DomainInfo,
                                              &TrustedDomainNameString,
                                              NL_RETURN_CLOSEST_HOP,
                                              &TransitiveUsed );

    if ( ClientSession == NULL ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "I_NetLogonDirectDomainName: %ws: No such trusted domain\n",
                TrustedDomainName ));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }


    //
    // If this is a transitive trust,
    //  return the name of the domain to the caller.
    //

    if ( TransitiveUsed ) {
        LOCK_TRUST_LIST( DomainInfo );
        if ( ClientSession->CsDnsDomainName.Buffer != NULL ) {
            *DirectDomainName =
                NetpAllocWStrFromWStr( ClientSession->CsDnsDomainName.Buffer );
        } else {
            UNLOCK_TRUST_LIST( DomainInfo );
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "I_NetLogonDirectDomainName: %ws: No DNS domain name\n",
                    TrustedDomainName ));
            Status = STATUS_NO_SUCH_DOMAIN;
            goto Cleanup;
        }
        UNLOCK_TRUST_LIST( DomainInfo );

        if ( *DirectDomainName == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
    }


    //
    // Common exit
    //

    Status = STATUS_SUCCESS;

Cleanup:
    if ( ClientSession != NULL ) {
        NlUnrefClientSession( ClientSession );
    }


    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "I_NetLogonDirectDomainName: %ws: failed %lX\n",
                TrustedDomainName,
                Status));
    }
    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }


    //
    // Indicate that the calling thread has left netlogon.dll
    //

    NlEndNetlogonCall();

    return Status;
}


NTSTATUS
I_NetLogonGetAuthDataEx(
    IN LPWSTR HostedDomainName OPTIONAL,
    IN LPWSTR TrustedDomainName,
    IN ULONG Flags,
    IN PLARGE_INTEGER FailedSessionSetupTime OPTIONAL,
    OUT LPWSTR *OurClientPrincipleName,
    OUT PVOID *ClientContext OPTIONAL,
    OUT LPWSTR *ServerName,
    OUT PNL_OS_VERSION ServerOsVersion,
    OUT PULONG AuthnLevel,
    OUT PLARGE_INTEGER SessionSetupTime
    )
/*++

Routine Description:

    This function returns the data that a caller could passed to
    RpcBindingSetAuthInfoW to do an RPC call using the Netlogon security package.

    The returned data is valid for the life of Netlogon's secure channel to
    the current DC.  There is no way for the caller to determine that lifetime.
    So, the caller should be prepared for access to be denied and respond to that
    by calling I_NetLogonGetAuthData again.  This condition is indicated by passing
    the timestamp of the previuosly used secure channel session setup.

    Once the returned data is passed to RpcBindingSetAuthInfoW, the data should
    not be deallocated until after the binding handle is closed.

Arguments:

    HostedDomainName - Identifies the hosted domain that this request applies to.
        May be the Netbios domain name or the DNS domain name.
        NULL implies the primary domain hosted by this machine.

    TrustedDomainName - Identifies the domain the trust relationship is to.
        May be the Netbios domain name or the DNS domain name.

    Flags - Flags defining which ClientContext to return:

        NL_DIRECT_TRUST_REQUIRED: Indicates that STATUS_NO_SUCH_DOMAIN should be returned
            if TrustedDomainName is not directly trusted.

        NL_RETURN_CLOSEST_HOP: Indicates that for indirect trust, the "closest hop"
            session should be returned rather than the actual session

        NL_ROLE_PRIMARY_OK: Indicates that if this is a PDC, it's OK to return
            the client session to the primary domain.

        NL_REQUIRE_DOMAIN_IN_FOREST - Indicates that STATUS_NO_SUCH_DOMAIN should be
            returned if TrustedDomainName is not a domain in the forest.

    FailedSessionSetupTime - The time of the previous session setup to the server
        that the caller detected as no longer available. If this parameter is
        passed, the secure channel will be reset by this routine unless the timestamp
        on the current secure channel is different from the one passed by the caller
        (in which case the secure channel got already reset between the two calls to
        this routine).

    OurClientPrincipleName - The principle name of this machine (which is a client as far
        as authenication is concerned). This is the ServerPrincipleName parameter to pass
        to RpcBindingSetAuthInfo. Must be freed using NetApiBufferFree.

    ClientContext - Authentication data for ServerName to pass as AuthIdentity to
        RpcBindingSetAuthInfo. Must be freed using I_NetLogonFree.
        Note this OUT parameter is NULL if ServerName doesn't support this
        functionality.

    ServerName - UNC name of a DC in the trusted domain.
        The caller should RPC to the named DC.  This DC is the only DC that has the server
        side context associated with the returned ClientContext. The buffer must be freed
        using NetApiBufferFree.

    ServerOsVersion - Returns the operating system version of the DC named ServerName.

    AuthnLevel - Authentication level Netlogon will use for its secure channel. This value
        will be one of:

            RPC_C_AUTHN_LEVEL_PKT_PRIVACY: Sign and seal
            RPC_C_AUTHN_LEVEL_PKT_INTEGRITY: Sign only

        The caller can ignore this value and independently choose an authentication level.

    SessionSetupTime - The time of the secure channel session setup to the server.

Return Value:

    STATUS_SUCCESS: The auth data was successfully returned.

    STATUS_NO_MEMORY: There is not enough memory to complete the operation

    STATUS_NETLOGON_NOT_STARTED: Netlogon is not running

    STATUS_NO_SUCH_DOMAIN: HostedDomainName does not correspond to a hosted domain, OR
        TrustedDomainName is not a trusted domain corresponding to Flags.

    STATUS_NO_LOGON_SERVERS: No DCs are not currently available

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDOMAIN_INFO DomainInfo = NULL;
    PCLIENT_SESSION ClientSession = NULL;
    BOOLEAN AmWriter = FALSE;
    UNICODE_STRING TrustedDomainNameString;

    LPWSTR LocalClientPrincipleName = NULL;
    LPWSTR LocalServerName = NULL;
    PVOID LocalClientContext = NULL;
    ULONG LocalAuthnLevel = 0;
    NL_OS_VERSION LocalServerOsVersion = 0;
    LARGE_INTEGER LocalSessionSetupTime;

    ULONG IterationIndex = 0;

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return STATUS_NETLOGON_NOT_STARTED;
    }

    //
    // Find the Hosted domain.
    //

    DomainInfo = NlFindDomain( HostedDomainName, NULL, FALSE );

    if ( DomainInfo == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "I_NetLogonGetAuthData called for non-existent domain: %ws\n",
                  HostedDomainName ));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    NlPrintDom(( NL_SESSION_SETUP, DomainInfo,
                 "I_NetLogonGetAuthData called: %ws %ws (Flags 0x%lx) %s\n",
                 HostedDomainName,
                 TrustedDomainName,
                 Flags,
                 (FailedSessionSetupTime != NULL) ?
                    "(with reset)" : " " ));

    //
    // Reference the client session.
    //

    RtlInitUnicodeString( &TrustedDomainNameString, TrustedDomainName );
    ClientSession = NlFindNamedClientSession( DomainInfo,
                                              &TrustedDomainNameString,
                                              Flags,
                                              NULL );

    if ( ClientSession == NULL ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                     "I_NetLogonGetAuthData: %ws: No such trusted domain (Flags 0x%lx)\n",
                     TrustedDomainName,
                     Flags ));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Get the server principal name
    //

    LocalClientPrincipleName =
        NetpAllocWStrFromWStr( ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer );

    if ( LocalClientPrincipleName == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Get the auth level
    //

    LocalAuthnLevel = NlGlobalParameters.SealSecureChannel ?
                          RPC_C_AUTHN_LEVEL_PKT_PRIVACY :
                          RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;


    //
    // Become a Writer of the ClientSession.
    //

    if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "I_NetLogonGetAuthData: Can't become writer of client session.\n" ));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    AmWriter = TRUE;

    //
    // Ensure that session is authenticated and that
    //  it is not the one that the caller doesn't like.
    //

    for ( IterationIndex = 0; IterationIndex < 2; IterationIndex++ ) {

        //
        // If the session isn't authenticated, do so now.
        //  Note that doing this call prior to resetting the secure
        //  channel will avoid excessive channel reset due to the
        //  unexpected caller  activity. Specifically, if we already
        //  reset the session recently, this check will fail.
        //

        Status = NlEnsureSessionAuthenticated( ClientSession, 0 );
        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // On the first iteration, if this is the session that the
        //  caller doesn't like, reset the session and retry the authentication
        //

        if ( IterationIndex == 0 &&
             FailedSessionSetupTime != NULL &&
             FailedSessionSetupTime->QuadPart == ClientSession->CsLastAuthenticationTry.QuadPart ) {

            NlSetStatusClientSession( ClientSession, STATUS_NO_LOGON_SERVERS );
        } else {
            break;
        }
    }

    //
    // Get the server name
    //

    LocalServerName = NetpAllocWStrFromWStr( ClientSession->CsUncServerName );
    if ( LocalServerName == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Get the client context, if asked and available
    //

    if ( ClientContext != NULL &&
         (ClientSession->CsNegotiatedFlags & NETLOGON_SUPPORTS_LSA_AUTH_RPC) != 0 ) {
        LocalClientContext = NlBuildAuthData( ClientSession );
        if ( LocalClientContext == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Get the session setup time
    //

    LocalSessionSetupTime = ClientSession->CsLastAuthenticationTry;
    NlAssert( LocalSessionSetupTime.QuadPart != 0 );

    //
    // Determine the OS version
    //

    if ( ClientSession->CsNegotiatedFlags & ~NETLOGON_SUPPORTS_WIN2000_MASK ) {
        LocalServerOsVersion = NlWhistler;

    } else if ( ClientSession->CsNegotiatedFlags & ~NETLOGON_SUPPORTS_NT4_MASK ) {
        LocalServerOsVersion = NlWin2000;

    } else if ( ClientSession->CsNegotiatedFlags & ~NETLOGON_SUPPORTS_NT351_MASK ) {
        LocalServerOsVersion = NlNt40;

    } else if ( ClientSession->CsNegotiatedFlags != 0 ) {
        LocalServerOsVersion = NlNt351;

    } else {
        LocalServerOsVersion = NlNt35_or_older;
    }

    //
    // Common exit
    //

Cleanup:

    if ( ClientSession != NULL ) {
        if ( AmWriter ) {
            NlResetWriterClientSession( ClientSession );
        }
        NlUnrefClientSession( ClientSession );
    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    //
    // Return the data on success
    //

    if ( NT_SUCCESS(Status) ) {
        *OurClientPrincipleName = LocalClientPrincipleName;
        LocalClientPrincipleName = NULL;
        *AuthnLevel = LocalAuthnLevel;
        *ServerName = LocalServerName;
        LocalServerName = NULL;
        *ServerOsVersion = LocalServerOsVersion;
        *SessionSetupTime = LocalSessionSetupTime;

        if ( ClientContext != NULL ) {
            *ClientContext = LocalClientContext;
            LocalClientContext = NULL;
        }
    } else {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                     "I_NetLogonGetAuthData failed: %ws %ws (Flags 0x%lx)%s 0x%lx\n",
                     HostedDomainName,
                     TrustedDomainName,
                     Flags,
                     (FailedSessionSetupTime != NULL) ?
                        " (with reset):" : ":",
                     Status ));
    }

    if ( LocalClientPrincipleName != NULL ) {
        NetApiBufferFree( LocalClientPrincipleName );
    }

    if ( LocalServerName != NULL ) {
        NetApiBufferFree( LocalServerName );
    }

    if ( LocalClientContext != NULL ) {
        I_NetLogonFree( LocalClientContext );
    }

    //
    // Indicate that the calling thread has left netlogon.dll
    //

    NlEndNetlogonCall();

    return Status;
}

NET_API_STATUS
NetrGetDCName (
    IN  LPWSTR   ServerName OPTIONAL,
    IN  LPWSTR   DomainName OPTIONAL,
    OUT LPWSTR  *Buffer
    )

/*++

Routine Description:

    Get the name of the primary domain controller for a domain.

Arguments:

    ServerName - name of remote server (null for local)

    DomainName - name of domain (null for primary)

    Buffer - Returns a pointer to an allcated buffer containing the
        servername of the PDC of the domain.  The server name is prefixed
        by \\.  The buffer should be deallocated using NetApiBufferFree.

Return Value:

        NERR_Success - Success.  Buffer contains PDC name prefixed by \\.
        NERR_DCNotFound     No DC found for this domain.
        ERROR_INVALID_NAME  Badly formed domain name

--*/
{
#ifdef _WKSTA_NETLOGON
    return ERROR_NOT_SUPPORTED;
    UNREFERENCED_PARAMETER( ServerName );
    UNREFERENCED_PARAMETER( DomainName );
    UNREFERENCED_PARAMETER( Buffer );
#endif // _WKSTA_NETLOGON
#ifdef _DC_NETLOGON
    NET_API_STATUS NetStatus;
    UNREFERENCED_PARAMETER( ServerName );

    //
    // This API is not supported on workstations.
    //

    if ( NlGlobalMemberWorkstation ) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Simply call the API which handles the local case specially.
    //

    NetStatus = NetGetDCName( NULL, DomainName, (LPBYTE *)Buffer );

    return NetStatus;
#endif // _DC_NETLOGON
}


NET_API_STATUS
DsrGetDcNameEx(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN LPWSTR SiteName OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    Same as DsGetDcNameW except:

    * This is the RPC server side implementation.

Arguments:

    Same as DsGetDcNameW except as above.

Return Value:

    Same as DsGetDcNameW except as above.


--*/
{
    return DsrGetDcNameEx2( ComputerName,
                            NULL,   // No Account name
                            0,      // No Allowable account control bits
                            DomainName,
                            DomainGuid,
                            SiteName,
                            Flags,
                            DomainControllerInfo );

}


VOID
DsFlagsToString(
    IN DWORD Flags,
    OUT LPSTR Buffer
    )
/*++

Routine Description:

    Routine to convert DsGetDcName flags to a printable string

Arguments:

    Flags - flags to convert.

    Buffer - buffer large enough for the longest string.

Return Value:

    Buffer containing printable string.
        Free using LocalFree.

--*/
{

    //
    // Build a string for each bit.
    //

    *Buffer = '\0';
    if ( Flags & DS_FORCE_REDISCOVERY ) {
        strcat( Buffer, "FORCE " );
        Flags &= ~DS_FORCE_REDISCOVERY;
    }

    if ( Flags & DS_DIRECTORY_SERVICE_REQUIRED ) {
        strcat( Buffer, "DS " );
        Flags &= ~DS_DIRECTORY_SERVICE_REQUIRED;
    }
    if ( Flags & DS_DIRECTORY_SERVICE_PREFERRED ) {
        strcat( Buffer, "DSP " );
        Flags &= ~DS_DIRECTORY_SERVICE_PREFERRED;
    }
    if ( Flags & DS_GC_SERVER_REQUIRED ) {
        strcat( Buffer, "GC " );
        Flags &= ~DS_GC_SERVER_REQUIRED;
    }
    if ( Flags & DS_PDC_REQUIRED ) {
        strcat( Buffer, "PDC " );
        Flags &= ~DS_PDC_REQUIRED;
    }
    if ( Flags & DS_IP_REQUIRED ) {
        strcat( Buffer, "IP " );
        Flags &= ~DS_IP_REQUIRED;
    }
    if ( Flags & DS_KDC_REQUIRED ) {
        strcat( Buffer, "KDC " );
        Flags &= ~DS_KDC_REQUIRED;
    }
    if ( Flags & DS_TIMESERV_REQUIRED ) {
        strcat( Buffer, "TIMESERV " );
        Flags &= ~DS_TIMESERV_REQUIRED;
    }
    if ( Flags & DS_WRITABLE_REQUIRED ) {
        strcat( Buffer, "WRITABLE " );
        Flags &= ~DS_WRITABLE_REQUIRED;
    }
    if ( Flags & DS_GOOD_TIMESERV_PREFERRED ) {
        strcat( Buffer, "GTIMESERV " );
        Flags &= ~DS_GOOD_TIMESERV_PREFERRED;
    }
    if ( Flags & DS_AVOID_SELF ) {
        strcat( Buffer, "AVOIDSELF " );
        Flags &= ~DS_AVOID_SELF;
    }
    if ( Flags & DS_ONLY_LDAP_NEEDED ) {
        strcat( Buffer, "LDAPONLY " );
        Flags &= ~DS_ONLY_LDAP_NEEDED;
    }
    if ( Flags & DS_BACKGROUND_ONLY ) {
        strcat( Buffer, "BACKGROUND " );
        Flags &= ~DS_BACKGROUND_ONLY;
    }


    if ( Flags & DS_IS_FLAT_NAME ) {
        strcat( Buffer, "NETBIOS " );
        Flags &= ~DS_IS_FLAT_NAME;
    }
    if ( Flags & DS_IS_DNS_NAME ) {
        strcat( Buffer, "DNS " );
        Flags &= ~DS_IS_DNS_NAME;
    }

    if ( Flags & DS_RETURN_DNS_NAME ) {
        strcat( Buffer, "RET_DNS " );
        Flags &= ~DS_RETURN_DNS_NAME;
    }
    if ( Flags & DS_RETURN_FLAT_NAME ) {
        strcat( Buffer, "RET_NETBIOS " );
        Flags &= ~DS_RETURN_FLAT_NAME;
    }

    if ( Flags ) {
        sprintf( &Buffer[strlen(Buffer)], "0x%lx ", Flags );
    }
}


NET_API_STATUS
DsrGetDcNameEx2(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPWSTR AccountName OPTIONAL,
        IN ULONG AllowableAccountControlBits,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN LPWSTR SiteName OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    Same as DsGetDcNameW except:

    AccountName - Account name to pass on the ping request.
        If NULL, no account name will be sent.

    AllowableAccountControlBits - Mask of allowable account types for AccountName.

    * This is the RPC server side implementation.

Arguments:

    Same as DsGetDcNameW except as above.

Return Value:

    Same as DsGetDcNameW except as above.


--*/
{
    NET_API_STATUS NetStatus;

    PDOMAIN_INFO DomainInfo;
    LPWSTR CapturedInfo = NULL;
    LPWSTR CapturedDnsDomainName;
    LPWSTR CapturedDnsForestName;
    LPWSTR CapturedSiteName;
    GUID CapturedDomainGuidBuffer;
    GUID *CapturedDomainGuid;
    LPSTR FlagsBuffer;
    ULONG InternalFlags = 0;
    LPWSTR DnsDomainTrustName = NULL;
    LPWSTR NetbiosDomainTrustName = NULL;
    LPWSTR NetlogonDnsDomainTrustName = NULL;
    LPWSTR NetlogonNetbiosDomainTrustName = NULL;
    UNICODE_STRING LsaDnsDomainTrustName = {0};
    UNICODE_STRING LsaNetbiosDomainTrustName = {0};
    BOOL HaveDnsServers;


    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return ERROR_NETLOGON_NOT_STARTED;
    }


    //
    // Allocate a temp buffer
    //  (Don't put it on the stack since we don't want to commit a huge stack.)
    //

    CapturedInfo = LocalAlloc( LMEM_ZEROINIT,
                               (NL_MAX_DNS_LENGTH+1)*sizeof(WCHAR) +
                               (NL_MAX_DNS_LENGTH+1)*sizeof(WCHAR) +
                               (NL_MAX_DNS_LABEL_LENGTH+1)*sizeof(WCHAR)
                               + 200 );

    if ( CapturedInfo == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CapturedDnsDomainName = CapturedInfo;
    CapturedDnsForestName = &CapturedDnsDomainName[NL_MAX_DNS_LENGTH+1];
    CapturedSiteName = &CapturedDnsForestName[NL_MAX_DNS_LENGTH+1];
    FlagsBuffer = (LPSTR)&CapturedSiteName[NL_MAX_DNS_LABEL_LENGTH+1];

    IF_NL_DEBUG( MISC ) {
        DsFlagsToString( Flags, FlagsBuffer );
    }



    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ComputerName );

    if ( DomainInfo == NULL ) {
        // Default to primary domain to handle the case where the ComputerName
        // is an IP address.
        //  ?? Perhaps we should simply always use the primary domain

        DomainInfo = NlFindNetbiosDomain( NULL, TRUE );

        if ( DomainInfo == NULL ) {
            NetStatus = ERROR_INVALID_COMPUTERNAME;
            goto Cleanup;
        }
    }

    //
    // Be verbose
    //

    NlPrintDom((NL_MISC,  DomainInfo,
                "DsGetDcName function called: Dom:%ws Acct:%ws Flags: %s\n",
                DomainName,
                AccountName,
                FlagsBuffer ));

    //
    // If the caller didn't specify a site name,
    //  default to our site name.
    //

    if ( !ARGUMENT_PRESENT(SiteName) ) {
        if  ( NlCaptureSiteName( CapturedSiteName ) ) {
            SiteName = CapturedSiteName;
            InternalFlags |= DS_SITENAME_DEFAULTED;
        }
    }

    //
    // If the caller passed a domain name,
    //  and the domain is trusted,
    //  determine the Netbios and DNS versions of the domain name.
    //

    if ( DomainName != NULL ) {

        //
        // First try to get the names from netlogon's trusted domain list
        //

        NetStatus = NlGetTrustedDomainNames (
                        DomainInfo,
                        DomainName,
                        &NetlogonDnsDomainTrustName,
                        &NetlogonNetbiosDomainTrustName );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }

        DnsDomainTrustName = NetlogonDnsDomainTrustName;
        NetbiosDomainTrustName = NetlogonNetbiosDomainTrustName;


        //
        // If that didn't work,
        //  try getting better information from LSA's logon session list
        //

        if ( DnsDomainTrustName == NULL || NetbiosDomainTrustName == NULL ) {
            NTSTATUS Status;
            UNICODE_STRING DomainNameString;

            RtlInitUnicodeString( &DomainNameString, DomainName );

            Status = LsaIGetNbAndDnsDomainNames(
                                &DomainNameString,
                                &LsaDnsDomainTrustName,
                                &LsaNetbiosDomainTrustName );

            if ( !NT_SUCCESS(Status) ) {
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

            //
            // If the LSA returned names,
            //  use them
            //

            if ( LsaDnsDomainTrustName.Buffer != NULL  &&
                 LsaNetbiosDomainTrustName.Buffer != NULL ) {

                DnsDomainTrustName = LsaDnsDomainTrustName.Buffer;
                NetbiosDomainTrustName = LsaNetbiosDomainTrustName.Buffer;
            }
        }
    }


    //
    // Pass the request to the common implementation.
    //
    // When DsIGetDcName is called from netlogon,
    //  it has both the Netbios and DNS domain name available for the primary
    //  domain.  That can trick DsGetDcName into returning DNS host name of a
    //  DC in the primary domain.  However, on IPX only systems, that won't work.
    //  Avoid that problem by not passing the DNS domain name of the primary domain
    //  if there are no DNS servers.
    //

    CapturedDomainGuid = NlCaptureDomainInfo( DomainInfo,
                                              CapturedDnsDomainName,
                                              &CapturedDomainGuidBuffer );
    NlCaptureDnsForestName( CapturedDnsForestName );

    HaveDnsServers = NlDnsHasDnsServers();

    NetStatus = DsIGetDcName(
                    DomainInfo->DomUncUnicodeComputerName+2,
                    AccountName,
                    AllowableAccountControlBits,
                    DomainName,
                    CapturedDnsForestName,
                    DomainGuid,
                    SiteName,
                    Flags,
                    InternalFlags,
                    DomainInfo,
                    NL_DC_MAX_TIMEOUT + NlGlobalParameters.ExpectedDialupDelay*1000,
                    DomainInfo->DomUnicodeDomainName,
                    HaveDnsServers ? CapturedDnsDomainName : NULL,
                    CapturedDomainGuid,
                    HaveDnsServers ? DnsDomainTrustName : NULL,
                    NetbiosDomainTrustName,
                    DomainControllerInfo );

    if ( NetStatus != ERROR_NO_SUCH_DOMAIN ) {
        goto Cleanup;
    }

    //
    // Clean up locally used resources.
    //
Cleanup:

    NlPrintDom((NL_MISC,  DomainInfo,
                "DsGetDcName function returns %ld: Dom:%ws Acct:%ws Flags: %s\n",
                NetStatus,
                DomainName,
                AccountName,
                FlagsBuffer ));

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    if ( CapturedInfo != NULL ) {
        LocalFree( CapturedInfo );
    }

    if ( NetlogonDnsDomainTrustName != NULL ) {
        NetApiBufferFree( NetlogonDnsDomainTrustName );
    }
    if ( NetlogonNetbiosDomainTrustName != NULL ) {
        NetApiBufferFree( NetlogonNetbiosDomainTrustName );
    }

    if ( LsaDnsDomainTrustName.Buffer != NULL ) {
        LsaIFreeHeap( LsaDnsDomainTrustName.Buffer );
    }

    if ( LsaNetbiosDomainTrustName.Buffer != NULL ) {
        LsaIFreeHeap( LsaNetbiosDomainTrustName.Buffer );
    }

    //
    // Indicate that the calling thread has left netlogon.dll
    //

    NlEndNetlogonCall();

    return NetStatus;

}

NET_API_STATUS
DsrGetDcName(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN GUID *SiteGuid OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    Same as DsGetDcNameW except:

    * This is the RPC server side implementation.

Arguments:

    Same as DsGetDcNameW except as above.

Return Value:

    Same as DsGetDcNameW except as above.


--*/
{
    return DsrGetDcNameEx2( ComputerName,
                            NULL,   // No Account name
                            0,      // No Allowable account control bits
                            DomainName,
                            DomainGuid,
                            NULL,   // No site name
                            Flags,
                            DomainControllerInfo );

    UNREFERENCED_PARAMETER( SiteGuid );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\lsarepl.h ===
/*++

Copyright (c) 1987-1996 Microsoft Corporation

Module Name:

    lsarepl.h

Abstract:

    Function prototypes for Low level LSA Replication functions

Author:

    06-Apr-1992 (madana)
        Created for LSA replication.

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


#ifdef _DC_NETLOGON
//
// lsarepl.c
//

NTSTATUS
NlPackLsaPolicy(
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize );

NTSTATUS
NlPackLsaTDomain(
    IN PSID Sid,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize );

NTSTATUS
NlPackLsaAccount(
    IN PSID Sid,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize,
    IN PSESSION_INFO SessionInfo
    );

NTSTATUS
NlPackLsaSecret(
    IN PUNICODE_STRING Name,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize,
    IN PSESSION_INFO SessionInfo );

#endif // _DC_NETLOGON
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\lsrvrepl.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\logonsrv.h ===
/*++

Copyright (c) 1987-1996 Microsoft Corporation

Module Name:

    logonsrv.h

Abstract:

    Netlogon service internal constants and definitions.

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.

--*/

//
// Define _DC_NETLOGON if _WKSTA_NETLOGON is not defined.
//

#ifndef _WKSTA_NETLOGON
#define _DC_NETLOGON
#endif // _WKSTA_NETLOGON

////////////////////////////////////////////////////////////////////////////
//
// Common include files needed by ALL netlogon server files
//
////////////////////////////////////////////////////////////////////////////

#if ( _MSC_VER >= 800 )
#pragma warning ( 3 : 4100 ) // enable "Unreferenced formal parameter"
#pragma warning ( 3 : 4219 ) // enable "trailing ',' used for variable argument list"
#endif

#include <nt.h>     // LARGE_INTEGER definition
#include <ntrtl.h>  // LARGE_INTEGER definition
#include <nturtl.h> // LARGE_INTEGER definition
#include <ntlsa.h>  // Needed by lsrvdata.h

#define NOMINMAX        // Avoid redefinition of min and max in stdlib.h
#include <rpc.h>        // Needed by logon_s.h
#define INCL_WINSOCK_API_PROTOTYPES 1
#include <winsock2.h>   // Winsock support
#include <logon_s.h>    // includes lmcons.h, lmaccess.h, netlogon.h, ssi.h, windef.h

#include <windows.h>

#include <alertmsg.h>   // ALERT_* defines
#include <align.h>      // ROUND_UP_COUNT ...
#include <config.h>     // net config helpers.
#include <confname.h>   // SECTION_ equates, NETLOGON_KEYWORD_ equates.
#include <debugfmt.h>   // FORMAT_*
//#define SDK_DNS_RECORD 1 // Needed for dnsapi.h
#include <windns.h>     // DNS API
#include <dnsapi.h>     // Dns API
#include <icanon.h>     // NAMETYPE_* defines
#include <lmapibuf.h>   // NetApiBufferFree
#include <lmerr.h>      // NERR_ equates.
#include <lmerrlog.h>   // NELOG_*
#include <lmserver.h>   // Server API defines and prototypes
#include <lmshare.h>    // share API functions and prototypes
#include <lmsname.h>    // Needed for NETLOGON service name
#include <lmsvc.h>      // SERVICE_UIC codes are defined here
#include <logonp.h>     // NetpLogon routines
#include <lsarpc.h>     // Needed by lsrvdata.h and logonsrv.h
#include <lsaisrv.h>    // LsaI routines
#include <wincrypt.h>   // CryptoAPI

#ifndef NETSETUP_JOIN
#define SECURITY_KERBEROS
#include <security.h>   // Interface to LSA/Kerberos
#include <secint.h>     // needed to get Kerberos interfaces.
#include <sspi.h>       // Needed by ssiinit.h
// #include <secext.h>     // Needed by secpkg.h
#include <secpkg.h>     // Needed by sphelp.h
#endif

#include <names.h>      // NetpIsUserNameValid
#include <netlib.h>     // NetpCopy...
#include <netlibnt.h>   // NetpNtStatusToApiStatus
#include "nlp.h"        // Nlp routine
#include <ntddbrow.h>   // Interface to browser driver
#include <ntrpcp.h>     // Rpcp routines
#include <samrpc.h>     // Needed by lsrvdata.h and logonsrv.h
#include <samisrv.h>    // SamIFree routines
#include <secobj.h>     // NetpAccessCheck
#include <stddef.h>     // offsetof()
#include <stdlib.h>     // C library functions (rand, etc)
#include <tstring.h>    // Transitional string routines.
#include <lmjoin.h>     // Needed by netsetup.h
#include <netsetup.h>   // NetpSetDnsComputerNameAsRequired
#include <wmistr.h>     // WMI trace
#include <evntrace.h>   // TRACEHANDLE

#ifndef NETSETUP_JOIN
#include <cryptdll.h>
#include <ntdsa.h>
#include <ntdsapi.h>
#include <ntdsapip.h>
#endif

//
// Netlogon specific header files.
//

#include <nlrepl.h>     // I_Net*
#include <dsgetdc.h>    // DsGetDcName()
#include <dsgetdcp.h>   // DsGetDcOpen()
#include "worker.h"     // Worker routines
#include "nlbind.h"     // Netlogon RPC binding cache routines
#include "nlcommon.h"   // Routines shared with logonsrv\common
#include "domain.h"     // Hosted domain definitions
#include "nldns.h"      // DNS name registration
#include "changelg.h"   // Change Log support
#include "chutil.h"     // Change Log utilities
#include "iniparm.h"    // DEFAULT_, MIN_, and MAX_ equates.
#include "ssiinit.h"    // Misc global definitions
#include "replutil.h"
#include "nldebug.h"    // Netlogon debugging
#include "nlsecure.h"   // Security Descriptor for APIs
#include "ismapi.h"
#include "nlsite.h"
#include "lsrvdata.h"   // Globals

//
// RtlCopyMemory on IA64 is now optimized to do aligned copies inline.
// This doesn't work for us as we use RtlCopyMemory to copy data from
// unaligned buffers to aligned ones, so we cause unaligment exception.
// To avoid this, revert to the old unoptimized version.
//

#if defined(_M_IA64)
#undef RtlCopyMemory
NTSYSAPI
VOID
NTAPI
RtlCopyMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );
#endif // _M_IA64

#ifdef _DC_NETLOGON
#define NETLOGON_SCRIPTS_SHARE L"NETLOGON"
#define NETLOGON_SYSVOL_SHARE  L"SYSVOL"
#endif // _DC_NETLOGON

#define MAX_LOGONREQ_COUNT  3


#define NETLOGON_INSTALL_WAIT  60000       // 60 secs

//
// Exit codes for NlExit
//

typedef enum {
    DontLogError,
    LogError,
    LogErrorAndNtStatus,
    LogErrorAndNetStatus
} NL_EXIT_CODE;

////////////////////////////////////////////////////////////////////////
//
// Procedure Forwards
//
////////////////////////////////////////////////////////////////////////

//
// error.c
//

NET_API_STATUS
NlCleanup(
    VOID
    );

VOID
NlExit(
    IN DWORD ServiceError,
    IN DWORD Data,
    IN NL_EXIT_CODE ExitCode,
    IN LPWSTR ErrorString
    );

BOOL
GiveInstallHints(
    IN BOOL Started
    );

#ifdef _DC_NETLOGON
VOID
NlControlHandler(
    IN DWORD opcode
    );
#endif // _DC_NETLOGON

VOID
RaiseAlert(
    IN DWORD alert_no,
    IN LPWSTR *string_array
    );

//
// Nlparse.c
//

BOOL
Nlparse(
    IN PNETLOGON_PARAMETERS NlParameters,
    IN PNETLOGON_PARAMETERS DefaultParameters OPTIONAL,
    IN BOOLEAN IsChangeNotify
    );

VOID
NlParseFree(
    IN PNETLOGON_PARAMETERS NlParameters
    );

VOID
NlReparse(
    VOID
    );

BOOL
NlparseAllSections(
    IN PNETLOGON_PARAMETERS NlParameters,
    IN BOOLEAN IsChangeNotify
    );

//
// announce.c
//

VOID
NlRemovePendingBdc(
    IN PSERVER_SESSION ServerSession
    );

VOID
NlPrimaryAnnouncementFinish(
    IN PSERVER_SESSION ServerSession,
    IN DWORD DatabaseId,
    IN PLARGE_INTEGER SerialNumber
    );

VOID
NlPrimaryAnnouncementTimeout(
    VOID
    );

VOID
NlPrimaryAnnouncement(
    IN DWORD AnnounceFlags
    );

#define ANNOUNCE_FORCE      0x01
#define ANNOUNCE_CONTINUE   0x02
#define ANNOUNCE_IMMEDIATE  0x04




//
// lsrvutil.c
//

NTSTATUS
NlGetOutgoingPassword(
    IN PCLIENT_SESSION ClientSession,
    OUT PUNICODE_STRING *CurrentValue,
    OUT PUNICODE_STRING *OldValue,
    OUT PDWORD CurrentVersionNumber,
    OUT PLARGE_INTEGER LastSetTime OPTIONAL
    );

NTSTATUS
NlSessionSetup(
    IN OUT PCLIENT_SESSION ClientSession
    );

NTSTATUS
NlEnsureSessionAuthenticated(
    IN PCLIENT_SESSION ClientSession,
    IN DWORD DesiredFlags
    );

BOOLEAN
NlTimeHasElapsedEx(
    IN PLARGE_INTEGER StartTime,
    IN PLARGE_INTEGER Period,
    OUT PULONG RemainingTime OPTIONAL
    );

BOOLEAN
NlTimeToReauthenticate(
    IN PCLIENT_SESSION ClientSession
    );

BOOLEAN
NlTimeToRediscover(
    IN PCLIENT_SESSION ClientSession,
    BOOLEAN WithAccount
    );

NTSTATUS
NlUpdateDomainInfo(
    IN PCLIENT_SESSION ClientSession
    );

NET_API_STATUS
NlCreateShare(
    LPWSTR SharePath,
    LPWSTR ShareName,
    BOOLEAN AllowAuthenticatedUsers,
    BOOL UpdateExclusiveShareAccess,
    BOOL AllowExclusiveShareAccess
    );

NET_API_STATUS
NlCacheJoinDomainControllerInfo(
    VOID
    );


NTSTATUS
NlSamOpenNamedUser(
    IN PDOMAIN_INFO DomainInfo,
    IN LPCWSTR UserName,
    OUT SAMPR_HANDLE *UserHandle OPTIONAL,
    OUT PULONG UserId OPTIONAL,
    PSAMPR_USER_INFO_BUFFER *UserAllInfo OPTIONAL
    );

NTSTATUS
NlSamChangePasswordNamedUser(
    IN PDOMAIN_INFO DomainInfo,
    IN LPCWSTR UserName,
    IN PUNICODE_STRING ClearTextPassword OPTIONAL,
    IN PNT_OWF_PASSWORD OwfPassword OPTIONAL
    );

NTSTATUS
NlGetIncomingPassword(
    IN PDOMAIN_INFO DomainInfo,
    IN LPCWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN ULONG AllowableAccountControlBits,
    IN BOOL CheckAccountDisabled,
    OUT PNT_OWF_PASSWORD OwfPassword OPTIONAL,
    OUT PNT_OWF_PASSWORD OwfPreviousPassword OPTIONAL,
    OUT PULONG AccountRid OPTIONAL,
    OUT PULONG TrustAttributes OPTIONAL,
    OUT PBOOL IsDnsDomainTrustAccount OPTIONAL
    );

NTSTATUS
NlSetIncomingPassword(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PUNICODE_STRING ClearTextPassword OPTIONAL,
    IN DWORD ClearPasswordVersionNumber,
    IN PNT_OWF_PASSWORD OwfPassword OPTIONAL
    );

NTSTATUS
NlChangePassword(
    IN PCLIENT_SESSION ClientSession,
    IN BOOLEAN ForcePasswordChange,
    OUT PULONG RetCallAgainPeriod OPTIONAL
    );

NTSTATUS
NlChangePasswordHigher(
    IN PCLIENT_SESSION ClientSession,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN PLM_OWF_PASSWORD NewOwfPassword OPTIONAL,
    IN PUNICODE_STRING NewClearPassword OPTIONAL,
    IN PDWORD ClearPasswordVersionNumber OPTIONAL
    );

NTSTATUS
NlGetUserPriv(
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG GroupCount,
    IN PGROUP_MEMBERSHIP Groups,
    IN ULONG UserRelativeId,
    OUT LPDWORD Priv,
    OUT LPDWORD AuthFlags
    );

BOOLEAN
NlGenerateRandomBits(
    PUCHAR pBuffer,
    ULONG  cbBuffer
    );


//
// netlogon.c
//


#ifdef _DC_NETLOGON
BOOL
TimerExpired(
    IN PTIMER Timer,
    IN PLARGE_INTEGER TimeNow,
    IN OUT LPDWORD Timeout
    );

ULONG
NlGetDomainFlags(
    IN PDOMAIN_INFO DomainInfo
    );

NTSTATUS
NlWaitForService(
    LPWSTR ServiceName,
    ULONG Timeout,
    BOOLEAN RequireAutoStart
    );

int
NlNetlogonMain(
    IN DWORD argc,
    IN LPWSTR *argv
    );

NTSTATUS
NlInitLsaDBInfo(
    PDOMAIN_INFO DomainInfo,
    DWORD DBIndex
    );

NTSTATUS
NlInitSamDBInfo(
    PDOMAIN_INFO DomainInfo,
    DWORD DBIndex
    );

BOOL
NlCreateSysvolShares(
    VOID
    );

#endif // _DC_NETLOGON

//
// mailslot.c
//

NTSTATUS
NlpWriteMailslot(
    IN LPWSTR MailslotName,
    IN LPVOID Buffer,
    IN DWORD BufferSize
    );

#ifdef _DC_NETLOGON
HANDLE
NlBrowserCreateEvent(
    VOID
    );

VOID
NlBrowserCloseEvent(
    IN HANDLE EventHandle
    );

BOOL
NlBrowserOpen(
    VOID
    );

VOID
NlBrowserClose(
    VOID
    );

NTSTATUS
NlBrowserSendDatagramA(
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG IpAddress,
    IN LPSTR OemServerName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR TransportName,
    IN LPSTR OemMailslotName,
    IN PVOID Buffer,
    IN ULONG BufferSize
    );

NET_API_STATUS
NlBrowserFixAllNames(
    IN PDOMAIN_INFO DomainInfo,
    IN PVOID Context
    );

VOID
NlBrowserAddName(
    IN PDOMAIN_INFO DomainInfo
    );

VOID
NlBrowserDelName(
    IN PDOMAIN_INFO DomainInfo
    );

VOID
NlBrowserUpdate(
    IN PDOMAIN_INFO DomainInfo,
    IN DWORD Role
    );

NTSTATUS
NlBrowserRenameDomain(
    IN LPWSTR OldDomainName OPTIONAL,
    IN LPWSTR NewDomainName
    );

NET_API_STATUS
NlBrowserGetTransportList(
    OUT PLMDR_TRANSPORT_LIST *TransportList
    );

VOID
NlBrowserSyncHostedDomains(
    VOID
    );

VOID
NlMailslotPostRead(
    IN BOOLEAN IgnoreDuplicatesOfPreviousMessage
    );

BOOL
NlMailslotOverlappedResult(
    OUT LPBYTE *Message,
    OUT PULONG BytesRead,
    OUT LPWSTR *TransportName,
    OUT PNL_TRANSPORT *Transport,
    OUT PSOCKADDR *ClientSockAddr,
    OUT LPWSTR *DestinationName,
    OUT PBOOLEAN IgnoreDuplicatesOfPreviousMessage,
    OUT PNETLOGON_PNP_OPCODE NlPnpOpcode
    );

NET_API_STATUS
NlServerComputerNameAdd(
    IN LPWSTR HostedDomainName,
    IN LPWSTR HostedServerName
    );

//
// oldstub.c
//

void _fgs__NETLOGON_DELTA_ENUM (NETLOGON_DELTA_ENUM  * _source);

// Use this to free all memory allocated by SAM.
#define SamLsaFreeMemory( _X ) MIDL_user_free(_X)

//
// ds.c
//


NET_API_STATUS
NlGetRoleInformation(
    PDOMAIN_INFO DomainInfo,
    PBOOLEAN IsPdc,
    PBOOLEAN Nt4MixedDomain
    );

//
// rgroups.c
//

NTSTATUS
NlpExpandResourceGroupMembership(
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT PNETLOGON_VALIDATION_SAM_INFO4 * UserInfo,
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG ComputerAccountId
    );

NTSTATUS
NlpAddResourceGroupsToSamInfo (
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT PNETLOGON_VALIDATION_SAM_INFO4 *ValidationInformation,
    IN PSAMPR_PSID_ARRAY ResourceGroups
    );

NTSTATUS
NlpAddOtherOrganizationSid (
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT PNETLOGON_VALIDATION_SAM_INFO4 *ValidationInformation
    );

#endif // _DC_NETLOGON

//
// nltrace.c
//

ULONG
_stdcall
NlpInitializeTrace(PVOID Param);

VOID
NlpTraceEvent(
    IN ULONG WmiEventType,
    IN ULONG TraceGuid );

VOID
NlpTraceServerAuthEvent(
    IN ULONG WmiEventType,
    IN LPWSTR ComputerName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PULONG NegotiatedFlags,
    IN NTSTATUS Status
    );

//
// The following "typedef enum" actually is the index of LPGUID in
// the table of NlpTraceGuids[] (defined in nltrace.c). We should
// always change NlpTraceGuids[] if we add any other entry
// in the following enum type.
//
typedef enum _NLPTRACE_GUID {

    NlpGuidServerAuth,
    NlpGuidSecureChannelSetup

} NLPTRACE_GUID;

//
// parse.c
//

NET_API_STATUS
NlParseOne(
    IN LPNET_CONFIG_HANDLE SectionHandle,
    IN BOOL GpSection,
    IN LPWSTR Keyword,
    IN ULONG DefaultValue,
    IN ULONG MinimumValue,
    IN ULONG MaximumValue,
    OUT PULONG Value
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\lsarepl.c ===
/*++

Copyright (c) 1987-1996 Microsoft Corporation

Module Name:

    lsarepl.c

Abstract:

    Low level LSA Replication functions.

Author:

    06-Apr-1992 (madana)
        Created for LSA replication.

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

#include "lsarepl.h"


NTSTATUS
NlPackLsaPolicy(
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize )
/*++

Routine Description:

    Pack a description of the LSA policy info into the specified buffer.

Arguments:

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;
    ULONG i;

    PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor = NULL;

    PLSAPR_POLICY_INFORMATION PolicyAuditLogInfo = NULL;
    PLSAPR_POLICY_INFORMATION PolicyAuditEventsInfo = NULL;
    PLSAPR_POLICY_INFORMATION PolicyPrimaryDomainInfo = NULL;
    PLSAPR_POLICY_INFORMATION PolicyDefaultQuotaInfo = NULL;
    PLSAPR_POLICY_INFORMATION PolicyModificationInfo = NULL;

    PNETLOGON_DELTA_POLICY DeltaPolicy = NULL;

    DEFPACKTIMER;
    DEFLSATIMER;

    INITPACKTIMER;
    INITLSATIMER;

    STARTPACKTIMER;

    NlPrint((NL_SYNC_MORE, "Packing Policy Object\n"));

    *BufferSize = 0;

    Delta->DeltaType = AddOrChangeLsaPolicy;
    Delta->DeltaUnion.DeltaPolicy = NULL;

    QUERY_LSA_SECOBJ_INFO(DBInfo->DBHandle);

    STARTLSATIMER;

    Status = LsarQueryInformationPolicy(
                DBInfo->DBHandle,
                PolicyAuditLogInformation,
                &PolicyAuditLogInfo);

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        PolicyAuditLogInfo = NULL;
        goto Cleanup;
    }

    STARTLSATIMER;

    Status = LsarQueryInformationPolicy(
                DBInfo->DBHandle,
                PolicyAuditEventsInformation,
                &PolicyAuditEventsInfo);

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        PolicyAuditEventsInfo = NULL;
        goto Cleanup;
    }

    STARTLSATIMER;

    Status = LsarQueryInformationPolicy(
                DBInfo->DBHandle,
                PolicyPrimaryDomainInformation,
                &PolicyPrimaryDomainInfo);

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        PolicyPrimaryDomainInfo = NULL;
        goto Cleanup;
    }


    STARTLSATIMER;

    Status = LsarQueryInformationPolicy(
                DBInfo->DBHandle,
                PolicyDefaultQuotaInformation,
                &PolicyDefaultQuotaInfo);

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        PolicyDefaultQuotaInfo = NULL;
        goto Cleanup;
    }

    STARTLSATIMER;

    Status = LsarQueryInformationPolicy(
                DBInfo->DBHandle,
                PolicyModificationInformation,
                &PolicyModificationInfo);

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        PolicyModificationInfo = NULL;
        goto Cleanup;
    }

    //
    // Fill in the delta structure
    //

    //
    // copy SID info (There is only one policy database.  It has no SID).
    //

    Delta->DeltaID.Sid = NULL;

    //
    // allocate delta buffer
    //

    DeltaPolicy = (PNETLOGON_DELTA_POLICY)
        MIDL_user_allocate( sizeof(NETLOGON_DELTA_POLICY) );

    if( DeltaPolicy == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaPolicy, sizeof(NETLOGON_DELTA_POLICY) );
    // INIT_PLACE_HOLDER(DeltaPolicy);

    Delta->DeltaUnion.DeltaPolicy = DeltaPolicy;
    *BufferSize += sizeof(NETLOGON_DELTA_POLICY);

    DeltaPolicy->MaximumLogSize =
        PolicyAuditLogInfo->PolicyAuditLogInfo.MaximumLogSize;
    DeltaPolicy->AuditRetentionPeriod;
        PolicyAuditLogInfo->PolicyAuditLogInfo.AuditRetentionPeriod;

    DeltaPolicy->AuditingMode =
        PolicyAuditEventsInfo->
            PolicyAuditEventsInfo.AuditingMode;
    DeltaPolicy->MaximumAuditEventCount =
        PolicyAuditEventsInfo->
            PolicyAuditEventsInfo.MaximumAuditEventCount;

    *BufferSize += NlCopyData(
                    (LPBYTE *)&(PolicyAuditEventsInfo->
                        PolicyAuditEventsInfo.EventAuditingOptions),
                    (LPBYTE *)&(DeltaPolicy->EventAuditingOptions),
                    (DeltaPolicy->MaximumAuditEventCount + 1) *
                        sizeof(ULONG));

    // Tell the BDC to 'set' these bits and not just 'or' them in to the current ones
    for ( i=0; i<DeltaPolicy->MaximumAuditEventCount; i++ ) {
        DeltaPolicy->EventAuditingOptions[i] |= POLICY_AUDIT_EVENT_NONE;
    }

    //
    // sanitity check, EventAuditingOptions size is ULONG size.
    //

    NlAssert(sizeof(*(PolicyAuditEventsInfo->
                PolicyAuditEventsInfo.EventAuditingOptions)) ==
                    sizeof(ULONG) );

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&PolicyPrimaryDomainInfo->
                        PolicyPrimaryDomainInfo.Name,
                    &DeltaPolicy->PrimaryDomainName );

    *BufferSize += NlCopyData(
                    (LPBYTE *)&(PolicyPrimaryDomainInfo->
                        PolicyPrimaryDomainInfo.Sid),
                    (LPBYTE *)&(DeltaPolicy->PrimaryDomainSid),
                    RtlLengthSid((PSID)(PolicyPrimaryDomainInfo->
                        PolicyPrimaryDomainInfo.Sid) ));

    DeltaPolicy->QuotaLimits.PagedPoolLimit =
        (ULONG)PolicyDefaultQuotaInfo->PolicyDefaultQuotaInfo.QuotaLimits.PagedPoolLimit;
    DeltaPolicy->QuotaLimits.NonPagedPoolLimit =
        (ULONG)PolicyDefaultQuotaInfo->PolicyDefaultQuotaInfo.QuotaLimits.NonPagedPoolLimit;
    DeltaPolicy->QuotaLimits.MinimumWorkingSetSize =
        (ULONG)PolicyDefaultQuotaInfo->PolicyDefaultQuotaInfo.QuotaLimits.MinimumWorkingSetSize;
    DeltaPolicy->QuotaLimits.MaximumWorkingSetSize =
        (ULONG)PolicyDefaultQuotaInfo->PolicyDefaultQuotaInfo.QuotaLimits.MaximumWorkingSetSize;
    DeltaPolicy->QuotaLimits.PagefileLimit =
        (ULONG)PolicyDefaultQuotaInfo->PolicyDefaultQuotaInfo.QuotaLimits.PagefileLimit;

    NEW_TO_OLD_LARGE_INTEGER(
        PolicyDefaultQuotaInfo->PolicyDefaultQuotaInfo.QuotaLimits.TimeLimit,
        DeltaPolicy->QuotaLimits.TimeLimit );

    NEW_TO_OLD_LARGE_INTEGER(
        PolicyModificationInfo->PolicyModificationInfo.ModifiedId,
        DeltaPolicy->ModifiedId );

    NEW_TO_OLD_LARGE_INTEGER(
        PolicyModificationInfo->PolicyModificationInfo.DatabaseCreationTime,
        DeltaPolicy->DatabaseCreationTime );


    DELTA_SECOBJ_INFO(DeltaPolicy);


    //
    // All Done
    //

    Status = STATUS_SUCCESS;

Cleanup:

    STARTLSATIMER;

    if ( SecurityDescriptor != NULL ) {
        LsaIFree_LSAPR_SR_SECURITY_DESCRIPTOR( SecurityDescriptor );
    }

    if ( PolicyAuditLogInfo != NULL ) {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAuditLogInformation,
            PolicyAuditLogInfo );
    }

    if ( PolicyAuditEventsInfo != NULL ) {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAuditEventsInformation,
            PolicyAuditEventsInfo );
    }

    if ( PolicyPrimaryDomainInfo != NULL ) {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyPrimaryDomainInformation,
            PolicyPrimaryDomainInfo );
    }

    if ( PolicyDefaultQuotaInfo != NULL ) {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDefaultQuotaInformation,
            PolicyDefaultQuotaInfo );
    }

    if ( PolicyModificationInfo != NULL ) {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyModificationInformation,
            PolicyModificationInfo );
    }

    STOPLSATIMER;

    if( !NT_SUCCESS(Status) ) {
        NlFreeDBDelta( Delta );
        *BufferSize = 0;
    }


    STOPPACKTIMER;

    NlPrint((NL_REPL_OBJ_TIME,"Time taken to pack POLICY object:\n"));
    PRINTPACKTIMER;
    PRINTLSATIMER;

    return(Status);
}


NTSTATUS
NlPackLsaTDomain(
    IN PSID Sid,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize )
/*++

Routine Description:

    Pack a description of the specified trusted domain info into the
    specified buffer.

Arguments:

    Sid - The SID of the trusted domain.

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;

    LSAPR_HANDLE TrustedDomainHandle = NULL;
    PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainNameInfo = NULL;
    PLSAPR_TRUSTED_DOMAIN_INFO TrustedPosixOffsetInfo = NULL;

    PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor = NULL;

    PNETLOGON_DELTA_TRUSTED_DOMAINS DeltaTDomain = NULL;

    DWORD i;
    DWORD Entries;
    DWORD Size = 0;
    PLSAPR_UNICODE_STRING UnicodeControllerName;

    DEFPACKTIMER;
    DEFLSATIMER;

    INITPACKTIMER;
    INITLSATIMER;

    STARTPACKTIMER;

    NlPrint((NL_SYNC_MORE, "Packing Trusted Domain Object\n"));

    *BufferSize = 0;

    Delta->DeltaType = AddOrChangeLsaTDomain;
    Delta->DeltaID.Sid = NULL;
    Delta->DeltaUnion.DeltaTDomains = NULL;

    //
    // open trusted domain
    //

    STARTLSATIMER;

    Status = LsarOpenTrustedDomain(
                DBInfo->DBHandle,
                (PLSAPR_SID)Sid,
                0,
                &TrustedDomainHandle );

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        TrustedDomainHandle = NULL;
        goto Cleanup;
    }

    QUERY_LSA_SECOBJ_INFO(TrustedDomainHandle);

    STARTLSATIMER;

    Status = LsarQueryInfoTrustedDomain(
                TrustedDomainHandle,
                TrustedDomainNameInformation,
                &TrustedDomainNameInfo );

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        TrustedDomainNameInfo = NULL;
        goto Cleanup;
    }

    NlPrint((NL_SYNC_MORE,
        "\t Trusted Domain Object name %wZ\n",
            (PUNICODE_STRING)&TrustedDomainNameInfo->
                TrustedDomainNameInfo.Name ));

    STARTLSATIMER;

    Status = LsarQueryInfoTrustedDomain(
                TrustedDomainHandle,
                TrustedPosixOffsetInformation,
                &TrustedPosixOffsetInfo );

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        TrustedPosixOffsetInfo = NULL;
        goto Cleanup;
    }

    //
    // Fill in the delta structure
    //

    //
    // copy SID info
    //

    Delta->DeltaID.Sid = MIDL_user_allocate( RtlLengthSid(Sid) );


    if( Delta->DeltaID.Sid == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( Delta->DeltaID.Sid, Sid, RtlLengthSid(Sid) );

    //
    // allocate delta buffer
    //

    DeltaTDomain = (PNETLOGON_DELTA_TRUSTED_DOMAINS)
        MIDL_user_allocate( sizeof(NETLOGON_DELTA_TRUSTED_DOMAINS) );

    if( DeltaTDomain == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaTDomain, sizeof(NETLOGON_DELTA_TRUSTED_DOMAINS) );
    // INIT_PLACE_HOLDER(DeltaTDomain);

    Delta->DeltaUnion.DeltaTDomains = DeltaTDomain;
    *BufferSize += sizeof(NETLOGON_DELTA_TRUSTED_DOMAINS);

    *BufferSize += NlCopyUnicodeString(
                        (PUNICODE_STRING)&TrustedDomainNameInfo->
                            TrustedDomainNameInfo.Name,
                        &DeltaTDomain->DomainName );

    DELTA_SECOBJ_INFO(DeltaTDomain);

    //
    // send Posix Offset info across using place holder.
    //

    DeltaTDomain->DummyLong1 =
        TrustedPosixOffsetInfo->TrustedPosixOffsetInfo.Offset;

    //
    // All Done
    //

    Status = STATUS_SUCCESS;

Cleanup:

    STARTLSATIMER;

    if ( TrustedDomainHandle != NULL ) {
        LsarClose( &TrustedDomainHandle );
    }

    if ( SecurityDescriptor != NULL ) {
        LsaIFree_LSAPR_SR_SECURITY_DESCRIPTOR( SecurityDescriptor );
    }

    if ( TrustedDomainNameInfo != NULL ) {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            TrustedDomainNameInformation,
            TrustedDomainNameInfo );
    }

    if ( TrustedPosixOffsetInfo != NULL ) {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            TrustedPosixOffsetInformation,
            TrustedPosixOffsetInfo );
    }

    STOPLSATIMER;

    if( !NT_SUCCESS(Status) ) {
        NlFreeDBDelta( Delta );
        *BufferSize = 0;
    }

    STOPPACKTIMER;

    NlPrint((NL_REPL_OBJ_TIME,"Time taken to pack TDOMAIN object:\n"));
    PRINTPACKTIMER;
    PRINTLSATIMER;

    return(Status);
}


NTSTATUS
NlPackLsaAccount(
    IN PSID Sid,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize,
    IN PSESSION_INFO SessionInfo
    )
/*++

Routine Description:

    Pack a description of the specified LSA account info into the
    specified buffer.

Arguments:

    Sid - The SID of the LSA account.

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

    SessionInfo: Info describing BDC that's calling us

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;

    PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor = NULL;

    PNETLOGON_DELTA_ACCOUNTS DeltaAccount = NULL;
    LSAPR_HANDLE AccountHandle = NULL;

    PLSAPR_PRIVILEGE_SET Privileges = NULL;
    ULONG SystemAccessFlags;

    PULONG PrivilegeAttributes;
    PUNICODE_STRING PrivilegeNames;
    LUID MachineAccountPrivilegeLuid;
    DWORD CopiedPrivilegeCount;

    DWORD i;
    DWORD Size;

    DEFPACKTIMER;
    DEFLSATIMER;

    INITPACKTIMER;
    INITLSATIMER;

    STARTPACKTIMER;

    NlPrint((NL_SYNC_MORE, "Packing Lsa Account Object\n"));

    *BufferSize = 0;
    MachineAccountPrivilegeLuid = RtlConvertLongToLuid(SE_MACHINE_ACCOUNT_PRIVILEGE);

    Delta->DeltaType = AddOrChangeLsaAccount;
    Delta->DeltaID.Sid = NULL;
    Delta->DeltaUnion.DeltaAccounts = NULL;

    //
    // open lsa account
    //

    STARTLSATIMER;

    Status = LsarOpenAccount(
                DBInfo->DBHandle,
                (PLSAPR_SID)Sid,
                0,
                &AccountHandle );

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        AccountHandle = NULL;
        goto Cleanup;
    }

    QUERY_LSA_SECOBJ_INFO(AccountHandle);

    STARTLSATIMER;

    Status = LsarEnumeratePrivilegesAccount(
                AccountHandle,
                &Privileges );

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        Privileges = NULL;
        goto Cleanup;
    }

    STARTLSATIMER;

    Status = LsarGetSystemAccessAccount(
                AccountHandle,
                &SystemAccessFlags );

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Fill in the delta structure
    //

    //
    // copy SID info
    //

    Delta->DeltaID.Sid = MIDL_user_allocate( RtlLengthSid(Sid) );


    if( Delta->DeltaID.Sid == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( Delta->DeltaID.Sid, Sid, RtlLengthSid(Sid) );

    //
    // allocate delta buffer
    //

    DeltaAccount = (PNETLOGON_DELTA_ACCOUNTS)
        MIDL_user_allocate( sizeof(NETLOGON_DELTA_ACCOUNTS) );

    if( DeltaAccount == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaAccount, sizeof(NETLOGON_DELTA_ACCOUNTS) );
    // INIT_PLACE_HOLDER(DeltaAccount);

    Delta->DeltaUnion.DeltaAccounts = DeltaAccount;
    *BufferSize += sizeof(NETLOGON_DELTA_ACCOUNTS);

    DeltaAccount->PrivilegeControl = Privileges->Control;

    DeltaAccount->PrivilegeEntries = 0;
    DeltaAccount->PrivilegeAttributes = NULL;
    DeltaAccount->PrivilegeNames = NULL;

    Size = Privileges->PrivilegeCount * sizeof(ULONG);

    PrivilegeAttributes = MIDL_user_allocate( Size );

    if( PrivilegeAttributes == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    DeltaAccount->PrivilegeAttributes = PrivilegeAttributes;
    *BufferSize += Size;

    Size = Privileges->PrivilegeCount * sizeof(UNICODE_STRING);

    PrivilegeNames = MIDL_user_allocate( Size );

    if( PrivilegeNames == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    DeltaAccount->PrivilegeNames = PrivilegeNames;
    *BufferSize += Size;

    //
    // now fill up Privilege Attributes and Names
    //

    CopiedPrivilegeCount = 0;
    for( i = 0; i < Privileges->PrivilegeCount; i++ ) {

        //
        // Don't replicate SeMachineAccount privilege to NT 3.1.  It can't handle it.
        //  (Use the SUPPORTS_ACCOUNT_LOCKOUT bit so we don't have to consume
        //  another bit.)
        //
        if ( (SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_ACCOUNT_LOCKOUT) ||
             (!RtlEqualLuid((PLUID)(&Privileges->Privilege[i].Luid),
                            &MachineAccountPrivilegeLuid ))) {

            PLSAPR_UNICODE_STRING PrivName = NULL;

            *PrivilegeAttributes = Privileges->Privilege[i].Attributes;


            //
            // convert LUID to Name
            //

            STARTLSATIMER;

            Status = LsarLookupPrivilegeName(
                        DBInfo->DBHandle,
                        (PLUID)&Privileges->Privilege[i].Luid,
                        &PrivName );

            STOPLSATIMER;

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            *BufferSize += NlCopyUnicodeString(
                            (PUNICODE_STRING)PrivName,
                            PrivilegeNames );

            LsaIFree_LSAPR_UNICODE_STRING( PrivName );
            CopiedPrivilegeCount ++;
            PrivilegeAttributes++;
            PrivilegeNames++;
        } else {
            NlPrint((NL_SYNC_MORE,
                     "NlPackLsaAccount: ignored privilege %ld %ld\n",
                      (PLUID) LongToPtr( (&Privileges->Privilege[i].Luid)->HighPart ),
                      (PLUID) ULongToPtr( (&Privileges->Privilege[i].Luid)->LowPart ) ));
        }
    }
    DeltaAccount->PrivilegeEntries = CopiedPrivilegeCount;

    //
    // Send only those bits that NT4.0 BDC understands.
    //  Otherwise, it will choke on it.
    //
    DeltaAccount->SystemAccessFlags = SystemAccessFlags & POLICY_MODE_ALL_NT4;

    DELTA_SECOBJ_INFO(DeltaAccount);

    //
    // All Done
    //

    Status = STATUS_SUCCESS;

Cleanup:

    STARTLSATIMER;

    if ( AccountHandle != NULL ) {
        LsarClose( &AccountHandle );
    }

    if ( SecurityDescriptor != NULL ) {
        LsaIFree_LSAPR_SR_SECURITY_DESCRIPTOR( SecurityDescriptor );
    }

    if ( Privileges != NULL ) {
        LsaIFree_LSAPR_PRIVILEGE_SET( Privileges );
    }

    STOPLSATIMER;

    if( !NT_SUCCESS(Status) ) {
        NlFreeDBDelta( Delta );
        *BufferSize = 0;
    }

    STOPPACKTIMER;

    NlPrint((NL_REPL_OBJ_TIME,"Time taken to pack LSAACCOUNT object:\n"));
    PRINTPACKTIMER;
    PRINTLSATIMER;

    return(Status);

}



NTSTATUS
NlPackLsaSecret(
    IN PUNICODE_STRING Name,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize,
    IN PSESSION_INFO SessionInfo
    )
/*++

Routine Description:

    Pack a description of the specified LSA secret info into the
    specified buffer.

Arguments:

    Name - Name of the secret.

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

    SessionInfo: Information shared between BDC and PDC

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;

    PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor = NULL;

    LSAPR_HANDLE SecretHandle = NULL;

    PNETLOGON_DELTA_SECRET DeltaSecret = NULL;

    PLSAPR_CR_CIPHER_VALUE CurrentValue = NULL;
    PLSAPR_CR_CIPHER_VALUE OldValue = NULL;
    LARGE_INTEGER CurrentValueSetTime;
    LARGE_INTEGER OldValueSetTime;

    DEFPACKTIMER;
    DEFLSATIMER;

    INITPACKTIMER;
    INITLSATIMER;

    STARTPACKTIMER;

    NlPrint((NL_SYNC_MORE, "Packing Secret Object: %wZ\n", Name));

    //
    // we should be packing only GLOBAL secrets
    //

    NlAssert(
        (Name->Length / sizeof(WCHAR) >
                LSA_GLOBAL_SECRET_PREFIX_LENGTH ) &&
        (_wcsnicmp( Name->Buffer,
                 LSA_GLOBAL_SECRET_PREFIX,
                 LSA_GLOBAL_SECRET_PREFIX_LENGTH ) == 0) );

    *BufferSize = 0;

    Delta->DeltaType = AddOrChangeLsaSecret;
    Delta->DeltaID.Name = NULL;
    Delta->DeltaUnion.DeltaPolicy = NULL;

    //
    // open lsa account
    //

    STARTLSATIMER;

    Status = LsarOpenSecret(
                DBInfo->DBHandle,
                (PLSAPR_UNICODE_STRING)Name,
                0,
                &SecretHandle );

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        SecretHandle = NULL;
        goto Cleanup;
    }

    QUERY_LSA_SECOBJ_INFO(SecretHandle);

    STARTLSATIMER;

    Status = LsarQuerySecret(
                SecretHandle,
                &CurrentValue,
                &CurrentValueSetTime,
                &OldValue,
                &OldValueSetTime );

    STOPLSATIMER;

    if (!NT_SUCCESS(Status)) {
        CurrentValue = NULL;
        OldValue = NULL;
        goto Cleanup;
    }

    //
    // Fill in the delta structure
    //

    //
    // copy ID field
    //

    Delta->DeltaID.Name =
        MIDL_user_allocate( Name->Length + sizeof(WCHAR) );

    if( Delta->DeltaID.Name == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    wcsncpy( Delta->DeltaID.Name,
                Name->Buffer,
                Name->Length / sizeof(WCHAR) );

    //
    // terminate string
    //

    Delta->DeltaID.Name[ Name->Length / sizeof(WCHAR) ] = L'\0';


    DeltaSecret = (PNETLOGON_DELTA_SECRET)
        MIDL_user_allocate( sizeof(NETLOGON_DELTA_SECRET) );

    if( DeltaSecret == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaSecret, sizeof(NETLOGON_DELTA_SECRET) );
    // INIT_PLACE_HOLDER(DeltaSecret);

    Delta->DeltaUnion.DeltaSecret = DeltaSecret;
    *BufferSize += sizeof(NETLOGON_DELTA_SECRET);

    NEW_TO_OLD_LARGE_INTEGER(
        CurrentValueSetTime,
        DeltaSecret->CurrentValueSetTime );

    NEW_TO_OLD_LARGE_INTEGER(
        OldValueSetTime,
        DeltaSecret->OldValueSetTime );

    if( CurrentValue != NULL && CurrentValue->Buffer != NULL && CurrentValue->Length != 0) {

        //
        // Copy the secret into an allocated buffer and encrypt it in place.
        //  Don't use the LSA's buffer since it a ALLOCATE_ALL_NODES.
        //

        DeltaSecret->CurrentValue.Buffer =
            MIDL_user_allocate( CurrentValue->Length );

        if( DeltaSecret->CurrentValue.Buffer == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        DeltaSecret->CurrentValue.Length =
            DeltaSecret->CurrentValue.MaximumLength = CurrentValue->Length;
        RtlCopyMemory( DeltaSecret->CurrentValue.Buffer,
                       CurrentValue->Buffer,
                       CurrentValue->Length );


        //
        // secret values are encrypted using session keys.
        //

        Status = NlEncryptSensitiveData(
                        (PCRYPT_BUFFER) &DeltaSecret->CurrentValue,
                        SessionInfo );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

    } else {

        DeltaSecret->CurrentValue.Length = 0;
        DeltaSecret->CurrentValue.MaximumLength = 0;
        DeltaSecret->CurrentValue.Buffer = NULL;
    }

    *BufferSize += DeltaSecret->CurrentValue.MaximumLength;

    if( OldValue != NULL && OldValue->Buffer != NULL && OldValue->Length != 0 ) {

        //
        // Copy the secret into an allocated buffer and encrypt it in place.
        //  Don't use the LSA's buffer since it a ALLOCATE_ALL_NODES.
        //

        DeltaSecret->OldValue.Buffer =
            MIDL_user_allocate( OldValue->Length );

        if( DeltaSecret->OldValue.Buffer == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        DeltaSecret->OldValue.Length =
            DeltaSecret->OldValue.MaximumLength = OldValue->Length;
        RtlCopyMemory( DeltaSecret->OldValue.Buffer,
                       OldValue->Buffer,
                       OldValue->Length );


        //
        // secret values are encrypted using session keys.
        //

        Status = NlEncryptSensitiveData(
                        (PCRYPT_BUFFER) &DeltaSecret->OldValue,
                        SessionInfo );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

    } else {

        DeltaSecret->OldValue.Length = 0;
        DeltaSecret->OldValue.MaximumLength = 0;
        DeltaSecret->OldValue.Buffer = NULL;
    }

    *BufferSize += DeltaSecret->OldValue.MaximumLength;

    DELTA_SECOBJ_INFO(DeltaSecret);

    //
    // All Done
    //

    Status = STATUS_SUCCESS;

Cleanup:

    STARTLSATIMER;

    if ( SecretHandle != NULL ) {
        LsarClose( &SecretHandle );
    }

    if ( SecurityDescriptor != NULL ) {
        LsaIFree_LSAPR_SR_SECURITY_DESCRIPTOR( SecurityDescriptor );
    }

    if( CurrentValue != NULL ) {
        LsaIFree_LSAPR_CR_CIPHER_VALUE( CurrentValue );
    }

    if( OldValue != NULL ) {
        LsaIFree_LSAPR_CR_CIPHER_VALUE( OldValue );
    }

    STOPLSATIMER;

    if( !NT_SUCCESS(Status) ) {
        NlFreeDBDelta( Delta );
        *BufferSize = 0;
    }

    STOPPACKTIMER;

    NlPrint((NL_REPL_OBJ_TIME,"Time taken to pack SECRET object:\n"));
    PRINTPACKTIMER;
    PRINTLSATIMER;

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\lsrvdata.h ===
/*++

Copyright (c) 1987-1996 Microsoft Corporation

Module Name:

    lsrvdata.h

Abstract:

    Netlogon service global variable external and definitions

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.
    07-May-1992 JohnRo
        Use net config helpers for NetLogon.

--*/


//
// netlogon.c will #include this file with LSRVDATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
// If we need to allocate data (i.e. LSRVDATA_ALLOCATE is defined) we
// also want to allocate Guids, so define INITGUID.  Also, reinclude
// guiddef.h.  Without guiddef.h reincluded, DEFINE_GUID will be resolved
// from precompiled logonsrv.h that included this file with LSRVDATA_ALLOCATE
// not defined causing only external definition of Guids.  Reincluding
// guiddef.h here forces definition of INITGUID to take effect.
//
#ifdef LSRVDATA_ALLOCATE
#define EXTERN
#define INITGUID
#include <guiddef.h>
#else
#define EXTERN extern
#ifdef INITGUID
#undef INITGUID
#endif
#endif


///////////////////////////////////////////////////////////////////////////
//
// Modifiable Variables: these variables change over time.
//
///////////////////////////////////////////////////////////////////////////

//
// Global NetStatus of the Netlogon service
//

EXTERN SERVICE_STATUS NlGlobalServiceStatus;
#ifdef _DC_NETLOGON
EXTERN SERVICE_STATUS_HANDLE NlGlobalServiceHandle;
#endif // _DC_NETLOGON



///////////////////////////////////////////////////////////////////////////
//
// Read-only variables after initialization.
//
///////////////////////////////////////////////////////////////////////////

//
// Computername of this computer.
//

EXTERN LPWSTR NlGlobalUnicodeComputerName;

//
// True if this is a workstation or member server.
//

EXTERN BOOL NlGlobalMemberWorkstation;

#ifdef _DC_NETLOGON
//
// Handle to wait on for mailslot reads
//

EXTERN HANDLE NlGlobalMailslotHandle;
#endif // _DC_NETLOGON

//
// Flag to indicate when RPC has been started
//

EXTERN BOOL NlGlobalRpcServerStarted;
EXTERN BOOL NlGlobalTcpIpRpcServerStarted;
EXTERN BOOL NlGlobalServerSupportsAuthRpc;

//
// Service Termination event.
//

EXTERN HANDLE NlGlobalTerminateEvent;
EXTERN BOOL NlGlobalTerminate;
EXTERN BOOL NlGlobalUnloadNetlogon;

//
// Flags indicating if netlogon.dll was unloaded.
//
EXTERN BOOL NlGlobalNetlogonUnloaded;      // Used for one run of netlogon service
EXTERN BOOL NlGlobalChangeLogDllUnloaded;  // Used for life of netlogon.dll

//
// Service Started Event
//

EXTERN HANDLE NlGlobalStartedEvent;

//
// Timers need attention event.
//

EXTERN HANDLE NlGlobalTimerEvent;

//
// This #define allows netlogon instrumentation for rogue authorization info
// WE MUST NOT UNDER ANY CIRCUMSTANCES SHIP WITH THIS ACTIVE
//

// #define ROGUE_DC

#ifdef ROGUE_DC

EXTERN HKEY NlGlobalRogueKey;

#endif

//
// Command line arguments.
//

EXTERN NETLOGON_PARAMETERS NlGlobalParameters;
EXTERN CRITICAL_SECTION NlGlobalParametersCritSect;

EXTERN ULONG NlGlobalMaxConcurrentApi;

//
// Boolean to indicate weather the DC info left by
//  join has been read. If the info exists, the first
//  DC discovery for the primary domain will use the
//  info to return the DC that was used by join. That
//  DC is guaranteed to have the right machine pwd.

EXTERN BOOL NlGlobalJoinLogicDone;

//
// Global Flag used to partially pause the netlogon service until RPCSS is started.
//

EXTERN BOOL    NlGlobalPartialDisable;

//
// TRUE if the DS is being back synced
//
EXTERN BOOL NlGlobalDsPaused;
EXTERN HANDLE NlGlobalDsPausedEvent;
EXTERN HANDLE NlGlobalDsPausedWaitHandle;



//
// Global variables required for scavenger thread.
//

EXTERN TIMER NlGlobalScavengerTimer;
EXTERN CRITICAL_SECTION NlGlobalScavengerCritSect;
#ifdef _DC_NETLOGON
EXTERN BOOL NlGlobalDcScavengerIsRunning;
EXTERN WORKER_ITEM NlGlobalDcScavengerWorkItem;
#endif // _DC_NETLOGON

//
// Global list of outstanding challenge request/responses
//

EXTERN CRITICAL_SECTION NlGlobalChallengeCritSect;
EXTERN LIST_ENTRY NlGlobalChallengeList;
EXTERN ULONG NlGlobalChallengeCount;
//
// Variables for cordinating MSV threads running in netlogon.dll
//

EXTERN CRITICAL_SECTION NlGlobalMsvCritSect;
EXTERN HANDLE NlGlobalMsvTerminateEvent;
EXTERN BOOL NlGlobalMsvEnabled;
EXTERN ULONG NlGlobalMsvThreadCount;

//
// For workstations and non-DC servers,
//  maintain a list of domains trusted by our primary domain.
//
// Access serialized by NlGlobalDcDiscoveryCritSect
//

EXTERN PTRUSTED_DOMAIN NlGlobalTrustedDomainList;
EXTERN DWORD NlGlobalTrustedDomainCount;
EXTERN LARGE_INTEGER NlGlobalTrustedDomainListTime;

//
// Serialize DC Discovery activities
//

EXTERN CRITICAL_SECTION NlGlobalDcDiscoveryCritSect;

//
// Timer for timing out API calls to trusted domains
//
// Serialized using DomainInfo->DomTrustListCritSect.
//

EXTERN TIMER NlGlobalApiTimer;
EXTERN DWORD NlGlobalBindingHandleCount;

//
// For BDC, this is the session used to communicate with the PDC.
// For a workstation, this is the session used to communicate with a DC.
//

EXTERN PCLIENT_SESSION NlGlobalClientSession;

//
// This is a pointer to the DomainInfo structure for the primary domain.
//
EXTERN PDOMAIN_INFO NlGlobalDomainInfo;
EXTERN ULONG NlGlobalServicedDomainCount;  // This includes non-domain NCs
EXTERN CRITICAL_SECTION NlGlobalDomainCritSect;

//
// Global DB Info array
//
EXTERN DB_INFO  NlGlobalDBInfoArray[NUM_DBS];

//
// Critical section serializing startup and stopping of the replicator thread.
//

EXTERN CRITICAL_SECTION NlGlobalReplicatorCritSect;


//
// List of all BDC's the PDC has sent a pulse to.
//

EXTERN LIST_ENTRY NlGlobalBdcServerSessionList;
EXTERN ULONG NlGlobalBdcServerSessionCount;

EXTERN LIST_ENTRY NlGlobalPendingBdcList;
EXTERN ULONG NlGlobalPendingBdcCount;
EXTERN TIMER NlGlobalPendingBdcTimer;
EXTERN LIST_ENTRY NlGlobalBdcServerSessionList;
EXTERN ULONG NlGlobalBdcServerSessionCount;
EXTERN BOOL NlGlobalPrimaryAnnouncementIsRunning;

//
// Flag indicating that this is a PDC that's enabled to do replication to
//  a NT 3.X/4 BDC.
//  (Serialized by NlGlobalReplicatorCritSect)
//
BOOL NlGlobalPdcDoReplication;


//
// List of transports clients might connect to
//
EXTERN ULONG NlGlobalIpTransportCount;
EXTERN LIST_ENTRY NlGlobalTransportList;
EXTERN CRITICAL_SECTION NlGlobalTransportCritSect;

//
// List of IP addresses from Winsock.
//

EXTERN SOCKET NlGlobalWinsockPnpSocket;
EXTERN HANDLE NlGlobalWinsockPnpEvent;
EXTERN LPSOCKET_ADDRESS_LIST NlGlobalWinsockPnpAddresses;
EXTERN ULONG NlGlobalWinsockPnpAddressSize;

//
// List of all DNS names registered.
//

EXTERN LIST_ENTRY NlGlobalDnsList;
EXTERN CRITICAL_SECTION NlGlobalDnsCritSect;
EXTERN BOOLEAN NlGlobalWinSockInitialized;
EXTERN TIMER NlGlobalDnsScavengerTimer;

//
// Name of the tree this machine is in.
//
// Access serialized by NlGlobalDnsForestNameCritSect.
//
EXTERN CRITICAL_SECTION NlGlobalDnsForestNameCritSect;
EXTERN LPWSTR NlGlobalUnicodeDnsForestName;
EXTERN UNICODE_STRING NlGlobalUnicodeDnsForestNameString;
EXTERN ULONG NlGlobalUnicodeDnsForestNameLen;
EXTERN LPSTR NlGlobalUtf8DnsForestName;
EXTERN LPSTR NlGlobalUtf8DnsForestNameAlias;

//
// Critical section to protect access to covered site lists
//
EXTERN CRITICAL_SECTION NlGlobalSiteCritSect;

///////////////////////////////////////////////////////////////////////////
//
// Changelog Variables
//
///////////////////////////////////////////////////////////////////////////

//
// To serialize change log access
//

EXTERN CRITICAL_SECTION NlGlobalChangeLogCritSect;


//
// Amount SAM/LSA increments serial number by on promotion.
//
EXTERN LARGE_INTEGER NlGlobalChangeLogPromotionIncrement;
EXTERN LONG NlGlobalChangeLogPromotionMask;



//
// Netlogon started flag, used by the changelog to determine the
// netlogon service is successfully started and initialization
// completed.
//
EXTERN _CHANGELOG_NETLOGON_STATE NlGlobalChangeLogNetlogonState;


//
// Event to indicate that something interesting is being logged to the
// change log.  The booleans below (protected by NlGlobalChangeLogCritSect)
// indicate the actual interesting event.
//

EXTERN HANDLE NlGlobalChangeLogEvent;

//
// Indicates that a "replicate immediately" event has happened.
//

EXTERN BOOL NlGlobalChangeLogReplicateImmediately;

//
// Event to indicate that the trust data object has been updated.
//

EXTERN HANDLE NlGlobalTrustInfoUpToDateEvent;

//
// List of MachineAccount changes
//

EXTERN LIST_ENTRY NlGlobalChangeLogNotifications;

//
// Sid of the Builtin domain
//

EXTERN PSID NlGlobalChangeLogBuiltinDomainSid;

//
// A Zero GUID.
//

EXTERN GUID NlGlobalZeroGuid;

//
// The change log is a log of ALL changes made to the SAM/LSA databases.  The
// change log is maintained in serial number order.
//
EXTERN CHANGELOG_DESCRIPTOR NlGlobalChangeLogDesc;
EXTERN CHANGELOG_DESCRIPTOR NlGlobalTempChangeLogDesc;
EXTERN WCHAR NlGlobalChangeLogFilePrefix[MAX_PATH+1]; // Changelog file name. (w/o postfix)

//
// Bits describing services whether the DS, KDC, or time service are actually
//  running.
//

EXTERN DWORD NlGlobalChangeLogServiceBits;
EXTERN BOOLEAN NlGlobalDsRunningUnknown;


//
// Role of the machine from the change log's perspective.
//

EXTERN CHANGELOG_ROLE NlGlobalChangeLogRole;

//
// The name of the site this machine is in
//

EXTERN LPWSTR NlGlobalUnicodeSiteName;
EXTERN LPSTR NlGlobalUtf8SiteName;

//
// The time when the site name was set last time
//

EXTERN LARGE_INTEGER NlGlobalSiteNameSetTime;

//
// The last time the event log for clients with
//  no site was output. Access serialized by
//  NlGlobalSiteCritSect
//

EXTERN LARGE_INTEGER NlGlobalNoClientSiteEventTime;

//
// The number of times a client with no site was
//  detected during the last event log timeout period.
//  Access serialized by NlGlobalSiteCritSect
//

EXTERN ULONG NlGlobalNoClientSiteCount;

//
// The GUID of the DSA on this machine.
//

EXTERN GUID NlGlobalDsaGuid;

//
// Boolean indicating whether the DC demotion is in progress
//

EXTERN BOOLEAN NlGlobalDcDemotionInProgress;

//
// Handle to Cryptographic Service Provider
//

EXTERN HCRYPTPROV NlGlobalCryptProvider;

//
// Netlogon security package variables
//

CRITICAL_SECTION NlGlobalSecPkgCritSect;

//
// Handle to duplicate event log routines
//

HANDLE NlGlobalEventlogHandle;

//
// Handle to dynamically loaded ntdsa.dll
//

HANDLE NlGlobalNtDsaHandle;
HANDLE NlGlobalIsmDllHandle;
HANDLE NlGlobalDsApiDllHandle;

//
// Pointers to dynamically linked ntdsa.dll routines
//

PCrackSingleName NlGlobalpCrackSingleName;
PGetConfigurationName NlGlobalpGetConfigurationName;
PGetConfigurationNamesList NlGlobalpGetConfigurationNamesList;
PGetDnsRootAlias NlGlobalpGetDnsRootAlias;
PDsGetServersAndSitesForNetLogon NlGlobalpDsGetServersAndSitesForNetLogon;
PDsFreeServersAndSitesForNetLogon NlGlobalpDsFreeServersAndSitesForNetLogon;
PDsBindW NlGlobalpDsBindW;
PDsUnBindW NlGlobalpDsUnBindW;
PIsMangledRDNExternal NlGlobalpIsMangledRDNExternal;

//
// WMI tracing handles and GUIDs
//

EXTERN ULONG            NlpEventTraceFlag;
EXTERN TRACEHANDLE      NlpTraceRegistrationHandle;
EXTERN TRACEHANDLE      NlpTraceLoggerHandle;

// This is the control Guid for the group of Guids traced below
DEFINE_GUID ( /* f33959b4-dbec-11d2-895b-00c04f79ab69 */
    NlpControlGuid,
    0xf33959b4,
    0xdbec,
    0x11d2,
    0x89, 0x5b, 0x00, 0xc0, 0x4f, 0x79, 0xab, 0x69
  );

DEFINE_GUID ( /* 393da8c0-dbed-11d2-895b-00c04f79ab69 */
    NlpServerAuthGuid,
    0x393da8c0,
    0xdbed,
    0x11d2,
    0x89, 0x5b, 0x00, 0xc0, 0x4f, 0x79, 0xab, 0x69
  );

DEFINE_GUID ( /* 63dbb180-dbed-11d2-895b-00c04f79ab69 */
    NlpSecureChannelSetupGuid,
    0x63dbb180,
    0xdbed,
    0x11d2,
    0x89, 0x5b, 0x00, 0xc0, 0x4f, 0x79, 0xab, 0x69
  );

#undef EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\lsrvutil.c ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    lsrvutil.c

Abstract:

    Utility functions for the netlogon service.

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    00-Jun-1989 (PradyM)
        modified lm10 code for new NETLOGON service

    00-Feb-1990 (PradyM)
        bugfixes

    00-Aug-1990 (t-RichE)
        added alerts for auth failure due to time slippage

    11-Jul-1991 (cliffv)
        Ported to NT.  Converted to NT style.

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//

#include <accessp.h>    // NetpAliasMemberToPriv
#include <msgtext.h>    // MTXT_* defines
#include <netcan.h>     // NetpwPathCompare()
#include <ssiapi.h>     // I_NetSamDeltas()

/*lint -e740 */  /* don't complain about unusual cast */


#define MAX_DC_AUTHENTICATION_WAIT (long) (45L*1000L)             // 45 seconds

//
// We want to prevent too-frequent alerts from
// being sent in case of Authentication failures.
//

#define MAX_ALERTS    10        // send one every 10 to 30 mins based on pulse


VOID
RaiseNetlogonAlert(
    IN DWORD alertNum,
    IN LPWSTR *AlertStrings,
    IN OUT DWORD *ptrAlertCount
    )
/*++

Routine Description:

    Raise an alert once per MAX_ALERTS occurances

Arguments:

    alertNum -- RaiseAlert() alert number.

    AlertStrings -- RaiseAlert() arguments

    ptrAlertCount -- Points to the count of occurence of this particular
        alert.  This routine increments it and will set it to that value
        modulo MAX_ALERTS.

Return Value:

    NONE

--*/
{
    if (*ptrAlertCount == 0) {
        NetpRaiseAlert( SERVICE_NETLOGON, alertNum, AlertStrings);
    }
    (*ptrAlertCount)++;
    (*ptrAlertCount) %= MAX_ALERTS;
}





NTSTATUS
NlOpenSecret(
    IN PCLIENT_SESSION ClientSession,
    IN ULONG DesiredAccess,
    OUT PLSAPR_HANDLE SecretHandle
    )
/*++

Routine Description:


    Open the Lsa Secret Object containing the password to be used for the
    specified client session.

Arguments:

    ClientSession - Structure used to define the session.
        On Input, the following fields must be set:
            CsNetbiosDomainName
            CsSecureChannelType

    DesiredAccess - Access required to the secret.

    SecretHandle - Returns a handle to the secret.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING SecretNameString;

    NlAssert( ClientSession->CsReferenceCount > 0 );

    //
    // Only use secrets for workstation and BDC machine accounts.
    //

    switch ( ClientSession->CsSecureChannelType ) {
    case ServerSecureChannel:
    case WorkstationSecureChannel:
        RtlInitUnicodeString( &SecretNameString, SSI_SECRET_NAME );
        break;

    case TrustedDomainSecureChannel:
    case TrustedDnsDomainSecureChannel:
    default:
        Status = STATUS_INTERNAL_ERROR;
        NlPrint((NL_CRITICAL, "NlOpenSecret: Invalid account type\n"));
        return Status;

    }

    //
    // Get the Password of the account from LSA secret storage
    //


    Status = LsarOpenSecret(
                ClientSession->CsDomainInfo->DomLsaPolicyHandle,
                (PLSAPR_UNICODE_STRING)&SecretNameString,
                DesiredAccess,
                SecretHandle );

    return Status;

}


NTSTATUS
NlGetOutgoingPassword(
    IN PCLIENT_SESSION ClientSession,
    OUT PUNICODE_STRING *CurrentValue,
    OUT PUNICODE_STRING *OldValue,
    OUT PDWORD CurrentVersionNumber,
    OUT PLARGE_INTEGER LastSetTime OPTIONAL
    )
/*++

Routine Description:

    Get the outgoing password to be used for the specified client session.

Arguments:

    ClientSession - Structure used to define the session.
        On Input, the following fields must be set:
            CsNetbiosDomainName
            CsSecureChannelType

    CurrentValue - Current password for the client session.
        CurrentValue should be freed using LocalFree
        A NULL pointer is returned if there is no current password.

    OldValue - Previous password for the client session.
        OldValue should be freed using LocalFree
        A NULL pointer is returned if there is no old password.

    CurrentVersionNumber - Version number of the current password
        for interdomain trust account. Set to 0 on failure status
        or if this is not interdomain trust account.

    LastSetTime - Time when the password was last changed.

Return Value:

    Status of operation.

    STATUS_NO_TRUST_LSA_SECRET: Secret object is not accessable
    STATUS_NO_MEMORY: Not enough memory to allocate password buffers

--*/
{
    NTSTATUS Status;
    LSAPR_HANDLE SecretHandle = NULL;

    PLSAPR_CR_CIPHER_VALUE CrCurrentPassword = NULL;
    PLSAPR_CR_CIPHER_VALUE CrOldPassword = NULL;

    PLSAPR_TRUSTED_DOMAIN_INFO TrustInfo = NULL;
    PLSAPR_AUTH_INFORMATION AuthInfo;
    PLSAPR_AUTH_INFORMATION OldAuthInfo;
    ULONG AuthInfoCount;
    ULONG i;
    BOOL PasswordFound = FALSE;
    BOOL PasswordVersionFound = FALSE;

    //
    // Initialization
    //

    *CurrentValue = NULL;
    *OldValue = NULL;
    *CurrentVersionNumber = 0;


    //
    // Workstation and BDC secure channels get their outgoing password from
    //  an LSA secret.
    //
    switch ( ClientSession->CsSecureChannelType ) {
    case ServerSecureChannel:
    case WorkstationSecureChannel:
        //
        // Get the Password of the account from LSA secret storage
        //

        Status = NlOpenSecret( ClientSession, SECRET_QUERY_VALUE, &SecretHandle );

        if ( !NT_SUCCESS( Status ) ) {

            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlGetOutgoingPassword: cannot NlOpenSecret 0x%lx\n",
                    Status ));

            //
            // return more appropriate error.
            //

            if ( !NlpIsNtStatusResourceError( Status )) {
                Status = STATUS_NO_TRUST_LSA_SECRET;
            }
            goto Cleanup;
        }

        Status = LsarQuerySecret(
                    SecretHandle,
                    &CrCurrentPassword,
                    LastSetTime,
                    &CrOldPassword,
                    NULL );

        if ( !NT_SUCCESS( Status ) ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlGetOutgoingPassword: cannot LsaQuerySecret 0x%lx\n",
                    Status ));

            //
            // return more appropriate error.
            //

            if ( !NlpIsNtStatusResourceError( Status )) {
                Status = STATUS_NO_TRUST_LSA_SECRET;
            }
            goto Cleanup;
        }

        //
        // Copy the current password back to the caller.
        //
        if ( CrCurrentPassword != NULL ) {
            *CurrentValue = LocalAlloc(0, sizeof(UNICODE_STRING)+CrCurrentPassword->Length+sizeof(WCHAR) );

            if ( *CurrentValue == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            (*CurrentValue)->Buffer = (LPWSTR)(((LPBYTE)(*CurrentValue))+sizeof(UNICODE_STRING));
            RtlCopyMemory( (*CurrentValue)->Buffer, CrCurrentPassword->Buffer, CrCurrentPassword->Length );
            (*CurrentValue)->Length = (USHORT)CrCurrentPassword->Length;
            (*CurrentValue)->MaximumLength = (USHORT)((*CurrentValue)->Length + sizeof(WCHAR));
            (*CurrentValue)->Buffer[(*CurrentValue)->Length/sizeof(WCHAR)] = L'\0';

        }

        //
        // Copy the Old password back to the caller.
        //
        if ( CrOldPassword != NULL ) {
            *OldValue = LocalAlloc(0, sizeof(UNICODE_STRING)+CrOldPassword->Length+sizeof(WCHAR) );

            if ( *OldValue == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            (*OldValue)->Buffer = (LPWSTR)(((LPBYTE)(*OldValue))+sizeof(UNICODE_STRING));
            RtlCopyMemory( (*OldValue)->Buffer, CrOldPassword->Buffer, CrOldPassword->Length );
            (*OldValue)->Length = (USHORT)CrOldPassword->Length;
            (*OldValue)->MaximumLength = (USHORT)((*OldValue)->Length + sizeof(WCHAR));
            (*OldValue)->Buffer[(*OldValue)->Length/sizeof(WCHAR)] = L'\0';

        }

        break;

    //
    // Trusted domain secure channels get their outgoing password from the trusted
    //  domain object.
    //

    case TrustedDomainSecureChannel:
    case TrustedDnsDomainSecureChannel:


        //
        // Get the authentication information from the LSA.
        //
        Status = LsarQueryTrustedDomainInfoByName(
                    ClientSession->CsDomainInfo->DomLsaPolicyHandle,
                    (PLSAPR_UNICODE_STRING) ClientSession->CsTrustName,
                    TrustedDomainAuthInformation,
                    &TrustInfo );

        if (!NT_SUCCESS(Status)) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlGetOutgoingPassword: %wZ: cannot LsarQueryTrustedDomainInfoByName 0x%lx\n",
                    ClientSession->CsTrustName,
                    Status ));
            if ( !NlpIsNtStatusResourceError( Status )) {
                Status = STATUS_NO_TRUST_LSA_SECRET;
            }
            goto Cleanup;
        }

        AuthInfoCount = TrustInfo->TrustedAuthInfo.OutgoingAuthInfos;
        AuthInfo = TrustInfo->TrustedAuthInfo.OutgoingAuthenticationInformation;
        OldAuthInfo = TrustInfo->TrustedAuthInfo.OutgoingPreviousAuthenticationInformation;

        if (AuthInfoCount == 0 || AuthInfo == NULL) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlGetOutgoingPassword: %wZ: No auth info for this domain.\n",
                    ClientSession->CsTrustName ));
            Status = STATUS_NO_TRUST_LSA_SECRET;
            goto Cleanup;
        }
        NlAssert( OldAuthInfo != NULL );

        //
        // Loop through the various auth infos looking for the cleartext password
        // and its version number.
        //

        for ( i=0; i<AuthInfoCount; i++ ) {

            //
            // Handle the cleartext password
            //

            if ( AuthInfo[i].AuthType == TRUST_AUTH_TYPE_CLEAR && !PasswordFound ) {

                //
                // Copy the current password back to the caller.
                //
                *CurrentValue = LocalAlloc(0, sizeof(UNICODE_STRING)+AuthInfo[i].AuthInfoLength+sizeof(WCHAR) );

                if ( *CurrentValue == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                (*CurrentValue)->Buffer = (LPWSTR)(((LPBYTE)(*CurrentValue))+sizeof(UNICODE_STRING));
                RtlCopyMemory( (*CurrentValue)->Buffer, AuthInfo[i].AuthInfo, AuthInfo[i].AuthInfoLength );
                (*CurrentValue)->Length = (USHORT)AuthInfo[i].AuthInfoLength;
                (*CurrentValue)->MaximumLength = (USHORT)((*CurrentValue)->Length + sizeof(WCHAR));
                (*CurrentValue)->Buffer[(*CurrentValue)->Length/sizeof(WCHAR)] = L'\0';

                //
                // Copy the password change time back to the caller.
                //

                if ( ARGUMENT_PRESENT( LastSetTime )) {
                    *LastSetTime = AuthInfo[i].LastUpdateTime;
                }

                //
                // Only copy the old password if it is also clear.
                //

                if ( OldAuthInfo[i].AuthType == TRUST_AUTH_TYPE_CLEAR ) {

                    //
                    // Copy the Old password back to the caller.
                    //
                    *OldValue = LocalAlloc(0, sizeof(UNICODE_STRING)+OldAuthInfo[i].AuthInfoLength+sizeof(WCHAR) );

                    if ( *OldValue == NULL ) {
                        Status = STATUS_NO_MEMORY;
                        goto Cleanup;
                    }

                    (*OldValue)->Buffer = (LPWSTR)(((LPBYTE)(*OldValue))+sizeof(UNICODE_STRING));
                    RtlCopyMemory( (*OldValue)->Buffer, OldAuthInfo[i].AuthInfo, OldAuthInfo[i].AuthInfoLength );
                    (*OldValue)->Length = (USHORT)OldAuthInfo[i].AuthInfoLength;
                    (*OldValue)->MaximumLength = (USHORT)((*OldValue)->Length + sizeof(WCHAR));
                    (*OldValue)->Buffer[(*OldValue)->Length/sizeof(WCHAR)] = L'\0';
                }

                PasswordFound = TRUE;
                if ( PasswordVersionFound ) {
                    break;
                }

            //
            // Handle the version number of the cleartext password
            //

            } else if ( AuthInfo[i].AuthType == TRUST_AUTH_TYPE_VERSION && !PasswordVersionFound &&
                        AuthInfo[i].AuthInfoLength == sizeof(*CurrentVersionNumber) ) {
                RtlCopyMemory( CurrentVersionNumber, AuthInfo[i].AuthInfo, AuthInfo[i].AuthInfoLength );

                PasswordVersionFound = TRUE;
                if ( PasswordFound ) {
                    break;
                }
            }

        }

        //if ( i == AuthInfoCount ) {
        if ( !PasswordFound ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlGetOutgoingPassword: %wZ: No clear password for this domain.\n",
                    ClientSession->CsTrustName ));
            Status = STATUS_NO_TRUST_LSA_SECRET;
            goto Cleanup;
        }
        break;

    default:
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlGetOutgoingPassword: invalid secure channel type\n" ));
        Status = STATUS_NO_TRUST_LSA_SECRET;
        goto Cleanup;
    }



    Status = STATUS_SUCCESS;


    //
    // Free locally used resources.
    //
Cleanup:
    if ( !NT_SUCCESS(Status) ) {
        if ( *CurrentValue != NULL ) {
            LocalFree( *CurrentValue );
            *CurrentValue = NULL;
        }
        if ( *OldValue != NULL ) {
            LocalFree( *OldValue );
            *OldValue = NULL;
        }
        *CurrentVersionNumber = 0;
    }

    if ( SecretHandle != NULL ) {
        (VOID) LsarClose( &SecretHandle );
    }

    if ( CrCurrentPassword != NULL ) {
        (VOID) LsaIFree_LSAPR_CR_CIPHER_VALUE ( CrCurrentPassword );
    }

    if ( CrOldPassword != NULL ) {
        (VOID) LsaIFree_LSAPR_CR_CIPHER_VALUE ( CrOldPassword );
    }

    if ( TrustInfo != NULL ) {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO( TrustedDomainAuthInformation,
                                            TrustInfo );
    }

    return Status;
}


NTSTATUS
NlSetOutgoingPassword(
    IN PCLIENT_SESSION ClientSession,
    IN PUNICODE_STRING CurrentValue OPTIONAL,
    IN PUNICODE_STRING OldValue OPTIONAL,
    IN DWORD CurrentVersionNumber,
    IN DWORD OldVersionNumber
    )
/*++

Routine Description:

    Set the outgoing password to be used for the specified client session.

Arguments:

    ClientSession - Structure used to define the session.

    CurrentValue - Current password for the client session.
        A NULL pointer indicates there is no current password (blank password)

    OldValue - Previous password for the client session.
        A NULL pointer indicates there is no old password (blank password)

    CurrentVersionNumber - The version number of the Current password.
        Ignored if this is not an interdomain trust account.

    OldVersionNumber - The version number of the Old password.
        Ignored if this is not an interdomain trust account.

Return Value:

    Status of operation.


--*/
{
    NTSTATUS Status;
    LSAPR_HANDLE SecretHandle = NULL;

    UNICODE_STRING LocalNullPassword;
    LSAPR_CR_CIPHER_VALUE CrCurrentPassword;
    LSAPR_CR_CIPHER_VALUE CrOldPassword;

    LSAPR_TRUSTED_DOMAIN_INFO TrustInfo;
    LSAPR_AUTH_INFORMATION CurrentAuthInfo[2];
    LSAPR_AUTH_INFORMATION OldAuthInfo[2];

    //
    // Initialization
    //

    if ( CurrentValue == NULL ) {
        CurrentValue = &LocalNullPassword;
        RtlInitUnicodeString( &LocalNullPassword, NULL );
    }

    if ( OldValue == NULL ) {
        OldValue = &LocalNullPassword;
        RtlInitUnicodeString( &LocalNullPassword, NULL );
    }


    //
    // Workstation and BDC secure channels get their outgoing password from
    //  an LSA secret.
    //
    switch ( ClientSession->CsSecureChannelType ) {
    case ServerSecureChannel:
    case WorkstationSecureChannel:
        //
        // Open the LSA secret to set.
        //

        Status = NlOpenSecret( ClientSession, SECRET_SET_VALUE, &SecretHandle );

        if ( !NT_SUCCESS( Status ) ) {

            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSetOutgoiningPassword: cannot NlOpenSecret 0x%lx\n",
                    Status ));
            goto Cleanup;
        }

        //
        // Convert the current password to LSA'ese.
        //

        CrCurrentPassword.Buffer = (LPBYTE)CurrentValue->Buffer;
        CrCurrentPassword.Length = CurrentValue->Length;
        CrCurrentPassword.MaximumLength = CurrentValue->MaximumLength;

        //
        // Convert the old password to LSA'ese.
        //

        CrOldPassword.Buffer = (LPBYTE)OldValue->Buffer;
        CrOldPassword.Length = OldValue->Length;
        CrOldPassword.MaximumLength = OldValue->MaximumLength;

        Status = LsarSetSecret(
                    SecretHandle,
                    &CrCurrentPassword,
                    &CrOldPassword );

        if ( !NT_SUCCESS( Status ) ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSetOutgoingPassword: cannot LsarSetSecret 0x%lx\n",
                    Status ));
            goto Cleanup;
        }

        break;

    //
    // Trusted domain secure channels get their outgoing password from the trusted
    //  domain object.
    //

    case TrustedDomainSecureChannel:
    case TrustedDnsDomainSecureChannel:

        //
        // Fill in the trust information.
        //

        RtlZeroMemory( &TrustInfo, sizeof(TrustInfo) );

        TrustInfo.TrustedAuthInfo.OutgoingAuthInfos = 2;
        TrustInfo.TrustedAuthInfo.OutgoingAuthenticationInformation =
            CurrentAuthInfo;
        TrustInfo.TrustedAuthInfo.OutgoingPreviousAuthenticationInformation =
            OldAuthInfo;

        //
        // Fill in the current authentication information.
        //

        NlQuerySystemTime( &CurrentAuthInfo[0].LastUpdateTime );
        CurrentAuthInfo[0].AuthType = TRUST_AUTH_TYPE_CLEAR;
        CurrentAuthInfo[0].AuthInfoLength = CurrentValue->Length;
        CurrentAuthInfo[0].AuthInfo = (LPBYTE)CurrentValue->Buffer;

        //
        // Fill in the current password version number
        //

        CurrentAuthInfo[1].LastUpdateTime = CurrentAuthInfo[0].LastUpdateTime;
        CurrentAuthInfo[1].AuthType = TRUST_AUTH_TYPE_VERSION;
        CurrentAuthInfo[1].AuthInfoLength = sizeof( CurrentVersionNumber );
        CurrentAuthInfo[1].AuthInfo = (LPBYTE) &CurrentVersionNumber;

        //
        // Fill in the old authentication information.
        //

        OldAuthInfo[0].LastUpdateTime = CurrentAuthInfo[0].LastUpdateTime;
        OldAuthInfo[0].AuthType = TRUST_AUTH_TYPE_CLEAR;
        OldAuthInfo[0].AuthInfoLength = OldValue->Length;
        OldAuthInfo[0].AuthInfo = (LPBYTE)OldValue->Buffer;

        //
        // Fill in the old password version number.
        //

        OldAuthInfo[1].LastUpdateTime = CurrentAuthInfo[0].LastUpdateTime;
        OldAuthInfo[1].AuthType = TRUST_AUTH_TYPE_VERSION;
        OldAuthInfo[1].AuthInfoLength = sizeof( OldVersionNumber );
        OldAuthInfo[1].AuthInfo = (LPBYTE) &OldVersionNumber;


        //
        // Get the authentication information from the LSA.
        //
        Status = LsarSetTrustedDomainInfoByName(
                    ClientSession->CsDomainInfo->DomLsaPolicyHandle,
                    (PLSAPR_UNICODE_STRING) ClientSession->CsTrustName,
                    TrustedDomainAuthInformation,
                    &TrustInfo );

        if (!NT_SUCCESS(Status)) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSetOutgoingPassword: %wZ: cannot LsarSetTrustedDomainInfoByName 0x%lx\n",
                    ClientSession->CsTrustName,
                    Status ));
            if ( !NlpIsNtStatusResourceError( Status )) {
                Status = STATUS_NO_TRUST_LSA_SECRET;
            }
            goto Cleanup;
        }

        //
        // Be verbose
        //

        NlPrint(( NL_SESSION_SETUP, "NlSetOutgoingPassword: Current Clear Text Password is: " ));
        NlpDumpBuffer(NL_SESSION_SETUP, CurrentAuthInfo[0].AuthInfo, CurrentAuthInfo[0].AuthInfoLength );
        NlPrint(( NL_SESSION_SETUP, "NlSetOutgoingPassword: Current Clear Password Version Number is: 0x%lx\n",
                  CurrentVersionNumber ));
        NlPrint(( NL_SESSION_SETUP, "NlSetOutgoingPassword: Previous Clear Text Password is: " ));
        NlpDumpBuffer(NL_SESSION_SETUP, OldAuthInfo[0].AuthInfo, OldAuthInfo[0].AuthInfoLength );
        NlPrint(( NL_SESSION_SETUP, "NlSetOutgoingPassword: Previous Clear Password Version Number is: 0x%lx\n",
                  OldVersionNumber ));

        break;

    default:
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlSetOutgoingPassword: invalid secure channel type\n" ));
        Status = STATUS_NO_TRUST_LSA_SECRET;
        goto Cleanup;
    }



    Status = STATUS_SUCCESS;


    //
    // Free locally used resources.
    //
Cleanup:
    if ( SecretHandle != NULL ) {
        (VOID) LsarClose( &SecretHandle );
    }

    return Status;
}


NTSTATUS
NlGetIncomingPassword(
    IN PDOMAIN_INFO DomainInfo,
    IN LPCWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN ULONG AllowableAccountControlBits,
    IN BOOL CheckAccountDisabled,
    OUT PNT_OWF_PASSWORD OwfPassword OPTIONAL,
    OUT PNT_OWF_PASSWORD OwfPreviousPassword OPTIONAL,
    OUT PULONG AccountRid OPTIONAL,
    OUT PULONG TrustAttributes OPTIONAL,
    OUT PBOOL IsDnsDomainTrustAccount OPTIONAL
    )
/*++

Routine Description:

    Get the incoming password for the specified AccountName and SecureChannelType

    Check the machine account:
        Ensure the SecureChannelType is valid,
        Verify that the account exists,
        Ensure the user account is the right account type.

Arguments:

    DomainInfo - Emulated domain

    AccountName - Name of the account to authenticate with.

    SecureChannelType - The type of the account.
        Use NullSecureChannel if channel type is not known.

    AllowableAccountControlBits - The type of the account.
        Use 0 if AccountControlBits is not known.
        Typically only one of AllowableAccountControlBits or SecureChannelType
        will be specified.

    CheckAccountDisabled - TRUE if we should return an error if the account
        is disabled.

    OwfPassword - Returns the NT OWF of the incoming password for the named
        account.  If NULL, the password is not returned.

    OwfPreviousPassword - Returns the NT OWF of the incoming previous password for
    the named interdomain trust account.  If NULL, the password is not returned.
    If OwfPreviousPassword is not NULL, OwfPassword must not be NULL either;
    otherwise the function asserts.  If OwfPreviousPassword is not NULL and the
    account is not interdomain, the function asserts.  If both OwfPassword and
    OwfPreviousPassword are NULL, the account is only checked for validity.

    AccountRid - Returns the RID of AccountName

    TrustAttributes - Returns the TrustAttributes for the interdomain trust account.

    IsDnsDomainTrustAccount - Returns TRUE if the passed in account name is the
        DNS domain name of an uplevel domain trust.  Set only if the account control
        bits (either passed directly or determined from the secure channel type)
        correspond to an interdomain trust account.

Return Value:

    Status of operation.


--*/
{
    NTSTATUS Status;

    SAMPR_HANDLE UserHandle = NULL;
    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL;

    ULONG Length;
    PLSAPR_TRUSTED_DOMAIN_INFO TrustInfo = NULL;
    PLSAPR_AUTH_INFORMATION AuthInfo;
    ULONG AuthInfoCount;
    BOOL PasswordFound = FALSE;
    BOOL PreviousPasswordFound = FALSE;
    ULONG i;

    //
    // Initialization
    //

    if ( ARGUMENT_PRESENT(AccountRid) ) {
        *AccountRid = 0;
    }

    if ( ARGUMENT_PRESENT(TrustAttributes) ) {
        *TrustAttributes = 0;
    }

    if ( ARGUMENT_PRESENT(IsDnsDomainTrustAccount) ) {
        *IsDnsDomainTrustAccount = FALSE;  // assume it's not and prove if otherwise
    }

    Length = wcslen( AccountName );
    if ( Length < 1 ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Convert the secure channel type to allowable account control bits.
    //

    switch (SecureChannelType) {
    case WorkstationSecureChannel:
        AllowableAccountControlBits |= USER_WORKSTATION_TRUST_ACCOUNT;
        break;

    case ServerSecureChannel:
        AllowableAccountControlBits |= USER_SERVER_TRUST_ACCOUNT;
        break;

    case TrustedDomainSecureChannel:
        AllowableAccountControlBits |= USER_INTERDOMAIN_TRUST_ACCOUNT;
        break;

    case TrustedDnsDomainSecureChannel:
        AllowableAccountControlBits |= USER_DNS_DOMAIN_TRUST_ACCOUNT;
        break;

    case NullSecureChannel:
        if ( AllowableAccountControlBits == 0 ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                            "NlGetIncomingPassword: Invalid AAC (%x) for %ws\n",
                            AllowableAccountControlBits,
                            AccountName ));
            return STATUS_INVALID_PARAMETER;
        }
        break;

    default:
        NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NlGetIncomingPassword: Invalid channel type (%x) for %ws\n",
                        SecureChannelType,
                        AccountName ));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If this is an interdomain trust account,
    //  use an interdomain trust object.
    //

    if ( AllowableAccountControlBits == USER_DNS_DOMAIN_TRUST_ACCOUNT ||
         AllowableAccountControlBits == USER_INTERDOMAIN_TRUST_ACCOUNT ) {
        UNICODE_STRING AccountNameString;

        //
        // If this is a DNS trust account,
        //  remove the optional . from the end of the account name.
        //

        RtlInitUnicodeString( &AccountNameString, AccountName );
        if ( AllowableAccountControlBits == USER_DNS_DOMAIN_TRUST_ACCOUNT ) {
            if ( Length != 0 && AccountName[Length-1] == '.' ) {
                AccountNameString.Length -= sizeof(WCHAR);
            }

        //
        // If this is an NT4-style interdomain trust,
        //  remove the $ from the end of the account name.
        //
        } else {

             //
             // Ensure the account name has the correct postfix.
             //

             if ( Length <= SSI_ACCOUNT_NAME_POSTFIX_LENGTH ) {
                 return STATUS_NO_SUCH_USER;
             }

             if ( _wcsicmp(&AccountName[Length - SSI_ACCOUNT_NAME_POSTFIX_LENGTH],
                 SSI_ACCOUNT_NAME_POSTFIX) != 0 ) {
                 return STATUS_NO_SUCH_USER;
             }

             AccountNameString.Length -= SSI_ACCOUNT_NAME_POSTFIX_LENGTH*sizeof(WCHAR);

        }



        //
        // Get the authentication information from the LSA.
        //

        Status = LsarQueryTrustedDomainInfoByName(
                    DomainInfo->DomLsaPolicyHandle,
                    (PLSAPR_UNICODE_STRING) &AccountNameString,
                    TrustedDomainFullInformation,
                    &TrustInfo );

        if (!NT_SUCCESS(Status)) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlGetIncomingPassword: %wZ: cannot LsarQueryTrustedDomainInfoByName 0x%lx\n",
                    &AccountNameString,
                    Status ));
            if ( !NlpIsNtStatusResourceError( Status )) {
                Status = STATUS_NO_SUCH_USER;
            }
            goto Cleanup;
        }

        //
        // Ensure the attributes of the trust account are right.
        //
        if ( (TrustInfo->TrustedFullInfo.Information.TrustDirection & TRUST_DIRECTION_INBOUND) == 0 ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlGetIncomingPassword: %wZ: trust is not inbound\n",
                    &AccountNameString ));
            Status = STATUS_NO_SUCH_USER;
            goto Cleanup;
        }

        if ( TrustInfo->TrustedFullInfo.Information.TrustType != TRUST_TYPE_DOWNLEVEL &&
             TrustInfo->TrustedFullInfo.Information.TrustType != TRUST_TYPE_UPLEVEL ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlGetIncomingPassword: %wZ: trust type doesn't match request type 0x%lx %ld\n",
                    &AccountNameString,
                    AllowableAccountControlBits,
                    TrustInfo->TrustedFullInfo.Information.TrustType ));
            Status = STATUS_NO_SUCH_USER;
            goto Cleanup;
        }

        if ( TrustInfo->TrustedFullInfo.Information.TrustAttributes & TRUST_ATTRIBUTE_UPLEVEL_ONLY ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlGetIncomingPassword: %wZ: trust is KERB only\n",
                    &AccountNameString ));
            Status = STATUS_NO_SUCH_USER;
            goto Cleanup;
        }

        //
        // Return the trust attributes to the caller
        //

        if ( ARGUMENT_PRESENT(TrustAttributes) ) {
            *TrustAttributes = TrustInfo->TrustedFullInfo.Information.TrustAttributes;
        }

        //
        // Determine whether the passed account is a DNS domain trust account
        //
        // Simply check if this is a uplevel trust and if the account name passed
        //  is the Name of the trusted domain
        //

        if ( ARGUMENT_PRESENT(IsDnsDomainTrustAccount) ) {
            if ( TrustInfo->TrustedFullInfo.Information.TrustType == TRUST_TYPE_UPLEVEL &&
                 TrustInfo->TrustedFullInfo.Information.Name.Length > 0 ) {
                LPWSTR DnsDomainNameString = NULL;

                DnsDomainNameString = LocalAlloc( 0,
                      TrustInfo->TrustedFullInfo.Information.Name.Length + sizeof(WCHAR) );

                if ( DnsDomainNameString == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }
                RtlCopyMemory( DnsDomainNameString,
                               TrustInfo->TrustedFullInfo.Information.Name.Buffer,
                               TrustInfo->TrustedFullInfo.Information.Name.Length );
                DnsDomainNameString[ TrustInfo->TrustedFullInfo.Information.Name.Length/sizeof(WCHAR) ] = L'\0';

                //
                // Note that we don't have to remove the trailing dot
                //  in AccountName if present because the DNS comprare
                //  API ignores trailing dots.
                //
                *IsDnsDomainTrustAccount = NlEqualDnsName(DnsDomainNameString, AccountName);

                LocalFree( DnsDomainNameString );
            }
        }

        //
        // Only get the password if the caller really wants it.
        //

        if ( OwfPassword != NULL ) {
            AuthInfoCount = TrustInfo->TrustedFullInfo.AuthInformation.IncomingAuthInfos;
            AuthInfo = TrustInfo->TrustedFullInfo.AuthInformation.IncomingAuthenticationInformation;

            if (AuthInfoCount == 0 || AuthInfo == NULL) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NlGetIncomingPassword: %wZ: No auth info for this domain.\n",
                        &AccountNameString ));
                Status = STATUS_NO_SUCH_USER;
                goto Cleanup;
            }

            //
            // Loop through the various auth infos looking for the cleartext password
            //  or NT OWF password.
            //
            // If there is a clear text password, use it.
            // Otherwise, use the NT OWF password.
            //

            for ( i=0; i<AuthInfoCount; i++ ) {

                //
                // Handle an NT OWF password.
                //

                if ( AuthInfo[i].AuthType == TRUST_AUTH_TYPE_NT4OWF ) {

                    //
                    // Only use the OWF if it is valid
                    //

                    if ( AuthInfo[i].AuthInfoLength != sizeof(*OwfPassword) ) {
                        NlPrintDom((NL_CRITICAL, DomainInfo,
                                "NlGetIncomingPassword: %wZ: OWF password has bad length %ld\n",
                                &AccountNameString,
                                AuthInfo[i].AuthInfoLength ));
                    } else {
                        RtlCopyMemory( OwfPassword, AuthInfo[i].AuthInfo, sizeof(*OwfPassword) );
                        PasswordFound = TRUE;
                    }

                }

                //
                // Handle a cleartext password.
                //

                else if ( AuthInfo[i].AuthType == TRUST_AUTH_TYPE_CLEAR ) {
                    UNICODE_STRING TempUnicodeString;

                    TempUnicodeString.Buffer = (LPWSTR)AuthInfo[i].AuthInfo;
                    TempUnicodeString.MaximumLength =
                        TempUnicodeString.Length = (USHORT)AuthInfo[i].AuthInfoLength;

                    NlPrint((NL_CHALLENGE_RES,"NlGetIncomingPassword: New Clear Password = " ));
                    NlpDumpBuffer(NL_CHALLENGE_RES, TempUnicodeString.Buffer, TempUnicodeString.Length );

                    NlpDumpTime( NL_CHALLENGE_RES, "NlGetIncomingPassword: New Password Changed: ", AuthInfo[i].LastUpdateTime );

                    Status = RtlCalculateNtOwfPassword(&TempUnicodeString,
                                                       OwfPassword);

                    if ( !NT_SUCCESS(Status) ) {
                        NlPrintDom((NL_CRITICAL, DomainInfo,
                                "NlGetIncomingPassword: %wZ: cannot RtlCalculateNtOwfPassword 0x%lx\n",
                                &AccountNameString,
                                Status ));
                        goto Cleanup;
                    }

                    PasswordFound = TRUE;

                    //
                    // Use this clear text password
                    //
                    break;
                }

            }
        }

        //
        // Only get the previous password if the caller really wants it.
        //

        if ( OwfPreviousPassword != NULL ) {
            // If OwfPreviousPassword is not NULL, OwfPassword must not be NULL either
            NlAssert( OwfPassword != NULL );
            AuthInfoCount = TrustInfo->TrustedFullInfo.AuthInformation.IncomingAuthInfos;
            AuthInfo = TrustInfo->TrustedFullInfo.AuthInformation.IncomingPreviousAuthenticationInformation;

            if (AuthInfoCount == 0 || AuthInfo == NULL) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NlGetIncomingPassword: %wZ: No previous auth info for this domain.\n",
                        &AccountNameString ));
                Status = STATUS_NO_SUCH_USER;
                goto Cleanup;
            }

            //
            // Loop through the various auth infos looking for the previous cleartext password
            //  or NT OWF password.
            //
            // If there is a clear text password, use it.
            // Otherwise, use the NT OWF password.
            //

            for ( i=0; i<AuthInfoCount; i++ ) {

                //
                // Handle an NT OWF password.
                //

                if ( AuthInfo[i].AuthType == TRUST_AUTH_TYPE_NT4OWF ) {

                    //
                    // Only use the OWF if it is valid
                    //

                    if ( AuthInfo[i].AuthInfoLength != sizeof(*OwfPreviousPassword) ) {
                        NlPrintDom((NL_CRITICAL, DomainInfo,
                                "NlGetIncomingPassword: %wZ: previous OWF password has bad length %ld\n",
                                &AccountNameString,
                                AuthInfo[i].AuthInfoLength ));
                    } else {
                        RtlCopyMemory( OwfPreviousPassword, AuthInfo[i].AuthInfo, sizeof(*OwfPreviousPassword) );
                        PreviousPasswordFound = TRUE;
                    }

                }

                //
                // Handle a cleartext password.
                //

                else if ( AuthInfo[i].AuthType == TRUST_AUTH_TYPE_CLEAR ) {
                    UNICODE_STRING TempUnicodeString;

                    TempUnicodeString.Buffer = (LPWSTR)AuthInfo[i].AuthInfo;
                    TempUnicodeString.MaximumLength =
                        TempUnicodeString.Length = (USHORT)AuthInfo[i].AuthInfoLength;

                    NlPrint((NL_CHALLENGE_RES,"NlGetIncomingPassword: Old Clear Password = " ));
                    NlpDumpBuffer(NL_CHALLENGE_RES, TempUnicodeString.Buffer, TempUnicodeString.Length );

                    NlpDumpTime( NL_CHALLENGE_RES, "NlGetIncomingPassword: Old Password Changed: ", AuthInfo[i].LastUpdateTime );

                    Status = RtlCalculateNtOwfPassword(&TempUnicodeString,
                                                       OwfPreviousPassword);

                    if ( !NT_SUCCESS(Status) ) {
                        NlPrintDom((NL_CRITICAL, DomainInfo,
                                "NlGetIncomingPassword: %wZ: cannot RtlCalculateNtOwfPassword 0x%lx\n",
                                &AccountNameString,
                                Status ));
                        goto Cleanup;
                    }

                    PreviousPasswordFound = TRUE;

                    //
                    // Use this clear text password
                    //
                    break;
                }

            }
        }

        //
        // Only get the account RID if the caller really wants it.
        //

        if ( ARGUMENT_PRESENT( AccountRid) ) {
            PUNICODE_STRING FlatName;
            WCHAR SamAccountName[CNLEN+1+1];

            //
            // The name of the SAM account that corresponds to the inbound
            // trust is FlatName$.
            //

            FlatName = (PUNICODE_STRING) &TrustInfo->TrustedFullInfo.Information.FlatName;
            if ( FlatName->Length < sizeof(WCHAR) ||
                 FlatName->Length > CNLEN * sizeof(WCHAR) ) {

                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NlGetIncomingPassword: %wZ: Flat Name length is bad %ld\n",
                        &AccountNameString,
                        FlatName->Length ));
            } else {

                RtlCopyMemory( SamAccountName,
                               FlatName->Buffer,
                               FlatName->Length );

                SamAccountName[FlatName->Length/sizeof(WCHAR)] =
                                SSI_ACCOUNT_NAME_POSTFIX_CHAR;
                SamAccountName[(FlatName->Length/sizeof(WCHAR))+1] = L'\0';


                //
                // Get the account RID from SAM.
                //
                // ??? This is a gross hack.
                // The LSA should return this RID to me directly.
                //

                Status = NlSamOpenNamedUser( DomainInfo, SamAccountName, NULL, AccountRid, NULL );

                if (!NT_SUCCESS(Status)) {
                    NlPrintDom((NL_CRITICAL, DomainInfo,
                            "NlGetIncomingPassword: Can't NlSamOpenNamedUser for %ws 0x%lx.\n",
                            SamAccountName,
                            Status ));
                    goto Cleanup;
                }
            }
        }



    //
    // Othewise the account is a SAM user account.
    //

    } else {

        //
        // OwfPreviousPassword must be NULL for a SAM account
        //

        NlAssert( OwfPreviousPassword == NULL );

        //
        // Ensure the account name has the correct postfix.
        //

        if ( AllowableAccountControlBits == USER_SERVER_TRUST_ACCOUNT ||
             AllowableAccountControlBits == USER_WORKSTATION_TRUST_ACCOUNT ) {
            if ( Length <= SSI_ACCOUNT_NAME_POSTFIX_LENGTH ) {
                return STATUS_NO_SUCH_USER;
            }

            if ( _wcsicmp(&AccountName[Length - SSI_ACCOUNT_NAME_POSTFIX_LENGTH],
                SSI_ACCOUNT_NAME_POSTFIX) != 0 ) {
                return STATUS_NO_SUCH_USER;
            }
        }

        //
        // Open the user account.
        //

        Status = NlSamOpenNamedUser( DomainInfo, AccountName, &UserHandle, AccountRid, &UserAllInfo );

        if (!NT_SUCCESS(Status)) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlGetIncomingPassword: Can't NlSamOpenNamedUser for %ws 0x%lx.\n",
                    AccountName,
                    Status ));
            goto Cleanup;
        }


        //
        // Ensure the Account type matches the account type on the account.
        //

        if ( (UserAllInfo->All.UserAccountControl &
              USER_ACCOUNT_TYPE_MASK &
              AllowableAccountControlBits ) == 0 ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                            "NlGetIncomingPassword: Invalid account type (%x) instead of %x for %ws\n",
                            UserAllInfo->All.UserAccountControl & USER_ACCOUNT_TYPE_MASK,
                            AllowableAccountControlBits,
                            AccountName ));
              Status = STATUS_NO_SUCH_USER;
              goto Cleanup;
        }

        //
        // Check if the account is disabled.
        //
        if ( CheckAccountDisabled ) {
            if ( UserAllInfo->All.UserAccountControl & USER_ACCOUNT_DISABLED ) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NlGetIncomingPassword: %ws account is disabled\n",
                        AccountName ));
                Status = STATUS_NO_SUCH_USER;
                goto Cleanup;
            }
        }



        //
        // Return the password if the caller wants it.
        //

        if ( OwfPassword != NULL ) {

            //
            // Use the NT OWF Password,
            //

            if ( UserAllInfo->All.NtPasswordPresent &&
                 UserAllInfo->All.NtOwfPassword.Length == sizeof(*OwfPassword) ) {

                RtlCopyMemory( OwfPassword,
                               UserAllInfo->All.NtOwfPassword.Buffer,
                               sizeof(*OwfPassword) );
                PasswordFound = TRUE;

            // Allow for the case that the account has no password at all.
            } else if ( UserAllInfo->All.LmPasswordPresent ) {

                NlPrint((NL_CRITICAL,
                        "NlGetIncomingPassword: No NT Password for %ws\n",
                        AccountName ));

                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }


            //
            // Update the last time this account was used.
            //

            {
                SAMPR_USER_INFO_BUFFER UserInfo;
                NTSTATUS LogonStatus;

                UserInfo.Internal2.StatisticsToApply = USER_LOGON_NET_SUCCESS_LOGON;

                LogonStatus = SamrSetInformationUser(
                                UserHandle,
                                UserInternal2Information,
                                &UserInfo );

                if ( !NT_SUCCESS(LogonStatus)) {
                    NlPrint((NL_CRITICAL,
                            "NlGetIncomingPassword: Cannot set last logon time %ws %lx\n",
                            AccountName,
                            LogonStatus ));
                }
            }
        }
    }




    //
    // If no password exists on the account,
    //  return a blank password.
    //

    if ( !PasswordFound && OwfPassword != NULL ) {
        UNICODE_STRING TempUnicodeString;

        RtlInitUnicodeString(&TempUnicodeString, NULL);
        Status = RtlCalculateNtOwfPassword(&TempUnicodeString,
                                           OwfPassword);
        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlGetIncomingPassword: %ws: cannot RtlCalculateNtOwfPassword (NULL) 0x%lx\n",
                    AccountName,
                    Status ));
            goto Cleanup;
        }
    }

    //
    // If no previous password exists on the account,
    //  return the current password.
    //

    if ( !PreviousPasswordFound && OwfPreviousPassword != NULL ) {

        //
        // If OwfPreviousPassword is not NULL, OwfPassword must not be NULL either.
        //

        NlAssert( OwfPassword != NULL );

        //
        // If previous password is not found, return the current one instead.
        //

        *OwfPreviousPassword = *OwfPassword;
    }

    Status = STATUS_SUCCESS;


    //
    // Free locally used resources.
    //
Cleanup:
    if ( UserAllInfo != NULL ) {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo,
                                         UserAllInformation);
    }

    if ( UserHandle != NULL ) {
        SamrCloseHandle( &UserHandle );
    }

    if ( TrustInfo != NULL ) {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO( TrustedDomainFullInformation,
                                            TrustInfo );
    }

    return Status;
}


NTSTATUS
NlSetIncomingPassword(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PUNICODE_STRING ClearTextPassword OPTIONAL,
    IN DWORD ClearPasswordVersionNumber,
    IN PNT_OWF_PASSWORD OwfPassword OPTIONAL
    )
/*++

Routine Description:

    Set the incoming password for the specified AccountName and SecureChannelType.
    At the same time, update the previous password info.

Arguments:

    DomainInfo - Emulated domain

    AccountName - Name of the account to set the password on

    SecureChannelType - The type of the account being used.

    ClearTextPassword - The Clear text password for the named account.

    ClearPasswordVersionNumber - The version number of the Clear text password.
        Used only for interdomain trust account. Ignored if ClearTextPassword
        is NULL.

    OwfPassword - The NT OWF of the incoming password for the named
        account.  If both the clear text and OWF password are specified,
        the OWF password is ignored.

Return Value:

    Status of operation.


--*/
{
    NTSTATUS Status;

    UNICODE_STRING AccountNameString;
    ULONG Length;

    LSAPR_TRUSTED_DOMAIN_INFO TrustInfo;
    PLSAPR_TRUSTED_DOMAIN_INFO TrustInfoOld = NULL;
    LSAPR_AUTH_INFORMATION CurrentAuthInfo[3], PreviousAuthInfo[3], NoneAuthInfo;
    ULONG iClear, iOWF, iVersion, i;
    DWORD OldVersionNumber = 0;


    //
    // Workstation and BDC secure channels get their outgoing password from
    //  an LSA secret.
    //
    switch ( SecureChannelType ) {
    case ServerSecureChannel:
    case WorkstationSecureChannel:

        NlPrint(( NL_SESSION_SETUP, "Setting Password of '%ws' to: ", AccountName ));
        if ( ClearTextPassword != NULL ) {
            NlpDumpBuffer( NL_SESSION_SETUP, ClearTextPassword->Buffer, ClearTextPassword->Length );
        } else if (OwfPassword != NULL ) {
            NlpDumpBuffer( NL_SESSION_SETUP, OwfPassword, sizeof(*OwfPassword) );
        }

        //
        // Set the encrypted password in SAM.
        //

        Status = NlSamChangePasswordNamedUser( DomainInfo,
                                               AccountName,
                                               ClearTextPassword,
                                               OwfPassword );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlSetIncomingPassword: Cannot change password on local user account %lX\n",
                    Status));
            goto Cleanup;
        }

        break;

    //
    // Trusted domain secure channels get their incoming password from the trusted
    //  domain object.
    //

    case TrustedDomainSecureChannel:
    case TrustedDnsDomainSecureChannel:

        //
        // If this is a DNS trust account,
        //  remove the optional . from the end of the account name.
        //

        RtlInitUnicodeString( &AccountNameString, AccountName );
        Length = AccountNameString.Length / sizeof(WCHAR);
        if ( SecureChannelType == TrustedDnsDomainSecureChannel ) {

            if ( Length != 0 && AccountName[Length-1] == '.' ) {
                AccountNameString.Length -= sizeof(WCHAR);
            }

        //
        // If this is an NT4-style interdomain trust,
        //  remove the $ from the end of the account name.
        //
        } else {

            //
            // Ensure the account name has the correct postfix.
            //

            if ( Length <= SSI_ACCOUNT_NAME_POSTFIX_LENGTH ) {
                Status = STATUS_NO_SUCH_USER;
                goto Cleanup;
            }

            if ( _wcsicmp(&AccountName[Length - SSI_ACCOUNT_NAME_POSTFIX_LENGTH],
                SSI_ACCOUNT_NAME_POSTFIX) != 0 ) {
                Status = STATUS_NO_SUCH_USER;
                goto Cleanup;
            }

            AccountNameString.Length -= SSI_ACCOUNT_NAME_POSTFIX_LENGTH*sizeof(WCHAR);

        }

        //
        // First get the current authentication information (that is old as far as
        // the function is concerned) from the LSA.
        //

        Status = LsarQueryTrustedDomainInfoByName(
                    DomainInfo->DomLsaPolicyHandle,
                    (PLSAPR_UNICODE_STRING) &AccountNameString,
                    TrustedDomainAuthInformation,
                    &TrustInfoOld );

        if (!NT_SUCCESS(Status)) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlSetIncomingPassword: %wZ: cannot LsarQueryTrustedDomainInfoByName 0x%lx\n",
                    &AccountNameString,
                    Status ));
            // if ( !NlpIsNtStatusResourceError( Status )) {
            //      Status = STATUS_NO_SUCH_USER;
            // }
            goto Cleanup;
        }

        //
        // Fill in the trust information.
        //

        RtlZeroMemory( &TrustInfo, sizeof(TrustInfo) );

        TrustInfo.TrustedAuthInfo.IncomingAuthInfos = 0;
        TrustInfo.TrustedAuthInfo.IncomingAuthenticationInformation =
            CurrentAuthInfo;
        TrustInfo.TrustedAuthInfo.IncomingPreviousAuthenticationInformation =
            PreviousAuthInfo;

        //
        // Fill in the current and previous authentication information.
        //

        NlQuerySystemTime( &CurrentAuthInfo[0].LastUpdateTime );
        NlPrint(( NL_SESSION_SETUP, "Setting Password of '%ws' to: ", AccountName ));
        if ( ClearTextPassword != NULL ) {
            CurrentAuthInfo[0].AuthType = TRUST_AUTH_TYPE_CLEAR;
            CurrentAuthInfo[0].AuthInfoLength = ClearTextPassword->Length;
            CurrentAuthInfo[0].AuthInfo = (LPBYTE)ClearTextPassword->Buffer;

            NlpDumpBuffer(NL_SESSION_SETUP, ClearTextPassword->Buffer, ClearTextPassword->Length );

            CurrentAuthInfo[1].LastUpdateTime = CurrentAuthInfo[0].LastUpdateTime;
            CurrentAuthInfo[1].AuthType = TRUST_AUTH_TYPE_VERSION;
            CurrentAuthInfo[1].AuthInfoLength = sizeof(ClearPasswordVersionNumber);
            CurrentAuthInfo[1].AuthInfo = (LPBYTE) &ClearPasswordVersionNumber;

            NlPrint(( NL_SESSION_SETUP, "Password Version number is %lu\n",
                      ClearPasswordVersionNumber ));
        } else {
            CurrentAuthInfo[0].AuthType = TRUST_AUTH_TYPE_NT4OWF;
            CurrentAuthInfo[0].AuthInfoLength = sizeof(*OwfPassword);
            CurrentAuthInfo[0].AuthInfo = (LPBYTE)OwfPassword;

            NlpDumpBuffer(NL_SESSION_SETUP, OwfPassword, sizeof(*OwfPassword) );
        }

        //
        // The AuthType values of corresponding elements of IncomingAuthenticationInformation and
        // IncomingPreviousAuthenticationInformation arrays must be the same for internal reasons.
        // Thus, use NoneAuthInfo element to fill in missing counterparts in these arrays.

        NoneAuthInfo.LastUpdateTime = CurrentAuthInfo[0].LastUpdateTime;
        NoneAuthInfo.AuthType = TRUST_AUTH_TYPE_NONE;
        NoneAuthInfo.AuthInfoLength = 0;
        NoneAuthInfo.AuthInfo = NULL;

        //
        // Find first Clear and OWF passwords (if any) in the old password info.
        //

        for ( iClear = 0; iClear < TrustInfoOld->TrustedAuthInfo.IncomingAuthInfos; iClear++ ) {

            if ( TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iClear].AuthType ==
                 TRUST_AUTH_TYPE_CLEAR ) {
                break;
            }

        }

        for ( iVersion = 0; iVersion < TrustInfoOld->TrustedAuthInfo.IncomingAuthInfos; iVersion++ ) {

            if ( TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iVersion].AuthType ==
                 TRUST_AUTH_TYPE_VERSION &&
                 TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iVersion].AuthInfoLength ==
                 sizeof(OldVersionNumber) ) {

                RtlCopyMemory( &OldVersionNumber,
                               TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iVersion].AuthInfo,
                               sizeof(OldVersionNumber) );
                break;
            }

        }

        for ( iOWF = 0; iOWF < TrustInfoOld->TrustedAuthInfo.IncomingAuthInfos; iOWF++ ) {

            if ( TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iOWF].AuthType ==
                 TRUST_AUTH_TYPE_NT4OWF ) {
                break;
            }

        }

        //
        // Update previous info using only first Clear and OWF passwords in the current info
        // (that is old as far as this function is concerned).  AuthTypes other than Clear,
        // Version, and OWF are going to be lost.
        //

        if (ClearTextPassword != NULL) {

            if (iClear < TrustInfoOld->TrustedAuthInfo.IncomingAuthInfos) {
                PreviousAuthInfo[0] = TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iClear];
            } else {
                PreviousAuthInfo[0] = NoneAuthInfo;
            }

            //
            // Preserve the old version number only if it is in accordance with the passed value
            //

            if ( iVersion < TrustInfoOld->TrustedAuthInfo.IncomingAuthInfos &&
                 ClearPasswordVersionNumber > 0 &&
                 OldVersionNumber == ClearPasswordVersionNumber - 1 ) {
                PreviousAuthInfo[1] = TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iVersion];
            } else {
                PreviousAuthInfo[1] = NoneAuthInfo;
            }

            TrustInfo.TrustedAuthInfo.IncomingAuthInfos = 2;

            //
            // If there is a previous OWF password, preserve it
            //

            if (iOWF < TrustInfoOld->TrustedAuthInfo.IncomingAuthInfos) {
                PreviousAuthInfo[2] = TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iOWF];
                CurrentAuthInfo[2] = NoneAuthInfo;
                TrustInfo.TrustedAuthInfo.IncomingAuthInfos = 3;
            }

        } else {

            if (iOWF < TrustInfoOld->TrustedAuthInfo.IncomingAuthInfos) {
                PreviousAuthInfo[0] = TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iOWF];
            } else {
                PreviousAuthInfo[0] = NoneAuthInfo;
            }
            TrustInfo.TrustedAuthInfo.IncomingAuthInfos = 1;

            //
            // If there is a previous clear text password, preserve it
            //

            if (iClear < TrustInfoOld->TrustedAuthInfo.IncomingAuthInfos) {
                PreviousAuthInfo[1] = TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iClear];
                CurrentAuthInfo[1]  = NoneAuthInfo;
                TrustInfo.TrustedAuthInfo.IncomingAuthInfos = 2;
            }

            //
            // If there is a previous clear text password version number, preserve it
            //

            if (iVersion < TrustInfoOld->TrustedAuthInfo.IncomingAuthInfos) {
                PreviousAuthInfo[2] = TrustInfoOld->TrustedAuthInfo.IncomingAuthenticationInformation[iVersion];
                CurrentAuthInfo[2]  = NoneAuthInfo;
                TrustInfo.TrustedAuthInfo.IncomingAuthInfos = 3;
            }

        }

        for ( i = 0; i < TrustInfo.TrustedAuthInfo.IncomingAuthInfos; i++ ) {
            if ( CurrentAuthInfo[i].AuthType == TRUST_AUTH_TYPE_CLEAR) {
                NlPrint(( NL_SESSION_SETUP, "Current Clear Text Password of '%ws' is: ", AccountName ));
                NlpDumpBuffer(NL_SESSION_SETUP, CurrentAuthInfo[i].AuthInfo, CurrentAuthInfo[i].AuthInfoLength );
            } else if ( CurrentAuthInfo[i].AuthType == TRUST_AUTH_TYPE_VERSION ) {
                NlPrint(( NL_SESSION_SETUP, "Current Clear Password Version Number of '%ws' is: ", AccountName ));
                NlpDumpBuffer(NL_SESSION_SETUP, CurrentAuthInfo[i].AuthInfo, CurrentAuthInfo[i].AuthInfoLength );
            } else if ( CurrentAuthInfo[i].AuthType == TRUST_AUTH_TYPE_NT4OWF) {
                NlPrint(( NL_SESSION_SETUP, "Current OWF Password of '%ws' is: ", AccountName ));
                NlpDumpBuffer(NL_SESSION_SETUP, CurrentAuthInfo[i].AuthInfo, CurrentAuthInfo[i].AuthInfoLength );
            } else if ( CurrentAuthInfo[i].AuthType == TRUST_AUTH_TYPE_NONE) {
                NlPrint(( NL_SESSION_SETUP, "Current Auth Info entry for '%ws' has no type\n", AccountName ));
            }

            if ( PreviousAuthInfo[i].AuthType == TRUST_AUTH_TYPE_CLEAR) {
                NlPrint(( NL_SESSION_SETUP, "Previous Clear Text Password of '%ws' is: ", AccountName ));
                NlpDumpBuffer(NL_SESSION_SETUP, PreviousAuthInfo[i].AuthInfo, PreviousAuthInfo[i].AuthInfoLength );
            } else if ( PreviousAuthInfo[i].AuthType == TRUST_AUTH_TYPE_VERSION ) {
                NlPrint(( NL_SESSION_SETUP, "Previous Clear Password Version Number of '%ws' is: ", AccountName ));
                NlpDumpBuffer(NL_SESSION_SETUP, PreviousAuthInfo[i].AuthInfo, PreviousAuthInfo[i].AuthInfoLength );
            } else if ( PreviousAuthInfo[i].AuthType == TRUST_AUTH_TYPE_NT4OWF) {
                NlPrint(( NL_SESSION_SETUP, "Previous OWF Text Password of '%ws' is: ", AccountName ));
                NlpDumpBuffer(NL_SESSION_SETUP, PreviousAuthInfo[i].AuthInfo, PreviousAuthInfo[i].AuthInfoLength );
            } else if ( PreviousAuthInfo[i].AuthType == TRUST_AUTH_TYPE_NONE) {
                NlPrint(( NL_SESSION_SETUP, "Previous Auth Info entry for '%ws' has no type\n", AccountName ));
            }
        }

        //
        // Set the authentication information in the LSA.
        //
        Status = LsarSetTrustedDomainInfoByName(
                    DomainInfo->DomLsaPolicyHandle,
                    (PLSAPR_UNICODE_STRING) &AccountNameString,
                    TrustedDomainAuthInformation,
                    &TrustInfo );

        if (!NT_SUCCESS(Status)) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                    "NlSetIncomingPassword: %wZ: cannot LsarSetTrustedDomainInfoByName 0x%lx\n",
                    &AccountNameString,
                    Status ));
            goto Cleanup;
        }
        break;

    //
    // We don't support any other secure channel type
    //
    default:
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NlSetIncomingPassword: %ws: invalid secure channel type: %ld\n",
                AccountName,
                SecureChannelType ));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;

    }





    Status = STATUS_SUCCESS;


    //
    // Free locally used resources.
    //
Cleanup:

    if ( TrustInfoOld != NULL ) {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO( TrustedDomainAuthInformation,
                                            TrustInfoOld );
    }

    return Status;
}


BOOLEAN
NlTimeToRediscover(
    IN PCLIENT_SESSION ClientSession,
    BOOLEAN WithAccount
    )
/*++

Routine Description:

    Determine if it is time to rediscover this Client Session.
    If a session setup failure happens to a discovered DC,
    rediscover the DC if the discovery happened a long time ago (more than 5 minutes).

Arguments:

    ClientSession - Structure used to define the session.

    WithAccount - If TRUE, the caller is going to attempt the discovery "with account".

Return Value:

    TRUE -- iff it is time to re-discover

--*/
{
    BOOLEAN ReturnBoolean;

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );

    //
    // If the last discovery was longer than 5 minutes ago,
    //  it's fine to rediscover regardless of the rediscovery
    //  type (with or without account)
    //

    ReturnBoolean = NetpLogonTimeHasElapsed(
                ClientSession->CsLastDiscoveryTime,
                MAX_DC_REAUTHENTICATION_WAIT );

    //
    // If it turns out that the last rediscovery was recent but
    //  the caller is going to attempt the discovery "with account"
    //  perhaps the last rediscovery with account wasn't recent
    //

    if ( !ReturnBoolean && WithAccount ) {
        ReturnBoolean = NetpLogonTimeHasElapsed(
                    ClientSession->CsLastDiscoveryWithAccountTime,
                    MAX_DC_REAUTHENTICATION_WAIT );
    }
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

    return ReturnBoolean;
}

NET_API_STATUS
NlCacheJoinDomainControllerInfo(
    VOID
    )
/*++

Routine Description:

    This function reads from the registry and caches the DC information
    that was previously written by the join process.  This DC is bound
    to have the correct password for this machine.  If no info is
    available in the registry, no action needs to be taken.

    The join DC info is cached in the DsGetDcName cache. Netlogon will
    then discover this DC and will set up a secure channel to it. Caching
    the DC info in the DsGetDcName cache will ensure that not only Netlogon
    but every other process will consistently talk to this DC.

Arguments:

    None.

Return Value:

    NO_ERROR - The DC info (if any) was read and the client session
        strusture was successfully set.

    Otherwise, some error occured during this operation.

--*/
{
    ULONG WinError = ERROR_SUCCESS;      // Registry reading errors
    NET_API_STATUS NetStatus = NO_ERROR; // Netlogon API return codes

    HKEY  hJoinKey = NULL;
    ULONG BytesRead = 0;
    ULONG Type;
    DWORD KerberosIsDone = 0;
    LPWSTR DcName = NULL;
    ULONG DcFlags = 0;

    PDOMAIN_INFO DomainInfo = NULL;
    PCLIENT_SESSION ClientSession = NULL;
    PNL_DC_CACHE_ENTRY DcCacheEntry = NULL;

    //
    // Caching the join DC info is needed only for workstations
    //

    if ( !NlGlobalMemberWorkstation ) {
        return NO_ERROR;
    }

    //
    // Open the registry key
    //

    WinError = RegOpenKey( HKEY_LOCAL_MACHINE,
                           NETSETUPP_NETLOGON_JD_NAME,
                           &hJoinKey );

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    // Read DC name
    //

    WinError = RegQueryValueEx( hJoinKey,
                           NETSETUPP_NETLOGON_JD_DC,
                           0,
                           &Type,
                           NULL,
                           &BytesRead);

    if ( WinError != ERROR_SUCCESS ) {
        goto Cleanup;
    } else if ( Type != REG_SZ ) {
        WinError = ERROR_DATATYPE_MISMATCH;
        goto Cleanup;
    }

    DcName = LocalAlloc( LMEM_ZEROINIT, BytesRead );

    if ( DcName == NULL ) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    WinError = RegQueryValueEx( hJoinKey,
                           NETSETUPP_NETLOGON_JD_DC,
                           0,
                           &Type,
                           (PUCHAR) DcName,
                           &BytesRead);

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    // The name should include at least '\\' and one character
    //

    if ( wcslen(DcName) < 3 ) {
        NlPrint(( NL_CRITICAL,
                  "NlCacheJoinDomainControllerInfo: DcName is too short.\n" ));
        WinError = ERROR_DATATYPE_MISMATCH;
        goto Cleanup;
    }

    //
    // Read Flags
    //

    WinError = RegQueryValueEx( hJoinKey,
                           NETSETUPP_NETLOGON_JD_F,
                           0,
                           &Type,
                           NULL,
                           &BytesRead);

    if ( WinError != ERROR_SUCCESS ) {
        goto Cleanup;
    } else if ( Type != REG_DWORD ) {
        WinError = ERROR_DATATYPE_MISMATCH;
        goto Cleanup;
    }

    WinError = RegQueryValueEx( hJoinKey,
                           NETSETUPP_NETLOGON_JD_F,
                           0,
                           &Type,
                           (PUCHAR)&DcFlags,
                           &BytesRead);

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    // If we've made it up to this point, the registry was successfully read
    //

    WinError = ERROR_SUCCESS;
    NlPrint(( NL_INIT, "Join DC: %ws, Flags: 0x%lx\n", DcName, DcFlags ));

    //
    // If we are started right after a domain join,
    //  the browser has been notified about the
    //  domain rename by a change log worker.
    //  Wait until the change log worker exits.
    //  Otherwise, the browser will reject the
    //  datagram send when we pass the new emulated
    //  domain name. Do this even if we end up avoiding
    //  the ping in this routine (for NT4.0 DC) because
    //  we'll do the ping just a little bit later for
    //  the DC discovery.
    //

    NlWaitForChangeLogBrowserNotify();

    //
    // If this is not NT5 DC, avoid caching it since it's a PDC.
    // We don't want to overload the PDC by having all clients
    // talking to it after they join the domain. We will just
    // delete the reg key here because Kerberos won't use NT4 DC
    // anyway.
    //

    if ( (DcFlags & DS_DS_FLAG) == 0 ) {
        ULONG WinErrorTmp = ERROR_SUCCESS;
        HKEY hJoinKeyTmp = NULL;

        NlPrint(( NL_INIT, "NlCacheJoinDomainControllerInfo: Join DC is not NT5, deleting it\n" ));

        WinErrorTmp = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    NETSETUPP_NETLOGON_JD_PATH,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hJoinKeyTmp );

        if ( WinErrorTmp == ERROR_SUCCESS ) {
            WinErrorTmp = RegDeleteKey( hJoinKeyTmp,
                                        NETSETUPP_NETLOGON_JD );

            if ( WinErrorTmp != ERROR_SUCCESS ) {
                NlPrint(( NL_CRITICAL,
                          "NlCacheJoinDomainControllerInfo: Couldn't deleted JoinDomain 0x%lx\n",
                          WinErrorTmp ));
            }

            RegCloseKey( hJoinKeyTmp );

        } else {
            NlPrint(( NL_CRITICAL,
                      "NlCacheJoinDomainControllerInfo: RegOpenKeyEx failed 0x%lx\n",
                      WinErrorTmp ));
        }

        //
        // Treat this as error
        //
        NetStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }


    //
    // Now get the client session to the primary domain
    //

    DomainInfo = NlFindNetbiosDomain( NULL, TRUE );    // Primary domain

    if ( DomainInfo == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NlCacheJoinDomainControllerInfo: Cannot NlFindNetbiosDomain\n" ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    ClientSession = NlRefDomClientSession( DomainInfo );

    if ( ClientSession == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NlCacheJoinDomainControllerInfo: Cannot NlRefDomClientSession\n" ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Finally ping the DC given this info. Cache the response.
    //

    NetStatus = NlPingDcName( ClientSession,
                              (DcFlags & DS_DNS_CONTROLLER_FLAG) ?
                                DS_PING_DNS_HOST :
                                DS_PING_NETBIOS_HOST,
                              TRUE,           // Cache this DC
                              FALSE,          // Do not require IP
                              TRUE,           // Ensure the DC has our account
                              FALSE,          // Do not refresh the session
                              DcName+2,       // Skip '\\' in the name
                              &DcCacheEntry );

    if ( NetStatus == NO_ERROR ) {
        NlPrint(( NL_INIT, "Join DC cached successfully\n" ));

        //
        // Also set the site name
        //
        if ( DcCacheEntry->UnicodeClientSiteName != NULL ) {
            NlSetDynamicSiteName( DcCacheEntry->UnicodeClientSiteName );
        }

    } else {
        NlPrint(( NL_CRITICAL, "Failed to cache join DC: 0x%lx\n", NetStatus ));
    }

Cleanup:

    //
    // Free up locally used resources
    //

    if ( DcName != NULL ) {
        LocalFree( DcName );
    }

    if ( DcCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( DcCacheEntry );
    }

    if ( hJoinKey != NULL ) {
        RegCloseKey( hJoinKey );
    }

    if ( ClientSession != NULL ) {
        NlUnrefClientSession( ClientSession );
    }

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    //
    // If everything is successful return NO_ERROR.
    //  Otherwise, if Netlogon API failed, return its error code.
    //  Otherwise, return registry reading error.
    //

    if ( WinError == ERROR_SUCCESS && NetStatus == NO_ERROR ) {
        return NO_ERROR;
    } else if ( NetStatus != NO_ERROR ) {
        return NetStatus;
    } else {
        return WinError;
    }
}

NTSTATUS
NlGetPasswordFromPdc(
    IN PDOMAIN_INFO DomainInfo,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )
/*++

Routine Description:

    This function is used to by a BDC to get a machine account password
    from the PDC in the doamin.

Arguments:

    DomainInfo - Identifies the domain the account is in.

    AccountName -- Name of the account to get the password for.

    AccountType -- The type of account being accessed.

    EncryptedNtOwfPassword -- Returns the OWF password of the account.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;
    NETLOGON_AUTHENTICATOR OurAuthenticator;
    NETLOGON_AUTHENTICATOR ReturnAuthenticator;
    PCLIENT_SESSION ClientSession = NULL;
    SESSION_INFO SessionInfo;
    BOOLEAN FirstTry = TRUE;
    BOOLEAN AmWriter = FALSE;
    ENCRYPTED_LM_OWF_PASSWORD SessKeyEncrPassword;

    NlPrintDom((NL_SESSION_SETUP, DomainInfo,
            "NlGetPasswordFromPdc: Getting password for %ws from PDC.\n",
            AccountName ));

    //
    // Reference the client session.
    //

    ClientSession = NlRefDomClientSession( DomainInfo );

    if ( ClientSession == NULL ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NlGetPasswordFromPdc: This BDC has no client session with the PDC.\n"));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    //
    // Become a Writer of the ClientSession.
    //

    if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NlGetPasswordFromPdc: Can't become writer of client session.\n"));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    AmWriter = TRUE;

    //
    // If the session isn't authenticated,
    //  do so now.
    //

FirstTryFailed:

    Status = NlEnsureSessionAuthenticated( ClientSession, 0 );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    SessionInfo.SessionKey = ClientSession->CsSessionKey;
    // SessionInfo.NegotiatedFlags = ClientSession->CsNegotiatedFlags;

    //
    // Build the Authenticator for this request to the PDC.
    //

    NlBuildAuthenticator(
                    &ClientSession->CsAuthenticationSeed,
                    &ClientSession->CsSessionKey,
                    &OurAuthenticator);

    //
    // Get the password from the PDC
    //

    NL_API_START( Status, ClientSession, TRUE ) {

        NlAssert( ClientSession->CsUncServerName != NULL );
        Status = I_NetServerPasswordGet( ClientSession->CsUncServerName,
                                         AccountName,
                                         AccountType,
                                         ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                                         &OurAuthenticator,
                                         &ReturnAuthenticator,
                                         &SessKeyEncrPassword);

        if ( !NT_SUCCESS(Status) ) {
            NlPrintRpcDebug( "I_NetServerPasswordGet", Status );
        }

    // NOTE: This call may drop the secure channel behind our back
    } NL_API_ELSE( Status, ClientSession, TRUE ) {
    } NL_API_END;


    //
    // Now verify primary's authenticator and update our seed
    //

    if ( Status == STATUS_ACCESS_DENIED ||
         !NlUpdateSeed( &ClientSession->CsAuthenticationSeed,
                        &ReturnAuthenticator.Credential,
                        &ClientSession->CsSessionKey) ) {

        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlGetPasswordFromPdc: denying access after status: 0x%lx\n",
                    Status ));

        //
        // Preserve any status indicating a communication error.
        //

        if ( NT_SUCCESS(Status) ) {
            Status = STATUS_ACCESS_DENIED;
        }
        NlSetStatusClientSession( ClientSession, Status );

        //
        // Perhaps the netlogon service on the server has just restarted.
        //  Try just once to set up a session to the server again.
        //
        if ( FirstTry ) {
            FirstTry = FALSE;
            goto FirstTryFailed;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Decrypt the password returned from the PDC.
    //

    Status = RtlDecryptNtOwfPwdWithNtOwfPwd(
                &SessKeyEncrPassword,
                (PNT_OWF_PASSWORD) &SessionInfo.SessionKey,
                NtOwfPassword );
    NlAssert( NT_SUCCESS(Status) );

    //
    // Common exit
    //

Cleanup:
    if ( ClientSession != NULL ) {
        if ( AmWriter ) {
            NlResetWriterClientSession( ClientSession );
        }
        NlUnrefClientSession( ClientSession );
    }

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "NlGetPasswordFromPdc: %ws: failed %lX\n",
                AccountName,
                Status));
    }

    return Status;
}


NTSTATUS
NlSessionSetup(
    IN OUT PCLIENT_SESSION ClientSession
    )
/*++

Routine Description:

    Verify that the requestor (this machine) has a valid account at
    Primary Domain Controller (primary). The authentication
    is done via an elaborate protocol. This routine will be
    used only when NETLOGON service starts with role != primary.

    The requestor (i.e. this machine) will generate a challenge
    and send it to the Primary Domain Controller and will receive
    a challenge from the primary in response. Now we will compute
    credentials using primary's challenge and send it across and
    wait for credentials, computed at primary using our initial
    challenge, to be returned by PDC. Before computing credentials
    a sessionkey will be built which uniquely identifies this
    session and it will be returned to caller for future use.

    If both machines authenticate then they keep the
    ClientCredential and the session key for future use.

    ?? If multiple domains are supported on a single DC, what mechanism
    do I use to short circuit discovery?  What mechanism do I use to short
    circuit API calls (e.g., pass through authentication) to a DC in that
    domain? Do Ihave to worry about lock contention across such API calls?
    Can I avoid authentication/encryption acress such a secure channel?

Arguments:

    ClientSession - Structure used to define the session.
        On Input the following fields must be set:
            CsState
            CsNetbiosDomainName
            CsUncServerName (May be NULL string depending on SecureChannelType)
            CsAccountName
            CsSecureChannelType
        The caller must be a writer of the ClientSession.

        On Output, the following fields will be set
            CsConnectionStatus
            CsState
            CsSessionKey
            CsAuthenticationSeed

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status;

    NETLOGON_CREDENTIAL ServerChallenge;
    NETLOGON_CREDENTIAL ClientChallenge;
    NETLOGON_CREDENTIAL ComputedServerCredential;
    NETLOGON_CREDENTIAL ReturnedServerCredential;

    BOOLEAN WeDidDiscovery = FALSE;
    BOOLEAN WeDidDiscoveryWithAccount = FALSE;
    BOOLEAN ErrorFromDiscoveredServer = FALSE;
    BOOLEAN SignOrSealError = FALSE;
    BOOLEAN GotNonDsDc = FALSE;
    BOOLEAN DomainDowngraded = FALSE;

    NT_OWF_PASSWORD NtOwfPassword;
    DWORD NegotiatedFlags;
    PUNICODE_STRING NewPassword = NULL;
    PUNICODE_STRING OldPassword = NULL;
    LARGE_INTEGER PasswordChangeTime;
    NT_OWF_PASSWORD NewOwfPassword;
    PNT_OWF_PASSWORD PNewOwfPassword = NULL;
    NT_OWF_PASSWORD OldOwfPassword;
    PNT_OWF_PASSWORD POldOwfPassword = NULL;
    NT_OWF_PASSWORD PdcOwfPassword;
    ULONG i;
    ULONG KeyStrength;
    DWORD DummyPasswordVersionNumber;



    //
    // Used to indicate whether the current or the old password is being
    //  tried to access the DC.
    //  0: implies the current password
    //  1: implies the old password
    //  2: implies both failed
    //

    DWORD State;

    //
    // Ensure we're a writer.
    //

    NlAssert( ClientSession->CsReferenceCount > 0 );
    NlAssert( ClientSession->CsFlags & CS_WRITER );

    NlPrintCs((NL_SESSION_SETUP, ClientSession,
            "NlSessionSetup: Try Session setup\n" ));

    //
    // Start the WMI trace of secure channel setup
    //

    NlpTraceEvent( EVENT_TRACE_TYPE_START, NlpGuidSecureChannelSetup );

    //
    // If we're free to pick the DC which services our request,
    //  do so.
    //
    // Apparently there was a problem with the previously chosen DC
    // so we pick again here. (There is a chance we'll pick the same server.)
    //

    NlPrint(( NL_SESSION_MORE, "NlSessionSetup: ClientSession->CsState = 0x%lx\n",
              ClientSession->CsState));

    if ( ClientSession->CsState == CS_IDLE ) {
        NlAssert( ClientSession->CsUncServerName == NULL );

        WeDidDiscovery = TRUE;

        //
        // Pick the name of a DC in the domain.
        //
        // On the first try do not specify the account in
        //  the discovery attempt as discoveries with account
        //  are much more costly than plain discoveries on the
        //  server side. If we fail session setup because the
        //  discovered server doesn't have our account, we will
        //  retry the discovery with account below.
        //

        Status = NlDiscoverDc( ClientSession,
                               DT_Synchronous,
                               FALSE,
                               FALSE ) ;  // without account

        if ( !NT_SUCCESS(Status) ) {

            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: Session setup: cannot pick trusted DC\n" ));

            goto Cleanup;

        }
    }
    NlAssert( ClientSession->CsState != CS_IDLE );

FirstTryFailed:

    //
    // If this is a workstation in an NT5 domain, we should not use NT4 DC.
    // Indeed, Negotiate will not use an NT4 DC in a mixed mode domain to
    // prevent a downgrade attack.
    //
    if ( NlGlobalMemberWorkstation &&
         (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_HAS_DS) == 0 &&
         (ClientSession->CsFlags & CS_NT5_DOMAIN_TRUST) != 0 ) {

        NET_API_STATUS NetStatus;
        PDOMAIN_CONTROLLER_INFOW DomainControllerInfo = NULL;

        GotNonDsDc = TRUE;
        NlPrintCs(( NL_CRITICAL, ClientSession, "NlSessionSetup: Only downlevel DC available\n" ));

        //
        // Determine whether the domain has been downgraded (just to warn
        // the user). To determine this, try to discover a PDC and if the
        // PDC is available and it is NT4, the domain has been indeed
        // downgraded. In such case, this workstation should rejoin the
        // domain.
        //
        NetStatus = DsrGetDcNameEx2( NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     NULL,
                                     DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY,
                                     &DomainControllerInfo );

        if ( NetStatus == NO_ERROR &&
             (DomainControllerInfo->Flags & DS_DS_FLAG) == 0 ) {
            DomainDowngraded = TRUE;  // Domain has been downgraded (rejoin needed)
            NlPrintCs(( NL_CRITICAL, ClientSession,
                        "NlSessionSetup: NT5 domain has been downgraded.\n" ));
        }

        if ( DomainControllerInfo != NULL ) {
            NetApiBufferFree( DomainControllerInfo );
        }

        Status = STATUS_NO_LOGON_SERVERS;
        ErrorFromDiscoveredServer = TRUE;
        goto Cleanup;
    }

    //
    // Prepare our challenge
    //

    NlComputeChallenge( &ClientChallenge );



    NlPrint((NL_CHALLENGE_RES,"NlSessionSetup: ClientChallenge = " ));
    NlpDumpBuffer(NL_CHALLENGE_RES, &ClientChallenge, sizeof(ClientChallenge) );


    //
    // Get the Password of the account from LSA secret storage
    //

    Status = NlGetOutgoingPassword( ClientSession,
                                    &NewPassword,
                                    &OldPassword,
                                    &DummyPasswordVersionNumber,
                                    &PasswordChangeTime );

    if ( !NT_SUCCESS( Status ) ) {

        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlSessionSetup: cannot NlGetOutgoingPassword 0x%lx\n",
                Status ));

        //
        // return more appropriate error.
        //

        if ( !NlpIsNtStatusResourceError( Status )) {
            Status = STATUS_NO_TRUST_LSA_SECRET;
        }
        goto Cleanup;
    }


    //
    // Try setting up a secure channel first using the CurrentPassword.
    //  If that fails, try using the OldPassword
    //  If that fails, for interdomain trusts, try the password from our PDC
    //


    for ( State = 0; ; State++ ) {

        //
        // Use the right password for this iteration
        //

        if ( State == 0 ) {

            //
            // If the new password isn't present in the LSA,
            //  just ignore it.
            //

            if ( NewPassword == NULL ) {
                continue;
            }

            //
            // Compute the NT OWF password
            //

            Status = RtlCalculateNtOwfPassword( NewPassword,
                                                &NewOwfPassword );

            if ( !NT_SUCCESS( Status ) ) {

                //
                // return more appropriate error.
                //
                if ( !NlpIsNtStatusResourceError( Status )) {
                    Status = STATUS_NO_TRUST_LSA_SECRET;
                }
                goto Cleanup;
            }

            //
            // Try this password
            //

            PNewOwfPassword = &NewOwfPassword;
            NtOwfPassword = NewOwfPassword;

            NlPrint((NL_CHALLENGE_RES,"NlSessionSetup: Clear New Password = " ));
            NlpDumpBuffer(NL_CHALLENGE_RES, NewPassword->Buffer, NewPassword->Length );
            NlpDumpTime( NL_CHALLENGE_RES, "NlSessionSetup: Password Changed: ", PasswordChangeTime );

        //
        // On the second iteration, use the old password
        //

        } else if ( State == 1 ) {

            //
            // If the old password isn't present in the LSA,
            //  just ignore it.
            //

            if ( OldPassword == NULL ) {
                continue;
            }

            //
            // Check if the old password is the same as the new one
            //

            if ( NewPassword != NULL && OldPassword != NULL &&
                 NewPassword->Length == OldPassword->Length &&
                 RtlEqualMemory( NewPassword->Buffer,
                                 OldPassword->Buffer,
                                 OldPassword->Length ) ) {

                NlPrintCs((NL_CRITICAL, ClientSession,
                         "NlSessionSetup: new password is bad. Old password is same as new password.\n" ));
                continue; // Try the password from our PDC
            }

            //
            // Compute the NT OWF password
            //

            Status = RtlCalculateNtOwfPassword( OldPassword,
                                                &OldOwfPassword );

            if ( !NT_SUCCESS( Status ) ) {

                //
                // return more appropriate error.
                //
                if ( !NlpIsNtStatusResourceError( Status )) {
                    Status = STATUS_NO_TRUST_LSA_SECRET;
                }
                goto Cleanup;
            }

            //
            // Try this password
            //

            POldOwfPassword = &OldOwfPassword;
            NtOwfPassword = OldOwfPassword;
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: new password is bad, try old one\n" ));

            NlPrint((NL_CHALLENGE_RES,"NlSessionSetup: Clear Old Password = " ));
            NlpDumpBuffer(NL_CHALLENGE_RES, OldPassword->Buffer, OldPassword->Length );
            NlpDumpTime( NL_CHALLENGE_RES, "NlSessionSetup: Password Changed: ", PasswordChangeTime );

        //
        // On the third iteration, for an interdomain trust account,
        // use the password from the PDC. We actually think this is
        // useful only for NT4 trusted side that keeps only one
        // password. For NT5 or later, one of the passwords above
        // should work, but ...
        //

        } else if ( State == 2 &&
                    ClientSession->CsDomainInfo->DomRole == RoleBackup &&
                    IsDomainSecureChannelType(ClientSession->CsSecureChannelType) ) {

            Status = NlGetPasswordFromPdc(
                            ClientSession->CsDomainInfo,
                            ClientSession->CsAccountName,
                            ClientSession->CsSecureChannelType,
                            &PdcOwfPassword );

            if ( !NT_SUCCESS(Status) ) {
                NlPrintDom(( NL_CRITICAL, ClientSession->CsDomainInfo,
                             "NlSessionSetup: Can't NlGetPasswordFromPdc %ws 0x%lx.\n",
                             ClientSession->CsAccountName,
                             Status ));
                // Ignore the particular status from the PDC
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }

            //
            // Check if this password is the same as the new one we have
            //

            if ( PNewOwfPassword != NULL &&
                 RtlEqualNtOwfPassword(&PdcOwfPassword, PNewOwfPassword) ) {
                NlPrintCs(( NL_CRITICAL, ClientSession,
                            "NlSessionSetup: PDC password is same as new password.\n" ));
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }

            //
            // Check if this password is the same as the old one we have
            //

            if ( POldOwfPassword != NULL &&
                 RtlEqualNtOwfPassword(&PdcOwfPassword, POldOwfPassword) ) {
                NlPrintCs(( NL_CRITICAL, ClientSession,
                            "NlSessionSetup: PDC password is same as old password.\n" ));
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }

            //
            // Try this password
            //

            NtOwfPassword = PdcOwfPassword;
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: try password from the PDC\n" ));

        //
        // We tried our best but nothing worked
        //

        } else {
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        NlPrint((NL_CHALLENGE_RES,"NlSessionSetup: Password = " ));
        NlpDumpBuffer(NL_CHALLENGE_RES, &NtOwfPassword, sizeof(NtOwfPassword) );


        //
        // Get the primary's challenge
        //

        NlAssert( ClientSession->CsState != CS_IDLE );
        NL_API_START( Status, ClientSession, TRUE ) {

            NlAssert( ClientSession->CsUncServerName != NULL );
            Status = I_NetServerReqChallenge(ClientSession->CsUncServerName,
                                             ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                                             &ClientChallenge,
                                             &ServerChallenge );

            if ( !NT_SUCCESS(Status) ) {
                NlPrintRpcDebug( "I_NetServerReqChallenge", Status );
            }

        } NL_API_ELSE ( Status, ClientSession, FALSE ) {

            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: Session setup: "
                    "cannot FinishApiClientSession for I_NetServerReqChallenge 0x%lx\n",
                    Status ));
            // Failure here indicates that the discovered server is really slow.
            // Let the "ErrorFromDiscoveredServer" logic do the rediscovery.
            if ( NT_SUCCESS(Status) ) {
                // We're dropping the secure channel so
                // ensure we don't use any successful status from the DC
                Status = STATUS_NO_LOGON_SERVERS;
            }
            ErrorFromDiscoveredServer = TRUE;
            goto Cleanup;

        } NL_API_END;

        if ( !NT_SUCCESS( Status ) ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: Session setup: "
                    "cannot I_NetServerReqChallenge 0x%lx\n",
                    Status ));

            //
            // If access is denied, it might be because we weren't able to
            //  authenticate with the new password, try the old password.
            //
            // Between NT 5 machines, we use Kerberos (and the machine account) to
            //  authenticate this machine.

            if ( Status == STATUS_ACCESS_DENIED && State == 0 ) {
                continue;
            }

            ErrorFromDiscoveredServer = TRUE;
            goto Cleanup;
        }

        NlPrint((NL_CHALLENGE_RES,"NlSessionSetup: ServerChallenge = " ));
        NlpDumpBuffer(NL_CHALLENGE_RES, &ServerChallenge, sizeof(ServerChallenge) );

        //
        // For NT 5 to NT 5,
        //  use a stronger session key.
        //

        if ( (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_HAS_DS) != 0 ||
             NlGlobalParameters.RequireStrongKey ) {
            KeyStrength = NETLOGON_SUPPORTS_STRONG_KEY;
        } else {
            KeyStrength = 0;
        }
        //
        // Actually compute the session key given the two challenges and the
        //  password.
        //

        Status = NlMakeSessionKey(
                        KeyStrength,
                        &NtOwfPassword,
                        &ClientChallenge,
                        &ServerChallenge,
                        &ClientSession->CsSessionKey );

        if ( !NT_SUCCESS( Status ) ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: Session setup: cannot NlMakeSessionKey 0x%lx\n",
                    Status ));
            goto Cleanup;
        }


        NlPrint((NL_CHALLENGE_RES,"NlSessionSetup: SessionKey = " ));
        NlpDumpBuffer(NL_CHALLENGE_RES, &ClientSession->CsSessionKey, sizeof(ClientSession->CsSessionKey) );


        //
        // Prepare credentials using our challenge.
        //

        NlComputeCredentials( &ClientChallenge,
                              &ClientSession->CsAuthenticationSeed,
                              &ClientSession->CsSessionKey );

        NlPrint((NL_CHALLENGE_RES,"NlSessionSetup: Authentication Seed = " ));
        NlpDumpBuffer(NL_CHALLENGE_RES, &ClientSession->CsAuthenticationSeed, sizeof(ClientSession->CsAuthenticationSeed) );

        //
        // Send these credentials to primary. The primary will compute
        // credentials using the challenge supplied by us and compare
        // with these. If both match then it will compute credentials
        // using its challenge and return it to us for verification
        //

        NL_API_START( Status, ClientSession, TRUE ) {

            NegotiatedFlags = NETLOGON_SUPPORTS_MASK |
                KeyStrength |
                (NlGlobalParameters.AvoidSamRepl ? NETLOGON_SUPPORTS_AVOID_SAM_REPL : 0) |
#ifdef ENABLE_AUTH_RPC
                ((NlGlobalParameters.SignSecureChannel||NlGlobalParameters.SealSecureChannel) ? (NETLOGON_SUPPORTS_AUTH_RPC|NETLOGON_SUPPORTS_LSA_AUTH_RPC) : 0)  |
#endif // ENABLE_AUTH_RPC
                (NlGlobalParameters.AvoidLsaRepl ? NETLOGON_SUPPORTS_AVOID_LSA_REPL : 0) |
                (NlGlobalParameters.NeutralizeNt4Emulator ? NETLOGON_SUPPORTS_NT4EMULATOR_NEUTRALIZER : 0);

            NlAssert( ClientSession->CsUncServerName != NULL );
            ClientSession->CsNegotiatedFlags = NegotiatedFlags;

            Status = I_NetServerAuthenticate3( ClientSession->CsUncServerName,
                                               ClientSession->CsAccountName,
                                               ClientSession->CsSecureChannelType,
                                               ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                                               &ClientSession->CsAuthenticationSeed,
                                               &ReturnedServerCredential,
                                               &ClientSession->CsNegotiatedFlags,
                                               &ClientSession->CsAccountRid );

            //
            // Releases older then NT 5.0 used older authentication API.
            //

            if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
                NlPrint((NL_CRITICAL,"NlSessionSetup: Fall back to Authenticate2\n" ));
                ClientSession->CsNegotiatedFlags = NegotiatedFlags;
                ClientSession->CsAccountRid = 0;
                Status = I_NetServerAuthenticate2( ClientSession->CsUncServerName,
                                                   ClientSession->CsAccountName,
                                                   ClientSession->CsSecureChannelType,
                                                   ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                                                   &ClientSession->CsAuthenticationSeed,
                                                   &ReturnedServerCredential,
                                                   &ClientSession->CsNegotiatedFlags );

                if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE ) {
                    ClientSession->CsNegotiatedFlags = 0;
                    Status = I_NetServerAuthenticate( ClientSession->CsUncServerName,
                                                      ClientSession->CsAccountName,
                                                      ClientSession->CsSecureChannelType,
                                                      ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                                                      &ClientSession->CsAuthenticationSeed,
                                                      &ReturnedServerCredential );

                    if ( !NT_SUCCESS(Status) ) {
                        NlPrintRpcDebug( "I_NetServerAuthenticate", Status );
                    }
                } else if ( !NT_SUCCESS(Status) ) {
                    NlPrintRpcDebug( "I_NetServerAuthenticate2", Status );
                }

            } else if ( !NT_SUCCESS(Status) ) {
                NlPrintRpcDebug( "I_NetServerAuthenticate3", Status );
            }


        } NL_API_ELSE( Status, ClientSession, FALSE ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: Session setup: "
                    "cannot FinishApiClientSession for I_NetServerAuthenticate 0x%lx\n",
                    Status ));
            // Failure here indicates that the discovered server is really slow.
            // Let the "ErrorFromDiscoveredServer" logic do the rediscovery.
            if ( NT_SUCCESS(Status) ) {
                // We're dropping the secure channel so
                // ensure we don't use any successful status from the DC
                Status = STATUS_NO_LOGON_SERVERS;
            }
            ErrorFromDiscoveredServer = TRUE;
            goto Cleanup;
        } NL_API_END;

        if ( !NT_SUCCESS( Status ) ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: Session setup: "
                    "cannot I_NetServerAuthenticate 0x%lx\n",
                    Status ));

            //
            // If access is denied, it might be because we weren't able to
            //  authenticate with the new password, try the old password
            //  or password from the PDC.
            //

            if ( Status == STATUS_ACCESS_DENIED && State < 2 ) {
                continue;
            }
            ErrorFromDiscoveredServer = TRUE;
            goto Cleanup;
        }


        NlPrint((NL_CHALLENGE_RES,"NlSessionSetup: ServerCredential GOT = " ));
        NlpDumpBuffer(NL_CHALLENGE_RES, &ReturnedServerCredential, sizeof(ReturnedServerCredential) );


        //
        // The DC returned a server credential to us,
        //  ensure the server credential matches the one we would compute.
        //

        NlComputeCredentials( &ServerChallenge,
                              &ComputedServerCredential,
                              &ClientSession->CsSessionKey);


        NlPrint((NL_CHALLENGE_RES,"NlSessionSetup: ServerCredential MADE = " ));
        NlpDumpBuffer(NL_CHALLENGE_RES, &ComputedServerCredential, sizeof(ComputedServerCredential) );


        if ( !RtlEqualMemory( &ReturnedServerCredential,
                              &ComputedServerCredential,
                              sizeof(ReturnedServerCredential)) ) {

            Status = STATUS_ACCESS_DENIED;
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: Session setup: "
                    "Servercredential don't match ours 0x%lx\n",
                    Status));
            goto Cleanup;
        }

        //
        // If we require signing or sealing and didn't negotiate it,
        //  fail now.
        //

        if ( NlGlobalParameters.RequireSignOrSeal &&
             (ClientSession->CsNegotiatedFlags & NETLOGON_SUPPORTS_AUTH_RPC) == 0 ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: SignOrSeal required and DC doesn't support it\n" ));

            SignOrSealError = TRUE;
            Status = STATUS_ACCESS_DENIED;
            ErrorFromDiscoveredServer = TRUE; // Highly unlikely that retrying will work, but ...
            goto Cleanup;
        }

        //
        // If we require signing or sealing and didn't negotiate it,
        //  fail now.
        //
        // We'll never really get this far.  Since we used a strong key,
        //  we'll get ACCESS_DENIED above.
        //

        if ( NlGlobalParameters.RequireStrongKey &&
             (ClientSession->CsNegotiatedFlags & NETLOGON_SUPPORTS_STRONG_KEY) == 0 ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: StrongKey required and DC doesn't support it\n" ));

            SignOrSealError = TRUE;
            Status = STATUS_ACCESS_DENIED;
            ErrorFromDiscoveredServer = TRUE; // Highly unlikely that retrying will work, but ...
            goto Cleanup;
        }

        //
        // If we've made it this far, we've successfully authenticated
        //  with the DC, drop out of the loop.
        //

        break;
    }

    //
    // If the new DC is an NT 5 DC,
    //  mark it so.
    //

    if ((ClientSession->CsNegotiatedFlags & NETLOGON_SUPPORTS_GENERIC_PASSTHRU) != 0 ) {
        NlPrintCs(( NL_SESSION_MORE, ClientSession,
                "NlSessionSetup: DC is an NT 5 DC: %ws\n",
                ClientSession->CsUncServerName ));

        //
        // This flag would have been set during discovery if real discovery was
        //  done.  However, if NlSetServerClientSession was called from anywhere
        //  else other than discovery, the flag may not yet be set.
        //
        EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
        ClientSession->CsDiscoveryFlags |= CS_DISCOVERY_HAS_DS;
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );


        //
        // This flag would be set during client session creation if the domain
        // was an NT 5 domain at that time.  If we happened to stumble on an
        // NT 5 DC after the fact, mark it now.
        //
        if ( ClientSession->CsSecureChannelType == WorkstationSecureChannel ) {
            LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
            ClientSession->CsFlags |= CS_NT5_DOMAIN_TRUST;
            UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
        }

    }


    //
    // If we used the old password to authenticate,
    //  update the DC to the current password ASAP.
    //
    // Note that we don't need to reset the scavenge event here to start
    //  the scavenging imeediately to change the password. On DCs, the
    //  scavenging will always happen within the scavenging interval.
    //  On workstations, one might worry that the scavenging may happen
    //  in the distant future at next password reset interval (which is
    //  long, 30 days by default). However, if this is the first session
    //  setup on service start, the scavenging will start immediately and
    //  it will be scheduled every scavenging interval until the password
    //  is set on the DC. Otherwise, if this is not the first session setup
    //  and password got into mismatch due a failed password change on the
    //  DC, the password change routine will schedule the scavenging to run
    //  within the scavenge period until the password is set, so we don't
    //  need to reset the timer here since it's alrteady scheduled properly.
    //

    if ( State == 1 ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlSessionSetup: old password succeeded\n" ));
        LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
        ClientSession->CsFlags |= CS_UPDATE_PASSWORD;
        UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    }

    //
    // Save the password for our own future reference.
    //

    RtlCopyMemory( &ClientSession->CsNtOwfPassword, &NtOwfPassword, sizeof( NtOwfPassword ));

    //
    // If this is a workstation,
    //  grab useful information about the domain.
    //

    NlSetStatusClientSession( ClientSession, STATUS_SUCCESS );  // Mark session as authenticated
    if ( NlGlobalMemberWorkstation ) {

        Status = NlUpdateDomainInfo( ClientSession );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlSessionSetup: NlUpdateDomainInfo failed 0x%lX\n",
                    Status ));
            ErrorFromDiscoveredServer = TRUE;
            goto Cleanup;
        }

    //
    // If this is a DC,
    //  determine if we should get the FTinfo from the trusted domain.
    //
    } else {
        PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo;

        //
        // If this is the PDC,
        //  and the trusted domain is a cross forest trust,
        //  get the FTinfo from the trusted domain and write it to our TDO.
        //
        // Ignore failures.
        //

        if ( ClientSession->CsDomainInfo->DomRole == RolePrimary &&
             (ClientSession->CsTrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0 ) {

            Status = NlpGetForestTrustInfoHigher(
                                ClientSession,
                                DS_GFTI_UPDATE_TDO,
                                FALSE,  // Don't impersonate caller
                                TRUE,   // We set up the session
                                &ForestTrustInfo );

            if ( !NT_SUCCESS(Status) ) {
                NlPrintCs((NL_CRITICAL, ClientSession,
                        "NlSessionSetup: NlpGetForestTrustInfoHigher failed 0x%lX\n",
                        Status ));
                ErrorFromDiscoveredServer = TRUE;
                goto Cleanup;
            } else {
                NetApiBufferFree( ForestTrustInfo );
            }
        }
    }


    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //

Cleanup:

    //
    // Free locally used resources
    //

    if ( NewPassword != NULL ) {
        LocalFree( NewPassword );
    }

    if ( OldPassword != NULL ) {
        LocalFree( OldPassword );
    }


    //
    // Upon success, save the status and reset counters.
    //

    if ( NT_SUCCESS(Status) ) {

        NlSetStatusClientSession( ClientSession, Status );
        ClientSession->CsAuthAlertCount = 0;
        ClientSession->CsTimeoutCount = 0;
        ClientSession->CsFastCallCount = 0;
#if NETLOGONDBG
        if ( ClientSession->CsNegotiatedFlags != NegotiatedFlags ) {
            NlPrintCs((NL_SESSION_SETUP, ClientSession,
                    "NlSessionSetup: negotiated %lx flags rather than %lx\n",
                    ClientSession->CsNegotiatedFlags,
                    NegotiatedFlags ));
        }
#endif // NETLOGONDBG



    //
    // write event log and raise alert
    //

    } else {
        BOOLEAN RetryDiscovery = FALSE;
        BOOLEAN RetryDiscoveryWithAccount = FALSE;
        WCHAR PreviouslyDiscoveredServer[NL_MAX_DNS_LENGTH+3];
        LPWSTR MsgStrings[5];

        //
        // Save the name of the discovered server.
        //

        if ( ClientSession->CsUncServerName != NULL ) {
            wcscpy( PreviouslyDiscoveredServer, ClientSession->CsUncServerName );
        } else {
            wcscpy( PreviouslyDiscoveredServer, L"<Unknown>" );
        }

        //
        // If the failure came from the discovered server,
        //  decide whether we should retry the session setup
        //  to a different server
        //
        if ( ErrorFromDiscoveredServer ) {

            //
            // If we didn't do the plain discovery (without account) just now,
            //  try the discovery again and redo the session setup.
            //
            if ( !WeDidDiscovery && NlTimeToRediscover(ClientSession, FALSE) ) {
                RetryDiscovery = TRUE;
            }

            //
            // If we didn't do the discovery with account and
            //  the session setup failed because the server didn't have our account and
            //  we didn't try a discovery with account recently,
            //  try the discovery again (with account) and redo the session setup.
            //
            if ( !WeDidDiscoveryWithAccount &&
                 (Status == STATUS_NO_SUCH_USER || Status == STATUS_NO_TRUST_SAM_ACCOUNT) &&
                 NlTimeToRediscover(ClientSession, TRUE) ) {
                RetryDiscoveryWithAccount = TRUE;
            }
        }


        //
        // If we are to retry the discovery, do so
        //

        if ( RetryDiscovery || RetryDiscoveryWithAccount ) {
            NTSTATUS TempStatus;

            NlPrintCs((NL_SESSION_SETUP, ClientSession,
                "NlSessionSetup: Retry failed session setup (%s account) since discovery wasn't recent.\n",
                (RetryDiscoveryWithAccount ? "with" : "without") ));


            //
            // Pick the name of a new DC in the domain.
            //

            NlSetStatusClientSession( ClientSession, STATUS_NO_LOGON_SERVERS );

            TempStatus = NlDiscoverDc( ClientSession,
                                       DT_Synchronous,
                                       FALSE,
                                       RetryDiscoveryWithAccount );  // retry with account as needed

            if ( NT_SUCCESS(TempStatus) ) {

                //
                // Don't bother redoing the session setup if we picked the same DC.
                //  In particular, if we retried because the previously found DC
                //  didn't have our account, we retried the discovery with account
                //  above but may have got the same DC (shouldn't really happen, but...)
                //
                if ( _wcsicmp( ClientSession->CsUncServerName,
                               PreviouslyDiscoveredServer ) != 0 ) {

                    //
                    // We certainly did a discovery here,
                    //  but it may or may not be with account
                    //
                    WeDidDiscovery = TRUE;
                    WeDidDiscoveryWithAccount = RetryDiscoveryWithAccount;
                    goto FirstTryFailed;
                } else {
                    NlPrintCs((NL_SESSION_SETUP, ClientSession,
                            "NlSessionSetup: Skip retry failed session setup since same DC discovered.\n" ));
                }

            } else {
                NlPrintCs((NL_CRITICAL, ClientSession,
                        "NlSessionSetup: Session setup: cannot re-pick trusted DC\n" ));

            }
        }


        switch(Status) {
        case STATUS_NO_TRUST_LSA_SECRET:

            MsgStrings[0] = PreviouslyDiscoveredServer;
            MsgStrings[1] = ClientSession->CsDebugDomainName;
            MsgStrings[2] = ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
            MsgStrings[3] = NULL; // RaiseNetlogonAlert

            NlpWriteEventlog (NELOG_NetlogonAuthNoTrustLsaSecret,
                              EVENTLOG_ERROR_TYPE,
                              (LPBYTE) &Status,
                              sizeof(Status),
                              MsgStrings,
                              3 );

            RaiseNetlogonAlert( NELOG_NetlogonAuthNoTrustLsaSecret,
                                MsgStrings,
                                &ClientSession->CsAuthAlertCount);
            break;

        case STATUS_NO_TRUST_SAM_ACCOUNT:

            MsgStrings[0] = PreviouslyDiscoveredServer;
            MsgStrings[1] = ClientSession->CsDebugDomainName;
            MsgStrings[2] = ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer;
            MsgStrings[3] = ClientSession->CsAccountName;
            MsgStrings[4] = NULL; // RaiseNetlogonAlert

            NlpWriteEventlog (NELOG_NetlogonAuthNoTrustSamAccount,
                              EVENTLOG_ERROR_TYPE,
                              (LPBYTE) &Status,
                              sizeof(Status),
                              MsgStrings,
                              4 );

            RaiseNetlogonAlert( NELOG_NetlogonAuthNoTrustSamAccount,
                                MsgStrings,
                                &ClientSession->CsAuthAlertCount);
            break;

        case STATUS_ACCESS_DENIED:

            if ( SignOrSealError ) {
                MsgStrings[0] = PreviouslyDiscoveredServer;
                MsgStrings[1] = ClientSession->CsDebugDomainName;
                MsgStrings[2] = NULL; // RaiseNetlogonAlert

                NlpWriteEventlog (NELOG_NetlogonRequireSignOrSealError,
                                  EVENTLOG_ERROR_TYPE,
                                  NULL,
                                  0,
                                  MsgStrings,
                                  2 );

                RaiseNetlogonAlert( NELOG_NetlogonRequireSignOrSealError,
                                    MsgStrings,
                                    &ClientSession->CsAuthAlertCount);
            } else {

                MsgStrings[0] = ClientSession->CsDebugDomainName;
                MsgStrings[1] = PreviouslyDiscoveredServer;
                MsgStrings[2] = NULL; // RaiseNetlogonAlert

                NlpWriteEventlog (NELOG_NetlogonAuthDCFail,
                                  EVENTLOG_ERROR_TYPE,
                                  (LPBYTE) &Status,
                                  sizeof(Status),
                                  MsgStrings,
                                  2 );

                RaiseNetlogonAlert( NELOG_NetlogonAuthDCFail,
                                    MsgStrings,
                                    &ClientSession->CsAuthAlertCount);
            }
            break;

        case STATUS_NO_LOGON_SERVERS:
        default:

            MsgStrings[0] = ClientSession->CsDebugDomainName;
            MsgStrings[1] = (LPWSTR) LongToPtr( Status );

            // The order of checks is important
            if ( DomainDowngraded ) {
                NlpWriteEventlog (NELOG_NetlogonAuthDomainDowngraded,
                                  EVENTLOG_ERROR_TYPE,
                                  (LPBYTE) &Status,
                                  sizeof(Status),
                                  MsgStrings,
                                  2 | NETP_LAST_MESSAGE_IS_NTSTATUS );
            } else if ( GotNonDsDc ) {
                NlpWriteEventlog (NELOG_NetlogonAuthNoUplevelDomainController,
                                  EVENTLOG_ERROR_TYPE,
                                  (LPBYTE) &Status,
                                  sizeof(Status),
                                  MsgStrings,
                                  2 | NETP_LAST_MESSAGE_IS_NTSTATUS );
            } else {
                NlpWriteEventlog (NELOG_NetlogonAuthNoDomainController,
                                  EVENTLOG_ERROR_TYPE,
                                  (LPBYTE) &Status,
                                  sizeof(Status),
                                  MsgStrings,
                                  2 | NETP_LAST_MESSAGE_IS_NTSTATUS );
            }

            MsgStrings[0] = ClientSession->CsDebugDomainName;
            MsgStrings[1] = PreviouslyDiscoveredServer;
            MsgStrings[2] = NULL; // RaiseNetlogonAlert

            RaiseNetlogonAlert( ALERT_NetlogonAuthDCFail,
                                MsgStrings,
                                &ClientSession->CsAuthAlertCount);
            break;
        }



        //
        // ??: Is this how to handle failure for all account types.
        //

        switch(Status) {

        case STATUS_NO_TRUST_LSA_SECRET:
        case STATUS_NO_TRUST_SAM_ACCOUNT:
        case STATUS_ACCESS_DENIED:

            NlSetStatusClientSession( ClientSession, Status );
            break;

        default:

            NlSetStatusClientSession( ClientSession, STATUS_NO_LOGON_SERVERS );
            break;
        }
    }


    //
    // Mark the time we last tried to authenticate.
    //
    // We need to do this after NlSetStatusClientSession which zeros
    // CsLastAuthenticationTry.
    //

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
    NlQuerySystemTime( &ClientSession->CsLastAuthenticationTry );
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );


    NlPrintCs((NL_SESSION_SETUP, ClientSession,
            "NlSessionSetup: Session setup %s\n",
            (NT_SUCCESS(ClientSession->CsConnectionStatus)) ? "Succeeded" : "Failed" ));

    //
    // End the WMI trace of secure channel setup
    //

    NlpTraceEvent( EVENT_TRACE_TYPE_END, NlpGuidSecureChannelSetup );

    return Status;
}


BOOLEAN
NlTimeHasElapsedEx(
    IN PLARGE_INTEGER StartTime,
    IN PLARGE_INTEGER Period,
    OUT PULONG TimeInterval OPTIONAL
    )
/*++

Routine Description:

    Determine if "Timeout" milliseconds has has elapsed since StartTime.

Arguments:

    StartTime - Specifies an absolute time when the event started (100ns units).

    Period - Specifies a relative time in 100ns units.

    TimeInterval - If specified and time has elapsed, returns the amount of time
        (in milliseconds) passed since the timeout.  If specified and time
        has not elapsed, returns the amount of time (in milliseconds) left until
        Period elapses.

Return Value:

    TRUE -- iff Period 100nano-seconds have elapsed since StartTime.

--*/
{
    LARGE_INTEGER TimeNow;
    LARGE_INTEGER ElapsedTime;
    BOOLEAN Result = FALSE;

    //
    //
    // Compute the elapsed time since we last authenticated
    //

    // NlpDumpTime( NL_MISC, "StartTime: ", *StartTime );

     NlQuerySystemTime( &TimeNow );
    // NlpDumpTime( NL_MISC, "TimeNow: ", TimeNow );
    ElapsedTime.QuadPart = TimeNow.QuadPart - StartTime->QuadPart;
    // NlpDumpTime( NL_MISC, "ElapsedTime: ", ElapsedTime );
    // NlpDumpTime( NL_MISC, "Period: ", *Period );


    //
    // If the elapsed time is negative (totally bogus) or greater than the
    //  maximum allowed, indicate that enough time has passed.
    //
    //

    if ( ElapsedTime.QuadPart < 0 ) {
        if ( ARGUMENT_PRESENT( TimeInterval )) {
            *TimeInterval = 0;  // pretend it just elapsed
        }
        return TRUE;
    }

    if ( ElapsedTime.QuadPart > Period->QuadPart ) {
        Result = TRUE;
    } else {
        Result = FALSE;
    }

    //
    // If the caller want to know the amount of time left,
    //  compute it.
    //

    if ( ARGUMENT_PRESENT( TimeInterval )) {

       LARGE_INTEGER TimeRemaining;
       LARGE_INTEGER MillisecondsRemaining;

   /*lint -e569 */  /* don't complain about 32-bit to 31-bit initialize */
       LARGE_INTEGER BaseGetTickMagicDivisor = { 0xe219652c, 0xd1b71758 };
   /*lint +e569 */  /* don't complain about 32-bit to 31-bit initialize */
       CCHAR BaseGetTickMagicShiftCount = 13;


       //
       // Compute the Time remaining/passed on the timer.
       //
       if ( Result == FALSE ) {
           TimeRemaining.QuadPart = Period->QuadPart - ElapsedTime.QuadPart;
       } else {
           TimeRemaining.QuadPart = ElapsedTime.QuadPart - Period->QuadPart;
       }
       // NlpDumpTime( NL_MISC, "TimeRemaining: ", TimeRemaining );

       //
       // Compute the number of milliseconds remaining/passed.
       //

       MillisecondsRemaining = RtlExtendedMagicDivide(
                                   TimeRemaining,
                                   BaseGetTickMagicDivisor,
                                   BaseGetTickMagicShiftCount );

       // NlpDumpTime( NL_MISC, "MillisecondsRemaining: ", MillisecondsRemaining );



       //
       // If the time is in the far distant future/past,
       //   round it down.
       //

       if ( MillisecondsRemaining.HighPart != 0 ||
            MillisecondsRemaining.LowPart > TIMER_MAX_PERIOD ) {

           *TimeInterval = TIMER_MAX_PERIOD;

       } else {

           *TimeInterval = MillisecondsRemaining.LowPart;

       }
    }

    return Result;
}


BOOLEAN
NlTimeToReauthenticate(
    IN PCLIENT_SESSION ClientSession
    )
/*++

Routine Description:

    Determine if it is time to reauthenticate this Client Session.
    To reduce the number of re-authentication attempts, we try
    to re-authenticate only on demand and then only at most every 45
    seconds.

Arguments:

    ClientSession - Structure used to define the session.

Return Value:

    TRUE -- iff it is time to re-authenticate

--*/
{
    BOOLEAN ReturnBoolean;

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
    ReturnBoolean = NetpLogonTimeHasElapsed(
                ClientSession->CsLastAuthenticationTry,
                MAX_DC_AUTHENTICATION_WAIT );
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

    return ReturnBoolean;
}





NET_API_STATUS
NlCreateShare(
    LPWSTR SharePath,
    LPWSTR ShareName,
    BOOLEAN AllowAuthenticatedUsers,
    BOOL UpdateExclusiveShareAccess,
    BOOL AllowExclusiveShareAccess
    )
/*++

Routine Description:

    Share the netlogon scripts directory.

Arguments:

    SharePath - Path that the new share should be point to.

    ShareName - Name of the share.

    AllowAuthenticatedUsers - TRUE if AuthenticatedUsers should have
        Full Control on this share.

    UpdateExclusiveShareAccess - If TRUE, the exclusive share
        access semantics will be updated as specified by
        AllowExclusiveShareAccess.

    AllowExclusiveShareAccess - If TRUE, the exclusive access to the
        specified share will be granted. Otherwise, the exclusive
        access to the specified share will not be granted. This
        parameter is ignored if UpdateExclusiveShareAccess is FALSE.

Return Value:

    TRUE: if successful
    FALSE: if error (NlExit was called)

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    SHARE_INFO_502 ShareInfo502;

    PSHARE_INFO_1005 ShareInfo1005 = NULL;
    DWORD CurrentFlags = 0;

    WORD AnsiSize;
    CHAR AnsiRemark[NNLEN+1];
    TCHAR Remark[NNLEN+1];

    ACE_DATA AceData[] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
            GENERIC_EXECUTE | GENERIC_READ,     &WorldSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
            GENERIC_ALL,                        &AliasAdminsSid},
        // Must be the last ACE
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
            GENERIC_ALL,                        &AuthenticatedUserSid}
    };
    ULONG AceCount = (sizeof(AceData)/sizeof(AceData[0]));

    //
    // If Authenticated Users shouldn't be allowed full control,
    //  remove the authenticated user ACE.
    //

    if ( !AllowAuthenticatedUsers ) {
        AceCount --;
    }


    //
    // Build the structure describing the share.
    //

    ShareInfo502.shi502_path = SharePath;
    ShareInfo502.shi502_security_descriptor = NULL;

    NlPrint((NL_INIT, "'%ws' share is to '%ws'\n",
                      ShareName,
                      SharePath));

    NetStatus = (NET_API_STATUS) DosGetMessage(
                                    NULL,       // No insertion strings
                                    0,          // No insertion strings
                                    AnsiRemark,
                                    sizeof(AnsiRemark),
                                    MTXT_LOGON_SRV_SHARE_REMARK,
                                    MESSAGE_FILENAME,
                                    &AnsiSize );

    if ( NetStatus == NERR_Success ) {
        NetpCopyStrToTStr( Remark, AnsiRemark );
        ShareInfo502.shi502_remark = Remark;
    } else {
        ShareInfo502.shi502_remark = TEXT( "" );
    }

    ShareInfo502.shi502_netname = ShareName;
    ShareInfo502.shi502_type = STYPE_DISKTREE;
    ShareInfo502.shi502_permissions = ACCESS_READ;
    ShareInfo502.shi502_max_uses = 0xffffffff;
    ShareInfo502.shi502_passwd = TEXT("");

    //
    // Set the security descriptor on the share
    //

    //
    // Create a security descriptor containing the DACL.
    //

    Status = NetpCreateSecurityDescriptor(
                AceData,
                AceCount,
                NULL,  // Default the owner Sid
                NULL,  // Default the primary group
                &ShareInfo502.shi502_security_descriptor );

    if ( !NT_SUCCESS( Status ) ) {
        NlPrint((NL_CRITICAL,
                 "'%ws' share: Cannot create security descriptor 0x%lx\n",
                 SharePath, Status ));

        NetStatus = NetpNtStatusToApiStatus( Status );
        return NetStatus;
    }


    //
    // Create the share.
    //

    NetStatus = NetShareAdd(NULL, 502, (LPBYTE) &ShareInfo502, NULL);

    if (NetStatus == NERR_DuplicateShare) {

        PSHARE_INFO_2 ShareInfo2 = NULL;

        NlPrint((NL_INIT, "'%ws' share already exists. \n", ShareName));

        //
        // check to see the shared path is same.
        //

        NetStatus = NetShareGetInfo( NULL,
                                     ShareName,
                                     2,
                                     (LPBYTE *) &ShareInfo2 );

        if ( NetStatus == NERR_Success ) {

            //
            // compare path names.
            //
            // ShareName is path canonicalized already.
            //
            //

            NlPrint((NL_INIT, "'%ws' share current path is %ws\n", ShareName, ShareInfo2->shi2_path));

            if( NetpwPathCompare(
                    SharePath,
                    ShareInfo2->shi2_path, 0, 0 ) != 0 ) {

                //
                // delete share.
                //

                NetStatus = NetShareDel( NULL, ShareName, 0);

                if( NetStatus == NERR_Success ) {

                    //
                    // Recreate share.
                    //

                    NetStatus = NetShareAdd(
                                    NULL,
                                    502,
                                    (LPBYTE) &ShareInfo502,
                                    NULL);

                    if( NetStatus == NERR_Success ) {

                        NlPrint((NL_INIT,
                                 "'%ws' share was recreated with new path %ws\n",
                                ShareName, SharePath ));
                    }

                }
            }
        }

        if( ShareInfo2 != NULL ) {
            NetpMemoryFree( ShareInfo2 );
        }
    }

    //
    // Free the security descriptor
    //

    NetpMemoryFree( ShareInfo502.shi502_security_descriptor );

    if ( NetStatus != NERR_Success ) {

        NlPrint((NL_CRITICAL,
                "'%ws' share: Error attempting to create-share: %ld\n",
                ShareName,
                NetStatus ));
        return NetStatus;

    }

    //
    // If we don't need to update the exclusing share access semantics,
    //  we are done
    //

    if ( !UpdateExclusiveShareAccess ) {
        return NERR_Success;
    }

    //
    // Set the exclusive share access semantics as appropriate
    //

    NetStatus = NetShareGetInfo( NULL, ShareName, 1005, (LPBYTE*)&ShareInfo1005 );

    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "NlCreateShare: NetShareGetInfo (1005) failed for share '%ws': %lu\n",
                  ShareName,
                  NetStatus ));
        return NetStatus;
    }

    //
    // Save the current flags
    //

    CurrentFlags = ShareInfo1005->shi1005_flags;

    //
    // If we allow the exclusive share access...
    //

    if ( AllowExclusiveShareAccess ) {

        //
        // If the current setting doesn't allow the exclusive access,
        //  update it
        //
        if ( ShareInfo1005->shi1005_flags & SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS ) {
            ShareInfo1005->shi1005_flags &= ~SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS;
        }

    //
    // If we disallow the exclusive share access...
    //

    } else {

        //
        // If the current setting allows the exclusive access,
        //  update it
        //
        if ( (ShareInfo1005->shi1005_flags & SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS) == 0 ) {
            ShareInfo1005->shi1005_flags |= SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS;
        }
    }

    //
    // Update the share as needed
    //

    if ( CurrentFlags != ShareInfo1005->shi1005_flags ) {

        NetStatus = NetShareSetInfo( NULL, ShareName, 1005, (LPBYTE)ShareInfo1005, NULL );

        if ( NetStatus == NO_ERROR ) {
            NlPrint(( NL_INIT,
                      "NlCreateShare: Share '%ws' updated successfully flags 0x%lx 0x%lx\n",
                      ShareName,
                      CurrentFlags,
                      ShareInfo1005->shi1005_flags ));
        } else {
            NlPrint(( NL_CRITICAL,
                      "NlCreateShare: Failed to update share '%ws' flags 0x%lx 0x%lx: 0x%lx\n",
                      ShareName,
                      CurrentFlags,
                      ShareInfo1005->shi1005_flags,
                      NetStatus ));
        }
    }

    //
    // Free the share info
    //

    if ( ShareInfo1005 != NULL ) {
        NetApiBufferFree( ShareInfo1005 );
    }

    return NetStatus;
}



NTSTATUS
NlSamOpenNamedUser(
    IN PDOMAIN_INFO DomainInfo,
    IN LPCWSTR UserName,
    OUT SAMPR_HANDLE *UserHandle OPTIONAL,
    OUT PULONG UserId OPTIONAL,
    OUT PSAMPR_USER_INFO_BUFFER *UserAllInfo OPTIONAL
    )
/*++

Routine Description:

    Utility routine to open a Sam user given the username.

Arguments:

    DomainInfo - Domain the user is in.

    UserName - Name of user to open

    UserHandle - Optionally returns a handle to the opened user.

    UserId - Optionally returns the relative ID of the opened user.

    UserAllInfo - Optionally returns ALL of the information about the
        named user.  Free the returned information using
        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );

Return Value:

    STATUS_NO_SUCH_USER: if the account doesn't exist

--*/
{
    NTSTATUS Status;

    UNICODE_STRING UserNameString;
    PSAMPR_USER_INFO_BUFFER LocalUserAllInfo = NULL;
    SID_AND_ATTRIBUTES_LIST ReverseMembership;

    //
    // Initialization.
    //

    if ( ARGUMENT_PRESENT( UserHandle) ) {
        *UserHandle = NULL;
    }
    if ( ARGUMENT_PRESENT( UserAllInfo) ) {
        *UserAllInfo = NULL;
    }

    //
    // Get the info about the user.
    //
    // Use SamIGetUserLogonInformation instead of SamrLookupNamesInDomain and
    //  SamrOpen user.  The former is more efficient (since it only does one
    //  DirSearch and doesn't lock the global SAM lock) and more powerful
    //  (since it returns UserAllInformation).
    //

    RtlInitUnicodeString( &UserNameString, UserName );

    Status = SamIGetUserLogonInformation(
                DomainInfo->DomSamAccountDomainHandle,
                SAM_NO_MEMBERSHIPS, // Don't need group memberships
                &UserNameString,
                &LocalUserAllInfo,
                &ReverseMembership,
                UserHandle );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_NOT_FOUND ) {
            Status = STATUS_NO_SUCH_USER;
        }
        goto Cleanup;
    }

    //
    // Return information to the caller.
    //

    if ( ARGUMENT_PRESENT(UserId) ) {
        *UserId = LocalUserAllInfo->All.UserId;
    }

    if ( ARGUMENT_PRESENT( UserAllInfo) ) {
        *UserAllInfo = LocalUserAllInfo;
        LocalUserAllInfo = NULL;
    }

    //
    // Free locally used resources.
    //
Cleanup:

    if ( LocalUserAllInfo != NULL ) {
        SamIFree_SAMPR_USER_INFO_BUFFER( LocalUserAllInfo, UserAllInformation );
    }

    return Status;

}


NTSTATUS
NlSamChangePasswordNamedUser(
    IN PDOMAIN_INFO DomainInfo,
    IN LPCWSTR UserName,
    IN PUNICODE_STRING ClearTextPassword OPTIONAL,
    IN PNT_OWF_PASSWORD OwfPassword OPTIONAL
    )
/*++

Routine Description:

    Utility routine to set the OWF password on a user given the username.

Arguments:

    DomainInfo - Domain the user is in.

    UserName - Name of user to open

    ClearTextPassword - Clear text password to set on the account

    OwfPassword - OWF password to set on the account

Return Value:

--*/
{
    NTSTATUS Status;
    SAMPR_HANDLE UserHandle = NULL;

    //
    // Open the user that represents this server.
    //

    Status = NlSamOpenNamedUser( DomainInfo, UserName, &UserHandle, NULL, NULL );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // If Clear text password isn't NULL, use it.
    //  Otherwise use OWF password.
    //

    if ( ClearTextPassword != NULL ) {
        UNICODE_STRING UserNameString;
        RtlInitUnicodeString( &UserNameString, UserName );

        Status = SamIChangePasswordForeignUser(
                                  &UserNameString,
                                  ClearTextPassword,
                                  NULL,
                                  0 );

        if ( !NT_SUCCESS(Status) ) {
            NlPrint(( NL_CRITICAL,
                      "NlSamChangePasswordNamedUser: Can't SamIChangePasswordForeignUser %lX\n",
                      Status ));
            goto Cleanup;
        }

    //
    // Use the NT OWF Password,
    //

    } else if ( OwfPassword != NULL ) {
        SAMPR_USER_INFO_BUFFER UserInfo;

        UserInfo.Internal1.PasswordExpired = FALSE;
        UserInfo.Internal1.LmPasswordPresent = FALSE;
        UserInfo.Internal1.NtPasswordPresent = TRUE;
        UserInfo.Internal1.EncryptedNtOwfPassword =
            *((PENCRYPTED_NT_OWF_PASSWORD)(OwfPassword));

        Status = SamrSetInformationUser(
                    UserHandle,
                    UserInternal1Information,
                    &UserInfo );

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,
                      "NlSamChangePasswordNamedUser: Can't SamrSetInformationUser %lX\n",
                      Status ));
            goto Cleanup;
        }
    }

Cleanup:
    if ( UserHandle != NULL ) {
        (VOID) SamrCloseHandle( &UserHandle );
    }
    return Status;
}



NTSTATUS
NlChangePassword(
    IN PCLIENT_SESSION ClientSession,
    IN BOOLEAN ForcePasswordChange,
    OUT PULONG RetCallAgainPeriod OPTIONAL
    )
/*++

Routine Description:

    Change this machine's password at the primary.
    Also update password locally if the call succeeded.

    To determine if the password of "machine account"
    needs to be changed.  If the password is older than
    7 days then it must be changed asap.  We will defer
    changing the password if we know before hand that
    primary dc is down since our call will fail anyway.

Arguments:

    ClientSession - Structure describing the session to change the password
        for.  The specified structure must be referenced.

    ForcePasswordChange - TRUE if the password should be changed even if
        the password hasn't expired yet.

    RetCallAgainPeriod - Returns the amount of time (in milliseconds) that should elapse
        before the caller should call this routine again.
        0: After a period of time determined by the caller.
        MAILSLOT_WAIT_FOREVER: never
        other: After at least this amount of time.

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;
    NETLOGON_AUTHENTICATOR OurAuthenticator;
    NETLOGON_AUTHENTICATOR ReturnAuthenticator;

    LM_OWF_PASSWORD OwfPassword;

    LARGE_INTEGER CurrentPasswordTime;
    PUNICODE_STRING CurrentPassword = NULL;
    PUNICODE_STRING OldPassword = NULL;
    DWORD PasswordVersion;

    WCHAR ClearTextPassword[LM20_PWLEN+1];
    UNICODE_STRING NewPassword;

    BOOL PasswordChangedOnServer = FALSE;
    BOOL LsaSecretChanged = FALSE;
    BOOL DefaultCurrentPasswordBeingChanged = FALSE;
    BOOL DefaultOldPasswordBeingChanged = FALSE;

    BOOLEAN AmWriter = FALSE;

    ULONG CallAgainPeriod = 0;

    //
    // Initialization
    //

    NlAssert( ClientSession->CsReferenceCount > 0 );

    //
    // If the password change was refused by the DC,
    //  Don't ever try to change the password again (until the next reboot).
    //
    //  This could have been written to try every MaximumPasswordAge.  However,
    //  that gets complex if you take into consideration the CS_UPDATE_PASSWORD
    //  case where the time stamp on the LSA Secret doesn't get changed.
    //

    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    if ( ClientSession->CsFlags & CS_PASSWORD_REFUSED ) {
        UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

        CallAgainPeriod = MAILSLOT_WAIT_FOREVER;
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }
    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );





    //
    // Become a writer of the ClientSession.
    //

    if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                 "NlChangePassword: Can't become writer of client session.\n" ));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    AmWriter = TRUE;


    //
    // Get the outgoing password and the time the password was last changed
    //

    Status = NlGetOutgoingPassword( ClientSession,
                                    &CurrentPassword,
                                    &OldPassword,
                                    &PasswordVersion,
                                    &CurrentPasswordTime );

    if ( !NT_SUCCESS( Status ) ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlChangePassword: Cannot NlGetOutgoingPassword %lX\n",
                Status));
        goto Cleanup;
    }


    //
    // If the (old or new) password is still the default password
    //      (lower case computer name),
    //  or the password is null (a convenient default for domain trust),
    //  Flag that fact.
    //

    if ( CurrentPassword == NULL ||
         CurrentPassword->Length == 0 ||
         RtlEqualComputerName( &ClientSession->CsDomainInfo->DomUnicodeComputerNameString,
                               CurrentPassword ) ) {
        DefaultCurrentPasswordBeingChanged = TRUE;
        NlPrintCs((NL_SESSION_SETUP, ClientSession,
                 "NlChangePassword: New LsaSecret is default value.\n" ));

    }

    if ( OldPassword == NULL ||
         OldPassword->Length == 0 ||
         RtlEqualComputerName( &ClientSession->CsDomainInfo->DomUnicodeComputerNameString,
                               OldPassword ) ) {
        DefaultOldPasswordBeingChanged = TRUE;
        NlPrintCs((NL_SESSION_SETUP, ClientSession,
                  "NlChangePassword: Old LsaSecret is default value.\n" ));
    }


    //
    // If the password has not yet expired,
    //  and the password is not the default,
    //  and the password change isn't forced,
    //  just return.
    //

    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    if ( (ClientSession->CsFlags & CS_UPDATE_PASSWORD) == 0 &&
        !NlTimeHasElapsedEx( &CurrentPasswordTime,
                             &NlGlobalParameters.MaximumPasswordAge_100ns,
                             &CallAgainPeriod ) &&
        !DefaultCurrentPasswordBeingChanged &&
        !DefaultOldPasswordBeingChanged &&
        !ForcePasswordChange ) {

       //
       // Note that, since NlTimeHasElapsedEx returned FALSE,
       //  CallAgainPeriod is the time left until the next
       //  password change.
       //
       UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
       Status = STATUS_SUCCESS;
       goto Cleanup;
    }
    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

    CallAgainPeriod = 0;    // Let the caller determine the frequency for retries.
    NlPrintCs((NL_SESSION_SETUP, ClientSession,
             "NlChangePassword: Doing it.\n" ));


    //
    // If the session isn't authenticated,
    //  do so now.
    //
    // We're careful to not force this authentication unless the password
    //  needs to be changed.
    //
    // If this is the PDC changing its own password,
    //  there's no need to authenticate.
    //

    if ( ClientSession->CsState != CS_AUTHENTICATED &&
         !( ClientSession->CsSecureChannelType == ServerSecureChannel &&
            ClientSession->CsDomainInfo->DomRole == RolePrimary ) ) {

        //
        // If we've tried to authenticate recently,
        //  don't bother trying again.
        //

        if ( !NlTimeToReauthenticate( ClientSession ) ) {
            Status = ClientSession->CsConnectionStatus;
            goto Cleanup;

        }

        //
        // Try to set up the session.
        //

        Status = NlSessionSetup( ClientSession );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }
    }



    //
    // Once we change the password in LsaSecret storage,
    //  all future attempts to change the password should use the value
    //  from LsaSecret storage.  The secure channel is using the old
    //  value of the password.
    //

    LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
    if (ClientSession->CsFlags & CS_UPDATE_PASSWORD) {
        NlPrintCs((NL_SESSION_SETUP, ClientSession,
                 "NlChangePassword: Password already updated in secret\n" ));

        if ( CurrentPassword == NULL ) {
            RtlInitUnicodeString( &NewPassword, NULL );
        } else {
            NewPassword = *CurrentPassword;
        }

    //
    // Handle the case where LsaSecret storage has not yet been updated.
    //

    } else {
        ULONG i;


        //
        // Build a new clear text password using:
        //  Entirely random bits.
        // Srvmgr later uses this password as a zero terminated unicode string
        //  so ensure there aren't any zero chars in the middle
        //


        if ( !NlGenerateRandomBits( (LPBYTE)ClearTextPassword, sizeof(ClearTextPassword))) {
            NlPrint((NL_CRITICAL, "Can't NlGenerateRandomBits for clear password\n" ));
        }

        for (i = 0; i < sizeof(ClearTextPassword)/sizeof(WCHAR); i++) {
            if ( ClearTextPassword[i] == '\0') {
                ClearTextPassword[i] = 1;
            }
        }
        ClearTextPassword[LM20_PWLEN] = L'\0';

        RtlInitUnicodeString( &NewPassword, ClearTextPassword );

        //
        //
        // Set the new outgoing password locally.
        //
        // Set the OldValue to the perviously obtained CurrentValue.
        // Increment the password version number.
        //
        PasswordVersion++;
        Status = NlSetOutgoingPassword(
                    ClientSession,
                    &NewPassword,
                    CurrentPassword,
                    PasswordVersion,
                    PasswordVersion-1 );

        if ( !NT_SUCCESS( Status ) ) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                     "NlChangePassword: Cannot NlSetOutgoingPassword %lX\n",
                     Status));
            UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
            goto Cleanup;
        }

        //
        // Flag that we've updated the password in LsaSecret storage.
        //

        LsaSecretChanged = TRUE;
        ClientSession->CsFlags |= CS_UPDATE_PASSWORD;
        NlPrintCs((NL_SESSION_SETUP, ClientSession,
                 "NlChangePassword: Flag password changed in LsaSecret\n" ));

    }
    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );


    //
    // Perform the initial encryption.
    //

    Status = RtlCalculateNtOwfPassword( &NewPassword, &OwfPassword);

    if ( !NT_SUCCESS( Status )) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlChangePassword: Cannot RtlCalculateNtOwfPassword %lX\n",
                Status));
        goto Cleanup;
    }

    //
    // If this is a PDC, all we need to do is change the local account password
    //

    if ( ClientSession->CsSecureChannelType == ServerSecureChannel &&
         ClientSession->CsDomainInfo->DomRole == RolePrimary ) {
        Status = NlSamChangePasswordNamedUser( ClientSession->CsDomainInfo,
                                               ClientSession->CsAccountName,
                                               &NewPassword,
                                               &OwfPassword );

        if ( NT_SUCCESS(Status) ) {
            PasswordChangedOnServer = TRUE;
        } else {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlChangePassword: Cannot change password on PDC local user account 0x%lx\n",
                    Status));
        }
        goto Cleanup;
    }


    //
    // Change the password on the PDC
    //

    Status = NlChangePasswordHigher( ClientSession,
                                     ClientSession->CsAccountName,
                                     ClientSession->CsSecureChannelType,
                                     &OwfPassword,
                                     &NewPassword,
                                     &PasswordVersion );

    if ( Status != STATUS_ACCESS_DENIED ) {
        PasswordChangedOnServer = TRUE;
    }

    //
    // If the server refused the change,
    //  put the lsa secret back the way it was.
    //  pretend the change was successful.
    //

    if ( Status == STATUS_WRONG_PASSWORD ) {

        NlPrintCs((NL_SESSION_SETUP, ClientSession,
                 "NlChangePassword: PDC refused to change password\n" ));
        //
        // If we changed the LSA secret,
        //  put it back.
        //

        LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
        if ( LsaSecretChanged ) {
            NlPrintCs((NL_SESSION_SETUP, ClientSession,
                     "NlChangePassword: undoing LSA secret change.\n" ));

            PasswordVersion--;
            Status = NlSetOutgoingPassword(
                        ClientSession,
                        CurrentPassword,
                        OldPassword,
                        PasswordVersion,
                        PasswordVersion > 0 ? PasswordVersion-1 : 0 );

            if ( !NT_SUCCESS( Status ) ) {
                NlPrintCs((NL_CRITICAL, ClientSession,
                         "NlChangePassword: Cannot undo NlSetOutgoingPassword %lX\n",
                         Status));
                UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
                goto Cleanup;
            }

            //
            // Undo what we've done above.
            //
            ClientSession->CsFlags &= ~CS_UPDATE_PASSWORD;
        }

        //
        // Prevent us from trying too frequently.
        //

        ClientSession->CsFlags |= CS_PASSWORD_REFUSED;
        CallAgainPeriod = MAILSLOT_WAIT_FOREVER;
        UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

        //
        // Avoid special cleanup below.
        //
        PasswordChangedOnServer = FALSE;
        Status = STATUS_SUCCESS;
    }

    //
    // Common exit
    //

Cleanup:

    if ( PasswordChangedOnServer ) {

        //
        // On success,
        // Indicate that the password has now been updated on the
        // PDC so the old password is no longer in use.
        //

        if ( NT_SUCCESS( Status ) ) {

            LOCK_TRUST_LIST( ClientSession->CsDomainInfo );
            ClientSession->CsFlags &= ~CS_UPDATE_PASSWORD;

            NlPrintCs((NL_SESSION_SETUP, ClientSession,
                     "NlChangePassword: Flag password updated on PDC\n" ));

            //
            // If the default current password was changed,
            //  avoid leaving the default password around as the old
            //  password.  Otherwise, a bogus DC could convince us to use
            //  the bogus DC via the default password. Set both current
            //  and old version numbers to the new value.
            //

            if ( DefaultCurrentPasswordBeingChanged ) {
                NlPrintCs((NL_SESSION_SETUP, ClientSession,
                         "NlChangePassword: Setting LsaSecret old password to same as new password\n" ));

                Status = NlSetOutgoingPassword(
                            ClientSession,
                            &NewPassword,
                            &NewPassword,
                            PasswordVersion,
                            PasswordVersion );

                if ( !NT_SUCCESS( Status ) ) {
                    NlPrintCs((NL_CRITICAL, ClientSession,
                             "NlChangePassword: Cannot LsarSetSecret to set old password %lX\n",
                             Status));
                    UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );
                    goto Cleanup;
                }

            }

            //
            // Save the password for our own future reference.
            //
            // CsNtOwfPassword is the most recent known good password
            //

            RtlCopyMemory( &ClientSession->CsNtOwfPassword, &OwfPassword, sizeof( OwfPassword ));
            UNLOCK_TRUST_LIST( ClientSession->CsDomainInfo );

            //
            // Indicate we don't need to call change the password again for awhile
            //

            if ( NlGlobalParameters.MaximumPasswordAge > (TIMER_MAX_PERIOD/NL_MILLISECONDS_PER_DAY) ) {

                CallAgainPeriod = TIMER_MAX_PERIOD;
            } else {
                CallAgainPeriod = NlGlobalParameters.MaximumPasswordAge * NL_MILLISECONDS_PER_DAY;

            }



        //
        // Notify the Admin that he'll have to manually set this server's
        // password on both this server and the PDC.
        //

        } else {

            LPWSTR MsgStrings[2];

            //
            // Drop the secure channel
            //

            NlSetStatusClientSession( ClientSession, Status );

            //
            // write event log
            //

            MsgStrings[0] = ClientSession->CsAccountName;
            MsgStrings[1] = (LPWSTR) LongToPtr( Status );

            NlpWriteEventlog (
                NELOG_NetlogonPasswdSetFailed,
                EVENTLOG_ERROR_TYPE,
                (LPBYTE) & Status,
                sizeof(Status),
                MsgStrings,
                2 | NETP_LAST_MESSAGE_IS_NTSTATUS );
        }


    }


    //
    // Clean up locally used resources.
    //

    if ( CurrentPassword != NULL ) {
        LocalFree( CurrentPassword );
    }

    if ( OldPassword != NULL ) {
        LocalFree( OldPassword );
    }

    if ( AmWriter ) {
        NlResetWriterClientSession( ClientSession );
    }

    //
    // Tell the caller when he should call us again
    //

    if ( ARGUMENT_PRESENT( RetCallAgainPeriod) ) {
        *RetCallAgainPeriod = CallAgainPeriod;
    }

    return Status;
}


NTSTATUS
NlRefreshClientSession(
    IN PCLIENT_SESSION ClientSession
    )
/*++

Routine Description:

    Refresh the client session info. The info that we intend
    to refresh is:

        * Server name (the DC can be renamed in Whistler).
        * Discovery flags, in particular whether the server
            is still close.
        * The server IP address.

    We will also refresh our site name (on workstation).

    The caller must be a writer of the ClientSession.

Arguments:

    ClientSession - Structure describing the session.

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NET_API_STATUS NetStatus = NO_ERROR;
    PNL_DC_CACHE_ENTRY NlDcCacheEntry = NULL;
    BOOLEAN DcRediscovered = FALSE;

    //
    // If the client session is idle,
    //  there is nothing to refresh
    //

    if ( ClientSession->CsState == CS_IDLE ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // If the server (DC) is NT4.0, there is no need for refresh.
    //  (The only info that can potentially change for NT4.0 DC
    //   is its IP address which is not worth refreshing)
    //

    if ( (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_HAS_DS) == 0 ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // If it's not yet time to refresh the info,
    //  we don't need to do anything
    //

    EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
    if ( !NetpLogonTimeHasElapsed(ClientSession->CsLastRefreshTime,
                                  MAX_DC_REFRESH_TIMEOUT) ) {
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }
    LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );


    //
    // Get the up to date server info
    //

    Status = NlGetAnyDCName( ClientSession,
                             FALSE,   // Do not require IP
                             FALSE,   // Don't do with-account discovery
                             &NlDcCacheEntry,
                             &DcRediscovered );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Use this opportunity to update our site on a workstation
    //

    if ( NlGlobalMemberWorkstation ) {

        //
        // Only Win2K or newer DCs undestand the site concept
        //
        if ( (NlDcCacheEntry->ReturnFlags & DS_DS_FLAG) != 0 ) {
            NlSetDynamicSiteName( NlDcCacheEntry->UnicodeClientSiteName );
        } else {
            NlPrint(( NL_SITE,
                      "NlRefreshClientSession: NlGetAnyDCName returned NT4 DC\n" ));
        }
    }

Cleanup:

    if ( NlDcCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( NlDcCacheEntry );
    }

    return Status;
}


NTSTATUS
NlEnsureSessionAuthenticated(
    IN PCLIENT_SESSION ClientSession,
    IN DWORD DesiredFlags
    )
/*++

Routine Description:

    Ensure there is an authenticated session for the specified ClientSession.

    If the authenticated DC does not have the characteristics specified by
    DesiredFlags, attempt to find a DC that does.

    The caller must be a writer of the ClientSession.

Arguments:

    ClientSession - Structure describing the session.


    DesiredFlags - characteristics that the authenticated DC should have.
        Can be one or more of the following:

            CS_DISCOVERY_HAS_DS      // Discovered DS has a DS
            CS_DISCOVERY_IS_CLOSE    // Discovered DS is in a close site

        It is the callers responsibility to ensure that the DC really DOES
        have those characteristics.

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;

    //
    // First refresh the client session
    //

    Status = NlRefreshClientSession( ClientSession );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlpEnsureSessionAuthenticated: Can't refresh the session: 0x%lx\n",
                    Status ));
        goto Cleanup;
    }

    //
    // If this secure channel is from a BDC to the PDC,
    //  there is only ONE PDC so don't ask for special characteristics.
    //

    if ( ClientSession->CsSecureChannelType == ServerSecureChannel ) {
        DesiredFlags = 0;

    //
    // If this secure channel isn't expected to have NT 5 DCs,
    //  don't try to find one.
    //

    } else if ((ClientSession->CsFlags & CS_NT5_DOMAIN_TRUST) == 0 ) {
        DesiredFlags = 0;

    //
    // If we don't have a close DC,
    //  and it has been a long time since we've tried to find a close DC,
    //  do it now.
    //

    } else if ( (ClientSession->CsDiscoveryFlags & CS_DISCOVERY_IS_CLOSE) == 0 ) {
        BOOLEAN ReturnBoolean;

        EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
        if ( NetpLogonTimeHasElapsed(
                    ClientSession->CsLastDiscoveryTime,
                    NlGlobalParameters.CloseSiteTimeout * 1000 ) ) {
            DesiredFlags |= CS_DISCOVERY_IS_CLOSE;
        }
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
    }

    //
    // If a DC has already been detected,
    //  and the caller wants special characteristics,
    //  try for them now.
    //

    if ( ClientSession->CsState != CS_IDLE &&
         DesiredFlags != 0 ) {


        //
        // If the DC doesn't have the required characteristics,
        //  try to find a new one now
        //

        EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );
        if ( (ClientSession->CsDiscoveryFlags & DesiredFlags) != DesiredFlags ) {

            //
            // Avoid discovery if we've done it recently.
            //
            // All discoveries prefer a DC that has all of the desired characteristics.
            // So if we didn't find one, don't try again.
            //

            if ( NlTimeToRediscover(ClientSession, FALSE) ) {  // we'll do discovery without account

                NlPrintCs(( NL_SESSION_SETUP, ClientSession,
                            "NlpEnsureSessionAuthenticated: Try to find a better DC for this operation. 0x%lx\n", DesiredFlags ));

                //
                // Discovering a DC when the session is not idle tries to find a
                //  "better" DC.
                //
                // Ignore failures.
                //
                // Call without the any locks locked to prevent doing network I/O
                //  with the lock held.
                //
                // Don't ask for with-account discovery as it's too costly on the
                //  server side. If the discovered server doesn't have our account,
                //  the session setup logic will attempt with-account discovery.
                //

                LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );
                Status = NlDiscoverDc ( ClientSession,
                                        DT_Synchronous,
                                        FALSE ,
                                        FALSE ); // without account
                EnterCriticalSection( &NlGlobalDcDiscoveryCritSect );

            }

        }
        LeaveCriticalSection( &NlGlobalDcDiscoveryCritSect );

    }

    //
    // If we haven't yet authenticated,
    //  do so now.
    //

    if ( ClientSession->CsState != CS_AUTHENTICATED ) {

        //
        // If we've tried to authenticate recently,
        //  don't bother trying again.
        //

        if ( !NlTimeToReauthenticate( ClientSession ) ) {
            Status = ClientSession->CsConnectionStatus;
            NlAssert( !NT_SUCCESS( Status ));
            if ( NT_SUCCESS( Status )) {
                Status = STATUS_NO_LOGON_SERVERS;
            }
            goto Cleanup;

        }

        //
        // Try to set up the session.
        //

        Status = NlSessionSetup( ClientSession );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }
    }

    Status = STATUS_SUCCESS;
Cleanup:

    return Status;
}


NTSTATUS
NlChangePasswordHigher(
    IN PCLIENT_SESSION ClientSession,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN PLM_OWF_PASSWORD NewOwfPassword OPTIONAL,
    IN PUNICODE_STRING NewClearPassword OPTIONAL,
    IN PDWORD ClearPasswordVersionNumber OPTIONAL
    )
/*++

Routine Description:

    Pass the new password to the machine specified by the ClientSession.

    The caller must be a writer of the ClientSession.

Arguments:

    ClientSession - Structure describing the session to change the password
        for.  The specified structure must be referenced.

    AccountName - Name of the account whose password is being changed.

    AccountType - Type of account whose password is being changed.

    NewOwfPassword - Owf password to pass to ClientSession

    NewClearPassword - Clear password to pass to client session

    ClearPasswordVersionNumber - Version number of the clear password. Must
        be present if NewClearPassword is present.

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;
    NETLOGON_AUTHENTICATOR OurAuthenticator;
    NETLOGON_AUTHENTICATOR ReturnAuthenticator;
    SESSION_INFO SessionInfo;
    BOOLEAN FirstTry = TRUE;


    //
    // Initialization
    //

    NlAssert( ClientSession->CsReferenceCount > 0 );
    NlAssert( ClientSession->CsFlags & CS_WRITER );



    //
    // If the session isn't authenticated,
    //  do so now.
    //
    // We're careful to not force this authentication unless the password
    //  needs to be changed.
    //
FirstTryFailed:
    Status = NlEnsureSessionAuthenticated( ClientSession, 0 );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    SessionInfo.SessionKey = ClientSession->CsSessionKey;
    SessionInfo.NegotiatedFlags = ClientSession->CsNegotiatedFlags;


    //
    // Build the Authenticator for this request to the PDC.
    //

    NlBuildAuthenticator(
                    &ClientSession->CsAuthenticationSeed,
                    &ClientSession->CsSessionKey,
                    &OurAuthenticator);


    //
    // If the other side will accept a clear text password,
    //  send it.
    //

    if ( NewClearPassword != NULL &&
         (SessionInfo.NegotiatedFlags & NETLOGON_SUPPORTS_PASSWORD_SET_2) != 0 ) {
        NL_TRUST_PASSWORD NlTrustPassword;
        NL_PASSWORD_VERSION PasswordVersion;

        //
        // Copy the new password to the end of the buffer.
        //

        RtlCopyMemory( ((LPBYTE)NlTrustPassword.Buffer) +
                            NL_MAX_PASSWORD_LENGTH * sizeof(WCHAR) -
                            NewClearPassword->Length,
                        NewClearPassword->Buffer,
                        NewClearPassword->Length );

        NlTrustPassword.Length = NewClearPassword->Length;

        //
        // For an interdomain trust account,
        // indicate that we pass the password version number by prefixing
        // a DWORD equal to PASSWORD_VERSION_NUMBER_PRESENT right before
        // the password in NewClearPassword->Buffer. An old server (RC0)
        // not supporting version numbers will simply ignore these bits.
        // A server supporting version numbers will examine these bits
        // and if they are equal to PASSWORD_VERSION_NUMBER_PRESENT then
        // that will be an indication that a version number is passed. An
        // old client not supporting version numbers will generate random
        // bits in place of PASSWORD_VERSION_NUMBER_PRESENT.  It is highly
        // unlikely that an old client will generate random bits equal to
        // PASSWORD_VERSION_NUMBER_PRESENT.  The
        // version number will be a DWORD preceeding the DWORD equal to
        // PASSWORD_VERSION_NUMBER_PRESENT.  Another DWORD equal to 0 will
        // preceed the version number.  Its purpose is to allow any future
        // additions to the buffer.  The value of this DWORD different from
        // 0 will indicate without any uncertainty that some additional
        // info is passed preceding this DWORD. The 3 new DWORDs are packed
        // in a struct to avoid unalingment problems.
        //

        if ( IsDomainSecureChannelType( AccountType ) ) {

            NlAssert( ClearPasswordVersionNumber != NULL );
            NlAssert( NL_MAX_PASSWORD_LENGTH * sizeof(WCHAR) -
                                NewClearPassword->Length -
                                sizeof(PasswordVersion) > 0 );

            PasswordVersion.ReservedField = 0;
            PasswordVersion.PasswordVersionNumber = *ClearPasswordVersionNumber;
            PasswordVersion.PasswordVersionPresent = PASSWORD_VERSION_NUMBER_PRESENT;

            RtlCopyMemory( ((LPBYTE)NlTrustPassword.Buffer) +
                                NL_MAX_PASSWORD_LENGTH * sizeof(WCHAR) -
                                NewClearPassword->Length -
                                sizeof(PasswordVersion),
                            &PasswordVersion,
                            sizeof(PasswordVersion) );
        }

        //
        // Fill the rest of the buffer with random bytes
        //

        if ( !NlGenerateRandomBits( (LPBYTE)NlTrustPassword.Buffer,
                               (NL_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                                    NewClearPassword->Length -
                                    sizeof(PasswordVersion) ) ) {
            NlPrint((NL_CRITICAL, "Can't NlGenerateRandomBits for clear password prefix\n" ));
        }

        //
        // Encrypt the whole buffer.
        //

        NlEncryptRC4( &NlTrustPassword,
                      sizeof( NlTrustPassword ),
                      &SessionInfo );


        //
        // Change the password on the machine our connection is to.
        //

        NL_API_START( Status, ClientSession, TRUE ) {

            NlAssert( ClientSession->CsUncServerName != NULL );
            Status = I_NetServerPasswordSet2( ClientSession->CsUncServerName,
                                             AccountName,
                                             AccountType,
                                             ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                                             &OurAuthenticator,
                                             &ReturnAuthenticator,
                                             &NlTrustPassword);

            if ( !NT_SUCCESS(Status) ) {
                NlPrintRpcDebug( "I_NetServerPasswordSet2", Status );
            }

        // NOTE: This call may drop the secure channel behind our back
        } NL_API_ELSE( Status, ClientSession, TRUE ) {
        } NL_API_END;

    //
    // If the other side needs an OWF password,
    //  send it.
    //

    } else {
        ENCRYPTED_LM_OWF_PASSWORD SessKeyEncrPassword;
        LM_OWF_PASSWORD LocalOwfPassword;

        //
        // If the caller doesn't know the OWF password,
        //  compute the owf.
        //

        if ( NewOwfPassword == NULL ) {

            //
            // Perform the initial encryption.
            //

            Status = RtlCalculateNtOwfPassword( NewClearPassword, &LocalOwfPassword);

            if ( !NT_SUCCESS( Status )) {
                NlPrintCs((NL_CRITICAL, ClientSession,
                        "NlChangePasswordHigher: Cannot RtlCalculateNtOwfPassword %lX\n",
                        Status));
                goto Cleanup;
            }

            NewOwfPassword = &LocalOwfPassword;
        }



        //
        // Encrypt the password again with the session key.
        //  The PDC will decrypt it on the other side.
        //

        Status = RtlEncryptNtOwfPwdWithNtOwfPwd(
                            NewOwfPassword,
                            (PNT_OWF_PASSWORD) &ClientSession->CsSessionKey,
                            &SessKeyEncrPassword) ;

        if ( !NT_SUCCESS( Status )) {
            NlPrintCs((NL_CRITICAL, ClientSession,
                    "NlChangePasswordHigher: Cannot RtlEncryptNtOwfPwdWithNtOwfPwd %lX\n",
                    Status));
            goto Cleanup;
        }


        //
        // Change the password on the machine our connection is to.
        //

        NL_API_START( Status, ClientSession, TRUE ) {

            NlAssert( ClientSession->CsUncServerName != NULL );
            Status = I_NetServerPasswordSet( ClientSession->CsUncServerName,
                                             AccountName,
                                             AccountType,
                                             ClientSession->CsDomainInfo->DomUnicodeComputerNameString.Buffer,
                                             &OurAuthenticator,
                                             &ReturnAuthenticator,
                                             &SessKeyEncrPassword);

            if ( !NT_SUCCESS(Status) ) {
                NlPrintRpcDebug( "I_NetServerPasswordSet", Status );
            }

        // NOTE: This call may drop the secure channel behind our back
        } NL_API_ELSE( Status, ClientSession, TRUE ) {
        } NL_API_END;
    }


    //
    // Now verify primary's authenticator and update our seed
    //

    if ( NlpDidDcFail( Status ) ||
         !NlUpdateSeed( &ClientSession->CsAuthenticationSeed,
                        &ReturnAuthenticator.Credential,
                        &ClientSession->CsSessionKey) ) {

        NlPrintCs(( NL_CRITICAL, ClientSession,
                    "NlChangePasswordHigher: denying access after status: 0x%lx\n",
                    Status ));

        //
        // Preserve any status indicating a communication error.
        //

        if ( NT_SUCCESS(Status) ) {
            Status = STATUS_ACCESS_DENIED;
        }
        NlSetStatusClientSession( ClientSession, Status );

        //
        // Perhaps the netlogon service on the server has just restarted.
        //  Try just once to set up a session to the server again.
        //
        if ( FirstTry ) {
            FirstTry = FALSE;
            goto FirstTryFailed;
        }
    }

    //
    // Common exit
    //

Cleanup:

    if ( !NT_SUCCESS(Status) ) {
        NlPrintCs((NL_CRITICAL, ClientSession,
                "NlChangePasswordHigher: %ws: failed %lX\n",
                AccountName,
                Status));
    }

    return Status;
}




NTSTATUS
NlGetUserPriv(
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG GroupCount,
    IN PGROUP_MEMBERSHIP Groups,
    IN ULONG UserRelativeId,
    OUT LPDWORD Priv,
    OUT LPDWORD AuthFlags
    )

/*++

Routine Description:

    Determines the Priv and AuthFlags for the specified user.

Arguments:

    DomainInfo - Hosted domain the user account is in.

    GroupCount - Number of groups this user is a member of

    Groups - Array of groups this user is a member of.

    UserRelativeId - Relative ID of the user to query.

    Priv - Returns the Lanman 2.0 Privilege level for the specified user.

    AuthFlags - Returns the Lanman 2.0 Authflags for the specified user.


Return Value:

    Status of the operation.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    ULONG GroupIndex;
    PSID *UserSids = NULL;
    ULONG UserSidCount = 0;
    SAMPR_PSID_ARRAY SamSidArray;
    SAMPR_ULONG_ARRAY Aliases;

    //
    // Initialization
    //

    Aliases.Element = NULL;

    //
    // Allocate a buffer to point to the SIDs we're interested in
    // alias membership for.
    //

    UserSids = (PSID *)
        NetpMemoryAllocate( (GroupCount+1) * sizeof(PSID) );

    if ( UserSids == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Add the User's Sid to the Array of Sids.
    //

    NetStatus = NetpDomainIdToSid( DomainInfo->DomAccountDomainId,
                                   UserRelativeId,
                                   &UserSids[0] );

    if ( NetStatus != NERR_Success ) {
        Status = NetpApiStatusToNtStatus( NetStatus );
        goto Cleanup;
    }

    UserSidCount ++;



    //
    // Add each group the user is a member of to the array of Sids.
    //

    for ( GroupIndex = 0; GroupIndex < GroupCount; GroupIndex ++ ){

        NetStatus = NetpDomainIdToSid( DomainInfo->DomAccountDomainId,
                                       Groups[GroupIndex].RelativeId,
                                       &UserSids[GroupIndex+1] );

        if ( NetStatus != NERR_Success ) {
            Status = NetpApiStatusToNtStatus( NetStatus );
            goto Cleanup;
        }

        UserSidCount ++;
    }


    //
    // Find out which aliases in the builtin domain this user is a member of.
    //

    SamSidArray.Count = UserSidCount;
    SamSidArray.Sids = (PSAMPR_SID_INFORMATION) UserSids;
    Status = SamrGetAliasMembership( DomainInfo->DomSamBuiltinDomainHandle,
                                     &SamSidArray,
                                     &Aliases );

    if ( !NT_SUCCESS(Status) ) {
        Aliases.Element = NULL;
        NlPrint((NL_CRITICAL,
                "NlGetUserPriv: SamGetAliasMembership returns %lX\n",
                Status ));
        goto Cleanup;
    }

    //
    // Convert the alias membership to priv and auth flags
    //

    NetpAliasMemberToPriv(
                 Aliases.Count,
                 Aliases.Element,
                 Priv,
                 AuthFlags );

    Status = STATUS_SUCCESS;

    //
    // Free Locally used resources.
    //
Cleanup:
    if ( Aliases.Element != NULL ) {
        SamIFree_SAMPR_ULONG_ARRAY ( &Aliases );
    }

    if ( UserSids != NULL ) {

        for ( GroupIndex = 0; GroupIndex < UserSidCount; GroupIndex ++ ) {
            NetpMemoryFree( UserSids[GroupIndex] );
        }

        NetpMemoryFree( UserSids );
    }

    return Status;
}

/*lint +e740 */  /* don't complain about unusual cast */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nlcommon.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    nlcommon.c

Abstract:

    Just an include for ..\nlcommon.c

Author:

    ChandanS 09-April-1998

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

#include "..\idl\nlcommon.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\mailslot.c ===
/*--


Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    mailslot.c

Abstract:

    Routines for doing I/O on the netlogon service's mailslots.

Author:

    03-Nov-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//

#include <lmbrowsr.h>   // I_BrowserSetNetlogonState
#include <srvann.h>     // Service announcement
#include <nbtioctl.h>   // IOCTL_NETBT_REMOVE_FROM_REMOTE_TABLE


//
// Define maximum buffer size returned from the browser.
//
// Header returned by browser + actual mailslot message size + name of
// mailslot + name of transport.
//

#define MAILSLOT_MESSAGE_SIZE \
           (sizeof(NETLOGON_MAILSLOT)+ \
                  NETLOGON_MAX_MS_SIZE + \
                  (NETLOGON_LM_MAILSLOT_LEN+1) * sizeof(WCHAR) + \
                  (MAXIMUM_FILENAME_LENGTH+1) * sizeof(WCHAR))

/////////////////////////////////////////////////////////////////////////////
//
// Structure describing one of the primary mailslots the netlogon service
// will read messages from.
//
// This structure is used only by netlogon's main thread and therefore needs
// no synchronization.
//
/////////////////////////////////////////////////////////////////////////////

typedef struct _NETLOGON_MAILSLOT_DESC {

    HANDLE BrowserHandle;   // Handle to the browser device driver

    HANDLE BrowserReadEvent;// Handle to wait on for overlapped I/O

    OVERLAPPED Overlapped;  // Governs overlapped I/O

    BOOL ReadPending;       // True if a read operation is pending

    LPBYTE CurrentMessage;  // Pointer to Message1 or Message2 below

    LPBYTE PreviousMessage; // Previous value of CurrentMessage


    //
    // Buffer containing message from browser
    //
    // The buffers are alternated allowing us to compare if an incoming
    // message is identical to the previous message.
    //
    // Leave room so the actual used portion of each buffer is properly aligned.
    // The NETLOGON_MAILSLOT struct begins with a LARGE_INTEGER which must be
    // aligned.

    BYTE Message1[ MAILSLOT_MESSAGE_SIZE + ALIGN_WORST ];
    BYTE Message2[ MAILSLOT_MESSAGE_SIZE + ALIGN_WORST ];

} NETLOGON_MAILSLOT_DESC, *PNETLOGON_MAILSLOT_DESC;

PNETLOGON_MAILSLOT_DESC NlGlobalMailslotDesc;




HANDLE
NlBrowserCreateEvent(
    VOID
    )
/*++

Routine Description:

    Creates an event to be used in a DeviceIoControl to the browser.

    ??: Consider caching one or two events to reduce the number of create
    events

Arguments:

    None

Return Value:

    Handle to an event or NULL if the event couldn't be allocated.

--*/
{
    HANDLE EventHandle;
    //
    // Create a completion event
    //

    EventHandle = CreateEvent(
                                  NULL,     // No security ettibutes
                                  TRUE,     // Manual reset
                                  FALSE,    // Initially not signaled
                                  NULL);    // No Name

    if ( EventHandle == NULL ) {
        NlPrint((NL_CRITICAL, "Cannot create Browser read event %ld\n", GetLastError() ));
    }

    return EventHandle;
}


VOID
NlBrowserCloseEvent(
    IN HANDLE EventHandle
    )
/*++

Routine Description:

    Closes an event used in a DeviceIoControl to the browser.

Arguments:

    EventHandle - Handle of the event to close

Return Value:

    None.

--*/
{
    (VOID) CloseHandle( EventHandle );
}



VOID
NlBrowserClose(
    VOID
    );


NTSTATUS
NlBrowserDeviceIoControl(
    IN HANDLE BrowserHandle,
    IN DWORD FunctionCode,
    IN PLMDR_REQUEST_PACKET RequestPacket,
    IN DWORD RequestPacketSize,
    IN LPBYTE Buffer,
    IN DWORD BufferSize
    )
/*++

Routine Description:

    Send a DeviceIoControl syncrhonously to the browser.

Arguments:

    FunctionCode - DeviceIoControl function code

    RequestPacket - The request packet to send.

    RequestPacketSize - Size (in bytes) of the request packet.

    Buffer - Additional buffer to pass to the browser

    BufferSize - Size (in bytes) of Buffer

Return Value:

    Status of the operation.

    STATUS_NETWORK_UNREACHABLE: Cannot write to network.

    STATUS_BAD_NETWORK_PATH: The name the datagram is destined for isn't
        registered


--*/
{
    NTSTATUS Status;
    DWORD WinStatus;
    OVERLAPPED Overlapped;
    DWORD BytesReturned;

    //
    // Initialization
    //

    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    //
    // Get a completion event
    //

    Overlapped.hEvent = NlBrowserCreateEvent();

    if ( Overlapped.hEvent == NULL ) {
        return NetpApiStatusToNtStatus( GetLastError() );
    }

    //
    // Send the request to the Datagram Receiver device driver.
    //

    if ( !DeviceIoControl(
                   BrowserHandle,
                   FunctionCode,
                   RequestPacket,
                   RequestPacketSize,
                   Buffer,
                   BufferSize,
                   &BytesReturned,
                   &Overlapped )) {

        WinStatus = GetLastError();

        if ( WinStatus == ERROR_IO_PENDING ) {
            if ( !GetOverlappedResult( BrowserHandle,
                                       &Overlapped,
                                       &BytesReturned,
                                       TRUE )) {
                WinStatus = GetLastError();
            } else {
                WinStatus = NO_ERROR;
            }
        }
    } else {
        WinStatus = NO_ERROR;
    }

    //
    // Delete the completion event
    //

    NlBrowserCloseEvent( Overlapped.hEvent );


    if ( WinStatus ) {
        //
        // Some transports return an error if the name cannot be resolved:
        //  Nbf returns ERROR_NOT_READY
        //  NetBt returns ERROR_BAD_NETPATH
        //
        if ( WinStatus == ERROR_BAD_NETPATH || WinStatus == ERROR_NOT_READY ) {
            Status = STATUS_BAD_NETWORK_PATH;
        } else {
            NlPrint((NL_CRITICAL,"Ioctl %lx to Browser returns %ld\n", FunctionCode, WinStatus));
            Status = NetpApiStatusToNtStatus( WinStatus );
        }
    } else {
        Status = STATUS_SUCCESS;
    }


    return Status;
}



NTSTATUS
NlBrowserOpenDriver(
    PHANDLE BrowserHandle
    )
/*++

Routine Description:

    This routine opens the NT LAN Man Datagram Receiver driver.

Arguments:

    BrowserHandle - Upon success, returns a handle to the browser driver
        Close it using NtClose

Return Value:

    Status of the operation

--*/
{
    NTSTATUS Status;
    BOOL ReturnValue;

    UNICODE_STRING DeviceName;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;


    //
    // Open the browser device.
    //
    RtlInitUnicodeString(&DeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                   BrowserHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   0,
                   0
                   );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    return Status;
}


NTSTATUS
NlBrowserRenameDomain(
    IN LPWSTR OldDomainName OPTIONAL,
    IN LPWSTR NewDomainName
    )
/*++

Routine Description:

    Tell the browser to rename the domain.

Arguments:

    OldDomainName - previous name of the domain.
        If not specified, the primary domain is implied.

    NewDomainName - new name of the domain.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    HANDLE BrowserHandle = NULL;
    LPBYTE Where;

    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)+2*(DNLEN+1)*sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;


    //
    // Open the browser driver.
    //

    Status = NlBrowserOpenDriver( &BrowserHandle );

    if (Status != NERR_Success) {
        return(Status);
    }

    //
    // Build the request packet.
    //
    RtlInitUnicodeString( &RequestPacket->TransportName, NULL );
    RequestPacket->Parameters.DomainRename.ValidateOnly = FALSE;


    //
    // Copy the new domain name into the packet.
    //

    Where = (LPBYTE) RequestPacket->Parameters.DomainRename.DomainName;
    RequestPacket->Parameters.DomainRename.DomainNameLength = wcslen( NewDomainName ) * sizeof(WCHAR);
    wcscpy( (LPWSTR)Where, NewDomainName );
    Where += RequestPacket->Parameters.DomainRename.DomainNameLength + sizeof(WCHAR);


    //
    // Copy the old domain name to the request packet.
    //

    if ( OldDomainName == NULL ) {
        RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, NULL );
    } else {
        wcscpy( (LPWSTR)Where, OldDomainName );
        RtlInitUnicodeString( &RequestPacket->EmulatedDomainName,
                              (LPWSTR)Where );
        Where += RequestPacket->EmulatedDomainName.Length + sizeof(WCHAR);
    }


    //
    // Pass the reeqest to the browser.
    //

    Status = NlBrowserDeviceIoControl(
                   BrowserHandle,
                   IOCTL_LMDR_RENAME_DOMAIN,
                   RequestPacket,
                   (ULONG)(Where - (LPBYTE)RequestPacket),
                   NULL,
                   0 );

    if (Status != NERR_Success) {
        NlPrint((NL_CRITICAL,
                 "NlBrowserRenameDomain: Unable rename domain from %ws to %ws: %lx\n",
                OldDomainName,
                NewDomainName,
                Status ));
    }

    if ( BrowserHandle != NULL ) {
        NtClose( BrowserHandle );
    }
    return Status;

}


NET_API_STATUS
NlBrowserDeviceControlGetInfo(
    IN DWORD FunctionCode,
    IN PLMDR_REQUEST_PACKET RequestPacket,
    IN DWORD RequestPacketSize,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize
    )
/*++

Routine Description:

    This function allocates the buffer and fill it with the information
    that is retrieved from the datagram receiver.

Arguments:

    FunctionCode - DeviceIoControl function code

    RequestPacket - The request packet to send.

    RequestPacketSize - Size (in bytes) of the request packet.

    OutputBuffer - Returns a pointer to the buffer allocated by this routine
        which contains the use information requested.  This buffer should
        be freed using MIDL_user_free.

    PreferedMaximumLength - Supplies the number of bytes of information to
        return in the buffer.  If this value is MAXULONG, we will try to
        return all available information if there is enough memory resource.

    BufferHintSize - Supplies the hint size of the output buffer so that the
        memory allocated for the initial buffer will most likely be large
        enough to hold all requested data.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{

//
// Buffer allocation size for enumeration output buffer.
//
#define INITIAL_ALLOCATION_SIZE  48*1024  // First attempt size (48K)
#define FUDGE_FACTOR_SIZE        1024  // Second try TotalBytesNeeded
                                       //     plus this amount

    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    DWORD OutputBufferLength;
    DWORD TotalBytesNeeded = 1;
    ULONG OriginalResumeKey;

    //
    // Initialization
    //

    if ( NlGlobalMailslotDesc == NULL ||
         NlGlobalMailslotDesc->BrowserHandle == NULL ) {
        return ERROR_NOT_SUPPORTED;
    }

    OriginalResumeKey = RequestPacket->Parameters.EnumerateNames.ResumeHandle;

    //
    // If PreferedMaximumLength is MAXULONG, then we are supposed to get all
    // the information, regardless of size.  Allocate the output buffer of a
    // reasonable size and try to use it.  If this fails, the Redirector FSD
    // will say how much we need to allocate.
    //

    if (PreferedMaximumLength == MAXULONG) {
        OutputBufferLength = (BufferHintSize) ?
                             BufferHintSize :
                             INITIAL_ALLOCATION_SIZE;
    } else {
        OutputBufferLength = PreferedMaximumLength;
    }

    OutputBufferLength = ROUND_UP_COUNT(OutputBufferLength, ALIGN_WCHAR);

    if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);

    //
    // Make the request of the Datagram Receiver
    //

    RequestPacket->Parameters.EnumerateServers.EntriesRead = 0;

    Status = NlBrowserDeviceIoControl(
                    NlGlobalMailslotDesc->BrowserHandle,
                    FunctionCode,
                    RequestPacket,
                    RequestPacketSize,
                    *OutputBuffer,
                    OutputBufferLength );

    NetStatus = NetpNtStatusToApiStatus(Status);


    //
    // If we couldn't get all the data on the first call,
    //  the datagram receiver returned the needed size of the buffer.
    //

    if ( RequestPacket->Parameters.EnumerateNames.EntriesRead !=
         RequestPacket->Parameters.EnumerateNames.TotalEntries ) {

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        TotalBytesNeeded = RequestPacket->Parameters.EnumerateNames.TotalBytesNeeded;
    }

    if ((TotalBytesNeeded > OutputBufferLength) &&
        (PreferedMaximumLength == MAXULONG)) {

        //
        // Initial output buffer allocated was too small and we need to return
        // all data.  First free the output buffer before allocating the
        // required size plus a fudge factor just in case the amount of data
        // grew.
        //

        MIDL_user_free(*OutputBuffer);

        OutputBufferLength =
            ROUND_UP_COUNT((TotalBytesNeeded + FUDGE_FACTOR_SIZE),
                           ALIGN_WCHAR);

        if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);


        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.ResumeHandle
                    )
                );

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.ResumeHandle
                    )
                );

        RequestPacket->Parameters.EnumerateNames.ResumeHandle = OriginalResumeKey;
        RequestPacket->Parameters.EnumerateServers.EntriesRead = 0;

        //
        //  Make the request of the Datagram Receiver
        //

        Status = NlBrowserDeviceIoControl(
                        NlGlobalMailslotDesc->BrowserHandle,
                        FunctionCode,
                        RequestPacket,
                        RequestPacketSize,
                        *OutputBuffer,
                        OutputBufferLength );

        NetStatus = NetpNtStatusToApiStatus(Status);

    }


    //
    // If not successful in getting any data, or if the caller asked for
    // all available data with PreferedMaximumLength == MAXULONG and
    // our buffer overflowed, free the output buffer and set its pointer
    // to NULL.
    //
    if ((NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA) ||
        (TotalBytesNeeded == 0) ||
        (PreferedMaximumLength == MAXULONG && NetStatus == ERROR_MORE_DATA) ||
        (RequestPacket->Parameters.EnumerateServers.EntriesRead == 0)) {

        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;

        //
        // PreferedMaximumLength == MAXULONG and buffer overflowed means
        // we do not have enough memory to satisfy the request.
        //
        if (NetStatus == ERROR_MORE_DATA) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return NetStatus;
}

NET_API_STATUS
NlBrowserGetTransportList(
    OUT PLMDR_TRANSPORT_LIST *TransportList
    )

/*++

Routine Description:

    This routine returns the list of transports bound into the browser.

Arguments:

    TransportList - Transport list to return.
        This buffer should be freed using MIDL_user_free.

Return Value:

    NERR_Success or reason for failure.

--*/

{
    NET_API_STATUS NetStatus;
    LMDR_REQUEST_PACKET RequestPacket;

    RequestPacket.Type = EnumerateXports;

    RtlInitUnicodeString(&RequestPacket.TransportName, NULL);
    RtlInitUnicodeString(&RequestPacket.EmulatedDomainName, NULL);

    NetStatus = NlBrowserDeviceControlGetInfo(
                    IOCTL_LMDR_ENUMERATE_TRANSPORTS,
                    &RequestPacket,
                    sizeof(RequestPacket),
                    TransportList,
                    0xffffffff,
                    4096 );

    return NetStatus;
}



NTSTATUS
NlBrowserAddDelName(
    IN PDOMAIN_INFO DomainInfo,
    IN BOOLEAN AddName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR TransportName OPTIONAL,
    IN PUNICODE_STRING Name OPTIONAL
    )
/*++

Routine Description:

    Add or delete a name in the browser.

Arguments:

    DomainInfo - Hosted domain the name is to be added/deleted for.

    AddName - TRUE to add the name.  FALSE to delete the name.

    NameType - Type of name to be added/deleted

    TransportName -- Name of the transport to send on.
        Use NULL to send on all transports.

    Name - Name to be added
        If not specified, all names of NameType are deleted for this hosted domain.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    LPBYTE Where;
    PLMDR_REQUEST_PACKET RequestPacket = NULL;
    ULONG TransportNameSize;

    //
    // Build the request packet.
    //

    if ( TransportName != NULL ) {
        TransportNameSize = (wcslen(TransportName) + 1) * sizeof(WCHAR);
    } else {
        TransportNameSize = 0;
    }

    RequestPacket = NetpMemoryAllocate( sizeof(LMDR_REQUEST_PACKET) +
                                        (max(CNLEN, DNLEN) + 1) * sizeof(WCHAR) +
                                        (DNLEN + 1) * sizeof(WCHAR) +
                                        TransportNameSize );

    if (RequestPacket == NULL) {
        return STATUS_NO_MEMORY;
    }

    RequestPacket->Parameters.AddDelName.Type = NameType;

    //
    // Copy the name to be added to request packet.
    //

    Where = (LPBYTE) RequestPacket->Parameters.AddDelName.Name;
    if ( Name == NULL ) {
        NlAssert( !AddName );
        RequestPacket->Parameters.AddDelName.DgReceiverNameLength = 0;
    } else {
        RequestPacket->Parameters.AddDelName.DgReceiverNameLength =
            Name->Length;
        RtlCopyMemory( Where, Name->Buffer, Name->Length );
        Where += Name->Length;
    }

    //
    // Copy the hosted domain name to the request packet.
    //

    wcscpy( (LPWSTR)Where,
            DomainInfo->DomUnicodeDomainNameString.Buffer );
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName,
                          (LPWSTR)Where );
    Where += DomainInfo->DomUnicodeDomainNameString.Length + sizeof(WCHAR);

    //
    // Fill in the TransportName
    //

    if ( TransportName != NULL ) {
        wcscpy( (LPWSTR) Where, TransportName);
        RtlInitUnicodeString( &RequestPacket->TransportName, (LPWSTR) Where );
        Where += TransportNameSize;
    } else {
        RequestPacket->TransportName.Length = 0;
        RequestPacket->TransportName.Buffer = NULL;
    }


    //
    // Do the actual work
    //

    Status = NlBrowserDeviceIoControl(
                   NlGlobalMailslotDesc->BrowserHandle,
                   AddName ? IOCTL_LMDR_ADD_NAME_DOM : IOCTL_LMDR_DELETE_NAME_DOM,
                   RequestPacket,
                   (ULONG)(Where - (LPBYTE)RequestPacket),
                   NULL,
                   0 );

    NetpMemoryFree( RequestPacket );
    return Status;
}


VOID
NlBrowserAddName(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Add the Domain<1B> name.  This is the name NetGetDcName uses to identify
    the PDC.

Arguments:

    DomainInfo - Hosted domain the name is to be added for.

Return Value:

    None.

--*/
{
    LPWSTR MsgStrings[3] = { NULL };
    BOOL AtLeastOneTransportEnabled = FALSE;
    BOOL NameAdded = FALSE;

    if ( NlGlobalMailslotDesc == NULL) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NlBrowserAddName: before browser initialized.\n" ));
        goto Cleanup;
    }

    //
    // If the domain has been renamed,
    //  delete any old names lying around.
    //

    if ( DomainInfo->DomFlags & DOM_RENAMED_1B_NAME ) {
        NlBrowserDelName( DomainInfo );
    }

    //
    // Add the <domain>0x1B name.
    //
    // This is the name NetGetDcName uses to identify the PDC.
    //
    // Do this for each transport separately and log any error
    //  indicating which transport failed.
    //

    if ( DomainInfo->DomRole == RolePrimary ) {
        PLIST_ENTRY ListEntry;
        PNL_TRANSPORT TransportEntry;
        NTSTATUS Status = STATUS_SUCCESS;

        //
        // Capture the domain name for event log output.
        //  If we can't capture (i.e. no memory), we simply
        //  won't output below.
        //

        EnterCriticalSection( &NlGlobalDomainCritSect );
        MsgStrings[0] = NetpAllocWStrFromWStr( DomainInfo->DomUnicodeDomainName );
        LeaveCriticalSection( &NlGlobalDomainCritSect );


        EnterCriticalSection( &NlGlobalTransportCritSect );
        for ( ListEntry = NlGlobalTransportList.Flink ;
              ListEntry != &NlGlobalTransportList ;
              ListEntry = ListEntry->Flink) {

            TransportEntry = CONTAINING_RECORD( ListEntry, NL_TRANSPORT, Next );

            //
            // Skip deleted transports.
            //
            if ( !TransportEntry->TransportEnabled ) {
                continue;
            }
            AtLeastOneTransportEnabled = TRUE;

            Status = NlBrowserAddDelName( DomainInfo,
                                          TRUE,
                                          PrimaryDomainBrowser,
                                          TransportEntry->TransportName,
                                          &DomainInfo->DomUnicodeDomainNameString );

            if ( NT_SUCCESS(Status) ) {
                NameAdded = TRUE;
                NlPrintDom(( NL_MISC, DomainInfo,
                             "Added the 0x1B name on transport %ws\n",
                             TransportEntry->TransportName ));

            //
            // Output the event log indicating the name of the failed transport
            //
            } else if ( MsgStrings[0] != NULL ) {
                NlPrintDom(( NL_CRITICAL, DomainInfo,
                             "Failed to add the 0x1B name on transport %ws\n",
                             TransportEntry->TransportName ));

                MsgStrings[1] = TransportEntry->TransportName;
                MsgStrings[2] = (LPWSTR) LongToPtr( Status );

                NlpWriteEventlog(
                    NELOG_NetlogonAddNameFailure,
                    EVENTLOG_ERROR_TYPE,
                    (LPBYTE)&Status,
                    sizeof(Status),
                    MsgStrings,
                    3 | NETP_LAST_MESSAGE_IS_NTSTATUS );
            }
        }
        LeaveCriticalSection( &NlGlobalTransportCritSect );

        //
        // Indicate that the name was added (at least on one transport)
        //

        if ( NameAdded ) {
            EnterCriticalSection( &NlGlobalDomainCritSect );
            DomainInfo->DomFlags |= DOM_ADDED_1B_NAME;
            LeaveCriticalSection( &NlGlobalDomainCritSect );
        }
        if ( !AtLeastOneTransportEnabled ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                         "Can't add the 0x1B name because all transports are disabled\n" ));
        }
    }

Cleanup:

    if ( MsgStrings[0] != NULL ) {
        NetApiBufferFree( MsgStrings[0] );
    }
}


VOID
NlBrowserDelName(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Delete the Domain<1B> name.  This is the name NetGetDcName uses to identify
    the PDC.

Arguments:

    DomainInfo - Hosted domain the name is to be deleted for.

Return Value:

    Success (Not used)

--*/
{
    NTSTATUS Status;

    if ( NlGlobalMailslotDesc == NULL) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                 "NlBrowserDelName: before browser initialized.\n" ));
        return;
    }

    //
    // Delete the <domain>0x1B name.
    //

    EnterCriticalSection(&NlGlobalDomainCritSect);
    if ( NlGlobalMailslotDesc->BrowserHandle != NULL &&
         (DomainInfo->DomFlags & (DOM_ADDED_1B_NAME|DOM_RENAMED_1B_NAME)) != 0 ) {
        LeaveCriticalSection(&NlGlobalDomainCritSect);

        Status = NlBrowserAddDelName( DomainInfo,
                                      FALSE,
                                      PrimaryDomainBrowser,
                                      NULL,     // Delete on all transports
                                      NULL );   // Delete all such names to handle the rename case

        if (! NT_SUCCESS(Status)) {
            NlPrintDom((NL_CRITICAL, DomainInfo,
                     "Can't remove the 0x1B name: 0x%lx\n",
                     Status));
        }

        EnterCriticalSection(&NlGlobalDomainCritSect);
        DomainInfo->DomFlags &= ~(DOM_ADDED_1B_NAME|DOM_RENAMED_1B_NAME);
    }
    LeaveCriticalSection(&NlGlobalDomainCritSect);

    return;
}



NET_API_STATUS
NlBrowserFixAllNames(
    IN PDOMAIN_INFO DomainInfo,
    IN PVOID Context
)
/*++

Routine Description:

    Scavenge the DomainName<1B> name.

Arguments:

    DomainInfo - The domain being scavenged.

    Context - Not Used

Return Value:

    Success (not used).

--*/
{


    //
    // Ensure our Domain<1B> name is registered.
    //

    if ( NlGlobalTerminate ) {
        return NERR_Success;
    }

    if ( DomainInfo->DomRole == RolePrimary ) {
        NlBrowserAddName( DomainInfo );
    } else {
        NlBrowserDelName( DomainInfo );
    }

    return NERR_Success;
    UNREFERENCED_PARAMETER( Context );
}


ULONG
NlServerType(
    IN DWORD Role
    )

/*++

Routine Description:

    Determines server type, that is used to set in service table.

Arguments:

    Role - Role to be translated

Return Value:

    SV_TYPE_DOMAIN_CTRL     if role is primary domain controller
    SV_TYPE_DOMAIN_BAKCTRL  if backup
    0                       if none of the above


--*/
{
    switch (Role) {
    case RolePrimary:
        return SV_TYPE_DOMAIN_CTRL;
    case RoleBackup:
        return SV_TYPE_DOMAIN_BAKCTRL;
    default:
        return 0;
    }
}



VOID
NlBrowserSyncHostedDomains(
    VOID
    )
/*++

Routine Description:

    Tell the browser and SMB server to delete any hosted domains it has
    that we don't have.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;
    LPWSTR HostedDomainName;
    LPWSTR HostedComputerName;
    DWORD RoleBits;

    PBROWSER_EMULATED_DOMAIN Domains;
    DWORD EntriesRead;
    DWORD TotalEntries;
    DWORD i;

    PSERVER_TRANSPORT_INFO_1 TransportInfo1;

#ifdef notdef
    //
    // Enumerate the Hosted domains.
    //  ?? Don't call this function.  This function requires the browser be
    //  running.  Rather, invent an Ioctl to the bowser to enumerate domains
    //  and use that ioctl here.
    //
    // ?? Note: Role no longer comes back from this API.  Role in the browser
    //  is now maintained on a per "network" basis.

    NetStatus = I_BrowserQueryEmulatedDomains(
                    NULL,
                    &Domains,
                    &EntriesRead );

    if ( NetStatus != NERR_Success ) {

        NlPrint((NL_CRITICAL,"NlBrowserSyncHostedDomains: Couldn't I_BrowserQueryEmulatedDomains %ld 0x%lx.\n",
                NetStatus, NetStatus ));

    //
    // Handle each enumerated domain
    //

    } else if ( EntriesRead != 0 ) {

        for ( i=0 ; i<EntriesRead; i++ ) {
            PDOMAIN_INFO DomainInfo;

            //
            // If we know the specified domain,
            //  all is well.
            //

            DomainInfo = NlFindNetbiosDomain( Domains[i].DomainName, FALSE );

            if ( DomainInfo != NULL ) {

                //
                // Ensure the hosted server name is identical.
                //

                if ( NlNameCompare( Domains[i].EmulatedServerName,
                                    DomainInfo->DomUnicodeComputerNameString.Buffer,
                                    NAMETYPE_COMPUTER) != 0 ) {

                    NlPrintDom((NL_CRITICAL, DomainInfo,
                             "NlBrowserSyncHostedDomains: hosted computer name missmatch: %ws %ws.\n",
                             Domains[i].EmulatedServerName,
                             DomainInfo->DomUnicodeComputerNameString.Buffer ));

                    // Tell the browser the name we have by deleting and re-adding
                    NlBrowserUpdate( DomainInfo, RoleInvalid );
                    NlBrowserUpdate( DomainInfo, DomainInfo->DomRole );
                }
                NlDereferenceDomain( DomainInfo );

            //
            // If we don't have the specified domain,
            //  delete it from the browser.
            //
            } else {
                NlPrint((NL_CRITICAL,"%ws: NlBrowserSyncHostedDomains: Browser had an hosted domain we didn't (deleting)\n",
                        Domains[i].DomainName ));

                //  ?? Don't call this function.  This function requires the browser be
                //  running.  Rather, invent an Ioctl to the bowser to enumerate domains
                //  and use that ioctl here.
                //

                NetStatus = I_BrowserSetNetlogonState(
                                NULL,
                                Domains[i].DomainName,
                                NULL,
                                0 );

                if ( NetStatus != NERR_Success ) {
                        NlPrint((NL_CRITICAL,"%ws: NlBrowserSyncHostedDomains: Couldn't I_BrowserSetNetlogonState %ld 0x%lx.\n",
                                Domains[i].DomainName,
                                NetStatus, NetStatus ));
                    // This isn't fatal
                }
            }
        }

        NetApiBufferFree( Domains );
    }
#endif // notdef


    //
    // Enumerate the transports supported by the server.
    //

    NetStatus = NetServerTransportEnum(
                    NULL,       // local
                    1,          // level 1
                    (LPBYTE *) &TransportInfo1,
                    0xFFFFFFFF, // PrefMaxLength
                    &EntriesRead,
                    &TotalEntries,
                    NULL );     // No resume handle

    if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {
        NlPrint(( NL_CRITICAL,
                  "NlBrowserSyncEnulatedDomains: Cannot NetServerTransportEnum %ld\n",
                  NetStatus ));


    //
    // Handle each enumerated transport.

    } else if ( EntriesRead != 0 ) {

        //
        // Weed out duplicates.
        //
        //  It'd be really inefficient to process duplicate entries.  Especially,
        //  in the cases where corrective action needed to be taken.
        //

        for ( i=0; i<EntriesRead; i++ ) {
            DWORD j;

            for ( j=i+1; j<EntriesRead; j++ ) {
                if ( TransportInfo1[i].svti1_domain != NULL &&
                     TransportInfo1[i].svti1_transportaddresslength ==
                     TransportInfo1[j].svti1_transportaddresslength &&
                     RtlEqualMemory( TransportInfo1[i].svti1_transportaddress,
                                       TransportInfo1[j].svti1_transportaddress,
                                       TransportInfo1[i].svti1_transportaddresslength ) &&
                    NlNameCompare( TransportInfo1[i].svti1_domain,
                                   TransportInfo1[j].svti1_domain,
                                   NAMETYPE_DOMAIN ) == 0 ) {
#ifdef notdef
                    NlPrint((NL_CRITICAL,
                             "%ws: NlBrowserSyncHostedDomains: Duplicate SMB server entry ignored.\n",
                             TransportInfo1[i].svti1_domain ));
#endif // notdef
                    TransportInfo1[j].svti1_domain = NULL;

                }
            }
        }

        //
        // Process each enumerated domain.
        //

        for ( i=0 ; i<EntriesRead; i++ ) {
            PDOMAIN_INFO DomainInfo;

            WCHAR UnicodeComputerName[CNLEN+1];
            ULONG UnicodeComputerNameSize;
            NTSTATUS TempStatus;

            //
            // ignore duplicates
            //

            if ( TransportInfo1[i].svti1_domain == NULL ) {
                continue;
            }

#ifdef notdef
            NlPrint((NL_CRITICAL,
                     "%ws: NlBrowserSyncHostedDomains: processing SMB entry.\n",
                     TransportInfo1[i].svti1_domain ));
#endif // notdef


            //
            // If we know the specified domain,
            //  all is well.
            //

            DomainInfo = NlFindNetbiosDomain( TransportInfo1[i].svti1_domain, FALSE );

            if ( DomainInfo != NULL ) {

                //
                // Ensure the Hosted server name is identical.
                //

                if ( TransportInfo1[i].svti1_transportaddresslength !=
                        DomainInfo->DomOemComputerNameLength ||
                     !RtlEqualMemory( TransportInfo1[i].svti1_transportaddress,
                                       DomainInfo->DomOemComputerName,
                                       DomainInfo->DomOemComputerNameLength ) ) {

                    TempStatus = RtlOemToUnicodeN(
                                      UnicodeComputerName,
                                      CNLEN*sizeof(WCHAR),
                                      &UnicodeComputerNameSize,
                                      TransportInfo1[i].svti1_transportaddress,
                                      TransportInfo1[i].svti1_transportaddresslength );

                    if ( NT_SUCCESS(TempStatus) ) {
                        UnicodeComputerName[UnicodeComputerNameSize/sizeof(WCHAR)] = L'\0';

                        NlPrintDom((NL_CRITICAL, DomainInfo,
                                 "NlBrowserSyncHostedDomains: hosted computer name mismatch (SMB server): %ws %ws.\n",
                                 UnicodeComputerName,
                                 DomainInfo->DomUnicodeComputerNameString.Buffer ));

                        //
                        // Tell the SMB server the name we have by deleting and re-adding
                        //

                        NetStatus = NetServerComputerNameDel(
                                        NULL,
                                        UnicodeComputerName );

                        if ( NetStatus != NERR_Success ) {
                            NlPrintDom((NL_CRITICAL, DomainInfo,
                                     "NlBrowserSyncHostedDomains: can't NetServerComputerNameDel: %ws.\n",
                                     UnicodeComputerName ));
                            // This isn't fatal
                        }

                        NetStatus = NlServerComputerNameAdd(
                                        DomainInfo->DomUnicodeDomainName,
                                        DomainInfo->DomUnicodeComputerNameString.Buffer );

                        if ( NetStatus != NERR_Success ) {
                            NlPrintDom((NL_CRITICAL, DomainInfo,
                                     "NlBrowserSyncHostedDomains: can't NetServerComputerNameAdd: %ws.\n",
                                     DomainInfo->DomUnicodeComputerNameString.Buffer ));
                            // This isn't fatal
                        }
                    }

                }
                NlDereferenceDomain( DomainInfo );


            //
            // If we don't have the specified domain,
            //  delete it from the SMB server.
            //
            } else {
                NlPrint((NL_CRITICAL,"%ws: NlBrowserSyncHostedDomains: SMB server had a hosted domain we didn't (deleting)\n",
                        TransportInfo1[i].svti1_domain ));

                TempStatus = RtlOemToUnicodeN(
                                  UnicodeComputerName,
                                  CNLEN*sizeof(WCHAR),
                                  &UnicodeComputerNameSize,
                                  TransportInfo1[i].svti1_transportaddress,
                                  TransportInfo1[i].svti1_transportaddresslength );

                if ( !NT_SUCCESS(TempStatus) ) {
                    NlPrint((NL_CRITICAL,
                             "%ws: NlBrowserSyncHostedDomains: can't RtlOemToUnicode: %lx.\n",
                             TransportInfo1[i].svti1_domain,
                             TempStatus ));
                    // This isn't fatal

                } else {
                    UnicodeComputerName[UnicodeComputerNameSize/sizeof(WCHAR)] = L'\0';

                    // When we really do hosted domains,
                    //  we have to work out a mechanism where the SMB server and
                    //  Netlogon has the same set of hosted domains.
                    //
                    // I ran into a case where netlogon had processed a rename
                    // of the domain and the SMB server hadn't.  In that case,
                    // the code below would delete the primary domain of the SMB
                    // server.
                    //

#ifdef notdef
                    NetStatus = NetServerComputerNameDel(
                                    NULL,
                                    UnicodeComputerName );

                    if ( NetStatus != NERR_Success ) {
                        NlPrint((NL_CRITICAL,
                                 "%ws: NlBrowserSyncHostedDomains: can't NetServerComputerNameDel: %ws.\n",
                                 TransportInfo1[i].svti1_domain,
                                 UnicodeComputerName ));
                        // This isn't fatal
                    }
#endif // notdef
                }

            }
        }


        (VOID) NetApiBufferFree( TransportInfo1 );
    }
    return;
}


VOID
NlBrowserUpdate(
    IN PDOMAIN_INFO DomainInfo,
    IN DWORD Role
    )
/*++

Routine Description:

    Tell the browser and SMB server about our new role.

Arguments:

    DomainInfo - Hosted domain the name is to be deleted for.

    Role - Our new Role.
        RoleInvalid implies the domain is being deleted.

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;

    DWORD BrowserRole;

    //
    // Initialization.
    //
    switch (Role) {
    case RolePrimary:
        BrowserRole = BROWSER_ROLE_PDC ; break;
    case RoleBackup:
        BrowserRole = BROWSER_ROLE_BDC ; break;
    default:
        // Default to telling the browser to delete the Hosted domain.
        BrowserRole = 0 ; break;
    }


    //
    // Tell the server what role to announce
    //

    if ( DomainInfo->DomFlags & DOM_PRIMARY_DOMAIN ) {
        BOOL Ok;

        //
        // Since the service controller doesn't have a mechanism to set some
        // bits and turn others off, turn all of the bits off then set the right
        // ones.
        //
        Ok = I_ScSetServiceBits( NlGlobalServiceHandle,
                                 SV_TYPE_DOMAIN_CTRL |
                                     SV_TYPE_DOMAIN_BAKCTRL, // Bits of interest
                                 FALSE,      // Set bits off
                                 FALSE,      // Don't force immediate announcement
                                 NULL);   // All transports
        if ( !Ok ) {

            NetStatus = GetLastError();

            NlPrint((NL_CRITICAL,"Couldn't I_ScSetServiceBits off %ld 0x%lx.\n",
                    NetStatus, NetStatus ));
            // This isn't fatal
        }

        //
        // For the primary domain,
        //  Tell the service controller and let it tell the server service after it
        //  merges the bits from the other services.
        //
        if ( BrowserRole != 0 ) {
            Ok = I_ScSetServiceBits( NlGlobalServiceHandle,
                                     NlServerType(Role),
                                     TRUE,      // Set bits on
                                     TRUE,      // Force immediate announcement
                                     NULL);   // All transports

        }

        if ( !Ok ) {

            NetStatus = GetLastError();

            NlPrint((NL_CRITICAL,"Couldn't I_ScSetServiceBits %ld 0x%lx.\n",
                    NetStatus, NetStatus ));
            // This isn't fatal
        }
    } else {

        //
        // For domains that aren't the primary domain,
        //  tell the Lanman server directly
        //  (since the service controller doesn't care about those doamins).
        //
        NetStatus = I_NetServerSetServiceBitsEx(
                                NULL,                       // Local server service
                                DomainInfo->DomUnicodeComputerNameString.Buffer,
                                NULL,                       // All transports
                                SV_TYPE_DOMAIN_CTRL |
                                    SV_TYPE_DOMAIN_BAKCTRL, // Bits of interest
                                NlServerType(Role),         // New Role
                                TRUE );                     // Update immediately

        if ( NetStatus != NERR_Success ) {

            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "NlBrowserUpdate: Couldn't I_NetServerSetServiceBitsEx %ld 0x%lx.\n",
                      NetStatus, NetStatus ));
            // This isn't fatal
        }
    }


#ifdef notdef
    //
    // Tell the browser our role has changed.
    //

    // Avoid deleting the primary domain
    if ( BrowserRole != 0 || !IsPrimaryDomain(DomainInfo) ) {
        //  ?? Don't call this function.  This function requires the browser be
        //  running.  Rather, invent an Ioctl to the bowser to enumerate domains
        //  and use that ioctl here.
        //
        // This function serves two purposes: Adding/deleting the hosted domain
        //  in the browser and setting the role.  The first might very well be
        //  a function of the bowser.  The later is naturally a function of
        // the browser service (but should be indirected through the bowser to
        // avoid domain rename issues).
        //
        // When we really do multiple hosted domains, create an emulated domain
        // via one IOCTL to the bowser.  Change it's role via another ioctl
        // to the bowser.  Both calls will result in notifications to the browser
        // service via normal PNP notifications.
        //
        // One might even think that the ioctl to change its role is the one
        // below that adds the 1B name.  That is, if the 1B name is added, then
        // this machine is the PDC.  If not, then it is not the PDC.
        //
        // In the mean time, hack the interface to the browser service indicating
        //  that it should NEVER create an emulated domain based on this call.
        //  Otherwise, on a domain rename, we may end up creating an emulated domain
        //  because our notification and the browser's are asynchronous.
        //
        // Actually, I've updated the bowser to do the 1B trick mentioned above.
        //  So this code merely has to do the right thing for the hosted domain.
        //

        NetStatus = I_BrowserSetNetlogonState(
                        NULL,
                        DomainInfo->DomUnicodeDomainName,
                        DomainInfo->DomUnicodeComputerNameString.Buffer,
                        BrowserRole | BROWSER_ROLE_AVOID_CREATING_DOMAIN );

        if ( NetStatus != NERR_Success ) {
            if ( BrowserRole != 0 || NetStatus != ERROR_NO_SUCH_DOMAIN ) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "NlBrowserUpdate: Couldn't I_BrowserSetNetlogonState %ld 0x%lx.\n",
                        NetStatus, NetStatus ));
            }
            // This isn't fatal
        }
    }
#endif // notdef

    //
    // Register or deregister the Domain<1B> name depending on the new role
    //

    if ( Role == RolePrimary ) {
        NlBrowserAddName( DomainInfo );
    } else {
        NlBrowserDelName( DomainInfo );
    }

    //
    // Tell the SMB server to delete a removed Hosted domain.
    //

    if ( Role == RoleInvalid && !IsPrimaryDomain(DomainInfo) ) {

        NetStatus = NetServerComputerNameDel(
                        NULL,
                        DomainInfo->DomUnicodeComputerNameString.Buffer );

        if ( NetStatus != NERR_Success ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                      "NlBrowserUpdate: Couldn't NetServerComputerNameDel %ld 0x%lx.\n",
                      NetStatus, NetStatus ));
            // This isn't fatal
        }
    }

    return;

}



BOOL
NlBrowserOpen(
    VOID
    )
/*++

Routine Description:

    This routine opens the NT LAN Man Datagram Receiver driver and prepares
    for reading mailslot messages from it.

Arguments:

    None.

Return Value:

    TRUE -- iff initialization is successful.

    if false, NlExit will already have been called.

--*/
{
    NTSTATUS Status;
    BOOL ReturnValue;

    BYTE Buffer[sizeof(LMDR_REQUEST_PACKET) +
                (max(CNLEN, DNLEN) + 1) * sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET) Buffer;


    //
    // Allocate the mailslot descriptor for this mailslot
    //

    NlGlobalMailslotDesc = NetpMemoryAllocate( sizeof(NETLOGON_MAILSLOT_DESC) );

    if ( NlGlobalMailslotDesc == NULL ) {
        NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL);
        return FALSE;
    }

    RtlZeroMemory( NlGlobalMailslotDesc, sizeof(NETLOGON_MAILSLOT_DESC) );

    NlGlobalMailslotDesc->CurrentMessage =
        ROUND_UP_POINTER( NlGlobalMailslotDesc->Message1, ALIGN_WORST);


    //
    // Open the browser device.
    //

    Status = NlBrowserOpenDriver( &NlGlobalMailslotDesc->BrowserHandle );

    if (! NT_SUCCESS(Status)) {
        NlPrint((NL_CRITICAL,
                 "NtOpenFile browser driver failed: 0x%lx\n",
                 Status));
        ReturnValue = FALSE;
        goto Cleanup;
    }


    //
    // Create a completion event
    //

    NlGlobalMailslotHandle =
        NlGlobalMailslotDesc->BrowserReadEvent = NlBrowserCreateEvent();

    if ( NlGlobalMailslotDesc->BrowserReadEvent == NULL ) {
        Status = NetpApiStatusToNtStatus( GetLastError() );
        ReturnValue = FALSE;
        goto Cleanup;
    }


    //
    // Set the maximum number of messages to be queued
    //

    RequestPacket->TransportName.Length = 0;
    RequestPacket->TransportName.Buffer = NULL;
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, NULL );
    RequestPacket->Parameters.NetlogonMailslotEnable.MaxMessageCount =
        NlGlobalMemberWorkstation ?
            1 :
            NlGlobalParameters.MaximumMailslotMessages;

    Status = NlBrowserDeviceIoControl(
                   NlGlobalMailslotDesc->BrowserHandle,
                   IOCTL_LMDR_NETLOGON_MAILSLOT_ENABLE,
                   RequestPacket,
                   sizeof(LMDR_REQUEST_PACKET),
                   NULL,
                   0 );

    if (! NT_SUCCESS(Status)) {
        NlPrint((NL_CRITICAL,"Can't set browser max message count: 0x%lx\n",
                         Status));
        ReturnValue = FALSE;
        goto Cleanup;
    }


    ReturnValue = TRUE;

Cleanup:
    if ( !ReturnValue ) {
        NET_API_STATUS NetStatus = NetpNtStatusToApiStatus(Status);

        NlExit( NELOG_NetlogonBrowserDriver, NetStatus, LogErrorAndNtStatus, NULL);
        NlBrowserClose();
    }

    return ReturnValue;
}


VOID
NlBrowserClose(
    VOID
    )
/*++

Routine Description:

    This routine cleans up after a NlBrowserInitialize()

Arguments:

    None.

Return Value:

    None.

--*/
{
    IO_STATUS_BLOCK IoSb;
    NTSTATUS Status;

    BYTE Buffer[sizeof(LMDR_REQUEST_PACKET) +
                (max(CNLEN, DNLEN) + 1) * sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET) Buffer;

    if ( NlGlobalMailslotDesc == NULL) {
        return;
    }


    //
    //  If we've opened the browser, clean up.
    //

    if ( NlGlobalMailslotDesc->BrowserHandle != NULL ) {

        //
        // Tell the browser to stop queueing messages
        //

        RequestPacket->TransportName.Length = 0;
        RequestPacket->TransportName.Buffer = NULL;
        RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, NULL );
        RequestPacket->Parameters.NetlogonMailslotEnable.MaxMessageCount = 0;

        Status = NlBrowserDeviceIoControl(
                       NlGlobalMailslotDesc->BrowserHandle,
                       IOCTL_LMDR_NETLOGON_MAILSLOT_ENABLE,
                       RequestPacket,
                       sizeof(LMDR_REQUEST_PACKET),
                       NULL,
                       0 );

        if (! NT_SUCCESS(Status)) {
            NlPrint((NL_CRITICAL,"Can't reset browser max message count: 0x%lx\n",
                             Status));
        }


        //
        //  Cancel the I/O operations outstanding on the browser.
        //

        NtCancelIoFile(NlGlobalMailslotDesc->BrowserHandle, &IoSb);

        //
        // Close the handle to the browser
        //

        NtClose(NlGlobalMailslotDesc->BrowserHandle);
        NlGlobalMailslotDesc->BrowserHandle = NULL;
    }

    //
    // Close the global browser read event
    //

    if ( NlGlobalMailslotDesc->BrowserReadEvent != NULL ) {
        NlBrowserCloseEvent(NlGlobalMailslotDesc->BrowserReadEvent);
    }
    NlGlobalMailslotHandle = NULL;

    //
    // Free the descriptor describing the browser
    //

    NetpMemoryFree( NlGlobalMailslotDesc );
    NlGlobalMailslotDesc = NULL;

}

NTSTATUS
NlpWriteMailslot(
    IN LPWSTR MailslotName,
    IN LPVOID Buffer,
    IN DWORD BufferSize
    )

/*++

Routine Description:

    Write a message to a named mailslot

Arguments:

    MailslotName - Unicode name of the mailslot to write to.

    Buffer - Data to write to the mailslot.

    BufferSize - Number of bytes to write to the mailslot.

Return Value:

    NT status code for the operation

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    //
    //  Write the mailslot message.
    //

    NetStatus = NetpLogonWriteMailslot( MailslotName, Buffer, BufferSize );
    if ( NetStatus != NERR_Success ) {
        Status = NetpApiStatusToNtStatus( NetStatus );
        NlPrint((NL_CRITICAL, "NetpLogonWriteMailslot failed %lx\n", Status));
        return Status;
    }

#if NETLOGONDBG
    NlPrint(( NL_MAILSLOT,
              "Sent '%s' message to %ws on all transports.\n",
              NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)Buffer)->Opcode),
              MailslotName));

    NlpDumpBuffer( NL_MAILSLOT_TEXT, Buffer, BufferSize );
#endif // NETLOGONDBG

    return STATUS_SUCCESS;
}

NTSTATUS
NlFlushNetbiosCacheName(
    IN LPCWSTR NetbiosDomainName,
    IN CHAR Extention,
    IN PNL_TRANSPORT Transport
    )
/*++

Routine Description:

    This routine flushes the specified name from the Netbios
    remote cache table.

Arguments:

    NetbiosDomainName - The name to be flushed.

    Extention - the type of the name (extention added as the
        16th character of the name to flush): 0x00, 0x1C, 0x1B, etc.

    Transport - The transport (device) on which the name is to
        be flushed.

Return Value:

    STATUS_SUCCESS: The name has been successfully flushed

    STATUS_RESOURCE_NAME_NOT_FOUND: The name was not found in the cache

    Otherwise, an error returned by NtCreateFile or NtDeviceIoControlFile

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    CHAR            NameToBeFlushed[NETBIOS_NAMESIZE];

    //
    // First open the Netbios device if it hasn't been done already
    //

    EnterCriticalSection( &NlGlobalTransportCritSect );
    if ( Transport->DeviceHandle == INVALID_HANDLE_VALUE ) {
        OBJECT_ATTRIBUTES Attributes;
        UNICODE_STRING UnicodeString;
        HANDLE LocalHandle;

        RtlInitUnicodeString( &UnicodeString, Transport->TransportName );

        InitializeObjectAttributes( &Attributes,
                                    &UnicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );

        NtStatus = NtCreateFile( &LocalHandle,
                                 MAXIMUM_ALLOWED,
                                 &Attributes,
                                 &IoStatusBlock,
                                 NULL,            // allocation size
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN_IF,
                                 0,
                                 NULL,            // no EAs
                                 0 );

        if( !NT_SUCCESS(NtStatus) ) {
            LeaveCriticalSection( &NlGlobalTransportCritSect );
            NlPrint(( NL_CRITICAL, "NlFlushNetbiosCacheName: NtCreateFile failed 0x%lx\n",
                      NtStatus ));
            return NtStatus;
        }

        Transport->DeviceHandle = LocalHandle;
    }
    LeaveCriticalSection( &NlGlobalTransportCritSect );

    //
    // Now form the name to flush
    //
    // Convert to upper case, blank pad to the right
    // and put the appropriate Extension at the end
    //

    RtlFillMemory( &NameToBeFlushed, NETBIOS_NAMESIZE, ' ' );

    NtStatus = RtlUpcaseUnicodeToOemN( NameToBeFlushed,
                                       NETBIOS_NAMESIZE - 1,  // Maximum for resulting string size
                                       NULL,         // Don't care about the resulting string size
                                       (LPWSTR)NetbiosDomainName,
                                       wcslen(NetbiosDomainName)*sizeof(WCHAR) );

    if ( !NT_SUCCESS(NtStatus) ) {
        NlPrint(( NL_CRITICAL, "NlFlushNetbiosCacheName: RtlUpcaseUnicodeToOemN failed 0x%lx\n",
                  NtStatus ));
        return NtStatus;
    }

    //
    // Set the appropriate extention
    //

    NameToBeFlushed[NETBIOS_NAMESIZE-1] = Extention;

    //
    // Finally flush the name from the cache
    //

    NtStatus = NtDeviceIoControlFile(
                      Transport->DeviceHandle, // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &IoStatusBlock,          // IoStatusBlock
                      IOCTL_NETBT_REMOVE_FROM_REMOTE_TABLE,  // IoControlCode
                      NameToBeFlushed,         // InputBuffer
                      sizeof(NameToBeFlushed), // InputBufferSize
                      NULL,                    // OutputBuffer
                      0 );                     // OutputBufferSize

    //
    // STATUS_RESOURCE_NAME_NOT_FOUND just means that the name was not in the cache
    //

    if ( !NT_SUCCESS(NtStatus) && NtStatus != STATUS_RESOURCE_NAME_NOT_FOUND ) {
        NlPrint(( NL_CRITICAL, "NlFlushNetbiosCacheName: NtDeviceIoControlFile failed 0x%lx\n",
                  NtStatus ));
    }

    return NtStatus;
}


NTSTATUS
NlBrowserSendDatagram(
    IN PVOID ContextDomainInfo,
    IN ULONG IpAddress,
    IN LPWSTR UnicodeDestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR TransportName,
    IN LPSTR OemMailslotName,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOL SendSynchronously,
    IN OUT PBOOL FlushNameOnOneIpTransport OPTIONAL
    )
/*++

Routine Description:

    Send the specified mailslot message to the specified mailslot on the
    specified server on the specified transport..

Arguments:

    DomainInfo - Hosted domain sending the datagram

    IpAddress - IpAddress of the machine to send the message to.
        If zero, UnicodeDestinationName must be specified.
        If ALL_IP_TRANSPORTS, UnicodeDestination must be specified but the datagram
            will only be sent on IP transports.

    UnicodeDestinationName -- Name of the server to send to.

    NameType -- Type of name represented by UnicodeDestinationName.

    TransportName -- Name of the transport to send on.
        Use NULL to send on all transports.

    OemMailslotName -- Name of the mailslot to send to.

    Buffer -- Specifies a pointer to the mailslot message to send.

    BufferSize -- Size in bytes of the mailslot message

    SendSynchronously -- If TRUE, the send will happen syncronously (i.e. the
        send will not return until the network I/O completes). Otherwise, the
        send will happen asynchronously (i.e. it will be queued for processing).

    FlushNameOnOneIpTransport -- Used only if we send on all transports (i.e.
        TransportName is NULL), otherwise ignored.  If TRUE, the name specified
        by UnicodeDestinationName will be flushed on one of the available IP
        enabled transports prior to sending the datagram. On return, set to
        FALSE if the name has been successfully flushed or the name was not
        found in the cache.

Return Value:

    Status of the operation.

    STATUS_NETWORK_UNREACHABLE: Cannot write to network.

--*/
{
    PLMDR_REQUEST_PACKET RequestPacket = NULL;
    PDOMAIN_INFO DomainInfo = (PDOMAIN_INFO) ContextDomainInfo;

    DWORD OemMailslotNameSize;
    DWORD TransportNameSize;
    DWORD DestinationNameSize;

    NTSTATUS Status;
    LPBYTE Where;

    //
    // If the transport isn't specified,
    //  send on all transports.
    //

    if ( TransportName == NULL ) {
        ULONG i;
        PLIST_ENTRY ListEntry;
        NTSTATUS SavedStatus = STATUS_NETWORK_UNREACHABLE;
        ULONG TransportCount = 0;
        ULONG BadNetPathCount = 0;

        //
        // Send on all transports.
        //

        EnterCriticalSection( &NlGlobalTransportCritSect );
        for ( ListEntry = NlGlobalTransportList.Flink ;
              ListEntry != &NlGlobalTransportList ;
              ListEntry = ListEntry->Flink) {

            PNL_TRANSPORT TransportEntry;

            TransportEntry = CONTAINING_RECORD( ListEntry, NL_TRANSPORT, Next );

            //
            // Skip deleted transports.
            //
            if ( !TransportEntry->TransportEnabled ) {
                continue;
            }

            //
            // Skip direct host IPX transport unless sending to a particular
            // machine.
            //

            if ( TransportEntry->DirectHostIpx &&
                 NameType != ComputerName ) {
                continue;
            }

            //
            // Skip non-IP transports if sending to an IP address.
            //

            if ( IpAddress != 0  &&
                 TransportEntry->IpAddress == 0 ) {
                continue;
            }

            //
            // Leave the critical section before sending the datagram
            // because NetBt now doesn't return from the datagram send
            // until after the name lookup completes.  So, it can take
            // a considerable amount of time for the datagram send to
            // return to us.
            //

            LeaveCriticalSection( &NlGlobalTransportCritSect );

            //
            // If this is IP transport, flush the name if requested
            //

            if ( FlushNameOnOneIpTransport != NULL &&
                 *FlushNameOnOneIpTransport &&
                 TransportEntry->IsIpTransport ) {

                NTSTATUS TmpStatus;
                CHAR Extention;

                if ( NameType == ComputerName ) {
                    Extention = 0x00;
                } else if ( NameType == DomainName ) {
                    Extention = 0x1C;
                } else if ( NameType == PrimaryDomainBrowser ) {
                    Extention = 0x1B;
                } else {
                    NlAssert( !"[NETLOGON] Unexpected name type passed to NlBrowserSendDatagram" );
                }

                TmpStatus = NlFlushNetbiosCacheName( UnicodeDestinationName,
                                                     Extention,
                                                     TransportEntry );

                //
                // If we successfully flushed the name or the name is not in the cache,
                //  indicate that the name has been flushed
                //
                if ( NT_SUCCESS(TmpStatus) || TmpStatus == STATUS_RESOURCE_NAME_NOT_FOUND ) {
                    *FlushNameOnOneIpTransport = FALSE;
                }
            }

            Status = NlBrowserSendDatagram(
                              DomainInfo,
                              IpAddress,
                              UnicodeDestinationName,
                              NameType,
                              TransportEntry->TransportName,
                              OemMailslotName,
                              Buffer,
                              BufferSize,
                              SendSynchronously,
                              FlushNameOnOneIpTransport );

            EnterCriticalSection( &NlGlobalTransportCritSect );

            //
            // Since a TransportEntry is never removed from the global
            // transport list (it can only become marked as disabled
            // during the time when we had the crit sect released),
            // we should be able to follow its link to the next entry in
            // the global list on the next iteration of the loop.  The
            // only problem can occur when the service was said to terminate
            // and NlTransportClose was called to free up the global list.
            // In this case NlGlobalTerminate is set to TRUE so we can
            // successfully return from this routine.
            //

            if ( NlGlobalTerminate ) {
                LeaveCriticalSection( &NlGlobalTransportCritSect );
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }

            TransportCount ++;
            if ( NT_SUCCESS(Status) ) {
                // If any transport works, we've been successful
                SavedStatus = STATUS_SUCCESS;
            } else if ( Status == STATUS_BAD_NETWORK_PATH ) {
                // Count the number of transports that couldn't resolve the name
                BadNetPathCount ++;
            } else {
                // Remember the real reason for the failure instead of the default failure status
                // Remember only the first failure.
                if ( SavedStatus == STATUS_NETWORK_UNREACHABLE ) {
                    SavedStatus = Status;
                }
            }

        }
        LeaveCriticalSection( &NlGlobalTransportCritSect );

        //
        // If we're returning the default status,
        //  and at least one transport couldn't resolved the name,
        //  and all transports couldn't resolve the name,
        //  tell the caller we couldn't resolve the name.
        //

        if (  SavedStatus == STATUS_NETWORK_UNREACHABLE &&
              BadNetPathCount > 0 &&
              TransportCount == BadNetPathCount ) {
            SavedStatus = STATUS_BAD_NETWORK_PATH;
        }

        //
        // If we have no transports available,
        //  tell the caller we couldn't resolve the name
        //

        if ( TransportCount == 0 ) {
            NlPrint(( NL_CRITICAL, "NlBrowserSendDatagram: No transports available\n" ));
            SavedStatus = STATUS_BAD_NETWORK_PATH;
        }

        return SavedStatus;
    }

    //
    // Allocate a request packet.
    //

    OemMailslotNameSize = strlen(OemMailslotName) + 1;
    TransportNameSize = (wcslen(TransportName) + 1) * sizeof(WCHAR);

    if ( UnicodeDestinationName == NULL ) {
        return STATUS_INTERNAL_ERROR;
    }

    DestinationNameSize = wcslen(UnicodeDestinationName) * sizeof(WCHAR);

    RequestPacket = NetpMemoryAllocate(
                                  sizeof(LMDR_REQUEST_PACKET) +
                                  TransportNameSize +
                                  OemMailslotNameSize +
                                  DestinationNameSize + sizeof(WCHAR) +
                                  DomainInfo->DomUnicodeDomainNameString.Length + sizeof(WCHAR) +
                                  sizeof(WCHAR)) ; // For alignment

    if (RequestPacket == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }



    //
    // Fill in the Request Packet.
    //

    RequestPacket->Type = Datagram;
    RequestPacket->Parameters.SendDatagram.DestinationNameType = NameType;


    //
    // Fill in the name of the machine to send the mailslot message to.
    //

    RequestPacket->Parameters.SendDatagram.NameLength = DestinationNameSize;

    Where = (LPBYTE) RequestPacket->Parameters.SendDatagram.Name;
    RtlCopyMemory( Where, UnicodeDestinationName, DestinationNameSize );
    Where += DestinationNameSize;


    //
    // Fill in the name of the mailslot to send to.
    //

    RequestPacket->Parameters.SendDatagram.MailslotNameLength =
        OemMailslotNameSize;
    strcpy( Where, OemMailslotName);
    Where += OemMailslotNameSize;
    Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );


    //
    // Fill in the TransportName
    //

    wcscpy( (LPWSTR) Where, TransportName);
    RtlInitUnicodeString( &RequestPacket->TransportName, (LPWSTR) Where );
    Where += TransportNameSize;


    //
    // Copy the hosted domain name to the request packet.
    //
    wcscpy( (LPWSTR)Where,
            DomainInfo->DomUnicodeDomainNameString.Buffer );
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName,
                          (LPWSTR)Where );
    Where += DomainInfo->DomUnicodeDomainNameString.Length + sizeof(WCHAR);



    //
    // Send the request to the browser.
    //


    Status = NlBrowserDeviceIoControl(
                   NlGlobalMailslotDesc->BrowserHandle,
                   SendSynchronously ?
                     IOCTL_LMDR_WRITE_MAILSLOT :
                     IOCTL_LMDR_WRITE_MAILSLOT_ASYNC,
                   RequestPacket,
                   (ULONG)(Where - (LPBYTE)RequestPacket),
                   Buffer,
                   BufferSize );


    //
    // Free locally used resources.
    //
Cleanup:

    if ( RequestPacket != NULL ) {
        NetpMemoryFree( RequestPacket );
    }


    NlpDumpBuffer( NL_MAILSLOT_TEXT, Buffer, BufferSize );

    // NlPrint(( NL_MAILSLOT, "Transport %ws 0x%lx\n", TransportName, Status ));

    return Status;
}


NTSTATUS
NlBrowserSendDatagramA(
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG IpAddress,
    IN LPSTR OemServerName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR TransportName,
    IN LPSTR OemMailslotName,
    IN PVOID Buffer,
    IN ULONG BufferSize
    )
/*++

Routine Description:

    Send asynchronously the specified mailslot message to the specified
    mailslot on the specified server on the specified transport.

Arguments:

    DomainInfo - Hosted domain sending the datagram

    IpAddress - IpAddress of the machine to send the message to.
        If zero, OemServerName must be specified.

    OemServerName -- Name of the server to send to.

    NameType -- Type of name represented by OemServerName.

    TransportName -- Name of the transport to send on.
        Use NULL to send on all transports.

    OemMailslotName -- Name of the mailslot to send to.

    Buffer -- Specifies a pointer to the mailslot message to send.

    BufferSize -- Size in bytes of the mailslot message

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    WCHAR UnicodeDestinationName[CNLEN+1];


    //
    // Convert DestinationName to unicode
    //

    NetStatus = NetpNCopyStrToWStr(
                    UnicodeDestinationName,
                    OemServerName,
                    CNLEN );

    if ( NetStatus != NERR_Success ) {
        return NetpApiStatusToNtStatus( NetStatus );
    }

    UnicodeDestinationName[CNLEN] = L'\0';

    //
    // Pass the request to the function taking unicode destination name.
    //

    return NlBrowserSendDatagram(
                    DomainInfo,
                    IpAddress,
                    UnicodeDestinationName,
                    NameType,
                    TransportName,
                    OemMailslotName,
                    Buffer,
                    BufferSize,
                    FALSE,   // send synchronously ?
                    NULL );  // Don't flush Netbios cache

}




VOID
NlMailslotPostRead(
    IN BOOLEAN IgnoreDuplicatesOfPreviousMessage
    )

/*++

Routine Description:

    Post a read on the mailslot if one isn't already posted.

Arguments:

    IgnoreDuplicatesOfPreviousMessage - TRUE to indicate that the next
        message read should be ignored if it is a duplicate of the previous
        message.

Return Value:

    TRUE -- iff successful.

--*/
{
    NET_API_STATUS WinStatus;
    ULONG LocalBytesRead;

    //
    // If a read is already pending,
    //  immediately return to caller.
    //

    if ( NlGlobalMailslotDesc->ReadPending ) {
        return;
    }

    //
    // Decide which buffer to read into.
    //
    // Switch back and forth so we always have the current buffer and the
    // previous buffer.
    //

    if ( IgnoreDuplicatesOfPreviousMessage ) {
        NlGlobalMailslotDesc->PreviousMessage = NlGlobalMailslotDesc->CurrentMessage;
        if ( NlGlobalMailslotDesc->CurrentMessage >= NlGlobalMailslotDesc->Message2 ) {
            NlGlobalMailslotDesc->CurrentMessage =
                ROUND_UP_POINTER( NlGlobalMailslotDesc->Message1, ALIGN_WORST);
        } else {
            NlGlobalMailslotDesc->CurrentMessage =
                ROUND_UP_POINTER( NlGlobalMailslotDesc->Message2, ALIGN_WORST);
        }

    //
    // If duplicates of the previous message need not be ignored,
    //  indicate so.
    //  Don't bother switching the buffer pointers.
    //

    } else {
        NlGlobalMailslotDesc->PreviousMessage = NULL;
    }


    //
    // Post an overlapped read to the mailslot.
    //

    RtlZeroMemory( &NlGlobalMailslotDesc->Overlapped,
                   sizeof(NlGlobalMailslotDesc->Overlapped) );

    NlGlobalMailslotDesc->Overlapped.hEvent = NlGlobalMailslotDesc->BrowserReadEvent;

    if ( !DeviceIoControl(
                   NlGlobalMailslotDesc->BrowserHandle,
                   IOCTL_LMDR_NETLOGON_MAILSLOT_READ,
                   NULL,
                   0,
                   NlGlobalMailslotDesc->CurrentMessage,
                   MAILSLOT_MESSAGE_SIZE,
                   &LocalBytesRead,
                   &NlGlobalMailslotDesc->Overlapped )) {

        WinStatus = GetLastError();

        //
        // On error, wait a second before returning.  This ensures we don't
        //  consume the system in an infinite loop.  We don't shutdown netlogon
        //  because the error might be a temporary low memory condition.
        //

        if(  WinStatus != ERROR_IO_PENDING ) {
            LPWSTR MsgStrings[1];

            NlPrint((NL_CRITICAL,
                    "Error in reading mailslot message from browser"
                    ". WinStatus = %ld\n",
                    WinStatus ));

            MsgStrings[0] = (LPWSTR) ULongToPtr( WinStatus );

            NlpWriteEventlog( NELOG_NetlogonFailedToReadMailslot,
                              EVENTLOG_WARNING_TYPE,
                              (LPBYTE)&WinStatus,
                              sizeof(WinStatus),
                              MsgStrings,
                              1 | NETP_LAST_MESSAGE_IS_NETSTATUS );

            Sleep( 1000 );

        } else {
            NlGlobalMailslotDesc->ReadPending = TRUE;
        }

    } else {
        NlGlobalMailslotDesc->ReadPending = TRUE;
    }

    return;

}


BOOL
NlMailslotOverlappedResult(
    OUT LPBYTE *Message,
    OUT PULONG BytesRead,
    OUT LPWSTR *TransportName,
    OUT PNL_TRANSPORT *Transport,
    OUT PSOCKADDR *ClientSockAddr,
    OUT LPWSTR *DestinationName,
    OUT PBOOLEAN IgnoreDuplicatesOfPreviousMessage,
    OUT PNETLOGON_PNP_OPCODE NlPnpOpcode
    )

/*++

Routine Description:

    Get the overlapped result of a previous mailslot read.

Arguments:

    Message - Returns a pointer to the buffer containing the message

    BytesRead - Returns the number of bytes read into the buffer

    TransportName - Returns a pointer to the name of the transport the message
        was received on.

    Transport - Returns a pointer to the Transport structure if this is a
        mailslot message.

    ClientSockAddr - Returns a pointer to the SockAddr of the client that
        sent the message.
        Returns NULL if transport isn't running IP.

    DestinationName - Returns a pointer to the name of the server or domain
        the message was sent to.

    IgnoreDuplicatesOfPreviousMessage - Indicates that duplicates of the
        previous message are to be ignored.

    NpPnpOpcode - Returns the PNP opcode if this is a PNP operation.
        Returns NlPnpMailslotMessage if this is a mailslot message.

Return Value:

    TRUE -- iff successful.

--*/
{
    NET_API_STATUS WinStatus;
    ULONG LocalBytesRead;
    PNETLOGON_MAILSLOT NetlogonMailslot;

    //
    // Default to not ignoring duplicate messages.
    //  (Only ignore duplicates if a message has been properly processed.)

    *IgnoreDuplicatesOfPreviousMessage = FALSE;

    //
    // By default, assume a mailslot message is available.
    *NlPnpOpcode = NlPnpMailslotMessage;

    //
    // Always post another read regardless of the success or failure of
    //  GetOverlappedResult.
    // We don't know the failure mode of GetOverlappedResult, so we don't
    // know in the failure case if we're discarding a mailslot message.
    // But we do know that there is no read pending, so make sure we
    // issue another one.
    //

    NlGlobalMailslotDesc->ReadPending = FALSE; // no read pending anymore


    //
    // Get the result of the last read
    //

    if( !GetOverlappedResult( NlGlobalMailslotDesc->BrowserHandle,
                              &NlGlobalMailslotDesc->Overlapped,
                              &LocalBytesRead,
                              TRUE) ) {    // wait for the read to complete.

        LPWSTR MsgStrings[1];

        // On error, wait a second before returning.  This ensures we don't
        //  consume the system in an infinite loop.  We don't shutdown netlogon
        //  because the error might be a temporary low memory condition.
        //

        WinStatus = GetLastError();

        NlPrint((NL_CRITICAL,
                "Error in GetOverlappedResult on mailslot read"
                ". WinStatus = %ld\n",
                WinStatus ));

        MsgStrings[0] = (LPWSTR) ULongToPtr( WinStatus );

        NlpWriteEventlog( NELOG_NetlogonFailedToReadMailslot,
                          EVENTLOG_WARNING_TYPE,
                          (LPBYTE)&WinStatus,
                          sizeof(WinStatus),
                          MsgStrings,
                          1 | NETP_LAST_MESSAGE_IS_NETSTATUS );

        Sleep( 1000 );

        return FALSE;

    }

    //
    // On success,
    //  Return the mailslot message to the caller.


    NetlogonMailslot = (PNETLOGON_MAILSLOT) NlGlobalMailslotDesc->CurrentMessage;


    //
    // Return pointers into the buffer returned by the browser
    //

    *Message = &NlGlobalMailslotDesc->CurrentMessage[
                    NetlogonMailslot->MailslotMessageOffset];
    *TransportName = (LPWSTR) &NlGlobalMailslotDesc->CurrentMessage[
                    NetlogonMailslot->TransportNameOffset];
    if ( NetlogonMailslot->ClientSockAddrSize == 0 ) {
        *ClientSockAddr = NULL;
    } else {
        *ClientSockAddr = (PSOCKADDR) &NlGlobalMailslotDesc->CurrentMessage[
                        NetlogonMailslot->ClientSockAddrOffset];
    }

    //
    // If this is a PNP notification,
    //  simply return the opcode and the transport name.
    //

    if ( NetlogonMailslot->MailslotNameSize == 0 ) {
        *NlPnpOpcode = NetlogonMailslot->MailslotNameOffset;
        *Message = NULL;
        *BytesRead = 0;
        *DestinationName = NULL;
        *Transport = NULL;

        NlPrint(( NL_MAILSLOT_TEXT,
                  "Received PNP opcode 0x%x on transport: %ws\n",
                  *NlPnpOpcode,
                  *TransportName ));

    //
    // If this is a mailslot message,
    //  return the message to the caller.
    //

    } else {

        *BytesRead = NetlogonMailslot->MailslotMessageSize;
        *DestinationName = (LPWSTR) &NlGlobalMailslotDesc->CurrentMessage[
                        NetlogonMailslot->DestinationNameOffset];

        //
        // Determine the transport the request came in on.
        //

        *Transport = NlTransportLookupTransportName( *TransportName );

        if ( *Transport == NULL ) {
            NlPrint((NL_CRITICAL,
                    "%ws: Received message for this unsupported transport\n",
                    *TransportName ));
            return FALSE;
        }

        //
        // Determine if we can discard an ancient or duplicate message
        //
        // Only discard messages that are either expensive to process on this
        // machine or generate excessive traffic to respond to.  Don't discard
        // messages that we've worked hard to get (e.g., discovery responses).
        //

        switch ( ((PNETLOGON_LOGON_QUERY)*Message)->Opcode) {
        case LOGON_REQUEST:
        case LOGON_SAM_LOGON_REQUEST:
        case LOGON_PRIMARY_QUERY:

            //
            // If the message is too old,
            //  discard it.
            //

            if ( NlTimeHasElapsedEx( &NetlogonMailslot->TimeReceived,
                                     &NlGlobalParameters.MailslotMessageTimeout_100ns,
                                     NULL )) {

#if NETLOGONDBG
                NlPrint(( NL_MAILSLOT,
                          "%ws: Received '%s' message on %ws:"
                                " (Discarded as too old.)\n",
                          *DestinationName,
                          NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)*Message)->Opcode),
                          *TransportName ));
#endif // NETLOGONDBG
                return FALSE;
            }

            //
            // If the previous message was recent,
            //  and this message is identical to it,
            //  discard the current message.
            //

#ifdef notdef
            NlPrint(( NL_MAILSLOT, "%ws: test prev\n", *DestinationName ));
#endif // notdef

            if ( NlGlobalMailslotDesc->PreviousMessage != NULL ) {
                PNETLOGON_MAILSLOT PreviousNetlogonMailslot;

                PreviousNetlogonMailslot = (PNETLOGON_MAILSLOT)
                    NlGlobalMailslotDesc->PreviousMessage;

#ifdef notdef
                NlPrint(( NL_MAILSLOT, "%ws: test time\n", *DestinationName ));
#endif // notdef

                // ??: Compare source netbios name?
                if ( (PreviousNetlogonMailslot->TimeReceived.QuadPart +
                     NlGlobalParameters.MailslotDuplicateTimeout_100ns.QuadPart >
                     NetlogonMailslot->TimeReceived.QuadPart) ) {

#ifdef notdef
                    NlPrint(( NL_MAILSLOT, "%ws: test message\n", *DestinationName ));
#endif // notdef

                    if ( (PreviousNetlogonMailslot->MailslotMessageSize ==
                         NetlogonMailslot->MailslotMessageSize) &&

                         RtlEqualMemory(
                            &NlGlobalMailslotDesc->CurrentMessage[
                                NetlogonMailslot->MailslotMessageOffset],
                            &NlGlobalMailslotDesc->PreviousMessage[
                                PreviousNetlogonMailslot->MailslotMessageOffset],
                            NetlogonMailslot->MailslotMessageSize ) ) {


                        //
                        // Ensure the next comparison is to the timestamp of the
                        // message we actually responded to.
                        //

                        NetlogonMailslot->TimeReceived =
                            PreviousNetlogonMailslot->TimeReceived;


                        NlPrint(( NL_MAILSLOT,
                                  "%ws: Received '%s' message on %ws:"
                                        " (Discarded as duplicate of previous.)\n",
                                  *DestinationName,
                                  NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)*Message)->Opcode),
                                  *TransportName ));

                        *IgnoreDuplicatesOfPreviousMessage = TRUE;
                        return FALSE;

                    }
                }
            }

            //
            // If this isn't an IP transport,
            //  and if the caller explicitly wanted one,
            //  discard the message.
            //
            // NT 5 only sends the query on IP when netlogon is running.
            // When Netlogon isn't running, the query is sent on all transports
            //  bound to the redir.  Since this DC ignores duplicate messages,
            //  we want to avoid responding to the non-IP requests or we'll
            //  ignore the IP query as being a duplicate of this one.
            //
            // WIN 98 with the Active Directory service pack also sets this bit
            // and sends on all transports.
            //

            if ( !(*Transport)->IsIpTransport ) {
                DWORD Version;
                DWORD VersionFlags;
                DWORD LocalBytesRead;

                LocalBytesRead = *BytesRead;

                Version = NetpLogonGetMessageVersion( *Message,
                                                      &LocalBytesRead,
                                                      &VersionFlags );

                if ( VersionFlags & NETLOGON_NT_VERSION_IP ) {

                    NlPrint(( NL_MAILSLOT,
                              "%ws: Received '%s' message on %ws:"
                                    " (Caller wants response on IP transport.)\n",
                              *DestinationName,
                              NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)*Message)->Opcode),
                              *TransportName ));

                    return FALSE;
                }
            }
        }

        NlPrint(( NL_MAILSLOT,
                  "%ws: Received '%s' message on %ws\n",
                  *DestinationName,
                  NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)*Message)->Opcode),
                  *TransportName ));

        NlpDumpBuffer(NL_MAILSLOT_TEXT, *Message, *BytesRead);
    }

    return TRUE;

}

NET_API_STATUS
NlServerComputerNameAdd(
    IN LPWSTR HostedDomainName,
    IN LPWSTR HostedServerName
)
/*++

Routine Description:

    This routine causes the SMB server to respond to requests on HostedServerName
    and to announce this servername as being a member of HostedDomainName.

    This code was stolen from NetServerComputerNameAdd.  It is different from that
    API in the following ways:

    1) It only works locally.
    2) HostedDomainName is not optional.
    3) Failure to add the name on any transport fails the routine

Arguments:

    HostedServerName --A pointer to the ASCIIZ string containing the
        name which the server should stop supporting

    HostedDomainName --A pointer to the ASCIIZ string containing the
        domain name the server should use when announcing the presence of
        'HostedServerName'

Return Value:

    NERR_Success, or reason for failure

--*/
{
    DWORD resumehandle = 0;
    NET_API_STATUS retval;
    DWORD entriesread, totalentries;
    DWORD i, j;
    UCHAR NetBiosName[ MAX_PATH ];
    OEM_STRING NetBiosNameString;
    UNICODE_STRING UniName;
    PSERVER_TRANSPORT_INFO_1 psti1;

    //
    // Ensure a valid HostedServerName was passed in
    //
    if( HostedServerName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the HostedServerName to an OEM string
    //
    RtlInitUnicodeString( &UniName, HostedServerName );
    NetBiosNameString.Buffer = (PCHAR)NetBiosName;
    NetBiosNameString.MaximumLength = sizeof( NetBiosName );
    (VOID) RtlUpcaseUnicodeStringToOemString(
                                &NetBiosNameString,
                                &UniName,
                                FALSE
                                );


    //
    // Enumerate all the transports so we can add the name and domain
    //  to each one.
    //
    retval = NetServerTransportEnum ( NULL,
                                      1,
                                      (LPBYTE *)&psti1,
                                      (DWORD)-1,
                                      &entriesread,
                                      &totalentries,
                                      &resumehandle );
    if( retval == NERR_Success ) {
        //
        // Add the new name and domain to all of the transports
        //
        for( i=0; i < entriesread; i++ ) {

            //
            // Make sure we haven't already added to this transport
            //
            for( j = 0; j < i; j++ ) {
                if( wcscmp( psti1[j].svti1_transportname, psti1[i].svti1_transportname ) == 0 ) {
                    break;
                }
            }

            if( i != j ) {
                psti1[i].svti1_transportname[0] = '\0';
                continue;
            }

            psti1[i].svti1_transportaddress = NetBiosName;
            psti1[i].svti1_transportaddresslength = strlen( NetBiosName );
            psti1[i].svti1_domain = HostedDomainName;

            retval = NetServerTransportAddEx( NULL, 1, (LPBYTE)&psti1[ i ]  );

#ifndef NWLNKIPX_WORKS
            //
            // ??: The SMB server doesn't allow multiple names on NWLNK IPX.
            //

            if ( retval == ERROR_TOO_MANY_NAMES &&
                 _wcsicmp( psti1[i].svti1_transportname, L"\\Device\\NwlnkIpx" ) == 0 ) {
                retval = NERR_Success;
            }
#endif // NWLNKIPX_WORKS

            if( retval != NERR_Success ) {

                NlPrint((NL_CRITICAL,
                         "%ws: NlServerComputerNameAdd: Cannot add %ws to SMB server on transport %ws %ld\n",
                         HostedDomainName,
                         HostedServerName,
                         psti1[i].svti1_transportname,
                         retval ));

                //
                // Remove any names already added.
                //

                for( j=0; j < i; j++ ) {
                    NET_API_STATUS TempStatus;

                    if ( psti1[j].svti1_transportname[0] == '\0' ) {
                        continue;
                    }

                    TempStatus = NetServerTransportDel( NULL, 1, (LPBYTE)&psti1[ j ]  );

                    NlPrint((NL_CRITICAL,
                             "%ws: NlServerComputerNameAdd: Cannot remove %ws to SMB server on transport %ws %ld\n",
                             HostedDomainName,
                             HostedServerName,
                             psti1[i].svti1_transportname,
                             TempStatus ));
                }
                break;
            }
        }

        MIDL_user_free( psti1 );
    }


    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\makefile.inc ===
logon_s_stub.c: ..\idl\$(O)\logon_s.c
nlcommon.c: ..\idl\nlcommon.c
dsgetdc.c: ..\idl\netpdc.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nldebug.h ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    nldebug.h

Abstract:

    Netlogon service debug support

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.

--*/

//
// nlp.c will #include this file with DEBUG_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef EXTERN
#undef EXTERN
#endif
#ifdef DEBUG_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

////////////////////////////////////////////////////////////////////////
//
// Debug Definititions
//
////////////////////////////////////////////////////////////////////////

#define NL_INIT          0x00000001 // Initialization
#define NL_MISC          0x00000002 // Misc debug
#define NL_LOGON         0x00000004 // Logon processing
#define NL_SYNC          0x00000008 // Synchronization and replication
#define NL_MAILSLOT      0x00000010 // Mailslot messages
#define NL_SITE          0x00000020 // Sites
#define NL_CRITICAL      0x00000100 // Only real important errors
#define NL_SESSION_SETUP 0x00000200 // Trusted Domain maintenance
#define NL_DOMAIN        0x00000400 // Hosted Domain maintenance
#define NL_2             0x00000800
#define NL_SERVER_SESS   0x00001000 // Server session maintenance
#define NL_CHANGELOG     0x00002000 // Change Log references
#define NL_DNS           0x00004000 // DNS name registration

//
// Very verbose bits
//

#define NL_WORKER        0x00010000 // Debug worker thread
#define NL_DNS_MORE      0x00020000 // Verbose DNS name registration
#define NL_PULSE_MORE    0x00040000 // Verbose pulse processing
#define NL_SESSION_MORE  0x00080000 // Verbose session management
#define NL_REPL_TIME     0x00100000 // replication timing output
#define NL_REPL_OBJ_TIME 0x00200000 // replication objects get/set timing output
#define NL_ENCRYPT       0x00400000 // debug encrypt and decrypt across net
#define NL_SYNC_MORE     0x00800000 // additional replication dbgprint
#define NL_PACK_VERBOSE  0x01000000 // Verbose Pack/Unpack
#define NL_MAILSLOT_TEXT 0x02000000 // Verbose Mailslot messages
#define NL_CHALLENGE_RES 0x04000000 // challenge response debug
#define NL_SITE_MORE     0x08000000 // Verbose sites

//
// Control bits.
//

#define NL_INHIBIT_CANCEL 0x10000000 // Don't cancel API calls
#define NL_TIMESTAMP      0x20000000 // TimeStamp each output line
#define NL_ONECHANGE_REPL 0x40000000 // Only replicate one change per call
#define NL_BREAKPOINT     0x80000000 // Enter debugger on startup


#ifdef WIN32_CHICAGO
#ifdef NETLOGONDBG
#undef NETLOGONDBG
#endif
#if DBG
#define NETLOGONDBG 1
#endif // DBG
#endif // WIN32_CHICAGO

#if  NETLOGONDBG || defined(NLTEST_IMAGE)

#ifdef WIN32_CHICAGO
EXTERN DWORD NlGlobalTrace;
#endif // WIN32_CHICAGO

//
// Debug share path.
//

EXTERN LPWSTR NlGlobalDebugSharePath;

#ifndef WIN32_CHICAGO
#define IF_NL_DEBUG(Function) \
     if (NlGlobalParameters.DbFlag & NL_ ## Function)
#else
#define IF_NL_DEBUG(Function) \
     if (NlGlobalTrace & NL_ ## Function)
#endif

#define NlPrint(_x_) NlPrintRoutine _x_
#define NlPrintDom(_x_) NlPrintDomRoutine _x_
#define NlPrintCs(_x_) NlPrintCsRoutine _x_

VOID
NlAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );

#define NlAssert(Predicate) \
    { \
        if (!(Predicate)) \
            NlAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\netlogon.log"
#define DEBUG_BAK_FILE      L"\\netlogon.bak"

#define DEBUG_SHARE_NAME    L"DEBUG"

VOID
NlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR FORMATSTRING,              // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

#ifdef _NETLOGON_SERVER
VOID
NlPrintDomRoutine(
    IN DWORD DebugFlag,
    IN PDOMAIN_INFO DomainInfo OPTIONAL,
    IN LPSTR Format,
    ...
    );

VOID
NlPrintCsRoutine(
    IN DWORD DebugFlag,
    IN PCLIENT_SESSION,
    IN LPSTR Format,
    ...
    );

VOID
NlPrintRoutineV(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    va_list arglist
    );

VOID
NlPrintRpcDebug(
    IN LPCSTR RpcRoutineName,
    IN NTSTATUS StatusIn
    );
#endif // _NETLOGON_SERVER

VOID
NlpDumpGuid(
    IN DWORD DebugFlag,
    IN GUID *Guid
    );

VOID
NlpDumpSid(
    IN DWORD DebugFlag,
    IN PSID Sid
    );

VOID
NlpDumpTime(
    IN DWORD DebugFlag,
    IN LPSTR Comment,
    IN LARGE_INTEGER ConvertTime
    );

VOID
NlpDumpPeriod(
    IN DWORD DebugFlag,
    IN LPSTR Comment,
    IN ULONG Period
    );

VOID
NlpDumpBuffer(
    IN DWORD DebugFlag,
    IN PVOID Buffer,
    IN DWORD BufferSize
    );

VOID
NlOpenDebugFile(
    IN BOOL ReopenFlag
    );

//
// Debug log file
//

EXTERN HANDLE NlGlobalLogFile;
#define DEFAULT_MAXIMUM_LOGFILE_SIZE 20000000
EXTERN LPBYTE NlGlobalLogFileOutputBuffer;

//
// To serialize access to log file.
//

#ifndef WIN32_CHICAGO
EXTERN CRITICAL_SECTION NlGlobalLogFileCritSect;
#endif // WIN32_CHICAGO

#else

#define IF_NL_DEBUG(Function) if (FALSE)

// Nondebug version.
#define NlpDumpBuffer
#define NlpDumpGuid
#define NlpDumpSid
#define NlPrint(_x_)
#define NlPrintDom(_x_)
#define NlPrintCs(_x_)
#define NlAssert(Predicate)   /* no output; ignore arguments */

#undef EXTERN

#endif // NETLOGONDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nlldap.cxx ===
/*--


Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    nlldap.cxx

Abstract:

    Routines the use the DS's ldap filter.

    This is actually in a .cxx file by itself to work around a compiler bug
    where .c files cannot include ldap.h

Author:


Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#include <nt.h>     // LARGE_INTEGER definition
#include <ntrtl.h>  // LARGE_INTEGER definition
#include <nturtl.h> // LARGE_INTEGER definition
#include <ntlsa.h>  // Needed by lsrvdata.h
#include <ntddbrow.h>  // Needed by nlcommon.h

#define NOMINMAX        // Avoid redefinition of min and max in stdlib.h
#include <rpc.h>        // Needed by logon_s.h
#include <logon_s.h>    // includes lmcons.h, lmaccess.h, netlogon.h, ssi.h, windef.h
//
#include <windows.h>
#include <winsock2.h>   // Winsock support
#include <lmapibuf.h>   // NetApiBufferFree
#include <logonp.h>     // NetpLogon routines
#include <lsarpc.h>     // Needed by lsrvdata.h and logonsrv.h
#include <lsaisrv.h>    // Needed by changelg.h
#include <wincrypt.h>   // CryptoAPI, needed by lsrvdata.h
#ifdef __cplusplus
}  /* extern "C" */
#endif /* __cplusplus */
#include <netlib.h>     // Needed by nlcommon.h
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#include <samrpc.h>     // Needed by lsrvdata.h and logonsrv.h
#include <ntdsa.h>      // THSave/THRestore
#include <wmistr.h>     // Needed by lsrvdata.h
#include <evntrace.h>   // Needed by lsrvdata.h
#include <sspi.h>       // Needed by ssiinit.h

//
// Netlogon specific header files.
//

#define _AVOID_REPL_API 1
#include <nlrepl.h>     // I_Net*
#include "worker.h"     // Worker routines
#include "nlcommon.h"   // Routines shared with logonsrv\common
#include "domain.h"     // Hosted domain definitions
#include "changelg.h"   // Change Log support
#include "chutil.h"     // Change Log utilities
#include "iniparm.h"    // registry parameters
#include "windns.h"     // needed by ssiinit.h
#include "ssiinit.h"    // Misc global definitions
#include "nldebug.h"    // Netlogon debugging
#include "lsrvdata.h"   // Globals

// #include <string.h>     // strnicmp ...
#include <ldap.h>       // Filter for LDAP query

#define NL_MAXIMUM_USER_NAME_LENGTH  20 // The max SAM allows

BOOLEAN
IsFilterName(
    IN Filter *CurrentFilter,
    IN LPSTR NameToMatch
    )

/*++

Routine Description:

    If the CurrentFilter is for NameToMatch, return TRUE

Arguments:

    Filter - Pointer to an equalityMatch Filter element.

    NameToMatch - Specifies the name to compare with the filter element.

Return Value:

    TRUE name matches.

--*/
{
    ULONG NameLength;

    NameLength = strlen( NameToMatch );
    if ( NameLength != CurrentFilter->u.equalityMatch.attributeDesc.length ) {
        return FALSE;
    }
    if ( _strnicmp( NameToMatch,
                    (LPSTR)CurrentFilter->u.equalityMatch.attributeDesc.value,
                    NameLength ) != 0 ) {
        return FALSE;
    }
    return TRUE;
}

NET_API_STATUS
FilterString(
    IN Filter *CurrentFilter,
    IN ULONG UnicodeStringBufferSize,
    OUT LPWSTR UnicodeStringBuffer OPTIONAL,
    OUT LPWSTR *UnicodeString
    )

/*++

Routine Description:

    Return a zero terminated unicode string containing the value of the
    current equalityMatch filter element.

    The value of the element is expected to be in UTF-8.

Arguments:

    Filter - Pointer to an equalityMatch Filter element.

    UnicodeStringBuffer -- Buffer to copy the covnverted string to.
        If NULL, the function will allocate the needed memory and
        return it in UnicodeString.

    UnicodeStringSize - Size in wide charactes of UnicodeStringBuffer.
        If this size is less than what's needed to store the resulting
        NULL terminated unicode string, the function will allocate the
        needed memory and return it in UnicodeString.

    UnicodeString - Returns a pointer to the resulting string.
        If the passed in buffer for the resulting unicode string isn't
        large enough, the function will allocate the needed memory and
        the pointer to the allocated memory will be returned in this
        parameter. If NULL and the passed in buffer isn't large enough
        to store the resulting NULL terminated string, the function
        returns ERROR_INSUFFICIENT_BUFFER. On successful return, the
        caller should check whether UnicodeString != UnicodeStringBuffer
        and, if so, free the allocated buffer using NetApiBufferFree.

Return Value:

    Error returned by NetpAllocWStrFromUtf8StrAsRequired.

--*/
{
    NET_API_STATUS NetStatus;
    LPWSTR AllocatedUnicodeString = NULL;

    //
    // Call the worker routine
    //

    NetStatus =  NetpAllocWStrFromUtf8StrAsRequired(
                    (LPSTR)CurrentFilter->u.equalityMatch.assertionValue.value,
                    CurrentFilter->u.equalityMatch.assertionValue.length,
                    UnicodeStringBufferSize,
                    UnicodeStringBuffer,
                    &AllocatedUnicodeString );

    //
    // Set the return pointer to point to the appropriate buffer
    //

    if ( NetStatus == NO_ERROR ) {
        if ( AllocatedUnicodeString != NULL ) {
            NlAssert( AllocatedUnicodeString != UnicodeStringBuffer );
            *UnicodeString = AllocatedUnicodeString;
        } else {
            *UnicodeString = UnicodeStringBuffer;
        }
    }

    return NetStatus;
}

NET_API_STATUS
FilterBinary(
    IN  Filter *CurrentFilter,
    IN  ULONG BufferSize,
    OUT PVOID Buffer,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    Returns a properly aligned pointer to the binary data.

Arguments:

    Filter - Pointer to an equalityMatch Filter element.

    Buffer - Buffer to copy the data into.

    BufferSize - The size of the passed buffer. If the
        buffer isn't large enough to store the data,
        ERROR_INSUFFICIENT_BUFFER is returned.

    DataSize - Size of the data copied

Return Value:

    NO_ERROR - The data has been successfully coppied.

    ERROR_INSUFFICIENT_BUFFER - The passed in buffer is too small.

--*/
{
    if ( BufferSize < CurrentFilter->u.equalityMatch.assertionValue.length ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    RtlCopyMemory( Buffer,
                   CurrentFilter->u.equalityMatch.assertionValue.value,
                   CurrentFilter->u.equalityMatch.assertionValue.length );

    *DataSize = CurrentFilter->u.equalityMatch.assertionValue.length;

    return NO_ERROR;
}


NTSTATUS
I_NetLogonLdapLookupEx(
    IN PVOID FilterParam,
    IN PVOID ClientSockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    )

/*++

Routine Description:

    This routine builds a response to an LDAP ping of a DC.  DsGetDcName does
    such a ping to ensure the DC is functional and still meets the requirements
    of the DsGetDcName.  DsGetDcName does an LDAP lookup of the NULL DN asking
    for attribute "Netlogon".  The DS turns that into a call to this routine
    passing in the filter parameter.

    The DS is expected to save the DS thread state before calling.  This routine
    calls SAM which expects to have its own DS thread state.

Arguments:

    Filter - Filter describing the query.  The filter is built by the DsGetDcName
        client, so we can limit the flexibility significantly.

    SockAddr - Socket Address of the client this request came in on.

    Response - Returns a pointer to an allocated buffer containing
        the response to return to the caller.  This response is a binary blob
        which should be returned to the caller bit-for-bit intact.
        The buffer should be freed be calling I_NetLogonFree.

    ResponseSize - Size (in bytes) of the returned message.

Return Value:

    STATUS_SUCCESS -- The response was returned in the supplied buffer.

    STATUS_INVALID_PARAMETER -- The filter was invalid.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NET_API_STATUS NetStatus = NO_ERROR;

    Filter *LdapFilter = (Filter *) FilterParam;
    Filter *CurrentFilter;
    struct _setof3_ *CurrentAnd;

    LPSTR DnsDomainName = NULL;
    GUID DomainGuid;
    GUID *DomainGuidPtr = NULL;
    // The domain SID buffer must be DWORD alligned. Avoid any buffer overflow problem
    //  due to truncation in case SECURITY_MAX_SID_SIZE isn't evenly divisible by 4
    ULONG DomainSid[SECURITY_MAX_SID_SIZE/sizeof(ULONG)+1];
    PSID DomainSidPtr = NULL;
    WCHAR UnicodeComputerNameBuffer[MAX_COMPUTERNAME_LENGTH+1];
    LPWSTR UnicodeComputerName = NULL;
    WCHAR UnicodeUserNameBuffer[NL_MAXIMUM_USER_NAME_LENGTH+1];
    LPWSTR UnicodeUserName = NULL;
    ULONG AllowableAccountControlBits = 0;
    DWORD NtVersion = LMNT_MESSAGE;
    DWORD NtVersionFlags = NETLOGON_NT_VERSION_5;
    ULONG Length = 0;
    SOCKADDR_IN SockAddrIn;

    //
    // Initialization.
    //

    *Response = NULL;
    *ResponseSize = 0;

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Validate the client socket address.
    //

    if ( ClientSockAddr != NULL ) {
        if ( ((PSOCKADDR)ClientSockAddr)->sa_family != AF_INET ) {
            NlPrint((NL_CRITICAL,
                    "I_NetlogonLdapLookupEx: DS passed us a SOCKADDR that wasn't AF_INET (ignoring it)\n" ));
            ClientSockAddr = NULL;
        } else {
            //
            // Force the port number to zero to avoid confusion later.
            SockAddrIn = *((PSOCKADDR_IN)ClientSockAddr);
            SockAddrIn.sin_port = 0;
            ClientSockAddr = &SockAddrIn;

        }
    }



    //
    // Parse the filter.
    //

    if ( LdapFilter != NULL ) {

        //
        // The first element of the filter must be an AND.
        //

        if ( LdapFilter->choice != and_chosen ) {
            NlPrint((NL_CRITICAL,
                    "I_NetlogonLdapLookup: Filter doesn't have AND %ld\n",
                    LdapFilter->choice ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Loop through the AND'ed attributes.
        //
        //

        for ( CurrentAnd = LdapFilter->u.and;
              CurrentAnd != NULL;
              CurrentAnd = CurrentAnd->next ) {

            CurrentFilter = &CurrentAnd->value;

            if ( CurrentFilter->choice != equalityMatch_chosen ) {
                NlPrint((NL_CRITICAL,
                        "I_NetlogonLdapLookup: Filter doesn't have EqualityMatch %ld\n",
                        LdapFilter->choice ));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // Handle DnsDomainName parameter.
            //

            if ( IsFilterName( CurrentFilter, NL_FILTER_DNS_DOMAIN_NAME ) ) {

                if ( CurrentFilter->u.equalityMatch.assertionValue.length == 0 ) {
                    NlPrint((NL_CRITICAL,
                            "I_NetlogonLdapLookup: Bad DnsDomainName\n" ));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // Avoid leaking memory - there must be only one domain name specified
                //

                if ( DnsDomainName != NULL ) {
                    NlPrint(( NL_CRITICAL,
                              "I_NetlogonLdapLookup: Bad ping from %ws: multiple DnsDomainName\n",
                              UnicodeComputerName ));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                NetStatus = NetApiBufferAllocate(
                                CurrentFilter->u.equalityMatch.assertionValue.length + sizeof(CHAR),
                                (LPVOID *) &DnsDomainName );

                if ( NetStatus != NO_ERROR ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                RtlCopyMemory( DnsDomainName,
                               CurrentFilter->u.equalityMatch.assertionValue.value,
                               CurrentFilter->u.equalityMatch.assertionValue.length );

                DnsDomainName[ CurrentFilter->u.equalityMatch.assertionValue.length ] = '\0';

            //
            // Handle Host parameter.
            //

            } else if ( IsFilterName( CurrentFilter, NL_FILTER_HOST_NAME ) ) {

                //
                // Avoid leaking memory - there must be only one host name specified
                //

                if ( UnicodeComputerName != NULL ) {
                    NlPrint(( NL_CRITICAL,
                              "I_NetlogonLdapLookup: Bad ping from %ws: multiple UnicodeComputerName\n",
                              UnicodeComputerName ));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                NetStatus = FilterString( CurrentFilter,
                                          MAX_COMPUTERNAME_LENGTH+1,
                                          UnicodeComputerNameBuffer,
                                          &UnicodeComputerName );

                if ( NetStatus != NO_ERROR ) {
                    NlPrint((NL_CRITICAL,
                            "I_NetlogonLdapLookup: Bad UnicodeComputerName 0x%lx\n",
                             NetStatus ));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

            //
            // Handle User parameter.
            //

            } else if ( IsFilterName( CurrentFilter, NL_FILTER_USER_NAME ) ) {

                //
                // Avoid leaking memory - there must be only one user name specified
                //

                if ( UnicodeUserName != NULL ) {
                    NlPrint(( NL_CRITICAL,
                              "I_NetlogonLdapLookup: Bad ping from %ws: multiple UnicodeUserName\n",
                              UnicodeComputerName ));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                NetStatus = FilterString( CurrentFilter,
                                          NL_MAXIMUM_USER_NAME_LENGTH+1,
                                          UnicodeUserNameBuffer,
                                          &UnicodeUserName );

                if ( NetStatus != NO_ERROR ) {
                    NlPrint((NL_CRITICAL,
                            "I_NetlogonLdapLookup: Bad UnicodeUserName 0x%lx\n",
                             NetStatus ));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

            //
            // Handle AccountControlBits parameter.
            //
            } else if ( IsFilterName( CurrentFilter, NL_FILTER_ALLOWABLE_ACCOUNT_CONTROL ) ) {

                NetStatus = FilterBinary( CurrentFilter,
                                          sizeof(AllowableAccountControlBits),
                                          &AllowableAccountControlBits,
                                          &Length );

                if ( NetStatus != NO_ERROR || Length != sizeof(AllowableAccountControlBits) ) {
                    NlPrint((NL_CRITICAL,
                            "I_NetlogonLdapLookup: Bad AllowableAccountControl 0x%lx %lu\n",
                             NetStatus,
                             Length ));

                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

            //
            // Handle DomainSid parameter.
            //
            } else if ( IsFilterName( CurrentFilter, NL_FILTER_DOMAIN_SID ) ) {

                NetStatus = FilterBinary( CurrentFilter,
                                          sizeof(DomainSid),
                                          DomainSid,
                                          &Length );

                //
                // Check the length
                //
                if ( NetStatus != NO_ERROR ||
                     !RtlValidSid(DomainSid) ||
                     RtlLengthSid(DomainSid) != Length ) {

                    NlPrint((NL_CRITICAL,
                            "I_NetlogonLdapLookup: Bad DomainSid 0x%lx %ld\n",
                             NetStatus,
                             Length ));

                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                DomainSidPtr = DomainSid;

            //
            // Handle DomainGuid parameter.
            //
            } else if ( IsFilterName( CurrentFilter, NL_FILTER_DOMAIN_GUID ) ) {

                NetStatus = FilterBinary( CurrentFilter,
                                          sizeof(DomainGuid),
                                          &DomainGuid,
                                          &Length );

                //
                // Check the length
                //
                if ( NetStatus != NO_ERROR ||
                     Length != sizeof(GUID) ) {

                    NlPrint((NL_CRITICAL,
                            "I_NetlogonLdapLookup: Bad DomainGuid 0x%lx %ld\n",
                             NetStatus,
                             Length ));

                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                DomainGuidPtr = &DomainGuid;

            //
            // Handle NtVersion parameter.
            //
            } else if ( IsFilterName( CurrentFilter, NL_FILTER_NT_VERSION ) ) {

                NetStatus = FilterBinary( CurrentFilter,
                                          sizeof(NtVersionFlags),
                                          &NtVersionFlags,
                                          &Length );

                if ( NetStatus != NO_ERROR || Length != sizeof(NtVersionFlags) ) {
                    NlPrint((NL_CRITICAL,
                            "I_NetlogonLdapLookup: Bad NtVersionFlags 0x%lx %ld\n",
                             NetStatus,
                             Length ));

                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

            //
            // Attributes we don't understand are ignored.  That way clients
            //  that are newer than this version can pass additional information
            //  to newer DCs and not worry about breaking older DCs.
            //

            } else {
                NlPrint((NL_CRITICAL,
                        "I_NetlogonLdapLookup: unrecognized parameter %.*s\n",
                        CurrentFilter->u.equalityMatch.attributeDesc.length,
                        CurrentFilter->u.equalityMatch.attributeDesc.value ));
            }

        }

    }


    //
    // Build the ping based on the queried information.
    //

    NetStatus = NlGetLocalPingResponse(
                    L"UDP LDAP",
                    TRUE,   // LDAP ping
                    NULL,   // No Netbios domain name
                    DnsDomainName,
                    DomainGuidPtr,
                    DomainSidPtr,
                    FALSE,  // Not PDC only
                    UnicodeComputerName,
                    UnicodeUserName,
                    AllowableAccountControlBits,
                    NtVersion,
                    NtVersionFlags,
                    (PSOCKADDR)ClientSockAddr,
                    Response,
                    ResponseSize );

    if ( NetStatus != NO_ERROR ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if NETLOGONDBG
    NlpDumpBuffer( NL_MAILSLOT_TEXT, *Response, *ResponseSize );
#endif // NETLOGONDBG

    Status = STATUS_SUCCESS;

Cleanup:
    if ( DnsDomainName != NULL ) {
        NetApiBufferFree( DnsDomainName );
    }
    if ( UnicodeComputerName != NULL &&
         UnicodeComputerName != UnicodeComputerNameBuffer ) {
        NetApiBufferFree( UnicodeComputerName );
    }
    if ( UnicodeUserName != NULL &&
         UnicodeUserName != UnicodeUserNameBuffer ) {
        NetApiBufferFree( UnicodeUserName );
    }

    // Let netlogon service exit.
    NlEndNetlogonCall();
    return Status;


}
#ifdef __cplusplus
}  /* extern "C" */
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\netlogon.c ===
/*--


Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    netlogon.c

Abstract:

    Entry point and main thread of Netlogon service.

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    21-Nov-1990 (madana)
        added code for update (reverse replication) and lockout support.

    21-Nov-1990 (madana)
        server type support.

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.

--*/


//
// Common include files.
//
#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

#include <overflow.h>

//
// Include lsrvdata.h again allocating the actual variables
// this time around.
//

#define LSRVDATA_ALLOCATE
#include "lsrvdata.h"
#undef LSRVDATA_ALLOCATE


//
// Include files specific to this .c file
//

#include <ctype.h>      // C library type functions
#include <lmwksta.h>    // WKSTA API defines and prototypes
#include <w32timep.h>   // W32TimeGetNetlogonServiceBits
extern BOOLEAN SampUsingDsData();

//
// Globals
//

#define INTERROGATE_RESP_DELAY      2000    // may want to tune it
#define MAX_PRIMARY_TRACK_FAIL      3       // Primary pulse slips

//
// RpcInit workitem
WORKER_ITEM NlGlobalRpcInitWorkItem;



BOOLEAN
NetlogonDllInit (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This is the DLL initialization routine for netlogon.dll.

Arguments:

    Standard.

Return Value:

    TRUE iff initialization succeeded.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    UNREFERENCED_PARAMETER(DllHandle);          // avoid compiler warnings
    UNREFERENCED_PARAMETER(Context);            // avoid compiler warnings


    //
    // Handle attaching netlogon.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

        NlGlobalMsvEnabled = FALSE;
        NlGlobalMsvThreadCount = 0;
        NlGlobalMsvTerminateEvent = NULL;

        if ( !DisableThreadLibraryCalls( DllHandle ) ) {
            KdPrint(("NETLOGON.DLL: DisableThreadLibraryCalls failed: %ld\n",
                         GetLastError() ));
        }
        Status = NlInitChangeLog();

#if NETLOGONDBG
        if ( !NT_SUCCESS( Status ) ) {
            KdPrint(("NETLOGON.DLL: Changelog initialization failed: %lx\n",
                         Status ));
        }
#endif // NETLOGONDBG

        if ( NT_SUCCESS(Status) ) {
            //
            // Initialize the Critical Section used to serialize access to
            // variables shared by MSV threads and netlogon threads.
            //

            try {
                InitializeCriticalSection( &NlGlobalMsvCritSect );
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                KdPrint(("NETLOGON.DLL: Cannot initialize NlGlobalMsvCritSect\n"));
                Status = STATUS_NO_MEMORY;
            }

            //
            // Initialize the cache of discovered domains.
            //

            if ( NT_SUCCESS(Status) ) {
                NetStatus = NetpDcInitializeCache();

                if ( NetStatus != NO_ERROR ) {
                    KdPrint(("NETLOGON.DLL: Cannot NetpDcinitializeCache\n"));
                    Status = STATUS_NO_MEMORY;
                }

                if ( !NT_SUCCESS(Status) ) {
                    DeleteCriticalSection( &NlGlobalMsvCritSect );
                }
            }

            if ( !NT_SUCCESS(Status) ) {
                NlCloseChangeLog();
            }
        }


    //
    // Handle detaching netlogon.dll from a process.
    //

    } else if (Reason == DLL_PROCESS_DETACH) {
        Status = NlCloseChangeLog();
#if NETLOGONDBG
        if ( !NT_SUCCESS( Status ) ) {
            KdPrint(("NETLOGON.DLL: Changelog initialization failed: %lx\n",
                         Status ));
        }
#endif // NETLOGONDBG

        //
        // Delete the Critical Section used to serialize access to
        // variables shared by MSV threads and netlogon threads.
        //

        DeleteCriticalSection( &NlGlobalMsvCritSect );

        //
        // Free the cache of discovered DCs.
        //

        NetpDcUninitializeCache();

    } else {
        Status = STATUS_SUCCESS;
    }

    return (BOOLEAN)(NT_SUCCESS(Status));

}


BOOLEAN
NlInitDbSerialNumber(
    IN PDOMAIN_INFO DomainInfo,
    IN OUT PLARGE_INTEGER SerialNumber,
    IN OUT PLARGE_INTEGER CreationTime,
    IN DWORD DBIndex
    )

/*++

Routine Description:

    Set the SerialNumber and CreationTime in the NlGlobalDBInfoArray data
    structure.

    On the PDC,
        Validate that it matches the value found in the change log.
        Ensure the values are non-zero.

Arguments:

    DomainInfo - Hosted Domain this database is for.

    SerialNumber - Specifies the serial number found in the database.
        On return, specifies the serial number to write to the database

    CreationTime - Specifies the creation time found in the database.
        On return, specifies the creation time to write to the database

    DBIndex -- DB Index of the database being initialized

Return Value:

    TRUE -- iff the serial number and creation time need to be written back
            to the database.

--*/

{
    BOOLEAN ReturnValue = FALSE;


    //
    // If we're running as the primary,
    //  check to see if we are a newly promoted primary that was in
    //  the middle of a full sync before we were promoted.
    //

    NlAssert( IsPrimaryDomain( DomainInfo ) );
    if ( NlGlobalPdcDoReplication ) {

        if ( SerialNumber->QuadPart == 0 || CreationTime->QuadPart == 0 ) {

            NlPrint(( NL_CRITICAL,
                      "NlInitDbSerialNumber: %ws"
                      ": Pdc has bogus Serial number %lx %lx or Creation Time %lx %lx (reset).\n",
                      NlGlobalDBInfoArray[DBIndex].DBName,
                    SerialNumber->HighPart,
                    SerialNumber->LowPart,
                    CreationTime->HighPart,
                    CreationTime->LowPart ));

            //
            //  This is the primary,
            //  we probably shouldn't be replicating from a partial database,
            //  but at least set the replication information to something
            //  reasonable.
            //
            // This will FORCE a full sync on every BDC since the CreationTime has
            // changed.  That's the right thing to do since we can't possibly know
            // what state this database is in.
            //

            NlQuerySystemTime( CreationTime );
            SerialNumber->QuadPart = 1;
            ReturnValue = TRUE;

        }


    }



    //
    // The global serial number array has already been initialized
    //  from the changelog.  If that information is wrong, just reset the
    //  changelog now.
    //


    LOCK_CHANGELOG();

    //
    // If there was no serial number in the changelog for this database,
    //  set it now.
    //

    if ( NlGlobalChangeLogDesc.SerialNumber[DBIndex].QuadPart == 0 ) {

        NlPrint((NL_SYNC, "NlInitDbSerialNumber: %ws"
                        ": No serial number in change log (set to %lx %lx)\n",
                        NlGlobalDBInfoArray[DBIndex].DBName,
                        SerialNumber->HighPart,
                        SerialNumber->LowPart ));


        NlGlobalChangeLogDesc.SerialNumber[DBIndex] = *SerialNumber;

    //
    // If the serial number in the changelog is greater than the
    // serial number in the database, this is caused by the changelog
    // being flushed to disk and the SAM database not being flushed.
    //
    // Cure this problem by deleting the superfluous changelog entries.
    //

    } else if ( NlGlobalChangeLogDesc.SerialNumber[DBIndex].QuadPart !=
                    SerialNumber->QuadPart ) {

        NlPrint((NL_SYNC, "NlInitDbSerialNumber: %ws"
                        ": Changelog serial number different than database: "
                        "ChangeLog = %lx %lx DB = %lx %lx\n",
                        NlGlobalDBInfoArray[DBIndex].DBName,
                        NlGlobalChangeLogDesc.SerialNumber[DBIndex].HighPart,
                        NlGlobalChangeLogDesc.SerialNumber[DBIndex].LowPart,
                        SerialNumber->HighPart,
                        SerialNumber->LowPart ));

        (VOID) NlFixChangeLog( &NlGlobalChangeLogDesc, DBIndex, *SerialNumber );

    } else {

        NlPrint((NL_SYNC, "NlInitDbSerialNumber: %ws"
                        ": Serial number is %lx %lx\n",
                        NlGlobalDBInfoArray[DBIndex].DBName,
                        SerialNumber->HighPart,
                        SerialNumber->LowPart ));
    }

    //
    // In all cases,
    //  set the globals to match the database.
    //

    NlGlobalChangeLogDesc.SerialNumber[DBIndex] = *SerialNumber;
    NlGlobalDBInfoArray[DBIndex].CreationTime = *CreationTime;

    UNLOCK_CHANGELOG();


    return ReturnValue;
}


NTSTATUS
NlInitLsaDBInfo(
    PDOMAIN_INFO DomainInfo,
    DWORD DBIndex
    )

/*++

Routine Description:

    Initialize NlGlobalDBInfoArray data structure.  Some of the LSA
    database info is already determined in ValidateStartup functions, so
    those values are used here.

Arguments:

    DomainInfo - Hosted Domain this database is for.

    DBIndex -- DB Index of the database being initialized

Return Value:

    NT status code.

--*/

{

    NTSTATUS        Status;

    //
    // Initialize LSA database info.
    //

    NlGlobalDBInfoArray[DBIndex].DBIndex = DBIndex;
    NlGlobalDBInfoArray[DBIndex].DBName = L"LSA";
    NlGlobalDBInfoArray[DBIndex].DBSessionFlag = SS_LSA_REPL_NEEDED;

    NlGlobalDBInfoArray[DBIndex].DBHandle = DomainInfo->DomLsaPolicyHandle;

    //
    // Forgo this initialization on a workstation.
    //

    if ( !NlGlobalMemberWorkstation ) {
        LARGE_INTEGER SerialNumber;
        LARGE_INTEGER CreationTime;


        //
        // Get the LSA Modified information.
        //

        Status = LsaIGetSerialNumberPolicy(
                    NlGlobalDBInfoArray[DBIndex].DBHandle,
                    &SerialNumber,
                    &CreationTime );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                    "NlInitLsaDbInfo: LsaIGetSerialNumberPolicy failed %lx\n",
                    Status ));
            goto Cleanup;
        }

        //
        // Set the SerialNumber and CreationTime in the globals.
        //

        if ( NlInitDbSerialNumber(
                DomainInfo,
                &SerialNumber,
                &CreationTime,
                DBIndex ) ) {


            Status = LsaISetSerialNumberPolicy(
                        NlGlobalDBInfoArray[DBIndex].DBHandle,
                        &SerialNumber,
                        &CreationTime,
                        (BOOLEAN) FALSE );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

}


NTSTATUS
NlInitSamDBInfo(
    PDOMAIN_INFO DomainInfo,
    DWORD DBIndex
    )

/*++

Routine Description:

    Initialize NlGlobalDBInfoArray data structure. Some of the SAM database
    info is already determined in ValidateStartup functions, so those
    values are used here. For BUILTIN database, the database is opened,
    database handle is obtained and other DB info
    queried and initialized in this function.

Arguments:

    DomainInfo - Hosted Domain this database is for.

    DBIndex -- DB Index of the database being initialized

Return Value:

    NT status code.

--*/

{

    NTSTATUS        Status;
    PSAMPR_DOMAIN_INFO_BUFFER DomainModified = NULL;
    PSAMPR_DOMAIN_INFO_BUFFER DomainReplica = NULL;



    //
    // Initialize SAM database info.
    //

    NlGlobalDBInfoArray[DBIndex].DBIndex = DBIndex;
    if ( DBIndex == SAM_DB ) {
        NlGlobalDBInfoArray[DBIndex].DBName = L"SAM";
        NlGlobalDBInfoArray[DBIndex].DBSessionFlag = SS_ACCOUNT_REPL_NEEDED;
        NlGlobalDBInfoArray[DBIndex].DBHandle = DomainInfo->DomSamAccountDomainHandle;
    } else {
        NlGlobalDBInfoArray[DBIndex].DBName = L"BUILTIN";
        NlGlobalDBInfoArray[DBIndex].DBSessionFlag = SS_BUILTIN_REPL_NEEDED;
        NlGlobalDBInfoArray[DBIndex].DBHandle = DomainInfo->DomSamBuiltinDomainHandle;
    }



    //
    // Forgo this initialization on a workstation.
    //

    if ( !NlGlobalMemberWorkstation ) {

        //
        // Get the replica source name.
        //

        Status = SamrQueryInformationDomain(
                    NlGlobalDBInfoArray[DBIndex].DBHandle,
                    DomainReplicationInformation,
                    &DomainReplica );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                    "NlInitSamDbInfo: %ws: Cannot SamrQueryInformationDomain (Replica): %lx\n",
                    NlGlobalDBInfoArray[DBIndex].DBName,
                    Status ));
            DomainReplica = NULL;
            goto Cleanup;
        }

        //
        // Get the Domain Modified information.
        //

        Status = SamrQueryInformationDomain(
                    NlGlobalDBInfoArray[DBIndex].DBHandle,
                    DomainModifiedInformation,
                    &DomainModified );

        if ( !NT_SUCCESS(Status) ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                    "NlInitSamDbInfo: %ws: Cannot SamrQueryInformationDomain (Modified): %lx\n",
                    NlGlobalDBInfoArray[DBIndex].DBName,
                    Status ));
            DomainModified = NULL;
            goto Cleanup;
        }

        //
        // Set the SerialNumber and CreationTime in the globals.
        //

        if ( NlInitDbSerialNumber(
                DomainInfo,
                &DomainModified->Modified.DomainModifiedCount,
                &DomainModified->Modified.CreationTime,
                DBIndex ) ) {

            Status = SamISetSerialNumberDomain(
                        NlGlobalDBInfoArray[DBIndex].DBHandle,
                        &DomainModified->Modified.DomainModifiedCount,
                        &DomainModified->Modified.CreationTime,
                        (BOOLEAN) FALSE );

            if ( !NT_SUCCESS(Status) ) {
                NlPrintDom(( NL_CRITICAL, DomainInfo,
                        "NlInitSamDbInfo: %ws: Cannot SamISetSerialNumberDomain: %lx\n",
                        NlGlobalDBInfoArray[DBIndex].DBName,
                        Status ));
                goto Cleanup;
            }
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // Free locally used resources.
    //
    if ( DomainModified != NULL ) {
        SamIFree_SAMPR_DOMAIN_INFO_BUFFER( DomainModified,
                                           DomainModifiedInformation );
    }

    if ( DomainReplica != NULL ) {
        SamIFree_SAMPR_DOMAIN_INFO_BUFFER( DomainReplica,
                                           DomainReplicationInformation );
    }

    return Status;

}


BOOL
NlCreateSysvolShares(
    VOID
    )

/*++

Routine Description:

    Create the Sysvol and Netlogon shares.

Arguments:

    None.

Return Value:

    TRUE -- iff initialization is successful.

--*/
{
    BOOL RetVal = TRUE;
    BOOL NetlogonShareRelatedToSysvolShare = FALSE;

    NET_API_STATUS NetStatus;
    LPWSTR AllocatedPath = NULL;
    LPWSTR PathToShare = NULL;

    LPWSTR DomDnsDomainNameAlias = NULL;
    LPWSTR AllocatedPathAlias = NULL;
    //
    // Create the sysvol share.
    //
    if ( NlGlobalParameters.SysVolReady ) {

        NetStatus =  NlCreateShare( NlGlobalParameters.UnicodeSysvolPath,
                                    NETLOGON_SYSVOL_SHARE,
                                    TRUE,
                                    TRUE,  // update exclusive share access
                                    NlGlobalParameters.AllowExclusiveSysvolShareAccess ) ;

        if ( NetStatus != NERR_Success ) {
            LPWSTR MsgStrings[2];

            NlPrint((NL_CRITICAL, "NlCreateShare %lu\n", NetStatus ));

            MsgStrings[0] = NlGlobalParameters.UnicodeSysvolPath;
            MsgStrings[1] = (LPWSTR) ULongToPtr( NetStatus );

            NlpWriteEventlog (NELOG_NetlogonFailedToCreateShare,
                              EVENTLOG_ERROR_TYPE,
                              (LPBYTE) &NetStatus,
                              sizeof(NetStatus),
                              MsgStrings,
                              2 | NETP_LAST_MESSAGE_IS_NETSTATUS );

            /* This isn't fatal. Just continue */
        }
    } else {
        NetStatus = NetShareDel( NULL, NETLOGON_SYSVOL_SHARE, 0);

        if ( NetStatus != NERR_Success ) {

            if ( NetStatus != NERR_NetNameNotFound ) {
                NlPrint((NL_CRITICAL, "NetShareDel SYSVOL failed %lu\n", NetStatus ));
            }

            /* This isn't fatal. Just continue */
        }
    }

    //
    // Create NETLOGON share.
    //

    //
    // Build the default netlogon share path
    //
    if ( NlGlobalParameters.UnicodeScriptPath == NULL &&
         NlGlobalParameters.UnicodeSysvolPath != NULL ) {
        PDOMAIN_INFO DomainInfo = NULL;
        ULONG Size;
        ULONG SysVolSize;
        PUCHAR Where;

        //
        // Get pointer to global domain info.
        //

        DomainInfo = NlFindNetbiosDomain( NULL, TRUE );    // Primary domain

        if ( DomainInfo == NULL ) {
            NlPrint((NL_CRITICAL, "NlCreateSysvolShares: Cannot find primary domain.\n" ));
            // This can't happen
            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Allocate a buffer for the real path
        //  Avoid this if we have no DNS domain
        //  name which is the case when we are
        //  in teh middle of dcpromo and somebody
        //  started us manually.
        //
        EnterCriticalSection(&NlGlobalDomainCritSect);
        if ( DomainInfo->DomUnicodeDnsDomainNameString.Length > 0 ) {
            SysVolSize = wcslen( NlGlobalParameters.UnicodeSysvolPath ) * sizeof(WCHAR);
            Size = SysVolSize +
                   sizeof(WCHAR) +
                   DomainInfo->DomUnicodeDnsDomainNameString.Length +
                   sizeof(DEFAULT_SCRIPTS);

            AllocatedPath = LocalAlloc( LMEM_ZEROINIT, Size );

            if ( AllocatedPath == NULL ) {
                LeaveCriticalSection(&NlGlobalDomainCritSect);
                NlDereferenceDomain( DomainInfo );
                RetVal = FALSE;
                goto Cleanup;
            }

            PathToShare = AllocatedPath;

            //
            // Build the real path
            //

            Where = (PUCHAR)PathToShare;
            RtlCopyMemory( Where, NlGlobalParameters.UnicodeSysvolPath, SysVolSize );
            Where += SysVolSize;

            *((WCHAR *)Where) = L'\\';
            Where += sizeof(WCHAR);

            // Ignore the trailing . on the DNS domain name
            RtlCopyMemory( Where,
                           DomainInfo->DomUnicodeDnsDomainNameString.Buffer,
                           DomainInfo->DomUnicodeDnsDomainNameString.Length - sizeof(WCHAR) );
            Where += DomainInfo->DomUnicodeDnsDomainNameString.Length - sizeof(WCHAR);

            //
            // At this point the path has the form "...\SYSVOL\SYSVOL\DnsDomainName".
            // This is the name of the junction point that points to the actual
            // sysvol root directory "...\SYSVOL\domain" (where "domain" is literal).
            // On the domain rename, we need to rename the junction point to correspond
            // to the current DNS domain name.  The old name is stored in the domain
            // name alias, so we can rename from "...\SYSVOL\SYSVOL\DnsDomainNameAlias"
            // to "...\SYSVOL\SYSVOL\DnsDomainName".  Note that if the rename hasn't yet
            // happened, DNS domain name alias is actually the future domain name. This
            // is OK as the junction named "...\SYSVOL\SYSVOL\DnsDomainNameAlias" will
            // not exist and the junction rename will fail properly.
            //

            if ( DomainInfo->DomUtf8DnsDomainNameAlias != NULL &&
                 !NlEqualDnsNameUtf8(DomainInfo->DomUtf8DnsDomainName,
                                     DomainInfo->DomUtf8DnsDomainNameAlias) ) {


                //
                // Get the Unicode alias name
                //
                DomDnsDomainNameAlias = NetpAllocWStrFromUtf8Str( DomainInfo->DomUtf8DnsDomainNameAlias );
                if ( DomDnsDomainNameAlias == NULL ) {
                    LeaveCriticalSection(&NlGlobalDomainCritSect);
                    NlDereferenceDomain( DomainInfo );
                    RetVal = FALSE;
                    goto Cleanup;
                }

                //
                // Allocate storage for the path corresponding to the alias
                //
                AllocatedPathAlias = LocalAlloc( LMEM_ZEROINIT,
                        SysVolSize +                                   // sysvol part of the path
                        sizeof(WCHAR) +                                // path separator
                        wcslen(DomDnsDomainNameAlias)*sizeof(WCHAR) +  // domain name part
                        sizeof(WCHAR) );                               // string terminator

                if ( AllocatedPathAlias == NULL ) {
                    LeaveCriticalSection(&NlGlobalDomainCritSect);
                    NlDereferenceDomain( DomainInfo );
                    RetVal = FALSE;
                    goto Cleanup;
                }

                //
                // Fill in the path corresponding to the alias
                //
                swprintf( AllocatedPathAlias,
                          L"%ws\\%ws",
                          NlGlobalParameters.UnicodeSysvolPath,
                          DomDnsDomainNameAlias );

                //
                // Rename the junction. Ignore any failure.
                //
                if ( !MoveFile(AllocatedPathAlias, PathToShare) ) {
                    NetStatus = GetLastError();
                    if ( NetStatus != ERROR_FILE_NOT_FOUND ) {
                        NlPrint(( NL_CRITICAL, "NlCreateSysvolShares: Failed to rename junction: %ws %ws 0x%lx\n",
                                  AllocatedPathAlias,
                                  PathToShare,
                                  NetStatus ));
                    }
                } else {
                    NlPrint(( NL_INIT, "Renamed SysVol junction from %ws to %ws\n",
                              AllocatedPathAlias,
                              PathToShare ));
                }
            }

            //
            // Now finish building the share path
            //
            RtlCopyMemory( Where, DEFAULT_SCRIPTS, sizeof(DEFAULT_SCRIPTS) );
        }
        LeaveCriticalSection(&NlGlobalDomainCritSect);

        NlDereferenceDomain( DomainInfo );
        NetlogonShareRelatedToSysvolShare = TRUE;
    } else {
        PathToShare = NlGlobalParameters.UnicodeScriptPath;
    }


    if ( NlGlobalParameters.SysVolReady ||
         !NetlogonShareRelatedToSysvolShare ) {

        if ( PathToShare != NULL ) {
            NetStatus =  NlCreateShare( PathToShare,
                                        NETLOGON_SCRIPTS_SHARE,
                                        FALSE,
                                        TRUE,  // update exclusive share access
                                        NlGlobalParameters.AllowExclusiveScriptsShareAccess ) ;

            if ( NetStatus != NERR_Success ) {
                LPWSTR MsgStrings[2];

                NlPrint((NL_CRITICAL, "NlCreateShare %lu\n", NetStatus ));

                MsgStrings[0] = PathToShare;
                MsgStrings[1] = (LPWSTR) ULongToPtr( NetStatus );

                NlpWriteEventlog (NELOG_NetlogonFailedToCreateShare,
                                  EVENTLOG_ERROR_TYPE,
                                  (LPBYTE) &NetStatus,
                                  sizeof(NetStatus),
                                  MsgStrings,
                                  2 | NETP_LAST_MESSAGE_IS_NETSTATUS );

                /* This isn't fatal. Just continue */
            }
        }
    } else {
        NetStatus = NetShareDel( NULL, NETLOGON_SCRIPTS_SHARE, 0);

        if ( NetStatus != NERR_Success ) {

            if ( NetStatus != NERR_NetNameNotFound ) {
                NlPrint((NL_CRITICAL, "NetShareDel NETLOGON failed %lu\n", NetStatus ));
            }

            /* This isn't fatal. Just continue */
        }
    }

Cleanup:

    if ( AllocatedPath != NULL ) {
        LocalFree( AllocatedPath );
    }
    if ( AllocatedPathAlias != NULL ) {
        LocalFree( AllocatedPathAlias );
    }
    if ( DomDnsDomainNameAlias != NULL ) {
        NetApiBufferFree( DomDnsDomainNameAlias );
    }

    return RetVal;
}



#ifdef _DC_NETLOGON

BOOL
NlInitDomainController(
    VOID
    )

/*++

Routine Description:

    Do Domain Controller specific initialization.

Arguments:

    None.

Return Value:

    TRUE -- iff initialization is successful.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    //
    // Ensure the browser doesn't have extra Hosted domains.
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    NlBrowserSyncHostedDomains();



    //
    // Check that the server is installed or install pending
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    if ( !NetpIsServiceStarted( SERVICE_SERVER ) ){
        NlExit( NERR_ServerNotStarted, ERROR_SERVICE_DEPENDENCY_FAIL, LogError, NULL);
        return FALSE;
    }

    //
    // Create SYSVOL and Netlogon shares.
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    if ( !NlCreateSysvolShares() ) {
        NlExit( SERVICE_UIC_RESOURCE, ERROR_NOT_ENOUGH_MEMORY, LogError, NULL);
        return FALSE;
    }

    //
    // Delete the key Netlogon\FullSyncKey
    //  (This key was used on a BDC in releases prior to NT 5.0 to keep
    //  synchronization state.)
    //

    NetStatus = RegDeleteKeyA(
                    HKEY_LOCAL_MACHINE,
                    NL_FULL_SYNC_KEY );

    if ( NetStatus != NERR_Success ) {

        if ( NetStatus != ERROR_FILE_NOT_FOUND ) {
            NlPrint((NL_CRITICAL, "Cannot delete Netlogon\\FullSyncKey %lu\n", NetStatus ));
        }

        /* This isn't fatal. Just continue */
    }

    //
    // Tell LSA whether we emulate NT4.0
    //

    LsaINotifyNetlogonParametersChangeW(
           LsaEmulateNT4,
           REG_DWORD,
           (PWSTR)&NlGlobalParameters.Nt4Emulator,
           sizeof(NlGlobalParameters.Nt4Emulator) );

#ifdef notdef
    //
    // Initialize any Hosted domains.
    //

    Status = NlInitializeHostedDomains();
    if (!NT_SUCCESS(Status)){
        NET_API_STATUS NetStatus = NetpNtStatusToApiStatus(Status);

        NlPrint((NL_CRITICAL, "Failed to initialize Hosted domains: 0x%x\n",Status));
        NlExit( SERVICE_UIC_M_DATABASE_ERROR, NetStatus, LogErrorAndNtStatus, NULL);
        return FALSE;
    }
#endif // notdef


    //
    // Successful initialization.
    //

    return TRUE;
}
#endif // _DC_NETLOGON


NET_API_STATUS
NlReadPersitantTrustedDomainList(
    VOID
    )

/*++

Routine Description:

    Read the persistant trusted domain list

Arguments:

    None.

Return Value:

    TRUE -- iff initialization is successful.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    PDOMAIN_INFO DomainInfo = NULL;

    PDS_DOMAIN_TRUSTSW ForestTrustList = NULL;
    ULONG ForestTrustListCount;
    ULONG ForestTrustListSize;

    PDS_DOMAIN_TRUSTSW RegForestTrustList = NULL;
    ULONG RegForestTrustListCount;
    ULONG RegForestTrustListSize;



    //
    // Get pointer to global domain info.
    //

    DomainInfo = NlFindNetbiosDomain( NULL, TRUE );    // Primary domain

    if ( DomainInfo == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Get the cached trusted domain list from the registry.
    //     (Do this even if the data isn't used to force deletion of the registry entry.)
    //
    // The TDL was kept in the registry for NT 4.  NT 5 keeps it in a binary file.
    //

    NetStatus = NlReadRegTrustedDomainList (
                    DomainInfo,
                    TRUE, // Delete this registry key since we no longer need it.
                    &RegForestTrustList,
                    &RegForestTrustListSize,
                    &RegForestTrustListCount );


    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // If NCPA has just joined a domain,
    //  and has pre-determined the trusted domain list for us,
    //  pick up that list.
    //
    // When this machine joins a domain,
    // NCPA caches the trusted domain list where we can find it.  That ensures the
    // trusted domain list is available upon reboot even before we dial via RAS.  Winlogon
    // can therefore get the trusted domain list from us under those circumstances.
    //

    (VOID) NlReadFileTrustedDomainList (
                    DomainInfo,
                    NL_FOREST_BINARY_LOG_FILE_JOIN,
                    TRUE,           // Delete this file since we no longer need it.
                    DS_DOMAIN_VALID_FLAGS,  // Read everything
                    &ForestTrustList,
                    &ForestTrustListSize,
                    &ForestTrustListCount );



    //
    // If there is a cached list,
    //  Save it back in the primary file for future starts.
    //

    if ( ForestTrustListCount ) {
        NlPrint(( NL_INIT,
                  "Replacing trusted domain list with one for newly joined %ws domain.\n",
                  DomainInfo->DomUnicodeDomainName));

        NetStatus = NlWriteFileForestTrustList (
                        NL_FOREST_BINARY_LOG_FILE,
                        ForestTrustList,
                        ForestTrustListCount );

        if ( NetStatus != NO_ERROR ) {
            LPWSTR MsgStrings[2];

            MsgStrings[0] = NL_FOREST_BINARY_LOG_FILE;
            MsgStrings[1] = (LPWSTR) ULongToPtr( NetStatus );

            NlpWriteEventlog (NELOG_NetlogonFailedFileCreate,
                              EVENTLOG_ERROR_TYPE,
                              (LPBYTE) &NetStatus,
                              sizeof(NetStatus),
                              MsgStrings,
                              2 | NETP_LAST_MESSAGE_IS_NETSTATUS );
        }

        //
        // Indicate that we no longer know what site we're in.
        //
        NlSetDynamicSiteName( NULL );

    //
    // Otherwise, read the current one from the binary file.
    //

    } else {
        NlPrint(( NL_INIT, "Getting cached trusted domain list from binary file.\n" ));

        (VOID) NlReadFileTrustedDomainList (
                        DomainInfo,
                        NL_FOREST_BINARY_LOG_FILE,
                        FALSE,  // Don't delete (Save it for the next boot)
                        DS_DOMAIN_VALID_FLAGS,  // Read everything
                        &ForestTrustList,
                        &ForestTrustListSize,
                        &ForestTrustListCount );

        //
        // If there is no information in the file,
        //  use the information from the registry.
        //

        if ( ForestTrustListCount == 0 ) {
            NlPrint(( NL_INIT, "There is no binary file (use registry).\n" ));
            ForestTrustList = RegForestTrustList;
            RegForestTrustList = NULL;
            ForestTrustListSize = RegForestTrustListSize;
            ForestTrustListCount = RegForestTrustListCount;

            //
            // Save the collected information to the binary file.
            //

            NetStatus = NlWriteFileForestTrustList (
                                    NL_FOREST_BINARY_LOG_FILE,
                                    ForestTrustList,
                                    ForestTrustListCount );

            if ( NetStatus != NO_ERROR ) {
                LPWSTR MsgStrings[2];

                MsgStrings[0] = NL_FOREST_BINARY_LOG_FILE;
                MsgStrings[1] = (LPWSTR) ULongToPtr( NetStatus );

                NlpWriteEventlog (NELOG_NetlogonFailedFileCreate,
                                  EVENTLOG_ERROR_TYPE,
                                  (LPBYTE) &NetStatus,
                                  sizeof(NetStatus),
                                  MsgStrings,
                                  2 | NETP_LAST_MESSAGE_IS_NETSTATUS );
            }

        }

    }

    //
    // In all cases, set the trusted domain list into globals.
    //

    (VOID) NlSetForestTrustList( DomainInfo,
                                 &ForestTrustList,
                                 ForestTrustListSize,
                                 ForestTrustListCount );

    NetStatus = NO_ERROR;


    //
    // Return
    //
Cleanup:
    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    if ( ForestTrustList != NULL ) {
        NetApiBufferFree( ForestTrustList );
    }

    if ( RegForestTrustList != NULL ) {
        NetApiBufferFree( RegForestTrustList );
    }

    return NetStatus;
}


BOOL
NlInitWorkstation(
    VOID
    )

/*++

Routine Description:

    Do workstation specific initialization.

Arguments:

    None.

Return Value:

    TRUE -- iff initialization is successful.

--*/
{
    NET_API_STATUS NetStatus;


    //
    // Get the persistant trusted domain list.
    //
    NetStatus = NlReadPersitantTrustedDomainList();

    if ( NetStatus != NO_ERROR ) {
        NlExit( SERVICE_UIC_RESOURCE, NetStatus, LogError, NULL);
        return FALSE;
    }

    return TRUE;

}




NTSTATUS
NlWaitForService(
    LPWSTR ServiceName,
    ULONG Timeout,
    BOOLEAN RequireAutoStart
    )

/*++

Routine Description:

    Wait up to Timeout seconds for the a service to start.

Arguments:

    Timeout - Timeout for event (in seconds).

    RequireAutoStart - TRUE if the service start needs to be automatic.

Return Status:

    STATUS_SUCCESS - Indicates service successfully initialized.

    STATUS_TIMEOUT - Timeout occurred.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    LPQUERY_SERVICE_CONFIG AllocServiceConfig = NULL;
    QUERY_SERVICE_CONFIG DummyServiceConfig;
    DWORD ServiceConfigSize;



    //
    // Open a handle to the Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        NlPrint(( NL_CRITICAL,
                  "NlWaitForService: %ws: OpenSCManager failed: %lu\n",
                  ServiceName,
                  GetLastError()));
        Status = STATUS_TIMEOUT;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        ServiceName,
                        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NlWaitForService: %ws: OpenService failed: %lu\n",
                  ServiceName,
                  GetLastError()));
        Status = STATUS_TIMEOUT;
        goto Cleanup;
    }


    //
    // If need to have automatic service start up and
    // If the service isn't configured to be automatically started
    //  by the service controller, don't bother waiting for it to start.
    // Also don't wait if the service is disabled.
    //
    // ?? Pass "DummyServiceConfig" and "sizeof(..)" since QueryService config
    //  won't allow a null pointer, yet.

    if ( QueryServiceConfig(
            ServiceHandle,
            &DummyServiceConfig,
            sizeof(DummyServiceConfig),
            &ServiceConfigSize )) {

        ServiceConfig = &DummyServiceConfig;

    } else {

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_INSUFFICIENT_BUFFER ) {
            NlPrint(( NL_CRITICAL,
                      "NlWaitForService: %ws: QueryServiceConfig failed: %lu\n",
                      ServiceName,
                      NetStatus));
            Status = STATUS_TIMEOUT;
            goto Cleanup;
        }

        AllocServiceConfig = LocalAlloc( 0, ServiceConfigSize );
        ServiceConfig = AllocServiceConfig;

        if ( AllocServiceConfig == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !QueryServiceConfig(
                ServiceHandle,
                ServiceConfig,
                ServiceConfigSize,
                &ServiceConfigSize )) {

            NlPrint(( NL_CRITICAL,
                      "NlWaitForService: %ws: QueryServiceConfig failed again: %lu\n",
                      ServiceName,
                      GetLastError()));
            Status = STATUS_TIMEOUT;
            goto Cleanup;
        }
    }

    if ( (RequireAutoStart && ServiceConfig->dwStartType != SERVICE_AUTO_START) ||
         (ServiceConfig->dwStartType == SERVICE_DISABLED) ) {
        NlPrint(( NL_CRITICAL,
                  "NlWaitForService: %ws Service start type invalid: %lu\n",
                  ServiceName,
                  ServiceConfig->dwStartType ));
        Status = STATUS_TIMEOUT;
        goto Cleanup;
    }



    //
    // Loop waiting for the service to start.
    //  (Convert Timeout to a number of 5 second iterations)
    //

    Timeout = (Timeout+5)/5;
    for (;;) {


        //
        // Query the status of the service.
        //

        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

            NlPrint(( NL_CRITICAL,
                      "NlWaitForService: %ws: QueryServiceStatus failed: %lu\n",
                      ServiceName,
                      GetLastError() ));
            Status = STATUS_TIMEOUT;
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            Status = STATUS_SUCCESS;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If service failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){
                NlPrint(( NL_CRITICAL,
                          "NlWaitForService: %ws: service couldn't start: %lu %lx\n",
                          ServiceName,
                          ServiceStatus.dwWin32ExitCode,
                          ServiceStatus.dwWin32ExitCode ));
                if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
                    NlPrint(( NL_CRITICAL, "         Service specific error code: %lu %lx\n",
                              ServiceStatus.dwServiceSpecificExitCode,
                              ServiceStatus.dwServiceSpecificExitCode ));
                }
                Status = STATUS_TIMEOUT;
                goto Cleanup;
            }

            //
            // If service has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If service is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
            NlPrint(( NL_CRITICAL,
                      "NlWaitForService: %ws: Invalid service state: %lu\n",
                      ServiceName,
                      ServiceStatus.dwCurrentState ));
            Status = STATUS_TIMEOUT;
            goto Cleanup;

        }


        //
        // Wait five seconds for the service to start.
        //  If it has successfully started, just return now.
        //

        NlPrint(( NL_INIT,
                  "NlWaitForService: %ws: wait for service to start\n",
                  ServiceName ));
        (VOID) WaitForSingleObject( NlGlobalTerminateEvent, 5 * 1000 );

        if ( NlGlobalTerminate ) {
            Status = STATUS_TIMEOUT;
            goto Cleanup;
        }

        if ( !GiveInstallHints( FALSE ) ) {
            Status = STATUS_TIMEOUT;
            goto Cleanup;
        }

        //
        // If we've waited long enough for the service to start,
        //  time out now.
        //

        if ( (--Timeout) == 0 ) {
            Status = STATUS_TIMEOUT;
            goto Cleanup;
        }


    }

    /* NOT REACHED */

Cleanup:
    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    if ( AllocServiceConfig != NULL ) {
        LocalFree( AllocServiceConfig );
    }
    return Status;
}

VOID
NlInitTcpRpc(
    IN LPVOID ThreadParam
)
/*++

Routine Description:

    This function initializes TCP RPC for Netlogon.  It runs in a separate thread
    so that Netlogon need not depend on RPCSS.


Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    ULONG RetryCount;
    RPC_POLICY RpcPolicy;
    DWORD PortNumber = 0;
// #define NL_TOTAL_RPC_SLEEP_TIME (5*60*1000)    // 5 minutes
// #define NL_RPC_SLEEP_TIME (10 * 1000)          // 10 seconds
// #define NL_RPC_RETRY_COUNT (NL_TOTAL_RPC_SLEEP_TIME/NL_RPC_SLEEP_TIME)

    //
    // Set up TCP/IP as a non-authenticated transport.
    //
    // The named pipe transport is authenticated.  Since Netlogon runs as Local
    // System, Kerberos will authenticate using the machine account.  On the BDC/PDC
    // connection, this requires both the PDC and BDC
    // machine account to be in sync.  However, netlogon is responsible for making the
    // BDC account in sync by trying the old and new passwords in NlSessionSetup.  And
    // Netlogon (or DS replication in the future) is responsible for keeping the PDC password
    // in sync.  Thus, it is better to remove Netlogon's dependency on Kerberos authentication.
    //


    //
    // Wait up to 15 minutes for the RPCSS service to start
    //

    Status = NlWaitForService( L"RPCSS", 15 * 60, TRUE );

    if ( Status != STATUS_SUCCESS ) {
        return;
    }

    if ( NlGlobalTerminate ) {
        goto Cleanup;
    }

    //
    // Tell RPC to not fail.  That'll ensure RPC uses TCP when it gets added.
    //
    RtlZeroMemory( &RpcPolicy, sizeof(RpcPolicy) );

    RpcPolicy.Length = sizeof(RpcPolicy);
    RpcPolicy.EndpointFlags = RPC_C_DONT_FAIL;

    // The next statement is explicitly commented out
    //  because we want to honor admin settings and avoid
    //  listening on those NICs which admin has explicitly
    //  configured as such.
    //
    // RpcPolicy.NICFlags = RPC_C_BIND_TO_ALL_NICS;

    //
    // If the port number is configured in the registry, use it
    //

    if ( NlReadDwordNetlogonRegValue("DcTcpipPort", &PortNumber) ) {
        CHAR PortNumberStr[16];

        NlPrint(( NL_INIT, "Using RPC server port %lu\n", PortNumber ));

        _ultoa( PortNumber, PortNumberStr, 10 );

        NetStatus = RpcServerUseProtseqEpExA(
                        "ncacn_ip_tcp",
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                        PortNumberStr,  // port number
                        NULL,           // no security descriptor
                        &RpcPolicy );

        if ( NetStatus != NO_ERROR ) {
            LPWSTR MsgStrings[2];

            NlPrint(( NL_CRITICAL, "Can't RpcServerUseProtseq for port %s: %ld (giving up)\n",
                      PortNumberStr,
                      NetStatus ));

            MsgStrings[0] = NetpAllocWStrFromAStr( PortNumberStr );

            if ( MsgStrings[0] != NULL ) {
                MsgStrings[1] = (LPWSTR) UlongToPtr( NetStatus );

                NlpWriteEventlog( NELOG_NetlogonRpcPortRequestFailure,
                                  EVENTLOG_ERROR_TYPE,
                                  NULL,
                                  0,
                                  MsgStrings,
                                  2 | NETP_LAST_MESSAGE_IS_NETSTATUS );

                NetApiBufferFree( MsgStrings[0] );
            }
        }
    //
    // Otherwise, don't specify the port number.
    //  The end point mapper will choose it dynamically
    //  at the time a client connects to us.
    //

    } else {
        NetStatus = RpcServerUseProtseqExW(
                        L"ncacn_ip_tcp",
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                        NULL,           // no security descriptor
                        &RpcPolicy );

        if ( NetStatus != NO_ERROR ) {
            NlPrint(( NL_CRITICAL, "Can't RpcServerUseProtseq %ld (giving up)\n", NetStatus ));
            goto Cleanup;
        }
    }


    {
        RPC_BINDING_VECTOR *BindingVector = NULL;
        NetStatus = RpcServerInqBindings(&BindingVector);

        if ( NetStatus != NO_ERROR) {
            NlPrint((NL_CRITICAL, "Can't RpcServerInqBindings %ld\n", NetStatus ));
            goto Cleanup;
        }

        //
        // Some early versions of NT 5 still haven't started RPCSS by the time
        //  we get here.
        //
        // for ( RetryCount = NL_RPC_RETRY_COUNT; RetryCount != 0; RetryCount-- ) {
            NetStatus = RpcEpRegister(
                            logon_ServerIfHandle,
                            BindingVector,
                            NULL,                   // no uuid vector
                            L""                     // no annotation
                            );

            if ( NetStatus != NO_ERROR ) {
                NlPrint((NL_CRITICAL, "Can't RpcEpRegister %ld (giving up)\n", NetStatus ));
            }

           //  if (RetryCount == 1 ) {
            // } else {
               //  NlPrint((NL_CRITICAL, "Can't RpcEpRegister %ld (trying again)\n", NetStatus ));
                /// (VOID) WaitForSingleObject( NlGlobalTerminateEvent, NL_RPC_SLEEP_TIME );
            // }
        // }

        RpcBindingVectorFree(&BindingVector);

        if ( NetStatus != NO_ERROR) {
            NlPrint((NL_CRITICAL, "Can't RpcEpRegister %ld\n", NetStatus ));
            goto Cleanup;
        }

        NlGlobalTcpIpRpcServerStarted = TRUE;
    }


    //
    // Finish enabling Netlogon functionality.
    //

Cleanup:
    NlGlobalPartialDisable = FALSE;

    //
    // NlMainLoop avoided doing an immediate announcement when first starting up.
    // To do so would have the BDC call us (the PDC) prior to having TCP/IP RPC enabled.
    // Thus, we do an announcement now to ensure the BDCs do call us as soon as possible
    // after the PDC boots.
    //

    if ( !NlGlobalTerminate && NlGlobalPdcDoReplication ) {
        LOCK_CHANGELOG();
        NlGlobalChangeLogReplicateImmediately = TRUE;
        UNLOCK_CHANGELOG();

        if ( !SetEvent( NlGlobalChangeLogEvent ) ) {
            NlPrint((NL_CRITICAL,
                    "Cannot set ChangeLog event: %lu\n",
                    GetLastError() ));
        }
    }

    NlPrint((NL_INIT, "NlInitTcpRpc thread finished.\n" ));
    UNREFERENCED_PARAMETER( ThreadParam );
}


VOID
NlpDsNotPaused(
    IN PVOID Context,
    IN BOOLEAN TimedOut
    )
/*++

Routine Description:

    Worker routine that gets called when the DS is no longer paused.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NlGlobalDsPaused = FALSE;

    NlPrint((NL_INIT, "DS is no longer paused.\n" ));


    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( TimedOut );
}




BOOL
NlInit(
    VOID
    )

/*++

Routine Description:

    Initialize NETLOGON service related data structs after verfiying that
    all conditions for startup have been satisfied. Will also create a
    mailslot to listen to requests from clients and create two shares to
    allow execution of logon scripts.


Arguments:

    None.

Return Value:

    TRUE -- iff initialization is successful.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS    NetStatus;
    LONG RegStatus;

    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventName;

    NT_PRODUCT_TYPE NtProductType;

    WORD wVersionRequested;
    WSADATA wsaData;
    int err;

    HANDLE WmiInitThreadHandle = NULL;
    DWORD ThreadId;

    //
    // Initialize the AuthZ resource manager on DC
    //

    if ( !NlGlobalMemberWorkstation ) {

        NetStatus = NlInitializeAuthzRM();
        if ( NetStatus != NO_ERROR ) {
            NlExit( NELOG_NetlogonSystemError, NetStatus, LogError, NULL );
            return FALSE;
        }
    }

    //
    // Initialize CryptoAPI provider.
    //

    if ( !CryptAcquireContext(
                    &NlGlobalCryptProvider,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                    ))
    {
        NlGlobalCryptProvider = (HCRYPTPROV)NULL;
        NlExit( NELOG_NetlogonSystemError, GetLastError(), LogError, NULL);
        return FALSE;
    }

    //
    // Let the ChangeLog routines know that Netlogon is started.
    //

    NlGlobalChangeLogNetlogonState = NetlogonStarting;

    //
    // Enable detection of duplicate event log messages
    //
    NetpEventlogSetTimeout ( NlGlobalEventlogHandle,
                             NlGlobalParameters.DuplicateEventlogTimeout*1000 );

    //
    // Don't let MaxConcurrentApi dynamically change
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        NtProductType = NtProductWinNt;
    }

    NlGlobalMaxConcurrentApi = NlGlobalParameters.MaxConcurrentApi;
    if ( NlGlobalMaxConcurrentApi == 0 ) {
        if ( NlGlobalMemberWorkstation ) {

            // Default to 1 concurrent API on a member workstation
            if ( NtProductType == NtProductWinNt ) {
                NlGlobalMaxConcurrentApi = 1;

            // Default to 2 concurrent API on a member server
            } else {
                NlGlobalMaxConcurrentApi = 2;
            }

        } else {
            // Default to 1 concurrent API on a DC
            NlGlobalMaxConcurrentApi = 1;
        }
    }

    if ( NlGlobalMaxConcurrentApi != 1 ) {
        //  One for the original binding and one for each concurrent logon api
        NlGlobalMaxConcurrentApi += 1;
    }


    //
    // Initialize worker threads.
    //

    if ( !NlGlobalMemberWorkstation ) {
        NetStatus = NlWorkerInitialization();
        if ( NetStatus != NO_ERROR ) {
            NlExit( SERVICE_UIC_RESOURCE, NetStatus, LogError, NULL);
            return FALSE;
        }
    }




    //
    // Check that the redirector is installed, will exit on error.
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    if ( !NetpIsServiceStarted( SERVICE_WORKSTATION ) ){
        NlExit( NERR_WkstaNotStarted, ERROR_SERVICE_DEPENDENCY_FAIL, LogError, NULL);
        return FALSE;
    }




    //
    // Create well know SID for netlogon.dll
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    Status =  NetpCreateWellKnownSids( NULL );

    if( !NT_SUCCESS( Status ) ) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        NlExit( SERVICE_UIC_RESOURCE, NetStatus, LogError, NULL);
        return FALSE;
    }


    //
    // Create the security descriptors we'll use for the APIs
    //

    Status = NlCreateNetlogonObjects();

    if ( !NT_SUCCESS(Status) ) {
        NET_API_STATUS NetStatus = NetpNtStatusToApiStatus(Status);

        NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNtStatus, NULL);
        return FALSE;
    }



    //
    // Create Timer event
    //

    NlGlobalTimerEvent = CreateEvent(
                            NULL,       // No special security
                            FALSE,      // Auto Reset
                            FALSE,      // No Timers need no attention
                            NULL );     // No name

    if ( NlGlobalTimerEvent == NULL ) {
        NlExit( NELOG_NetlogonSystemError, GetLastError(), LogErrorAndNetStatus, NULL);
        return FALSE;
    }

#if DBG

    //
    // create debug share. Ignore error.
    //

    if( NlCreateShare(
            NlGlobalDebugSharePath,
            DEBUG_SHARE_NAME,
            FALSE,
            FALSE, // don't update exclusive share access
            FALSE ) != NERR_Success ) {
        NlPrint((NL_CRITICAL, "Can't create Debug share (%ws, %ws).\n",
                    NlGlobalDebugSharePath, DEBUG_SHARE_NAME ));
    }

#endif

    //
    // Initialize winsock.  We need it for all DNS support.
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    wVersionRequested = MAKEWORD( 1, 1 );

    err = WSAStartup( wVersionRequested, &wsaData );
    if ( err == 0 ) {
        if ( LOBYTE( wsaData.wVersion ) != 1 ||
             HIBYTE( wsaData.wVersion ) != 1 ) {
            WSACleanup();
            NlPrint((NL_CRITICAL, "Wrong winsock version (continuing) %ld.\n", wsaData.wVersion ));
        } else {
            NlGlobalWinSockInitialized = TRUE;
        }
    } else {
        NlPrint((NL_CRITICAL, "Can't initialize winsock (continuing) %ld.\n", err ));
    }


    //
    // Open the browser so we can send and receive mailslot messages.
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    if ( !NlBrowserOpen() ) {
        return FALSE;
    }


    //
    // Wait for SAM/LSA to start
    //  Do this before the first access to SAM/LSA/DS.
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    if ( !NlWaitForSamService( TRUE ) ) {
        NlExit( SERVICE_UIC_M_DATABASE_ERROR, ERROR_INVALID_SERVER_STATE, LogError, NULL);
        return FALSE;
    }

    //
    // Re-initialize after netlogon.dll unload
    // See if the DS is running.
    //  I only need this since nltest /unload loses all dll state.

    if ( NlGlobalNetlogonUnloaded ) {
        if ( SampUsingDsData() ) {
            NlPrint((NL_INIT,
                    "Set DS-running bit after netlogon.dll unload\n" ));
            I_NetLogonSetServiceBits( DS_DS_FLAG, DS_DS_FLAG );
        }
        if ( NetpIsServiceStarted( SERVICE_KDC ) ){
            NlPrint((NL_INIT,
                    "Set KDC-running bit after netlogon.dll unload\n" ));
            I_NetLogonSetServiceBits( DS_KDC_FLAG, DS_KDC_FLAG );
        }
    }



    //
    // Initialize the Site lookup code
    //

    NetStatus = NlSiteInitialize();

    if ( NetStatus != NERR_Success ) {
        if ( NetStatus == NELOG_NetlogonBadSiteName ) {
            // Error already logged
            NlExit( NetStatus, NetStatus, DontLogError, NULL);
        } else {
            NlExit( NELOG_NetlogonGetSubnetToSite, NetStatus, LogErrorAndNetStatus, NULL);
        }
        return FALSE;
    }


    //
    // Build a list of transports for later reference
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    NetStatus = NlTransportOpen();

    if ( NetStatus != NERR_Success ) {
        NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL);
        return FALSE;
    }


    //
    // Initialize the Dynamic Dns code
    //

    NetStatus = NlDnsInitialize();

    if ( NetStatus != NERR_Success ) {
        NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL);
        return FALSE;
    }


    //
    // Initialize the Hosted domain module and the primary domain.
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    NetStatus = NlInitializeDomains();

    if ( NetStatus != NERR_Success ) {
        // NlExit already called
        return FALSE;
    }

    //
    // Initialize WMI tracing in a separate thread.
    // Ignore any failure.
    //

    WmiInitThreadHandle =
        CreateThread(
            NULL, // No security attributes
            0,
            (LPTHREAD_START_ROUTINE)
                NlpInitializeTrace,
            NULL,
            0, // No special creation flags
            &ThreadId );

    if ( WmiInitThreadHandle == NULL ) {
        NlPrint(( NL_CRITICAL, "Can't create WMI init thread %ld\n", GetLastError() ));
    } else {
        CloseHandle( WmiInitThreadHandle );
    }

    //
    // Do Workstation or Domain Controller specific initialization
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    if ( NlGlobalMemberWorkstation ) {
        if ( !NlInitWorkstation() ) {
            return FALSE;
        }
    } else {
        if ( !NlInitDomainController() ) {
            return FALSE;
        }
    }

    //
    // Create an event that is signalled when the last MSV thread leaves
    //  a netlogon routine.
    //

    NlGlobalMsvTerminateEvent = CreateEvent( NULL,     // No security attributes
                                             TRUE,     // Must be manually reset
                                             FALSE,    // Initially not signaled
                                             NULL );   // No name

    if ( NlGlobalMsvTerminateEvent == NULL ) {
        NlExit( NELOG_NetlogonSystemError, GetLastError(), LogErrorAndNetStatus, NULL);
        return FALSE;
    }

    NlGlobalMsvEnabled = TRUE;

    //
    // We are now ready to act as a Netlogon service
    //  Enable RPC
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }


    NlPrint((NL_INIT,"Starting RPC server.\n"));

    //
    // Tell RPC that Netlogon support the Netlogon security package.
    //

#ifdef ENABLE_AUTH_RPC
    if ( !NlGlobalMemberWorkstation ) {
        NetStatus = RpcServerRegisterAuthInfo(
                        NL_PACKAGE_NAME,
                        RPC_C_AUTHN_NETLOGON,
                        NULL,
                        NULL );

        if ( NetStatus == RPC_S_UNKNOWN_AUTHN_SERVICE ) {
            NlGlobalServerSupportsAuthRpc = FALSE;
            NlPrint((NL_CRITICAL, "Rpc doesn't support Netlogon Authentication service.  Disable it.\n" ));

        } else if (NetStatus != NERR_Success) {
            NlExit( NELOG_NetlogonFailedToAddRpcInterface, NetStatus, LogErrorAndNetStatus, NULL );
            return FALSE;
        }
    }
#endif // ENABLE_AUTH_RPC

#ifdef ROGUE_DC

    if ( ERROR_SUCCESS != RegOpenKeyExW(
                              HKEY_LOCAL_MACHINE,
                              L"System\\CurrentControlSet\\Services\\Kdc\\Rogue",
                              0,
                              KEY_READ,
                              &NlGlobalRogueKey ))
    {
        NlPrint((NL_CRITICAL, "Failed to read the \"Rogue\" key from registry\n"));
    }

#endif

    //
    // NOTE:  Now all RPC servers in lsass.exe (now winlogon) share the same
    // pipe name.  However, in order to support communication with
    // version 1.0 of WinNt,  it is necessary for the Client Pipe name
    // to remain the same as it was in version 1.0.  Mapping to the new
    // name is performed in the Named Pipe File System code.
    //
    NetStatus = RpcpAddInterface ( L"lsass", logon_ServerIfHandle );

    if (NetStatus != NERR_Success) {
        NlExit( NELOG_NetlogonFailedToAddRpcInterface, NetStatus, LogErrorAndNetStatus, NULL );
        return FALSE;
    }

    NlGlobalRpcServerStarted = TRUE;



    //
    // Start TCP/IP transport in another thread to avoid dependency on RPCSS.
    //

    if ( !NlGlobalMemberWorkstation ) {
        HANDLE LocalThreadHandle;
        DWORD ThreadId;

        NlGlobalPartialDisable = TRUE;

        //
        // Queue the TCP/IP initialization to a high priority worker thread.
        //  (We'd rather not wait for discovery on 100's of trusted domains.)
        //

        NlInitializeWorkItem( &NlGlobalRpcInitWorkItem, NlInitTcpRpc, NULL );
        if ( !NlQueueWorkItem( &NlGlobalRpcInitWorkItem, TRUE, TRUE ) ) {

            NlGlobalPartialDisable = FALSE;

            NlPrint((NL_CRITICAL, "Can't create TcpRpc Thread\n" ));
        }

    }

    //
    // If the DS isn't backsyncing,
    //  avoid overhead of finding out when it is done.
    //

    if ( NlGlobalMemberWorkstation ) {
        NlGlobalDsPaused = FALSE;
    } else {
        NlGlobalDsPaused = LsaIIsDsPaused();

        if ( NlGlobalDsPaused ) {
            NlPrint((NL_INIT, "NlInit: DS is paused.\n" ));

            //
            // Open the event that the DS triggers after it is no longer paused
            //

            NlGlobalDsPausedEvent = OpenEvent( SYNCHRONIZE,
                                               FALSE,
                                               DS_SYNCED_EVENT_NAME_W );

            if ( NlGlobalDsPausedEvent == NULL ) {
                NetStatus = GetLastError();

                NlPrint((NL_CRITICAL, "NlInit: Cannot open DS paused event. %ld\n", NetStatus ));
                NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL);
                return FALSE;
            }

            //
            // Register to wait on the event.
            //

            if ( !RegisterWaitForSingleObject(
                    &NlGlobalDsPausedWaitHandle,
                    NlGlobalDsPausedEvent,
                    NlpDsNotPaused, // Callback routine
                    NULL,           // No context
                    -1,             // Wait forever
                    WT_EXECUTEINWAITTHREAD |      // We're quick so reduce the overhead
                        WT_EXECUTEONLYONCE ) ) {  // Once the DS triggers, we're done

                NetStatus = GetLastError();

                NlPrint((NL_CRITICAL, "NlInit: Cannot register DS paused wait routine. %ld\n", NetStatus ));
                NlExit( NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL);
                return FALSE;
            }


        }

    }




    //
    // Let the ChangeLog routines know that Netlogon is started.
    //

    NlGlobalChangeLogNetlogonState = NetlogonStarted;


    // Set an event telling anyone wanting to call NETLOGON that we're
    // initialized.
    //

    if ( !GiveInstallHints( FALSE ) ) {
        return FALSE;
    }

    RtlInitUnicodeString( &EventName, L"\\NETLOGON_SERVICE_STARTED");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtCreateEvent(
                   &NlGlobalStartedEvent,
                   SYNCHRONIZE|EVENT_MODIFY_STATE,
                   &EventAttributes,
                   NotificationEvent,
                   (BOOLEAN) FALSE      // The event is initially not signaled
                   );

    if ( !NT_SUCCESS(Status)) {

        //
        // If the event already exists, a waiting thread beat us to
        // creating it.  Just open it.
        //

        if( Status == STATUS_OBJECT_NAME_EXISTS ||
            Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = NtOpenEvent( &NlGlobalStartedEvent,
                                    SYNCHRONIZE|EVENT_MODIFY_STATE,
                                    &EventAttributes );

        }
        if ( !NT_SUCCESS(Status)) {
            NET_API_STATUS NetStatus = NetpNtStatusToApiStatus(Status);

            NlPrint((NL_CRITICAL,
                    " Failed to open NETLOGON_SERVICE_STARTED event. %lX\n",
                     Status ));
            NlPrint((NL_CRITICAL,
                    "        Failing to initialize SAM Server.\n"));
            NlExit( SERVICE_UIC_SYSTEM, NetStatus, LogError, NULL);
            return FALSE;
        }
    }

    Status = NtSetEvent( NlGlobalStartedEvent, NULL );
    if ( !NT_SUCCESS(Status)) {
        NET_API_STATUS NetStatus = NetpNtStatusToApiStatus(Status);

        NlPrint((NL_CRITICAL,
                 "Failed to set NETLOGON_SERVICE_STARTED event. %lX\n",
                 Status ));
        NlPrint((NL_CRITICAL, "        Failing to initialize SAM Server.\n"));

        NtClose(NlGlobalStartedEvent);
        NlExit( SERVICE_UIC_SYSTEM, NetStatus, LogError, NULL);
        return FALSE;
    }

    //
    // Don't close the event handle.  Closing it would delete the event and
    //  a future waiter would never see it be set.
    //


    //
    // Query the Windows Time service to determine if this machine
    // is the server of the Time service and if it is a good time server.
    //
    // We need to make this call after we've started RPC to avoid race
    // conditions between netlogon and w32time.  Both services will first
    // start RPC and only then will try to set the service bits in netlogon.
    // The last one up will correctly set the bits through calling
    // W32TimeGetNetlogonServiceBits (in the case of netlogon) or
    // I_NetLogonSetServiceBits (in the case of w32time).
    //
    // ???: Relink to the w32tclnt.lib when w32time folks move it to a
    //  public location.
    //

    if ( !NlGlobalMemberWorkstation ) {
        ULONG TimeServiceBits;

        NetStatus = W32TimeGetNetlogonServiceBits( NULL, &TimeServiceBits );

        if ( NetStatus == NO_ERROR ) {
            Status = I_NetLogonSetServiceBits( DS_TIMESERV_FLAG | DS_GOOD_TIMESERV_FLAG,
                                               TimeServiceBits );
            if ( !NT_SUCCESS(Status) ) {
                NlPrint(( NL_CRITICAL, "Cannot I_NetLogonSetServiceBits %ld\n", Status ));
            }
        } else {
            NlPrint(( NL_CRITICAL, "Cannot W32TimeGetNetlogonServiceBits 0x%lx\n", NetStatus ));
        }
    }

    //
    // we are just about done, this will be final hint
    //

    if ( !GiveInstallHints( TRUE ) ) {
        return FALSE;
    }

    //
    // Successful initialization.
    //

    return TRUE;
}

ULONG
NlGetDomainFlags(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Returns the flags describing what capabilities this Domain has.

Arguments:

    DomainInfo - Domain whose flags are to be returned.
        If NULL, only non-domain specific flags are returned.

Return Value:

    Status of the operation.

--*/
{
    ULONG Flags=0;

    //
    // Grab the global flags.
    //

    LOCK_CHANGELOG();
    Flags |= NlGlobalChangeLogServiceBits;
    UNLOCK_CHANGELOG();

    //
    // A machine that supports the DS also supports an LDAP server
    //

    if ( Flags & DS_DS_FLAG ) {
        Flags |= DS_LDAP_FLAG;

        // NT 5 DCs are always writable
        Flags |= DS_WRITABLE_FLAG;
    }

    //
    // Grab the domain specific flags.
    //

    if ( DomainInfo != NULL ) {

        if ( DomainInfo->DomRole == RolePrimary ) {
            Flags |= DS_PDC_FLAG;
        }

        //
        // If this is NDNC, we are only an LDAP server servicing it.
        //  So, set only those two flags and only if the DS is running.
        //
        if ( (DomainInfo->DomFlags & DOM_NON_DOMAIN_NC) != 0 &&
             (Flags & DS_DS_FLAG) != 0 ) {
            Flags = DS_NDNC_FLAG | DS_LDAP_FLAG | DS_WRITABLE_FLAG;
        }

    }

    //
    // If we're emulating AD/UNIX,
    //  turn off all of the bits they're not allowed to set.
    //
#ifdef EMULATE_AD_UNIX
    Flags &= ~(DS_DS_FLAG|DS_PDC_FLAG);
#endif // EMULATE_AD_UNIX

    return Flags;
}


NET_API_STATUS
BuildSamLogonResponse(
    IN PDOMAIN_INFO DomainInfo,
    IN BOOLEAN UseNameAliases,
    IN USHORT Opcode,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN LPCWSTR TransportName,
    IN LPCWSTR UnicodeWorkstationName,
    IN BOOL IsNt5,
    IN DWORD OurIpAddress,
    OUT BYTE ResponseBuffer[NETLOGON_MAX_MS_SIZE],
    OUT LPDWORD ResponseBufferSize
    )
/*++

Routine Description:

    Build the response message to a SAM Logon request.

Arguments:

    DomainInfo - Hosted Domain message came from

    UseNameAliases - TRUE if domain and forest name aliases (not active names)
        should be returned in the response message.

    Opcode - Opcode for the response message

    UnicodeUserName - The name of the user logging on.

    TransportName - Name of transport the request came in on

    UnicodeWorkstationName - Name of the machine the request is from

    IsNt5 - True if this is a response to an NT 5 query.

    OurIpAddress - IP Address of the transport this message was received on.
        0: Not an IP transport

    ResponseBuffer - Buffer to build the response in

    ResponseBufferSize - Size (in bytes) of the returned message.

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    PCHAR Where;
    PNETLOGON_SAM_LOGON_RESPONSE SamResponse = (PNETLOGON_SAM_LOGON_RESPONSE) ResponseBuffer;
    ULONG ResponseNtVersion = 0;

    //
    // Pack the pre-NT 5.0 information.
    //

    SamResponse->Opcode = Opcode;

    Where = (PCHAR) SamResponse->UnicodeLogonServer;
    NetpLogonPutUnicodeString( DomainInfo->DomUncUnicodeComputerName,
                         sizeof(SamResponse->UnicodeLogonServer),
                         &Where );
    NetpLogonPutUnicodeString( (LPWSTR) UnicodeUserName,
                         sizeof(SamResponse->UnicodeUserName),
                         &Where );
    NetpLogonPutUnicodeString( DomainInfo->DomUnicodeDomainName,
                         sizeof(SamResponse->UnicodeDomainName),
                         &Where );

    //
    // Append GUID and DNS info if this is NT 5.0 asking,
    //

    if ( IsNt5 ) {
        WORD CompressOffset[3]; // One per compressessed String
        CHAR *CompressUtf8String[3];
        ULONG CompressCount;

        ULONG Utf8StringSize;
        ULONG Flags = 0;
        UCHAR ZeroByte = 0;

        NetpLogonPutGuid( &DomainInfo->DomDomainGuidBuffer,
                          &Where );

        // We don't handle the site GUID.
        NetpLogonPutGuid( &NlGlobalZeroGuid,
                          &Where );

        //
        // If we're not responding to a message on an IP transport,
        //  don't include DNS naming information in the response.
        //

        if ( OurIpAddress == 0 ) {
            //
            // This routine is only called if the original caller used a Netbios domain name.
            // Such a caller shouldn't be returned the DNS domain information.  We have
            // no reason to believe he has a DNS server.
            // (This problem is also "fixed" on the client side such that the client ignores
            // the DNS info.  We're fixing it here to avoid putting the extra bytes on the wire.)
            //
            // Copy NULL Dns Tree name, dns domain name, and dns host name
            //
            NetpLogonPutBytes( &ZeroByte, 1, &Where );
            NetpLogonPutBytes( &ZeroByte, 1, &Where );
            NetpLogonPutBytes( &ZeroByte, 1, &Where );
        } else {

            //
            // Initialize for copying Cutf-8 strings.
            //

            Utf8StringSize = sizeof(SamResponse->DnsForestName) +
                             sizeof(SamResponse->DnsDomainName) +
                             sizeof(SamResponse->DnsHostName);

            CompressCount = 0;  // No strings compressed yet.


            //
            // Copy the DnsTree name into the message.
            //
            // If we are instructed to use name aliases and
            //  there is an alias for forest name, use it.
            //  Otherwise, use the active forest name.
            //


            EnterCriticalSection( &NlGlobalDnsForestNameCritSect );
            NetStatus = NlpUtf8ToCutf8( ResponseBuffer,
                                        (UseNameAliases && NlGlobalUtf8DnsForestNameAlias) ?
                                            NlGlobalUtf8DnsForestNameAlias :
                                            NlGlobalUtf8DnsForestName,
                                        FALSE,
                                        &Where,
                                        &Utf8StringSize,
                                        &CompressCount,
                                        CompressOffset,
                                        CompressUtf8String );
            LeaveCriticalSection( &NlGlobalDnsForestNameCritSect );

            if ( NetStatus != NO_ERROR ) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "Cannot pack DnsForestName into message %ld\n",
                        NetStatus ));
                return NetStatus;
            }


            //
            // Copy the Dns Domain Name after the Tree name.
            //
            // If we are instructed to use name aliases and
            //  there is an alias for the domain name, use it.
            //  Otherwise, use the active domain name.
            //

            EnterCriticalSection(&NlGlobalDomainCritSect);
            NetStatus = NlpUtf8ToCutf8(
                            ResponseBuffer,
                            (UseNameAliases && DomainInfo->DomUtf8DnsDomainNameAlias) ?
                                DomainInfo->DomUtf8DnsDomainNameAlias :
                                DomainInfo->DomUtf8DnsDomainName,
                            FALSE,
                            &Where,
                            &Utf8StringSize,
                            &CompressCount,
                            CompressOffset,
                            CompressUtf8String );
            LeaveCriticalSection(&NlGlobalDomainCritSect);

            if ( NetStatus != NO_ERROR ) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "Cannot pack DomainName into message %ld\n",
                        NetStatus ));
                return NetStatus;
            }

            //
            // Copy the Dns Host Name after the domain name.
            //

            NetStatus = NlpUtf8ToCutf8(
                            ResponseBuffer,
                            DomainInfo->DomUtf8DnsHostName,
                            FALSE,
                            &Where,
                            &Utf8StringSize,
                            &CompressCount,
                            CompressOffset,
                            CompressUtf8String );

            if ( NetStatus != NO_ERROR ) {
                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "Cannot pack HostName into message %ld\n",
                        NetStatus ));
                return NetStatus;
            }

        }

        //
        // Output the IP address of the transport we received the message on.
        //

        SmbPutUlong( Where, ntohl(OurIpAddress));
        Where += sizeof(ULONG);

        //
        // Finally output the flags describing this machine.
        //

        SmbPutUlong( Where, NlGetDomainFlags(DomainInfo) );
        Where += sizeof(ULONG);


        //
        // Tell the caller additional information is present.
        //
        ResponseNtVersion |= NETLOGON_NT_VERSION_5;
    }

    NetpLogonPutNtToken( &Where, ResponseNtVersion );

    *ResponseBufferSize = (DWORD)(Where - (PCHAR)SamResponse);

    //
    // Always good to debug
    //

    NlPrintDom((NL_MAILSLOT, DomainInfo,
            "Ping response '%s' %ws to \\\\%ws on %ws\n",
            NlMailslotOpcode(Opcode),
            UnicodeUserName,
            UnicodeWorkstationName,
            TransportName ));


    return NO_ERROR;

}


NET_API_STATUS
BuildSamLogonResponseEx(
    IN PDOMAIN_INFO DomainInfo,
    IN BOOLEAN UseNameAliases,
    IN USHORT Opcode,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN BOOL IsDnsDomainTrustAccount,
    IN LPCWSTR TransportName,
    IN LPCWSTR UnicodeWorkstationName,
    IN PSOCKADDR ClientSockAddr OPTIONAL,
    IN ULONG VersionFlags,
    IN DWORD OurIpAddress,
    OUT BYTE ResponseBuffer[NETLOGON_MAX_MS_SIZE],
    OUT LPDWORD ResponseBufferSize
    )
/*++

Routine Description:

    Build the extended response message to a SAM Logon request.

Arguments:

    DomainInfo - Hosted Domain message came from

    UseNameAliases - TRUE if domain and forest name aliases (not active names)
        should be returned in the response message.

    Opcode - Opcode for the response message
        This is the non-EX version of the opcode.

    UnicodeUserName - The name of the user logging on.

    IsDnsDomainTrustAccount - If TRUE, UnicodeUserName is the
        name of a DNS domain trust account.

    TransportName - Name of transport the request came in on

    UnicodeWorkstationName - The name of the workstation we're responding to.

    ClientSockAddr - Socket Address of the client this request came in on.
        If NULL, the client is this machine.

    VersionFlags - Version flags from the caller.

    OurIpAddress - IP Address of the transport this message was received on.
        0: Not an IP transport

    ResponseBuffer - Buffer to build the response in

    ResponseBufferSize - Size (in bytes) of the returned message.

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    PCHAR Where;
    PNETLOGON_SAM_LOGON_RESPONSE_EX SamResponse = (PNETLOGON_SAM_LOGON_RESPONSE_EX) ResponseBuffer;
    ULONG ResponseNtVersion = 0;
    WORD CompressOffset[10];
    CHAR *CompressUtf8String[10];
    ULONG CompressCount = 0;
    ULONG Utf8StringSize;
    ULONG LocalFlags = 0;
    ULONG LocalVersion = 0;
    PNL_SITE_ENTRY ClientSiteEntry = NULL;
    LPWSTR ClientSiteName = NULL;
    WCHAR CapturedSiteName[NL_MAX_DNS_LABEL_LENGTH+1];
    LPSTR LocalUtf8UserName = NULL;

    //
    // Compute the name of the site the client machine is in.
    //

    if ( ClientSockAddr != NULL ) {

        ClientSiteEntry = NlFindSiteEntryBySockAddr( ClientSockAddr );

        if ( ClientSiteEntry == NULL ) {
            WCHAR IpAddressString[NL_SOCK_ADDRESS_LENGTH+1];

            NetpSockAddrToWStr( ClientSockAddr,
                                sizeof(SOCKADDR_IN),
                                IpAddressString );

            //
            // Passing 0 as the bit mask will force the
            //  log output even if DbFlag == 0. We point to
            //  this output from the event log written at
            //  scavenging time, so don't change the format
            //  of the output here.
            //
            NlPrintDom(( 0, DomainInfo,
                         "NO_CLIENT_SITE: %ws %ws\n",
                         UnicodeWorkstationName,
                         IpAddressString ));

            //
            // If this is the first no site client,
            //  set the timestamp for this observation window
            //
            EnterCriticalSection( &NlGlobalSiteCritSect );
            if ( NlGlobalNoClientSiteCount == 0 ) {
                NlQuerySystemTime( &NlGlobalNoClientSiteEventTime );
            }

            //
            // Increment the number of clients with no site
            //  we hit during this timeout period
            //
            NlGlobalNoClientSiteCount ++;
            LeaveCriticalSection( &NlGlobalSiteCritSect );

        } else {
            ULONG SiteIndex;

            ClientSiteName = ClientSiteEntry->SiteName;

            EnterCriticalSection( &NlGlobalSiteCritSect );
            if ( VersionFlags & NETLOGON_NT_VERSION_GC ) {
                for ( SiteIndex = 0; SiteIndex < DomainInfo->GcCoveredSitesCount; SiteIndex++ ) {
                    if ( (DomainInfo->GcCoveredSites)[SiteIndex].CoveredSite == ClientSiteEntry ) {
                        LocalFlags |= DS_CLOSEST_FLAG;
                        break;
                    }
                }
            } else {
                for ( SiteIndex = 0; SiteIndex < DomainInfo->CoveredSitesCount; SiteIndex++ ) {
                    if ( (DomainInfo->CoveredSites)[SiteIndex].CoveredSite == ClientSiteEntry ) {
                        LocalFlags |= DS_CLOSEST_FLAG;
                        break;
                    }
                }
            }
            LeaveCriticalSection( &NlGlobalSiteCritSect );
        }
    } else {

        //
        // If this is a loopback call,
        //  we already know our site name.
        //  (And it is the closest site.)
        //

        if ( VersionFlags & NETLOGON_NT_VERSION_LOCAL ) {
            if  ( NlCaptureSiteName( CapturedSiteName ) ) {
                ClientSiteName = CapturedSiteName;
                LocalFlags |= DS_CLOSEST_FLAG;
            }
        } else {
            NlPrintDom((NL_SITE, DomainInfo,
                    "Client didn't pass us his IP Address. (No site returned)\n" ));
        }
    }



    //
    // Pack the opcode converting it to the _EX version
    //

    switch ( Opcode ) {
    case LOGON_SAM_LOGON_RESPONSE:
        Opcode = LOGON_SAM_LOGON_RESPONSE_EX; break;
    case LOGON_SAM_PAUSE_RESPONSE:
        Opcode = LOGON_SAM_PAUSE_RESPONSE_EX; break;
    case LOGON_SAM_USER_UNKNOWN:
        Opcode = LOGON_SAM_USER_UNKNOWN_EX; break;
    }

    SamResponse->Opcode = Opcode;
    SamResponse->Sbz = 0;

    //
    // Output the flags describing this machine.
    //

    SamResponse->Flags = LocalFlags | NlGetDomainFlags(DomainInfo);

    //
    // Output the GUID of this domain.
    //

    Where = (PCHAR) &SamResponse->DomainGuid;
    NetpLogonPutGuid( &DomainInfo->DomDomainGuidBuffer,
                      &Where );

    //
    // Initialize for copying Cutf-8 strings.
    //

    Utf8StringSize = sizeof(SamResponse->DnsForestName) +
                     sizeof(SamResponse->DnsDomainName) +
                     sizeof(SamResponse->DnsHostName) +
                     sizeof(SamResponse->NetbiosDomainName) +
                     sizeof(SamResponse->NetbiosComputerName) +
                     sizeof(SamResponse->UserName) +
                     sizeof(SamResponse->DcSiteName) +
                     sizeof(SamResponse->ClientSiteName);

    CompressCount = 0;  // No strings compressed yet.


    //
    // Copy the DnsTree name into the message.
    //
    // If we are instructed to use name aliases and
    //  there is an alias for forest name, use it.
    //  Otherwise, use the active forest name.
    //

    EnterCriticalSection( &NlGlobalDnsForestNameCritSect );
    NetStatus = NlpUtf8ToCutf8( ResponseBuffer,
                                (UseNameAliases && NlGlobalUtf8DnsForestNameAlias) ?
                                    NlGlobalUtf8DnsForestNameAlias :
                                    NlGlobalUtf8DnsForestName,
                                FALSE,
                                &Where,
                                &Utf8StringSize,
                                &CompressCount,
                                CompressOffset,
                                CompressUtf8String );
    LeaveCriticalSection( &NlGlobalDnsForestNameCritSect );

    if ( NetStatus != NO_ERROR ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "Cannot pack DnsForestName into message %ld\n",
                NetStatus ));
        goto Cleanup;
    }

    //
    // Copy the Dns Domain Name after the Tree name.
    //
    // If we are instructed to use name aliases and
    //  there is an alias for the domain name, use it.
    //  Otherwise, use the active domain name.
    //

    EnterCriticalSection(&NlGlobalDomainCritSect);
    NetStatus = NlpUtf8ToCutf8(
                    ResponseBuffer,
                    (UseNameAliases && DomainInfo->DomUtf8DnsDomainNameAlias) ?
                        DomainInfo->DomUtf8DnsDomainNameAlias :
                        DomainInfo->DomUtf8DnsDomainName,
                    FALSE,
                    &Where,
                    &Utf8StringSize,
                    &CompressCount,
                    CompressOffset,
                    CompressUtf8String );
    LeaveCriticalSection(&NlGlobalDomainCritSect);

    if ( NetStatus != NO_ERROR ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "Cannot pack DomainName into message %ld\n",
                NetStatus ));
        goto Cleanup;
    }

    //
    // Copy the Dns Host Name after the domain name.
    //

    NetStatus = NlpUtf8ToCutf8(
                    ResponseBuffer,
                    DomainInfo->DomUtf8DnsHostName,
                    FALSE,
                    &Where,
                    &Utf8StringSize,
                    &CompressCount,
                    CompressOffset,
                    CompressUtf8String );

    if ( NetStatus != NO_ERROR ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "Cannot pack HostName into message %ld\n",
                NetStatus ));
        goto Cleanup;
    }

    //
    // Copy the Netbios domain name
    //

    NetStatus = NlpUnicodeToCutf8(
                    ResponseBuffer,
                    DomainInfo->DomUnicodeDomainName,
                    TRUE,
                    &Where,
                    &Utf8StringSize,
                    &CompressCount,
                    CompressOffset,
                    CompressUtf8String );

    if ( NetStatus != NO_ERROR ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "Cannot pack Netbios Domain Name into message %ld\n",
                NetStatus ));
        goto Cleanup;
    }

    //
    // Copy the Netbios computer name
    //

    NetStatus = NlpUnicodeToCutf8(
                    ResponseBuffer,
                    DomainInfo->DomUnicodeComputerNameString.Buffer,
                    TRUE,
                    &Where,
                    &Utf8StringSize,
                    &CompressCount,
                    CompressOffset,
                    CompressUtf8String );

    if ( NetStatus != NO_ERROR ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "Cannot pack Netbios computername into message %ld\n",
                NetStatus ));
        goto Cleanup;
    }

    //
    // Copy the UserName
    //

    if ( UnicodeUserName != NULL && *UnicodeUserName != UNICODE_NULL ) {

        LocalUtf8UserName = NetpAllocUtf8StrFromWStr( UnicodeUserName );
        if ( LocalUtf8UserName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // For SAM account names we are going to truncate the name
        //  to 63 bytes max to fit it into the space allowed for a
        //  single label by RFC 1035.  Note that this should be fine
        //  because valid SAM account names are limited to 20 characters
        //  (which is at most 60 bytes for UTF-8 character storage).
        //  Therefore our response for long (truncated) SAM names is
        //  going to be SAM_USER_UNKNOWN in which case the client will
        //  skip the verification of the returned (truncated) account name.
        //

        if ( !IsDnsDomainTrustAccount &&  // => SAM account name
             strlen(LocalUtf8UserName) > NL_MAX_DNS_LABEL_LENGTH ) {

            NlAssert( Opcode == LOGON_SAM_USER_UNKNOWN_EX );
            NlPrintDom(( (Opcode == LOGON_SAM_USER_UNKNOWN_EX) ? NL_MISC : NL_CRITICAL,
                         DomainInfo,
                         "BuildSamLogonResponseEx: Truncating SAM account name %ws for Opcode %lu\n",
                         UnicodeUserName,
                         Opcode ));
            LocalUtf8UserName[ NL_MAX_DNS_LABEL_LENGTH ] = '\0';
        }
    }

    //
    // Always ignore dots for user name (even if this is a DNS domain name)
    //  to preserve the last period in the DNS domain trust name.
    //

    NetStatus = NlpUtf8ToCutf8(
                    ResponseBuffer,
                    LocalUtf8UserName,
                    TRUE,    // Ignore dots
                    &Where,
                    &Utf8StringSize,
                    &CompressCount,
                    CompressOffset,
                    CompressUtf8String );

    if ( NetStatus != NO_ERROR ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "Cannot pack User Name into message %ld\n",
                NetStatus ));
        goto Cleanup;
    }


    //
    // Copy the Name of the site this DC is in.
    //

    NetStatus = NlpUtf8ToCutf8( ResponseBuffer,
                                NlGlobalUtf8SiteName,
                                FALSE,
                                &Where,
                                &Utf8StringSize,
                                &CompressCount,
                                CompressOffset,
                                CompressUtf8String );

    if ( NetStatus != NO_ERROR ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "Cannot pack DcSiteName into message %ld\n",
                NetStatus ));
        goto Cleanup;
    }


    //
    // Copy the Name of the site the client machine is in.
    //

    NetStatus = NlpUnicodeToCutf8( ResponseBuffer,
                                   ClientSiteName,
                                   FALSE,
                                   &Where,
                                   &Utf8StringSize,
                                   &CompressCount,
                                   CompressOffset,
                                   CompressUtf8String );

    if ( NetStatus != NO_ERROR ) {
        NlPrintDom((NL_CRITICAL, DomainInfo,
                "Cannot pack ClientSiteName into message %ld\n",
                NetStatus ));
        goto Cleanup;
    }

    //
    // If the caller wants it,
    //  output the IP address of the transport we received the message on.
    //

    if ( OurIpAddress &&
         (VersionFlags & NETLOGON_NT_VERSION_5EX_WITH_IP) != 0 ) {
        SOCKADDR_IN DcSockAddrIn;
        CHAR DcSockAddrSize;

        //
        // Convert the IP address to a SockAddr.
        //
        RtlZeroMemory( &DcSockAddrIn, sizeof(DcSockAddrIn) );
        DcSockAddrIn.sin_family = AF_INET;
        DcSockAddrIn.sin_port = 0;
        DcSockAddrIn.sin_addr.S_un.S_addr = OurIpAddress;

        DcSockAddrSize = sizeof(SOCKADDR_IN);

        //
        // Put the size of the SockAddr into the message
        //  provided we still have room left
        //

        if ( sizeof(DcSockAddrIn) > Utf8StringSize ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                         "Not enough space for socket address 0x%lx 0x%lx\n",
                         Utf8StringSize,
                         sizeof(DcSockAddrIn) ));
        } else {
            NetpLogonPutBytes( &DcSockAddrSize, 1, &Where ); // This has dedicated field

            //
            // Put the SockAddr itself into the message
            //
            NetpLogonPutBytes( &DcSockAddrIn, sizeof(DcSockAddrIn), &Where );

            //
            // Tell the caller that the size field is there.
            //
            LocalVersion |= NETLOGON_NT_VERSION_5EX_WITH_IP;
        }
    }

    //
    // Set the version of this message.
    //

    NetpLogonPutNtToken( &Where, NETLOGON_NT_VERSION_5EX | LocalVersion );

    *ResponseBufferSize = (DWORD)(Where - (PCHAR)SamResponse);

    NetStatus = NO_ERROR;

    //
    // Free locally used resources;
    //

Cleanup:

    //
    // Always good to debug
    //

    NlPrintDom((NL_MAILSLOT, DomainInfo,
            "Ping response '%s' %ws to \\\\%ws Site: %ws on %ws\n",
            NlMailslotOpcode(Opcode),
            UnicodeUserName,
            UnicodeWorkstationName,
            ClientSiteName,
            TransportName ));

    if ( LocalUtf8UserName != NULL ) {
        NetpMemoryFree( LocalUtf8UserName );
    }

    if ( ClientSiteEntry != NULL ) {
        NlDerefSiteEntry( ClientSiteEntry );
    }

    return NetStatus;
}

#ifdef _DC_NETLOGON
NTSTATUS
NlSamVerifyUserAccountEnabled(
    IN PDOMAIN_INFO DomainInfo,
    IN LPCWSTR AccountName,
    IN ULONG AllowableAccountControlBits,
    IN BOOL CheckAccountDisabled
    )
/*++

Routine Description:

    Verify whether the user account exists and is enabled.
    This function uses efficient version of SAM account lookup,
    namely SamINetLogonPing (as opposed to SamIOpenNamedUser).

Arguments:

    DomainInfo - Hosted Domain

    AccountName - The name of the user account to check

    AllowableAccountControlBits - A mask of allowable SAM account types that
        are allowed to satisfy this request.

    CheckAccountDisabled - TRUE if we should return an error if the account
        is disabled.

Return Value:

    STATUS_SUCCESS -- The account has been verified
    STATUS_NO_SUCH_USER -- The account has failed to verify
    Otherwise, an error returned by SamINetLogonPing

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UserNameString;
    BOOLEAN AccountExists;
    ULONG UserAccountControl;
    ULONG Length;

    //
    // Ensure the account name has the correct postfix.
    //

    if ( AllowableAccountControlBits == USER_SERVER_TRUST_ACCOUNT ||
         AllowableAccountControlBits == USER_WORKSTATION_TRUST_ACCOUNT ) {

        Length = wcslen( AccountName );

        if ( Length <= SSI_ACCOUNT_NAME_POSTFIX_LENGTH ) {
            return STATUS_NO_SUCH_USER;
        }

        if ( _wcsicmp(&AccountName[Length - SSI_ACCOUNT_NAME_POSTFIX_LENGTH],
            SSI_ACCOUNT_NAME_POSTFIX) != 0 ) {
            return STATUS_NO_SUCH_USER;
        }
    }

    //
    // User accounts exist only in real domains
    //

    if ( (DomainInfo->DomFlags & DOM_REAL_DOMAIN) == 0 ) {

        NlPrintDom(( NL_CRITICAL, DomainInfo,
                     "NlSamVerifyUserAccountEnabled: Domain is not real 0x%lx\n",
                     DomainInfo->DomFlags ));
        return STATUS_NO_SUCH_USER;
    }


    RtlInitUnicodeString( &UserNameString, AccountName );

    //
    // Call the expedite version of SAM user lookup
    //

    Status = SamINetLogonPing( DomainInfo->DomSamAccountDomainHandle,
                               &UserNameString,
                               &AccountExists,
                               &UserAccountControl );

    if ( !NT_SUCCESS(Status) ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                     "NlSamVerifyUserAccountEnabled: SamINetLogonPing failed 0x%lx\n",
                     Status ));
        return Status;
    }

    //
    // If the account doesn't exist,
    //  return now
    //

    if ( !AccountExists ) {
        return STATUS_NO_SUCH_USER;
    }

    //
    // Ensure the Account type matches the account type on the account.
    //

    if ( (UserAccountControl & USER_ACCOUNT_TYPE_MASK & AllowableAccountControlBits) == 0 ) {
        NlPrintDom(( NL_CRITICAL, DomainInfo,
                     "NlSamVerifyUserAccountEnabled: Invalid account type (0x%lx) instead of 0x%lx for %ws\n",
                     UserAccountControl & USER_ACCOUNT_TYPE_MASK,
                     AllowableAccountControlBits,
                     AccountName ));

        return STATUS_NO_SUCH_USER;
    }

    //
    // Check if the account is disabled if requested
    //

    if ( CheckAccountDisabled ) {
        if ( UserAccountControl & USER_ACCOUNT_DISABLED ) {
            NlPrintDom(( NL_MISC, DomainInfo,
                         "NlSamVerifyUserAccountEnabled: %ws account is disabled\n",
                         AccountName ));
            return STATUS_NO_SUCH_USER;
        }
    }

    //
    // All checks succeeded
    //

    return STATUS_SUCCESS;
}


BOOLEAN
LogonRequestHandler(
    IN LPCWSTR TransportName,
    IN PDOMAIN_INFO DomainInfo,
    IN BOOLEAN UseNameAliases,
    IN PSID DomainSid OPTIONAL,
    IN DWORD Version,
    IN DWORD VersionFlags,
    IN LPCWSTR UnicodeUserName,
    IN DWORD RequestCount,
    IN LPCWSTR UnicodeWorkstationName,
    IN ULONG AllowableAccountControlBits,
    IN DWORD OurIpAddress,
    IN PSOCKADDR ClientSockAddr OPTIONAL,
    OUT BYTE ResponseBuffer[NETLOGON_MAX_MS_SIZE],
    OUT LPDWORD ResponseBufferSize
    )

/*++

Routine Description:

    Respond appropriate to an LM 2.0 or NT 3.x logon request.

Arguments:

    TransportName - Name of the transport the request came in on

    DomainInfo - Hosted Domain message came from

    UseNameAliases - TRUE if domain and forest name aliases (not active names)
        should be returned in the response message.

    DomainSid - If specified, must match the DomainSid of the sid specified by
        DomainInfo.

    Version - The version of the input message.  This parameter determine
        the version of the response.

    VersionFlags - The version flag bit from the input messge

    UnicodeUserName - The name of the user logging on.

    RequestCount - The number of times this user has repeated the logon request.

    UnicodeWorkstationName - The name of the workstation where the user is
        logging onto.

    AllowableAccountControlBits - A mask of allowable SAM account types that
        are allowed to satisfy this request.

    OurIpAddress - IP Address of the transport this message was received on.
        0: Not an IP transport

    ClientSockAddr - Socket Address of the client this request came in on.
        If NULL, the client is this machine.

    ResponseBuffer - Buffer to build the response in

    ResponseBufferSize - Size (in bytes) of the returned message.

Return Value:

    TRUE if this query should be responded to (the ResponseBuffer was filled in)

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NET_API_STATUS NetStatus = NO_ERROR;

    USHORT Response = 0;

    PCHAR Where;
    ULONG AccountType;
    BOOLEAN MessageBuilt = FALSE;
    BOOLEAN NetlogonPaused = FALSE;
    LPSTR NetlogonPausedReason;

    ULONG ResponseNtVersion = 0;
    BOOL IsDnsDomainTrustAccount = FALSE;

    //
    // If we are emulating NT4.0 domain and the client
    //  didn't indicate to neutralize the emulation,
    //  treat the client as NT4.0 client. That way we
    //  won't leak NT5.0 specific info to the client.
    //

    if ( NlGlobalParameters.Nt4Emulator &&
         (VersionFlags & NETLOGON_NT_VERSION_AVOID_NT4EMUL) == 0 ) {

        //
        // Pick up the only bit that existed in NT4.0
        //
        VersionFlags &= NETLOGON_NT_VERSION_1;
    }


    //
    // Compare the domain SID specified with the one for this domain.
    //

    if( DomainSid != NULL &&
        !RtlEqualSid( DomainInfo->DomAccountDomainId, DomainSid ) ) {

        LPWSTR AlertStrings[4];

        //
        // alert admin.
        //

        AlertStrings[0] = (LPWSTR)UnicodeWorkstationName;
        AlertStrings[1] = DomainInfo->DomUncUnicodeComputerName;
        AlertStrings[2] = DomainInfo->DomUnicodeDomainName;
        AlertStrings[3] = NULL; // Needed for RAISE_ALERT_TOO

        //
        // Save the info in the eventlog
        //

        NlpWriteEventlog(
                    ALERT_NetLogonUntrustedClient,
                    EVENTLOG_ERROR_TYPE,
                    NULL,
                    0,
                    AlertStrings,
                    3 | NETP_RAISE_ALERT_TOO );

        return FALSE;

    }


    //
    // Logons are not processed if the service is paused
    //
    // Even though we're "PartialDisabled",
    // we'll respond to queries that originated from this machine.
    // That ensures apps on this machine find this machine even though we're booting.
    //
    // Also, if this a PDC discovery and we are the PDC,
    // respond to it even if netlogon is paused since we are the only one who can respond.
    //

    if ( NlGlobalServiceStatus.dwCurrentState == SERVICE_PAUSED &&
         !((VersionFlags & NETLOGON_NT_VERSION_PDC) != 0 && DomainInfo->DomRole == RolePrimary) ) {
        NetlogonPaused = TRUE;
        NetlogonPausedReason = "Netlogon Service Paused";

    } else if ( NlGlobalDsPaused ) {
        NetlogonPaused = TRUE;
        NetlogonPausedReason = "DS paused";

    } else if ( NlGlobalPartialDisable && (VersionFlags & NETLOGON_NT_VERSION_LOCAL) == 0 ) {
        NetlogonPaused = TRUE;
        NetlogonPausedReason = "Waiting for RPCSS";

    } else if ( !NlGlobalParameters.SysVolReady ) {
        NetlogonPaused = TRUE;
        NetlogonPausedReason = "SysVol not ready";

    }

    if ( NetlogonPaused ) {

        if ( Version == LMNT_MESSAGE ) {
            Response = LOGON_SAM_PAUSE_RESPONSE;
        } else {

            //
            // Don't respond immediately to non-nt clients. They treat
            // "paused" responses as fatal.  That's just not so.
            // There may be many other DCs that are able to process the logon.
            //
            if ( RequestCount >= MAX_LOGONREQ_COUNT &&
                 NlGlobalServiceStatus.dwCurrentState == SERVICE_PAUSED ) {
                Response = LOGON_PAUSE_RESPONSE;
            }
        }

        NlPrintDom((NL_MAILSLOT, DomainInfo,
                "Returning paused to '%ws' since: %s\n",
                UnicodeWorkstationName,
                NetlogonPausedReason ));

        goto Cleanup;
    }

    //
    // Check the user name if passed
    //

    if ( UnicodeUserName == NULL || *UnicodeUserName == L'\0' ) {

        //
        // NT 5 does queries with a null account name.
        //  Bypass the SAM lookup for efficiencies sake.
        //
        if ( Version == LMNT_MESSAGE ) {
            Response = LOGON_SAM_LOGON_RESPONSE;
            goto Cleanup;
        } else {
            Status = STATUS_NO_SUCH_USER;
        }

    //
    // If this user does not have an account in SAM,
    //  immediately return a response indicating so.
    //
    // All we are trying to do here is ensuring that this guy
    // has a valid account except that we are not checking the
    // password
    //
    //  This is done so that STANDALONE logons for non existent
    //  users can be done in very first try, speeding up the response
    //  to user and reducing processing on DCs/BCs.
    //
    //
    // Disallow use of disabled accounts.
    //
    // We use this message to determine if a trusted domain has a
    // particular account.  Since the UI recommends disabling an account
    // rather than deleting it (conservation of rids and all that),
    // we shouldn't respond that we have the account if we really don't.
    //
    // We don't check the disabled bit in the Lanmax 2.x/WFW/WIN 95 case.  Downlevel
    // interactive logons are directed at a single particular domain.
    // It is better here that we indicate we have the account so later
    // he'll get a better error code indicating that the account is
    // disabled, rather than allowing him to logon standalone.
    //

    } else if ( !NlGlobalParameters.AvoidLocatorAccountLookup ) {

        //
        // If the account is interdomain trust account,
        //  we need to look it up in LSA
        //
        if ( AllowableAccountControlBits == USER_DNS_DOMAIN_TRUST_ACCOUNT ||
             AllowableAccountControlBits == USER_INTERDOMAIN_TRUST_ACCOUNT ) {

            Status = NlGetIncomingPassword(
                        DomainInfo,
                        UnicodeUserName,
                        NullSecureChannel,  // Don't know the secure channel type
                        AllowableAccountControlBits,
                        Version == LMNT_MESSAGE,
                        NULL,   // Don't return the password
                        NULL,   // Don't return the previous password
                        NULL,   // Don't return the account RID
                        NULL,   // Don't return the trust attributes
                        &IsDnsDomainTrustAccount );

        //
        // Otherwise the account is a SAM user account and
        //  we can use a quick SAM lookup
        //
        } else {
            Status = NlSamVerifyUserAccountEnabled( DomainInfo,
                                                    UnicodeUserName,
                                                    AllowableAccountControlBits,
                                                    Version == LMNT_MESSAGE );
        }

    } else {
        NlPrintDom(( NL_MAILSLOT, DomainInfo,
                     "LogonRequestHandler: Avoiding user '%ws' lookup for '%ws'\n",
                     UnicodeUserName,
                     UnicodeWorkstationName ));
    }

    if ( !NT_SUCCESS(Status) ) {

        if ( Status == STATUS_NO_SUCH_USER ) {

            if ( Version == LMNT_MESSAGE ) {
               Response = LOGON_SAM_USER_UNKNOWN;
            } else if ( Version == LM20_MESSAGE ) {
                Response = LOGON_USER_UNKNOWN;
            }
        }

        goto Cleanup;
    }

    //
    // For SAM clients, respond immediately.
    //

    if ( Version == LMNT_MESSAGE ) {
        Response = LOGON_SAM_LOGON_RESPONSE;
        goto Cleanup;

    //
    // For LM 2.0 clients, respond immediately.
    //

    } else if ( Version == LM20_MESSAGE ) {
        Response = LOGON_RESPONSE2;
        goto Cleanup;

    //
    // For LM 1.0 clients,
    //  don't support the request.
    //

    } else {
        Response = LOGON_USER_UNKNOWN;
        goto Cleanup;
    }

Cleanup:
    //
    // If we should respond to the caller, do so now.
    //

    switch (Response) {
    case LOGON_SAM_PAUSE_RESPONSE:
    case LOGON_SAM_USER_UNKNOWN:
    case LOGON_SAM_LOGON_RESPONSE:

        if (VersionFlags & (NETLOGON_NT_VERSION_5EX|NETLOGON_NT_VERSION_5EX_WITH_IP)) {
            NetStatus = BuildSamLogonResponseEx(
                                  DomainInfo,
                                  UseNameAliases,
                                  Response,
                                  UnicodeUserName,
                                  IsDnsDomainTrustAccount,
                                  TransportName,
                                  UnicodeWorkstationName,
                                  ClientSockAddr,
                                  VersionFlags,
                                  OurIpAddress,
                                  ResponseBuffer,
                                  ResponseBufferSize );
        } else {
            NetStatus = BuildSamLogonResponse(
                                  DomainInfo,
                                  UseNameAliases,
                                  Response,
                                  UnicodeUserName,
                                  TransportName,
                                  UnicodeWorkstationName,
                                  (VersionFlags & NETLOGON_NT_VERSION_5) != 0,
                                  OurIpAddress,
                                  ResponseBuffer,
                                  ResponseBufferSize );
        }

        if ( NetStatus != NO_ERROR ) {
            goto Done;
        }

        MessageBuilt = TRUE;
        break;


    case LOGON_RESPONSE2:
    case LOGON_USER_UNKNOWN:
    case LOGON_PAUSE_RESPONSE: {
        PNETLOGON_LOGON_RESPONSE2 Response2 = (PNETLOGON_LOGON_RESPONSE2)ResponseBuffer;

        Response2->Opcode = Response;

        Where = Response2->LogonServer;
        (VOID) strcpy( Where, "\\\\");
        Where += 2;
        NetpLogonPutOemString( DomainInfo->DomOemComputerName,
                          sizeof(Response2->LogonServer) - 2,
                          &Where );
        NetpLogonPutLM20Token( &Where );

        *ResponseBufferSize = (DWORD)(Where - (PCHAR)Response2);
        MessageBuilt = TRUE;

        //
        // Always good to debug
        //

        NlPrintDom((NL_MAILSLOT, DomainInfo,
                "%s logon mailslot message for %ws from \\\\%ws. Response '%s' on %ws\n",
                Version == LMNT_MESSAGE ? "Sam" : "Uas",
                UnicodeUserName,
                UnicodeWorkstationName,
                NlMailslotOpcode(Response),
                TransportName ));

        break;

    }
    }

    //
    // Free up any locally used resources.
    //

Done:

    return MessageBuilt;

}


VOID
I_NetLogonFree(
    IN PVOID Buffer
    )

/*++

Routine Description:

    Free any buffer allocated by Netlogon and returned to an in-process caller.

Arguments:

    Buffer - Buffer to deallocate.

Return Value:

    None.

--*/
{
    NetpMemoryFree( Buffer );
}


BOOLEAN
PrimaryQueryHandler(
    IN LPCWSTR TransportName,
    IN PDOMAIN_INFO DomainInfo,
    IN BOOLEAN UseNameAliases,
    IN DWORD Version,
    IN DWORD VersionFlags,
    IN LPCWSTR UnicodeWorkstationName,
    IN DWORD OurIpAddress,
    IN PSOCKADDR ClientSockAddr OPTIONAL,
    OUT BYTE ResponseBuffer[NETLOGON_MAX_MS_SIZE],
    OUT LPDWORD ResponseBufferSize
    )

/*++

Routine Description:

    Respond appropriately to a primary query request.

Arguments:

    TransportName - Name of the tranport the request came in on

    DomainInfo - Hosted Domain message came from

    UseNameAliases - TRUE if domain and forest name aliases (not active names)
        should be returned in the response message.

    Version - The version of the input message.

    VersionFlags - The version flag bit from the input messge

    UnicodeWorkstationName - The name of the workstation doing the query.

    OurIpAddress - IP Address of the transport this message was received on.
        0: Not an IP transport

    ClientSockAddr - Socket Address of the client this request came in on.
        If NULL, the client is this machine.

    ResponseBuffer - Buffer to build the response in

    ResponseBufferSize - Size (in bytes) of the returned message.

Return Value:

    TRUE if this primary query should be responded to (the ResponseBuffer was filled in)

--*/
{
    //
    // If we are emulating NT4.0 domain and the client
    //  didn't indicate to neutralize the emulation,
    //  treat the client as NT4.0 client. That way we
    //  won't leak NT5.0 specific info to the client.
    //

    if ( NlGlobalParameters.Nt4Emulator &&
         (VersionFlags & NETLOGON_NT_VERSION_AVOID_NT4EMUL) == 0 ) {

        //
        // Pick up the only bit that existed in NT4.0
        //
        VersionFlags &= NETLOGON_NT_VERSION_1;
    }


    //
    // Don't respond if the TCP transport isn't yet enabled.
    //
    //  This might be a BDC wanting to find its PDC to setup a secure channel.
    //  We don't want it to fall back to named pipes.
    //

    if ( NlGlobalDsPaused || NlGlobalPartialDisable ) {
        goto Cleanup;
    }

    //
    // Only respond if we're a PDC.
    //

    if ( DomainInfo->DomRole != RolePrimary ) {
        goto Cleanup;
    }

    //
    // Respond to the query
    //

    //
    // If the caller is an NT5.0 client,
    //  respond with a SamLogonResponse.
    //
    if (VersionFlags & (NETLOGON_NT_VERSION_5EX|NETLOGON_NT_VERSION_5EX_WITH_IP)) {
        NET_API_STATUS NetStatus;

        NetStatus = BuildSamLogonResponseEx(
                              DomainInfo,
                              UseNameAliases,
                              LOGON_SAM_LOGON_RESPONSE_EX,
                              NULL,        // No user name in response
                              FALSE,       // Not a DNS trust account name
                              TransportName,
                              UnicodeWorkstationName,
                              ClientSockAddr,
                              VersionFlags,
                              OurIpAddress,
                              ResponseBuffer,
                              ResponseBufferSize );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }

    } else if ( VersionFlags & NETLOGON_NT_VERSION_5 ) {
        NET_API_STATUS NetStatus;

        NetStatus = BuildSamLogonResponse(
                               DomainInfo,
                               UseNameAliases,
                               LOGON_SAM_LOGON_RESPONSE,
                               NULL,        // No user name in response
                               TransportName,
                               UnicodeWorkstationName,
                               TRUE,        // Supply NT 5.0 specific response
                               OurIpAddress,
                               ResponseBuffer,
                               ResponseBufferSize );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }

    } else {
        PNETLOGON_PRIMARY Response = (PNETLOGON_PRIMARY)ResponseBuffer;
        PCHAR Where;

        //
        // Build the response
        //
        // If we are the Primary DC, tell the caller our computername.
        // If we are a backup DC,
        //  tell the downlevel PDC who we think the primary is.
        //

        Response->Opcode = LOGON_PRIMARY_RESPONSE;

        Where = Response->PrimaryDCName;
        NetpLogonPutOemString(
                DomainInfo->DomOemComputerName,
                sizeof( Response->PrimaryDCName),
                &Where );

        //
        // If this is an NT query,
        //  add the NT specific response.
        //
        if ( Version == LMNT_MESSAGE ) {
            NetpLogonPutUnicodeString(
                DomainInfo->DomUnicodeComputerNameString.Buffer,
                sizeof(Response->UnicodePrimaryDCName),
                &Where );

            NetpLogonPutUnicodeString(
                DomainInfo->DomUnicodeDomainName,
                sizeof(Response->UnicodeDomainName),
                &Where );

            NetpLogonPutNtToken( &Where, 0 );
        }

        *ResponseBufferSize = (DWORD)(Where - (PCHAR)Response);

        NlPrintDom((NL_MAILSLOT, DomainInfo,
                "%s Primary Query mailslot message from %ws. Response %ws on %ws\n",
                Version == LMNT_MESSAGE ? "Sam" : "Uas",
                UnicodeWorkstationName,
                DomainInfo->DomUncUnicodeComputerName,
                TransportName ));

    }

    return TRUE;

    //
    // Free Locally used resources
    //
Cleanup:

    return FALSE;
}


NET_API_STATUS
NlGetLocalPingResponse(
    IN LPCWSTR TransportName,
    IN BOOL LdapPing,
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCSTR DnsDomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    IN BOOL PdcOnly,
    IN LPCWSTR UnicodeComputerName,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN ULONG NtVersion,
    IN ULONG NtVersionFlags,
    IN PSOCKADDR ClientSockAddr OPTIONAL,
    OUT PVOID *Message,
    OUT PULONG MessageSize
    )

/*++

Routine Description:

    Build the message response message to for a DC ping.

Arguments:

    TransportName - Name of the transport the message came in on

    LdapPing - TRUE iff the ping from client came over LDAP

    NetbiosDomainName - Netbios Domain Name of the domain to query.

    DnsDomainName - UTF-8 DNS Domain Name of the domain to query.

    DomainGuid - GUID of the domain being located.

If all three of the above are NULL, the primary domain is used.

    DomainSid - If specified, must match the DomainSid of the domain referenced.

    PdcOnly - True if only the PDC should respond.

    UnicodeComputerName - Netbios computer name of the machine to respond to.

    UnicodeUserName - Account name of the user being pinged.
        If NULL, DC will always respond affirmatively.

    AllowableAccountControlBits - Mask of allowable account types for UnicodeUserName.

    NtVersion - Version of the message

    NtVersionFlags - Version of the message.
        0: For backward compatibility.
        NETLOGON_NT_VERSION_5: for NT 5.0 message.

    ClientSockAddr - Socket Address of the client this request came in on.
        If NULL, the client is this machine.

    Message - Returns the message to be sent to the DC in question.
        Buffer must be free using NetpMemoryFree().

    MessageSize - Returns the size (in bytes) of the returned message


Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NO_SUCH_DOMAIN - If the machine isn't a DC for the requested domain.

    ERROR_NOT_ENOUGH_MEMORY - The message could not be allocated.

--*/
{
    NET_API_STATUS NetStatus;
    PDOMAIN_INFO DomainInfo = NULL;
    DWORD ResponseBufferSize;
    BYTE ResponseBuffer[NETLOGON_MAX_MS_SIZE];    // Buffer to build response in
    DWORD OurIpAddress;
    PLIST_ENTRY ListEntry;
    BOOLEAN AliasNameMatched = FALSE;

    //
    // Ignore this call on a workstation.
    //

    if ( NlGlobalMemberWorkstation ) {
        return ERROR_NO_SUCH_DOMAIN;
    }

    //
    // If we are emulating NT4.0 domain and this ping came from LDAP
    //  and the client didn't indicate to neutralize the emulation,
    //  ignore this ping
    //

    if ( NlGlobalParameters.Nt4Emulator &&
         LdapPing &&
         (NtVersionFlags & NETLOGON_NT_VERSION_AVOID_NT4EMUL) == 0 ) {

        return ERROR_NO_SUCH_DOMAIN;
    }

    //
    // Be Verbose
    //

    NlPrint((NL_MAILSLOT,
            "Received ping from %ws %s %ws on %ws\n",
            UnicodeComputerName,
            DnsDomainName,
            UnicodeUserName,
            TransportName ));

    //
    // The first time this is called, wait for the DS service to start.
    //

    if ( NlGlobalDsRunningUnknown ) {
        DWORD WaitStatus;
#define NL_NTDS_HANDLE 0
#define NL_SHUTDOWN_HANDLE 1
#define NL_DS_HANDLE_COUNT 2
        HANDLE EventHandles[NL_DS_HANDLE_COUNT];

        //
        // Create an event to wait on.
        //

        EventHandles[NL_NTDS_HANDLE] = OpenEvent(
                SYNCHRONIZE,
                FALSE,
                NTDS_DELAYED_STARTUP_COMPLETED_EVENT );

        if ( EventHandles[NL_NTDS_HANDLE] == NULL ) {
            NetStatus = GetLastError();
            NlPrint((NL_CRITICAL,
                    "NlGetLocalPingResponse: Cannot OpenEvent %ws %ld\n",
                    NTDS_DELAYED_STARTUP_COMPLETED_EVENT,
                    NetStatus ));
            goto Cleanup;
        }

        EventHandles[NL_SHUTDOWN_HANDLE] = NlGlobalTerminateEvent;

        //
        // Wait for the DS to start
        //

        WaitStatus = WaitForMultipleObjects( NL_DS_HANDLE_COUNT,
                                             EventHandles,
                                             FALSE,
                                             20*60*1000 );    // Twenty minutes maximum

        CloseHandle( EventHandles[NL_NTDS_HANDLE] );

        switch ( WaitStatus ) {
        case WAIT_OBJECT_0 + NL_NTDS_HANDLE:
            break;

        case WAIT_OBJECT_0 + NL_SHUTDOWN_HANDLE:
            NlPrint((NL_CRITICAL,
                    "NlGetLocalPingResponse: Netlogon shut down.\n" ));
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;

        case WAIT_TIMEOUT:
            NlPrint((NL_CRITICAL,
                    "NlGetLocalPingResponse: DS took too long to start.\n" ));
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;

        case WAIT_FAILED:
            NetStatus = GetLastError();
            NlPrint((NL_CRITICAL,
                    "NlGetLocalPingResponse: Wait for DS failed %ld.\n", NetStatus ));
            goto Cleanup;
        default:
            NlPrint((NL_CRITICAL,
                    "NlGetLocalPingResponse: Unknown status from Wait %ld.\n", WaitStatus ));
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        //
        // Never wait again.
        //
        NlGlobalDsRunningUnknown = FALSE;

    }

    //
    // If no specific domain is needed,
    //  use the default.
    //

    if ( DnsDomainName == NULL && DomainGuid == NULL && NetbiosDomainName == NULL ) {
        DomainInfo = NlFindNetbiosDomain(
                        NULL,
                        TRUE );

    //
    // See if the requested domain/NDNC is supported.
    //
    } else if ( DnsDomainName != NULL || DomainGuid != NULL ) {

        //
        // Lookup an emulated domain/NDNC using the passed DNS name.
        //
        // If the DNS domain name alias matches the query, the alias
        //  may change by the time we build the response.  That's OK,
        //  the client will disregard our response which is proper
        //  since we will no longer have that alias.
        //

        DomainInfo = NlFindDnsDomain(
                        DnsDomainName,
                        DomainGuid,
                        TRUE,  // look up NDNCs too
                        TRUE,  // check domain name aliase
                        &AliasNameMatched );

        //
        // If that didn't find the emulated domain,
        //  and the caller is looking for a GC,
        //  and this is a query that doesn't need a specific domain,
        //  check if the DNS domain name specified is that of our tree,
        //  we can respond to this request.
        //
        // Simply use the primary emulated domain.
        //

        if ( DomainInfo == NULL &&
             ( NtVersionFlags & NETLOGON_NT_VERSION_GC ) != 0 &&
             DomainSid == NULL &&
             UnicodeUserName == NULL &&
             AllowableAccountControlBits == 0 &&
             DnsDomainName != NULL ) {

            BOOL ForestNameSame = FALSE;

            EnterCriticalSection( &NlGlobalDnsForestNameCritSect );
            if ( NlGlobalUtf8DnsForestName != NULL &&
                 NlEqualDnsNameUtf8( DnsDomainName, NlGlobalUtf8DnsForestName ) ) {
                ForestNameSame = TRUE;
            }

            //
            // If this didn't match, check if the forest name alias does
            //
            if ( !ForestNameSame &&
                 NlGlobalUtf8DnsForestNameAlias != NULL &&
                 NlEqualDnsNameUtf8( DnsDomainName, NlGlobalUtf8DnsForestNameAlias ) ) {
                ForestNameSame = TRUE;
                AliasNameMatched = TRUE;
            }
            LeaveCriticalSection( &NlGlobalDnsForestNameCritSect );

            if ( ForestNameSame ) {
                DomainInfo = NlFindNetbiosDomain( NULL, TRUE );
            }
        }
    }

    if ( DomainInfo == NULL && NetbiosDomainName != NULL ) {
        DomainInfo = NlFindNetbiosDomain(
                        NetbiosDomainName,
                        FALSE );
    }


    if ( DomainInfo == NULL ) {

        NlPrint((NL_CRITICAL,
                "Ping from %ws for domain %s %ws for %ws on %ws is invalid since we don't host the named domain.\n",
                UnicodeComputerName,
                DnsDomainName,
                NetbiosDomainName,
                UnicodeUserName,
                TransportName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }


    //
    // Get the IP address of this machine (any IP address)
    //      Loop through the list of addresses learned via winsock.
    //
    // Default to the loopback address (127.0.0.1).  Since all DCs require IP
    //  to be installed, make sure we always have an IP address even though
    //  the net card is currently unplugged.
    //

    OurIpAddress = htonl(0x7f000001);
    EnterCriticalSection( &NlGlobalTransportCritSect );
    if ( NlGlobalWinsockPnpAddresses != NULL ) {
        int i;
        for ( i=0; i<NlGlobalWinsockPnpAddresses->iAddressCount; i++ ) {
            PSOCKADDR SockAddr;

            SockAddr = NlGlobalWinsockPnpAddresses->Address[i].lpSockaddr;
            if ( SockAddr->sa_family == AF_INET ) {
                OurIpAddress = ((PSOCKADDR_IN)SockAddr)->sin_addr.S_un.S_addr;
                break;
            }
        }
    }

    LeaveCriticalSection( &NlGlobalTransportCritSect );



    //
    // If this is a primary query,
    //  handle it.
    //

    if ( PdcOnly ) {

        //
        // If we don't have a response,
        //  just tell the caller this DC doesn't match.
        //

        if ( !PrimaryQueryHandler(
                        TransportName,
                        DomainInfo,
                        AliasNameMatched,
                        NtVersion,
                        NtVersionFlags,
                        UnicodeComputerName,
                        OurIpAddress,
                        ClientSockAddr,
                        ResponseBuffer,
                        &ResponseBufferSize ) ) {

            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

    //
    // If this isn't a primary query,
    //  handle it.
    //

    } else {

        //
        // If we don't have a response,
        //  just tell the caller this DC doesn't match.
        //
        if ( !LogonRequestHandler(
                        TransportName,
                        DomainInfo,
                        AliasNameMatched,
                        DomainSid,
                        NtVersion,
                        NtVersionFlags,
                        UnicodeUserName,
                        0,          // RequestCount
                        UnicodeComputerName,
                        AllowableAccountControlBits,
                        OurIpAddress,
                        ClientSockAddr,
                        ResponseBuffer,
                        &ResponseBufferSize ) ) {

            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

    }

    //
    // Actually allocate a buffer for the response.
    //

    *Message = NetpMemoryAllocate( ResponseBufferSize );

    if ( *Message == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( *Message, ResponseBuffer, ResponseBufferSize );
    *MessageSize = ResponseBufferSize;

    NetStatus = NO_ERROR;


Cleanup:
    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return NetStatus;
}
#endif // _DC_NETLOGON


BOOL
TimerExpired(
    IN PTIMER Timer,
    IN PLARGE_INTEGER TimeNow,
    IN OUT LPDWORD Timeout
    )

/*++

Routine Description:

    Determine whether a timer has expired.  If not, adjust the passed in
    timeout value to take this timer into account.

Arguments:

    Timer - Specifies the timer to check.

    TimeNow - Specifies the current time of day in NT standard time.

    Timeout - Specifies the current amount of time (in milliseconds)
        that the caller intends to wait for a timer to expire.
        If this timer has not expired, this value is adjusted to the
        smaller of the current value and the amount of time remaining
        on the passed in timer.

Return Value:

    TRUE - if the timer has expired.

--*/

{
    LARGE_INTEGER Period;
    LARGE_INTEGER ExpirationTime;
    LARGE_INTEGER ElapsedTime;
    LARGE_INTEGER TimeRemaining;
    LARGE_INTEGER MillisecondsRemaining;

/*lint -e569 */  /* don't complain about 32-bit to 31-bit initialize */
    LARGE_INTEGER BaseGetTickMagicDivisor = { 0xe219652c, 0xd1b71758 };
/*lint +e569 */  /* don't complain about 32-bit to 31-bit initialize */
    CCHAR BaseGetTickMagicShiftCount = 13;

    //
    // If the period to too large to handle (i.e., 0xffffffff is forever),
    //  just indicate that the timer has not expired.
    //

    if ( Timer->Period > TIMER_MAX_PERIOD ) {
        return FALSE;
    }

    //
    // If time has gone backwards (someone changed the clock),
    //  just start the timer over again.
    //
    // The kernel automatically updates the system time to the CMOS clock
    // periodically.  If we just expired the timer when time went backwards,
    // we'd risk periodically falsely triggering the timeout.
    //

    ElapsedTime.QuadPart = TimeNow->QuadPart - Timer->StartTime.QuadPart;

    if ( ElapsedTime.QuadPart < 0 ) {
        Timer->StartTime = *TimeNow;
    }

    //
    // Convert the period from  milliseconds to 100ns units.
    //

    Period.QuadPart = UInt32x32To64( (LONG) Timer->Period, 10000 );

    //
    // Compute the expiration time.
    //

    ExpirationTime.QuadPart = Timer->StartTime.QuadPart + Period.QuadPart;

    //
    // Compute the Time remaining on the timer.
    //

    TimeRemaining.QuadPart = ExpirationTime.QuadPart - TimeNow->QuadPart;

    //
    // If the timer has expired, tell the caller so.
    //

    if ( TimeRemaining.QuadPart <= 0 ) {
        return TRUE;
    }



    //
    // If the timer hasn't expired, compute the number of milliseconds
    //  remaining.
    //

    MillisecondsRemaining = RtlExtendedMagicDivide(
                                TimeRemaining,
                                BaseGetTickMagicDivisor,
                                BaseGetTickMagicShiftCount );

    NlAssert( MillisecondsRemaining.HighPart == 0 );
    NlAssert( MillisecondsRemaining.LowPart <= TIMER_MAX_PERIOD );

    //
    // Adjust the running timeout to be the smaller of the current value
    //  and the value computed for this timer.
    //

    if ( *Timeout > MillisecondsRemaining.LowPart ) {
        *Timeout = MillisecondsRemaining.LowPart;
    }

    return FALSE;

}

NET_API_STATUS
NlDomainScavenger(
    IN PDOMAIN_INFO DomainInfo,
    IN PVOID Context
)
/*++

Routine Description:

    Perform the per-domain scavenging.

Arguments:

    DomainInfo - The domain being scavenged.

    Context - Not Used

Return Value:

    Success (not used).

--*/
{
    DWORD DomFlags;

    //
    //  Change password if neccessary
    //

    if ( NlGlobalTerminate ) {
        return NERR_Success;
    }

    if ( !NlGlobalParameters.DisablePasswordChange ) {
        PCLIENT_SESSION ClientSession;

        ClientSession = NlRefDomClientSession( DomainInfo );

        if ( ClientSession != NULL ) {
            (VOID) NlChangePassword( ClientSession, FALSE, NULL );
            NlUnrefClientSession( ClientSession );
        }
    }



#ifdef _DC_NETLOGON
    //
    // Change the password on each entry in the trust list.
    //
    // Check whether forest trust info needs update.
    //

    if ( NlGlobalTerminate ) {
        return NERR_Success;
    }

    if ( DomainInfo->DomRole == RolePrimary ) {
        PLIST_ENTRY ListEntry;
        PCLIENT_SESSION ClientSession;
        ULONG LocalFtInfoUpdateInterval;

        //
        // Get the forest trust update interval as configured in registry
        //

        LocalFtInfoUpdateInterval = NlGlobalParameters.FtInfoUpdateInterval;

        //
        // If the value converted into milliseconds fits into a ULONG,
        //  use it
        //

        if ( LocalFtInfoUpdateInterval <= MAXULONG/1000 ) {
            LocalFtInfoUpdateInterval *= 1000;    // convert to milliseconds

        //
        // Otherwise, the interval is infinity
        //

        } else {
            LocalFtInfoUpdateInterval = MAXULONG;
        }

        //
        // Reset all the flags indicating we need to check the password
        //  and forest trust info
        //

        LOCK_TRUST_LIST( DomainInfo );
        for ( ListEntry = DomainInfo->DomTrustList.Flink ;
              ListEntry != &DomainInfo->DomTrustList ;
              ListEntry = ListEntry->Flink) {

            ClientSession = CONTAINING_RECORD( ListEntry,
                                               CLIENT_SESSION,
                                               CsNext );

            //
            // Only check if there is a direct trust to the domain.
            //
            if ( ClientSession->CsFlags & CS_DIRECT_TRUST ) {
                ClientSession->CsFlags |= CS_CHECK_DIRECT_TRUST;
            }
        }

        for ( ListEntry = DomainInfo->DomTrustList.Flink ;
              ListEntry != &DomainInfo->DomTrustList ;
              ) {

            BOOL RefreshFtInfo = FALSE;

            ClientSession = CONTAINING_RECORD( ListEntry,
                                               CLIENT_SESSION,
                                               CsNext );

            if ( (ClientSession->CsFlags & CS_CHECK_DIRECT_TRUST) == 0 ) {
              ListEntry = ListEntry->Flink;
              continue;
            }
            ClientSession->CsFlags &= ~CS_CHECK_DIRECT_TRUST;

            //
            // See if we need to refresh FTInfo for this (direct) trust
            //

            if ( (ClientSession->CsTrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) &&
                 (ClientSession->CsLastFtInfoRefreshTime.QuadPart == 0 ||
                  NetpLogonTimeHasElapsed(ClientSession->CsLastFtInfoRefreshTime,
                                          LocalFtInfoUpdateInterval)) ) {
                RefreshFtInfo = TRUE;
            }

            NlRefClientSession( ClientSession );
            UNLOCK_TRUST_LIST( DomainInfo );

            //
            // Change the password for this trusted domain.
            //

            (VOID) NlChangePassword( ClientSession, FALSE, NULL );

            //
            // check to see if we have been asked to leave.
            //

            if ( NlGlobalTerminate ) {
                NlUnrefClientSession( ClientSession );
                return NERR_Success;
            }

            //
            // Refresh FTInfo if needed
            //

            if ( RefreshFtInfo ) {

                //
                // Become a Writer of the ClientSession.
                //
                if ( !NlTimeoutSetWriterClientSession(ClientSession, WRITER_WAIT_PERIOD) ) {
                    NlPrintCs(( NL_CRITICAL, ClientSession,
                                "NlDomainScavenger: Can't become writer of client session.\n" ));

                } else {
                    PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo = NULL;

                    NlPrintCs(( NL_MISC, ClientSession,
                                "NlDomainScavenger: Updating forest trust info\n" ));

                    //
                    // Get the FTinfo from the trusted domain and write it to our TDO.
                    //  Ignore failures.
                    //
                    NlpGetForestTrustInfoHigher( ClientSession,
                                                 DS_GFTI_UPDATE_TDO,
                                                 FALSE,  // Don't impersonate caller
                                                 FALSE,  // We didn't set up the session
                                                 &ForestTrustInfo );

                    if ( ForestTrustInfo != NULL ) {
                        NetApiBufferFree( ForestTrustInfo );
                    }

                    NlResetWriterClientSession( ClientSession );
                }
            }

            NlUnrefClientSession( ClientSession );

            //
            // check to see if we have been asked to leave.
            //

            if ( NlGlobalTerminate ) {
                return NERR_Success;
            }

            LOCK_TRUST_LIST( DomainInfo );

            // Start again at the beginning.
            ListEntry = DomainInfo->DomTrustList.Flink;

        }
        UNLOCK_TRUST_LIST( DomainInfo );

    }

    //
    // Scavenge the list of failed forwarded user logons
    //

    if ( DomainInfo->DomRole == RoleBackup ) {
        NlScavengeOldFailedLogons( DomainInfo );
    }

    //
    // Scavenge through the server session table.
    //

    if ( DomainInfo->DomRole == RolePrimary || DomainInfo->DomRole == RoleBackup ) {


        if ( NlGlobalTerminate ) {
            return NERR_Success;
        }

        NlServerSessionScavenger( DomainInfo );

        //
        // Pick a DC for each non-authenicated entry in the trust list.
        //

        if ( NlGlobalTerminate ) {
            return NERR_Success;
        }

        NlPickTrustedDcForEntireTrustList( DomainInfo, FALSE );

    }

    //
    // If the role of this machine isn't known,
    //  the role update failed (so schedule another one).
    //

    if ( DomainInfo->DomRole == RoleInvalid ) {
        NlPrintDom((NL_MISC, DomainInfo,
                "DomainScavenger: Try again to update the role.\n" ));

        DomFlags = DOM_ROLE_UPDATE_NEEDED;
        NlStartDomainThread( DomainInfo, &DomFlags );
    }

    //
    // If this is a primary domain and the trust info is not up to date,
    // schedule the trust info update now.
    //

    if ( DomainInfo->DomFlags & DOM_PRIMARY_DOMAIN ) {

        if ( WaitForSingleObject( NlGlobalTrustInfoUpToDateEvent, 0 ) == WAIT_TIMEOUT ) {
            NlPrintDom((NL_MISC, DomainInfo,
                    "DomainScavenger: Try again to update the trusted domain list.\n" ));

            DomFlags = DOM_TRUST_UPDATE_NEEDED;
            NlStartDomainThread( DomainInfo, &DomFlags );
        }

    }

#endif // _DC_NETLOGON

    return NERR_Success;
    UNREFERENCED_PARAMETER( Context );
}

VOID
NlDcScavenger(
    IN LPVOID ScavengerParam
)
/*++

Routine Description:

    This function performs the scavenger operation.  This function is
    called every 15 mins interval.  This function is
    executed on the scavenger thread, thus leaving the main thread to
    process the mailslot messages better.

    This function is specific to domain controllers.


Arguments:

    None.

Return Value:

    None.

--*/
{
    LPWSTR MsgStrings[4];
    ULONG TimePassed = 0;
    LARGE_INTEGER DuplicateEventlogTimeout_100ns;

    //
    // Reset the scavenger timer to run at the normal interval.
    // Other places (challenge request/response handling) which
    // need more expedient scavenging will reschedule the timer
    // as needed.
    //

    EnterCriticalSection( &NlGlobalScavengerCritSect );
    NlGlobalScavengerTimer.Period = NlGlobalParameters.ScavengeInterval * 1000L;
    LeaveCriticalSection( &NlGlobalScavengerCritSect );

    //
    // Scavenge one domain at a time
    //

    if ( NlGlobalTerminate ) {
        goto Cleanup;
    }

    (VOID) NlEnumerateDomains( FALSE, NlDomainScavenger, NULL );

    //
    // Scavenge expired challenge entries in the
    //  global list of outstanding challenges
    //

    NlScavengeOldChallenges();

    //
    // If there were clients with no site, see if it's time
    //  to log an event -- avoid poluting the event log.
    //
    //  Note that we don't use the duplicate event log mechanism
    //  as the message we are logging is likely to be different
    //  from previous ones due to the count parameter.
    //

    EnterCriticalSection( &NlGlobalSiteCritSect );
    DuplicateEventlogTimeout_100ns.QuadPart =
        Int32x32To64( NlGlobalParameters.DuplicateEventlogTimeout, 10000000 );

    if ( NlGlobalNoClientSiteCount > 0 &&
         NlTimeHasElapsedEx(&NlGlobalNoClientSiteEventTime,
                            &DuplicateEventlogTimeout_100ns,
                            &TimePassed) ) {

        // Max ULONG is 4294967295 => 11 chars to store it
        WCHAR ConnectionCountStr[11];
        WCHAR DefaultLogMaxSizeStr[11];
        WCHAR LogMaxSizeStr[11];

        // 20 chars is more than enough: 0xffffffff/3600 = 1193046.47
        WCHAR TimeoutStr[20];

        //
        // Get the time passed since we logged
        //  the event last time
        //
        swprintf( TimeoutStr,
                  L"%.2f",
                  (double) (NlGlobalParameters.DuplicateEventlogTimeout + TimePassed/1000) / 3600 );

        swprintf( ConnectionCountStr, L"%lu", NlGlobalNoClientSiteCount );
        swprintf( DefaultLogMaxSizeStr, L"%lu", DEFAULT_MAXIMUM_LOGFILE_SIZE );
        swprintf( LogMaxSizeStr, L"%lu", NlGlobalParameters.LogFileMaxSize );

        MsgStrings[0] = TimeoutStr;
        MsgStrings[1] = ConnectionCountStr;
        MsgStrings[2] = DefaultLogMaxSizeStr;
        MsgStrings[3] = LogMaxSizeStr;

        NlpWriteEventlog( NELOG_NetlogonNoSiteForClients,
                          EVENTLOG_WARNING_TYPE,
                          NULL,
                          0,
                          MsgStrings,
                          4 );

        //
        // Reset the count
        //
        NlGlobalNoClientSiteCount = 0;
        NlQuerySystemTime( &NlGlobalNoClientSiteEventTime );
    }
    LeaveCriticalSection( &NlGlobalSiteCritSect );

    //
    // It's OK to run the scavenger again.
    //
Cleanup:
    EnterCriticalSection( &NlGlobalScavengerCritSect );
    NlGlobalDcScavengerIsRunning = FALSE;


    // Reset the StartTime in case this routine takes a long time to process.
    NlQuerySystemTime( &NlGlobalScavengerTimer.StartTime );
    LeaveCriticalSection( &NlGlobalScavengerCritSect );

    UNREFERENCED_PARAMETER( ScavengerParam );

}

VOID
NlWksScavenger(
    VOID
)
/*++

Routine Description:

    This function performs the scavenger operation.  This function is
    called every 15 mins interval.  This function is executed on the main thread.

    This function is specific to member workstations and member servers


Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG CallAgainPeriod = MAILSLOT_WAIT_FOREVER;  // Default to not scavenging again.
    ULONG TempPeriod;


    //
    //  Change password if neccessary
    //

    if ( !NlGlobalParameters.DisablePasswordChange ) {
        PCLIENT_SESSION ClientSession;

        ClientSession = NlRefDomClientSession( NlGlobalDomainInfo );

        if ( ClientSession != NULL ) {
            (VOID) NlChangePassword( ClientSession, FALSE, &CallAgainPeriod );
            NlUnrefClientSession( ClientSession );
        } else {
            // This can't happen (but try again periodically)
            CallAgainPeriod = 0;
        }
    }



    //
    // Never scavenge more frequently than the configured rate.
    //
    EnterCriticalSection( &NlGlobalScavengerCritSect );
    NlQuerySystemTime( &NlGlobalScavengerTimer.StartTime );
    NlGlobalScavengerTimer.Period = max( (NlGlobalParameters.ScavengeInterval * 1000L),
                                         CallAgainPeriod );

    NlpDumpPeriod( NL_MISC,
                   "NlWksScavenger: Can be called again in",
                   NlGlobalScavengerTimer.Period );

    LeaveCriticalSection( &NlGlobalScavengerCritSect );

}


VOID
NlMainLoop(
    VOID
    )

/*++

Routine Description:


    Waits for a logon request to arrive at the NETLOGON mailslot.

    This routine, also, processes several periodic events.  These events
    are timed by computing a timeout value on the mailslot read which is the
    time needed before the nearest periodic event needs to be processed.
    After such a timeout, this routine processes the event.

Arguments:

    None.

Return Value:

    Return iff the service is to exit.

    mail slot error occurred, eg if someone deleted the NETLOGON
    mail slot explicitly or if the logon server share has been deleted
    and cannot be re-shared.

--*/
{
    NET_API_STATUS NetStatus;
    DWORD WaitStatus;
    BOOLEAN IgnoreDuplicatesOfThisMessage;

    BOOLEAN RegNotifyNeeded = TRUE;
    HKEY ParmHandle = NULL;
    HANDLE ParmEventHandle = NULL;

    BOOLEAN GpRegNotifyNeeded = TRUE;
    HKEY GpParmHandle = NULL;
    HANDLE GpParmEventHandle = NULL;

    //
    // Variables controlling mailslot read timeout
    //

    DWORD MainLoopTimeout = 0;
    LARGE_INTEGER TimeNow;

    TIMER AnnouncerTimer;
    TIMER SubnetSiteUpdateTimer;

#define NL_WAIT_TERMINATE           0
#define NL_WAIT_TIMER               1
#define NL_WAIT_MAILSLOT            2
    // Optional entries should be at the end.
    ULONG NlWaitWinsock = 0;    //  3
    ULONG NlWaitNotify = 0;     //  4
    ULONG NlWaitParameters = 0; //  5
    ULONG NlWaitGpParameters = 0; //  6
#define NL_WAIT_COUNT               7

    HANDLE WaitHandles[ NL_WAIT_COUNT ];
    DWORD WaitCount = 0;

    //
    // Initialize handles to wait on.
    //

    WaitHandles[NL_WAIT_TERMINATE] = NlGlobalTerminateEvent;
    WaitCount++;
    WaitHandles[NL_WAIT_TIMER] = NlGlobalTimerEvent;
    WaitCount++;
    WaitHandles[NL_WAIT_MAILSLOT] = NlGlobalMailslotHandle;
    WaitCount++;

    //
    // In IP-less environments the Winsock event doesn't exist.
    //
    if ( NlGlobalWinsockPnpEvent != NULL ) {
        NlWaitWinsock = WaitCount;
        WaitHandles[NlWaitWinsock] = NlGlobalWinsockPnpEvent;
        WaitCount++;
    }

    //
    // When netlogon is run during retail setup
    //  (in an attempt to replicate the databases to a BDC),
    //  the role is Workstation at the instant netlogon.dll is loaded,
    //  therefore, the ChangeLogEvent won't have been initialized.
    //

    if ( NlGlobalChangeLogEvent != NULL ) {
        NlWaitNotify = WaitCount;
        WaitHandles[NlWaitNotify] = NlGlobalChangeLogEvent;
        WaitCount++;
    }

    //
    // Set up a secure channel to any DC in the domain.
    //  Don't fail if setup is impossible.
    //
    // We wait until now since this is a potentially lengthy operation.
    // If the user on the workstation is trying to logon immediately after
    // reboot, we'd rather have him wait in netlogon (where we have more
    // control) than have him waiting in MSV.
    //

    if ( NlGlobalMemberWorkstation ) {
        PDOMAIN_INFO DomainInfo;
        PCLIENT_SESSION ClientSession;

        DomainInfo = NlFindNetbiosDomain( NULL, TRUE );    // Primary domain

        if ( DomainInfo != NULL ) {

            ClientSession = NlRefDomClientSession(DomainInfo);

            if ( ClientSession != NULL ) {

                //
                // Set up a client session if it hasn't been already done
                //
                (VOID) NlTimeoutSetWriterClientSession( ClientSession, 0xFFFFFFFF );
                if ( ClientSession->CsState == CS_IDLE ) {
                    (VOID) NlSessionSetup( ClientSession );
                }
                NlResetWriterClientSession( ClientSession );

                NlUnrefClientSession( ClientSession );
            } else {
                NlPrint((NL_CRITICAL,
                        "NlMainLoop: Cannot NlRefDomClientSession\n" ));
            }

            NlDereferenceDomain( DomainInfo );
        } else {
            NlPrint((NL_CRITICAL,
                    "NlMainLoop: Cannot NlFindNetbiosDomain\n" ));
        }
    }



    //
    // Force the announce to happen immediately.
    //
    // Actually, wait the announcement period.  NlInitTcpRpc will force an "immediate"
    // announcement as soon as TCP RPC is enabled.
    //

    NlQuerySystemTime( &TimeNow );

    AnnouncerTimer.StartTime = TimeNow;
    AnnouncerTimer.Period = NlGlobalParameters.Pulse * 1000L;

    SubnetSiteUpdateTimer.StartTime = TimeNow;
    SubnetSiteUpdateTimer.Period = (DWORD) MAILSLOT_WAIT_FOREVER;

    NlGlobalApiTimer.StartTime = TimeNow;

    //
    // It is possible that we missed service notifications to update DNS
    // records on boot because we were not ready to process notifications
    // at that time. So if any of the DNS service bits is set, schedule
    // the DNS scavenger to run immediately to update DNS if it indeed
    // hasn't been done already.
    //

    if ( !NlGlobalMemberWorkstation &&
         (NlGetDomainFlags(NULL) & DS_DNS_SERVICE_BITS) != 0 ) {
        NlGlobalDnsScavengerTimer.StartTime.QuadPart = 0;
        NlGlobalDnsScavengerTimer.Period = 0;
    }

    NlPrint((NL_INIT, "Started successfully\n" ));

    //
    // Loop reading from the Netlogon mailslot
    //

    IgnoreDuplicatesOfThisMessage = FALSE;
    for ( ;; ) {
        DWORD Timeout;

        //
        // Issue a mailslot read request if we are domain controller and
        // there is no outstanding read request pending.
        //

        NlMailslotPostRead( IgnoreDuplicatesOfThisMessage );
        IgnoreDuplicatesOfThisMessage = FALSE;


        //
        // Register for registry change notification
        //

        if ( RegNotifyNeeded || GpRegNotifyNeeded ) {
            ULONG TryCount;

            //
            // Try couple of times to post the registry
            //  notification requests
            //
            for ( TryCount = 0; TryCount < 2; TryCount++ ) {
                NetStatus = NO_ERROR;

                // Retry the Netlogon Parameters registration on each iteration for resiliency
                if ( ParmHandle == NULL ) {
                    ParmHandle = NlOpenNetlogonKey( NL_PARAM_KEY );

                    if (ParmHandle == NULL) {
                        NlPrint(( NL_CRITICAL,
                                  "Cannot NlOpenNetlogonKey (ignored)\n" ));
                    }
                }

                if ( ParmEventHandle == NULL ) {
                    ParmEventHandle = CreateEvent( NULL,     // No security attributes
                                                   TRUE,     // Must be manually reset
                                                   FALSE,    // Initially not signaled
                                                   NULL );   // No name

                    if ( ParmEventHandle == NULL ) {
                        NlPrint(( NL_CRITICAL,
                                  "Cannot Create parameter key event %ld (ignored)\n",
                                  GetLastError() ));
                    } else {
                        NlWaitParameters = WaitCount;
                        WaitHandles[NlWaitParameters] = ParmEventHandle;
                        WaitCount++;
                        NlAssert( WaitCount <= NL_WAIT_COUNT );
                    }
                }

                if ( RegNotifyNeeded && ParmHandle != NULL && ParmEventHandle != NULL ) {
                    NetStatus = RegNotifyChangeKeyValue(
                                    ParmHandle,
                                    FALSE,      // don't watch subtree
                                    REG_NOTIFY_CHANGE_LAST_SET,
                                    ParmEventHandle,
                                    TRUE );     // Async

                    if ( NetStatus == NO_ERROR ) {
                        RegNotifyNeeded = FALSE;

                    // If the key has been manually deleted,
                    //   recover from it by just closing ParmHandle
                    //   to reopen it on the second try
                    } else if ( NetStatus == ERROR_KEY_DELETED ) {
                        NlPrint(( NL_CRITICAL, "Netlogon Parameters key deleted (recover)\n" ));
                        RegCloseKey( ParmHandle );
                        ParmHandle = NULL;
                        ResetEvent( ParmEventHandle );
                    } else {
                        NlPrint(( NL_CRITICAL,
                                  "Cannot RegNotifyChangeKeyValue 0x%lx (ignored)\n",
                                  NetStatus ));
                    }
                }

                // Retry the GP Parameters registration on each iteration for resiliency
                // Note that here we open the Netlogon key (not Netlogon\Parameters key)
                // and we watch for the subtree. We do this for debugging purposes to
                // see whether GP is enabled for Netlogon by checking if the GP created
                // Parameters section exists. See nlparse.c.
                if ( GpParmHandle == NULL ) {
                    GpParmHandle = NlOpenNetlogonKey( NL_GP_KEY );

                    if (GpParmHandle == NULL) {
                        NlPrint(( NL_CRITICAL,
                                  "Cannot NlOpenNetlogonKey for GP (ignored)\n" ));
                    }
                }

                if ( GpParmEventHandle == NULL ) {
                    GpParmEventHandle = CreateEvent( NULL,     // No security attributes
                                                   TRUE,     // Must be manually reset
                                                   FALSE,    // Initially not signaled
                                                   NULL );   // No name

                    if ( GpParmEventHandle == NULL ) {
                        NlPrint(( NL_CRITICAL,
                                  "Cannot Create GP parameter key event %ld (ignored)\n",
                                  GetLastError() ));
                    } else {
                        NlWaitGpParameters = WaitCount;
                        WaitHandles[NlWaitGpParameters] = GpParmEventHandle;
                        WaitCount++;
                        NlAssert( WaitCount <= NL_WAIT_COUNT );
                    }
                }

                if ( GpRegNotifyNeeded && GpParmHandle != NULL && GpParmEventHandle != NULL ) {
                    NetStatus = RegNotifyChangeKeyValue(
                                    GpParmHandle,
                                    TRUE,      // watch subtree
                                    REG_NOTIFY_CHANGE_LAST_SET,
                                    GpParmEventHandle,
                                    TRUE );     // Async

                    if ( NetStatus == NO_ERROR ) {
                        GpRegNotifyNeeded = FALSE;

                    // If GP has deleted the key,
                    //   recover from it by just closing GpParmHandle
                    //   to reopen it on the second try
                    } else if ( NetStatus == ERROR_KEY_DELETED ) {
                        NlPrint(( NL_CRITICAL, "Netlogon GP Parameters key deleted (recover)\n" ));
                        RegCloseKey( GpParmHandle );
                        GpParmHandle = NULL;
                        ResetEvent( GpParmEventHandle );
                    } else {
                        NlPrint(( NL_CRITICAL,
                                  "Cannot RegNotifyChangeKeyValue for GP 0x%lx (ignored)\n",
                                  NetStatus ));
                    }
                }

                //
                // If no error occured, no need to retry
                //
                if ( NetStatus == NO_ERROR ) {
                    break;
                }
            }

            NlReparse();

            //
            // Grab any changed parameters that affect this routine.
            //
            AnnouncerTimer.Period = NlGlobalParameters.Pulse * 1000L;
        }

        //
        // Wait for the next interesting event.
        //
        // On each iteration of the loop,
        //  we do an "extra" wait with a timeout of 0 to force mailslot
        //  processing to be more important that timeout processing.
        //
        // Since we can only compute a non-zero timeout by processing the
        // timeout events, using a constant 0 allows us to process all
        // non-timeout events before we compute the next true timeout value.
        //
        // This is especially important for handling async discovery.
        //  Our mailslot may be full of responses to discovery queries and
        //  we only have a 5 second timer before we ask for more responses.
        //  We want to avoid asking for additional responses until we finish
        //  processing those we have.
        //

        if ( MainLoopTimeout != 0 ) {
            NlPrint((NL_MAILSLOT_TEXT,
                    "Going to wait on mailslot. (Timeout: %ld)\n",
                    MainLoopTimeout));
        }

        WaitStatus = WaitForMultipleObjects( WaitCount,
                                             WaitHandles,
                                             FALSE,     // Wait for ANY handle
                                             MainLoopTimeout );

        MainLoopTimeout = 0; // Set default timeout


        //
        // If we've been asked to terminate,
        //  do so immediately
        //

        if  ( WaitStatus == NL_WAIT_TERMINATE ) {       // service termination
            goto Cleanup;


        //
        // Process timeouts and determine the timeout for the next iteration
        //

        } else if ( WaitStatus == WAIT_TIMEOUT ||       // timeout
                    WaitStatus == NL_WAIT_TIMER ) {     // someone changed a timer

            //
            // Assume there is no timeout to do.
            //
            // On each iteration of the loop we only process a single timer.
            // That ensures other events are more important than timers.
            //

            Timeout = (DWORD) -1;
            NlQuerySystemTime( &TimeNow );


            //
            // On the primary, timeout announcements to BDCs
            //

            if ( NlGlobalPdcDoReplication &&
                 TimerExpired( &NlGlobalPendingBdcTimer, &TimeNow, &Timeout )) {

                //
                // The work is done in the domain thread.
                //
                // Note that we don't need to worry about serializing
                //  this with previous announcement activity in the
                //  worker thread because there exists only one worker
                //  thread.  Also note that we don't run the risk of doing
                //  network I/O too often because this will be basically
                //  no-op if there are no outstanding BDCs to timeout.
                //
                NlPrimaryAnnouncementTimeout();

                NlGlobalPendingBdcTimer.StartTime = TimeNow;


            //
            // Check the scavenger timer
            //

            } else if ( TimerExpired( &NlGlobalScavengerTimer, &TimeNow, &Timeout ) ) {

                //
                // On workstation run the scavenger on main thread.
                //
                if ( NlGlobalMemberWorkstation ) {

                    NlWksScavenger();

                //
                // On domain controller, start scavenger thread if it is not
                //  running already.
                //
                } else {

                    EnterCriticalSection( &NlGlobalScavengerCritSect );
                    if ( !NlGlobalDcScavengerIsRunning ) {

                        if ( NlQueueWorkItem( &NlGlobalDcScavengerWorkItem, TRUE, FALSE ) ) {
                            NlGlobalDcScavengerIsRunning = TRUE;
                        }

                    }

                    //
                    // NlDcScavenger sets the StartTime,too
                    //  (But we have to reset the timer here to prevent it from
                    //  going off immediately again. We need to reset the period
                    //  (as well as the start time) since the period is set in
                    //  the registry notification processing to zero.)
                    //

                    NlGlobalScavengerTimer.StartTime = TimeNow;
                    NlGlobalScavengerTimer.Period = NlGlobalParameters.ScavengeInterval * 1000L;
                    LeaveCriticalSection( &NlGlobalScavengerCritSect );
                }


            //
            // Check the API timer
            //

            } else if ( TimerExpired( &NlGlobalApiTimer, &TimeNow, &Timeout)) {

                //
                // On worktstation, do the work in the main loop
                //
                if ( NlGlobalMemberWorkstation ) {
                    NlTimeoutApiClientSession( NlGlobalDomainInfo );

                //
                // On DC, timout APIs on all Hosted domains.
                //  Do this in domain threads so that not to block
                //  the main thread (which is critical for a DC) as
                //  the API timeout involves RPC.
                //
                } else {
                    DWORD DomFlags = DOM_API_TIMEOUT_NEEDED;
                    NlEnumerateDomains( FALSE, NlStartDomainThread, &DomFlags );
                }

                NlGlobalApiTimer.StartTime = TimeNow;

            //
            // Check the DNS Scavenger timer
            //

            } else if ( TimerExpired( &NlGlobalDnsScavengerTimer, &TimeNow, &Timeout)) {

                //
                // DnsScavenger sets the StartTime,too
                //  (But we have to reset the timer here to prevent it from
                //  going off immediately again.)
                //
                EnterCriticalSection( &NlGlobalDnsCritSect );
                NlGlobalDnsScavengerTimer.StartTime = TimeNow;
                NlGlobalDnsScavengerTimer.Period = (DWORD) MAILSLOT_WAIT_FOREVER;
                LeaveCriticalSection( &NlGlobalDnsCritSect );

                //
                // DNS scavenger does the work in a worker thread
                //

                NlDnsScavenge( TRUE,    // Normal periodic scavenge
                               TRUE,    // Refresh domain records in global list
                               FALSE,   // Don't force refresh if site coverage doesn't change
                               FALSE ); // Don't force record re-register


            //
            // Check the subnet and site update timer
            //

            } else if ( TimerExpired(&SubnetSiteUpdateTimer, &TimeNow, &Timeout) ) {

                SubnetSiteUpdateTimer.StartTime = TimeNow;
                SubnetSiteUpdateTimer.Period = (DWORD) MAILSLOT_WAIT_FOREVER;

                if ( !NlGlobalMemberWorkstation ) {
                    BOOLEAN SiteNameChanged = FALSE;

                    (VOID) NlSitesAddSubnetFromDs( &SiteNameChanged );

                    //
                    // If the Site Name changed,
                    //  tell DNS to re-register its names.
                    //
                    if ( SiteNameChanged || NlGlobalParameters.AutoSiteCoverage ) {
                        NlDnsForceScavenge( TRUE,  // refresh domain entries
                                            FALSE ); // don't force re-register
                    }
                }

            //
            // If we're the primary,
            //  periodically do announcements
            //

            } else if (NlGlobalPdcDoReplication &&
                TimerExpired( &AnnouncerTimer, &TimeNow, &Timeout ) ) {

                //
                // The work is done in the domain thread.
                //  Even though there is only one domain thread (so
                //  periodic announcements are serialized), we want
                //  to avoid adding a new work item if there is already
                //  one outstanding; otherwise we run a high risk of
                //  doing too much of periodic long network I/O.
                //

                LOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );
                if ( !NlGlobalPrimaryAnnouncementIsRunning ) {
                    DWORD DomFlags = DOM_PRIMARY_ANNOUNCE_NEEDED;

                    NlGlobalPrimaryAnnouncementIsRunning = TRUE;
                    UNLOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );

                    NlStartDomainThread( NlGlobalDomainInfo, &DomFlags );

                    LOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );
                }
                UNLOCK_SERVER_SESSION_TABLE( NlGlobalDomainInfo );

                AnnouncerTimer.StartTime = TimeNow;

            //
            // If we've gotten this far,
            //  we know the only thing left to do is to wait for the next event.
            //

            } else {
                MainLoopTimeout = Timeout;
            }


        //
        // Process interesting changelog events.
        //

        } else if ( WaitStatus == NlWaitNotify ) {


            //
            // If a "replicate immediately" event has happened,
            //  send a primary announcement.
            //
            LOCK_CHANGELOG();
            if ( NlGlobalChangeLogReplicateImmediately ) {

                NlGlobalChangeLogReplicateImmediately = FALSE;

                NlPrint((NL_MISC,
                        "NlMainLoop: Notification to replicate immediately\n" ));

                UNLOCK_CHANGELOG();

                //
                // Ignore this event on BDCs.
                //
                //  This event is never set on a BDC.  It may have been set
                //  prior to the role change while this machine was a PDC.
                //
                // There is only one domain thread, so this will be serialized
                //   with other anouncement activity.
                //

                if ( NlGlobalPdcDoReplication ) {
                    DWORD DomFlags = DOM_PRIMARY_ANNOUNCE_IMMEDIATE;
                    NlStartDomainThread( NlGlobalDomainInfo, &DomFlags );
                }
                LOCK_CHANGELOG();
            }

            //
            // Process any notifications that need processing
            //

            while ( !IsListEmpty( &NlGlobalChangeLogNotifications ) ) {
                PLIST_ENTRY ListEntry;
                PCHANGELOG_NOTIFICATION Notification;
                DWORD DomFlags;

                ListEntry = RemoveHeadList( &NlGlobalChangeLogNotifications );
                UNLOCK_CHANGELOG();

                Notification = CONTAINING_RECORD(
                                    ListEntry,
                                    CHANGELOG_NOTIFICATION,
                                    Next );

                switch ( Notification->EntryType ) {
                case ChangeLogTrustAccountAdded: {
                    NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType =
                        *(NETLOGON_SECURE_CHANNEL_TYPE*)&Notification->ObjectGuid;

                    NlPrint((NL_MISC,
                            "NlMainLoop: Notification that trust account added (or changed) %wZ 0x%lx %lx\n",
                            &Notification->ObjectName,
                            Notification->ObjectRid,
                            SecureChannelType ));

                    // This event happens on both a PDC and BDC
                    (VOID) NlCheckServerSession( Notification->ObjectRid,
                                                 &Notification->ObjectName,
                                                 SecureChannelType );

                    break;
                    }

                case ChangeLogTrustAccountDeleted:
                    NlPrint((NL_MISC,
                            "NlMainLoop: Notification that trust account deleted\n" ));
                    // This event happens on both a PDC and BDC
                    NlFreeServerSessionForAccount( &Notification->ObjectName );
                    break;

                case ChangeLogTrustDeleted:
                case ChangeLogTrustAdded:

                    //
                    // When a TrustedDomainObject is deleted,
                    //  don't just delete the ClientSession.
                    //  There still might be an XREF object stating an indirect trust.
                    //
                    NlPrint((NL_MISC,
                            "NlMainLoop: Notification that TDO added or deleted.\n" ));
                    DomFlags = DOM_TRUST_UPDATE_NEEDED;
                    NlStartDomainThread( NlGlobalDomainInfo, &DomFlags );
                    break;

                case ChangeLogRoleChanged:
                    NlPrint((NL_MISC,
                            "NlMainLoop: Notification that role changed\n" ));
                    DomFlags = DOM_ROLE_UPDATE_NEEDED;
                    NlStartDomainThread( NlGlobalDomainInfo, &DomFlags );
                    break;

                case ChangeDnsNames:
                    NlPrint((NL_MISC,
                            "NlMainLoop: Notification that registered DNS names should change\n" ));
                    //
                    // Register any names that need it.
                    //  (The caller passed TRUE or FALSE in ObjectRid to indicate whether
                    //  or not to force re-registration.)
                    //
                    NlDnsForceScavenge( TRUE,  // refresh domain entries
                                        Notification->ObjectRid );
                    break;

                case ChangeLogDsChanged: {
                    NL_DS_CHANGE_TYPE DsChangeType = (NL_DS_CHANGE_TYPE) Notification->ObjectRid;

                    switch ( DsChangeType ) {
                    case NlSubnetObjectChanged:
                    case NlSiteObjectChanged:
                    case NlSiteChanged:

                        if ( !NlGlobalMemberWorkstation ) {
                            NlPrint(( NL_MISC,
                                      "NlMainLoop: Notification %lu that DS site info changed\n",
                                      DsChangeType ));

                            //
                            // Reset the subnet and site update timer to run in 2 seconds.
                            //  There are two reasons to delay the processing:
                            //
                            //  * There might be many objects created in one batch. It's better
                            //    to consolidate all notifications and do one refresh, especially
                            //    if there are many objects created in which case the DS directory
                            //    read is going to be expensive.
                            //  * We don't have a way to sync with ISM for site object changes.
                            //    So we have to wait a little in the hope that ISM will rebuild
                            //    its data in the meantime.
                            //
                            //  Note that we don't need to reset the timer event as we will notice
                            //   this change on the next iteration of the main loop.
                            //
                            NlQuerySystemTime( &SubnetSiteUpdateTimer.StartTime );
                            SubnetSiteUpdateTimer.Period = 2000;
                        }
                        break;

                    case NlNdncChanged:

                        if ( !NlGlobalMemberWorkstation ) {
                            BOOLEAN ServicedNdncChanged = FALSE;
                            NlPrint(( NL_MISC, "NlMainLoop: Notification that NDNC changed\n" ));

                            NetStatus = NlUpdateServicedNdncs(
                                            NlGlobalDomainInfo->DomUnicodeComputerNameString.Buffer,
                                            NlGlobalDomainInfo->DomUnicodeDnsHostNameString.Buffer,
                                            FALSE,  // Don't call NlExit on failure
                                            &ServicedNdncChanged );

                            if ( NetStatus == NO_ERROR && ServicedNdncChanged ) {
                                NlDnsForceScavenge( TRUE,  // refresh domain entries
                                                    FALSE ); // don't force re-register
                            }
                        }
                        break;

                    case NlDnsRootAliasChanged:

                        if ( !NlGlobalMemberWorkstation ) {
                            NTSTATUS Status;
                            BOOL AliasNamesChanged = FALSE;
                            NlPrint(( NL_MISC, "NlMainLoop: Notification that DnsRootAlias changed\n" ));

                            Status = NlUpdateDnsRootAlias( NlGlobalDomainInfo,
                                                           &AliasNamesChanged );

                            if ( NT_SUCCESS(Status) && AliasNamesChanged ) {
                                NlDnsForceScavenge( TRUE,  // refresh domain entries
                                                    FALSE ); // don't force re-register
                            }
                        }
                        break;

                    case NlOrgChanged:
                        NlPrint((NL_MISC,
                                "NlMainLoop: Notification that ORG tree changed\n" ));
                        DomFlags = DOM_TRUST_UPDATE_NEEDED;
                        NlStartDomainThread( NlGlobalDomainInfo, &DomFlags );
                        break;

                    default:
                        NlPrint((NL_CRITICAL,
                                "Invalid DsChangeType: %ld\n",
                                DsChangeType ));

                    }
                    break;
                }

                case ChangeLogLsaPolicyChanged: {
                    POLICY_NOTIFICATION_INFORMATION_CLASS LsaPolicyChangeType =
                                  (POLICY_NOTIFICATION_INFORMATION_CLASS) Notification->ObjectRid;
                    NlPrint((NL_MISC,
                            "NlMainLoop: Notification that LSA Policy changed\n" ));

                    switch ( LsaPolicyChangeType ) {
                    case PolicyNotifyDnsDomainInformation: {
                        LPWSTR DomainName = NULL;
                        LPWSTR DnsDomainName = NULL;
                        PSID AccountDomainSid = NULL;
                        PSID PrimaryDomainSid = NULL;
                        GUID *PrimaryDomainGuid = NULL;
                        PCLIENT_SESSION ClientSession = NULL;
                        BOOLEAN DnsForestNameChanged;
                        BOOLEAN DnsDomainNameChanged;
                        BOOLEAN NetbiosDomainNameChanged;
                        BOOLEAN DomainGuidChanged;
                        NTSTATUS Status;


                        //
                        // Get the updated information from the LSA.
                        //
                        // (Update the TreeName as a side effect.)
                        //
                        //
                        NetStatus = NlGetDomainName(
                                        &DomainName,
                                        &DnsDomainName,
                                        &AccountDomainSid,
                                        &PrimaryDomainSid,
                                        &PrimaryDomainGuid,
                                        &DnsForestNameChanged );

                        if ( NetStatus == NO_ERROR ) {
                            PDOMAIN_INFO DomainInfo;

                            DomainInfo = NlFindNetbiosDomain( NULL, TRUE );    // Primary domain

                            if ( DomainInfo != NULL ) {
                                //
                                // Set the DomainNames on the domain.
                                //

                                // ???: retry later on failure
                                (VOID) NlSetDomainNameInDomainInfo(
                                                    DomainInfo,
                                                    DnsDomainName,
                                                    DomainName,
                                                    PrimaryDomainGuid,
                                                    &DnsDomainNameChanged,
                                                    &NetbiosDomainNameChanged,
                                                    &DomainGuidChanged );

                                //
                                // If the Netbios domain name has changed,
                                //  re-register the <DomainName>[1B] name.
                                //
                                // Merely flag the fact here that it needs to be renamed.
                                // Wait to do the actual rename after the bowser
                                // knows about the new emulated domain.
                                //

                                EnterCriticalSection(&NlGlobalDomainCritSect);
                                if ( NetbiosDomainNameChanged && DomainInfo->DomRole == RolePrimary ) {
                                    DomainInfo->DomFlags |= DOM_RENAMED_1B_NAME;
                                }
                                LeaveCriticalSection(&NlGlobalDomainCritSect);

                                //
                                // If there is a client session associated with this domain,
                                //  set the information there, too.
                                //

                                ClientSession = NlRefDomClientSession( DomainInfo );

                                if ( ClientSession != NULL) {

                                    //
                                    // Must be a writer to change
                                    if ( NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {

                                        UNICODE_STRING NetbiosDomainNameString;
                                        UNICODE_STRING DnsDomainNameString;


                                        //
                                        // Update any names that are on the ClientSession structure.
                                        //
                                        // ???: The routine below interprets a NULL parameter as
                                        //  a lack of interest in changing the name.  We're calling it
                                        //  as specifying that the name no longer exists.
                                        //  (This only applies to the GUID since the other fields
                                        //  are never passed in as NULL.)
                                        //  But that means this is a NT 4 domain and the GUID won't be used.
                                        //

                                        RtlInitUnicodeString( &NetbiosDomainNameString, DomainName );
                                        RtlInitUnicodeString( &DnsDomainNameString, DnsDomainName );

                                        // ???: retry later on failure
                                        LOCK_TRUST_LIST( DomainInfo );
                                        (VOID ) NlSetNamesClientSession( DomainInfo->DomClientSession,
                                                                       &NetbiosDomainNameString,
                                                                       &DnsDomainNameString,
                                                                       PrimaryDomainSid,
                                                                       PrimaryDomainGuid );
                                        UNLOCK_TRUST_LIST( DomainInfo );

                                        //
                                        // If the domain changed,
                                        //  Drop the secure channel since it is to the wrong DC.
                                        //

                                        if ( DnsDomainNameChanged ||
                                             NetbiosDomainNameChanged ||
                                             DomainGuidChanged ) {

                                            NlSetStatusClientSession( ClientSession, STATUS_NO_LOGON_SERVERS );

                                            //
                                            // Indicate that we no longer know what site we're in.
                                            //
                                            NlSetDynamicSiteName( NULL );

                                            //
                                            // Grab the trusted domain list from where join left it.
                                            //

                                            (VOID) NlReadPersitantTrustedDomainList();

                                        }

                                        NlResetWriterClientSession( ClientSession );
                                    }

                                    NlUnrefClientSession( ClientSession );

                                }


                                NlDereferenceDomain( DomainInfo );
                            }

                            //
                            // If one of the names that changed is one of the
                            //  names registered in DNS,
                            //  update any DNS names
                            //

                            if ( (DnsForestNameChanged ||
                                  DnsDomainNameChanged ||
                                  DomainGuidChanged ) &&
                                 !NlGlobalMemberWorkstation ) {
                                NlDnsForceScavenge( TRUE,  // refresh domain entries
                                                    FALSE ); // don't force re-register
                            }

                            //
                            // Tell the browser about the domain rename
                            //

                            Status = NlBrowserRenameDomain( NULL, DomainName );

                            if ( !NT_SUCCESS(Status) ) {
                                NlPrint((NL_CRITICAL,
                                        "Browser cannot rename domain to: %ws 0x%lx\n",
                                        DomainName,
                                        Status ));
                            }

                        }


                        if ( DomainName != NULL ) {
                            (VOID)LocalFree( DomainName );
                        }
                        if ( DnsDomainName != NULL ) {
                            (VOID)LocalFree( DnsDomainName );
                        }
                        if ( AccountDomainSid != NULL ) {
                            (VOID)LocalFree( AccountDomainSid );
                        }
                        if ( PrimaryDomainSid != NULL ) {
                            (VOID)LocalFree( PrimaryDomainSid );
                        }
                        if ( PrimaryDomainGuid != NULL ) {
                            (VOID)LocalFree( PrimaryDomainGuid );
                        }
                        break;
                    }

                    default:
                        NlPrint((NL_CRITICAL,
                                "Invalid LsaPolicyChangeType: %ld\n",
                                LsaPolicyChangeType ));

                    }
                    break;
                }

                //
                // NTDS-DSA object deleted
                //

                case ChangeLogNtdsDsaDeleted:
                    (VOID) NlDnsNtdsDsaDeletion (
                                Notification->DomainName.Buffer,
                                &Notification->DomainGuid,
                                &Notification->ObjectGuid,
                                Notification->ObjectName.Buffer );

                    break;

                default:
                    NlPrint((NL_CRITICAL,
                            "Invalid ChangeLogNotification: %ld %wZ\n",
                            Notification->EntryType,
                            &Notification->ObjectName ));

                }

                NetpMemoryFree( Notification );
                LOCK_CHANGELOG();
            }

            UNLOCK_CHANGELOG();

        //
        // Process WINSOCK PNP events.
        //

        } else if ( WaitStatus == NlWaitWinsock ) {

            //
            // Get the new list of IP addresses
            //

            if ( NlHandleWsaPnp() ) {
                //
                // The list changed.
                //
                if ( !NlGlobalMemberWorkstation ) {
                    NlDnsForceScavenge( TRUE,  // refresh domain entries
                                        TRUE ); // force re-register

                    //
                    // Flush any caches that aren't valid any more since there
                    // is now a new transport
                    //
                    // ?? Differentiate between adding a transport and removing one
                    //
                    NlFlushCacheOnPnp();

                }

            }


        //
        // Process mailslot messages.
        //

        } else if ( WaitStatus == NL_WAIT_MAILSLOT ) {
            PDOMAIN_INFO DomainInfo;
            DWORD Version;
            DWORD VersionFlags;
            DWORD BytesRead;

            LPBYTE Message;
            LPWSTR TransportName;
            PSOCKADDR ClientSockAddr;
            PNL_TRANSPORT Transport;
            LPWSTR ServerOrDomainName;
            NETLOGON_PNP_OPCODE NlPnpOpcode;

            //
            // Variables for unmarshalling the message read.
            //

            PCHAR Where;
            LPSTR OemWorkstationName;
            LPSTR OemUserName;
            LPSTR OemMailslotName;

            LPWSTR UnicodeWorkstationName;
            LPWSTR UnicodeUserName;

            LPSTR OemTemp;

            LPWSTR UnicodeTemp;

            DWORD ResponseBufferSize;
            BYTE ResponseBuffer[NETLOGON_MAX_MS_SIZE];    // Buffer to build response in


            if ( !NlMailslotOverlappedResult( &Message,
                                              &BytesRead,
                                              &TransportName,
                                              &Transport,
                                              &ClientSockAddr,
                                              &ServerOrDomainName,
                                              &IgnoreDuplicatesOfThisMessage,
                                              &NlPnpOpcode )){
                // Just continue if there really isn't a message
                continue;
            }


            //
            // If this is a PNP notification,
            //  process it.
            //

            if ( NlPnpOpcode != NlPnpMailslotMessage ) {
                BOOLEAN IpTransportChanged = FALSE;

                switch ( NlPnpOpcode ) {
                case NlPnpTransportBind:
                case NlPnpNewIpAddress:
                    if (!NlTransportAddTransportName(TransportName, &IpTransportChanged )) {
                        NlPrint((NL_CRITICAL,
                                "PNP: %ws: cannot add transport.\n",
                                TransportName ));
                    }

                    //
                    // Flush any caches that aren't valid any more since there
                    // is now a new transport
                    //
                    NlFlushCacheOnPnp();

                    break;

                case NlPnpTransportUnbind:
                    IpTransportChanged = NlTransportDisableTransportName( TransportName );
                    break;

                case NlPnpDomainRename:
                    NlPrint((NL_DOMAIN,
                            "PNP: Bowser says the domain has been renamed\n" ));

                    //
                    // Now that the hosted domain name in the bowser
                    // matches the one in netlogon,
                    // Ensure the DomainName<1B> names are properly registered.
                    //

                    (VOID) NlEnumerateDomains( FALSE, NlBrowserFixAllNames, NULL );
                    break;

                case NlPnpNewRole:
                    // We don't care that the browser has a new role.
                    break;

                default:
                    NlPrint((NL_CRITICAL,
                            "Unknown PNP opcode 0x%x\n",
                            NlPnpOpcode ));
                    break;
                }

                // Just continue if there really isn't a message
                continue;
            }

            //
            // Ignore mailslot messages to NETLOGON mailslot on workstation.
            //

            if ( NlGlobalMemberWorkstation ) {
                NlPrint((NL_CRITICAL,"NETLOGON mailslot on workstation (ignored)\n" ));
                continue;
            }


            //
            // ASSERT: Message and BytesRead describe a newly read message
            //
            //
            // Got a message. Check for bad length just in case.
            //

            if (BytesRead < sizeof(unsigned short) ) {
                NlPrint((NL_CRITICAL,"message size bad %ld\n", BytesRead ));
                continue;                     // Need at least an opcode
            }

            //
            // Here with a request to process in the Message.
            //

            Version = NetpLogonGetMessageVersion( Message, &BytesRead, &VersionFlags );

            if (Version == LMUNKNOWNNT_MESSAGE) {

                //
                // received a non-supported NT message.
                //

                NlPrint((NL_CRITICAL,
                        "Received a non-supported NT message, Opcode is 0x%x\n",
                        ((PNETLOGON_LOGON_QUERY)Message)->Opcode ));

                continue;
            }


            //
            // Determine which domain this message came in for.
            //

            DomainInfo = NlFindNetbiosDomain( ServerOrDomainName, FALSE );

            if ( DomainInfo == NULL ) {
                DomainInfo = NlFindDomainByServerName( ServerOrDomainName );
                if ( DomainInfo == NULL ) {
                    NlPrint((NL_CRITICAL,
                            "%ws: Received message for this unsupported domain\n",
                            ServerOrDomainName ));
                    continue;
                }
            }


            //
            // Handle a logon request from a UAS client
            //

            switch ( ((PNETLOGON_LOGON_QUERY)Message)->Opcode) {
            case LOGON_REQUEST: {
                USHORT RequestCount;

                //
                // Unmarshall the incoming message.
                //

                if ( Version == LMNT_MESSAGE ) {
                    break;
                }

                Where =  ((PNETLOGON_LOGON_REQUEST)Message)->ComputerName;
                if ( !NetpLogonGetOemString(
                        (PNETLOGON_LOGON_REQUEST)Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_LOGON_REQUEST)Message)->ComputerName),
                        &OemWorkstationName )) {
                    break;
                }
                if ( !NetpLogonGetOemString(
                        (PNETLOGON_LOGON_REQUEST)Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_LOGON_REQUEST)Message)->UserName),
                        &OemUserName )) {
                    break;
                }
                if ( !NetpLogonGetOemString(
                        (PNETLOGON_LOGON_REQUEST)Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_LOGON_REQUEST)Message)->MailslotName),
                        &OemMailslotName )) {
                    break;
                }

                // LM 2.x puts request count right before token
                Where = Message + BytesRead - 2;
                if ( !NetpLogonGetBytes(
                        (PNETLOGON_LOGON_REQUEST)Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_LOGON_REQUEST)Message)->RequestCount),
                        &RequestCount )) {
                    break;
                }

                //
                // Handle the logon request
                //

                UnicodeUserName = NetpLogonOemToUnicode( OemUserName );
                if ( UnicodeUserName == NULL ) {
                    break;
                }

                UnicodeWorkstationName = NetpLogonOemToUnicode( OemWorkstationName );
                if( UnicodeWorkstationName == NULL ) {
                    NetpMemoryFree( UnicodeUserName );
                    break;
                }


                //
                // Handle the primary query request
                //

                if ( LogonRequestHandler(
                                     Transport->TransportName,
                                     DomainInfo,
                                     FALSE, // don't use name aliases
                                     NULL,  // Domain Sid not known
                                     Version,
                                     VersionFlags,
                                     UnicodeUserName,
                                     RequestCount,
                                     UnicodeWorkstationName,
                                     USER_NORMAL_ACCOUNT,
                                     Transport->IpAddress,
                                     ClientSockAddr,
                                     ResponseBuffer,
                                     &ResponseBufferSize ) ) {

                    NTSTATUS Status;

                    Status = NlBrowserSendDatagram( DomainInfo,
                                                    0,
                                                    UnicodeWorkstationName,
                                                    ComputerName,
                                                    Transport->TransportName,
                                                    OemMailslotName,
                                                    ResponseBuffer,
                                                    ResponseBufferSize,
                                                    FALSE,   // Send asynch to avoid blocking main thread
                                                    NULL );  // Don't flush Netbios cache

                    if ( NT_SUCCESS(Status) ) {
                        IgnoreDuplicatesOfThisMessage = TRUE;
                    }

                }

                NetpMemoryFree( UnicodeWorkstationName );
                NetpMemoryFree( UnicodeUserName );


                break;
            }

            //
            // Handle a logon request from a SAM client
            //

            case LOGON_SAM_LOGON_REQUEST: {
                USHORT RequestCount;
                ULONG AllowableAccountControlBits;
                DWORD DomainSidSize;
                PCHAR DomainSid = NULL;

                //
                // Unmarshall the incoming message.
                //


                if ( Version != LMNT_MESSAGE ) {
                    break;
                }

                RequestCount = ((PNETLOGON_SAM_LOGON_REQUEST)Message)->RequestCount;

                Where =  (PCHAR)
                    (((PNETLOGON_SAM_LOGON_REQUEST)Message)->UnicodeComputerName);

                if ( !NetpLogonGetUnicodeString(
                        (PNETLOGON_SAM_LOGON_REQUEST)Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_SAM_LOGON_REQUEST)Message)->
                            UnicodeComputerName),
                        &UnicodeWorkstationName )) {
                    break;
                }
                if ( !NetpLogonGetUnicodeString(
                        (PNETLOGON_SAM_LOGON_REQUEST)Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_SAM_LOGON_REQUEST)Message)->
                            UnicodeUserName),
                        &UnicodeUserName )) {
                    break;
                }
                if ( !NetpLogonGetOemString(
                        (PNETLOGON_SAM_LOGON_REQUEST)Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_SAM_LOGON_REQUEST)Message)->
                            MailslotName),
                        &OemMailslotName )) {
                    break;
                }
                if ( !NetpLogonGetBytes(
                        (PNETLOGON_SAM_LOGON_REQUEST)Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_SAM_LOGON_REQUEST)Message)->
                            AllowableAccountControlBits),
                        &AllowableAccountControlBits )) {
                    break;
                }

                //
                // Get the domain SID.
                //
                // Don't make the following check mandatory.  Chicago
                // uses this message type without the SID present. Oct 1993.
                //


                if( Where < ((PCHAR)Message + BytesRead ) ) {

                    //
                    // Read Domain SID Length
                    //

                    if ( !NetpLogonGetBytes(
                            (PNETLOGON_SAM_LOGON_REQUEST)Message,
                            BytesRead,
                            &Where,
                            sizeof( ((PNETLOGON_SAM_LOGON_REQUEST)Message)->
                                DomainSidSize),
                            &DomainSidSize )) {

                        break;

                    }

                    //
                    // Read the SID itself.
                    //

                    if( DomainSidSize > 0 ) {


                        if ( !NetpLogonGetDomainSID(
                                (PNETLOGON_SAM_LOGON_REQUEST)Message,
                                BytesRead,
                                &Where,
                                DomainSidSize,
                                &DomainSid )) {

                            break;
                        }

                    }
                }



                //
                // Handle the logon request
                //

                if ( LogonRequestHandler(
                                     Transport->TransportName,
                                     DomainInfo,
                                     FALSE, // don't use name aliases
                                     DomainSid,
                                     Version,
                                     VersionFlags,
                                     UnicodeUserName,
                                     RequestCount,
                                     UnicodeWorkstationName,
                                     AllowableAccountControlBits,
                                     Transport->IpAddress,
                                     ClientSockAddr,
                                     ResponseBuffer,
                                     &ResponseBufferSize ) ) {
                    NTSTATUS Status;

                    Status = NlBrowserSendDatagram( DomainInfo,
                                                    0,
                                                    UnicodeWorkstationName,
                                                    ComputerName,
                                                    Transport->TransportName,
                                                    OemMailslotName,
                                                    ResponseBuffer,
                                                    ResponseBufferSize,
                                                    FALSE,   // Send asynch to avoid blocking main thread
                                                    NULL );  // Don't flush Netbios cache

                    if ( NT_SUCCESS(Status) ) {
                        IgnoreDuplicatesOfThisMessage = TRUE;
                    }

                }


                break;
            }

            //
            // Handle Logon Central query.
            //
            // This query could be sent by either LM1.0, LM 2.0 or LM NT Netlogon
            // services. We ignore LM 2.0  and LM NT queries since they are merely
            // trying
            // to find out if there are any LM1.0 netlogon services in the domain.
            // For LM 1.0 we respond with a LOGON_CENTRAL_RESPONSE to prevent the
            // starting LM1.0 netlogon service from starting.
            //

            case LOGON_CENTRAL_QUERY:

                if ( Version != LMUNKNOWN_MESSAGE ) {
                    break;
                }

                //
                // Drop on through to LOGON_DISTRIB_QUERY to send the response
                //


            //
            // Handle a Logon Disrib query
            //
            // LM2.0 NETLOGON server never sends this query hence it
            // must be another LM1.0 NETLOGON server trying to start up
            // in non-centralized mode. LM2.0 NETLOGON server will respond
            // with LOGON_CENTRAL_RESPONSE to prevent this.
            //

            case LOGON_DISTRIB_QUERY:


                //
                // Unmarshall the incoming message.
                //

                Where = ((PNETLOGON_LOGON_QUERY)Message)->ComputerName;
                if ( !NetpLogonGetOemString(
                        Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_LOGON_QUERY)Message)->ComputerName ),
                        &OemWorkstationName )) {
                    break;
                }
                if ( !NetpLogonGetOemString(
                        Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_LOGON_QUERY)Message)->MailslotName ),
                        &OemMailslotName )) {
                    break;
                }

                //
                // Build the response
                //

                ((PNETLOGON_LOGON_QUERY)ResponseBuffer)->Opcode = LOGON_CENTRAL_RESPONSE;
                ResponseBufferSize = sizeof( unsigned short);    // opcode only

#if NETLOGONDBG
                NlPrintDom((NL_MAILSLOT, DomainInfo,
                         "Sent '%s' message to %s[%s] on %ws.\n",
                         NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)ResponseBuffer)->Opcode),
                         OemWorkstationName,
                         NlDgrNameType(ComputerName),
                         TransportName ));
#endif // NETLOGONDBG

                //
                // NlBrowserSendDatagramA always sends asynchronously,
                //  so we are not blocking the main thread here
                //
                (VOID) NlBrowserSendDatagramA( DomainInfo,
                                              0,
                                              OemWorkstationName,
                                              ComputerName,
                                              TransportName,
                                              OemMailslotName,
                                              ResponseBuffer,
                                              ResponseBufferSize );

                break;


            //
            // Handle LOGON_PRIMARY_QUERY
            //
            // If we're the PDC, always respond to this message
            //  identifying ourselves.
            //
            // Otherwise, only respond to the message if it is from a Lanman 2.x
            //  netlogon trying to see if it can start up as a PDC.  In that
            //  case, pretend we are a PDC to prevent the Lanman 2.x PDC from
            //  starting.
            //
            //

            case LOGON_PRIMARY_QUERY:


                //
                // Unmarshall the incoming message.
                //


                Where =((PNETLOGON_LOGON_QUERY)Message)->ComputerName;
                if ( !NetpLogonGetOemString(
                        Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_LOGON_QUERY)Message)->ComputerName ),
                        &OemWorkstationName )) {

                    break;
                }
                if ( !NetpLogonGetOemString(
                        Message,
                        BytesRead,
                        &Where,
                        sizeof( ((PNETLOGON_LOGON_QUERY)Message)->MailslotName ),
                        &OemMailslotName )) {
                    break;
                }

                UnicodeWorkstationName =
                    NetpLogonOemToUnicode( OemWorkstationName );

                if( UnicodeWorkstationName == NULL ) {

                    NlPrintDom((NL_CRITICAL, DomainInfo,
                            "Out of memory to send logon response\n"));
                    break;
                }


                //
                // Handle the primary query request
                //

                if ( PrimaryQueryHandler(Transport->TransportName,
                                         DomainInfo,
                                         FALSE, // don't use name aliases
                                         Version,
                                         VersionFlags,
                                         UnicodeWorkstationName,
                                         Transport->IpAddress,
                                         ClientSockAddr,
                                         ResponseBuffer,
                                         &ResponseBufferSize ) ) {
                    NTSTATUS Status;

                    Status = NlBrowserSendDatagram( DomainInfo,
                                                    0,
                                                    UnicodeWorkstationName,
                                                    ComputerName,
                                                    Transport->TransportName,
                                                    OemMailslotName,
                                                    ResponseBuffer,
                                                    ResponseBufferSize,
                                                    FALSE,   // Send asynch to avoid blocking main thread
                                                    NULL );  // Don't flush Netbios cache

                    if ( NT_SUCCESS(Status) ) {
                        IgnoreDuplicatesOfThisMessage = TRUE;
                    }

                }

                NetpMemoryFree( UnicodeWorkstationName );


                break;


            //
            // Handle LOGON_FAIL_PRIMARY
            //

            case LOGON_FAIL_PRIMARY:

                //
                // If we are the primary,
                //  let everyone know we are really alive.
                //

                if ( NlGlobalPdcDoReplication ) {
                    // Send a UAS_CHANGE to everyone.
                    // Pretend it's time to do normal announcement
                    DWORD DomFlags = DOM_PRIMARY_ANNOUNCE_NEEDED;
                    NlStartDomainThread( NlGlobalDomainInfo, &DomFlags );
                    break;
                }

                break;


            //
            // Handle LOGON_UAS_CHANGE
            //

            case LOGON_UAS_CHANGE:


                //
                // Only accept messages from an NT PDC.
                //

                if ( Version != LMNT_MESSAGE ) {
                    break;
                }

                //
                // Only accepts messages if we're doing replication.
                //

                NlPrint((NL_CRITICAL,
                        "UAS Change message ignored since replication not enabled on this BDC.\n" ));

                break;




            //
            // Message not sent since NT3.1.
            // We ingnore this message and wait for the announcement.
            //
            case LOGON_START_PRIMARY:
                break;



            //
            // Messages used for NetLogonEnum support.
            //
            //  Simply ignore the messages
            //

            case LOGON_NO_USER:
            case LOGON_RELOGON_RESPONSE:
            case LOGON_WKSTINFO_RESPONSE:

                break;


            //
            // Handle unidentified opcodes
            //

            default:

                //
                // Unknown request, continue for re-issue of read.
                //

                NlPrintDom((NL_CRITICAL, DomainInfo,
                        "Unknown op-code in mailslot message 0x%x\n",
                        ((PNETLOGON_LOGON_QUERY)Message)->Opcode ));

                break;
            }

            //
            // Dereference the domain.
            //

            if ( DomainInfo != NULL ) {
                NlDereferenceDomain( DomainInfo );
            }


        //
        // Process registry change notifications
        //

        } else if ( WaitStatus == NlWaitParameters ) {
            NlPrint((NL_CRITICAL,
                    "NlMainLoop: Registry changed\n" ));
            RegNotifyNeeded = TRUE;

        //
        // Process GP registry change notifications
        //

        } else if ( WaitStatus == NlWaitGpParameters ) {
            NlPrint((NL_CRITICAL,
                    "NlMainLoop: GP Registry changed\n" ));
            GpRegNotifyNeeded = TRUE;

        //
        // Handle all other reasons of waking up
        //

        } else {
            NetStatus = GetLastError();
            NlPrint((NL_CRITICAL,
                    "NlMainLoop: Invalid wait status %ld %ld\n",
                    WaitStatus, NetStatus ));
            NlExit(NELOG_NetlogonSystemError, NetStatus, LogErrorAndNetStatus, NULL);
            goto Cleanup;
        }


    }

Cleanup:
    if ( ParmEventHandle != NULL ) {
        CloseHandle( ParmEventHandle );
    }
    if ( ParmHandle != NULL ) {
        RegCloseKey( ParmHandle );
    }
    if ( GpParmEventHandle != NULL ) {
        CloseHandle( GpParmEventHandle );
    }
    if ( GpParmHandle != NULL ) {
        RegCloseKey( GpParmHandle );
    }

    return;
}


int
NlNetlogonMain(
    IN DWORD argc,
    IN LPWSTR *argv
    )

/*++

Routine Description:

        Main routine for Netlogon service.

        This routine initializes the netlogon service.  This thread becomes
        the thread that reads logon mailslot messages.

Arguments:

    argc, argv - Command line arguments for the service.

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;
    PDB_INFO DBInfo;
    DWORD i;
    LARGE_INTEGER TimeNow;



    //
    // Initialize all global variable.
    //
    // We can't rely on this happening at load time since this address
    // space is shared by other services.
    //

    RtlZeroMemory( &NlGlobalParameters, sizeof(NlGlobalParameters) );
    NlGlobalMailslotHandle = NULL;
    NlGlobalNtDsaHandle = NULL;
    NlGlobalDsApiDllHandle = NULL;
    NlGlobalIsmDllHandle = NULL;
    NlGlobalRpcServerStarted = FALSE;
    NlGlobalServerSupportsAuthRpc = TRUE;
    NlGlobalTcpIpRpcServerStarted = FALSE;
    NlGlobalUnicodeComputerName = NULL;
    NlGlobalNetlogonSecurityDescriptor = NULL;

    try {
        InitializeCriticalSection( &NlGlobalChallengeCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NlPrint(( NL_CRITICAL, "Cannot initialize NlGlobalChallengeCritSect\n" ));
        return (int) ERROR_NOT_ENOUGH_MEMORY;
    }
    InitializeListHead( &NlGlobalChallengeList );
    NlGlobalChallengeCount = 0;

    InitializeListHead( &NlGlobalBdcServerSessionList );
    NlGlobalBdcServerSessionCount = 0;

    NlGlobalPdcDoReplication = FALSE;

    NlGlobalWinSockInitialized = FALSE;

    NlGlobalIpTransportCount = 0;
    InitializeListHead( &NlGlobalTransportList );
    InitializeListHead( &NlGlobalDnsList );
    NlGlobalUnicodeDnsForestName = NULL;
    NlGlobalUnicodeDnsForestNameLen = 0;
    RtlInitUnicodeString( &NlGlobalUnicodeDnsForestNameString, NULL );
    NlGlobalUtf8DnsForestName = NULL;
    NlGlobalUtf8DnsForestNameAlias = NULL;
    NlGlobalWinsockPnpSocket = INVALID_SOCKET;
    NlGlobalWinsockPnpEvent = NULL;
    NlGlobalWinsockPnpAddresses = NULL;
    NlGlobalWinsockPnpAddressSize = 0;

    InitializeListHead( &NlGlobalPendingBdcList );
    NlGlobalPendingBdcCount = 0;
    NlGlobalPendingBdcTimer.Period = (DWORD) MAILSLOT_WAIT_FOREVER;
    NlGlobalPrimaryAnnouncementIsRunning = FALSE;

    NlGlobalTerminateEvent = NULL;
    NlGlobalStartedEvent = NULL;
    NlGlobalTimerEvent = NULL;

    NlGlobalServiceHandle = 0;

    NlGlobalServiceStatus.dwServiceType = SERVICE_WIN32;
    NlGlobalServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    NlGlobalServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                        SERVICE_ACCEPT_PAUSE_CONTINUE;
    NlGlobalServiceStatus.dwCheckPoint = 1;
    NlGlobalServiceStatus.dwWaitHint = NETLOGON_INSTALL_WAIT;

    SET_SERVICE_EXITCODE(
        NO_ERROR,
        NlGlobalServiceStatus.dwWin32ExitCode,
        NlGlobalServiceStatus.dwServiceSpecificExitCode
        );

    NlGlobalClientSession = NULL;
    NlGlobalDomainInfo = NULL;
    NlGlobalServicedDomainCount = 0;
    NlGlobalTrustedDomainList = NULL;
    NlGlobalParameters.SiteName = NULL;
    NlGlobalTrustedDomainCount = 0;
    NlGlobalTrustedDomainListTime.QuadPart = 0;
    NlGlobalSiteNameSetTime.QuadPart = 0;
    NlGlobalNoClientSiteCount = 0;
    NlQuerySystemTime( &NlGlobalNoClientSiteEventTime );
    NlGlobalBindingHandleCount = 0;
    NlGlobalApiTimer.Period = (DWORD) MAILSLOT_WAIT_FOREVER;
    NlGlobalDnsScavengerTimer.Period = (DWORD) MAILSLOT_WAIT_FOREVER;
    NlGlobalNetlogonUnloaded = NlGlobalChangeLogDllUnloaded;
    NlGlobalDsRunningUnknown = TRUE;
    RtlZeroMemory( &NlGlobalZeroGuid, sizeof(NlGlobalZeroGuid) );
    NlGlobalJoinLogicDone = FALSE;


    //
    // Force the scavenger to start immediately.
    //
    // We want the password on the trust account to change immediately
    //  on the very first boot.
    //

    NlGlobalScavengerTimer.StartTime.QuadPart = 0;
    NlGlobalScavengerTimer.Period = NlGlobalParameters.ScavengeInterval * 1000L;

#if NETLOGONDBG
    NlGlobalParameters.DbFlag = 0;
    NlGlobalLogFile = INVALID_HANDLE_VALUE;
    NlGlobalDebugSharePath = NULL;
#endif // NETLOGONDBG


    for( i = 0, DBInfo = &NlGlobalDBInfoArray[0];
            i < NUM_DBS;
                i++, DBInfo++ ) {

        RtlZeroMemory( DBInfo, sizeof(*DBInfo) );
    }
    NlGlobalPartialDisable = FALSE;
    NlGlobalDsPaused = TRUE;
    NlGlobalDsPausedEvent = NULL;
    NlGlobalDsPausedWaitHandle = NULL;
    NlGlobalDcDemotionInProgress = FALSE;

    NlGlobalDcScavengerIsRunning = FALSE;
    NlInitializeWorkItem( &NlGlobalDcScavengerWorkItem, NlDcScavenger, NULL );

    //
    // Setup things needed before NlExit can be called
    //

    NlGlobalTerminate = FALSE;
#if NETLOGONDBG
    NlGlobalUnloadNetlogon = FALSE;
#endif // NETLOGONDBG

    NlGlobalTerminateEvent = CreateEvent( NULL,     // No security attributes
                                          TRUE,     // Must be manually reset
                                          FALSE,    // Initially not signaled
                                          NULL );   // No name

    if ( NlGlobalTerminateEvent == NULL ) {
        NetStatus = GetLastError();
        NlPrint((NL_CRITICAL, "Cannot create termination Event %lu\n",
                          NetStatus ));
        return (int) NetStatus;
    }


    //
    // Initialize global crit sects
    //

    try {
        InitializeCriticalSection( &NlGlobalReplicatorCritSect );
        InitializeCriticalSection( &NlGlobalDcDiscoveryCritSect );
        InitializeCriticalSection( &NlGlobalScavengerCritSect );
        InitializeCriticalSection( &NlGlobalTransportCritSect );
        InitializeCriticalSection( &NlGlobalDnsCritSect );
        InitializeCriticalSection( &NlGlobalDnsForestNameCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NlPrint((NL_CRITICAL, "Cannot InitializeCriticalSection\n" ));
        return (int) ERROR_NOT_ENOUGH_MEMORY;
    }

    try {
        InitializeCriticalSection( &NlGlobalParametersCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NlPrint((NL_CRITICAL, "Cannot initialize NlGlobalParametersCritSect\n" ));
        return (int) ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // seed the pseudo random number generator
    //

    NlQuerySystemTime( &TimeNow );
    srand( TimeNow.LowPart );


    //
    // Tell the service controller we've started.
    //
    // ?? - Need to set up security descriptor.
    //

    NlPrint((NL_INIT,"Calling RegisterServiceCtrlHandler\n"));

    NlGlobalServiceHandle =
        RegisterServiceCtrlHandler( SERVICE_NETLOGON, NlControlHandler);

    if (NlGlobalServiceHandle == 0) {
        LPWSTR MsgStrings[1];

        NetStatus = GetLastError();

        NlPrint((NL_CRITICAL, "RegisterServiceCtrlHandler failed %lu\n",
                          NetStatus ));

        MsgStrings[0] = (LPWSTR) ULongToPtr( NetStatus );

        NlpWriteEventlog (NELOG_NetlogonFailedToRegisterSC,
                          EVENTLOG_ERROR_TYPE,
                          (LPBYTE) &NetStatus,
                          sizeof(NetStatus),
                          MsgStrings,
                          1 | NETP_LAST_MESSAGE_IS_NETSTATUS );

        return (int) NetStatus;
    }

    if ( !GiveInstallHints( FALSE ) ) {
        goto Cleanup;
    }

    //
    // Nlparse the command line (.ini) arguments
    // it will set globals reflecting switch settings
    //

    NlOpenDebugFile( FALSE );
    if (! NlparseAllSections( &NlGlobalParameters, FALSE ) ) {
        goto Cleanup;
    }

    NlPrint((NL_INIT,"Command line parsed successfully ...\n"));
    if ( NlGlobalNetlogonUnloaded ) {
        NlPrint((NL_INIT,"Netlogon.dll has been unloaded (recover from it).\n"));
    }




#if DBG
    //
    // Enter the debugger.
    //
    // Wait 'til now since we don't want the service controller to time us out.
    //


    IF_NL_DEBUG( BREAKPOINT ) {
         DbgBreakPoint( );
    }
#endif // DBG



    //
    // Do startup checks, initialize data structs and do prelim setups
    //

    if ( !NlInit() ) {
        goto Cleanup;
    }




    //
    // Loop till the service is to exit.
    //

    NlGlobalNetlogonUnloaded = FALSE;
    NlMainLoop();

    //
    // Common exit point
    //

Cleanup:

    //
    // Cleanup and return to our caller.
    //

    return (int) NlCleanup();
    UNREFERENCED_PARAMETER( argc );
    UNREFERENCED_PARAMETER( argv );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nlsecure.c ===
/*++

Copyright (c) 1991-1996  Microsoft Corporation

Module Name:

    nlsecure.c

Abstract:

    This module contains the Netlogon service support routines
    which create security objects and enforce security _access checking.

Author:

    Cliff Van Dyke (CliffV) 22-Aug-1991

Revision History:

--*/


#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop


//
// Include nlsecure.h again allocating the actual variables
// this time around.
//

#define NLSECURE_ALLOCATE
#include "nlsecure.h"
#undef NLSECURE_ALLOCATE


NTSTATUS
NlCreateNetlogonObjects(
    VOID
    )
/*++

Routine Description:

    This function creates the workstation user-mode objects which are
    represented by security descriptors.

Arguments:

    None.

Return Value:

    NT status code

--*/
{
    NTSTATUS Status;

    //
    // Order matters!  These ACEs are inserted into the DACL in the
    // following order.  Security access is granted or denied based on
    // the order of the ACEs in the DACL.
    //
    //
    // Members of Group SECURITY_LOCAL aren't allowed to do a UAS logon
    // to force it to be done remotely.
    //

    ACE_DATA AceData[] = {

        {ACCESS_DENIED_ACE_TYPE, 0, 0,
               NETLOGON_UAS_LOGON_ACCESS |
               NETLOGON_UAS_LOGOFF_ACCESS,
                                            &LocalSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL,                 &AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               NETLOGON_CONTROL_ACCESS,     &AliasAccountOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               NETLOGON_CONTROL_ACCESS,     &AliasSystemOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               NETLOGON_CONTROL_ACCESS |
               NETLOGON_SERVICE_ACCESS,     &LocalSystemSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               NETLOGON_SERVICE_ACCESS,     &LocalServiceSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               NETLOGON_FTINFO_ACCESS,      &AuthenticatedUserSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               NETLOGON_UAS_LOGON_ACCESS |
               NETLOGON_UAS_LOGOFF_ACCESS |
               NETLOGON_QUERY_ACCESS,       &WorldSid}
    };

    //
    // Actually create the security descriptor.
    //

    Status = NetpCreateSecurityObject(
               AceData,
               sizeof(AceData)/sizeof(AceData[0]),
               AliasAdminsSid,
               AliasAdminsSid,
               &NlGlobalNetlogonInfoMapping,
               &NlGlobalNetlogonSecurityDescriptor );

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nlsecure.h ===
/*++

Copyright (c) 1991-1996 Microsoft Corporation

Module Name:

    nlsecure.h

Abstract:

    Private header file to be included by Netlogon service modules that
    need to enforce security.

Author:

    Cliff Van Dyke (CliffV) 22-Aug-1991

Revision History:

--*/

//
// nlsecure.c will #include this file with NLSECURE_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef NLSECURE_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

//-------------------------------------------------------------------//
//                                                                   //
// Object specific access masks                                      //
//                                                                   //
//-------------------------------------------------------------------//

//
// ConfigurationInfo specific access masks
//
#define NETLOGON_UAS_LOGON_ACCESS     0x0001
#define NETLOGON_UAS_LOGOFF_ACCESS    0x0002
#define NETLOGON_CONTROL_ACCESS       0x0004
#define NETLOGON_QUERY_ACCESS         0x0008
#define NETLOGON_SERVICE_ACCESS       0x0010
#define NETLOGON_FTINFO_ACCESS        0x0020

#define NETLOGON_ALL_ACCESS           (STANDARD_RIGHTS_REQUIRED    | \
                                      NETLOGON_UAS_LOGON_ACCESS    | \
                                      NETLOGON_UAS_LOGOFF_ACCESS   | \
                                      NETLOGON_CONTROL_ACCESS      | \
                                      NETLOGON_SERVICE_ACCESS      | \
                                      NETLOGON_FTINFO_ACCESS       | \
                                      NETLOGON_QUERY_ACCESS )


//
// Object type names for audit alarm tracking
//
#define NETLOGON_SERVICE_OBJECT       TEXT("NetlogonService")

//
// Security descriptors of Netlogon Service objects to control user accesses.
//

EXTERN PSECURITY_DESCRIPTOR NlGlobalNetlogonSecurityDescriptor;

//
// Generic mapping for each Netlogon Service object object
//

EXTERN GENERIC_MAPPING NlGlobalNetlogonInfoMapping
#ifdef NLSECURE_ALLOCATE
    = {
    STANDARD_RIGHTS_READ,                  // Generic read
    STANDARD_RIGHTS_WRITE,                 // Generic write
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    NETLOGON_ALL_ACCESS                    // Generic all
    }
#endif // NLSECURE_ALLOCATE
    ;


NTSTATUS
NlCreateNetlogonObjects(
    VOID
    );

#undef EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nldns.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    nldns.h

Abstract:

    Header for routines to register DNS names.

Author:

    Cliff Van Dyke (CliffV) 28-May-1996

Revision History:

--*/


//
// Log file of all names registered in DNS
//

#define NL_DNS_LOG_FILE L"\\system32\\config\\netlogon.dns"
#define NL_DNS_BINARY_LOG_FILE L"\\system32\\config\\netlogon.dnb"

// NL_MAX_DNS_LENGTH for each DNS name plus some slop
#define NL_DNS_RECORD_STRING_SIZE (NL_MAX_DNS_LENGTH*3+30 + 1)
#define NL_DNS_A_RR_VALUE_1 " IN A "
#define NL_DNS_CNAME_RR_VALUE_1 " IN CNAME "
#define NL_DNS_SRV_RR_VALUE_1 " IN SRV "
#define NL_DNS_RR_EOL "\r\n"

//
// Registry key where private data is stored across boots
//
// (This key does NOT have a change notify registered.)
//
#define NL_PRIVATE_KEY "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Private"

//
// Procedure Forwards for dns.c
//

HKEY
NlOpenNetlogonKey(
    LPSTR KeyName
    );

NET_API_STATUS
NlGetConfiguredDnsDomainName(
    OUT LPWSTR *DnsDomainName
    );

NET_API_STATUS
NlDnsInitialize(
    VOID
    );

VOID
NlDnsScavenge(
    IN BOOL NormalScavenge,
    IN BOOL RefreshDomainRecords,
    IN BOOL ForceRefreshDomainRecords,
    IN BOOL ForceReregister
    );

VOID
NlDnsForceScavenge(
    IN BOOL RefreshDomainRecords,
    IN BOOL ForceReregister
    );

BOOLEAN
NlDnsHasDnsServers(
    VOID
    );

NTSTATUS
NlDnsNtdsDsaDeletion (
    IN LPWSTR DnsDomainName,
    IN GUID *DomainGuid,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    );

BOOL
NlDnsCheckLastStatus(
    VOID
    );

//
// Flags affecting DNS scavenging activity
//

//
// Refresh domain records in the global list before doing DNS updates
//  if site coverage changes
//
#define NL_DNS_REFRESH_DOMAIN_RECORDS 0x00000001

//
// Refresh domain records in the global list before doing DNS updates
//  even if site coverage doesn't change
//
#define NL_DNS_FORCE_REFRESH_DOMAIN_RECORDS 0x00000002

//
// Force re-registration of all previously registered records
//
#define NL_DNS_FORCE_RECORD_REREGISTER 0x00000004

//
// Register <1B> domain browser names
//
#define NL_DNS_FIX_BROWSER_NAMES 0x00000008

//
// When this flag is set, we avoid forced DNS scavenge
//  for 5 minutes. This happens when the machine becomes
//  stressed with too many induced scavenging requests,
//  so it's better to back off for 5 minutes.
//
#define NL_DNS_AVOID_FORCED_SCAVENGE  0x80000000

NET_API_STATUS
NlDnsAddDomainRecords(
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG Flags
    );

NET_API_STATUS
NlDnsAddDomainRecordsWithSiteRefresh(
    IN PDOMAIN_INFO DomainInfo,
    IN PULONG Flags
    );

VOID
NlDnsShutdown(
    VOID
    );

NET_API_STATUS
NlSetDnsForestName(
    PUNICODE_STRING DnsForestName OPTIONAL,
    PBOOLEAN DnsForestNameChanged OPTIONAL
    );

VOID
NlCaptureDnsForestName(
    OUT WCHAR DnsForestName[NL_MAX_DNS_LENGTH+1]
    );

BOOL
NlDnsSetAvoidRegisterNameParam(
    IN LPTSTR_ARRAY NewDnsAvoidRegisterRecords
    );

BOOL
NetpEqualTStrArrays(
    LPTSTR_ARRAY TStrArray1 OPTIONAL,
    LPTSTR_ARRAY TStrArray2 OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nlp.c ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    nlp.c

Abstract:

    Private Netlogon service utility routines.

Author:

    Cliff Van Dyke (cliffv) 7-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    08-May-1992 JohnRo
        Use net config helpers for NetLogon.
        Use <prefix.h> equates.
--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#include <rpcasync.h>
#pragma hdrstop

// Include this again to declare the globals
#define DEBUG_ALLOCATE
#include <nldebug.h>    // Netlogon debugging
#undef DEBUG_ALLOCATE

//
// Include files specific to this .c file
//

#include <winerror.h>   // NO_ERROR
#include <prefix.h>     // PREFIX_ equates.
#include <stdarg.h>     // va_list, etc.
#include <stdio.h>      // vsprintf().
#include <tstr.h>       // TCHAR_ equates.




LPWSTR
NlStringToLpwstr(
    IN PUNICODE_STRING String
    )

/*++

Routine Description:

    Convert a Unicode String to an LPWSTR.

Arguments:

    String - Unicode String to copy

Return Value:

    LPWSTR in a NetpMemoryAllocate'd buffer.
    NULL is returned if there is no memory.

--*/

{
    LPWSTR Buffer;

    Buffer = NetpMemoryAllocate( String->Length + sizeof(WCHAR) );

    if ( Buffer != NULL ) {
        RtlCopyMemory( Buffer, String->Buffer, String->Length );
        Buffer[ String->Length / sizeof(WCHAR) ] = L'\0';
    }

    return Buffer;
}


BOOLEAN
NlAllocStringFromWStr(
    IN LPWSTR InString,
    OUT PUNICODE_STRING OutString
    )

/*++

Routine Description:

    Convert a zero terminated string into an allocated UNICODE_STRING structure.

Arguments:

    InString - String to copy

    OutString - String to copy into.
        OutString->Buffer should be freed using MIDL_user_free

Return Value:

    TRUE - success
    FALSE - couldn't allocate memory

--*/

{
    if ( InString == NULL ) {
        OutString->Length = 0;
        OutString->MaximumLength = 0;
        OutString->Buffer = NULL;
    } else {
        OutString->Length = wcslen(InString) * sizeof(WCHAR);
        OutString->MaximumLength = OutString->Length + sizeof(WCHAR);
        OutString->Buffer = MIDL_user_allocate( OutString->MaximumLength );

        if ( OutString->Buffer == NULL ) {
            return FALSE;
        }

        RtlCopyMemory( OutString->Buffer,
                       InString,
                       OutString->MaximumLength );
    }

    return TRUE;
}


BOOLEAN
NlDuplicateUnicodeString(
    IN PUNICODE_STRING InString OPTIONAL,
    OUT PUNICODE_STRING OutString
    )

/*++

Routine Description:

    Convert a UNICODE_STRING string into an allocated UNICODE_STRING structure.

Arguments:

    InString - String to copy

    OutString - String to copy into.
        OutString should be freed using NlFreeUnicodeString

Return Value:

    TRUE - success
    FALSE - couldn't allocate memory

--*/

{
    if ( InString == NULL || InString->Length == 0 ) {
        OutString->Length = 0;
        OutString->MaximumLength = 0;
        OutString->Buffer = NULL;
    } else {
        OutString->Length = InString->Length;
        OutString->MaximumLength = OutString->Length + sizeof(WCHAR);
        OutString->Buffer = MIDL_user_allocate( OutString->MaximumLength );

        if ( OutString->Buffer == NULL ) {
            return FALSE;
        }

        RtlCopyMemory( OutString->Buffer,
                       InString->Buffer,
                       OutString->Length );
        OutString->Buffer[OutString->Length/sizeof(WCHAR)] = L'\0';
    }

    return TRUE;
}


VOID
NlFreeUnicodeString(
    IN PUNICODE_STRING InString OPTIONAL
    )

/*++

Routine Description:

    Free the UNICODE_STRING structure allocated by NlDuplicateUnicodeString.

Arguments:

    InString - String to free

Return Value:

    None.

--*/

{
    if ( InString != NULL ) {

        if ( InString->Buffer != NULL ) {
            MIDL_user_free( InString->Buffer );
        }

        InString->Length = 0;
        InString->MaximumLength = 0;
        InString->Buffer = NULL;
    }
}


LPSTR
NlStringToLpstr(
    IN PUNICODE_STRING String
    )

/*++

Routine Description:

    Convert a Unicode String to an LPSTR.

Arguments:

    String - Unicode String to copy

Return Value:

    LPWSTR in a NetpMemoryAllocate'd buffer.
    NULL is returned if there is no memory.

--*/

{
    NTSTATUS Status;
    STRING OemString;

    OemString.MaximumLength = (USHORT) RtlUnicodeStringToOemSize( String );

    OemString.Buffer = NetpMemoryAllocate( OemString.MaximumLength );

    if ( OemString.Buffer != NULL ) {
        Status = RtlUnicodeStringToOemString( &OemString,
                                               String,
                                               (BOOLEAN) FALSE );
        if ( !NT_SUCCESS( Status ) ) {
            NetpMemoryFree( OemString.Buffer );
            return NULL;
        }
    }

    return OemString.Buffer;
}


VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    the Where parameter, and fixes the OutString string to point to that
    new copy.

Parameters:

    OutString - A pointer to a destination NT string

    InString - A pointer to an NT string to be copied

    Where - A pointer to space to put the actual string for the
        OutString.  The pointer is adjusted to point to the first byte
        following the copied string.

Return Values:

    None.

--*/

{
    NlAssert( OutString != NULL );
    NlAssert( InString != NULL );
    NlAssert( Where != NULL && *Where != NULL);
    NlAssert( *Where == ROUND_UP_POINTER( *Where, sizeof(WCHAR) ) );
#ifdef notdef
    KdPrint(("NlpPutString: %ld %Z\n", InString->Length, InString ));
    KdPrint(("  InString: %lx %lx OutString: %lx Where: %lx\n", InString,
        InString->Buffer, OutString, *Where ));
#endif

    if ( InString->Length > 0 ) {

        OutString->Buffer = (PWCH) *Where;
        OutString->MaximumLength = (USHORT)(InString->Length + sizeof(WCHAR));

        RtlCopyUnicodeString( OutString, InString );

        *Where += InString->Length;
//        *((WCHAR *)(*Where)) = L'\0';
        *(*Where) = '\0';
        *(*Where + 1) = '\0';
        *Where += 2;

    } else {
        RtlInitUnicodeString(OutString, NULL);
    }
#ifdef notdef
    KdPrint(("  OutString: %ld %lx\n",  OutString->Length, OutString->Buffer));
#endif

    return;
}


VOID
NlpWriteEventlogEx (
    IN DWORD EventId,
    IN DWORD EventType,
    IN LPBYTE RawDataBuffer OPTIONAL,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN DWORD StringCount,
    IN DWORD StatusMessageIndex
    )
/*++

Routine Description:

    Stub routine for calling Event Log.

Arguments:

    EventId - event log ID.

    EventType - Type of event.

    RawDataBuffer - Data to be logged with the error.

    numbyte - Size in bytes of "RawDataBuffer"

    StringArray - array of null-terminated strings.

    StringCount - number of zero terminated strings in "StringArray".  The following
        flags can be OR'd in to the count:

        LAST_MESSAGE_IS_NTSTATUS
        LAST_MESSAGE_IS_NETSTATUS
        ALLOW_DUPLICATE_EVENTS
        RAISE_ALERT_TOO

    StatusMessageIndex - Specifies the index of the message that is
        a Net or NT status in the StringArray. Used only if
        NETP_LAST_MESSAGE_IS_NETSTATUS or NETP_LAST_MESSAGE_IS_NTSTATUS
        are set in StringCount. If this parameter is MAXULONG and either
        of these flags is set, the default is assumed which is the last
        message in the list.

Return Value:

    TRUE: The message was written.

--*/
{
    DWORD ErrorCode;
    DWORD ActualStringCount = StringCount & NETP_STRING_COUNT_MASK;
    DWORD LocalStatusMessageIndex = StatusMessageIndex;
    BOOLEAN StatusPresent = FALSE;

    //
    // Check if the status message index in the list
    //  should be assigned the default value
    //

    if ( (StringCount & NETP_LAST_MESSAGE_IS_NETSTATUS) != 0 ||
         (StringCount & NETP_LAST_MESSAGE_IS_NTSTATUS)  != 0 ) {

        StatusPresent = TRUE;
        if ( LocalStatusMessageIndex == MAXULONG ) {
            LocalStatusMessageIndex = ActualStringCount - 1;
        }
    }

    //
    // If an NT status code was passed in,
    //  convert it to a net status code.
    //

    if ( StringCount & NETP_LAST_MESSAGE_IS_NTSTATUS ) {
        //
        // Do the "better" error mapping when eventviewer ParameterMessageFile
        // can be a list of files.  Then, add netmsg.dll to the list.
        //
        // StringArray[ActualStringCount-1] = (LPWSTR) NetpNtStatusToApiStatus( (NTSTATUS) StringArray[ActualStringCount-1] );
        if ( (NTSTATUS)(ULONG_PTR)StringArray[LocalStatusMessageIndex] == STATUS_SYNCHRONIZATION_REQUIRED ) {
            StringArray[LocalStatusMessageIndex] = (LPWSTR) NERR_SyncRequired;
            StringCount &= ~NETP_LAST_MESSAGE_IS_NTSTATUS;
            StringCount |= NETP_LAST_MESSAGE_IS_NETSTATUS;
        }

    }


    //
    // Dump the event to the debug file.
    //

#if NETLOGONDBG
    IF_NL_DEBUG( MISC ) {
        DWORD i;

        NlPrint((NL_MISC, "Eventlog: %ld (%ld) ",
                    EventId,
                    EventType ));

        for (i = 0; i < ActualStringCount ; i++ ) {
            if ( StatusPresent && i == LocalStatusMessageIndex ) {
                if ( StringCount & NETP_LAST_MESSAGE_IS_NTSTATUS ) {
                    NlPrint((NL_MISC, "0x%lx ", StringArray[i] ));
                } else if ( StringCount & NETP_LAST_MESSAGE_IS_NETSTATUS ) {
                    NlPrint((NL_MISC, "%ld ", StringArray[i] ));
                } else {
                    NlPrint((NL_MISC, "\"%ws\" ", StringArray[i] ));
                }
            } else {
                NlPrint((NL_MISC, "\"%ws\" ", StringArray[i] ));
            }
        }

        if( RawDataSize ) {
            if ( RawDataSize > 16 ) {
                NlPrint((NL_MISC, "\n" ));
            }

            NlpDumpBuffer( NL_MISC, RawDataBuffer, RawDataSize );

        } else {
            NlPrint((NL_MISC, "\n" ));
        }

    }
#endif // NETLOGONDBG

    //
    // Write the event and avoid duplicates
    //

    ErrorCode = NetpEventlogWriteEx2 (
                            NlGlobalEventlogHandle,
                            EventType,
                            0, // event category
                            EventId,
                            StringCount,
                            StatusMessageIndex,
                            RawDataSize,
                            StringArray,
                            RawDataBuffer );

    if( ErrorCode != NO_ERROR ) {
        if ( ErrorCode == ERROR_ALREADY_EXISTS ) {
            NlPrint((NL_MISC,
                     "Didn't log event since it was already logged.\n" ));
        } else {
            NlPrint((NL_CRITICAL,
                    "Error writing this event in the eventlog, Status = %ld\n",
                    ErrorCode ));
        }
        goto Cleanup;
    }

Cleanup:
    return;
}


VOID
NlpWriteEventlog (
    IN DWORD EventId,
    IN DWORD EventType,
    IN LPBYTE RawDataBuffer OPTIONAL,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN DWORD StringCount
    )
/*++

Routine Description:

    Stub routine for calling Event Log.

Arguments:

    Same as NlpWriteEventlogEx except that the status message
    index is defaulted to the last message index in the
    passed list.

Return Value:

    None

--*/
{
    NlpWriteEventlogEx ( EventId,
                         EventType,
                         RawDataBuffer,
                         RawDataSize,
                         StringArray,
                         StringCount,
                         MAXULONG );  // default status message index
}

#if NETLOGONDBG

VOID
NlpDumpBuffer(
    IN DWORD DebugFlag,
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    DebugFlag: Debug flag to pass on to NlPrintRoutine

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;
    BOOLEAN DumpDwords = FALSE;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( (NlGlobalParameters.DbFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // Don't want to intermingle output from different threads.
    //

    EnterCriticalSection( &NlGlobalLogFileCritSect );

    if ( BufferSize > NUM_CHARS ) {
        NlPrint((0,"\n"));  // Ensure this starts on a new line
        NlPrint((0,"------------------------------------\n"));
    } else {
        if ( BufferSize % sizeof(DWORD) == 0 ) {
            DumpDwords = TRUE;
        }
    }

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            if ( DumpDwords ) {
                if ( i % sizeof(DWORD) == 0 ) {
                    DWORD ADword;
                    RtlCopyMemory( &ADword, &BufferPtr[i], sizeof(DWORD) );
                    NlPrint((0,"%08x ", ADword));
                }
            } else {
                NlPrint((0,"%02x ", BufferPtr[i]));
            }

            if ( isprint(BufferPtr[i]) ) {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            } else {
                TextBuffer[i % NUM_CHARS] = '.';
            }

        } else {

            if ( DumpDwords ) {
                TextBuffer[i % NUM_CHARS] = '\0';
            } else {
                if ( BufferSize > NUM_CHARS ) {
                    NlPrint((0,"   "));
                    TextBuffer[i % NUM_CHARS] = ' ';
                } else {
                    TextBuffer[i % NUM_CHARS] = '\0';
                }
            }

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            NlPrint((0,"  %s\n", TextBuffer));
        }

    }

    if ( BufferSize > NUM_CHARS ) {
        NlPrint((0,"------------------------------------\n"));
    } else if ( BufferSize < NUM_CHARS ) {
        NlPrint((0,"\n"));
    }
    LeaveCriticalSection( &NlGlobalLogFileCritSect );
}


VOID
NlpDumpGuid(
    IN DWORD DebugFlag,
    IN GUID *Guid OPTIONAL
    )
/*++

Routine Description:

    Dumps a GUID to the debugger output.

Arguments:

    DebugFlag: Debug flag to pass on to NlPrintRoutine

    Guid: Guid to print

Return Value:

    none

--*/
{
    RPC_STATUS RpcStatus;
    char *StringGuid;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( (NlGlobalParameters.DbFlag & DebugFlag) == 0 ) {
        return;
    }


    if ( Guid == NULL ) {
        NlPrint(( DebugFlag, "(null)" ));
    } else {
        RpcStatus = UuidToStringA( Guid, &StringGuid );

        if ( RpcStatus != RPC_S_OK ) {
            return;
        }

        NlPrint(( DebugFlag, "%s", StringGuid ));

        RpcStringFreeA( &StringGuid );
    }

}

VOID
NlpDumpPeriod(
    IN DWORD DebugFlag,
    IN LPSTR Comment,
    IN ULONG Period
    )
/*++

Routine Description:

    Print an elapsed time (in milliseconds)

Arguments:

    DebugFlag - Debug flag to pass on to NlPrintRoutine

    Comment - Comment to print in front of the time

    Period - Time period (in milliseconds)

Return Value:

    None

--*/
{


    //
    // Convert the period to something easily readable
    //

    if ( Period == MAILSLOT_WAIT_FOREVER ) {
        NlPrint(( DebugFlag,
                  "%s 'never' (0x%lx)\n",
                  Comment,
                  Period  ));
    } else if ( (Period / NL_MILLISECONDS_PER_DAY) != 0 ) {
        NlPrint(( DebugFlag,
                  "%s %ld days (0x%lx)\n",
                  Comment,
                  Period / NL_MILLISECONDS_PER_DAY,
                  Period  ));
    } else if ( (Period / NL_MILLISECONDS_PER_HOUR) != 0 ) {
        NlPrint(( DebugFlag,
                  "%s %ld hours (0x%lx)\n",
                  Comment,
                  Period / NL_MILLISECONDS_PER_HOUR,
                  Period  ));
    } else if ( (Period / NL_MILLISECONDS_PER_MINUTE) != 0 ) {
        NlPrint(( DebugFlag,
                  "%s %ld minutes (0x%lx)\n",
                  Comment,
                  Period / NL_MILLISECONDS_PER_MINUTE,
                  Period  ));
    } else {
        NlPrint(( DebugFlag,
                  "%s %ld seconds (0x%lx)\n",
                  Comment,
                  Period / NL_MILLISECONDS_PER_SECOND,
                  Period  ));
    }

}


VOID
NlpDumpTime(
    IN DWORD DebugFlag,
    IN LPSTR Comment,
    IN LARGE_INTEGER ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    DebugFlag - Debug flag to pass on to NlPrintRoutine

    Comment - Comment to print in front of the time

    Time - GMT time to print (Nothing is printed if this is zero)

Return Value:

    None

--*/
{


    //
    // If we aren't debugging this functionality, just return.
    //
    if ( (NlGlobalParameters.DbFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // Convert an NT GMT time to ascii,
    //  Do so
    //

    if ( ConvertTime.QuadPart != 0 ) {
        LARGE_INTEGER LocalTime;
        TIME_FIELDS TimeFields;
        NTSTATUS Status;

        Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
        if ( !NT_SUCCESS( Status )) {
            NlPrint(( NL_CRITICAL, "Can't convert time from GMT to Local time\n" ));
            LocalTime = ConvertTime;
        }

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        NlPrint(( DebugFlag, "%s%8.8lx %8.8lx = %ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                Comment,
                ConvertTime.LowPart,
                ConvertTime.HighPart,
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second ));
    }
}


VOID
NlpDumpSid(
    IN DWORD DebugFlag,
    IN PSID Sid OPTIONAL
    )
/*++

Routine Description:

    Dumps a SID to the debugger output

Arguments:

    DebugFlag - Debug flag to pass on to NlPrintRoutine

    Sid - SID to output

Return Value:

    none

--*/
{


    //
    // If we aren't debugging this functionality, just return.
    //
    if ( (NlGlobalParameters.DbFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // Output the SID
    //

    if ( Sid == NULL ) {
        NlPrint((0, "(null)\n"));
    } else {
        UNICODE_STRING SidString;
        NTSTATUS Status;

        Status = RtlConvertSidToUnicodeString( &SidString, Sid, TRUE );

        if ( !NT_SUCCESS(Status) ) {
            NlPrint((0, "Invalid 0x%lX\n", Status ));
        } else {
            NlPrint((0, "%wZ\n", &SidString ));
            RtlFreeUnicodeString( &SidString );
        }
    }

}
#endif // NETLOGONDBG


DWORD
NlpAtoX(
    IN LPWSTR String
    )
/*++

Routine Description:

    Converts hexadecimal string to DWORD integer.

    Accepts the following form of hex string

        0[x-X][0-9, a-f, A-F]*

Arguments:

    String: hexadecimal string.

Return Value:

    Decimal value of the hex string.

--*/

{
    DWORD Value = 0;

    if( String == NULL )
        return 0;

    if( *String != TEXT('0') )
        return 0;

    String++;

    if( *String == TCHAR_EOS )
        return 0;

    if( ( *String != TEXT('x') )  && ( *String != TEXT('X') ) )
        return 0;

    String++;

    while(*String != TCHAR_EOS ) {

        if( (*String >= TEXT('0')) && (*String <= TEXT('9')) ) {
            Value = Value * 16 + ( *String - '0');
        } else if( (*String >= TEXT('a')) && (*String <= TEXT('f')) ) {
            Value = Value * 16 + ( 10 + *String - TEXT('a'));
        } else if( (*String >= TEXT('A')) && (*String <= TEXT('F')) ) {
            Value = Value * 16 + ( 10 + *String - TEXT('A'));
        } else {
            break;
        }
        String++;
    }

    return Value;
}


VOID
NlWaitForSingleObject(
    IN LPSTR WaitReason,
    IN HANDLE WaitHandle
    )
/*++

Routine Description:

    Waits an infinite amount of time for the specified handle.

Arguments:

    WaitReason - Text describing what we're waiting on

    WaitHandle - Handle to wait on

Return Value:

    None

--*/

{
    DWORD WaitStatus;

    //
    // Loop waiting.
    //

    for (;;) {
        WaitStatus = WaitForSingleObject( WaitHandle,
                                          2*60*1000 );  // Two minutes

        if ( WaitStatus == WAIT_TIMEOUT ) {
            NlPrint((NL_CRITICAL,
                   "WaitForSingleObject 2-minute timeout (Rewaiting): %s\n",
                    WaitReason ));
            continue;

        } else if ( WaitStatus == WAIT_OBJECT_0 ) {
            break;

        } else {
            NlPrint((NL_CRITICAL,
                    "WaitForSingleObject error: %ld %ld %s\n",
                    WaitStatus,
                    GetLastError(),
                    WaitReason ));
            UNREFERENCED_PARAMETER(WaitReason);
            break;
        }
    }

}


BOOLEAN
NlWaitForSamService(
    BOOLEAN NetlogonServiceCalling
    )
/*++

Routine Description:

    This procedure waits for the SAM service to start and to complete
    all its initialization.

Arguments:

    NetlogonServiceCalling:
         TRUE if this is the netlogon service proper calling
         FALSE if this is the changelog worker thread calling

Return Value:

    TRUE : if the SAM service is successfully starts.

    FALSE : if the SAM service can't start.

--*/
{
    NTSTATUS Status;
    DWORD WaitStatus;
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;

    //
    // open SAM event
    //

    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtOpenEvent( &EventHandle,
                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                            &EventAttributes );

    if ( !NT_SUCCESS(Status)) {

        if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            //
            // SAM hasn't created this event yet, let us create it now.
            // SAM opens this event to set it.
            //

            Status = NtCreateEvent(
                           &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes,
                           NotificationEvent,
                           FALSE // The event is initially not signaled
                           );

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION ) {

                //
                // second change, if the SAM created the event before we
                // do.
                //

                Status = NtOpenEvent( &EventHandle,
                                        SYNCHRONIZE|EVENT_MODIFY_STATE,
                                        &EventAttributes );

            }
        }

        if ( !NT_SUCCESS(Status)) {

            //
            // could not make the event handle
            //

            NlPrint((NL_CRITICAL,
                "NlWaitForSamService couldn't make the event handle : "
                "%lx\n", Status));

            return( FALSE );
        }
    }

    //
    // Loop waiting.
    //

    for (;;) {
        WaitStatus = WaitForSingleObject( EventHandle,
                                          5*1000 );  // 5 Seconds

        if ( WaitStatus == WAIT_TIMEOUT ) {
            if ( NetlogonServiceCalling ) {
                NlPrint((NL_CRITICAL,
                   "NlWaitForSamService 5-second timeout (Rewaiting)\n" ));
                if (!GiveInstallHints( FALSE )) {
                    (VOID) NtClose( EventHandle );
                    return FALSE;
                }
            }
            continue;

        } else if ( WaitStatus == WAIT_OBJECT_0 ) {
            break;

        } else {
            NlPrint((NL_CRITICAL,
                     "NlWaitForSamService: error %ld %ld\n",
                     GetLastError(),
                     WaitStatus ));
            (VOID) NtClose( EventHandle );
            return FALSE;
        }
    }

    (VOID) NtClose( EventHandle );
    return TRUE;

}

NET_API_STATUS
NlReadBinaryLog(
    IN LPWSTR FileSuffix,
    IN BOOL DeleteName,
    OUT LPBYTE *Buffer,
    OUT PULONG BufferSize
    )
/*++

Routine Description:

    Read a file into a buffer.

Arguments:

    FileSuffix - Specifies the name of the file to write (relative to the
        Windows directory)

    DeleteName - If true the file will be deleted

    Buffer - Returns an allocated buffer containing the file.
        Buffer should be freed using LocalFree.
        If the file doesn't exist, NULL will be returned (and NO_ERROR)

    BufferSize - Returns size (in bytes) of buffer

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;

    LPWSTR FileName = NULL;

    UINT WindowsDirectoryLength;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOLEAN FileNameKnown = FALSE;
    ULONG BytesRead;


    //
    // Initialization
    //
    *Buffer = NULL;
    *BufferSize = 0;

    //
    // Allocate a block to build the file name in
    //  (Don't put it on the stack since we don't want to commit a huge stack.)
    //

    FileName = LocalAlloc( LMEM_ZEROINIT, sizeof(WCHAR) * (MAX_PATH+1) );

    if ( FileName == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Build the name of the log file
    //

    WindowsDirectoryLength = GetSystemWindowsDirectoryW(
                                FileName,
                                sizeof(WCHAR) * (MAX_PATH+1) );

    if ( WindowsDirectoryLength == 0 ) {

        NetStatus = GetLastError();
        NlPrint(( NL_CRITICAL,
                  "NlWriteBinaryLog: Unable to GetSystemWindowsDirectoryW (%ld)\n",
                  NetStatus ));
        goto Cleanup;
    }

    if ( WindowsDirectoryLength + wcslen( FileSuffix ) + 1 >= MAX_PATH ) {

        NlPrint((NL_CRITICAL,
                 "NlWriteBinaryLog: file name length is too long \n" ));
        NetStatus = ERROR_INVALID_NAME;
        goto Cleanup;

    }

    wcscat( FileName, FileSuffix );
    FileNameKnown = TRUE;


    //
    // Open binary log file if exists
    //

    FileHandle = CreateFileW(
                        FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,                   // Supply better security ??
                        OPEN_EXISTING,          // Only open it if it exists
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );                 // No template

    if ( FileHandle == INVALID_HANDLE_VALUE) {

        NlPrint(( NL_CRITICAL,
                  FORMAT_LPWSTR ": Unable to open. %ld\n",
                  FileName,
                  GetLastError() ));

        // This isn't fatal
        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    //
    // Get the size of the file.
    //

    *BufferSize = GetFileSize( FileHandle, NULL );

    if ( *BufferSize == 0xFFFFFFFF ) {

        NetStatus = GetLastError();
        NlPrint((NL_CRITICAL,
                 "%ws: Unable to GetFileSize: %ld \n",
                 FileName,
                 NetStatus ));
        *BufferSize = 0;
        goto Cleanup;
    }

    if ( *BufferSize < 1 ) {
        NlPrint(( NL_CRITICAL,
                  "NlReadBinaryLog: %ws: size too small: %ld.\n",
                  FileName,
                  *BufferSize ));
        *BufferSize = 0;
        NetStatus = NO_ERROR;
        goto Cleanup;
    }


    //
    // Allocate a buffer to read the file into.
    //

    *Buffer = LocalAlloc( 0, *BufferSize );

    if ( *Buffer == NULL ) {
        *BufferSize = 0;
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Read the file into the buffer.
    //

    if ( !ReadFile( FileHandle,
                    *Buffer,
                    *BufferSize,
                    &BytesRead,
                    NULL ) ) {  // Not Overlapped

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_FILE_NOT_FOUND ) {
            NlPrint(( NL_CRITICAL,
                      "NlReadBinaryLog: %ws: Cannot ReadFile: %ld.\n",
                      FileName,
                      NetStatus ));
        }

        LocalFree( *Buffer );
        *Buffer = NULL;
        *BufferSize = 0;

        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    if ( BytesRead != *BufferSize ) {

        NlPrint(( NL_CRITICAL,
                  "NlReadBinaryLog: %ws: Cannot read entire File: %ld %ld.\n",
                  FileName,
                  BytesRead,
                  *BufferSize ));

        LocalFree( *Buffer );
        *Buffer = NULL;
        *BufferSize = 0;

        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    NetStatus = NO_ERROR;


    //
    // Be tidy.
    //
Cleanup:
    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
    }

    //
    // If the caller asked us to delete the file,
    //  do so now
    //

    if (DeleteName && FileNameKnown) {
        if ( !DeleteFile( FileName ) ) {
            DWORD WinError;
            WinError = GetLastError();
            if ( WinError != ERROR_FILE_NOT_FOUND ) {
                NlPrint((NL_CRITICAL,
                    "Cannot delete %ws (%ld)\n",
                    FileName,
                    WinError ));
            }
            // This isn't fatal
        }
    }

    if ( FileName != NULL ) {
        LocalFree( FileName );
    }
    return NetStatus;

}




#if NETLOGONDBG


VOID
NlOpenDebugFile(
    IN BOOL ReopenFlag
    )
/*++

Routine Description:

    Opens or re-opens the debug file

Arguments:

    ReopenFlag - TRUE to indicate the debug file is to be closed, renamed,
        and recreated.

Return Value:

    None

--*/

{
    LPWSTR AllocatedBuffer = NULL;
    LPWSTR LogFileName;
    LPWSTR BakFileName;
    DWORD FileAttributes;
    DWORD PathLength;
    DWORD WinError;

    //
    // Allocate a buffer for storage local to this procedure.
    //  (Don't put it on the stack since we don't want to commit a huge stack.)
    //

    AllocatedBuffer = LocalAlloc( 0, sizeof(WCHAR) *
                                     (MAX_PATH+1 +
                                      MAX_PATH+1 ) );

    if ( AllocatedBuffer == NULL ) {
        goto ErrorReturn;
    }

    LogFileName = AllocatedBuffer;
    BakFileName = &LogFileName[MAX_PATH+1];

    //
    // Close the handle to the debug file, if it is currently open
    //

    EnterCriticalSection( &NlGlobalLogFileCritSect );
    if ( NlGlobalLogFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( NlGlobalLogFile );
        NlGlobalLogFile = INVALID_HANDLE_VALUE;
    }
    LeaveCriticalSection( &NlGlobalLogFileCritSect );

    //
    // make debug directory path first, if it is not made before.
    //
    if( NlGlobalDebugSharePath == NULL ) {

        if ( !GetSystemWindowsDirectoryW( LogFileName, MAX_PATH+1 ) ) {
            NlPrint((NL_CRITICAL, "Window Directory Path can't be retrieved, %lu.\n",
                     GetLastError() ));
            goto ErrorReturn;
        }

        //
        // check debug path length.
        //

        PathLength = wcslen(LogFileName) * sizeof(WCHAR) +
                        sizeof(DEBUG_DIR) + sizeof(WCHAR);

        if( (PathLength + sizeof(DEBUG_FILE) > MAX_PATH+1 )  ||
            (PathLength + sizeof(DEBUG_BAK_FILE) > MAX_PATH+1 ) ) {

            NlPrint((NL_CRITICAL, "Debug directory path (%ws) length is too long.\n",
                        LogFileName));
            goto ErrorReturn;
        }

        wcscat(LogFileName, DEBUG_DIR);

        //
        // copy debug directory name to global var.
        //

        NlGlobalDebugSharePath =
            NetpMemoryAllocate( (wcslen(LogFileName) + 1) * sizeof(WCHAR) );

        if( NlGlobalDebugSharePath == NULL ) {
            NlPrint((NL_CRITICAL, "Can't allocated memory for debug share "
                                    "(%ws).\n", LogFileName));
            goto ErrorReturn;
        }

        wcscpy(NlGlobalDebugSharePath, LogFileName);
    }
    else {
        wcscpy(LogFileName, NlGlobalDebugSharePath);
    }

    //
    // Check this path exists.
    //

    FileAttributes = GetFileAttributesW( LogFileName );

    if( FileAttributes == 0xFFFFFFFF ) {

        WinError = GetLastError();
        if( WinError == ERROR_FILE_NOT_FOUND ) {

            //
            // Create debug directory.
            //

            if( !CreateDirectoryW( LogFileName, NULL) ) {
                NlPrint((NL_CRITICAL, "Can't create Debug directory (%ws), %lu.\n",
                         LogFileName, GetLastError() ));
                goto ErrorReturn;
            }

        }
        else {
            NlPrint((NL_CRITICAL, "Can't Get File attributes(%ws), %lu.\n",
                     LogFileName, WinError ));
            goto ErrorReturn;
        }
    }
    else {

        //
        // if this is not a directory.
        //

        if(!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            NlPrint((NL_CRITICAL, "Debug directory path (%ws) exists as file.\n",
                     LogFileName));
            goto ErrorReturn;
        }
    }

    //
    // Create the name of the old and new log file names
    //

    (VOID) wcscpy( BakFileName, LogFileName );
    (VOID) wcscat( LogFileName, L"\\Netlogon.log" );
    (VOID) wcscat( BakFileName, L"\\Netlogon.bak" );


    //
    // If this is a re-open,
    //  delete the backup file,
    //  rename the current file to the backup file.
    //

    if ( ReopenFlag ) {

        if ( !DeleteFile( BakFileName ) ) {
            WinError = GetLastError();
            if ( WinError != ERROR_FILE_NOT_FOUND ) {
                NlPrint((NL_CRITICAL,
                    "Cannot delete " FORMAT_LPWSTR "(%ld)\n",
                    BakFileName,
                    WinError ));
                NlPrint((NL_CRITICAL, "   Try to re-open the file.\n"));
                ReopenFlag = FALSE;     // Don't truncate the file
            }
        }
    }

    if ( ReopenFlag ) {
        if ( !MoveFile( LogFileName, BakFileName ) ) {
            NlPrint((NL_CRITICAL,
                    "Cannot rename " FORMAT_LPWSTR " to " FORMAT_LPWSTR
                        " (%ld)\n",
                    LogFileName,
                    BakFileName,
                    GetLastError() ));
            NlPrint((NL_CRITICAL,
                "   Try to re-open the file.\n"));
            ReopenFlag = FALSE;     // Don't truncate the file
        }
    }

    //
    // Open the file.
    //

    EnterCriticalSection( &NlGlobalLogFileCritSect );
    NlGlobalLogFile = CreateFileW( LogFileName,
                                  GENERIC_WRITE|GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  ReopenFlag ? CREATE_ALWAYS : OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );


    if ( NlGlobalLogFile == INVALID_HANDLE_VALUE ) {
        NlPrint((NL_CRITICAL,  "cannot open " FORMAT_LPWSTR ",\n",
                    LogFileName ));
        LeaveCriticalSection( &NlGlobalLogFileCritSect );
        goto ErrorReturn;
    } else {
        // Position the log file at the end
        (VOID) SetFilePointer( NlGlobalLogFile,
                               0,
                               NULL,
                               FILE_END );
    }

    LeaveCriticalSection( &NlGlobalLogFileCritSect );

Cleanup:
    if ( AllocatedBuffer != NULL ) {
        LocalFree( AllocatedBuffer );
    }

    return;

ErrorReturn:
    NlPrint((NL_CRITICAL,
            "   Debug output will be written to debug terminal.\n"));
    goto Cleanup;
}

#define MAX_PRINTF_LEN 1024        // Arbitrary.

VOID
NlPrintRoutineV(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    va_list arglist
    )
// Must be called with NlGlobalLogFileCritSect locked

{
    static LPSTR NlGlobalLogFileOutputBuffer = NULL;
    ULONG length;
    int   lengthTmp;
    DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    static LogProblemWarned = FALSE;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (NlGlobalParameters.DbFlag & DebugFlag) == 0 ) {
        return;
    }


    //
    // Allocate a buffer to build the line in.
    //  If there isn't already one.
    //

    length = 0;

    if ( NlGlobalLogFileOutputBuffer == NULL ) {
        NlGlobalLogFileOutputBuffer = LocalAlloc( 0, MAX_PRINTF_LEN + 1 );

        if ( NlGlobalLogFileOutputBuffer == NULL ) {
            return;
        }
    }

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // Never print empty lines.
        //

        if ( Format[0] == '\n' && Format[1] == '\0' ) {
            return;
        }

        //
        // If the log file is getting huge,
        //  truncate it.
        //

        if ( NlGlobalLogFile != INVALID_HANDLE_VALUE &&
             !TruncateLogFileInProgress ) {

            //
            // Only check every 50 lines,
            //

            LineCount++;
            if ( LineCount >= 50 ) {
                DWORD FileSize;
                LineCount = 0;

                //
                // Is the log file too big?
                //

                FileSize = GetFileSize( NlGlobalLogFile, NULL );
                if ( FileSize == 0xFFFFFFFF ) {
                    (void) DbgPrint( "[NETLOGON] Cannot GetFileSize %ld\n",
                                     GetLastError );
                } else if ( FileSize > NlGlobalParameters.LogFileMaxSize ) {
                    TruncateLogFileInProgress = TRUE;
                    LeaveCriticalSection( &NlGlobalLogFileCritSect );
                    NlOpenDebugFile( TRUE );
                    NlPrint(( NL_MISC,
                              "Logfile truncated because it was larger than %ld bytes\n",
                              NlGlobalParameters.LogFileMaxSize ));
                    EnterCriticalSection( &NlGlobalLogFileCritSect );
                    TruncateLogFileInProgress = FALSE;
                }

            }
        }

        //
        // If we're writing to the debug terminal,
        //  indicate this is a Netlogon message.
        //

        if ( NlGlobalLogFile == INVALID_HANDLE_VALUE ) {
            length += (ULONG) sprintf( &NlGlobalLogFileOutputBuffer[length], "[NETLOGON] " );
        }

        //
        // Put the timestamp at the begining of the line.
        //
        {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &NlGlobalLogFileOutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }

        //
        // Indicate the type of message on the line
        //
        {
            char *Text;

            switch (DebugFlag) {
            case NL_INIT:
                Text = "INIT"; break;
            case NL_MISC:
                Text = "MISC"; break;
            case NL_LOGON:
                Text = "LOGON"; break;
            case NL_SYNC:
            case NL_PACK_VERBOSE:
            case NL_REPL_TIME:
            case NL_REPL_OBJ_TIME:
            case NL_SYNC_MORE:
                Text = "SYNC"; break;
            case NL_ENCRYPT:
                Text = "ENCRYPT"; break;
            case NL_MAILSLOT:
            case NL_MAILSLOT_TEXT:
                Text = "MAILSLOT"; break;
            case NL_SITE:
            case NL_SITE_MORE:
                Text = "SITE"; break;
            case NL_CRITICAL:
                Text = "CRITICAL"; break;
            case NL_SESSION_SETUP:
            case NL_SESSION_MORE:
            case NL_CHALLENGE_RES:
            case NL_INHIBIT_CANCEL:
            case NL_SERVER_SESS:
                Text = "SESSION"; break;
            case NL_CHANGELOG:
                Text = "CHANGELOG"; break;
            case NL_PULSE_MORE:
                Text = "PULSE"; break;
            case NL_DOMAIN:
                Text = "DOMAIN"; break;
            case NL_DNS:
            case NL_DNS_MORE:
                Text = "DNS"; break;
            case NL_WORKER:
                Text = "WORKER"; break;
            case NL_TIMESTAMP:
            case NL_BREAKPOINT:
            default:
                Text = "UNKNOWN"; break;

            case 0:
                Text = NULL;
            }
            if ( Text != NULL ) {
                length += (ULONG) sprintf( &NlGlobalLogFileOutputBuffer[length], "[%s] ", Text );
            }
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    lengthTmp = _vsnprintf( &NlGlobalLogFileOutputBuffer[length],
                            MAX_PRINTF_LEN - length - 1,
                            Format,
                            arglist );

    if ( lengthTmp < 0 ) {
        length = MAX_PRINTF_LEN - 1;
        // always end the line which cannot fit into the buffer
        NlGlobalLogFileOutputBuffer[length-1] = '\n';
    } else {
        length += lengthTmp;
    }

    BeginningOfLine = (length > 0 && NlGlobalLogFileOutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {
        NlGlobalLogFileOutputBuffer[length-1] = '\r';
        NlGlobalLogFileOutputBuffer[length] = '\n';
        NlGlobalLogFileOutputBuffer[length+1] = '\0';
        length++;
    }


    //
    // If the log file isn't open,
    //  just output to the debug terminal
    //

    if ( NlGlobalLogFile == INVALID_HANDLE_VALUE ) {
#if DBG
        if ( !LogProblemWarned ) {
            (void) DbgPrint( "[NETLOGON] Cannot write to log file - file not open\n" );
            LogProblemWarned = TRUE;
        }
#endif // DBG

    //
    // Write the debug info to the log file.
    //

    } else {
        if ( !WriteFile( NlGlobalLogFile,
                         NlGlobalLogFileOutputBuffer,
                         length,
                         &BytesWritten,
                         NULL ) ) {
#if DBG
            if ( !LogProblemWarned ) {
                (void) DbgPrint( "[NETLOGON] Cannot write to log file %ld\n", GetLastError() );
                LogProblemWarned = TRUE;
            }
#endif // DBG
        }

    }

} // NlPrintRoutineV

VOID
NlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

    //
    // If we aren't debugging this functionality, just return.
    //

    if ( DebugFlag != 0 && (NlGlobalParameters.DbFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &NlGlobalLogFileCritSect );

    //
    // Simply change arguments to va_list form and call NlPrintRoutineV
    //

    va_start(arglist, Format);

    NlPrintRoutineV( DebugFlag, Format, arglist );

    va_end(arglist);

    LeaveCriticalSection( &NlGlobalLogFileCritSect );

} // NlPrintRoutine

VOID
NlPrintDomRoutine(
    IN DWORD DebugFlag,
    IN PDOMAIN_INFO DomainInfo OPTIONAL,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

    //
    // If we aren't debugging this functionality, just return.
    //

    if ( DebugFlag != 0 && (NlGlobalParameters.DbFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &NlGlobalLogFileCritSect );

    //
    // Prefix the printed line with the domain name
    //

    if ( NlGlobalServicedDomainCount > 1 ) {
        if ( DomainInfo == NULL ) {
            NlPrint(( DebugFlag, "%ws: ", L"[Unknown]" ));
        } else if ( DomainInfo->DomUnicodeDomainName != NULL &&
                    *(DomainInfo->DomUnicodeDomainName) != UNICODE_NULL ) {
            NlPrint(( DebugFlag, "%ws: ", DomainInfo->DomUnicodeDomainName ));
        } else {
            NlPrint(( DebugFlag, "%ws: ", DomainInfo->DomUnicodeDnsDomainName ));
        }
    }


    //
    // Simply change arguments to va_list form and call NlPrintRoutineV
    //

    va_start(arglist, Format);

    NlPrintRoutineV( DebugFlag, Format, arglist );

    va_end(arglist);

    LeaveCriticalSection( &NlGlobalLogFileCritSect );

} // NlPrintDomRoutine

VOID
NlPrintCsRoutine(
    IN DWORD DebugFlag,
    IN PCLIENT_SESSION ClientSession,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

    //
    // If we aren't debugging this functionality, just return.
    //

    if ( DebugFlag != 0 && (NlGlobalParameters.DbFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &NlGlobalLogFileCritSect );

    //
    // If a ClientSession was actually passed,
    //  print information specific to the session.
    //

    if ( ClientSession != NULL ) {
        //
        // Prefix the printed line with the hosted domain name
        //

        if ( NlGlobalServicedDomainCount > 1 ) {
            NlPrint(( DebugFlag,
                     "%ws: ",
                     ClientSession->CsDomainInfo == NULL ? L"[Unknown]" : ClientSession->CsDomainInfo->DomUnicodeDomainName ));
        }

        //
        // Prefix the printed line with the name of the trusted domain
        //

        NlPrint(( DebugFlag,
                 "%ws: ",
                 ClientSession->CsDebugDomainName == NULL ? L"[Unknown]" : ClientSession->CsDebugDomainName ));
    }


    //
    // Simply change arguments to va_list form and call NlPrintRoutineV
    //

    va_start(arglist, Format);

    NlPrintRoutineV( DebugFlag, Format, arglist );

    va_end(arglist);

    LeaveCriticalSection( &NlGlobalLogFileCritSect );

} // NlPrintCsRoutine

VOID
NlPrintRpcDebug(
    IN LPCSTR RpcRoutineName,
    IN NTSTATUS StatusIn
    )
/*++

Routine Description:

    This routine prints RPC extended error information
    relevant to the error specified.

    This code comes directly from the "RPC Debugging.doc" spec.

Arguments:

    RpcRoutineName - The name of the failed RPC routine for
        which we print the extended info.

    StatusIn - NT error status code returned by the failed
        RPC routine for which we print the extended error.

Return Value:

    None.

--*/
{
    RPC_STATUS Status2;
    RPC_ERROR_ENUM_HANDLE EnumHandle;
    ULONG EntryIndex = 0;
    BOOLEAN LoggingEnabled = FALSE;
    BOOLEAN FirstRecordCheck = TRUE;

    //
    // If the call didn't fail, there is nothing to debug
    //

    if ( NT_SUCCESS(StatusIn) ) {
        return;
    }

    //
    // Don't bother if netlogon's critical logging is turned off
    //

    IF_NL_DEBUG( CRITICAL ) {
        LoggingEnabled = TRUE;
    }

    if ( !LoggingEnabled ) {
        return;
    }

    //
    // Get the info from RPC
    //

    Status2 = RpcErrorStartEnumeration(&EnumHandle);

    if ( Status2 != RPC_S_OK ) {
        NlPrint(( NL_CRITICAL,
                  "NlPrintRpcDebug: Couldn't get EEInfo for %s: %lu (may be legitimate for 0x%lx)\n",
                  RpcRoutineName,
                  Status2,
                  StatusIn ));

    //
    // Loop through the records and log the info for each record
    //

    } else {
        RPC_EXTENDED_ERROR_INFO ErrorInfo;
        int Records;
        BOOL Result;
        BOOL CopyStrings = TRUE;
        BOOL fUseFileTime = TRUE;
        SYSTEMTIME *SystemTimeToUse;
        SYSTEMTIME SystemTimeBuffer;

        EnterCriticalSection( &NlGlobalLogFileCritSect );
        while (Status2 == RPC_S_OK) {
            ErrorInfo.Version = RPC_EEINFO_VERSION;
            ErrorInfo.Flags = 0;
            ErrorInfo.NumberOfParameters = 4;
            if (fUseFileTime) {
                ErrorInfo.Flags |= EEInfoUseFileTime;
            }

            Status2 = RpcErrorGetNextRecord(&EnumHandle, CopyStrings, &ErrorInfo);
            if (Status2 == RPC_S_ENTRY_NOT_FOUND) {
                break;
            } else if (Status2 != RPC_S_OK) {
                NlPrint(( NL_CRITICAL,
                          "NlPrintRpcDebug: Couldn't finish enumeration for %s: %lu\n",
                          RpcRoutineName,
                          Status2 ));
                break;
            } else {
                int i;

                //
                // The first record must have the NT/WIN32 status field equal/equivalent
                //  to the passed API error code.  Otherwise, this error info was generated
                //  for some other failure and is not relevant for our debugging purposes.
                //
                if ( FirstRecordCheck ) {
                    FirstRecordCheck = FALSE;

                    if ( StatusIn != ErrorInfo.Status &&
                         StatusIn != I_RpcMapWin32Status(ErrorInfo.Status) ) {
                        break;
                    }
                    NlPrint(( NL_CRITICAL,
                              "NlPrintRpcDebug: Dumping extended error for %s with 0x%lx\n",
                              RpcRoutineName,
                              StatusIn ));
                }

                if (ErrorInfo.ComputerName) {
                    NlPrint(( NL_CRITICAL, " [%lu] ComputerName is %S\n",
                              EntryIndex,
                              ErrorInfo.ComputerName ));
                    if (CopyStrings) {
                        Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.ComputerName);
                        ASSERT(Result);
                    }
                }
                NlPrint(( NL_CRITICAL, " [%lu] ProcessID is %d\n",
                          EntryIndex,
                          ErrorInfo.ProcessID ));
                if (fUseFileTime) {
                    Result = FileTimeToSystemTime(&ErrorInfo.u.FileTime,
                                                  &SystemTimeBuffer);
                    ASSERT(Result);
                    SystemTimeToUse = &SystemTimeBuffer;
                } else {
                    SystemTimeToUse = &ErrorInfo.u.SystemTime;
                }

                NlPrint(( NL_CRITICAL, " [%lu] System Time is: %d/%d/%d %d:%d:%d:%d\n",
                          EntryIndex,
                          SystemTimeToUse->wMonth,
                          SystemTimeToUse->wDay,
                          SystemTimeToUse->wYear,
                          SystemTimeToUse->wHour,
                          SystemTimeToUse->wMinute,
                          SystemTimeToUse->wSecond,
                          SystemTimeToUse->wMilliseconds ));
                NlPrint(( NL_CRITICAL, " [%lu] Generating component is %d\n",
                          EntryIndex,
                          ErrorInfo.GeneratingComponent ));
                NlPrint(( NL_CRITICAL, " [%lu] Status is %lu\n",
                          EntryIndex,
                          ErrorInfo.Status ));
                NlPrint(( NL_CRITICAL, " [%lu] Detection location is %d\n",
                          EntryIndex,
                          (int)ErrorInfo.DetectionLocation ));
                NlPrint(( NL_CRITICAL, " [%lu] Flags is %d\n",
                          EntryIndex,
                          ErrorInfo.Flags ));
                NlPrint(( NL_CRITICAL, " [%lu] NumberOfParameters is %d\n",
                          EntryIndex,
                          ErrorInfo.NumberOfParameters ));
                for (i = 0; i < ErrorInfo.NumberOfParameters; i ++) {
                    switch(ErrorInfo.Parameters[i].ParameterType) {
                        case eeptAnsiString:
                            NlPrint(( NL_CRITICAL, "     Ansi string: %s\n",
                                      ErrorInfo.Parameters[i].u.AnsiString ));
                            if (CopyStrings) {
                                Result = HeapFree(GetProcessHeap(), 0,
                                    ErrorInfo.Parameters[i].u.AnsiString);
                                ASSERT(Result);
                            }
                            break;

                        case eeptUnicodeString:
                            NlPrint(( NL_CRITICAL, "     Unicode string: %S\n",
                                      ErrorInfo.Parameters[i].u.UnicodeString ));
                            if (CopyStrings) {
                                Result = HeapFree(GetProcessHeap(), 0,
                                    ErrorInfo.Parameters[i].u.UnicodeString);
                                ASSERT(Result);
                            }
                            break;

                        case eeptLongVal:
                            NlPrint(( NL_CRITICAL, "     Long val: %d\n",
                                      ErrorInfo.Parameters[i].u.LVal ));
                            break;

                        case eeptShortVal:
                            NlPrint(( NL_CRITICAL, "     Short val: %d\n",
                                      (int)ErrorInfo.Parameters[i].u.SVal ));
                            break;

                        case eeptPointerVal:
                            NlPrint(( NL_CRITICAL, "     Pointer val: %d\n",
                                      ErrorInfo.Parameters[i].u.PVal ));
                            break;

                        case eeptNone:
                            NlPrint(( NL_CRITICAL, "     Truncated\n" ));
                            break;

                        default:
                            NlPrint(( NL_CRITICAL, "     Invalid type: %d\n",
                                      ErrorInfo.Parameters[i].ParameterType ));
                    }
                }
                EntryIndex ++;
            }
        }
        LeaveCriticalSection( &NlGlobalLogFileCritSect );
        RpcErrorEndEnumeration(&EnumHandle);
    }
}

//
// Have my own version of RtlAssert so debug versions of netlogon really assert on
// free builds.
//
VOID
NlAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
    char Response[ 2 ];

#if DBG
    while (TRUE) {
#endif // DBG

        NlPrint(( NL_CRITICAL, "Assertion failed: %s%s (Source File: %s, line %ld)\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                ));

#if DBG
        DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

        DbgPrompt( "Break, Ignore, Terminate Process or Terminate Thread (bipt)? ",
                   Response,
                   sizeof( Response )
                 );
        switch (Response[0]) {
            case 'B':
            case 'b':
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'P':
            case 'p':
                NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
                break;

            case 'T':
            case 't':
                NtTerminateThread( NtCurrentThread(), STATUS_UNSUCCESSFUL );
                break;
            }
        }

    DbgBreakPoint();
    NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
#endif // DBG
}

#endif // NETLOGONDBG


BOOLEAN
NlpIsNtStatusResourceError(
    NTSTATUS Status
    )

/*++

Routine Description:

    Returns TRUE if the passed in status is a resource error.

Arguments:

    Status - NT status code to check

Return Value:

    TRUE - if the status indicates a lack of resources

--*/
{

    switch ( Status ) {
    case STATUS_NO_MEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_DISK_FULL:

        return TRUE;

    default:

        return FALSE;
    }
}

BOOLEAN
NlpDidDcFail(
    NTSTATUS Status
    )

/*++

Routine Description:

    Call this routine with the Status code returned from a secure channel API.

    This routine checks the status code to determine if it specifically is one
    that indicates the DC is having problems.  The caller should respond by
    dropping the secure channel and picking another DC.

Arguments:

    Status - NT status code to check

Return Value:

    TRUE - if the status indicates the DC failed

--*/
{
    //
    // ???: we might consider adding the communications errors here
    //  (e.g., RPC_NT_CALL_FAILED and RPC_NT_SERVER_UNAVAILABLE).
    // However, all current callers already handle this issue using a more generic
    // mechanism.  For instance, those secure channel API that take an authenticator
    // will have the authenticator wrong for communications errors.  The other secure
    // channel API rely on the RPC exception differentiating between comm errors
    // and status codes from the DC.
    //

    //
    // Handle the "original recipe" status code indicating a secure channel problem
    //
    switch ( Status ) {
    case STATUS_ACCESS_DENIED:
        return TRUE;

    default:

        return NlpIsNtStatusResourceError( Status );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nlp.h ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    nlp.h

Abstract:

    Private Netlogon service utility routines.

Author:

    Cliff Van Dyke (cliffv) 7-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

//
// Procedure forwards from nlp.c
//

LPWSTR
NlStringToLpwstr(
    IN PUNICODE_STRING String
    );

LPSTR
NlStringToLpstr(
    IN PUNICODE_STRING String
    );

BOOLEAN
NlAllocStringFromWStr(
    IN LPWSTR InString,
    OUT PUNICODE_STRING OutString
    );

BOOLEAN
NlDuplicateUnicodeString(
    IN PUNICODE_STRING InString OPTIONAL,
    OUT PUNICODE_STRING OutString
    );

VOID
NlFreeUnicodeString(
    IN PUNICODE_STRING InString OPTIONAL
    );

VOID
NlpClearEventlogList (
    VOID
    );

VOID
NlpWriteEventlog (
    IN DWORD EventID,
    IN DWORD EventType,
    IN LPBYTE buffer OPTIONAL,
    IN DWORD numbytes,
    IN LPWSTR *msgbuf,
    IN DWORD strcount
    );

VOID
NlpWriteEventlogEx (
    IN DWORD EventId,
    IN DWORD EventType,
    IN LPBYTE RawDataBuffer OPTIONAL,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN DWORD StringCount,
    IN DWORD StatusMessageIndex
    );

DWORD
NlpAtoX(
    IN LPWSTR String
    );

VOID
NlWaitForSingleObject(
    IN LPSTR WaitReason,
    IN HANDLE WaitHandle
    );

BOOLEAN
NlWaitForSamService(
    BOOLEAN NetlogonServiceCalling
    );

VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    );

NET_API_STATUS
NlReadBinaryLog(
    IN LPWSTR FileSuffix,
    IN BOOL DeleteName,
    OUT LPBYTE *Buffer,
    OUT PULONG BufferSize
    );

BOOLEAN
NlpIsNtStatusResourceError(
    NTSTATUS Status
    );

BOOLEAN
NlpDidDcFail(
    NTSTATUS Status
    );

//
// Fast version of NtQuerySystemTime
//

#define NlQuerySystemTime( _Time ) GetSystemTimeAsFileTime( (LPFILETIME)(_Time) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nlsite.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    nlsite.c

Abstract:

    Routines to handle sites and subnets.

Author:

    Cliff Van Dyke (CliffV) 1-May-1997

Revision History:

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//
#include "ismapi.h"

//
// Structure describing several subnets.
//
// NlGlobalSubnetTree is the head of a tree of pointer to subnet.
// The most significant byte of an IP address is used to index into an array
// of SubTrees.  Each Subtree entry has either a pointer to the next level of
// the tree (to be indexed into with the next byte of the IP address) or a
// pointer to an NL_SUBNET leaf identifying the subnet this IP address is on.
//
// Both pointers can be NULL indicating that the subnet isn't registered.
//
// Both pointers can be non-NULL indicating that both a non-specific and specific
// subnet may be available.  The most specific subnet available for a particular
// IP address should be used.
//
//
// Multiple entries can point to the same NL_SUBNET leaf.  If the subnet mask is
// not an even number of bytes long, all of the entries represent IP addresses
// that correspond to the subnet mask will point to the subnet mask.
//

typedef struct _NL_SUBNET_TREE_ENTRY {

    //
    // Link to the next level of the tree
    //
    struct _NL_SUBNET_TREE *Subtree;

    //
    // Pointer to the subnet itself.
    //
    struct _NL_SUBNET *Subnet;


} NL_SUBNET_TREE_ENTRY, *PNL_SUBNET_TREE_ENTRY;

typedef struct _NL_SUBNET_TREE {
    NL_SUBNET_TREE_ENTRY Subtree[256];
} NL_SUBNET_TREE, *PNL_SUBNET_TREE;

//
// Structure describing a single subnet.
//
typedef struct _NL_SUBNET {

    //
    // Link for NlGlobalSubnetList
    //

    LIST_ENTRY Next;

    //
    // Subnet address. (Network bytes order)
    //

    ULONG SubnetAddress;

    //
    // Subnet mask. (Network byte order).
    //

    ULONG SubnetMask;

    //
    // Pointer to Site this subnet is in.
    //

    PNL_SITE_ENTRY SiteEntry;

    //
    // Reference Count.
    //

    ULONG ReferenceCount;

    //
    // Number of bits in the subnet mask
    //

    BYTE SubnetBitCount;


} NL_SUBNET, *PNL_SUBNET;


//
// Globals specific to this .c file.
//

BOOLEAN NlGlobalSiteInitialized = 0;

// List of all NL_SITE_ENTRY entries.
LIST_ENTRY NlGlobalSiteList;

// List of all NL_SUBNET entries
LIST_ENTRY NlGlobalSubnetList;

// Tree of subnets.
NL_SUBNET_TREE_ENTRY NlGlobalSubnetTree;
NL_SUBNET_TREE_ENTRY NlGlobalNewSubnetTree;

//
// Site Entry for the site this domain is a member of
//

PNL_SITE_ENTRY NlGlobalSiteEntry;
BOOLEAN NlGlobalOnlyOneSite;



VOID
NlRefSiteEntry(
    IN PNL_SITE_ENTRY SiteEntry
    )
/*++

Routine Description:

    Reference a site entry.

    NlGlobalSiteCritSect must be locked.

Arguments:

    SiteEntry - Entry to be referenced.

Return Value:

    None.

--*/
{
    SiteEntry->ReferenceCount ++;
}

VOID
NlDerefSiteEntry(
    IN PNL_SITE_ENTRY SiteEntry
    )
/*++

Routine Description:

    Dereference a site entry.

    If the reference count goes to zero,
        the site entry will be deleted.

Arguments:

    SiteEntry - Entry to be referenced.

Return Value:

    None.

--*/
{
    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( (--(SiteEntry->ReferenceCount)) == 0 ) {
        RemoveEntryList( &SiteEntry->Next );
        LocalFree( SiteEntry );
    }
    LeaveCriticalSection( &NlGlobalSiteCritSect );
}



BOOL
NetpEqualTStrArrays(
    LPTSTR_ARRAY TStrArray1 OPTIONAL,
    LPTSTR_ARRAY TStrArray2 OPTIONAL
    )

/*++

Routine Description:

    Compares to see if two TStrArray's are identical.

Arguments:

    TStrArray1 - First array to compare
    TStrArray2 - Second array to compare

Return Value:

    TRUE - Arrays are identical

    FALSE - Arrays are different

--*/
{
    //
    // Handle the NULL pointer cases.
    //
    if ( TStrArray1 == NULL && TStrArray2 == NULL ) {
        return TRUE;
    }
    if ( TStrArray1 != NULL && TStrArray2 == NULL ) {
        return FALSE;
    }
    if ( TStrArray1 == NULL && TStrArray2 != NULL ) {
        return FALSE;
    }


    //
    // Handle the case where both arrays exist
    //

    if ( NetpTStrArrayEntryCount ( TStrArray1 ) !=
         NetpTStrArrayEntryCount ( TStrArray2 ) ) {
        return FALSE;
    }

    while (!NetpIsTStrArrayEmpty(TStrArray1)) {

        //
        // Check if the entry is different.
        //
        // Do a case sensitive comparison to allow case changes to be detected.
        //
        if ( wcscmp( TStrArray1, TStrArray2 ) != 0 ) {
            return FALSE;
        }

        // Move to the next element
        TStrArray1 = NetpNextTStrArrayEntry(TStrArray1);
        TStrArray2 = NetpNextTStrArrayEntry(TStrArray2);
    }

    return TRUE;

}


NET_API_STATUS
NlSitesGetCloseSites(
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG ServerRole,
    OUT PNL_SITE_NAME_ARRAY *SiteNames
    )
/*++

Routine Description:

    This routine returns the site names of all the sites this DC covers.

Arguments:

    DomainInfo - Domain/Forest/NDNC info for which to return close sites

    ServerRole - The role this server plays in the domain/forest/NDNC.
        ??: When we go multihosted, this parameter will not be needed
        because the role will be uniquely identified in the DomainInfo.

    SiteNames - Returns an array of pointers to site names.
        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

--*/
{
    NET_API_STATUS NetStatus;

    PNL_COVERED_SITE CoveredSiteArray;
    ULONG CoveredSiteCount = 0;
    ULONG EntryCount;
    ULONG i;
    ULONG Size;
    PUNICODE_STRING Strings;
    LPBYTE Where;
    ULONG Index;

    EnterCriticalSection( &NlGlobalSiteCritSect );

    if ( (ServerRole & DOM_FOREST) != 0 ) {
        CoveredSiteArray = DomainInfo->GcCoveredSites;
        CoveredSiteCount = DomainInfo->GcCoveredSitesCount;
    } else if ( (ServerRole & DOM_REAL_DOMAIN) != 0 ||
                (ServerRole & DOM_NON_DOMAIN_NC) != 0 ) {
        CoveredSiteArray = DomainInfo->CoveredSites;
        CoveredSiteCount = DomainInfo->CoveredSitesCount;
    }

    //
    // Determine the length of the returned information
    //

    Size = sizeof(NL_SITE_NAME_ARRAY);
    EntryCount = 0;

    for ( Index = 0; Index < CoveredSiteCount; Index++ ) {
        Size += sizeof(UNICODE_STRING) +
            CoveredSiteArray[Index].CoveredSite->SiteNameString.Length + sizeof(WCHAR);
        EntryCount++;
    }

    //
    // Allocate the return buffer.
    //

    *SiteNames = MIDL_user_allocate( Size );

    if ( *SiteNames == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Strings = (PUNICODE_STRING) ((*SiteNames)+1);
    (*SiteNames)->EntryCount = EntryCount;
    (*SiteNames)->SiteNames = Strings;
    Where = (LPBYTE) &Strings[EntryCount];

    //
    // Loop copying the names into the return buffer.
    //

    i = 0;
    for ( Index = 0; Index < CoveredSiteCount; Index++ ) {
        RtlCopyMemory( Where,
                       CoveredSiteArray[Index].CoveredSite->SiteName,
                       CoveredSiteArray[Index].CoveredSite->SiteNameString.Length + sizeof(WCHAR) );

        Strings[i].Buffer = (LPWSTR)Where;
        Strings[i].Length = CoveredSiteArray[Index].CoveredSite->SiteNameString.Length;
        Strings[i].MaximumLength = Strings[i].Length + sizeof(WCHAR);

        Where += Strings[i].Length + sizeof(WCHAR);
        i++;
    }

    NetStatus = NO_ERROR;

    NlPrint(( NL_MISC, "NlSitesGetCloseSites returns successfully\n" ));

Cleanup:

    LeaveCriticalSection( &NlGlobalSiteCritSect );
    if ( NetStatus != NO_ERROR ) {
        if ( *SiteNames != NULL ) {
            MIDL_user_free( *SiteNames );
            *SiteNames = NULL;
        }
        NlPrint((NL_MISC, "NlSitesGetCloseSites returns unsuccessfully with status %ld.\n", NetStatus ));
    }
    return NetStatus;
}

BOOL
NlSitesSetSiteCoverageParam(
    IN ULONG ServerRole,
    IN LPTSTR_ARRAY NewSiteCoverage OPTIONAL
    )
/*++

Routine Description:

    This routine set the site names of all the sites this DC covers.

Arguments:

    ServerRole - Specifies the role of the server (DC/GC/NDNC) for which
        the registry site coverage is being set.

    NewSiteCoverage - Specifies the new covered sites

Return Value:

    TRUE: iff site coverage changed

--*/
{
    LPTSTR_ARRAY *OldSiteCoverage = NULL;
    BOOL SiteCoverageChanged;
    PLIST_ENTRY ListEntry;

    //
    // If asking about the GC,
    //  use GC specific globals.
    //

    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( ServerRole & DOM_FOREST ) {
        OldSiteCoverage = &NlGlobalParameters.GcSiteCoverage;
    } else if ( ServerRole & DOM_REAL_DOMAIN ) {
        OldSiteCoverage = &NlGlobalParameters.SiteCoverage;
    } else if ( ServerRole & DOM_NON_DOMAIN_NC ) {
        OldSiteCoverage = &NlGlobalParameters.NdncSiteCoverage;
    }
    NlAssert( OldSiteCoverage != NULL );

    //
    // Handle SiteCoverage changing
    //

    SiteCoverageChanged = !NetpEqualTStrArrays(
                                *OldSiteCoverage,
                                NewSiteCoverage );

    if ( SiteCoverageChanged ) {
        //
        // Swap in the new value.
        (VOID) NetApiBufferFree( *OldSiteCoverage );
        *OldSiteCoverage = NewSiteCoverage;

    }

    LeaveCriticalSection( &NlGlobalSiteCritSect );
    return SiteCoverageChanged;

}

//
// Procedure forwards of procedures in ntdsapi.dll
//

typedef
DWORD
(*PDsGetDomainControllerInfoW)(
    HANDLE                          hDs,            // in
    LPCWSTR                         DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo);      // out

PDsGetDomainControllerInfoW NlGlobalpDsGetDomainControllerInfoW;

typedef
VOID
(*PDsFreeDomainControllerInfoW)(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo);        // in

PDsFreeDomainControllerInfoW NlGlobalpDsFreeDomainControllerInfoW;


NTSTATUS
NlLoadNtDsApiDll(
    VOID
    )
/*++

Routine Description:

    This function loads the ntdsaapi.dll module if it is not loaded
    already.

Arguments:

    None

Return Value:

    NT Status code.

--*/
{
    static NTSTATUS DllLoadStatus = STATUS_SUCCESS;
    HANDLE DllHandle = NULL;

    //
    // If the DLL is already loaded,
    //  we're done.
    //

    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( NlGlobalDsApiDllHandle != NULL ) {
        LeaveCriticalSection( &NlGlobalSiteCritSect );
        return STATUS_SUCCESS;
    }


    //
    // If we've tried to load the DLL before and it failed,
    //  return the same error code again.
    //

    if( DllLoadStatus != STATUS_SUCCESS ) {
        goto Cleanup;
    }


    //
    // Load the dlls
    //

    DllHandle = LoadLibraryA( "NtDsApi" );

    if ( DllHandle == NULL ) {
        DllLoadStatus = STATUS_DLL_NOT_FOUND;
        goto Cleanup;
    }

//
// Macro to grab the address of the named procedure from ntdsa.dll
//

#define GRAB_ADDRESS( _X ) \
    NlGlobalp##_X = (P##_X) GetProcAddress( DllHandle, #_X ); \
    \
    if ( NlGlobalp##_X == NULL ) { \
        DllLoadStatus = STATUS_PROCEDURE_NOT_FOUND;\
        goto Cleanup; \
    }

    //
    // Get the addresses of the required procedures.
    //

    GRAB_ADDRESS( DsBindW )
    GRAB_ADDRESS( DsGetDomainControllerInfoW )
    GRAB_ADDRESS( DsFreeDomainControllerInfoW )
    GRAB_ADDRESS( DsUnBindW )


    DllLoadStatus = STATUS_SUCCESS;

Cleanup:
    if (DllLoadStatus == STATUS_SUCCESS) {
        NlGlobalDsApiDllHandle = DllHandle;

    } else {
        if ( DllHandle != NULL ) {
            FreeLibrary( DllHandle );
        }
    }
    LeaveCriticalSection( &NlGlobalSiteCritSect );
    return( DllLoadStatus );
}

VOID
NlSitesAddCloseSite(
    IN LPWSTR SiteName,
    IN OUT PNL_COVERED_SITE CoveredSites,
    IN OUT PULONG CoveredSitesCount,
    IN BOOLEAN CoveredAuto
    )
/*++

Routine Description:

    Add a site entry to the list passed. If the site entry already
    exists on the list, this is no-op. Otherwise, the site entry
    is added to the list (and to the global list of sites if this
    entry wasn't on the global list) and a reference on the site
    entry in the global list in incremented.

Arguments:

    SiteName - Name of site entry to add

    CoveredSites - Array of covered site entries.  The array
        must be big enough to accomodate a new potential entry.

    CoveredSiteCount - The current number of entries in CoveredSites.
        May be incremented if a new entry is added.

    CoveredAuto - If TRUE, this site is covered automatically.

Return Value:

    None

--*/
{
    PNL_SITE_ENTRY SiteEntry = NULL;
    ULONG CoveredSiteIndex;

    //
    // Sanity check
    //

    if ( SiteName == NULL || *SiteName == UNICODE_NULL ) {
        return;
    }

    //
    // Find/Add the site to the global list of sites
    //

    SiteEntry = NlFindSiteEntry( SiteName );
    if ( SiteEntry != NULL ) {

        //
        // If we already have this site on the current list of covered
        // sites, just update the auto coverage boolean and dereference
        // this site entry.
        //
        for ( CoveredSiteIndex = 0; CoveredSiteIndex < *CoveredSitesCount; CoveredSiteIndex++ ) {
            if ( CoveredSites[CoveredSiteIndex].CoveredSite == SiteEntry ) {
                CoveredSites[CoveredSiteIndex].CoveredAuto = CoveredAuto;
                NlDerefSiteEntry( SiteEntry );
                return;
            }
        }

        //
        // We don't have this site on the current list of covered
        // sites. So add this site to the list, set the auto coverage
        // boolean, and keep just added reference in the global list
        // of sites.
        //
        CoveredSites[*CoveredSitesCount].CoveredSite = SiteEntry;
        CoveredSites[*CoveredSitesCount].CoveredAuto = CoveredAuto;
        (*CoveredSitesCount) ++;
    }
}

BOOL
NlSitesGetIsmConnect(
    IN LPWSTR SiteName,
    OUT PISM_CONNECTIVITY *SiteConnect,
    OUT PULONG ThisSite
    )
/*++

Routine Description:

    Get the site connection matrix from ISM.

Arguments:

    SiteName - Site name of the site this DC is in

    SiteConnect - Returns a pointer to the site connection matrix
        Use I_ISMFree to free this data.

    ThisSite - Return an index to SiteName within SiteConnect
        0xFFFFFFFF - means this site is not in SiteConnect

Return Value:

    TRUE on success
    None.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    DWORD Length;
    PDSNAME DsRoot = NULL;
    LPWSTR IpName = NULL;
    DWORD SiteIndex1;
    DWORD SiteIndex2;

    BOOLEAN RetVal = FALSE;

    //
    // Initialization
    //
    *SiteConnect = NULL;
    *ThisSite = 0xFFFFFFFF;

    //
    // If netlogon isn't running,
    //  simply return since we don't want to wait for the ISM service to start
    //  while we're starting.
    //

    if ( NlGlobalChangeLogNetlogonState != NetlogonStarted ) {
        NlPrint(( NL_SITE_MORE,
                  "NlSitesGetIsmConnect: Avoided during startup.\n" ));
        goto Cleanup;
    }

    //
    // Wait up to 45 seconds for the ISM service to start
    //

    Status = NlWaitForService( SERVICE_ISMSERV, 45, TRUE );

    if ( Status != STATUS_SUCCESS ) {
        NlPrint(( NL_SITE_MORE,
                  "NlSitesGetIsmConnect: ISM service not started.\n" ));
        goto Cleanup;
    }


    //
    // Build the name of the IP transport
    //

#define ISM_IP_TRANSPORT L"CN=IP,CN=Inter-Site Transports,CN=Sites,"

    Length = 0;
    Status = NlGetConfigurationName( DSCONFIGNAME_CONFIGURATION, &Length, NULL );

    NlAssert( Status == STATUS_BUFFER_TOO_SMALL );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        NlPrint(( NL_CRITICAL,
                  "NlSitesGetIsmConnect: Cannot GetConfigurationName 0x%lx.\n",
                  Status ));
        goto Cleanup;
    }

    DsRoot = LocalAlloc( 0, Length );

    if ( DsRoot == NULL ) {
        goto Cleanup;
    }

    Status = NlGetConfigurationName( DSCONFIGNAME_CONFIGURATION, &Length, DsRoot );

    if ( !NT_SUCCESS( Status ) ) {
        NlPrint(( NL_CRITICAL,
                  "NlSitesGetIsmConnect: Cannot GetConfigurationName 0x%lx.\n",
                  Status ));
        goto Cleanup;
    }

    IpName = LocalAlloc( 0, DsRoot->NameLen * sizeof(WCHAR) +
                            sizeof( ISM_IP_TRANSPORT ) );

    if ( IpName == NULL ) {
        goto Cleanup;
    }

    wcscpy( IpName, ISM_IP_TRANSPORT );
    wcscat( IpName, DsRoot->StringName );


    //
    // Get the site link costs
    //

    NetStatus = I_ISMGetConnectivity( IpName, SiteConnect);

    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "NlSitesGetIsmConnect: Cannot I_ISMGetConnectivity %ld.\n",
                  NetStatus ));
        goto Cleanup;
    }

    if ( *SiteConnect == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NlSitesGetIsmConnect: I_ISMGetConnectivity returned NULL.\n" ));
        goto Cleanup;
    }


    //
    // Convert the returned site name to a canonical form
    //

    for (SiteIndex1 = 0; SiteIndex1 < (*SiteConnect)->cNumSites; SiteIndex1++) {

        if ( _wcsnicmp( (*SiteConnect)->ppSiteDNs[SiteIndex1], L"CN=", 3 ) == 0 ) {
            WCHAR *Comma;

            (*SiteConnect)->ppSiteDNs[SiteIndex1] += 3;

            Comma = wcschr( (*SiteConnect)->ppSiteDNs[SiteIndex1], L',' );

            if ( Comma != NULL ) {
                *Comma = L'\0';
            }

        }

        //
        // Remember which site this site is:
        //
        if ( _wcsicmp( SiteName,
                       (*SiteConnect)->ppSiteDNs[SiteIndex1] ) == 0 ) {
            *ThisSite = SiteIndex1;
        }

    }

    //
    // Be verbose
    //
#if NETLOGONDBG
    EnterCriticalSection( &NlGlobalLogFileCritSect );
    NlPrint(( NL_SITE_MORE,
              "NlSitesGetIsmConnect: Site link costs for %ld sites:\n",
              (*SiteConnect)->cNumSites ));

    for (SiteIndex2 = 0; SiteIndex2 < (*SiteConnect)->cNumSites; SiteIndex2++) {
        NlPrint(( NL_SITE_MORE,
                  "%s%5d",
                  SiteIndex2 ? "," : "    ",
                  SiteIndex2 ));
    }
    NlPrint(( NL_SITE_MORE, "\n"));
    for (SiteIndex1 = 0; SiteIndex1 < (*SiteConnect)->cNumSites; SiteIndex1++) {
        if ( *ThisSite == SiteIndex1 ) {
            NlPrint(( NL_SITE_MORE, "*" ));
        } else {
            NlPrint(( NL_SITE_MORE, " " ));
        }
        NlPrint(( NL_SITE_MORE,
                  "(%2d) %ws\n",
                  SiteIndex1,
                  (*SiteConnect)->ppSiteDNs[SiteIndex1]));

        for (SiteIndex2 = 0; SiteIndex2 < (*SiteConnect)->cNumSites; SiteIndex2++) {
            PISM_LINK pLink = &((*SiteConnect)->pLinkValues[SiteIndex1 * (*SiteConnect)->cNumSites + SiteIndex2]);

            NlPrint(( NL_SITE_MORE,
                      "%s%5d",
                      SiteIndex2 ? "," : "    ",
                      pLink->ulCost ));

        }
        NlPrint(( NL_SITE_MORE, "\n"));
    }
    LeaveCriticalSection( &NlGlobalLogFileCritSect );
#endif // NETLOGONDBG


    RetVal = TRUE;

Cleanup:
    if ( DsRoot != NULL ) {
        LocalFree( DsRoot );
    }

    if ( IpName != NULL ) {
        LocalFree( IpName );
    }

    return RetVal;
}

BOOL
NlValidateSiteName(
    IN LPWSTR SiteName
    )
/*++

Routine Description:

    This routine validates the site name to be non-mangled and
    valid for use as a label in a DNS name. A site with a
    mangled name may be created in addition to the site with the
    intended name as a result of a site name collision in the DS.

Arguments:

    SiteName -- The site name to be validated

Return Value:

    TRUE -- Site name is verified as valid for use
    FALSE -- Site name is not verified as valid for use

--*/
{
    NET_API_STATUS NetStatus;

    //
    // NULL site name is invalid
    //

    if ( SiteName == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NlValidateSiteName: NULL site name is invalid\n" ));

        return FALSE;
    }

    //
    // Check if the site name is mangled
    //

    if ( NlIsMangledRDNExternal(SiteName, wcslen(SiteName), NULL) ) {
        NlPrint(( NL_CRITICAL,
                  "NlValidateSiteName: Site name %ws is mangled\n",
                  SiteName ));

        return FALSE;
    }

    //
    // Sanity check that the site name can be
    //  used as a label in a DNS name
    //

    NetStatus = DnsValidateName_W( SiteName, DnsNameDomainLabel );

    if ( NetStatus == NO_ERROR || NetStatus == DNS_ERROR_NON_RFC_NAME ) {
        return TRUE;
    } else {
        NlPrint(( NL_CRITICAL,
                  "NlValidateSiteName: Site name %ws is not valid DNS label\n",
                  SiteName ));
        return FALSE;
    }
}

NET_API_STATUS
NlSitesUpdateSiteCoverageForRole(
    IN  PDOMAIN_INFO DomainInfo,
    IN  ULONG DomFlags,
    IN  HANDLE DsHandle,
    IN  PISM_CONNECTIVITY SiteConnect,
    IN  LPWSTR ThisSiteName,
    IN  ULONG ThisSiteIndex,
    OUT PBOOLEAN SiteCoverageChanged OPTIONAL
    )
/*++

Routine Description:

    This routine recomputes the site coverage for this DC based on the costs
    associated with the site links.

    Basically, for each site that has no DCs for this domain, the site this DC
    is in might be chosen to "cover" the site.  The following criteria is used:

    * Site link cost.
    * For sites where the above is equal, the site having the most DCs is chosen.
    * For sites where the above is equal, the site having the alphabetically least
      name is chosen.


Arguments:

    DomainInfo - Hosted domain whose site coverage is to be updated

    DomFlags - The role for which we need to update the site coverage

    DsHandle - Handle to the DS

    SiteConnect - If specified, the site link costs info returned by NlSitesGetIsmConnect

    ThisSiteName - The name of the site of this server

    ThisSiteIndex - The index of the site of this server in the SiteConnect info

    SiteCoverageChanged - If specified and the site covereage changes, returns TRUE.
        Otherwise, left intact.

Return Value:

    NO_ERROR

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;

    WCHAR DnsDomainName[NL_MAX_DNS_LENGTH+1];

    WCHAR CapturedDnsForestName[NL_MAX_DNS_LENGTH+1];

    ULONG SiteCount = 0;
    ULONG TmpSiteCount = 0;
    DWORD SiteIndex1;
    DWORD SiteIndex2;

    PULONG DcsInSite = NULL;
    BOOLEAN LocalSiteCoverageChanged = FALSE;

    PDS_DOMAIN_CONTROLLER_INFO_1W DcInfo = NULL;
    ULONG DcInfoCount;

    PDS_NAME_RESULT GcInfo = NULL;

    SERVERSITEPAIR *ServerSitePairs = NULL;

    PNL_SITE_ENTRY SiteEntry;

    PLIST_ENTRY ListEntry;
    LPSTR GcOrDcOrNdnc = NULL;

    BOOLEAN AtleastOneDc = FALSE;
    LPTSTR_ARRAY SiteCoverageParameter = NULL;

    PNL_COVERED_SITE CoveredSites = NULL;
    ULONG CoveredSitesCount = 0;
    ULONG CoveredSitesIndex;

    PNL_COVERED_SITE OldCoveredSites = NULL;
    ULONG OldCoveredSitesCount = 0;
    ULONG OldCoveredSitesIndex;

    //
    // Local variable initialization
    //

    if ( DomFlags & DOM_FOREST ) {
        GcOrDcOrNdnc = "GC";
    } else if ( DomFlags & DOM_REAL_DOMAIN ) {
        GcOrDcOrNdnc = "DC";
    } else if ( DomFlags & DOM_NON_DOMAIN_NC ) {
        GcOrDcOrNdnc = "NDNC";
    }

    //
    // Allocate a temporary storage for all possible site entries
    //
    // Count for the site link cost entries
    //

    if ( SiteConnect != NULL ) {
        TmpSiteCount += SiteConnect->cNumSites;
    }

    //
    // Count for the registry coverage parameter
    //

    if ( DomFlags & DOM_FOREST ) {
        SiteCoverageParameter = NlGlobalParameters.GcSiteCoverage;
    } else if ( DomFlags & DOM_REAL_DOMAIN ) {
        SiteCoverageParameter = NlGlobalParameters.SiteCoverage;
    } else if ( DomFlags & DOM_NON_DOMAIN_NC ) {
        SiteCoverageParameter = NlGlobalParameters.NdncSiteCoverage;
    }

    if ( SiteCoverageParameter != NULL ) {
        TmpSiteCount += NetpTStrArrayEntryCount( (LPTSTR_ARRAY) SiteCoverageParameter );
    }

    //
    // Count for the site of this machine
    //

    TmpSiteCount ++;

    //
    // Allocate the storage
    //

    CoveredSites = LocalAlloc( LMEM_ZEROINIT, TmpSiteCount * sizeof(NL_COVERED_SITE) );
    if ( CoveredSites == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Capture the dns domain name of the hosted
    //

    NlCaptureDomainInfo ( DomainInfo, DnsDomainName, NULL );

    //
    // Capture the forest name
    //

    NlCaptureDnsForestName( CapturedDnsForestName );

    //
    // If we are to automatically determine site coverage and
    //  we have the site link costs, build the coverage list
    //  corresponding to the specified role.
    //

    if ( NlGlobalParameters.AutoSiteCoverage &&
         SiteConnect != NULL &&
         SiteConnect->cNumSites != 0 ) {

        SiteCount = SiteConnect->cNumSites;

        //
        // Allocate a buffer for temporary storage.
        //

        DcsInSite = LocalAlloc( LMEM_ZEROINIT, SiteCount * sizeof(ULONG) );
        if ( DcsInSite == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Depending on the role, get the list of GCs/DCs/NDNCs and their sites
        //

        if ( DsHandle != NULL ) {

            //
            // Handle building the GC coverage list
            //

            if ( DomFlags & DOM_FOREST ) {
                LPWSTR DummyName = L".";

                //
                // Get the list of GCs in the forest and their sites.
                // Avoid this operation if we are not currently a GC in
                // which case update the GC covered site info based
                // on the registry setting below.
                //
                // ??: For multihosting, we will indicate whether we
                // are a GC in the forest DOMAIN_INFO struct instead of
                // the global as we currently use.
                //

                if ( (NlGetDomainFlags(DomainInfo) & DS_GC_FLAG) == 0 ) {
                    NlPrint(( NL_SITE_MORE,
                              "GC: This DC isn't a GC. So it doesn't auto cover any sites as a GC.\n" ));
                } else {

                    NetStatus = DsCrackNamesW(
                                    DsHandle,
                                    0,
                                    DS_LIST_GLOBAL_CATALOG_SERVERS,
                                    DS_LIST_GLOBAL_CATALOG_SERVERS,
                                    1,
                                    &DummyName,
                                    &GcInfo );

                    if ( NetStatus != NO_ERROR ) {
                        NlPrint(( NL_CRITICAL,
                                  "NlSitesUpdateSiteCoverage: CrackNames failed: %ld\n",
                                  NetStatus ));

                    } else {
                        ULONG GcIndex;


                        //
                        // Determine which sites are already covered by GCs.
                        //
                        for ( GcIndex=0; GcIndex < GcInfo->cItems; GcIndex++ ) {
                            LPWSTR GcSiteName = GcInfo->rItems[GcIndex].pName;
                            LPWSTR GcDnsHostName = GcInfo->rItems[GcIndex].pDomain;

                            NlPrint(( NL_SITE,
                                      "GC list: %ws %ws\n",
                                      GcSiteName,
                                      GcDnsHostName ));

                            if ( GcInfo->rItems[GcIndex].status != DS_NAME_NO_ERROR ) {
                                NlPrint(( NL_CRITICAL,
                                          "NlSitesUpdateSiteCoverage: CrackNameStatus bad: %ws %ws: %ld\n",
                                          GcSiteName,
                                          GcDnsHostName,
                                          GcInfo->rItems[GcIndex].status ));
                                continue;
                            }

                            //
                            // Count the number of GCs in each site.
                            //
                            for (SiteIndex1 = 0; SiteIndex1 < SiteCount; SiteIndex1++) {

                                if ( GcSiteName != NULL &&
                                     _wcsicmp( GcSiteName,
                                               SiteConnect->ppSiteDNs[SiteIndex1] ) == 0 ) {

                                    DcsInSite[SiteIndex1] ++;
                                    AtleastOneDc = TRUE;
                                    break;
                                }
                            }

                            //
                            // If this DC isn't in any known site,
                            //  simply ignore it.
                            //

                            if ( SiteIndex1 >= SiteCount ) {
                                NlPrint(( NL_CRITICAL,
                                          "GC: %ws %ws: isn't a site returned from ISM. (ignored)\n",
                                          GcSiteName,
                                          GcDnsHostName ));
                            }

                        }
                    }
                }

            //
            // Handle building the DC coverage list
            //
            } else if ( DomFlags & DOM_REAL_DOMAIN ) {
                ULONG DcIndex;

                //
                // Get the list of DCs in the domain and their sites
                //

                NetStatus = (*NlGlobalpDsGetDomainControllerInfoW)(
                                                        DsHandle,
                                                        DnsDomainName,
                                                        1,
                                                        &DcInfoCount,
                                                        &DcInfo );

                if ( NetStatus != NO_ERROR ) {
                    NlPrint(( NL_CRITICAL,
                              "NlSitesUpdateSiteCoverage: Cannot DsGetDomainControllerInfoW %ld.\n",
                              NetStatus ));
                    DcInfoCount = 0;
                }


                //
                // Determine which sites are already covered by DCs.
                //
                for ( DcIndex=0; DcIndex<DcInfoCount; DcIndex++ ) {
                    NlPrint(( NL_SITE,
                              "DC list: %ws %ws\n",
                              DcInfo[DcIndex].SiteName,
                              DcInfo[DcIndex].DnsHostName ));

                    //
                    // Count the number of DCs in each site.
                    //
                    for (SiteIndex1 = 0; SiteIndex1 < SiteCount; SiteIndex1++) {

                        if ( DcInfo[DcIndex].SiteName != NULL &&
                             _wcsicmp( DcInfo[DcIndex].SiteName,
                                       SiteConnect->ppSiteDNs[SiteIndex1] ) == 0 ) {

                            DcsInSite[SiteIndex1] ++;
                            AtleastOneDc = TRUE;
                            break;
                        }
                    }

                    //
                    // If this DC isn't in any known site,
                    //  simply ignore it.
                    //

                    if ( SiteIndex1 >= SiteCount ) {
                        NlPrint(( NL_CRITICAL,
                                  "DC: %ws %ws: isn't a site returned from ISM. (ignored)\n",
                                  DcInfo[DcIndex].SiteName,
                                  DcInfo[DcIndex].DnsHostName ));
                    }

                }

            //
            // Handle building the NDNC coverage list
            //
            } else if ( DomFlags & DOM_NON_DOMAIN_NC ) {
                SERVERSITEPAIR *ServerSitePairEntry;

                NetStatus = NlDsGetServersAndSitesForNetLogon( DnsDomainName,
                                                             &ServerSitePairs );
                //
                // Determine which sites are already covered by LDAP servers
                //
                if ( NetStatus == NO_ERROR ) {
                    ServerSitePairEntry = ServerSitePairs;
                    while ( ServerSitePairEntry != NULL &&
                            ServerSitePairEntry->wszDnsServer != NULL ) {

                        NlPrint(( NL_SITE,
                                  "NDNC list: %ws %ws\n",
                                  ServerSitePairEntry->wszSite,
                                  ServerSitePairEntry->wszDnsServer ));

                        //
                        // Count the number of LDAP servers in each site.
                        //
                        for (SiteIndex1 = 0; SiteIndex1 < SiteCount; SiteIndex1++) {

                            if ( ServerSitePairEntry->wszSite != NULL &&
                                 _wcsicmp( ServerSitePairEntry->wszSite,
                                           SiteConnect->ppSiteDNs[SiteIndex1] ) == 0 ) {

                                DcsInSite[SiteIndex1] ++;
                                AtleastOneDc = TRUE;
                                break;
                            }
                        }

                        //
                        // If this LDAP server isn't in any known site,
                        //  simply ignore it.
                        //
                        if ( SiteIndex1 >= SiteCount ) {
                            NlPrint(( NL_CRITICAL,
                                      "NDNC: %ws %ws: isn't a site returned from ISM. (ignored)\n",
                                      ServerSitePairEntry->wszSite,
                                      ServerSitePairEntry->wszDnsServer ));
                        }

                        ServerSitePairEntry ++;
                    }
                }
            }
        }
    }

    //
    // If we were able to build the DcsInSite array,
    //  Compute the auto site coverage.
    //

    if ( AtleastOneDc ) {

        //
        // For each site that has no DCs ...
        //

        for (SiteIndex1 = 0; SiteIndex1 < SiteCount; SiteIndex1++) {
            DWORD BestSite;

            if ( DcsInSite[SiteIndex1] != 0 ) {
                continue;
            }

            //
            // Skip this site if it's not valid for DNS registrations
            //

            if ( !NlValidateSiteName(SiteConnect->ppSiteDNs[SiteIndex1]) ) {
                continue;
            }

            NlPrint(( NL_SITE_MORE,
                      "%s: %ws: Site has no %ss\n",
                      GcOrDcOrNdnc,
                      SiteConnect->ppSiteDNs[SiteIndex1],
                      GcOrDcOrNdnc ));

            //
            // Pick the site that should cover that site
            //

            BestSite = 0xFFFFFFFF;
            for (SiteIndex2 = 0; SiteIndex2 < SiteCount; SiteIndex2++) {
                PISM_LINK Link2 = &(SiteConnect->pLinkValues[SiteIndex1 * SiteCount + SiteIndex2]);

                //
                // A site cannot auto cover itself.
                //

                if ( SiteIndex1 == SiteIndex2 ) {
#ifdef notdef
                    NlPrint(( NL_SITE_MORE,
                              "%s: %ws: Site ignoring itself.\n",
                              GcOrDcOrNdnc,
                              SiteConnect->ppSiteDNs[SiteIndex1] ));
#endif // notdef
                //
                // An invalid site is not eligible
                //

                } else if ( !NlValidateSiteName(SiteConnect->ppSiteDNs[SiteIndex2]) ) {
                    NlPrint(( NL_SITE_MORE,
                              "%s: %ws: Site '%ws' is invalid.\n",
                              GcOrDcOrNdnc,
                              SiteConnect->ppSiteDNs[SiteIndex1],
                              SiteConnect->ppSiteDNs[SiteIndex2] ));

                //
                // A site with an infinite cost cannot be reached.
                //  so don't consider it.
                //

                } else if ( Link2->ulCost == 0xFFFFFFFF ) {
                    NlPrint(( NL_SITE_MORE,
                              "%s: %ws: Site '%ws' has infinite cost.\n",
                              GcOrDcOrNdnc,
                              SiteConnect->ppSiteDNs[SiteIndex1],
                              SiteConnect->ppSiteDNs[SiteIndex2] ));

                //
                // A site with no DCs cannot cover any site
                //  so don't consider it.
                //

                } else if ( DcsInSite[SiteIndex2] == 0 ) {
                    NlPrint(( NL_SITE_MORE,
                              "%s: %ws: Site '%ws' has no Dcs.\n",
                              GcOrDcOrNdnc,
                              SiteConnect->ppSiteDNs[SiteIndex1],
                              SiteConnect->ppSiteDNs[SiteIndex2] ));

                //
                // If no best site has yet been picked,
                //  use this one.
                //

                } else if ( BestSite == 0xFFFFFFFF ) {
                    NlPrint(( NL_SITE_MORE,
                              "%s: %ws: Site '%ws' is the first valid site.\n",
                              GcOrDcOrNdnc,
                              SiteConnect->ppSiteDNs[SiteIndex1],
                              SiteConnect->ppSiteDNs[SiteIndex2] ));
                    BestSite = SiteIndex2;


                } else {
                    PISM_LINK LinkBest = &(SiteConnect->pLinkValues[SiteIndex1 * SiteCount + BestSite]);

                    //
                    // If the SiteLink cost is less than the current best,
                    //  use it.
                    //

                    if ( Link2->ulCost < LinkBest->ulCost ) {
                        NlPrint(( NL_SITE_MORE,
                                  "%s: %ws: '%ws' has cheaper link costs than '%ws'\n",
                                  GcOrDcOrNdnc,
                                  SiteConnect->ppSiteDNs[SiteIndex1],
                                  SiteConnect->ppSiteDNs[SiteIndex2],
                                  SiteConnect->ppSiteDNs[BestSite] ));
                        BestSite = SiteIndex2;

                    //
                    // If the SiteLink cose is equal ...
                    //
                    } else if ( Link2->ulCost == LinkBest->ulCost ) {

                        //
                        // ... then pick the site with the greater number of DCs
                        //

                        if ( DcsInSite[SiteIndex2] > DcsInSite[BestSite] ) {
                            NlPrint(( NL_SITE_MORE,
                                      "%s: %ws: '%ws' has more DCs than '%ws'\n",
                                      GcOrDcOrNdnc,
                                      SiteConnect->ppSiteDNs[SiteIndex1],
                                      SiteConnect->ppSiteDNs[SiteIndex2],
                                      SiteConnect->ppSiteDNs[BestSite] ));
                            BestSite = SiteIndex2;

                        //
                        // If the number of DCs is equal ...
                        //

                        } else if ( DcsInSite[SiteIndex2] == DcsInSite[BestSite] ) {

                            //
                            // Break the tie by using the site with the alphabetically
                            //  least name.
                            //

                            if (  _wcsicmp( SiteConnect->ppSiteDNs[SiteIndex2],
                                            SiteConnect->ppSiteDNs[BestSite] ) < 0 ) {

                                NlPrint(( NL_SITE_MORE,
                                          "%s: %ws: '%ws' is alphabetically before '%ws'\n",
                                          GcOrDcOrNdnc,
                                          SiteConnect->ppSiteDNs[SiteIndex1],
                                          SiteConnect->ppSiteDNs[SiteIndex2],
                                          SiteConnect->ppSiteDNs[BestSite] ));
                                BestSite = SiteIndex2;
                            }

                        }
                    }
                }

            }

            //
            // If the best site is the site this DC is in,
            //  then mark this site as covered.
            //

            if ( BestSite == ThisSiteIndex ) {
                NlPrint(( NL_SITE,
                          "%s: %ws: Site is auto covered by our site.\n",
                          GcOrDcOrNdnc,
                          SiteConnect->ppSiteDNs[SiteIndex1] ));

                NlSitesAddCloseSite( SiteConnect->ppSiteDNs[SiteIndex1],
                                     CoveredSites,
                                     &CoveredSitesCount,
                                     TRUE );  // auto covered

            } else {

                //
                // Note if no site was found
                //

                if ( BestSite == 0xFFFFFFFF ) {
                    NlPrint(( NL_SITE,
                              "%s: %ws: Site is not auto covered by any site.\n",
                              GcOrDcOrNdnc,
                              SiteConnect->ppSiteDNs[SiteIndex1] ));

                } else {
                    NlPrint(( NL_SITE,
                              "%s: %ws: Site is auto covered by site '%ws'.\n",
                              GcOrDcOrNdnc,
                              SiteConnect->ppSiteDNs[SiteIndex1],
                              SiteConnect->ppSiteDNs[BestSite] ));
                }
            }

        }
    }

    //
    // Now that all of the information has been collected.
    //  Update the in memory information with the CritSect locked.
    //

    EnterCriticalSection( &NlGlobalSiteCritSect );

    //
    // Merge in the list of covered sites from the registry
    //

    if ( SiteCoverageParameter != NULL ) {
        LPTSTR_ARRAY TStrArray;
        LPWSTR BackSlash = NULL;
        BOOLEAN SkipThisEntry;

        TStrArray = SiteCoverageParameter;
        while (!NetpIsTStrArrayEmpty(TStrArray)) {
            SkipThisEntry = FALSE;
            BackSlash = wcsstr(TStrArray, L"\\");

            //
            // If backslash is present, then the covered site is specified
            // for a given domain/forest/NDNC. The domain/forest/NDNC name
            // precedes the backslash while the site name follows after the
            // backslash. If backslash is absent, the site is covered for
            // all domains/forests/NDNCs.
            //
            if ( BackSlash != NULL ) {
                *BackSlash = UNICODE_NULL;

                //
                // Check the appropriate name depending on whether this is
                // a forest or a domain or an NDNC
                //
                if ( DomFlags & DOM_FOREST ) {
                    if ( !NlEqualDnsName(TStrArray, CapturedDnsForestName) ) {
                        SkipThisEntry = TRUE;
                    }
                } else if ( DomFlags & DOM_REAL_DOMAIN ) {
                    if ( !NlEqualDnsName(TStrArray, DnsDomainName) &&
                         NlNameCompare(TStrArray, DomainInfo->DomUnicodeDomainName, NAMETYPE_DOMAIN) != 0 ) {
                        SkipThisEntry = TRUE;
                    }
                } else if ( DomFlags & DOM_NON_DOMAIN_NC ) {
                    if ( !NlEqualDnsName(TStrArray, DnsDomainName) ) {
                        SkipThisEntry = TRUE;
                    }
                }
            }

            //
            // Add this site to the current list of covered sites
            //

            if ( !SkipThisEntry ) {
                if ( BackSlash != NULL ) {
                    if ( *(BackSlash+1) != UNICODE_NULL ) {
                        NlPrint(( NL_SITE,
                                  "%s: %ws: Site is covered by our site (regkey).\n",
                                  GcOrDcOrNdnc,
                                  BackSlash+1 ));

                        NlSitesAddCloseSite( BackSlash+1, CoveredSites, &CoveredSitesCount, FALSE );
                    }
                } else {
                    NlPrint(( NL_SITE,
                              "%s: %ws: Site is covered by our site (regkey).\n",
                              GcOrDcOrNdnc,
                              TStrArray ));

                    NlSitesAddCloseSite( TStrArray, CoveredSites, &CoveredSitesCount, FALSE );
                }
            }

            if ( BackSlash != NULL ) {
                *BackSlash = L'\\';
            }
            TStrArray = NetpNextTStrArrayEntry(TStrArray);
        }
    }

    //
    // The site this DC is in is covered by definition
    //

    NlSitesAddCloseSite( ThisSiteName, CoveredSites, &CoveredSitesCount, FALSE );


    //
    // Determine if the site coverages changes.
    // Log info if auto site coverage changes.
    //

    if ( (DomFlags & DOM_FOREST) != 0 ) {
        OldCoveredSites = DomainInfo->GcCoveredSites;
        OldCoveredSitesCount = DomainInfo->GcCoveredSitesCount;
    } else if ( (DomFlags & DOM_REAL_DOMAIN) != 0 ||
                (DomFlags & DOM_NON_DOMAIN_NC) != 0 ) {
        OldCoveredSites = DomainInfo->CoveredSites;
        OldCoveredSitesCount = DomainInfo->CoveredSitesCount;
    }

    //
    // Determine if new sites get covered and log events for newly auto
    // covered sites
    //

    for ( CoveredSitesIndex = 0; CoveredSitesIndex < CoveredSitesCount; CoveredSitesIndex++ ) {
        DWORD EventId = 0;
        LPWSTR MsgStrings[3];
        MsgStrings[0] = ThisSiteName;
        MsgStrings[1] = CoveredSites[CoveredSitesIndex].CoveredSite->SiteName;

        //
        // Determine if we didn't cover this site in the past
        //
        for ( OldCoveredSitesIndex = 0; OldCoveredSitesIndex < OldCoveredSitesCount; OldCoveredSitesIndex++ ) {
            if ( RtlEqualUnicodeString( &CoveredSites[CoveredSitesIndex].CoveredSite->SiteNameString,
                                        &OldCoveredSites[OldCoveredSitesIndex].CoveredSite->SiteNameString,
                                        TRUE ) ) {
                break;
            }
        }

        //
        // Indicate if this is a new covered site
        //
        if ( OldCoveredSitesIndex == OldCoveredSitesCount ) {
            LocalSiteCoverageChanged = TRUE;

            //
            // If the new site is auto covered, log the event
            //
            if ( CoveredSites[CoveredSitesIndex].CoveredAuto ) {

                //
                // Log for GC that this is a newly auto covered site
                //
                if ( DomFlags & DOM_FOREST ) {
                    EventId = NELOG_NetlogonGcSiteCovered;
                    MsgStrings[2] = CapturedDnsForestName;
                //
                // Log for DC that this is a newly auto covered site
                //
                } else if ( DomFlags & DOM_REAL_DOMAIN ) {
                    EventId = NELOG_NetlogonDcSiteCovered;
                    MsgStrings[2] = DomainInfo->DomUnicodeDomainName;
                //
                // Log for NDNC that this is a newly auto covered site
                //
                } else if ( DomFlags & DOM_NON_DOMAIN_NC ) {
                    EventId = NELOG_NetlogonNdncSiteCovered;
                    MsgStrings[2] = DnsDomainName;
                }
            }

        //
        // If we had this site not auto covered in the past and it is
        // auto covered now, log the event
        //
        } else if ( CoveredSites[CoveredSitesIndex].CoveredAuto &&
                    !OldCoveredSites[OldCoveredSitesIndex].CoveredAuto ) {

            //
            // Log for GC that this old manually covered site is now auto covered
            //
            if ( DomFlags & DOM_FOREST ) {
                EventId = NELOG_NetlogonGcOldSiteCovered;
                MsgStrings[2] = CapturedDnsForestName;
            //
            // Log for DC that this old manually covered site is now auto covered
            //
            } else if ( DomFlags & DOM_REAL_DOMAIN ) {
                EventId = NELOG_NetlogonDcOldSiteCovered;
                MsgStrings[2] = DomainInfo->DomUnicodeDomainName;
            //
            // Log for NDNC that this old manually covered site is now auto covered
            //
            } else if ( DomFlags & DOM_NON_DOMAIN_NC ) {
                EventId = NELOG_NetlogonNdncOldSiteCovered;
                MsgStrings[2] = DnsDomainName;
            }
        }

        //
        // Log the event if needed
        //
        if ( EventId != 0 ) {
            NlpWriteEventlog ( EventId,
                               EVENTLOG_INFORMATION_TYPE,
                               NULL,
                               0,
                               MsgStrings,
                               3 | NETP_ALLOW_DUPLICATE_EVENTS );
        }
    }

    //
    // Determine if old sites are nolonger covered and log events for old auto
    // covered sites which are nolonger auto covered
    //

    for ( OldCoveredSitesIndex = 0; OldCoveredSitesIndex < OldCoveredSitesCount; OldCoveredSitesIndex++ ) {
        DWORD EventId = 0;
        LPWSTR MsgStrings[2];
        MsgStrings[0] = OldCoveredSites[OldCoveredSitesIndex].CoveredSite->SiteName;

        //
        // Determine if we no longer cover this site
        //
        for ( CoveredSitesIndex = 0; CoveredSitesIndex < CoveredSitesCount; CoveredSitesIndex++ ) {
            if ( RtlEqualUnicodeString( &OldCoveredSites[OldCoveredSitesIndex].CoveredSite->SiteNameString,
                                        &CoveredSites[CoveredSitesIndex].CoveredSite->SiteNameString,
                                        TRUE ) ) {
                break;
            }
        }

        //
        // Indicate if this site is no longer covered
        //
        if ( CoveredSitesIndex == CoveredSitesCount ) {
            LocalSiteCoverageChanged = TRUE;

            //
            // If the old site was auto covered, log the event
            //
            if ( OldCoveredSites[OldCoveredSitesIndex].CoveredAuto ) {

                //
                // Log for GC that this old auto covered site is no longer auto covered
                //
                if ( DomFlags & DOM_FOREST ) {
                    EventId = NELOG_NetlogonGcSiteNotCovered;
                    MsgStrings[1] = CapturedDnsForestName;
                //
                // Log for DC that this old auto covered site is no longer auto covered
                //
                } else if ( DomFlags & DOM_REAL_DOMAIN ) {
                    EventId = NELOG_NetlogonDcSiteNotCovered;
                    MsgStrings[1] = DomainInfo->DomUnicodeDomainName;
                //
                // Log for NDNC that this old auto covered site is no longer auto covered
                //
                } else if ( DomFlags & DOM_NON_DOMAIN_NC ) {
                    EventId = NELOG_NetlogonNdncSiteNotCovered;
                    MsgStrings[1] = DnsDomainName;
                }
            }

        //
        // If we had this site auto covered in the past and it is
        // no longer auto covered, log the event
        //
        } else if ( OldCoveredSites[OldCoveredSitesIndex].CoveredAuto &&
                    !CoveredSites[CoveredSitesIndex].CoveredAuto ) {

            //
            // Log for GC that this old auto covered site is now manually covered
            //
            if ( DomFlags & DOM_FOREST ) {
                EventId = NELOG_NetlogonGcSiteNotCoveredAuto;
                MsgStrings[1] = CapturedDnsForestName;
            //
            // Log for DC that this old auto covered site is now manually covered
            //
            } else if ( DomFlags & DOM_REAL_DOMAIN ) {
                EventId = NELOG_NetlogonDcSiteNotCoveredAuto;
                MsgStrings[1] = DomainInfo->DomUnicodeDomainName;
            //
            // Log for NDNC that this old auto covered site is now manually covered
            //
            } else if ( DomFlags & DOM_NON_DOMAIN_NC ) {
                EventId = NELOG_NetlogonNdncSiteNotCoveredAuto;
                MsgStrings[1] = DnsDomainName;
            }
        }

        //
        // Log the event if needed
        //
        if ( EventId != 0 ) {
            NlPrint(( NL_SITE,
                      "%s: %ws: Site is no longer auto covered by our site.\n",
                      GcOrDcOrNdnc,
                      OldCoveredSites[OldCoveredSitesIndex].CoveredSite->SiteName ));

            NlpWriteEventlog ( EventId,
                               EVENTLOG_INFORMATION_TYPE,
                               NULL,
                               0,
                               MsgStrings,
                               2 | NETP_ALLOW_DUPLICATE_EVENTS );
        }
    }

    //
    // Dereference the old entries.
    //

    for ( OldCoveredSitesIndex = 0; OldCoveredSitesIndex < OldCoveredSitesCount; OldCoveredSitesIndex++ ) {
        NlDerefSiteEntry( OldCoveredSites[OldCoveredSitesIndex].CoveredSite );
    }

    //
    // Finally update the site coverage list.
    // Free the old list and allocate the new one.
    //

    if ( DomFlags & DOM_FOREST ) {

        if ( DomainInfo->GcCoveredSites != NULL ) {
            LocalFree( DomainInfo->GcCoveredSites );
            DomainInfo->GcCoveredSites = NULL;
            DomainInfo->GcCoveredSitesCount = 0;
        }

        if ( CoveredSitesCount != 0 ) {
            DomainInfo->GcCoveredSites = LocalAlloc( 0, CoveredSitesCount * sizeof(NL_COVERED_SITE  ) );
            if ( DomainInfo->GcCoveredSites != NULL ) {
                RtlCopyMemory( DomainInfo->GcCoveredSites,
                               CoveredSites,
                               CoveredSitesCount * sizeof(NL_COVERED_SITE) );
                DomainInfo->GcCoveredSitesCount = CoveredSitesCount;
            } else {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Reference the newly added entries, if any
        //
        for ( CoveredSitesIndex = 0; CoveredSitesIndex < DomainInfo->GcCoveredSitesCount; CoveredSitesIndex++ ) {
            NlRefSiteEntry( (DomainInfo->GcCoveredSites)[CoveredSitesIndex].CoveredSite );
        }

    } else if ( (DomFlags & DOM_REAL_DOMAIN) != 0 ||
                (DomFlags & DOM_NON_DOMAIN_NC) != 0 ) {

        if ( DomainInfo->CoveredSites != NULL ) {
            LocalFree( DomainInfo->CoveredSites );
            DomainInfo->CoveredSites = NULL;
            DomainInfo->CoveredSitesCount = 0;
        }

        if ( CoveredSitesCount != 0 ) {
            DomainInfo->CoveredSites = LocalAlloc( 0, CoveredSitesCount * sizeof(NL_COVERED_SITE) );
            if ( DomainInfo->CoveredSites != NULL ) {
                RtlCopyMemory( DomainInfo->CoveredSites,
                               CoveredSites,
                               CoveredSitesCount * sizeof(NL_COVERED_SITE) );
                DomainInfo->CoveredSitesCount = CoveredSitesCount;
            } else {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Reference the newly added entries, if any
        //
        for ( CoveredSitesIndex = 0; CoveredSitesIndex < DomainInfo->CoveredSitesCount; CoveredSitesIndex++ ) {
            NlRefSiteEntry( (DomainInfo->CoveredSites)[CoveredSitesIndex].CoveredSite );
        }
    }

    //
    // Now that the datebase is consistent, drop the lock for the next pass
    //

    LeaveCriticalSection( &NlGlobalSiteCritSect );

Cleanup:

    if ( DcsInSite != NULL ) {
        LocalFree( DcsInSite );
    }

    if ( DcInfo != NULL ) {
        (*NlGlobalpDsFreeDomainControllerInfoW)( 1, DcInfoCount, DcInfo );
    }

    if ( GcInfo != NULL ) {
        DsFreeNameResultW( GcInfo );
    }

    if ( ServerSitePairs != NULL ) {
        NlDsFreeServersAndSitesForNetLogon( ServerSitePairs );
    }

    //
    // Free the temprory list of covered sites.
    // Deref each temp entry.
    //

    if ( CoveredSites != NULL ) {
        for ( CoveredSitesIndex = 0; CoveredSitesIndex < CoveredSitesCount; CoveredSitesIndex++ ) {
            NlDerefSiteEntry( CoveredSites[CoveredSitesIndex].CoveredSite );
        }
        LocalFree( CoveredSites );
    }

    //
    // Update the site coverage change info only if it indeed changed
    //
    if ( NetStatus == NO_ERROR && SiteCoverageChanged != NULL && LocalSiteCoverageChanged ) {
        *SiteCoverageChanged = TRUE;
    }

    return NO_ERROR;

}

PNL_SITE_ENTRY
NlFindSiteEntry(
    IN LPWSTR SiteName
    )
/*++

Routine Description:

    This routine finds a site entry for a particular site name.  If one
    does not exist, one is created.

Arguments:

    SiteName - Name of the site.

Return Value:

    Pointer to the Site entry for the site.

    NULL: Memory could not be allocated.

--*/
{
    PLIST_ENTRY ListEntry;
    ULONG SiteNameSize;
    PNL_SITE_ENTRY SiteEntry;
    UNICODE_STRING SiteNameString;

    //
    // If the site entry already exists,
    //  return a pointer to it.
    //

    RtlInitUnicodeString( &SiteNameString, SiteName );
    EnterCriticalSection( &NlGlobalSiteCritSect );
    for ( ListEntry = NlGlobalSiteList.Flink ;
          ListEntry != &NlGlobalSiteList;
          ListEntry = ListEntry->Flink) {

        SiteEntry =
            CONTAINING_RECORD( ListEntry, NL_SITE_ENTRY, Next );

        if ( RtlEqualUnicodeString( &SiteEntry->SiteNameString,
                                    &SiteNameString,
                                    TRUE ) ) {

            NlRefSiteEntry( SiteEntry );
            LeaveCriticalSection( &NlGlobalSiteCritSect );
            return SiteEntry;
        }

    }


    //
    // If not,
    //  allocate one.
    //


    SiteNameSize = SiteNameString.Length + sizeof(WCHAR);
    SiteEntry = LocalAlloc( 0, sizeof(NL_SITE_ENTRY) + SiteNameSize );
    if ( SiteEntry == NULL ) {
        LeaveCriticalSection( &NlGlobalSiteCritSect );
        return NULL;
    }

    //
    // Fill it in.
    //

    // Being in global list is not a reference.
    SiteEntry->ReferenceCount = 1;

    SiteEntry->SiteNameString.Length = SiteNameString.Length;
    SiteEntry->SiteNameString.MaximumLength = SiteNameString.Length + sizeof(WCHAR);
    SiteEntry->SiteNameString.Buffer = SiteEntry->SiteName;

    RtlCopyMemory( &SiteEntry->SiteName, SiteName, SiteNameSize );
    InsertHeadList( &NlGlobalSiteList, &SiteEntry->Next );
    LeaveCriticalSection( &NlGlobalSiteCritSect );

    return SiteEntry;
}

VOID
NlSitesRefSubnet(
    IN PNL_SUBNET Subnet
    )
/*++

Routine Description:

    Reference a subnet

    NlGlobalSiteCritSect must be locked.

Arguments:

    Subnet - Entry to be Referenced.

Return Value:

    None.

--*/
{
    Subnet->ReferenceCount++;
}

PNL_SUBNET
NlFindSubnetEntry(
    IN LPWSTR SiteName,
    IN ULONG SubnetAddress,
    IN ULONG SubnetMask,
    IN BYTE SubnetBitCount
    )
/*++

Routine Description:

    This routine finds a subnet entry for a particular subnet name.  If one
    does not exist, one is created.

Arguments:

    SiteName - Name of the site the subnet covers.

    SubnetAddress - Subnet Address for the subnet to find.

    SubnetMask - Subnet mask for the subnet to find.

    SubnetBitCount - Subnet bit count for the subnet to find.

Return Value:

    Pointer to the Subnet entry for the site.
        Entry should be dereferenced using NlSitesDerefSubnet

    NULL: Memory could not be allocated.

--*/
{
    PLIST_ENTRY ListEntry;
    ULONG SiteNameSize;
    PNL_SUBNET Subnet;

    //
    // If the subnet entry already exists,
    //  return a pointer to it.
    //

    EnterCriticalSection( &NlGlobalSiteCritSect );
    for ( ListEntry = NlGlobalSubnetList.Flink ;
          ListEntry != &NlGlobalSubnetList;
          ListEntry = ListEntry->Flink) {

        Subnet =
            CONTAINING_RECORD( ListEntry, NL_SUBNET, Next );

        if ( Subnet->SubnetAddress == SubnetAddress &&
             Subnet->SubnetBitCount == SubnetBitCount &&
             Subnet->SubnetMask == SubnetMask &&
             _wcsicmp( Subnet->SiteEntry->SiteName, SiteName ) == 0 ) {

#if NETLOGONDBG
            {
                CHAR IpAddress[NL_IP_ADDRESS_LENGTH+1];
                NetpIpAddressToStr( Subnet->SubnetAddress, IpAddress );
                NlPrint(( NL_SITE, "%s/%ld: Re-adding Subnet for site '%ws'\n", IpAddress, Subnet->SubnetBitCount, SiteName ));
            }
#endif // NETLOGONDBG

            NlSitesRefSubnet( Subnet );
            LeaveCriticalSection( &NlGlobalSiteCritSect );
            return Subnet;
        }

    }

    //
    // If not,
    //  allocate one.
    //


    Subnet = LocalAlloc( 0, sizeof(NL_SUBNET) );
    if ( Subnet == NULL ) {
        LeaveCriticalSection( &NlGlobalSiteCritSect );
        return NULL;
    }

    //
    // Fill it in.
    //

    // Being in global list is not a reference.
    Subnet->ReferenceCount = 1;

    Subnet->SubnetAddress = SubnetAddress;
    Subnet->SubnetMask = SubnetMask;
    Subnet->SubnetBitCount = SubnetBitCount;

    Subnet->SiteEntry = NlFindSiteEntry( SiteName );

    if ( Subnet->SiteEntry == NULL ) {
        LocalFree( Subnet );
        LeaveCriticalSection( &NlGlobalSiteCritSect );
        return NULL;
    }

#if NETLOGONDBG
    {
        CHAR IpAddress[NL_IP_ADDRESS_LENGTH+1];
        NetpIpAddressToStr( Subnet->SubnetAddress, IpAddress );
        NlPrint(( NL_SITE, "%s/%ld: Adding Subnet for site '%ws'\n",
                  IpAddress,
                  Subnet->SubnetBitCount,
                  SiteName ));
    }
#endif // NETLOGONDBG


    InsertHeadList( &NlGlobalSubnetList, &Subnet->Next );
    LeaveCriticalSection( &NlGlobalSiteCritSect );

    return Subnet;
}

VOID
NlSitesDerefSubnet(
    IN PNL_SUBNET Subnet
    )
/*++

Routine Description:

    Dereference a subnet

    If the reference count goes to zero,
        the subnet entry will be deleted.

Arguments:

    Subnet - Entry to be dereferenced.

Return Value:

    None.

--*/
{
    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( (--(Subnet->ReferenceCount)) == 0 ) {
#if  NETLOGONDBG
            CHAR IpAddress[NL_IP_ADDRESS_LENGTH+1];
            NetpIpAddressToStr( Subnet->SubnetAddress, IpAddress );
            NlPrint(( NL_SITE, "%s/%ld: Subnet deleted\n", IpAddress, Subnet->SubnetBitCount ));
#endif // NETLOGONDBG

        //
        // If there is a site associated with this subnet,
        //  dereference it.
        //
        if ( Subnet->SiteEntry != NULL ) {
            NlDerefSiteEntry( Subnet->SiteEntry );
        }

        //
        // Remove the subnet from the global list
        //
        RemoveEntryList( &Subnet->Next );

        //
        // Free the Subnet entry itself.
        //
        LocalFree( Subnet );
    }
    LeaveCriticalSection( &NlGlobalSiteCritSect );
}

VOID
NlSiteDeleteSubnetTree(
    IN PNL_SUBNET_TREE_ENTRY SubnetTreeEntry
    )
/*++

Routine Description:

    Delete everything pointed to by this SubnetTreeEntry

    Enter with NlGlobalSiteCritSect locked.

Arguments:

    SubnetTreeEntry - SubnetTreeEntry to de-initialize

Return Value:

    TRUE: SubnetTreeEntry is now empty

    FALSE: SubnetTreeEntry still has entries.

--*/
{

    //
    // If there are children,
    //  delete them.
    //

    if ( SubnetTreeEntry->Subtree != NULL ) {
        ULONG i;

        for ( i=0; i<256; i++ ) {
            NlSiteDeleteSubnetTree( &SubnetTreeEntry->Subtree->Subtree[i] );
        }

        NlPrint(( NL_SITE_MORE, "Deleting subtree\n" ));
        LocalFree( SubnetTreeEntry->Subtree );
        SubnetTreeEntry->Subtree = NULL;
    }

    //
    // If there is a subnet,
    //  dereference it.
    //

    if ( SubnetTreeEntry->Subnet != NULL ) {
        // NlPrint(( NL_SITE_MORE, "Derefing subnet upon tree deletion\n" ));
        NlSitesDerefSubnet( SubnetTreeEntry->Subnet );
        SubnetTreeEntry->Subnet = NULL;
    }

    return;
}


VOID
NlSitesEndSubnetEnum(
    VOID
    )
/*++

Routine Description:

    This routine is called at the end of a set of NlSitesAddSubnet calls.
    The sequence is:

        loop for each subnet
            NlSitesAddSubnet
        NlSitesEndSubnetEnum

    NlSiteAddSubnet adds the entries to a temporary tree.  This routine
    swaps the temporary tree into the permanent location.  This mechanism
    does the following:

    a) Allows the old subnet tree to be used while the new tree is being built.
    b) Allows me to not permanently grab the SiteCritSect for the entire
        enumeration of subnet/site objects from the DS.
    c) Reuse the in-memory subnet/site structures in the old and new tree.  This
        avoids re-allocation of these structures (or worse temporarily doubling
        of memory usage).

Arguments:

    SiteName - Name of the site the subnet is in.

    SubnetName - subnet to be added

Return Value:

    NO_ERROR: success

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory for the subnet structure.


--*/
{

    //
    // Free all old entries in NlGlobalSubnetTree.
    //
    NlPrint(( NL_SITE_MORE, "NlSitesEndSubnetEnum: Entered\n" ));
    EnterCriticalSection( &NlGlobalSiteCritSect );
    NlSiteDeleteSubnetTree( &NlGlobalSubnetTree );

    //
    // Make the "new" subnet tree the real subnet tree.
    //

    NlGlobalSubnetTree = NlGlobalNewSubnetTree;
    RtlZeroMemory( &NlGlobalNewSubnetTree, sizeof(NlGlobalNewSubnetTree) );

    LeaveCriticalSection( &NlGlobalSiteCritSect );
    NlPrint(( NL_SITE_MORE, "NlSitesEndSubnetEnum: Exitted\n" ));
}


NET_API_STATUS
NlSitesAddSubnet(
    IN LPWSTR SiteName,
    IN LPWSTR SubnetName
    )
/*++

Routine Description:

    This routine adds a subnet to the tree of subnets.

Arguments:

    SiteName - Name of the site the subnet is in.

    SubnetName - subnet to be added

Return Value:

    NO_ERROR: success

    ERROR_INVALID_NAME: Subnet Name is not valid

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory for the subnet structure.


--*/
{
    NET_API_STATUS NetStatus;
    PNL_SUBNET Subnet = NULL;
    PNL_SUBNET_TREE_ENTRY SubnetTreeEntry;
    LPBYTE SubnetBytePointer;
    ULONG i;
    ULONG SubnetAddress;
    ULONG SubnetMask;
    BYTE SubnetBitCount;

    //
    // Parse the subnet name
    //

    EnterCriticalSection( &NlGlobalSiteCritSect );

    NetStatus = NlParseSubnetString( SubnetName,
                                     &SubnetAddress,
                                     &SubnetMask,
                                     &SubnetBitCount );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Find or allocate an entry for the subnet
    //

    Subnet = NlFindSubnetEntry( SiteName,
                                SubnetAddress,
                                SubnetMask,
                                SubnetBitCount );

    if ( Subnet == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Loop for each byte in the subnet address
    //

    SubnetTreeEntry = &NlGlobalNewSubnetTree;
    SubnetBytePointer = (LPBYTE) (&Subnet->SubnetAddress);
    while ( SubnetBitCount != 0 ) {
        NlPrint(( NL_SITE_MORE, "%ld: Doing byte\n", *SubnetBytePointer ));

        //
        // If there isn't a tree branch for the current node,
        //  create one.
        //

        if ( SubnetTreeEntry->Subtree == NULL ) {
            NlPrint(( NL_SITE_MORE, "%ld: Creating subtree\n", *SubnetBytePointer ));
            SubnetTreeEntry->Subtree = LocalAlloc( LMEM_ZEROINIT, sizeof(NL_SUBNET_TREE) );

            if ( SubnetTreeEntry->Subtree == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

        //
        // If this is the last byte of the subnet address,
        //  link the subnet onto the tree here.
        //

        if ( SubnetBitCount <= 8 ) {
            ULONG LoopCount;


            //
            // The caller indexes into this array with an IP address.
            // Create a link to our subnet for each possible IP addresses
            // that map onto this subnet.
            //
            // Between 1 and 128 IP addresses map onto this subnet address.
            //

            LoopCount = 1 << (8-SubnetBitCount);

            for ( i=0; i<LoopCount; i++ ) {
                PNL_SUBNET_TREE_ENTRY Subtree;
                ULONG SubnetIndex;

                //
                // Compute which entry is to be updated.
                //
                SubnetIndex = (*SubnetBytePointer) + i;
                NlPrint(( NL_SITE_MORE, "%ld: Doing sub-byte\n", SubnetIndex ));
                NlAssert( SubnetIndex <= 255 );
                Subtree = &SubnetTreeEntry->Subtree->Subtree[SubnetIndex];


                //
                // If there already is a subnet linked off the tree here,
                //  handle it.
                //

                if ( Subtree->Subnet != NULL ) {
                    NlPrint(( NL_SITE_MORE, "%ld: Subnet already exists %ld\n",
                                SubnetIndex,
                                Subtree->Subnet->SubnetBitCount ));

                    //
                    //  If the entry is for a less specific subnet
                    //  delete the current entry.
                    //

                    if ( Subtree->Subnet->SubnetBitCount < Subnet->SubnetBitCount ) {

                        NlPrint(( NL_SITE_MORE, "%ld: Deref previous subnet\n",
                                    SubnetIndex ));
                        NlSitesDerefSubnet( Subtree->Subnet );
                        Subtree->Subnet = NULL;

                    //
                    // Otherwise,
                    //  use the current entry since it is better than this one.
                    //
                    } else {
                        NlPrint(( NL_SITE_MORE, "%ld: Use previous subnet\n",
                                    SubnetIndex ));
                        continue;
                    }
                }

                //
                // Link the subnet into the tree.
                //  Increment the reference count.
                //
                NlSitesRefSubnet( Subnet );
                Subtree->Subnet = Subnet;
            }

            break;

        }

        //
        // Move on to the next byte of the subnet address
        //

        SubnetTreeEntry = &SubnetTreeEntry->Subtree->Subtree[*SubnetBytePointer];
        SubnetBitCount -= 8;
        SubnetBytePointer ++;

    }

    NetStatus = NO_ERROR;

    //
    // Free locally used resources.
    //
Cleanup:
    if ( Subnet != NULL ) {
        NlSitesDerefSubnet( Subnet );
    }
    LeaveCriticalSection( &NlGlobalSiteCritSect );

    return NetStatus;

}

PNL_SITE_ENTRY
NlFindSiteEntryBySockAddrEx(
    IN PSOCKADDR SockAddr,
    OUT PNL_SUBNET *RetSubnet OPTIONAL
    )
/*++

Routine Description:

    This routine look up the specified socket address and translate it to a
    site name.

Arguments:

    SockAddr - Socket Address to lookup

    RetSubnet - If specified, returns a pointer to the subnet object used to do
        the mapping.
        Might return NULL indicating a subnet object wasn't used.
        Entry should be dereferenced using NlSitesDerefSubnet.


Return Value:

    NULL: No site can be found for this SockAddr.

    Non-NULL: Site corresponding to the SockAddr.
        Entry should be derefenced using NlDerefSiteEntry


--*/
{
    PNL_SITE_ENTRY SiteEntry = NULL;
    PNL_SUBNET Subnet = NULL;
    PNL_SUBNET_TREE_ENTRY SubnetTreeEntry;
    ULONG ByteIndex;
    ULONG IpAddress;

    //
    // Convert SockAddr to IP address.
    //

    if ( ARGUMENT_PRESENT(RetSubnet) ) {
        *RetSubnet = NULL;
    }

    if ( SockAddr->sa_family != AF_INET ) {
        return NULL;
    }

    IpAddress = ((PSOCKADDR_IN)SockAddr)->sin_addr.S_un.S_addr;

    //
    // If there are no subnet entries and only one site,
    //  then all clients belong to that site.
    //  Don't bother mapping.
    //

    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( NlGlobalOnlyOneSite ) {
        if ( NlGlobalSiteEntry == NULL ) {
            LeaveCriticalSection( &NlGlobalSiteCritSect );
            return NULL;
        }

        SiteEntry = NlGlobalSiteEntry;
        NlRefSiteEntry( SiteEntry );

        //
        // If the caller isn't interested in the subnet name,
        //  we are done
        //
        if ( RetSubnet == NULL ) {
            LeaveCriticalSection( &NlGlobalSiteCritSect );
            return SiteEntry;
        }
    }



    //
    // Loop for each byte in the Ip address
    //

    SubnetTreeEntry = &NlGlobalSubnetTree;
    for ( ByteIndex=0; ByteIndex<sizeof(IpAddress); ByteIndex++) {
        ULONG SubnetIndex;

        //
        // If there is no subtree,
        //  we're done.
        //
        SubnetIndex = ((LPBYTE)(&IpAddress))[ByteIndex];
        NlPrint(( NL_SITE_MORE, "%ld: Lookup: Doing byte\n", SubnetIndex ));

        if ( SubnetTreeEntry->Subtree == NULL ) {
            break;
        }


        //
        // Compute which entry is being referenced
        //
        SubnetTreeEntry = &SubnetTreeEntry->Subtree->Subtree[SubnetIndex];


        //
        // If there already is a subnet linked off here,
        //  use it.
        //
        // (but continue walking down the tree trying to find a more explicit entry.)
        //

        if ( SubnetTreeEntry->Subnet != NULL ) {
            NlPrint(( NL_SITE_MORE, "%ld: Lookup: saving subnet at this level\n", SubnetIndex ));
            Subnet = SubnetTreeEntry->Subnet;
        }

    }

    //
    // If we found a subnet,
    //  return the site associated with the subnet.

    if ( Subnet != NULL ) {

        //
        // If we already know the site name (because there is
        //  only one site), this subnet must map to it
        //
        if ( SiteEntry != NULL ) {
            NlAssert( SiteEntry == Subnet->SiteEntry );
        } else {
            SiteEntry = Subnet->SiteEntry;
            NlRefSiteEntry( SiteEntry );
        }

        if ( ARGUMENT_PRESENT(RetSubnet) ) {
            NlSitesRefSubnet( Subnet );
            *RetSubnet = Subnet;
        }
    }

    LeaveCriticalSection( &NlGlobalSiteCritSect );

    return SiteEntry;

}

PNL_SITE_ENTRY
NlFindSiteEntryBySockAddr(
    IN PSOCKADDR SockAddr
    )
/*++

Routine Description:

    This routine look up the specified socket address and translate it to a
    site name.

Arguments:

    SockAddr - Socket Address to lookup

    RetSubnet - If specified, returns a pointer to the subnet object used to do
        the mapping.
        Might return NULL indicating a subnet object wasn't used.
        Entry should be dereferenced using NlSitesDerefSubnet.


Return Value:

    NULL: No site can be found for this SockAddr.

    Non-NULL: Site corresponding to the SockAddr.
        Entry should be derefenced using NlDerefSiteEntry


--*/
{
    return NlFindSiteEntryBySockAddrEx( SockAddr, NULL );
}

BOOL
NlCaptureSiteName(
    WCHAR CapturedSiteName[NL_MAX_DNS_LABEL_LENGTH+1]
    )
/*++

Routine Description:

    Capture the current sitename of the site this machine is in.

Arguments:

    CapturedSiteName - Returns the name of the site this machine is in.

Return Value:

    TRUE - if there is a site name.
    FALSE - if there is no site name.

--*/
{
    BOOL RetVal;

    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( NlGlobalUnicodeSiteName == NULL ) {
        CapturedSiteName[0] = L'\0';
        RetVal = FALSE;
    } else {
        wcscpy( CapturedSiteName, NlGlobalUnicodeSiteName );
        RetVal = TRUE;
    }
    LeaveCriticalSection( &NlGlobalSiteCritSect );

    return RetVal;
}

NET_API_STATUS
DsrGetSiteName(
        IN LPWSTR ComputerName OPTIONAL,
        OUT LPWSTR *SiteName
)
/*++

Routine Description:

    Same as DsGetSiteNameW except:

    * This is the RPC server side implementation.

Arguments:

    Same as DsGetSiteNameW except as above.

Return Value:

    Same as DsGetSiteNameW except as above.

Note:  On a workstation or a member server, this function makes a
    reasonable attempt to retrieve a valid name of the site ComputerName
    is in.  If the locally stored name is too old, the function receives
    the name from a DC.  If any error occurs during this process, the local
    value for the name is returned.  It is possible that the name received
    from the DC is out of date.  In that case the function will return it
    anyway.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    UNICODE_STRING DomainNameString;

    PDOMAIN_INFO DomainInfo = NULL;
    PCLIENT_SESSION ClientSession = NULL;
    PNL_DC_CACHE_ENTRY NlDcCacheEntry;
    BOOL AmWriter = FALSE;

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ComputerName );

    if ( DomainInfo == NULL ) {
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }

    EnterCriticalSection( &NlGlobalSiteCritSect );

    //
    // On a workstation or a member server, update the site name if it's not
    //  statically configured and is old.
    //  However, do not update if we are in NT4 domain since there is no site
    //  concept in NT4.
    //

    if ( NlGlobalMemberWorkstation &&
         !NlGlobalParameters.SiteNameConfigured &&
         DomainInfo->DomUnicodeDnsDomainNameString.Length != 0 &&
         NetpLogonTimeHasElapsed(
                NlGlobalSiteNameSetTime,
                NlGlobalParameters.SiteNameTimeout * 1000 ) ) {

        NlPrint(( NL_SITE, "DsrGetSiteName: Site name '%ws' is old. Getting a new one from DC.\n",
                  NlGlobalUnicodeSiteName ));

        LeaveCriticalSection( &NlGlobalSiteCritSect );

        //
        // Fill in the primary domain name.
        //

        RtlInitUnicodeString( &DomainNameString, DomainInfo->DomUnicodeDomainName );

        //
        // On the PDC or BDC,
        //  find the Client session for the domain.
        // On workstations,
        //  find the primary domain client session.
        //

        ClientSession = NlFindNamedClientSession( DomainInfo,
                                                  &DomainNameString,
                                                  NL_DIRECT_TRUST_REQUIRED,
                                                  NULL );

        if ( ClientSession == NULL ) {
            NlPrintDom(( NL_CRITICAL, DomainInfo,
                         "DsrGetSiteName: %wZ: No such trusted domain\n",
                         &DomainNameString ));
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        //
        // Become a writer of the client session.
        //

        if ( !NlTimeoutSetWriterClientSession( ClientSession, WRITER_WAIT_PERIOD ) ) {
            NlPrintCs(( NL_CRITICAL,  ClientSession,
                        "DsrGetSiteName: Can't become writer of client session.\n" ));
            NetStatus = ERROR_NO_LOGON_SERVERS;
            goto Cleanup;
        }
        AmWriter = TRUE;

        //
        // Get the DC info from the server
        //

        Status = NlGetAnyDCName( ClientSession,
                                 TRUE,   // Require IP be used to determine site correctly
                                 FALSE,  // Don't do with-account discovery
                                 &NlDcCacheEntry,
                                 NULL ); // don't care if the DC was rediscovered

        //
        // Do not error out on failure. Rather, use local cache.
        //  Use the response only if it is from an NT5 DC (that
        //  knows about the site of the client)
        //

        EnterCriticalSection( &NlGlobalSiteCritSect );
        if ( NT_SUCCESS(Status) ) {
            if ( (NlDcCacheEntry->ReturnFlags & DS_DS_FLAG) != 0 ) {
                NlSetDynamicSiteName( NlDcCacheEntry->UnicodeClientSiteName );
            } else {
                NlPrint(( NL_SITE,
                          "DsrGetSiteName: NlGetAnyDCName returned NT4 DC. Returning site '%ws' from local cache\n",
                          NlGlobalUnicodeSiteName ));
            }
            NetpDcDerefCacheEntry( NlDcCacheEntry );
        } else {
            NlPrint(( NL_CRITICAL,
                      "DsrGetSiteName: NlGetAnyDCName failed. Returning site '%ws' from local cache.\n",
                      NlGlobalUnicodeSiteName ));
        }

    } else {
        NlPrint(( NL_SITE, "DsrGetSiteName: Returning site name '%ws' from local cache.\n",
                  NlGlobalUnicodeSiteName ));
    }

    if ( NlGlobalUnicodeSiteName == NULL ) {
        *SiteName = NULL;
        NetStatus = ERROR_NO_SITENAME;
    } else {

        *SiteName = NetpAllocWStrFromWStr( NlGlobalUnicodeSiteName );

        if ( *SiteName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            NetStatus = NO_ERROR;
        }
    }

    LeaveCriticalSection( &NlGlobalSiteCritSect );

Cleanup:

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    if ( ClientSession != NULL ) {
        if ( AmWriter ) {
            NlResetWriterClientSession( ClientSession );
        }
        NlUnrefClientSession( ClientSession );
    }

    return NetStatus;
}

NET_API_STATUS
NlSetSiteName(
    IN LPWSTR SiteName OPTIONAL,
    OUT PBOOLEAN SiteNameChanged OPTIONAL
    )
/*++

Routine Description:

    This routine set the current site name in a global.

    Any bogus site name is truncated to be a valid site name.

Arguments:

    SiteName - Name of the site this machine is in.
        NULL: machine is no longer in a site.

    SiteNameChanged - If specified, returns TRUE if the site name changed

Return Value:

    NO_ERROR: success

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory for the subnet structure.

--*/
{
    NET_API_STATUS NetStatus;
    LPWSTR TempUnicodeSiteName = NULL;
    LPWSTR LocalUnicodeSiteName = NULL;
    LPSTR LocalUtf8SiteName = NULL;
    PNL_SITE_ENTRY LocalSiteEntry = NULL;

    //
    // Initialization
    //
    if ( ARGUMENT_PRESENT( SiteNameChanged )) {
        *SiteNameChanged = FALSE;
    }



    //
    // If the site name hasn't changed,
    //  early out.
    //  (Case sensitive compare to allow case changes.)
    //
    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( SiteName != NULL &&
         NlGlobalUnicodeSiteName != NULL &&
         wcscmp( NlGlobalUnicodeSiteName, SiteName ) == 0 ) {
        LeaveCriticalSection( &NlGlobalSiteCritSect );
        NetStatus = NO_ERROR;
        goto Cleanup;
    }
    LeaveCriticalSection( &NlGlobalSiteCritSect );

    //
    // Copy the site name into a Locally allocated buffer.
    //

    NlPrint(( NL_SITE, "Setting site name to '%ws'\n", SiteName ));

    if ( SiteName == NULL ) {
        LocalUnicodeSiteName = NULL;
        LocalUtf8SiteName = NULL;
        LocalSiteEntry = NULL;
    } else {
        BOOLEAN LogMessage = FALSE;
        UNICODE_STRING UnicodeStringOfSiteName;
        LPWSTR Period;
        DNS_STATUS DnsStatus;

        //
        // Ditch any period in the site name.
        //

        RtlInitUnicodeString( &UnicodeStringOfSiteName, SiteName );

        Period = wcschr( SiteName, L'.' );

        if ( Period != NULL ) {
            UnicodeStringOfSiteName.Length = (USHORT)(Period-SiteName) * sizeof(WCHAR);

            NlPrint(( NL_CRITICAL,
                      "Site name '%ws' contains a period (truncated to '%wZ').\n",
                      SiteName,
                      &UnicodeStringOfSiteName ));

            if ( UnicodeStringOfSiteName.Length == 0 ) {

                NlPrint(( NL_CRITICAL,
                          "Site name '%ws' truncated to zero characters (Set to '1').\n",
                          SiteName ));
                RtlInitUnicodeString( &UnicodeStringOfSiteName, L"1" );
            }

            LogMessage = TRUE;
        }


        //
        // Loop truncating the name until it is short enough.
        //
        // The length restriction only makes sense in the UTF-8 character set.
        // UTF-8 has multibyte characters so only truncate the UNICODE string
        //  and test the UTF-8 string.
        //

        for (;;) {

            LocalUtf8SiteName = NetpAllocUtf8StrFromUnicodeString( &UnicodeStringOfSiteName );

            if ( LocalUtf8SiteName == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            //
            // If the site name is OK, we're done.
            //

            if ( strlen(LocalUtf8SiteName) <= NL_MAX_DNS_LABEL_LENGTH ) {
                break;
            }

            //
            // Truncate the site name (and press on)
            //

            UnicodeStringOfSiteName.Length -= sizeof(WCHAR);


            NlPrint(( NL_CRITICAL,
                      "Site name '%ws' is too long (trucated to '%wZ')\n",
                      SiteName,
                      &UnicodeStringOfSiteName ));

            LogMessage = TRUE;
        }


        //
        // Validate the character set of the site name.
        //  (If invalid, map the bogus characters)
        //

        DnsStatus = DnsValidateName_UTF8( LocalUtf8SiteName, DnsNameDomain );

        if ( DnsStatus != ERROR_SUCCESS &&
             DnsStatus != DNS_ERROR_NON_RFC_NAME ) {

            ULONG i;


            //
            // Grab a copy of the string to map into
            //

            TempUnicodeSiteName = NetpAllocWStrFromWStr( SiteName );

            if ( TempUnicodeSiteName == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            UnicodeStringOfSiteName.Buffer = TempUnicodeSiteName;

            //
            // Map the bogus characters
            //

            for ( i=0; i<UnicodeStringOfSiteName.Length/sizeof(WCHAR); i++) {
                WCHAR JustOneChar[2];

                //
                // Test one character at a time.
                //

                JustOneChar[0] = UnicodeStringOfSiteName.Buffer[i];
                JustOneChar[1] = '\0';

                DnsStatus = DnsValidateName_W( JustOneChar, DnsNameDomain );

                if ( DnsStatus != ERROR_SUCCESS &&
                     DnsStatus != DNS_ERROR_NON_RFC_NAME ) {
                    UnicodeStringOfSiteName.Buffer[i] = L'-';

                }


            }

            //
            // Map back to UTF-8
            //

            NetpMemoryFree( LocalUtf8SiteName );

            LocalUtf8SiteName = NetpAllocUtf8StrFromUnicodeString( &UnicodeStringOfSiteName );

            if ( LocalUtf8SiteName == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            NlPrint(( NL_CRITICAL,
                      "Site name '%ws' has invalid character (set to '%wZ')\n",
                      SiteName,
                      &UnicodeStringOfSiteName ));

            LogMessage = TRUE;

        }


        //
        // If any munging of the name occurred,
        //  log the failure.
        //

        if ( LogMessage ) {
            LPWSTR MsgStrings[1];

            MsgStrings[0] = (LPWSTR) SiteName;

            NlpWriteEventlog( NELOG_NetlogonBadSiteName,
                              EVENTLOG_ERROR_TYPE,
                              NULL,
                              0,
                              MsgStrings,
                              1 );

        }


        LocalUnicodeSiteName = NetpAllocWStrFromUtf8Str( LocalUtf8SiteName );

        if ( LocalUnicodeSiteName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        NlAssert( wcslen(LocalUnicodeSiteName) <= NL_MAX_DNS_LABEL_LENGTH );

        LocalSiteEntry = NlFindSiteEntry( LocalUnicodeSiteName );

        if ( LocalSiteEntry == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // If the site name hasn't changed (Using modified site name),
    //  early out.
    //  (Case sensitive compare to allow case changes.)
    //
    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( LocalUnicodeSiteName != NULL &&
         NlGlobalUnicodeSiteName != NULL &&
         wcscmp( NlGlobalUnicodeSiteName, LocalUnicodeSiteName ) == 0 ) {
        LeaveCriticalSection( &NlGlobalSiteCritSect );
        NetStatus = NO_ERROR;
        goto Cleanup;
    }


    //
    // Free any previous entry
    //
    if ( NlGlobalUnicodeSiteName != NULL ) {
        NetpMemoryFree( NlGlobalUnicodeSiteName );
    }
    if ( NlGlobalUtf8SiteName != NULL ) {
        NetpMemoryFree( NlGlobalUtf8SiteName );
    }
    if ( NlGlobalSiteEntry != NULL ) {
        NlDerefSiteEntry( NlGlobalSiteEntry );
    }

    //
    // Save the new site name.
    //

    NlGlobalUnicodeSiteName = LocalUnicodeSiteName;
    LocalUnicodeSiteName = NULL;

    NlGlobalUtf8SiteName = LocalUtf8SiteName;
    LocalUtf8SiteName = NULL;

    NlGlobalSiteEntry = LocalSiteEntry;
    LocalSiteEntry = NULL;
    LeaveCriticalSection( &NlGlobalSiteCritSect );

    if ( ARGUMENT_PRESENT( SiteNameChanged )) {
        *SiteNameChanged = TRUE;
    }

    NetStatus = NO_ERROR;


    //
    // Cleanup local data.
    //
Cleanup:
    if ( TempUnicodeSiteName != NULL ) {
        NetpMemoryFree( TempUnicodeSiteName );
    }
    if ( LocalUnicodeSiteName != NULL ) {
        NetApiBufferFree( LocalUnicodeSiteName );
    }
    if ( LocalUtf8SiteName != NULL ) {
        NetpMemoryFree( LocalUtf8SiteName );
    }
    if ( LocalSiteEntry != NULL ) {
        NlDerefSiteEntry( LocalSiteEntry );
    }

    //
    // Set the time when the site name was updated
    //

    if ( NetStatus == NO_ERROR ) {
        NlQuerySystemTime( &NlGlobalSiteNameSetTime );
    }

    return NetStatus;

}

VOID
NlSetDynamicSiteName(
    IN LPWSTR SiteName OPTIONAL
    )
/*++

Routine Description:

    This routine set the current site name of this machine in the registry
    and in Netlogon globals

Arguments:

    SiteName - Name of the site this machine is in.
        NULL: machine is no longer in a site.

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;
    HKEY ParmHandle = NULL;
    ULONG SiteNameSize;

    //
    // Avoid changing the site name on DCs.
    //

    if ( !NlGlobalMemberWorkstation ) {
        return;
    }


    //
    // Don't change the sitename back to its current value.
    //  (Case sensitive compare to allow case changes.)
    //
    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( NlGlobalUnicodeSiteName != NULL &&
         SiteName != NULL &&
         wcscmp(SiteName, NlGlobalUnicodeSiteName) == 0 ) {
        NlPrint(( NL_SITE_MORE, "NlSetDynamicSiteName: Old and new site names '%ws' are identical.\n",
                  SiteName ));
        NlQuerySystemTime( &NlGlobalSiteNameSetTime );
        goto Cleanup;
    }

    //
    // If the site name was explicitly configured,
    //  don't set the site name.
    //

    if ( NlGlobalParameters.SiteNameConfigured ) {
        NlPrint(( NL_SITE_MORE,
                  "Cannot set site name to %ws from %ws since it is statically configured\n",
                  SiteName,
                  NlGlobalUnicodeSiteName ));
        goto Cleanup;
    }

    //
    // Save the name in globals.
    //

    NlSetSiteName( SiteName, NULL );

    //
    // Save the name in the registry to keep it across boots.
    //


    //
    // Open the key for Netlogon\Parameters
    //

    ParmHandle = NlOpenNetlogonKey( NL_PARAM_KEY );

    if (ParmHandle == NULL) {
        NlPrint(( NL_CRITICAL,
                  "Cannot NlOpenNetlogonKey to set site name to %ws from %ws\n",
                  SiteName,
                  NlGlobalUnicodeSiteName ));
        goto Cleanup;
    }

    //
    // If the we're no longer in a site,
    //  delete the value.
    //

    if ( SiteName == NULL ) {
        NetStatus = RegDeleteValueW( ParmHandle,
                                     NETLOGON_KEYWORD_DYNAMICSITENAME );

        if ( NetStatus != ERROR_SUCCESS ) {
            if ( NetStatus != ERROR_FILE_NOT_FOUND ) {
                NlPrint(( NL_CRITICAL,
                          "NlSetDynamicSiteName: Cannot delete '" NL_PARAM_KEY "\\%ws' %ld.\n",
                          NETLOGON_KEYWORD_DYNAMICSITENAME,
                          NetStatus ));
            }
            goto Cleanup;
        }
    //
    // Set the value in the registry.
    //
    } else {

        SiteNameSize = (wcslen(SiteName)+1) * sizeof(WCHAR);
        NetStatus = RegSetValueExW( ParmHandle,
                                    NETLOGON_KEYWORD_DYNAMICSITENAME,
                                    0,              // Reserved
                                    REG_SZ,
                                    (LPBYTE)SiteName,
                                    SiteNameSize+1 );

        if ( NetStatus != ERROR_SUCCESS ) {
            NlPrint(( NL_CRITICAL,
                      "NlSetDynamicSiteName: Cannot Set '" NL_PARAM_KEY "\\%ws' %ld.\n",
                      NETLOGON_KEYWORD_DYNAMICSITENAME,
                      NetStatus ));
            goto Cleanup;
        }
    }


Cleanup:
    LeaveCriticalSection( &NlGlobalSiteCritSect );

    if ( ParmHandle != NULL ) {
        RegCloseKey( ParmHandle );
    }
    return;
}

NET_API_STATUS
NlSitesAddSubnetFromDs(
    OUT PBOOLEAN SiteNameChanged OPTIONAL
    )
/*++

Routine Description:

    This routine reads the subnet\site mapping from the DS and populates
    Netlogon's cache with that information

Arguments:

    SiteNameChanged - If specified, returns TRUE if the site name changed

Return Value:

    NO_ERROR: success

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory for the subnet structure.


--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    PLSAP_SUBNET_INFO SubnetInfo = NULL;
    PLSAP_SITENAME_INFO SiteNameInfo = NULL;
    ULONG i;
    BOOLEAN MoreThanOneSite = FALSE;
    ULONG LocalSubnetCount = 0;

    //
    // Get the site name of this site.
    //

    Status = LsaIGetSiteName( &SiteNameInfo );

    if ( !NT_SUCCESS(Status) ) {

        //
        // If the DS simply isn't running,
        //  skip this.
        //

        if ( Status == STATUS_INVALID_DOMAIN_STATE ) {
            NlPrint(( NL_SITE,
                      "DS isn't running so site to subnet mapping ignored\n" ));
            NetStatus = NO_ERROR;
            goto Cleanup;
        }
        NlPrint(( NL_CRITICAL,
                  "Cannot LsaIGetSiteName %lx\n", Status ));
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    NlGlobalDsaGuid = SiteNameInfo->DsaGuid;

    NetStatus = NlSetSiteName( SiteNameInfo->SiteName.Buffer, SiteNameChanged );

    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "Cannot NlSetSiteName %ld\n", NetStatus ));
        goto Cleanup;
    }

    //
    // If this machine is marked as a GC,
    //  flag it so.
    //
    //  Really this is only needed if netlogon.dll is unloaded via nltest /unload.
    // Otherwise the flag is saved across starts/stops in a global.
    //

    if ( NlGlobalNetlogonUnloaded &&
         (SiteNameInfo->DsaOptions & NTDSDSA_OPT_IS_GC) != 0 ) {
        NlPrint((NL_INIT,
                "Set GC-running bit after netlogon.dll unload\n" ));
        I_NetLogonSetServiceBits( DS_GC_FLAG, DS_GC_FLAG );
    }


    //
    // Get the list of subnet to site mappings from the DS
    //

    NlPrint(( NL_SITE, "Adding subnet to site mappings from the DS\n" ));

    Status = LsaIQuerySubnetInfo( &SubnetInfo );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint((NL_CRITICAL, "Cannot LsaIQuerySubnetInfo %lx\n", Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Put them in our in-memory cache.
    //

    for ( i=0; i<SubnetInfo->SubnetCount; i++ ) {

        //
        // If there is no site associated with the subnet,
        //  silently ignore it.
        //

        if ( SubnetInfo->Subnets[i].SiteName.Length == 0 ) {
            NlPrint(( NL_SITE, "%wZ: Subnet has no associated site (ignored)\n",
                      &SubnetInfo->Subnets[i].SubnetName ));
            continue;
        }

        LocalSubnetCount ++;

        //
        // Determine if there are multiple sites in the enterprise
        //

        if ( !RtlEqualUnicodeString( &SiteNameInfo->SiteName,
                                     &SubnetInfo->Subnets[i].SiteName,
                                     TRUE )) {
            NlPrint(( NL_SITE, "%wZ: Site %wZ is not site this DC is in.\n",
                      &SubnetInfo->Subnets[i].SubnetName,
                      &SubnetInfo->Subnets[i].SiteName ));
            MoreThanOneSite = TRUE;
        }

        //
        // Add the subnet to out in memory cache.
        //

        NetStatus = NlSitesAddSubnet(
                        SubnetInfo->Subnets[i].SiteName.Buffer,
                        SubnetInfo->Subnets[i].SubnetName.Buffer );

        if ( NetStatus != NO_ERROR ) {
            NlPrint(( NL_CRITICAL,
                      "%wZ: %wZ: Cannot add subnet-to-site mapping to cache: %ld\n",
                      &SubnetInfo->Subnets[i].SubnetName,
                      &SubnetInfo->Subnets[i].SiteName,
                      NetStatus ));

            if ( NetStatus == ERROR_INVALID_NAME ) {
                LPWSTR MsgStrings[1];

                MsgStrings[0] = (LPWSTR) SubnetInfo->Subnets[i].SubnetName.Buffer;

                NlpWriteEventlog( NELOG_NetlogonBadSubnetName,
                                  EVENTLOG_INFORMATION_TYPE,
                                  NULL,
                                  0,
                                  MsgStrings,
                                  1 );
            }
        }
    }

    //
    // Indicate that all the subnets have been added.
    //
    NlSitesEndSubnetEnum();

    //
    // If there are no subnet entries,
    //  and there is only one site in the enterprise,
    //  indicate that all client belong to this site.
    //
    // If there are subnet entries,
    //  and all of them indicate the same site as our site,
    //  indicate that all clients belong to this site.
    //

    EnterCriticalSection( &NlGlobalSiteCritSect );
    if ( LocalSubnetCount == 0) {
        NlGlobalOnlyOneSite = (SubnetInfo->SiteCount == 1);
    } else {
        NlGlobalOnlyOneSite = !MoreThanOneSite;
    }

    if ( NlGlobalOnlyOneSite ) {
        NlPrint(( NL_SITE, "There is only one site.  All clients belong to it.\n" ));
    }
    LeaveCriticalSection( &NlGlobalSiteCritSect );


    NetStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:
    if ( SubnetInfo != NULL ) {
        LsaIFree_LSAP_SUBNET_INFO( SubnetInfo );
    }
    if ( SiteNameInfo != NULL ) {
        LsaIFree_LSAP_SITENAME_INFO( SiteNameInfo );
    }
    return NetStatus;
}


NET_API_STATUS
DsrAddressToSiteNamesW(
    IN LPWSTR ComputerName,
    IN DWORD EntryCount,
    IN PNL_SOCKET_ADDRESS SocketAddresses,
    OUT PNL_SITE_NAME_ARRAY *SiteNames
    )
/*++

Routine Description:

    The DsAddressToSiteNames API returns the site names that correspond to
    the specified addresses.

Arguments:

    ComputerName - Specifies the name of the domain controller to remote this API to.

    EntryCount - Number of addresses to convert.

    SocketAddresses - Specifies an array of addresses to convert.  EntryCount
        addresses must be specified. Each address must be of type AF_INET.

    SiteNames - Returns an array of pointers to site names.  EntryCount entries
        are returned.  An entry will be returned as NULL if the corresponding
        address does not map to any site or if the address is malformed.

        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_SITE_ENTRY *SiteEntries = NULL;
    ULONG i;
    ULONG Size;
    PUNICODE_STRING Strings;
    LPBYTE Where;

    //
    // This API is not supported on workstations.
    //

    *SiteNames = NULL;
    if ( NlGlobalMemberWorkstation ) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Initialization
    //

    if ( EntryCount == 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Allocate an array for intermediate results
    //

    SiteEntries = LocalAlloc( LMEM_ZEROINIT, EntryCount*sizeof(PNL_SITE_ENTRY) );

    if ( SiteEntries == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Loop mapping each entry
    //

    for ( i=0; i<EntryCount; i++ ) {
        PSOCKET_ADDRESS SocketAddress;
        PSOCKADDR SockAddr;

        //
        // Validate the entry
        //

        SocketAddress = (PSOCKET_ADDRESS)&SocketAddresses[i];
        SockAddr = SocketAddress->lpSockaddr;
        if ( (SocketAddress->iSockaddrLength < sizeof(SOCKADDR) ) ||
             (SockAddr == NULL) ) {
            NlPrint((NL_CRITICAL,
                    "DsrAddressToSiteNamesW: Sockaddr is too small %ld (ignoring it)\n",
                    SocketAddress->iSockaddrLength ));
            SiteEntries[i] = NULL;
        } else if ( SockAddr->sa_family != AF_INET ) {
            NlPrint((NL_CRITICAL,
                    "DsrAddressToSiteNamesW: Address familty isn't AF_INET %ld (ignoring it)\n",
                    SockAddr->sa_family ));
            SiteEntries[i] = NULL;
        } else {

            //
            // The SockAddr is valid so map it to a site name.
            //
            SiteEntries[i] = NlFindSiteEntryBySockAddrEx( SockAddr, NULL );
        }

    }

    //
    // Allocate a structure to return to the caller.
    //

    Size = sizeof(NL_SITE_NAME_ARRAY) + EntryCount * sizeof(UNICODE_STRING);
    for ( i=0; i<EntryCount; i++ ) {
        if ( SiteEntries[i] != NULL ) {
            Size += SiteEntries[i]->SiteNameString.Length + sizeof(WCHAR);
        }
    }

    *SiteNames = MIDL_user_allocate( Size );

    if ( *SiteNames == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Strings = (PUNICODE_STRING) ((*SiteNames)+1);
    (*SiteNames)->EntryCount = EntryCount;
    (*SiteNames)->SiteNames = Strings;
    Where = (LPBYTE) &Strings[EntryCount];

    //
    // Loop copying the names into the return buffer.
    //

    for ( i=0; i<EntryCount; i++ ) {
        if ( SiteEntries[i] == NULL ) {
            RtlInitUnicodeString( &Strings[i], NULL );
        } else {
            Strings[i].Length = SiteEntries[i]->SiteNameString.Length;
            Strings[i].MaximumLength = Strings[i].Length + sizeof(WCHAR);
            Strings[i].Buffer = (LPWSTR)Where;

            RtlCopyMemory( Where, SiteEntries[i]->SiteName, Strings[i].MaximumLength );

            Where += Strings[i].Length + sizeof(WCHAR);
        }
    }


    NetStatus = NO_ERROR;
Cleanup:

    //
    // Derference the site entries.
    //

    if ( SiteEntries != NULL ) {
        for ( i=0; i<EntryCount; i++ ) {
            if ( SiteEntries[i] != NULL ) {
                NlDerefSiteEntry( SiteEntries[i] );
            }
        }
        LocalFree( SiteEntries );
    }


    if ( NetStatus != NO_ERROR ) {
        if ( *SiteNames != NULL ) {
            MIDL_user_free( *SiteNames );
            *SiteNames = NULL;
        }
    }
    return NetStatus;
    UNREFERENCED_PARAMETER( ComputerName );
}


NET_API_STATUS
DsrAddressToSiteNamesExW(
    IN LPWSTR ComputerName,
    IN DWORD EntryCount,
    IN PNL_SOCKET_ADDRESS SocketAddresses,
    OUT PNL_SITE_NAME_EX_ARRAY *SiteNames
    )
/*++

Routine Description:

    The DsAddressToSiteNames API returns the site names and subnet names
    that correspond to the specified addresses.

Arguments:

    ComputerName - Specifies the name of the domain controller to remote this API to.

    EntryCount - Number of addresses to convert.

    SocketAddresses - Specifies an array of addresses to convert.  EntryCount
        addresses must be specified. Each address must be of type AF_INET.

    SiteNames - Returns an array of pointers to site names.  EntryCount entries
        are returned.  An entry will be returned as NULL if the corresponding
        address does not map to any site or if the address is malformed.

        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_SITE_ENTRY *SiteEntries = NULL;
    PNL_SUBNET *SubnetEntries;
    ULONG i;
    ULONG Size;
    PUNICODE_STRING SiteStrings = NULL;
    PUNICODE_STRING SubnetStrings = NULL;

    //
    // This API is not supported on workstations.
    //

    *SiteNames = NULL;
    if ( NlGlobalMemberWorkstation ) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Initialization
    //

    if ( EntryCount == 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Allocate an array for intermediate results
    //

    SiteEntries = LocalAlloc( LMEM_ZEROINIT,
                              EntryCount*(sizeof(PNL_SITE_ENTRY)+sizeof(PNL_SUBNET)) );

    if ( SiteEntries == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SubnetEntries = (PNL_SUBNET *) (&SiteEntries[EntryCount]);

    //
    // Loop mapping each entry
    //

    for ( i=0; i<EntryCount; i++ ) {
        PSOCKET_ADDRESS SocketAddress;
        PSOCKADDR SockAddr;

        //
        // Validate the entry
        //

        SocketAddress = (PSOCKET_ADDRESS)&SocketAddresses[i];
        SockAddr = SocketAddress->lpSockaddr;
        if ( (SocketAddress->iSockaddrLength < sizeof(SOCKADDR) ) ||
             (SockAddr == NULL) ) {
            NlPrint((NL_CRITICAL,
                    "DsrAddressToSiteNamesW: Sockaddr is too small %ld (ignoring it)\n",
                    SocketAddress->iSockaddrLength ));
            SiteEntries[i] = NULL;
        } else if ( SockAddr->sa_family != AF_INET ) {
            NlPrint((NL_CRITICAL,
                    "DsrAddressToSiteNamesW: Address familty isn't AF_INET %ld (ignoring it)\n",
                    SockAddr->sa_family ));
            SiteEntries[i] = NULL;
        } else {

            //
            // The SockAddr is valid so map it to a site name.
            //
            SiteEntries[i] = NlFindSiteEntryBySockAddrEx( SockAddr, &SubnetEntries[i] );
        }

    }

    //
    // Allocate a structure to return to the caller.
    //

    *SiteNames = MIDL_user_allocate( sizeof(NL_SITE_NAME_EX_ARRAY) );

    if ( *SiteNames == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    SubnetStrings = MIDL_user_allocate( EntryCount * sizeof(UNICODE_STRING) );

    if ( SubnetStrings == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( SubnetStrings, EntryCount * sizeof(UNICODE_STRING) );

    SiteStrings = MIDL_user_allocate( EntryCount * sizeof(UNICODE_STRING) );

    if ( SiteStrings == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( SiteStrings, EntryCount * sizeof(UNICODE_STRING) );

    (*SiteNames)->EntryCount = EntryCount;
    (*SiteNames)->SiteNames = SiteStrings;
    (*SiteNames)->SubnetNames = SubnetStrings;

    //
    // Loop copying the names into the return buffer.
    //

    for ( i=0; i<EntryCount; i++ ) {

        if ( SiteEntries[i] != NULL ) {
            LPWSTR Name;

            Name = NetpAllocWStrFromWStr( SiteEntries[i]->SiteName );

            if ( Name == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            RtlInitUnicodeString( &SiteStrings[i], Name );
        }

        if ( SubnetEntries[i] != NULL ) {
            WCHAR SubnetAddressString[NL_IP_ADDRESS_LENGTH+1+2+1];
            ULONG Length;
            UNICODE_STRING NumberString;
            LPWSTR Name;

            //
            // Compute the IP address part of the subnet name
            //
            NetpIpAddressToWStr( SubnetEntries[i]->SubnetAddress,
                                 SubnetAddressString );

            Length = wcslen(SubnetAddressString);

            SubnetAddressString[Length] = '/';
            Length ++;

            //
            // Compute the bit count part of the subnet name
            //
            NumberString.Buffer = &SubnetAddressString[Length];
            NumberString.MaximumLength = 3 * sizeof(WCHAR);

            RtlIntegerToUnicodeString( SubnetEntries[i]->SubnetBitCount,
                                       10,
                                       &NumberString );

            SubnetAddressString[Length+NumberString.Length/sizeof(WCHAR)] = '\0';

            //
            // Return it to the caller
            //

            Name = NetpAllocWStrFromWStr( SubnetAddressString );

            if ( Name == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            RtlInitUnicodeString( &SubnetStrings[i], Name );

        }
    }


    NetStatus = NO_ERROR;
Cleanup:

    //
    // Derference the site entries.
    //

    if ( SiteEntries != NULL ) {
        for ( i=0; i<EntryCount; i++ ) {
            if ( SiteEntries[i] != NULL ) {
                NlDerefSiteEntry( SiteEntries[i] );
            }
            if ( SubnetEntries[i] != NULL ) {
                NlSitesDerefSubnet( SubnetEntries[i] );
            }
        }
    }


    if ( NetStatus != NO_ERROR ) {
        if ( *SiteNames != NULL ) {
            MIDL_user_free( *SiteNames );
            *SiteNames = NULL;
        }
        if ( SiteStrings != NULL ) {
            for ( i=0; i<EntryCount; i++ ) {
                if ( SiteStrings[i].Buffer != NULL ) {
                    MIDL_user_free( SiteStrings[i].Buffer );
                }
            }
            MIDL_user_free( SiteStrings );
        }
        if ( SubnetStrings != NULL ) {
            for ( i=0; i<EntryCount; i++ ) {
                if ( SubnetStrings[i].Buffer != NULL ) {
                    MIDL_user_free( SubnetStrings[i].Buffer );
                }
            }
            MIDL_user_free( SubnetStrings );
        }
    }
    return NetStatus;
    UNREFERENCED_PARAMETER( ComputerName );
}

NET_API_STATUS
NlSiteInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize this module.

    Calls NlExit upon failure.

Arguments:

    None.

Return Value:

    Status of the initialization.

--*/
{
    NET_API_STATUS NetStatus;

    try {
        InitializeCriticalSection(&NlGlobalSiteCritSect);
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NlPrint((NL_CRITICAL, "Cannot InitializeCriticalSection for SiteCritSect\n" ));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    NlGlobalUnicodeSiteName = NULL;
    NlGlobalSiteEntry = NULL;
    InitializeListHead( &NlGlobalSiteList );
    InitializeListHead( &NlGlobalSubnetList );
    RtlZeroMemory( &NlGlobalSubnetTree, sizeof(NlGlobalSubnetTree) );
    RtlZeroMemory( &NlGlobalNewSubnetTree, sizeof(NlGlobalNewSubnetTree) );
    NlGlobalSiteInitialized = TRUE;

    //
    // Initially set the site name and populate the subnet tree.
    //
    if ( NlGlobalMemberWorkstation ) {
        NetStatus = NlSetSiteName( NlGlobalParameters.SiteName, NULL );
    } else {
        NetStatus = NlSitesAddSubnetFromDs( NULL );
    }

    return NetStatus;

}

VOID
NlSiteTerminate(
    VOID
    )
/*++

Routine Description:

    De-Initialize this module.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLIST_ENTRY ListEntry;

    //
    // If we've not initialized,
    //  we're done.
    //
    if ( !NlGlobalSiteInitialized ) {
        return;
    }

    NlPrint(( NL_SITE_MORE, "NlSiteTerminate: Entered\n" ));

    //
    // Free all entries in NlGlobalSubnetTree and NlGlobalNewSubnetTree
    //
    EnterCriticalSection( &NlGlobalSiteCritSect );
    NlSiteDeleteSubnetTree( &NlGlobalSubnetTree );
    NlSiteDeleteSubnetTree( &NlGlobalNewSubnetTree );

    //
    // Delete the site name.
    //
    NlSetSiteName( NULL, NULL );
    LeaveCriticalSection( &NlGlobalSiteCritSect );

    //
    // There should be no more sites or subnets since all covered sites
    // have been previously dereferenced and all remaining references
    // were from the tree above
    //
    NlAssert( IsListEmpty( &NlGlobalSiteList ) );
    NlAssert( IsListEmpty( &NlGlobalSubnetList ) );
    DeleteCriticalSection(&NlGlobalSiteCritSect);
    NlGlobalSiteInitialized = FALSE;
    NlPrint(( NL_SITE_MORE, "NlSiteTerminate: Exitted\n" ));

}


int __cdecl NlpCompareSiteName(
        const void *String1,
        const void *String2
    )
/*++

Routine Description:

    String comparison routine for DsrGetDcSiteCoverageW.

Arguments:

    String1: First string to compare

    String2: Second string to compare

Return Value:

--*/
{
    return RtlCompareUnicodeString(
                (PUNICODE_STRING) String1,
                (PUNICODE_STRING) String2,
                TRUE );
}

NET_API_STATUS
DsrGetDcSiteCoverageW(
    IN LPWSTR ComputerName OPTIONAL,
    OUT PNL_SITE_NAME_ARRAY *SiteNames
    )
/*++

Routine Description:

    This API returns the site names of all sites covered by DC.

Arguments:

    ComputerName - Specifies the name of the domain controller to remote this API to.

    SiteNames - Returns an array of pointers to site names.
        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

--*/
{
    NET_API_STATUS NetStatus;
    PDOMAIN_INFO DomainInfo = NULL;

    if ( NlGlobalMemberWorkstation ) {
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Lookup which domain this call pertains to.
    //

    DomainInfo = NlFindDomainByServerName( ComputerName );

    if ( DomainInfo == NULL ) {
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }

    //
    // Get the site names
    //

    NetStatus = NlSitesGetCloseSites( DomainInfo,
                                      DOM_REAL_DOMAIN,
                                      SiteNames );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Sort them into alphabetical order
    //

    qsort( (*SiteNames)->SiteNames,
           (*SiteNames)->EntryCount,
           sizeof(UNICODE_STRING),
           NlpCompareSiteName );


Cleanup:

    if ( DomainInfo != NULL ) {
        NlDereferenceDomain( DomainInfo );
    }

    return NetStatus;
}



NET_API_STATUS
I_NetLogonAddressToSiteName(
    IN PSOCKET_ADDRESS SocketAddress,
    OUT LPWSTR *SiteName
    )
/*++

Routine Description:

    This API returns the site name, if any, of the address in SocketAddress.

    It is provided for in-process callers. See DsrAddressToSiteNamesW for details.

Arguments:

    SocketAddess -- the address to be looked up

    SiteName -- the site name of the address; NULL is returned if no site
    is found.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

    ERROR_NETLOGON_NOT_STARTED - Netlogon is stopped.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    PNL_SITE_NAME_ARRAY SiteNameArray = NULL;

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return ERROR_NETLOGON_NOT_STARTED;
    }

    *SiteName = NULL;

    NetStatus = DsrAddressToSiteNamesW( NULL,
                                        1,
                                       (PNL_SOCKET_ADDRESS)SocketAddress,
                                       &SiteNameArray );

    if ( (NO_ERROR == NetStatus)
      && SiteNameArray->EntryCount > 0
      && SiteNameArray->SiteNames[0].Length > 0  ) {

        ULONG Size = SiteNameArray->SiteNames[0].Length + sizeof(WCHAR);
        *SiteName = MIDL_user_allocate(Size);
        if (*SiteName) {
            RtlZeroMemory(*SiteName, Size);
            RtlCopyMemory(*SiteName, SiteNameArray->SiteNames[0].Buffer, SiteNameArray->SiteNames[0].Length);
        } else {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (SiteNameArray != NULL) {
        MIDL_user_free(SiteNameArray);
    }

    //
    // Indicate that the calling thread has left netlogon.dll
    //

    NlEndNetlogonCall();

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nlsite.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    nlsite.h

Abstract:

    Header for routines to handle sites and subnets.

Author:

    Cliff Van Dyke (CliffV) 1-May-1997

Revision History:

--*/

//
// Structure defining a site name.
//
// The SiteEntry exists only if it is referenced.
// Site coverage lists each should maintain a reference
// to prevent the entry for a close site from being deleted.
//

typedef struct _NL_SITE_ENTRY {

    //
    // Link for NlGlobalSiteList
    //

    LIST_ENTRY Next;

    //
    // Reference Count.
    //

    ULONG ReferenceCount;

    //
    // Name of the site
    //  Must be last field in struct.
    //

    UNICODE_STRING SiteNameString;
    WCHAR SiteName[ANYSIZE_ARRAY];

} NL_SITE_ENTRY, *PNL_SITE_ENTRY;

//
// Structure defining a covered site.
//

typedef struct _NL_COVERED_SITE {

    //
    // Pointer to the covered site entry in
    // the global list of sites. This entry is
    // referenced.
    //
    PNL_SITE_ENTRY CoveredSite;

    BOOLEAN CoveredAuto;  // If TRUE, this site is covered automatically

} NL_COVERED_SITE, *PNL_COVERED_SITE;


//
// Procedure Forwards for nlsite.c
//

NET_API_STATUS
NlSiteInitialize(
    VOID
    );

VOID
NlSiteTerminate(
    VOID
    );

VOID
NlDerefSiteEntry(
    IN PNL_SITE_ENTRY SiteEntry
    );

PNL_SITE_ENTRY
NlFindSiteEntry(
    IN LPWSTR SiteName
    );

PNL_SITE_ENTRY
NlFindSiteEntryBySockAddr(
    IN PSOCKADDR SockAddr
    );

NET_API_STATUS
NlSitesAddSubnet(
    IN LPWSTR SiteName,
    IN LPWSTR SubnetName
    );

NET_API_STATUS
NlSitesAddSubnetFromDs(
    OUT PBOOLEAN SiteNameChanged OPTIONAL
    );

VOID
NlSitesEndSubnetEnum(
    VOID
    );

BOOL
NlCaptureSiteName(
    WCHAR CapturedSiteName[NL_MAX_DNS_LABEL_LENGTH+1]
    );

NET_API_STATUS
NlSetSiteName(
    IN LPWSTR SiteName OPTIONAL,
    OUT PBOOLEAN SiteNameChanged OPTIONAL
    );

BOOL
NlSitesSetSiteCoverageParam(
    IN ULONG ServerRole,
    IN LPTSTR_ARRAY NewSiteCoverage OPTIONAL
    );

NET_API_STATUS
NlSitesGetCloseSites(
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG ServerRole,
    OUT PNL_SITE_NAME_ARRAY *SiteNames
    );

NET_API_STATUS
NlSitesUpdateSiteCoverageForRole(
    IN  PDOMAIN_INFO DomainInfo,
    IN  ULONG DomFlags,
    IN  HANDLE DsHandle,
    IN  PISM_CONNECTIVITY SiteConnect,
    IN  LPWSTR ThisSiteName,
    IN  ULONG ThisSiteIndex,
    OUT PBOOLEAN SiteCoverageChanged OPTIONAL
    );

NTSTATUS
NlLoadNtDsApiDll(
    VOID
    );

BOOL
NlSitesGetIsmConnect(
    IN LPWSTR SiteName,
    OUT PISM_CONNECTIVITY *SiteConnect,
    OUT PULONG ThisSite
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\rgroups.c ===
/*++

Copyright (c) 1987-1996 Microsoft Corporation

Module Name:

    rgroups.c

Abstract:

    Routines to expand transitive group membership.

Author:

    Mike Swift (mikesw) 8-May-1998

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:


--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop
#include <authz.h>      // Authz API

GUID GUID_A_SECURED_FOR_CROSS_ORGANIZATION = {0x68B1D179,0x0D15,0x4d4f,0xAB,0x71,0x46,0x15,0x2E,0x79,0xA7,0xBC};

typedef struct _NL_AUTHZ_INFO {

    PNETLOGON_SID_AND_ATTRIBUTES SidAndAttributes;
    ULONG                        SidCount;

} NL_AUTHZ_INFO, *PNL_AUTHZ_INFO;


AUTHZ_RESOURCE_MANAGER_HANDLE NlAuthzRM = NULL;

BOOL
NlComputeAuthzGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    )
/*++

Routine Description:

    Authz callback for add groups to authz client context

Arguments:

    See Authz SDK documentation

Return Value:

    Always TRUE

--*/
{
    PNL_AUTHZ_INFO AuthzInfo = (PNL_AUTHZ_INFO) Args;

    *pSidAttrArray = (PSID_AND_ATTRIBUTES) AuthzInfo->SidAndAttributes;
    *pSidCount = AuthzInfo->SidCount;
    *pRestrictedSidAttrArray = NULL;
    *pRestrictedSidCount = 0;

    return (TRUE);
    UNREFERENCED_PARAMETER( hAuthzClientContext );
}

VOID
NlFreeAuthzGroups(
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    )
/*++

Routine Description:

    Authz callback to cleanup after adding groups to authz client context.
    Basically a no-op, as we already have a copy of the SIDs.

Arguments:

    See Authz SDK documentation

Return Value:

    None

--*/
{
    return;
    UNREFERENCED_PARAMETER( pSidAttrArray );
}

NET_API_STATUS
NlInitializeAuthzRM(
    VOID
    )
/*++

Routine Description:

    Initializes the Authz manager for netlogon

Arguments:

    None

Return Value:

    Status of Authz operation

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;

    if ( !AuthzInitializeResourceManager( 0,
                                          NULL,
                                          NlComputeAuthzGroups,
                                          NlFreeAuthzGroups,
                                          L"NetLogon",
                                          &NlAuthzRM) ) {

        NetStatus = GetLastError();
        NlPrint(( NL_CRITICAL, "NlInitializeAuthzRM: AuthzInitializeRm failed 0x%lx\n",
                  NetStatus ));
    }

    return NetStatus;
}

VOID
NlFreeAuthzRm(
    VOID
    )
/*++

Routine Description:

    Frees the Authz manager for netlogon

Arguments:

    None

Return Value:

    None

--*/
{
    if ( NlAuthzRM != NULL ) {
        if ( !AuthzFreeResourceManager(NlAuthzRM) ) {
            NlPrint((NL_CRITICAL, "AuthzFreeResourceManager failed 0x%lx\n", GetLastError()));
        } else {
            NlAuthzRM = NULL;
        }
    }
}


PSID
NlpCopySid(
    IN  PSID Sid
    )

/*++

Routine Description:

    Given a SID allocatees space for a new SID from the LSA heap and copies
    the original SID.

Arguments:

    Sid - The original SID.

Return Value:

    Sid - Returns a pointer to a buffer allocated from the LsaHeap
            containing the resultant Sid.

--*/
{
    PSID NewSid;
    ULONG Size;

    Size = RtlLengthSid( Sid );



    if ((NewSid = MIDL_user_allocate( Size )) == NULL ) {
        return NULL;
    }


    if ( !NT_SUCCESS( RtlCopySid( Size, NewSid, Sid ) ) ) {
        MIDL_user_free( NewSid );
        return NULL;
    }


    return NewSid;
}


NTSTATUS
NlpBuildPacSidList(
    IN  PNETLOGON_VALIDATION_SAM_INFO4 UserInfo,
    OUT PSAMPR_PSID_ARRAY Sids,
    OUT PULONG NonExtraSidCount
    )
/*++

Routine Description:

    Given the validation information for a user, expands the group member-
    ships and user id into a list of sids.  If user id is present, it
    will be expanded into the first entry of the list.

Arguments:

    UserInfo - user's validation information
    Sids - receives an array of all the user's group sids and user id
    NonExtraSidCount - Returns the number of SIDs in the UserInfo which
        are not Extra SIDs.

Return Value:


    STATUS_INSUFFICIENT_RESOURCES - there wasn't enough memory to
        create the list of sids.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NET_API_STATUS NetStatus;
    ULONG Size = 0, i;

    Sids->Count = 0;
    Sids->Sids = NULL;
    *NonExtraSidCount = 0;


    if (UserInfo->UserId != 0) {
        Size += sizeof(SAMPR_SID_INFORMATION);
    }

    Size += UserInfo->GroupCount * (ULONG)sizeof(SAMPR_SID_INFORMATION);


    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {
        Size += UserInfo->SidCount * (ULONG)sizeof(SAMPR_SID_INFORMATION);
    }



    Sids->Sids = (PSAMPR_SID_INFORMATION) MIDL_user_allocate( Size );

    if ( Sids->Sids == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        Sids->Sids,
        Size
        );


    //
    // Start copying SIDs into the structure
    //

    i = 0;

    //
    // If the UserId is non-zero, then it contians the users RID.
    //  This must be the first entry in the list as this is the
    //  order NlpVerifyAllowedToAuthenticate assumes.
    //

    if ( UserInfo->UserId ) {
        NetStatus = NetpDomainIdToSid(
                        UserInfo->LogonDomainId,
                        UserInfo->UserId,
                        (PSID *) &Sids->Sids[0].SidPointer
                        );

        if( NetStatus != ERROR_SUCCESS ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Sids->Count++;
        (*NonExtraSidCount) ++;
    }

    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ ) {

        NetStatus = NetpDomainIdToSid(
                        UserInfo->LogonDomainId,
                        UserInfo->GroupIds[i].RelativeId,
                        (PSID *) &Sids->Sids[Sids->Count].SidPointer
                        );
        if( NetStatus != ERROR_SUCCESS ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Sids->Count++;
        (*NonExtraSidCount) ++;
    }


    //
    // Add in the extra SIDs
    //

    //
    // ???: no need to allocate these
    //
    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {


        for ( i = 0; i < UserInfo->SidCount; i++ ) {


            Sids->Sids[Sids->Count].SidPointer = NlpCopySid(
                                                    UserInfo->ExtraSids[i].Sid
                                                    );
            if (Sids->Sids[Sids->Count].SidPointer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }


            Sids->Count++;
        }
    }


    //
    // Deallocate any memory we've allocated
    //

Cleanup:
    if (!NT_SUCCESS(Status)) {
        if (Sids->Sids != NULL) {
            for (i = 0; i < Sids->Count ;i++ ) {
                if (Sids->Sids[i].SidPointer != NULL) {
                    MIDL_user_free(Sids->Sids[i].SidPointer);
                }
            }
            MIDL_user_free(Sids->Sids);
            Sids->Sids = NULL;
            Sids->Count = 0;
        }
        *NonExtraSidCount = 0;
    }
    return Status;

}


NTSTATUS
NlpAddResourceGroupsToSamInfo (
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT PNETLOGON_VALIDATION_SAM_INFO4 *ValidationInformation,
    IN PSAMPR_PSID_ARRAY ResourceGroups
)
/*++

Routine Description:

    This function converts a NETLOGON_VALIDATION_SAM_INFO version 1, 2, or 4 to
    a NETLOGON_VALIDATION_SAM_INFO version 4 and optionally adds in an array of
    ResourceGroup sids.

    Since version 4 is a superset of the other two levels, the returned structure can
    be used even though one of the other info levels are needed.


Arguments:

    ValidationLevel -- Specifies the level of information passed as input in
        ValidationInformation.  Must be NetlogonValidationSamInfo or
        NetlogonValidationSamInfo2, NetlogonValidationSamInfo4

        NetlogonValidationSamInfo4 is always returned on output.

    ValidationInformation -- Specifies the NETLOGON_VALIDATION_SAM_INFO
        to convert.

    ResourceGroups - The list of resource groups to add to the structure.
        If NULL, no resource groups are added.


Return Value:

    STATUS_INSUFFICIENT_RESOURCES: not enough memory to allocate the new
            structure.

--*/
{
    ULONG Length;
    PNETLOGON_VALIDATION_SAM_INFO4 SamInfo = *ValidationInformation;
    PNETLOGON_VALIDATION_SAM_INFO4 SamInfo4;
    PBYTE Where;
    ULONG Index;
    ULONG GroupIndex;
    ULONG ExtraSids = 0;

    //
    // Calculate the size of the new structure
    //

    Length = sizeof( NETLOGON_VALIDATION_SAM_INFO4 )
            + SamInfo->GroupCount * sizeof(GROUP_MEMBERSHIP)
            + RtlLengthSid( SamInfo->LogonDomainId );


    //
    // Add space for extra sids & resource groups
    //

    if ( ValidationLevel != NetlogonValidationSamInfo &&
         (SamInfo->UserFlags & LOGON_EXTRA_SIDS) != 0 ) {

        for (Index = 0; Index < SamInfo->SidCount ; Index++ ) {
            Length += sizeof(NETLOGON_SID_AND_ATTRIBUTES) + RtlLengthSid(SamInfo->ExtraSids[Index].Sid);
        }
        ExtraSids += SamInfo->SidCount;
    }

    if ( ResourceGroups != NULL ) {
        for (Index = 0; Index < ResourceGroups->Count ; Index++ ) {
            Length += sizeof(NETLOGON_SID_AND_ATTRIBUTES) + RtlLengthSid(ResourceGroups->Sids[Index].SidPointer);
        }
        ExtraSids += ResourceGroups->Count;
    }

    //
    // Round up now to take into account the round up in the
    // middle of marshalling
    //

    Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->LogonDomainName.Length + sizeof(WCHAR)
            + SamInfo->LogonServer.Length + sizeof(WCHAR)
            + SamInfo->EffectiveName.Length + sizeof(WCHAR)
            + SamInfo->FullName.Length + sizeof(WCHAR)
            + SamInfo->LogonScript.Length + sizeof(WCHAR)
            + SamInfo->ProfilePath.Length + sizeof(WCHAR)
            + SamInfo->HomeDirectory.Length + sizeof(WCHAR)
            + SamInfo->HomeDirectoryDrive.Length + sizeof(WCHAR);

    if ( ValidationLevel == NetlogonValidationSamInfo4 ) {
        Length += SamInfo->DnsLogonDomainName.Length + sizeof(WCHAR)
            + SamInfo->Upn.Length + sizeof(WCHAR);

        //
        // The ExpansionStrings may be used to transport byte aligned data
        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString1.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString2.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString3.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString4.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString5.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString6.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString7.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString8.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString9.Length + sizeof(WCHAR);

        Length = ROUND_UP_COUNT(Length, sizeof(WCHAR))
            + SamInfo->ExpansionString10.Length + sizeof(WCHAR);
    }

    Length = ROUND_UP_COUNT( Length, sizeof(WCHAR) );

    SamInfo4 = (PNETLOGON_VALIDATION_SAM_INFO4) MIDL_user_allocate( Length );

    if ( !SamInfo4 ) {

        //
        // Free the passed-in allocated SAM info
        //
        if ( SamInfo ) {

            //
            // Zero out sensitive data
            //
            RtlSecureZeroMemory( &SamInfo->UserSessionKey, sizeof(SamInfo->UserSessionKey) );
            RtlSecureZeroMemory( &SamInfo->ExpansionRoom, sizeof(SamInfo->ExpansionRoom) );

            MIDL_user_free(SamInfo);
        }
        *ValidationInformation = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // First copy the whole structure, since most parts are the same
    //

    RtlCopyMemory( SamInfo4, SamInfo, sizeof(NETLOGON_VALIDATION_SAM_INFO));
    RtlZeroMemory( &((LPBYTE)SamInfo4)[sizeof(NETLOGON_VALIDATION_SAM_INFO)],
                   sizeof(NETLOGON_VALIDATION_SAM_INFO4) - sizeof(NETLOGON_VALIDATION_SAM_INFO) );

    //
    // Copy all the variable length data
    //

    Where = (PBYTE) (SamInfo4 + 1);

    RtlCopyMemory(
        Where,
        SamInfo->GroupIds,
        SamInfo->GroupCount * sizeof( GROUP_MEMBERSHIP) );

    SamInfo4->GroupIds = (PGROUP_MEMBERSHIP) Where;
    Where += SamInfo->GroupCount * sizeof( GROUP_MEMBERSHIP );

    //
    // Copy the extra groups
    //

    if (ExtraSids != 0) {

        ULONG SidLength;

        SamInfo4->ExtraSids = (PNETLOGON_SID_AND_ATTRIBUTES) Where;
        Where += sizeof(NETLOGON_SID_AND_ATTRIBUTES) * ExtraSids;

        GroupIndex = 0;

        if ( ValidationLevel != NetlogonValidationSamInfo &&
             (SamInfo->UserFlags & LOGON_EXTRA_SIDS) != 0 ) {

            for (Index = 0; Index < SamInfo->SidCount ; Index++ ) {

                SamInfo4->ExtraSids[GroupIndex].Attributes = SamInfo->ExtraSids[Index].Attributes;
                SamInfo4->ExtraSids[GroupIndex].Sid = (PSID) Where;
                SidLength = RtlLengthSid(SamInfo->ExtraSids[Index].Sid);
                RtlCopyMemory(
                    Where,
                    SamInfo->ExtraSids[Index].Sid,
                    SidLength

                    );
                Where += SidLength;
                GroupIndex++;
            }
        }

        //
        // Add the resource groups
        //


        if ( ResourceGroups != NULL ) {
            for (Index = 0; Index < ResourceGroups->Count ; Index++ ) {

                SamInfo4->ExtraSids[GroupIndex].Attributes = SE_GROUP_MANDATORY |
                                                   SE_GROUP_ENABLED |
                                                   SE_GROUP_ENABLED_BY_DEFAULT;

                SamInfo4->ExtraSids[GroupIndex].Sid = (PSID) Where;
                SidLength = RtlLengthSid(ResourceGroups->Sids[Index].SidPointer);
                RtlCopyMemory(
                    Where,
                    ResourceGroups->Sids[Index].SidPointer,
                    SidLength
                    );
                Where += SidLength;
                GroupIndex++;
            }
        }
        SamInfo4->SidCount = GroupIndex;
        NlAssert(GroupIndex == ExtraSids);


    }

    RtlCopyMemory(
        Where,
        SamInfo->LogonDomainId,
        RtlLengthSid( SamInfo->LogonDomainId ) );

    SamInfo4->LogonDomainId = (PSID) Where;
    Where += RtlLengthSid( SamInfo->LogonDomainId );

    //
    // Copy the WCHAR-aligned data
    //
    Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

    NlpPutString(   &SamInfo4->EffectiveName,
                    &SamInfo->EffectiveName,
                    &Where );

    NlpPutString(   &SamInfo4->FullName,
                    &SamInfo->FullName,
                    &Where );

    NlpPutString(   &SamInfo4->LogonScript,
                    &SamInfo->LogonScript,
                    &Where );

    NlpPutString(   &SamInfo4->ProfilePath,
                    &SamInfo->ProfilePath,
                    &Where );

    NlpPutString(   &SamInfo4->HomeDirectory,
                    &SamInfo->HomeDirectory,
                    &Where );

    NlpPutString(   &SamInfo4->HomeDirectoryDrive,
                    &SamInfo->HomeDirectoryDrive,
                    &Where );

    NlpPutString(   &SamInfo4->LogonServer,
                    &SamInfo->LogonServer,
                    &Where );

    NlpPutString(   &SamInfo4->LogonDomainName,
                    &SamInfo->LogonDomainName,
                    &Where );

    if ( ValidationLevel == NetlogonValidationSamInfo4 ) {

        NlpPutString(   &SamInfo4->DnsLogonDomainName,
                        &SamInfo->DnsLogonDomainName,
                        &Where );

        NlpPutString(   &SamInfo4->Upn,
                        &SamInfo->Upn,
                        &Where );

        NlpPutString(   &SamInfo4->ExpansionString1,
                        &SamInfo->ExpansionString1,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString2,
                        &SamInfo->ExpansionString2,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString3,
                        &SamInfo->ExpansionString3,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString4,
                        &SamInfo->ExpansionString4,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString5,
                        &SamInfo->ExpansionString5,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString6,
                        &SamInfo->ExpansionString6,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString7,
                        &SamInfo->ExpansionString7,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString8,
                        &SamInfo->ExpansionString8,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString9,
                        &SamInfo->ExpansionString9,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

        NlpPutString(   &SamInfo4->ExpansionString10,
                        &SamInfo->ExpansionString10,
                        &Where );

        Where = ROUND_UP_POINTER(Where, sizeof(WCHAR) );

    }

    //
    // Zero out sensitive data
    //
    RtlSecureZeroMemory( &SamInfo->UserSessionKey, sizeof(SamInfo->UserSessionKey) );
    RtlSecureZeroMemory( &SamInfo->ExpansionRoom, sizeof(SamInfo->ExpansionRoom) );

    MIDL_user_free(SamInfo);

    *ValidationInformation =  SamInfo4;

    return STATUS_SUCCESS;

}

NTSTATUS
NlpVerifyAllowedToAuthenticate(
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG ComputerAccountId,
    IN PSAMPR_PSID_ARRAY SamSidList,
    IN ULONG SamSidCount,
    IN PNETLOGON_SID_AND_ATTRIBUTES NlSidsAndAttributes,
    IN ULONG NlSidsAndAttributesCount
    )
/*++

Routine Description:

     This routine performs an access check to determine whether
     the user logon is allowed to a specified computer. This
     check is performed on the DC that is the computer uses on
     the secure channel in its domain. Note that the computer
     may be this DC when the logon is initiated locally from
     MSV package.

     This access check is performed only if the trust path traversed
     to validate the logon involved an Other Organization trust link.
     In this case, the well-known OtherOrg SID will be present in the
     passed-in netlogon SIDs list.

     The access check is performed on the security descriptor for the
     specified computer given the passed-in lists of SIDs.

Arguments:

    DomainInfo - Hosted domain the logon is for.

    ComputerAccountId - The RID of the computer being logged into.

    SamSidList - The list of SIDs in the form of SAM data structure.
        These are the SIDs which have been expanded from the group
        membership in the validation info.

    SamSidCount - The number of SIDs in SamSidList.

    NlSidsAndAttributes - The list of SIDs in the form of Netlogon
        data structure. These are the SIDs from the extra SIDs
        field in the validation info.

    NlSidsAndAttributesCount - The number of SIDs in NlSidsAndAttributes.

Return Value:

    STATUS_SUCCESS - The access check succedded.

    STATUS_AUTHENTICATION_FIREWALL_FAILED - The access check failed.

    STATUS_INSUFFICIENT_RESOURCES - there wasn't enough memory to
        create the combined list of sids.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NET_API_STATUS NetStatus = NO_ERROR;
    ULONG SidAndAttributesCount = 0;
    PNETLOGON_SID_AND_ATTRIBUTES SidAndAttributes = NULL;
    ULONG Index = 0;

    PSID ComputerAccountSid = NULL;
    UNICODE_STRING ComputerAccountSidStr;
    PUSER_INTERNAL6_INFORMATION LocalUserInfo = NULL;
    SID_AND_ATTRIBUTES_LIST LocalMembership = {0};

    NL_AUTHZ_INFO AuthzInfo = {0};
    AUTHZ_ACCESS_REPLY Reply = {0};
    OBJECT_TYPE_LIST TypeList = {0};
    AUTHZ_CLIENT_CONTEXT_HANDLE hClientContext = NULL;
    AUTHZ_ACCESS_REQUEST Request = {0};
    DWORD AccessMask = 0;
    LUID ZeroLuid = {0,0};
    DWORD Error = ERROR_ACCESS_DENIED;

    //
    // Per the specification, the access check is only performed if the
    // "other org" SID is in the list. The SID can only appear in the
    //  ExtraSids list which is what passed as the netlogon SIDs.
    //

    for ( Index = 0; Index < NlSidsAndAttributesCount; Index++ ) {
        if ( RtlEqualSid(NlSidsAndAttributes[Index].Sid, OtherOrganizationSid) ) {
            break;
        }
    }

    //
    // If the Other Org SID is not there, there is nothing to check
    //

    if ( Index == NlSidsAndAttributesCount ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // OK, the Other Org SID is there, so proceed with the check.
    //
    // Allocate memory to hold all the SIDs in a common structure
    //  that AuthZ proper understands
    //

    //
    // add everyone and authenticated users (note guess fallback should not
    // have the OtherOrg sid, therefore should not get this far)
    //

    SidAndAttributesCount = SamSidCount + NlSidsAndAttributesCount + 2;
    SidAndAttributes = LocalAlloc( LMEM_ZEROINIT,
                                   SidAndAttributesCount * sizeof(NETLOGON_SID_AND_ATTRIBUTES) );
    if ( SidAndAttributes == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Convert the SIDs from the SAM structure into the Netlogon
    //  structure that AuthZ proper understands
    //

    SidAndAttributesCount = 0;
    for ( Index = 0; Index < SamSidCount; Index++ ) {
        SidAndAttributes[SidAndAttributesCount].Sid = (PSID) SamSidList->Sids[Index].SidPointer;
        SidAndAttributes[SidAndAttributesCount].Attributes = SE_GROUP_MANDATORY |
                                                             SE_GROUP_ENABLED |
                                                             SE_GROUP_ENABLED_BY_DEFAULT;
        SidAndAttributesCount ++;
    }

    //
    // Copy the SIDs from the Netlogon passed-in structure
    //  into the common array
    //

    for ( Index = 0; Index < NlSidsAndAttributesCount; Index++ ) {
        SidAndAttributes[SidAndAttributesCount] = NlSidsAndAttributes[Index];
        SidAndAttributesCount ++;
    }

    SidAndAttributes[SidAndAttributesCount].Sid = WorldSid;
    SidAndAttributes[SidAndAttributesCount].Attributes = SE_GROUP_MANDATORY |
                                                         SE_GROUP_ENABLED |
                                                         SE_GROUP_ENABLED_BY_DEFAULT;
    SidAndAttributesCount ++;

    SidAndAttributes[SidAndAttributesCount].Sid = AuthenticatedUserSid;
    SidAndAttributes[SidAndAttributesCount].Attributes = SE_GROUP_MANDATORY |
                                                         SE_GROUP_ENABLED |
                                                         SE_GROUP_ENABLED_BY_DEFAULT;

    SidAndAttributesCount ++; 

    //
    // Set the AuthZ info for use by the AuthZ callback routine
    //

    AuthzInfo.SidAndAttributes = SidAndAttributes;
    AuthzInfo.SidCount = SidAndAttributesCount;

    //
    // Get the computer account SID from the RID
    //

    NetStatus = NetpDomainIdToSid( DomainInfo->DomAccountDomainId,
                                   ComputerAccountId,
                                   &ComputerAccountSid );

    if ( NetStatus != ERROR_SUCCESS ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Retrieve the workstation machine account Security Descriptor
    //  to be checked for access. Using the SID as the input yields
    //  the fastest search.
    //
    // We have to do this on every logon as the SD can change. There
    //  is no notification mechanism for SD changes. Kerberos has been
    //  doing this search on every logon and it hasn't been a big
    //  perf hit so far.
    //

    ComputerAccountSidStr.Buffer = ComputerAccountSid;
    ComputerAccountSidStr.MaximumLength =
        ComputerAccountSidStr.Length = (USHORT) RtlLengthSid( ComputerAccountSid );

    Status = SamIGetUserLogonInformation2(
                  DomainInfo->DomSamAccountDomainHandle,
                  SAM_NO_MEMBERSHIPS |  // Don't need group memberships
                      SAM_OPEN_BY_SID,  // Next parameter is the SID of the account
                  &ComputerAccountSidStr,
                  USER_ALL_SECURITYDESCRIPTOR, // Only need the security descriptor
                  0,                    // no extended fields
                  &LocalUserInfo,
                  &LocalMembership,
                  NULL );

    if ( !NT_SUCCESS(Status) ) {
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyAllowedToAuthenticate: SamIGetUserLogonInformation2 failed 0x%lx\n",
                  Status ));
        goto Cleanup;
    }

    //
    // Now initialize the AuthZ client context
    //

    if ( !AuthzInitializeContextFromSid(
             AUTHZ_SKIP_TOKEN_GROUPS, // take the SIDs as they are
             AuthzInfo.SidAndAttributes[0].Sid, // userid is first element in array
             NlAuthzRM,
             NULL,
             ZeroLuid,
             &AuthzInfo,
             &hClientContext) ) {

        NetStatus = GetLastError();
        NlPrint(( NL_CRITICAL,
                  "NlpVerifyAllowedToAuthenticate: AuthzInitializeContextFromSid failed 0x%lx\n",
                  NetStatus ));
        Status = NetpApiStatusToNtStatus( NetStatus );
        goto Cleanup;
    }

    //
    // Perform the access check
    //

    TypeList.Level = ACCESS_OBJECT_GUID;
    TypeList.ObjectType = &GUID_A_SECURED_FOR_CROSS_ORGANIZATION;
    TypeList.Sbz = 0;

    Request.DesiredAccess = ACTRL_DS_CONTROL_ACCESS; // ACTRL_DS_READ_PROP
    Request.ObjectTypeList = &TypeList;
    Request.ObjectTypeListLength = 1;
    Request.OptionalArguments = NULL;
    Request.PrincipalSelfSid = NULL;

    Reply.ResultListLength = 1;    // all or nothing w.r.t. access check.
    Reply.GrantedAccessMask = &AccessMask;
    Reply.Error = &Error;

    if ( !AuthzAccessCheck(
             0,
             hClientContext,
             &Request,
             NULL, // TBD:  add audit
             LocalUserInfo->I1.SecurityDescriptor.SecurityDescriptor,
             NULL,
             0,
             &Reply,
             NULL) ) { // don't cache result?  Check to see if optimal.

        NetStatus = GetLastError();
        NlPrint(( NL_CRITICAL,
            "NlpVerifyAllowedToAuthenticate: AuthzAccessCheck failed unexpectedly 0x%lx\n",
            NetStatus ));
        Status = NetpApiStatusToNtStatus( NetStatus );

    } else if ( (*Reply.Error) != ERROR_SUCCESS ) {

        NlPrint(( NL_LOGON,
          "NlpVerifyAllowedToAuthenticate: AuthzAccessCheck failed 0x%lx\n",
          *Reply.Error ));

        Status = STATUS_AUTHENTICATION_FIREWALL_FAILED;

    } else {

        Status = STATUS_SUCCESS;
    }

Cleanup:

    if ( SidAndAttributes != NULL ) {
        LocalFree( SidAndAttributes );
    }

    if ( ComputerAccountSid != NULL ) {
        NetpMemoryFree( ComputerAccountSid );
    }

    if ( hClientContext != NULL ) {
        AuthzFreeContext( hClientContext );
    }

    if ( LocalUserInfo != NULL ) {
        SamIFree_UserInternal6Information( LocalUserInfo );
    }

    SamIFreeSidAndAttributesList( &LocalMembership );

    return Status;
}


NTSTATUS
NlpExpandResourceGroupMembership(
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT PNETLOGON_VALIDATION_SAM_INFO4 * UserInfo,
    IN PDOMAIN_INFO DomainInfo,
    IN ULONG ComputerAccountId
    )
/*++

Routine Description:

    Given the validation information for a user, expands the group member-
    ships and user id into a list of sids.

    Also, performs an access check to determine whether the specified
    user can logon to the specified computer when Other Org trust link
    was traversed in the course of the logon validation.

Arguments:

    ValidationLevel -- Specifies the level of information passed as input in
        UserInfo.  Must be NetlogonValidationSamInfo or
        NetlogonValidationSamInfo2, NetlogonValidationSamInfo4

        NetlogonValidationSamInfo4 is always returned on output.

    UserInfo - user's validation information
        This structure is updated to include the resource groups that the user is a member of

    DomainInfo - Structure identifying the hosted domain used to determine the group membership.

    ComputerAccountId - The ID of the computer account for the workstation that passed the
        logon to this domain controller.

Return Value:


    STATUS_INSUFFICIENT_RESOURCES - there wasn't enough memory to
        create the list of sids.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_PSID_ARRAY SidList = {0};
    PSAMPR_PSID_ARRAY ResourceGroups = NULL;

    ULONG Index;
    ULONG NonExtraSidCount = 0;

    Status = NlpBuildPacSidList( *UserInfo,
                                 &SidList,
                                 &NonExtraSidCount );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    //
    // Call SAM to get the sids
    //

    Status = SamIGetResourceGroupMembershipsTransitive(
                DomainInfo->DomSamAccountDomainHandle,
                &SidList,
                0,              // no flags
                &ResourceGroups
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Build a new validation information structure
    //

    if (ResourceGroups->Count != 0) {

        Status = NlpAddResourceGroupsToSamInfo(
                    ValidationLevel,
                    UserInfo,
                    ResourceGroups
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
    }

    //
    // If we have the user ID, ensure this user has the access to
    //  authenticate to the computer that sent this logon to us.
    //  Do this check only if all DCs in the domain are doing this
    //  check (all DCs are .NET or higher) to ensure the consistent
    //  behavior.
    //

    if ( (*UserInfo)->UserId != 0 &&
         ComputerAccountId != 0 &&
         LsaINoMoreWin2KDomain() ) {

        Status = NlpVerifyAllowedToAuthenticate( DomainInfo,
                                                 ComputerAccountId,
                                                 &SidList,
                                                 NonExtraSidCount,
                                                 (*UserInfo)->ExtraSids,
                                                 (*UserInfo)->SidCount );
    }

Cleanup:

    SamIFreeSidArray(
        ResourceGroups
        );

    if (SidList.Sids != NULL) {
        for (Index = 0; Index < SidList.Count ;Index++ ) {
            if (SidList.Sids[Index].SidPointer != NULL) {
                MIDL_user_free(SidList.Sids[Index].SidPointer);
            }
        }
        MIDL_user_free(SidList.Sids);
    }

    return(Status);
}

NTSTATUS
NlpAddOtherOrganizationSid (
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    IN OUT PNETLOGON_VALIDATION_SAM_INFO4 *ValidationInformation
    )
/*++

Routine Description:

    This routine adds the Other Org SID to the extra SIDs field of
    the passed in validation info.

Arguments:

    ValidationLevel -- Specifies the level of information passed as input in
        ValidationInformation.  Must beNetlogonValidationSamInfo2 or
        NetlogonValidationSamInfo4.

    ValidationInformation -- Specifies the NETLOGON_VALIDATION_SAM_INFO
        to add the OtherOrg SID to.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES: not enough memory to allocate the new
        structure.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;
    SAMPR_PSID_ARRAY SidArray = {0};
    SAMPR_SID_INFORMATION Sid = {0};

    //
    // Check if the OtherOrg SID is already there
    //

    for ( Index = 0;
          Index < (*ValidationInformation)->SidCount;
          Index++ ) {

        //
        // If the Other Org SID is already there, there is nothing to add
        //

        if ( RtlEqualSid((*ValidationInformation)->ExtraSids[Index].Sid,
                         OtherOrganizationSid) ) {

            return STATUS_SUCCESS;
        }
    }

    //
    // Add the OtherOrg SID
    //

    SidArray.Count = 1;
    SidArray.Sids = &Sid;
    Sid.SidPointer = OtherOrganizationSid; // well known SID

    Status = NlpAddResourceGroupsToSamInfo(
                        ValidationLevel,
                        ValidationInformation,
                        &SidArray );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\replutil.h ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    replutil.h

Abstract:

    Low level functions for SSI Replication apis

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    22-Jul-1991 (cliffv)
        Ported to NT.  Converted to NT style.

--*/

//
// Description of the FullSync key in the registry.  The FullSync key stores sync
// data in the registry across reboots.
//

#define NL_FULL_SYNC_KEY "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\FullSync"

#ifdef _DC_NETLOGON
//
// replutil.c
//

DWORD
NlCopyUnicodeString (
    IN PUNICODE_STRING InString,
    OUT PUNICODE_STRING OutString
    );

DWORD
NlCopyData(
    IN LPBYTE *InData,
    OUT LPBYTE *OutData,
    DWORD DataLength
    );

VOID
NlFreeDBDelta(
    IN PNETLOGON_DELTA_ENUM Delta
    );

VOID
NlFreeDBDeltaArray(
    IN PNETLOGON_DELTA_ENUM DeltaArray,
    IN DWORD ArraySize
    );

NTSTATUS
NlPackSamUser (
    IN ULONG RelativeId,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    OUT LPDWORD BufferSize,
    IN PSESSION_INFO SessionInfo
    );

NTSTATUS
NlPackSamGroup (
    IN ULONG RelativeId,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    LPDWORD BufferSize
    );

NTSTATUS
NlPackSamGroupMember (
    IN ULONG RelativeId,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    LPDWORD BufferSize
    );

NTSTATUS
NlPackSamAlias (
    IN ULONG RelativeId,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    LPDWORD BufferSize
    );

NTSTATUS
NlPackSamAliasMember (
    IN ULONG RelativeId,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    LPDWORD BufferSize
    );

NTSTATUS
NlPackSamDomain (
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize
    );

NTSTATUS
NlEncryptSensitiveData(
    IN OUT PCRYPT_BUFFER Data,
    IN PSESSION_INFO SessionInfo
    );

#endif _DC_NETLOGON
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\oldstub.c ===
/*++

Copyright (c) 1994-1996 Microsoft Corporation

Module Name:

    oldstub.c

Abstract:

    This file contains functions generated by midl v1.0.  These
    functions were designed to only be called by the stubs, but
    these paticular functions are called by user code.  This
    file is needed in order to compile with midl v2.0 which
    doesn't generated these paticular functions anymore.

Author:

    Mario Goertzel      (MarioGo)    Jan 10, 1994

Environment:

    User Mode - Win32

Revision History:


--*/


//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

/* routine that frees graph for struct _UNICODE_STRING */
void _fgs__UNICODE_STRING (UNICODE_STRING  * _source)
  {
  if (_source->Buffer !=0)
    {
    SamLsaFreeMemory((void  *)(_source->Buffer));
    }
  }

/* routine that frees graph for struct _NLPR_SID_ARRAY */
void _fgs__NLPR_SID_ARRAY (NLPR_SID_ARRAY  * _source)
  {
  if (_source->Sids !=0)
    {
    SamLsaFreeMemory((void  *)(_source->Sids));
    }
  }

/* routine that frees graph for struct _NLPR_CR_CIPHER_VALUE */
void _fgs__NLPR_CR_CIPHER_VALUE (NLPR_CR_CIPHER_VALUE  * _source)
  {
  if (_source->Buffer !=0)
    {
    SamLsaFreeMemory((void  *)(_source->Buffer));
    }
  }

/* routine that frees graph for struct _NLPR_LOGON_HOURS */
void _fgs__NLPR_LOGON_HOURS (NLPR_LOGON_HOURS  * _source)
  {
  if (_source->LogonHours !=0)
    {
    SamLsaFreeMemory((void  *)(_source->LogonHours));
    }
  }

/* routine that frees graph for struct _NLPR_USER_PRIVATE_INFO */
void _fgs__NLPR_USER_PRIVATE_INFO (NLPR_USER_PRIVATE_INFO  * _source)
  {
  if (_source->Data !=0)
    {
    SamLsaFreeMemory((void  *)(_source->Data));
    }
  }

/* routine that frees graph for struct _NETLOGON_DELTA_USER */
void _fgs__NETLOGON_DELTA_USER (NETLOGON_DELTA_USER  * _source)
  {
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->UserName);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->FullName);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->HomeDirectory);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->HomeDirectoryDrive);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->ScriptPath);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->AdminComment);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->WorkStations);
  _fgs__NLPR_LOGON_HOURS ((NLPR_LOGON_HOURS *)&_source->LogonHours);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->UserComment);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->Parameters);
  _fgs__NLPR_USER_PRIVATE_INFO ((NLPR_USER_PRIVATE_INFO *)&_source->PrivateData);
  if (_source->SecurityDescriptor !=0)
    {
    SamLsaFreeMemory((void  *)(_source->SecurityDescriptor));
    }
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString1);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString2);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString3);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString4);
  }

/* routine that frees graph for struct _NETLOGON_DELTA_GROUP */
void _fgs__NETLOGON_DELTA_GROUP (NETLOGON_DELTA_GROUP  * _source)
  {
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->Name);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->AdminComment);
  if (_source->SecurityDescriptor !=0)
    {
    SamLsaFreeMemory((void  *)(_source->SecurityDescriptor));
    }
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString1);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString2);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString3);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString4);
  }

/* routine that frees graph for struct _NETLOGON_DELTA_GROUP_MEMBER */
void _fgs__NETLOGON_DELTA_GROUP_MEMBER (NETLOGON_DELTA_GROUP_MEMBER  * _source)
  {
  if (_source->MemberIds !=0)
    {
    SamLsaFreeMemory((void  *)(_source->MemberIds));
    }
  if (_source->Attributes !=0)
    {
    SamLsaFreeMemory((void  *)(_source->Attributes));
    }
  }

/* routine that frees graph for struct _NETLOGON_DELTA_ALIAS */
void _fgs__NETLOGON_DELTA_ALIAS (NETLOGON_DELTA_ALIAS  * _source)
  {
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->Name);
  if (_source->SecurityDescriptor !=0)
    {
    SamLsaFreeMemory((void  *)(_source->SecurityDescriptor));
    }
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString1);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString2);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString3);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString4);
  }

/* routine that frees graph for struct _NETLOGON_DELTA_ALIAS_MEMBER */
void _fgs__NETLOGON_DELTA_ALIAS_MEMBER (NETLOGON_DELTA_ALIAS_MEMBER  * _source)
  {
  _fgs__NLPR_SID_ARRAY ((NLPR_SID_ARRAY *)&_source->Members);
  }

/* routine that frees graph for struct _NETLOGON_DELTA_DOMAIN */
void _fgs__NETLOGON_DELTA_DOMAIN (NETLOGON_DELTA_DOMAIN  * _source)
  {
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DomainName);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->OemInformation);
  if (_source->SecurityDescriptor !=0)
    {
    SamLsaFreeMemory((void  *)(_source->SecurityDescriptor));
    }
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString1);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString2);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString3);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString4);
  }

/* routine that frees graph for struct _NETLOGON_DELTA_RENAME */
void _fgs__NETLOGON_DELTA_RENAME (NETLOGON_RENAME_GROUP  * _source)
  {
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->OldName);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->NewName);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString1);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString2);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString3);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString4);
  }

/* routine that frees graph for struct _NETLOGON_DELTA_POLICY */
void _fgs__NETLOGON_DELTA_POLICY (NETLOGON_DELTA_POLICY  * _source)
  {
  if (_source->EventAuditingOptions !=0)
    {
    SamLsaFreeMemory((void  *)(_source->EventAuditingOptions));
    }
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->PrimaryDomainName);
  if (_source->PrimaryDomainSid !=0)
    {
    SamLsaFreeMemory((void  *)(_source->PrimaryDomainSid));
    }
  if (_source->SecurityDescriptor !=0)
    {
    SamLsaFreeMemory((void  *)(_source->SecurityDescriptor));
    }
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString1);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString2);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString3);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString4);
  }

/* routine that frees graph for struct _NETLOGON_DELTA_TRUSTED_DOMAINS */
void _fgs__NETLOGON_DELTA_TRUSTED_DOMAINS (NETLOGON_DELTA_TRUSTED_DOMAINS  * _source)
  {
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DomainName);
  if (_source->ControllerNames !=0)
    {
      {
      unsigned long _sym15;
      for (_sym15 = 0; _sym15 < (unsigned long )(0 + _source->NumControllerEntries); _sym15++)
        {
        _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->ControllerNames[_sym15]);
        }
      }
    SamLsaFreeMemory((void  *)(_source->ControllerNames));
    }
  if (_source->SecurityDescriptor !=0)
    {
    SamLsaFreeMemory((void  *)(_source->SecurityDescriptor));
    }
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString1);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString2);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString3);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString4);
  }

/* routine that frees graph for struct _NETLOGON_DELTA_ACCOUNTS */
void _fgs__NETLOGON_DELTA_ACCOUNTS (NETLOGON_DELTA_ACCOUNTS  * _source)
  {
  if (_source->PrivilegeAttributes !=0)
    {
    SamLsaFreeMemory((void  *)(_source->PrivilegeAttributes));
    }
  if (_source->PrivilegeNames !=0)
    {
      {
      unsigned long _sym21;
      for (_sym21 = 0; _sym21 < (unsigned long )(0 + _source->PrivilegeEntries); _sym21++)
        {
        _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->PrivilegeNames[_sym21]);
        }
      }
    SamLsaFreeMemory((void  *)(_source->PrivilegeNames));
    }
  if (_source->SecurityDescriptor !=0)
    {
    SamLsaFreeMemory((void  *)(_source->SecurityDescriptor));
    }
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString1);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString2);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString3);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString4);
  }

/* routine that frees graph for struct _NETLOGON_DELTA_SECRET */
void _fgs__NETLOGON_DELTA_SECRET (NETLOGON_DELTA_SECRET  * _source)
  {
  _fgs__NLPR_CR_CIPHER_VALUE ((NLPR_CR_CIPHER_VALUE *)&_source->CurrentValue);
  _fgs__NLPR_CR_CIPHER_VALUE ((NLPR_CR_CIPHER_VALUE *)&_source->OldValue);
  if (_source->SecurityDescriptor !=0)
    {
    SamLsaFreeMemory((void  *)(_source->SecurityDescriptor));
    }
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString1);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString2);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString3);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString4);
  }

// Written by CliffV since MIDL no longer generates these.
/* routine that frees graph for struct _NETLOGON_DELTA_DELETE */
void _fgs__NETLOGON_DELTA_DELETE (NETLOGON_DELTA_DELETE_USER  * _source)
  {
  SamLsaFreeMemory((void  *)(_source->AccountName));
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString1);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString2);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString3);
  _fgs__UNICODE_STRING ((UNICODE_STRING *)&_source->DummyString4);
  }


/* routine that frees graph for union _NETLOGON_DELTA_UNION */
void _fgu__NETLOGON_DELTA_UNION (NETLOGON_DELTA_UNION  * _source, NETLOGON_DELTA_TYPE _branch)
  {
  switch (_branch)
    {
    case AddOrChangeDomain :
      {
      if (_source->DeltaDomain !=0)
        {
        _fgs__NETLOGON_DELTA_DOMAIN ((NETLOGON_DELTA_DOMAIN *)_source->DeltaDomain);
        SamLsaFreeMemory((void  *)(_source->DeltaDomain));
        }
      break;
      }
    case AddOrChangeGroup :
      {
      if (_source->DeltaGroup !=0)
        {
        _fgs__NETLOGON_DELTA_GROUP ((NETLOGON_DELTA_GROUP *)_source->DeltaGroup);
        SamLsaFreeMemory((void  *)(_source->DeltaGroup));
        }
      break;
      }
    case RenameGroup :
      {
      if (_source->DeltaRenameGroup !=0)
        {
        _fgs__NETLOGON_DELTA_RENAME ((NETLOGON_RENAME_GROUP *)_source->DeltaRenameGroup);
        SamLsaFreeMemory((void  *)(_source->DeltaRenameGroup));
        }
      break;
      }
    case AddOrChangeUser :
      {
      if (_source->DeltaUser !=0)
        {
        _fgs__NETLOGON_DELTA_USER ((NETLOGON_DELTA_USER *)_source->DeltaUser);
        SamLsaFreeMemory((void  *)(_source->DeltaUser));
        }
      break;
      }
    case RenameUser :
      {
      if (_source->DeltaRenameUser !=0)
        {
        _fgs__NETLOGON_DELTA_RENAME ((NETLOGON_RENAME_GROUP *)_source->DeltaRenameUser);
        SamLsaFreeMemory((void  *)(_source->DeltaRenameUser));
        }
      break;
      }
    case ChangeGroupMembership :
      {
      if (_source->DeltaGroupMember !=0)
        {
        _fgs__NETLOGON_DELTA_GROUP_MEMBER ((NETLOGON_DELTA_GROUP_MEMBER *)_source->DeltaGroupMember);
        SamLsaFreeMemory((void  *)(_source->DeltaGroupMember));
        }
      break;
      }
    case AddOrChangeAlias :
      {
      if (_source->DeltaAlias !=0)
        {
        _fgs__NETLOGON_DELTA_ALIAS ((NETLOGON_DELTA_ALIAS *)_source->DeltaAlias);
        SamLsaFreeMemory((void  *)(_source->DeltaAlias));
        }
      break;
      }
    case RenameAlias :
      {
      if (_source->DeltaRenameAlias !=0)
        {
        _fgs__NETLOGON_DELTA_RENAME ((NETLOGON_RENAME_GROUP *)_source->DeltaRenameAlias);
        SamLsaFreeMemory((void  *)(_source->DeltaRenameAlias));
        }
      break;
      }
    case ChangeAliasMembership :
      {
      if (_source->DeltaAliasMember !=0)
        {
        _fgs__NETLOGON_DELTA_ALIAS_MEMBER ((NETLOGON_DELTA_ALIAS_MEMBER *)_source->DeltaAliasMember);
        SamLsaFreeMemory((void  *)(_source->DeltaAliasMember));
        }
      break;
      }
    case AddOrChangeLsaPolicy :
      {
      if (_source->DeltaPolicy !=0)
        {
        _fgs__NETLOGON_DELTA_POLICY ((NETLOGON_DELTA_POLICY *)_source->DeltaPolicy);
        SamLsaFreeMemory((void  *)(_source->DeltaPolicy));
        }
      break;
      }
    case AddOrChangeLsaTDomain :
      {
      if (_source->DeltaTDomains !=0)
        {
        _fgs__NETLOGON_DELTA_TRUSTED_DOMAINS ((NETLOGON_DELTA_TRUSTED_DOMAINS *)_source->DeltaTDomains);
        SamLsaFreeMemory((void  *)(_source->DeltaTDomains));
        }
      break;
      }
    case AddOrChangeLsaAccount :
      {
      if (_source->DeltaAccounts !=0)
        {
        _fgs__NETLOGON_DELTA_ACCOUNTS ((NETLOGON_DELTA_ACCOUNTS *)_source->DeltaAccounts);
        SamLsaFreeMemory((void  *)(_source->DeltaAccounts));
        }
      break;
      }
    case AddOrChangeLsaSecret :
      {
      if (_source->DeltaSecret !=0)
        {
        _fgs__NETLOGON_DELTA_SECRET ((NETLOGON_DELTA_SECRET *)_source->DeltaSecret);
        SamLsaFreeMemory((void  *)(_source->DeltaSecret));
        }
      break;
      }
    case DeleteUserByName:
    case DeleteGroupByName:
      if (_source->DeltaDeleteUser !=0) {
        _fgs__NETLOGON_DELTA_DELETE ((NETLOGON_DELTA_DELETE_USER *)_source->DeltaDeleteUser);
        SamLsaFreeMemory((void  *)(_source->DeltaDeleteUser));
      }
      break;
    case SerialNumberSkip:
      if (_source->DeltaSerialNumberSkip !=0) {
        SamLsaFreeMemory((void  *)(_source->DeltaSerialNumberSkip));
      }
      break;
    default :
      {
      break;
      }
    }
  }

/* routine that frees graph for union _NETLOGON_DELTA_ID_UNION */
void _fgu__NETLOGON_DELTA_ID_UNION (NETLOGON_DELTA_ID_UNION  * _source, NETLOGON_DELTA_TYPE _branch)
  {
  switch (_branch)
    {
    case AddOrChangeLsaPolicy :
    case AddOrChangeLsaTDomain :
    case DeleteLsaTDomain :
    case AddOrChangeLsaAccount :
    case DeleteLsaAccount :
      {
      if (_source->Sid !=0)
        {
        SamLsaFreeMemory((void  *)(_source->Sid));
        }
      break;
      }
    case AddOrChangeLsaSecret :
    case DeleteLsaSecret :
      {
      if (_source->Name !=0)
        {
        SamLsaFreeMemory((void  *)(_source->Name));
        }
      break;
      }
    default :
      {
      break;
      }
    }
  }

/* routine that frees graph for struct _NETLOGON_DELTA_ENUM */
void _fgs__NETLOGON_DELTA_ENUM (NETLOGON_DELTA_ENUM  * _source)
  {
  _fgu__NETLOGON_DELTA_ID_UNION ((NETLOGON_DELTA_ID_UNION *)&_source->DeltaID, _source->DeltaType);
  _fgu__NETLOGON_DELTA_UNION ((NETLOGON_DELTA_UNION *)&_source->DeltaUnion, _source->DeltaType);
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\nltrace.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    NLTRACE.C

Abstract:

    Implement Netlogon Server event tracing by using WMI trace infrastructure.

Author:

    16-Mar-1999  KahrenT

Note:

    This code has been stolen from \nt\private\ds\src\newsam2\server\samtrace.c

Revision History:


--*/

#include "logonsrv.h"

#define RESOURCE_NAME __TEXT("MofResource")
#define IMAGE_PATH    __TEXT("netlogon.dll")

ULONG           NlpEventTraceFlag = FALSE;
TRACEHANDLE     NlpTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE     NlpTraceLoggerHandle = (TRACEHANDLE) 0;


//
// Forward declaration
//

ULONG
NlpTraceControlCallBack(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

//
// The following table contains the address of event trace GUID.
// We should always update NLPTRACE_GUID (enum type defined in logonsrv.h)
// whenever we add new event trace GUID for NetLogon
//

TRACE_GUID_REGISTRATION NlpTraceGuids[] =
{
    {&NlpServerAuthGuid,         NULL},
    {&NlpSecureChannelSetupGuid, NULL}
};


#define NlpGuidCount (sizeof(NlpTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))


ULONG
_stdcall
NlpInitializeTrace(
    PVOID Param
    )
/*++
Routine Description:

    Register WMI Trace Guids.  Note that there is no
    need to wait for WMI service because it has been
    brought into ntos kernel.

Parameters:

    None.

Reture Values:

    None.

--*/
{
    ULONG   Status = ERROR_SUCCESS;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

    //
    // Get the name of the image file
    //

    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }

    //
    // Register Trace GUIDs
    //

    Status = RegisterTraceGuids(
                    NlpTraceControlCallBack,
                    NULL,
                    &NlpControlGuid,
                    NlpGuidCount,
                    NlpTraceGuids,
                    FileName,
                    RESOURCE_NAME,
                    &NlpTraceRegistrationHandle);

    if ( Status != ERROR_SUCCESS ) {
        NlPrint((NL_CRITICAL, "NlpInitializeTrace Failed %d\n", Status));
    } else {
        NlPrint((NL_MISC, "NlpInitializeTrace succeeded %d\n", Status));
    }

    return Status;

UNREFERENCED_PARAMETER( Param );
}


ULONG
NlpTraceControlCallBack(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
/*++

Routine Description:

Parameters:

Return Values:

--*/
{

    PWNODE_HEADER   Wnode = (PWNODE_HEADER) Buffer;
    ULONG   Status = ERROR_SUCCESS;
    ULONG   RetSize;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            NlpTraceLoggerHandle = GetTraceLoggerHandle(Buffer);
            NlpEventTraceFlag = 1;     // enable flag
            RetSize = 0;
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            NlpTraceLoggerHandle = (TRACEHANDLE) 0;
            NlpEventTraceFlag = 0;     // disable flag
            RetSize = 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    *InOutBufferSize = RetSize;
    return Status;

UNREFERENCED_PARAMETER( RequestContext );
}


VOID
NlpTraceEvent(
    IN ULONG WmiEventType,
    IN ULONG TraceGuid
    )
/*++

Routine Description:

    This routine will do a WMI event trace. No parameters will be output.

Parameters:

    WmiEventType - Event Type, valid values are:
                   EVENT_TRACE_TYPE_START
                   EVENT_TRACE_TYPE_END

    TraceGuid - Index in NlpTraceGuids[]

Return Values:

    None.

--*/

{
    ULONG   WinError = ERROR_SUCCESS;
    EVENT_TRACE_HEADER EventTrace;

    if (NlpEventTraceFlag) {

        //
        // Fill the event information.
        //

        memset(&EventTrace, 0, sizeof(EVENT_TRACE_HEADER));

        EventTrace.GuidPtr = (ULONGLONG) NlpTraceGuids[TraceGuid].Guid;

        EventTrace.Class.Type = (UCHAR) WmiEventType;

        EventTrace.Flags |= (WNODE_FLAG_USE_GUID_PTR |  // GUID is actually a pointer
                             WNODE_FLAG_TRACED_GUID);   // denotes a trace

        EventTrace.Size = sizeof(EVENT_TRACE_HEADER);   // no other parameters/information

        WinError = TraceEvent(NlpTraceLoggerHandle, &EventTrace);

        if ( WinError != ERROR_SUCCESS ) {
            NlPrint(( NL_CRITICAL, "NlpTraceEvent Error 0x%x for TraceGuid %d\n",
                      WinError, TraceGuid ));
        }

    }

    return;
}

typedef struct _NL_SERVERAUTH_EVENT_INFO {
    EVENT_TRACE_HEADER EventTrace;
    MOF_FIELD eventInfo[5];  // the current limit is 8 MOF fields
} NL_SERVERAUTH_EVENT_INFO, *PNL_SERVERAUTH_EVENT_INFO;

VOID
NlpTraceServerAuthEvent(
    IN ULONG WmiEventType,
    IN LPWSTR ComputerName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PULONG NegotiatedFlags,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine will do a WMI event trace on the trusted side DC for a secure
    channel setup initiated by the trusting side.

Parameters:

    WmiEventType -- Event Type, valid values are:
        EVENT_TRACE_TYPE_START
        EVENT_TRACE_TYPE_END

    ComputerName -- Name of the trusting side computer setting up the secure channel

    AccountName -- Name of the Account used by ComputerName

    SecureChannelType -- The type of the account being used by ComputerName

    NegotiatedFlags -- Specifies flags indicating what features ComputerName or we support.
        If WmiEventType is EVENT_TRACE_TYPE_START, this is flags supplied by ComputerName
        If WmiEventType is EVENT_TRACE_TYPE_END, this is flags returned by us

    Status -- The status of the authentication performed by the trusted side (us).
        Ignored if this is a start of the event.

Return Values:

    None

--*/

{
    //
    // Log event only if tracing is turned on
    //

    if ( NlpEventTraceFlag ) {
        ULONG   WinError = ERROR_SUCCESS;
        NL_SERVERAUTH_EVENT_INFO EventTraceInfo;

        //
        // Fill the event information.
        //

        RtlZeroMemory( &EventTraceInfo, sizeof(EventTraceInfo) );
        EventTraceInfo.EventTrace.GuidPtr = (ULONGLONG) NlpTraceGuids[NlpGuidServerAuth].Guid;
        EventTraceInfo.EventTrace.Class.Type = (UCHAR) WmiEventType;
        EventTraceInfo.EventTrace.Flags |= (WNODE_FLAG_USE_GUID_PTR |
                                            WNODE_FLAG_USE_MOF_PTR |
                                            WNODE_FLAG_TRACED_GUID);
        EventTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER);

        //
        // Build ComputerName (ItemWString)
        //

        EventTraceInfo.eventInfo[0].DataPtr = (ULONGLONG) ComputerName;
        EventTraceInfo.eventInfo[0].Length = (wcslen(ComputerName) + 1) * sizeof(WCHAR);
        EventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD);

        //
        // Build AccountName (ItemWString)
        //

        EventTraceInfo.eventInfo[1].DataPtr = (ULONGLONG) AccountName;
        EventTraceInfo.eventInfo[1].Length = (wcslen(AccountName) + 1) * sizeof(WCHAR);
        EventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD);

        //
        // Build SecureChannelType (ItemULongX)
        //

        EventTraceInfo.eventInfo[2].DataPtr = (ULONGLONG) &SecureChannelType;
        EventTraceInfo.eventInfo[2].Length = sizeof(SecureChannelType);
        EventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD);

        //
        // Build NegotiatedFlags (ItemULongX)
        //

        EventTraceInfo.eventInfo[3].DataPtr = (ULONGLONG) NegotiatedFlags;
        EventTraceInfo.eventInfo[3].Length = sizeof(*NegotiatedFlags);
        EventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD);

        //
        // Build Status (ItemULongX)
        //

        if ( WmiEventType == EVENT_TRACE_TYPE_END ) {
            EventTraceInfo.eventInfo[4].DataPtr = (ULONGLONG) &Status;
            EventTraceInfo.eventInfo[4].Length = sizeof(Status);
            EventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD);
        }

        WinError = TraceEvent(NlpTraceLoggerHandle, (PEVENT_TRACE_HEADER)&EventTraceInfo);

        if ( WinError != ERROR_SUCCESS ) {
            NlPrint(( NL_CRITICAL, "NlpTraceServerAuthEvent: TraceEvent failed 0x%lx\n",
                      WinError ));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\parse.c ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    parse.c

Abstract:

    Routine to parse the command line.

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    01-Aug-1991 (cliffv)
        Ported to NT.  Converted to NT style.
    09-May-1992 JohnRo
        Enable use of win32 registry.
        Use net config helpers for NetLogon.
        Fixed UNICODE bug handling debug file name.
        Use <prefix.h> equates.

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

#include <configp.h>    // USE_WIN32_CONFIG (if defined), etc.
#include <prefix.h>     // PREFIX_ equates.

//
// Include files specific to this .c file
//

#include <string.h>     // strnicmp

NET_API_STATUS
NlParseOne(
    IN LPNET_CONFIG_HANDLE SectionHandle,
    IN BOOL GpSection,
    IN LPWSTR Keyword,
    IN ULONG DefaultValue,
    IN ULONG MinimumValue,
    IN ULONG MaximumValue,
    OUT PULONG Value
    )
/*++

Routine Description:

    Get a single numeric parameter from the netlogon section of the registry.

Arguments:

    SectionHandle - Handle into the registry.

    GpSection - TRUE iff the section is the group policy section.

    Keyword - Name of the value to read.

    DefaultValue - Default value if parameter doesn't exist.

    MinimumValue - Minumin valid value.

    MaximumValue - Maximum valid value.

    Value - Returns the value parsed.

Return Value:

    Status of the operation

--*/
{
    NET_API_STATUS NetStatus;
    LPWSTR ValueT = NULL;

    //
    // Always return a reasonable value.
    //
    *Value = DefaultValue;

    //
    // Determine if the value is specified in the registry at all.
    //

    NetStatus = NetpGetConfigValue (
            SectionHandle,
            Keyword,
            &ValueT );

    if( ValueT != NULL ) {
        NetApiBufferFree( ValueT );
        ValueT = NULL;
    }

    //
    // If the value wasn't specified,
    //  use the default.
    //

    if ( NetStatus == NERR_CfgParamNotFound ) {
        *Value = DefaultValue;

    //
    // If the value was specifed,
    //  get it from the registry.
    //

    } else {

        NetStatus = NetpGetConfigDword (
                SectionHandle,
                Keyword,      // keyword wanted
                DefaultValue,
                Value );

        if (NetStatus == NO_ERROR) {
            if ( *Value > MaximumValue || *Value < MinimumValue ) {
                ULONG InvalidValue;
                LPWSTR MsgStrings[6];
                // Each byte of the status code will transform into one character 0-F
                WCHAR  InvalidValueString[sizeof(WCHAR) * (sizeof(InvalidValue) + 1)];
                WCHAR  MinimumValueString[sizeof(WCHAR) * (sizeof(MinimumValue) + 1)];
                WCHAR  MaximumValueString[sizeof(WCHAR) * (sizeof(MaximumValue) + 1)];
                WCHAR  AssignedValueString[sizeof(WCHAR) * (sizeof(*Value) + 1)];

                InvalidValue = *Value;

                if ( *Value > MaximumValue ) {
                    *Value = MaximumValue;
                } else if ( *Value < MinimumValue ) {
                    *Value = MinimumValue;
                }

                swprintf( InvalidValueString, L"%lx", InvalidValue );
                swprintf( MinimumValueString, L"%lx", MinimumValue );
                swprintf( MaximumValueString, L"%lx", MaximumValue );
                swprintf( AssignedValueString, L"%lx", *Value );

                if ( GpSection ) {
                    MsgStrings[0] = L"Group Policy";
                } else {
                    MsgStrings[0] = L"Parameters";
                }

                MsgStrings[1] = InvalidValueString;
                MsgStrings[2] = Keyword;
                MsgStrings[3] = MinimumValueString;
                MsgStrings[4] = MaximumValueString;
                MsgStrings[5] = AssignedValueString;

                NlpWriteEventlog( NELOG_NetlogonInvalidDwordParameterValue,
                                  EVENTLOG_WARNING_TYPE,
                                  NULL,
                                  0,
                                  MsgStrings,
                                  6 );

            }

        } else {
            return NetStatus;

        }
    }

    return NERR_Success;
}



NET_API_STATUS
NlParseOnePath(
    IN LPNET_CONFIG_HANDLE SectionHandle,
    IN LPWSTR Keyword,
    IN LPWSTR DefaultValue1 OPTIONAL,
    OUT LPWSTR *Value
    )
/*++

Routine Description:

    Get a single path parameter from the netlogon section of the registry.

Arguments:

    SectionHandle - Handle into the registry.

    Keyword - Name of the value to read.

    DefaultValue1 - Default value if parameter doesn't exist.
        If NULL, Value will be set to NULL to indicate there is no default.

    Value - Returns the value parsed.
        Must be freed using NetApiBufferFree.

Return Value:

    Status of the operation

--*/
{
    NET_API_STATUS NetStatus;
    WCHAR OutPathname[MAX_PATH+1];
    WCHAR TempPathname[MAX_PATH*2+1];
    LPWSTR ValueT = NULL;
    ULONG type;

    //
    // Get the configured parameter
    //

    *Value = NULL;
    NetStatus = NetpGetConfigValue (
            SectionHandle,
            Keyword,   // key wanted
            &ValueT );                  // Must be freed by NetApiBufferFree().


    if (NetStatus != NO_ERROR) {
        //
        // Handle the default
        //
        if (NetStatus == NERR_CfgParamNotFound) {

            //
            // If there is no default,
            //  we're done.
            //

            if ( DefaultValue1 == NULL ) {
                *Value = NULL;
                NetStatus = NO_ERROR;
                goto Cleanup;
            }

            //
            // Build the default value.
            //

            ValueT = NetpAllocWStrFromWStr( DefaultValue1 );
            if ( ValueT == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

        } else {
            goto Cleanup;
        }
    }

    NlAssert( ValueT != NULL );

    //
    // Convert the configured sysvol path to a full pathname.
    //

    type = 0;   // Let the API figure out the type.
    NetStatus = I_NetPathCanonicalize( NULL,
                                       ValueT,
                                       OutPathname,
                                       sizeof(OutPathname),
                                       NULL,
                                       &type,
                                       0L );
    if (NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    if (type == ITYPE_PATH_ABSD) {
        NetpCopyTStrToWStr(TempPathname, OutPathname);
    } else if (type == ITYPE_PATH_RELND) {
        if ( !GetSystemWindowsDirectoryW(
                 TempPathname,
                 sizeof(TempPathname)/sizeof(WCHAR) ) ) {
            NetStatus = GetLastError();
            goto Cleanup;
        }
        wcscat( TempPathname, L"\\" );
        wcscat( TempPathname, OutPathname );
    } else {
        NetStatus = NERR_BadComponent;
        goto Cleanup;
    }

    //
    // Return the pathname in an allocated buffer
    //

    *Value = NetpAllocWStrFromWStr( TempPathname );

    if ( *Value == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }



Cleanup:
    if ( ValueT != NULL ) {
        (VOID) NetApiBufferFree( ValueT );
    }
    return NetStatus;

}


//
// Table of numeric parameters to parse.
//
#define getoffset( _x ) offsetof( NETLOGON_PARAMETERS, _x )
struct {
    LPWSTR Keyword;
    ULONG DefaultValue;
    ULONG MinimumValue;
    ULONG MaximumValue;
    ULONG ValueOffset;
    BOOLEAN ChangesDnsRegistration;
} ParseTable[] =
{
{ NETLOGON_KEYWORD_PULSE,                   DEFAULT_PULSE,                   MIN_PULSE,                   MAX_PULSE,                   getoffset( Pulse ),                   FALSE    },
{ NETLOGON_KEYWORD_RANDOMIZE,               DEFAULT_RANDOMIZE,               MIN_RANDOMIZE,               MAX_RANDOMIZE,               getoffset( Randomize ),               FALSE    },
{ NETLOGON_KEYWORD_PULSEMAXIMUM,            DEFAULT_PULSEMAXIMUM,            MIN_PULSEMAXIMUM,            MAX_PULSEMAXIMUM,            getoffset( PulseMaximum ),            FALSE    },
{ NETLOGON_KEYWORD_PULSECONCURRENCY,        DEFAULT_PULSECONCURRENCY,        MIN_PULSECONCURRENCY,        MAX_PULSECONCURRENCY,        getoffset( PulseConcurrency ),        FALSE    },
{ NETLOGON_KEYWORD_PULSETIMEOUT1,           DEFAULT_PULSETIMEOUT1,           MIN_PULSETIMEOUT1,           MAX_PULSETIMEOUT1,           getoffset( PulseTimeout1 ),           FALSE    },
{ NETLOGON_KEYWORD_PULSETIMEOUT2,           DEFAULT_PULSETIMEOUT2,           MIN_PULSETIMEOUT2,           MAX_PULSETIMEOUT2,           getoffset( PulseTimeout2 ),           FALSE    },
{ NETLOGON_KEYWORD_MAXIMUMMAILSLOTMESSAGES, DEFAULT_MAXIMUMMAILSLOTMESSAGES, MIN_MAXIMUMMAILSLOTMESSAGES, MAX_MAXIMUMMAILSLOTMESSAGES, getoffset( MaximumMailslotMessages ), FALSE    },
{ NETLOGON_KEYWORD_MAILSLOTMESSAGETIMEOUT,  DEFAULT_MAILSLOTMESSAGETIMEOUT,  MIN_MAILSLOTMESSAGETIMEOUT,  MAX_MAILSLOTMESSAGETIMEOUT,  getoffset( MailslotMessageTimeout ),  FALSE    },
{ NETLOGON_KEYWORD_MAILSLOTDUPLICATETIMEOUT,DEFAULT_MAILSLOTDUPLICATETIMEOUT,MIN_MAILSLOTDUPLICATETIMEOUT,MAX_MAILSLOTDUPLICATETIMEOUT,getoffset( MailslotDuplicateTimeout ),FALSE    },
{ NETLOGON_KEYWORD_EXPECTEDDIALUPDELAY,     DEFAULT_EXPECTEDDIALUPDELAY,     MIN_EXPECTEDDIALUPDELAY,     MAX_EXPECTEDDIALUPDELAY,     getoffset( ExpectedDialupDelay ),     FALSE    },
{ NETLOGON_KEYWORD_SCAVENGEINTERVAL,        DEFAULT_SCAVENGEINTERVAL,        MIN_SCAVENGEINTERVAL,        MAX_SCAVENGEINTERVAL,        getoffset( ScavengeInterval ),        FALSE    },
{ NETLOGON_KEYWORD_MAXIMUMPASSWORDAGE,      DEFAULT_MAXIMUMPASSWORDAGE,      MIN_MAXIMUMPASSWORDAGE,      MAX_MAXIMUMPASSWORDAGE,      getoffset( MaximumPasswordAge ),      FALSE    },
{ NETLOGON_KEYWORD_LDAPSRVPRIORITY,         DEFAULT_LDAPSRVPRIORITY,         MIN_LDAPSRVPRIORITY,         MAX_LDAPSRVPRIORITY,         getoffset( LdapSrvPriority ),         TRUE     },
{ NETLOGON_KEYWORD_LDAPSRVWEIGHT,           DEFAULT_LDAPSRVWEIGHT,           MIN_LDAPSRVWEIGHT,           MAX_LDAPSRVWEIGHT,           getoffset( LdapSrvWeight ),           TRUE     },
{ NETLOGON_KEYWORD_LDAPSRVPORT,             DEFAULT_LDAPSRVPORT,             MIN_LDAPSRVPORT,             MAX_LDAPSRVPORT,             getoffset( LdapSrvPort ),             TRUE     },
{ NETLOGON_KEYWORD_LDAPGCSRVPORT,           DEFAULT_LDAPGCSRVPORT,           MIN_LDAPGCSRVPORT,           MAX_LDAPGCSRVPORT,           getoffset( LdapGcSrvPort ),           TRUE     },
{ L"KdcSrvPort",                            DEFAULT_KDCSRVPORT,              MIN_KDCSRVPORT,              MAX_KDCSRVPORT,              getoffset( KdcSrvPort ),              TRUE     },
{ NETLOGON_KEYWORD_KERBISDDONEWITHJOIN,     DEFAULT_KERBISDDONEWITHJOIN,     MIN_KERBISDDONEWITHJOIN,     MAX_KERBISDDONEWITHJOIN,     getoffset( KerbIsDoneWithJoinDomainEntry),FALSE},
{ NETLOGON_KEYWORD_DNSTTL,                  DEFAULT_DNSTTL,                  MIN_DNSTTL,                  MAX_DNSTTL,                  getoffset( DnsTtl ),                  TRUE     },
{ NETLOGON_KEYWORD_DNSREFRESHINTERVAL,      DEFAULT_DNSREFRESHINTERVAL,      MIN_DNSREFRESHINTERVAL,      MAX_DNSREFRESHINTERVAL,      getoffset( DnsRefreshInterval ),      TRUE     },
{ L"CloseSiteTimeout",                      DEFAULT_CLOSESITETIMEOUT,        MIN_CLOSESITETIMEOUT,        MAX_CLOSESITETIMEOUT,        getoffset( CloseSiteTimeout ),        FALSE    },
{ L"SiteNameTimeout",                       DEFAULT_SITENAMETIMEOUT,         MIN_SITENAMETIMEOUT,         MAX_SITENAMETIMEOUT,         getoffset( SiteNameTimeout ),         FALSE    },
{ L"DuplicateEventlogTimeout",              DEFAULT_DUPLICATEEVENTLOGTIMEOUT,MIN_DUPLICATEEVENTLOGTIMEOUT,MAX_DUPLICATEEVENTLOGTIMEOUT,getoffset( DuplicateEventlogTimeout ),FALSE    },
{ L"MaxConcurrentApi",                      DEFAULT_MAXCONCURRENTAPI,        MIN_MAXCONCURRENTAPI,        MAX_MAXCONCURRENTAPI,        getoffset( MaxConcurrentApi ),        FALSE    },
{ L"NegativeCachePeriod",                     DEFAULT_NEGATIVECACHEPERIOD,       MIN_NEGATIVECACHEPERIOD,       MAX_NEGATIVECACHEPERIOD,       getoffset( NegativeCachePeriod ),       FALSE    },
{ L"BackgroundRetryInitialPeriod",            DEFAULT_BACKGROUNDRETRYINITIALPERIOD,MIN_BACKGROUNDRETRYINITIALPERIOD,MAX_BACKGROUNDRETRYINITIALPERIOD,getoffset( BackgroundRetryInitialPeriod ),FALSE    },
{ L"BackgroundRetryMaximumPeriod",            DEFAULT_BACKGROUNDRETRYMAXIMUMPERIOD,MIN_BACKGROUNDRETRYMAXIMUMPERIOD,MAX_BACKGROUNDRETRYMAXIMUMPERIOD,getoffset( BackgroundRetryMaximumPeriod ),FALSE    },
{ L"BackgroundRetryQuitTime",               DEFAULT_BACKGROUNDRETRYQUITTIME, MIN_BACKGROUNDRETRYQUITTIME, MAX_BACKGROUNDRETRYQUITTIME, getoffset( BackgroundRetryQuitTime ), FALSE    },
{ L"BackgroundSuccessfulRefreshPeriod",     DEFAULT_BACKGROUNDREFRESHPERIOD, MIN_BACKGROUNDREFRESHPERIOD, MAX_BACKGROUNDREFRESHPERIOD, getoffset( BackgroundSuccessfulRefreshPeriod ), FALSE    },
{ L"NonBackgroundSuccessfulRefreshPeriod",  DEFAULT_NONBACKGROUNDREFRESHPERIOD, MIN_NONBACKGROUNDREFRESHPERIOD, MAX_NONBACKGROUNDREFRESHPERIOD, getoffset( NonBackgroundSuccessfulRefreshPeriod ), FALSE    },
{ L"DnsFailedDeregisterTimeout",            DEFAULT_DNSFAILEDDEREGTIMEOUT, MIN_DNSFAILEDDEREGTIMEOUT, MAX_DNSFAILEDDEREGTIMEOUT, getoffset( DnsFailedDeregisterTimeout ), FALSE    },
{ L"MaxLdapServersPinged",                  DEFAULT_MAXLDAPSERVERSPINGED,  MIN_MAXLDAPSERVERSPINGED, MAX_MAXLDAPSERVERSPINGED, getoffset( MaxLdapServersPinged ), FALSE    },
{ L"SiteCoverageRefreshInterval",           DEFAULT_SITECOVERAGEREFRESHINTERVAL, MIN_SITECOVERAGEREFRESHINTERVAL, MAX_SITECOVERAGEREFRESHINTERVAL, getoffset( SiteCoverageRefreshInterval ), TRUE    },
{ L"FtInfoUpdateInterval",                  DEFAULT_FTINFO_UPDATE_INTERVAL,  MIN_FTINFO_UPDATE_INTERVAL,  MAX_FTINFO_UPDATE_INTERVAL, getoffset( FtInfoUpdateInterval ),  FALSE    },
#if NETLOGONDBG
{ NETLOGON_KEYWORD_DBFLAG,                  0,                               0,                           0xFFFFFFFF,                  getoffset( DbFlag ),                  FALSE    },
{ NETLOGON_KEYWORD_MAXIMUMLOGFILESIZE,      DEFAULT_MAXIMUM_LOGFILE_SIZE,    0,                           0xFFFFFFFF,                  getoffset( LogFileMaxSize ),          FALSE    },
#endif // NETLOGONDBG
};

//
// Table of boolean to parse.
//

struct {
    LPWSTR Keyword;
    BOOL DefaultValue;
    ULONG ValueOffset;
    BOOLEAN ChangesDnsRegistration;
} BoolParseTable[] =
{
#ifdef _DC_NETLOGON
{ NETLOGON_KEYWORD_REFUSEPASSWORDCHANGE,  DEFAULT_REFUSE_PASSWORD_CHANGE,  getoffset( RefusePasswordChange ),  FALSE },
{ NETLOGON_KEYWORD_ALLOWREPLINNONMIXED,   DEFAULT_ALLOWREPLINNONMIXED,     getoffset( AllowReplInNonMixed ),   FALSE },
{ L"AvoidSamRepl",                        TRUE,                            getoffset( AvoidSamRepl ),          FALSE },
{ L"AvoidLsaRepl",                        TRUE,                            getoffset( AvoidLsaRepl ),          FALSE },
{ L"SignSecureChannel",                   TRUE,                            getoffset( SignSecureChannel ),     FALSE },
{ L"SealSecureChannel",                   TRUE,                            getoffset( SealSecureChannel ),     FALSE },
{ L"RequireSignOrSeal",                   FALSE,                           getoffset( RequireSignOrSeal ),     FALSE },
{ L"RequireStrongKey",                    FALSE,                           getoffset( RequireStrongKey ),      FALSE },
{ L"SysVolReady",                         TRUE,                            getoffset( SysVolReady ),           FALSE },
{ L"UseDynamicDns",                       TRUE,                            getoffset( UseDynamicDns ),         TRUE  },
{ L"RegisterDnsARecords",                 TRUE,                            getoffset( RegisterDnsARecords ),   TRUE  },
{ L"AvoidPdcOnWan",                       FALSE,                           getoffset( AvoidPdcOnWan ),         FALSE },
{ L"AutoSiteCoverage",                    TRUE,                            getoffset( AutoSiteCoverage ),      TRUE  },
{ L"AvoidDnsDeregOnShutdown",             TRUE,                            getoffset(AvoidDnsDeregOnShutdown), TRUE  },
{ L"DnsUpdateOnAllAdapters",              FALSE,                           getoffset(DnsUpdateOnAllAdapters),  TRUE  },
{ NETLOGON_KEYWORD_NT4EMULATOR,           FALSE,                           getoffset(Nt4Emulator),             FALSE  },
#endif // _DC_NETLOGON
{ NETLOGON_KEYWORD_DISABLEPASSWORDCHANGE, DEFAULT_DISABLE_PASSWORD_CHANGE, getoffset( DisablePasswordChange ), FALSE },
{ NETLOGON_KEYWORD_NEUTRALIZENT4EMULATOR, FALSE,/* default is set later */ getoffset( NeutralizeNt4Emulator ), FALSE  },
{ L"AllowSingleLabelDnsDomain",           FALSE,                           getoffset(AllowSingleLabelDnsDomain), FALSE  },
{ L"AllowExclusiveSysvolShareAccess",     FALSE,                           getoffset(AllowExclusiveSysvolShareAccess), FALSE  },
{ L"AllowExclusiveScriptsShareAccess",    FALSE,                           getoffset(AllowExclusiveScriptsShareAccess), FALSE  },
{ L"AvoidLocatorAccountLookup",           FALSE,                           getoffset(AvoidLocatorAccountLookup), FALSE  },
};


VOID
NlParseRecompute(
    IN PNETLOGON_PARAMETERS NlParameters
    )
/*++

Routine Description:

    This routine recomputes globals that are simple functions of registry
    parameters.

Arguments:

    NlParameters - Structure describing all parameters

Return Value:

    None.

--*/
{
    ULONG RandomMinutes;

    //
    // Adjust values that are functions of each other.
    //

    if ( NlParameters->BackgroundRetryInitialPeriod < NlParameters->NegativeCachePeriod ) {
        NlParameters->BackgroundRetryInitialPeriod = NlParameters->NegativeCachePeriod;
    }
    if ( NlParameters->BackgroundRetryMaximumPeriod < NlParameters->BackgroundRetryInitialPeriod ) {
        NlParameters->BackgroundRetryMaximumPeriod = NlParameters->BackgroundRetryInitialPeriod;
    }
    if ( NlParameters->BackgroundRetryQuitTime != 0 &&
         NlParameters->BackgroundRetryQuitTime < NlParameters->BackgroundRetryMaximumPeriod ) {
        NlParameters->BackgroundRetryQuitTime = NlParameters->BackgroundRetryMaximumPeriod;
    }

    //
    // Convert from seconds to 100ns
    //
    NlParameters->PulseMaximum_100ns.QuadPart =
        Int32x32To64( NlParameters->PulseMaximum, 10000000 );
    NlParameters->PulseTimeout1_100ns.QuadPart =
        Int32x32To64( NlParameters->PulseTimeout1, 10000000 );
    NlParameters->PulseTimeout2_100ns.QuadPart =
        Int32x32To64( NlParameters->PulseTimeout2, 10000000 );
    NlParameters->MailslotMessageTimeout_100ns.QuadPart =
        Int32x32To64( NlParameters->MailslotMessageTimeout, 10000000 );
    NlParameters->MailslotDuplicateTimeout_100ns.QuadPart =
        Int32x32To64( NlParameters->MailslotDuplicateTimeout, 10000000 );
    NlParameters->BackgroundRetryQuitTime_100ns.QuadPart =
        Int32x32To64( NlParameters->BackgroundRetryQuitTime, 10000000 );


    //
    // Convert from days to 100ns
    //
    NlParameters->MaximumPasswordAge_100ns.QuadPart =
        ((LONGLONG) NlParameters->MaximumPasswordAge) *
        ((LONGLONG) 10000000) *
        ((LONGLONG) 24*60*60);

    //
    // Add a fraction of a day to prevent all machines created at the same time
    // from changing their password at the same time.
    RandomMinutes = (DWORD) rand() % (24*60);
    NlParameters->MaximumPasswordAge_100ns.QuadPart +=
        ((LONGLONG) RandomMinutes) *
        ((LONGLONG) 10000000) *
        ((LONGLONG) 60);
#ifdef notdef
    NlPrint((NL_INIT,"   RandomMinutes = %lu (0x%lx)\n",
                      RandomMinutes,
                      RandomMinutes ));
#endif // notdef


    NlParameters->ShortApiCallPeriod =
        SHORT_API_CALL_PERIOD + NlParameters->ExpectedDialupDelay * 1000;
    NlParameters->DnsRefreshIntervalPeriod =
            NlParameters->DnsRefreshInterval * 1000;
    if ( NlParameters->RequireSignOrSeal ) {
        NlParameters->SignSecureChannel = TRUE;
    }

}

NET_API_STATUS
NlParseTStr(
    IN LPNET_CONFIG_HANDLE SectionHandle,
    IN LPWSTR Keyword,
    IN BOOL MultivaluedParameter,
    IN OUT LPWSTR *DefaultValue,
    OUT LPWSTR *Parameter
    )
/*++

Routine Description:

    This routine parses a null or doubly-null terminated string

Arguments:

    SectionHandle -  Handle to a section in registry

    Keyword - The name of the parameter to read

    MultivaluedParameter - If TRUE, the keyword is a multiple
        string where elements are separated by a single null
        character and the array is ended with two null characters.
        If FALSE, the keyword is a single string ended with one
        null terminator.

    DefaultValue - The default value of the parameter.

        If NULL, the section handle passed is that of the Netlogon Parameters section.
        If non-NULL, the section handle passed is that of the GP section.
        If specified and used by this routine, it is set to NULL to indicate
            that it has been consumed by this routine.

    Parameter - Returns the parameter read.

Return Value:

    Status returned by NetpGetConfigTStrArray.

--*/
{
    NET_API_STATUS NetStatus;

    //
    // Get the configured parameter
    //
    // GP doesn't support multivalued strings. Instead a single
    //  string is used where individual strings are separated
    //  by spaces.
    //

    if ( MultivaluedParameter && DefaultValue == NULL ) {
        NetStatus = NetpGetConfigTStrArray (
                SectionHandle,
                Keyword,
                Parameter ); // Must be freed by NetApiBufferFree().
    } else {
        NetStatus = NetpGetConfigValue (
                SectionHandle,
                Keyword,
                Parameter ); // Must be freed by NetApiBufferFree().
    }

    //
    // If the parameter is empty string,
    //  set it to NULL
    //

    if ( NetStatus == NERR_Success &&
         (*Parameter)[0] == UNICODE_NULL ) {
        NetApiBufferFree( *Parameter );
        *Parameter = NULL;
        NetStatus = NERR_CfgParamNotFound;
    }

    //
    // Convert the single valued string into the multivalued form
    //

    if ( NetStatus == NERR_Success &&  // we successfully read the registry
         MultivaluedParameter &&       // this is multivalued parameter
         DefaultValue != NULL ) {      // we are parsing the GP section

        ULONG ParameterLength = 0;
        LPWSTR LocalParameter = NULL;

        //
        // The multivalued string will have two NULL terminator
        //  characters at the end, so allocate enough storage
        //
        ParameterLength = wcslen(*Parameter);
        NetStatus = NetApiBufferAllocate( (ParameterLength + 2) * sizeof(WCHAR),
                                          &LocalParameter );

        if ( NetStatus == NO_ERROR ) {
            LPWSTR ParameterPtr = NULL;
            LPWSTR LocalParameterPtr = NULL;

            RtlZeroMemory( LocalParameter, (ParameterLength + 2) * sizeof(WCHAR) );

            ParameterPtr = *Parameter;
            LocalParameterPtr = LocalParameter;
            while ( *ParameterPtr != UNICODE_NULL ) {

                //
                // Disregard spaces in the input string. Note that
                //  the user may have used several spaces to separate
                //  two adjacent strings.
                //
                while ( *ParameterPtr == L' ' && *ParameterPtr != UNICODE_NULL ) {
                    ParameterPtr ++;
                }

                //
                // Copy non-space characters
                //
                while ( *ParameterPtr != L' ' && *ParameterPtr != UNICODE_NULL ) {
                    *LocalParameterPtr++ = *ParameterPtr++;
                }

                //
                // Insert one NULL character between single values
                //
                *LocalParameterPtr++ = UNICODE_NULL;
            }

            //
            // Free the value read from registry
            //
            NetApiBufferFree( *Parameter );
            *Parameter = NULL;

            //
            // If the resulting multivalued string is not empty,
            //  use it. The resulting string may need smaller
            //  storage that we have allocated, so allocate again
            //  exactly what's needed to (potentially) save memory.
            //
            ParameterLength = NetpTStrArraySize( LocalParameter ); // this includes all storage
            if ( ParameterLength > 2*sizeof(WCHAR) ) {
                NetStatus = NetApiBufferAllocate( ParameterLength, Parameter );
                if ( NetStatus == NO_ERROR ) {
                    RtlCopyMemory( *Parameter, LocalParameter, ParameterLength );
                }

            } else {
                NetStatus = ERROR_INVALID_PARAMETER;
            }

            if ( LocalParameter != NULL ) {
                NetApiBufferFree( LocalParameter );
                LocalParameter = NULL;
            }
        }
    }

    //
    // Handle the default
    //

    if ( NetStatus != NERR_Success ) {
        if ( DefaultValue == NULL ) {
            *Parameter = NULL;
        } else {
            *Parameter = *DefaultValue;

            //
            // Indicate that we have consumed the
            //  value from the default parameters
            //
            *DefaultValue = NULL;
        }
    }

    //
    // Write event log on error
    //

    if ( NetStatus != NERR_Success && NetStatus != NERR_CfgParamNotFound ) {
        LPWSTR MsgStrings[3];

        if ( DefaultValue == NULL ) {
            MsgStrings[0] = L"Parameters";
        } else {
            MsgStrings[0] = L"Group Policy";
        }
        MsgStrings[1] = Keyword;
        MsgStrings[2] = (LPWSTR) ULongToPtr( NetStatus );

        NlpWriteEventlog( NELOG_NetlogonInvalidGenericParameterValue,
                          EVENTLOG_WARNING_TYPE,
                          (LPBYTE)&NetStatus,
                          sizeof(NetStatus),
                          MsgStrings,
                          3 | NETP_LAST_MESSAGE_IS_NETSTATUS );
        /* Not Fatal */
    }

    return NetStatus;
}


BOOL
Nlparse(
    IN PNETLOGON_PARAMETERS NlParameters,
    IN PNETLOGON_PARAMETERS DefaultParameters OPTIONAL,
    IN BOOLEAN IsChangeNotify
    )
/*++

Routine Description:

    Get parameters from the group policy or registry.

    All of the parameters are described in iniparm.h.

Arguments:

    NlParameters - Structure describing all parameters

    DefaultParameters - Structure describing default values for all parameters
        If NULL, the values are read from the Netlogon Parameters section and
        the default values specified in the parse table are used. If non-NULL,
        the values are read from the Group Policy section and the specified
        defaults are used.

    IsChangeNotify - TRUE if this call is the result of a change notification

Return Value:

    TRUE -- the registry was opened successfully and parameters
        were read.
    FALSE -- iff we couldn't open the appropriate registry section

--*/
{
    BOOLEAN RetVal = TRUE;
    NET_API_STATUS NetStatus;
    NET_API_STATUS TempNetStatus;

    LPWSTR ValueT = NULL;

    LPWSTR Keyword = NULL;
    LPWSTR MsgStrings[3];
    ULONG i;


    //
    // Variables for scanning the configuration data.
    //

    LPNET_CONFIG_HANDLE SectionHandle = NULL;
    LPNET_CONFIG_HANDLE WriteSectionHandle = NULL;
    RtlZeroMemory( NlParameters, sizeof(NlParameters) );

    //
    // Open the appropriate configuration section
    //

    NetStatus = NetpOpenConfigDataWithPathEx(
            &SectionHandle,
            NULL,                // no server name.
            (DefaultParameters == NULL) ?
                L"SYSTEM\\CurrentControlSet\\Services\\Netlogon" :
                TEXT(NL_GP_KEY),
            NULL,                // default Parameters area
            TRUE );              // we only want readonly access

    if ( NetStatus != NO_ERROR ) {
        SectionHandle = NULL;

        //
        // The Netlogon Parameters section must always
        //  exist. Write event log if we can't open it.
        //
        if ( DefaultParameters == NULL ) {
            MsgStrings[0] = L"Parameters";
            MsgStrings[1] = L"Parameters";
            MsgStrings[2] = (LPWSTR) ULongToPtr( NetStatus );

            NlpWriteEventlog( NELOG_NetlogonInvalidGenericParameterValue,
                              EVENTLOG_WARNING_TYPE,
                              (LPBYTE)&NetStatus,
                              sizeof(NetStatus),
                              MsgStrings,
                              3 | NETP_LAST_MESSAGE_IS_NETSTATUS );
        }

        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Loop parsing all the numeric parameters.
    //

    for ( i=0; i<sizeof(ParseTable)/sizeof(ParseTable[0]); i++ ) {

        NetStatus = NlParseOne(
                          SectionHandle,
                          (DefaultParameters != NULL),
                          ParseTable[i].Keyword,
                          (DefaultParameters == NULL) ?
                            ParseTable[i].DefaultValue :
                            *((PULONG)(((LPBYTE)DefaultParameters)+ParseTable[i].ValueOffset)),
                          ParseTable[i].MinimumValue,
                          ParseTable[i].MaximumValue,
                          (PULONG)(((LPBYTE)NlParameters)+ParseTable[i].ValueOffset) );

        if ( NetStatus != NERR_Success ) {

            if ( DefaultParameters == NULL ) {
                MsgStrings[0] = L"Parameters";
            } else {
                MsgStrings[0] = L"Group Policy";
            }
            MsgStrings[1] = ParseTable[i].Keyword;
            MsgStrings[2] = (LPWSTR) ULongToPtr( NetStatus );

            NlpWriteEventlog( NELOG_NetlogonInvalidGenericParameterValue,
                              EVENTLOG_WARNING_TYPE,
                              (LPBYTE)&NetStatus,
                              sizeof(NetStatus),
                              MsgStrings,
                              3 | NETP_LAST_MESSAGE_IS_NETSTATUS );
            /* Not Fatal */
        }
    }

    //
    // Loop parsing all the boolean parameters.
    //

    for ( i=0; i<sizeof(BoolParseTable)/sizeof(BoolParseTable[0]); i++ ) {

        NetStatus = NetpGetConfigBool (
                SectionHandle,
                BoolParseTable[i].Keyword,
                (DefaultParameters == NULL) ?
                    BoolParseTable[i].DefaultValue :
                    *((PBOOL)(((LPBYTE)DefaultParameters)+BoolParseTable[i].ValueOffset)),
                (PBOOL)(((LPBYTE)NlParameters)+BoolParseTable[i].ValueOffset) );

        //
        //  NeutralizeNt4Emulator is a special case: it must be TRUE on DC
        //
        if ( NetStatus == NO_ERROR &&
             !NlGlobalMemberWorkstation &&
             wcscmp(BoolParseTable[i].Keyword, NETLOGON_KEYWORD_NEUTRALIZENT4EMULATOR) == 0 &&
             !(*((PBOOL)(((LPBYTE)NlParameters)+BoolParseTable[i].ValueOffset))) ) {

            //
            // The code below will handle this error
            //
            NetStatus = ERROR_INVALID_PARAMETER;
        }

        if (NetStatus != NO_ERROR) {

            // Use a reasonable default
            if ( DefaultParameters == NULL ) {
                *(PBOOL)(((LPBYTE)NlParameters)+BoolParseTable[i].ValueOffset) =
                    BoolParseTable[i].DefaultValue;
            } else {
                *(PBOOL)(((LPBYTE)NlParameters)+BoolParseTable[i].ValueOffset) =
                    *((PBOOL)(((LPBYTE)DefaultParameters)+BoolParseTable[i].ValueOffset));
            }

            if ( DefaultParameters == NULL ) {
                MsgStrings[0] = L"Parameters";
            } else {
                MsgStrings[0] = L"Group Policy";
            }
            MsgStrings[1] = BoolParseTable[i].Keyword;
            MsgStrings[2] = (LPWSTR) ULongToPtr( NetStatus );

            NlpWriteEventlog( NELOG_NetlogonInvalidGenericParameterValue,
                              EVENTLOG_WARNING_TYPE,
                              (LPBYTE)&NetStatus,
                              sizeof(NetStatus),
                              MsgStrings,
                              3 | NETP_LAST_MESSAGE_IS_NETSTATUS );
            /* Not Fatal */
        }

    }


#ifdef _DC_NETLOGON
    //
    // Get the "SysVol" configured parameter
    //

    NetStatus = NlParseOnePath(
            SectionHandle,
            NETLOGON_KEYWORD_SYSVOL,   // key wanted
            (DefaultParameters == NULL) ?
                DEFAULT_SYSVOL :
                DefaultParameters->UnicodeSysvolPath,
            &NlParameters->UnicodeSysvolPath );


    if ( NetStatus != NO_ERROR ) {
        NlParameters->UnicodeSysvolPath = NULL;

        if ( DefaultParameters == NULL ) {
            MsgStrings[0] = L"Parameters";
        } else {
            MsgStrings[0] = L"Group Policy";
        }
        MsgStrings[1] = NETLOGON_KEYWORD_SYSVOL;
        MsgStrings[2] = (LPWSTR) ULongToPtr( NetStatus );

        NlpWriteEventlog( NELOG_NetlogonInvalidGenericParameterValue,
                          EVENTLOG_WARNING_TYPE,
                          (LPBYTE)&NetStatus,
                          sizeof(NetStatus),
                          MsgStrings,
                          3 | NETP_LAST_MESSAGE_IS_NETSTATUS );
        /* Not Fatal */
    }

    //
    // Get the "SCRIPTS" configured parameter
    //
    // Default Script path is relative to Sysvol
    //

    NetStatus = NlParseOnePath(
            SectionHandle,
            NETLOGON_KEYWORD_SCRIPTS,   // key wanted
            (DefaultParameters == NULL) ?
                NULL :  // No default (Default computed later)
                DefaultParameters->UnicodeScriptPath,
            &NlParameters->UnicodeScriptPath );

    if ( NetStatus != NO_ERROR ) {
        NlParameters->UnicodeScriptPath = NULL;

        if ( DefaultParameters == NULL ) {
            MsgStrings[0] = L"Parameters";
        } else {
            MsgStrings[0] = L"Group Policy";
        }
        MsgStrings[1] = NETLOGON_KEYWORD_SCRIPTS;
        MsgStrings[2] = (LPWSTR) ULongToPtr( NetStatus );

        NlpWriteEventlog( NELOG_NetlogonInvalidGenericParameterValue,
                          EVENTLOG_WARNING_TYPE,
                          (LPBYTE)&NetStatus,
                          sizeof(NetStatus),
                          MsgStrings,
                          3 | NETP_LAST_MESSAGE_IS_NETSTATUS );
        /* Not Fatal */
    }


    //
    // Get the "SiteName" configured parameter
    //

    NetStatus = NlParseTStr( SectionHandle,
                             NETLOGON_KEYWORD_SITENAME,
                             FALSE,  // single valued parameter
                             (DefaultParameters == NULL) ?
                                 NULL :
                                 &DefaultParameters->SiteName,
                             &NlParameters->SiteName );

    NlParameters->SiteNameConfigured = (NetStatus == NO_ERROR);

    //
    // If we are reading the Netlogon Parameters section ...
    //

    if ( DefaultParameters == NULL ) {

        //
        // If the site name is not configured, default it to the
        //  dynamic site name determined by Netlogon
        //
        if ( NetStatus == NERR_CfgParamNotFound ) {
            NetStatus = NlParseTStr( SectionHandle,
                                     NETLOGON_KEYWORD_DYNAMICSITENAME,
                                     FALSE,  // single valued parameter
                                     NULL,
                                     &NlParameters->SiteName );
        }
    //
    // If we are reading the GP section ...
    //

    } else {

        //
        // If the site name is not configured in the GP section,
        //  may be it was configured in the Netlogon parameters section
        //
        if ( !NlParameters->SiteNameConfigured ) {
            NlParameters->SiteNameConfigured = DefaultParameters->SiteNameConfigured;
        }
    }

    //
    // Get the "SiteCoverage" configured parameter
    //

    NetStatus = NlParseTStr( SectionHandle,
                             NETLOGON_KEYWORD_SITECOVERAGE,
                             TRUE,  // multivalued parameter
                             (DefaultParameters == NULL) ?
                                NULL :
                                &DefaultParameters->SiteCoverage,
                             &NlParameters->SiteCoverage );

    //
    // Get the "GcSiteCoverage" configured parameter
    //

    NetStatus = NlParseTStr( SectionHandle,
                             NETLOGON_KEYWORD_GCSITECOVERAGE,
                             TRUE,  // multivalued parameter
                             (DefaultParameters == NULL) ?
                                NULL :
                                &DefaultParameters->GcSiteCoverage,
                             &NlParameters->GcSiteCoverage );

    //
    // Get the "NdncSiteCoverage" configured parameter
    //

    NetStatus = NlParseTStr( SectionHandle,
                             NETLOGON_KEYWORD_NDNCSITECOVERAGE,
                             TRUE,  // multivalued parameter
                             (DefaultParameters == NULL) ?
                                NULL :
                                &DefaultParameters->NdncSiteCoverage,
                             &NlParameters->NdncSiteCoverage );

    //
    // Get the "DnsAvoidRegisterRecords" configured parameter
    //

    NetStatus = NlParseTStr( SectionHandle,
                             NETLOGON_KEYWORD_DNSAVOIDNAME,
                             TRUE,  // multivalued parameter
                             (DefaultParameters == NULL) ?
                                NULL :
                                &DefaultParameters->DnsAvoidRegisterRecords,
                             &NlParameters->DnsAvoidRegisterRecords );
#endif // _DC_NETLOGON


    //
    // Convert parameters to a more convenient form.
    //

    NlParseRecompute( NlParameters );


    //
    // If the KerbIsDoneWithJoinDomainEntry key value is 1, delete the
    // Netlogon\JoinDomain entry. Also delete this entry if this machine is
    // a DC in which case neither we nor Kerberos needs this entry. (As a
    // matter of fact, Kerberos won't even create KerbIsDoneWithJoinDomainEntry
    // on a DC.)
    // Always delete KerbIsDoneWithJoinDomainEntry
    // Ignore errors
    //
    // Do this only on the change notify since netlogon needs this info
    // to set the client session first time after a reboot.
    //

    if ( IsChangeNotify &&
         DefaultParameters == NULL ) {  // KerbIsDoneWithJoinDomainEntry is in netlogon params

        if ( NlParameters->KerbIsDoneWithJoinDomainEntry == 1 ||
             !NlGlobalMemberWorkstation )
        {
            ULONG WinError = ERROR_SUCCESS;
            HKEY hJoinKey = NULL;


            WinError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                     NETSETUPP_NETLOGON_JD_PATH,
                                     0,
                                     KEY_ALL_ACCESS,
                                     &hJoinKey);

            if ( WinError == ERROR_SUCCESS)
            {
                WinError = RegDeleteKey( hJoinKey,
                                         NETSETUPP_NETLOGON_JD );

                if ( WinError == ERROR_SUCCESS ) {
                    NlPrint(( NL_INIT, "NlParse: Deleted JoinDomain reg key\n" ));
                }
                if (hJoinKey)
                {
                    WinError = RegCloseKey(hJoinKey);
                }
            }
        }

        TempNetStatus = NetpOpenConfigData(
                &WriteSectionHandle,
                NULL,                       // no server name.
                SERVICE_NETLOGON,
                FALSE);  // writable, we are deleting it.

        if ( TempNetStatus == NO_ERROR ) {
            TempNetStatus = NetpDeleteConfigKeyword ( WriteSectionHandle,
                                                      NETLOGON_KEYWORD_KERBISDDONEWITHJOIN );
        }
    }

    NetStatus = NERR_Success;

Cleanup:

    //
    // Free any locally used resources
    //

    if ( ValueT != NULL) {
        (VOID) NetApiBufferFree( ValueT );
    }
    if ( SectionHandle != NULL ) {
        (VOID) NetpCloseConfigData( SectionHandle );
    }

    if ( WriteSectionHandle != NULL ) {
        (VOID) NetpCloseConfigData( WriteSectionHandle );
    }

    return RetVal;
}


BOOL
NlparseAllSections(
    IN PNETLOGON_PARAMETERS NlParameters,
    IN BOOLEAN IsChangeNotify
    )
/*++

Routine Description:

    Get parameters from both the Group Policy and the
    Netlogon Parameters registry sections.

Arguments:

    NlParameters - Structure describing all parameters

    IsChangeNotify - TRUE if this call is the result of a change notification

Return Value:

    TRUE -- iff the parse was successful.

--*/
{
    NETLOGON_PARAMETERS NlLocalParameters;
    NETLOGON_PARAMETERS GpParameters;

    RtlZeroMemory( &NlLocalParameters, sizeof(NlLocalParameters) );
    RtlZeroMemory( &GpParameters, sizeof(GpParameters) );

    //
    // Do the one time initialization here
    //

    if ( !IsChangeNotify ) {
        NT_PRODUCT_TYPE NtProductType;
        ULONG i;

        //
        // Flag if this is a workstation (or member server)
        //

        if ( !RtlGetNtProductType( &NtProductType ) ) {
            NtProductType = NtProductWinNt;
        }

        if ( NtProductType == NtProductLanManNt ) {
            NlGlobalMemberWorkstation = FALSE;
        } else {
            NlGlobalMemberWorkstation = TRUE;
        }

        //
        // Set the right default for NeutralizeNt4Emulator that depends
        //  on whether we are a DC or not
        //

        for ( i=0; i<sizeof(BoolParseTable)/sizeof(BoolParseTable[0]); i++ ) {
            if ( wcscmp(BoolParseTable[i].Keyword, NETLOGON_KEYWORD_NEUTRALIZENT4EMULATOR) == 0 ) {
                if ( NlGlobalMemberWorkstation ) {
                    BoolParseTable[i].DefaultValue = FALSE; // FALSE for a workstation
                } else {
                    BoolParseTable[i].DefaultValue = TRUE;  // TRUE for a DC
                }
                break;
            }
        }
    }

    //
    // First parse the new parameters from the Netlogon Parameters section
    //

    if ( !Nlparse( &NlLocalParameters, NULL, IsChangeNotify ) ) {
        return FALSE;  // error here is critical
    }

    //
    // Next parse from the GP section using the parameters from the
    //  Netlogon Parameters section as default
    //

    if ( !Nlparse( &GpParameters, &NlLocalParameters, IsChangeNotify ) ) {

        //
        // If the GP is not defined, use the parameters from
        //  the Netlogon Parameters section
        //

        *NlParameters = NlLocalParameters;
        NlPrint((NL_INIT, "Group Policy is not defined for Netlogon\n"));

    } else {

        *NlParameters = GpParameters;
        NlPrint((NL_INIT, "Group Policy is defined for Netlogon\n"));

        //
        // Free whatever is left in the local Netlogon parameters
        //
        NlParseFree( &NlLocalParameters );
    }

#if NETLOGONDBG

    //
    // Dump all the values on first invocation
    //

    if ( !IsChangeNotify ) {
        ULONG i;

        //
        // Be Verbose
        //

        NlPrint((NL_INIT, "Following are the effective values after parsing\n"));

        NlPrint((NL_INIT,"   Sysvol = " FORMAT_LPWSTR "\n",
                            NlParameters->UnicodeSysvolPath));

        NlPrint((NL_INIT,"   Scripts = " FORMAT_LPWSTR "\n",
                        NlParameters->UnicodeScriptPath));

        NlPrint((NL_INIT,"   SiteName (%ld) = " FORMAT_LPWSTR "\n",
                        NlParameters->SiteNameConfigured,
                        NlParameters->SiteName ));

        {
            LPTSTR_ARRAY TStrArray;
            if ( NlParameters->SiteCoverage != NULL ) {
                NlPrint((NL_INIT,"   SiteCoverage = " ));
                TStrArray = NlParameters->SiteCoverage;
                while (!NetpIsTStrArrayEmpty(TStrArray)) {
                    NlPrint((NL_INIT," '%ws'", TStrArray ));
                    TStrArray = NetpNextTStrArrayEntry(TStrArray);
                }
                NlPrint((NL_INIT,"\n" ));
            }
        }
        {
            LPTSTR_ARRAY TStrArray;
            if ( NlParameters->GcSiteCoverage != NULL ) {
                NlPrint((NL_INIT,"   GcSiteCoverage = " ));
                TStrArray = NlParameters->GcSiteCoverage;
                while (!NetpIsTStrArrayEmpty(TStrArray)) {
                    NlPrint((NL_INIT," '%ws'", TStrArray ));
                    TStrArray = NetpNextTStrArrayEntry(TStrArray);
                }
                NlPrint((NL_INIT,"\n" ));
            }
        }
        {
            LPTSTR_ARRAY TStrArray;
            if ( NlParameters->NdncSiteCoverage != NULL ) {
                NlPrint((NL_INIT,"   NdncSiteCoverage = " ));
                TStrArray = NlParameters->NdncSiteCoverage;
                while (!NetpIsTStrArrayEmpty(TStrArray)) {
                    NlPrint((NL_INIT," '%ws'", TStrArray ));
                    TStrArray = NetpNextTStrArrayEntry(TStrArray);
                }
                NlPrint((NL_INIT,"\n" ));
            }
        }
        {
            LPTSTR_ARRAY TStrArray;
            if ( NlParameters->DnsAvoidRegisterRecords != NULL ) {
                NlPrint((NL_INIT,"   DnsAvoidRegisterRecords = " ));
                TStrArray = NlParameters->DnsAvoidRegisterRecords;
                while (!NetpIsTStrArrayEmpty(TStrArray)) {
                    NlPrint((NL_INIT," '%ws'", TStrArray ));
                    TStrArray = NetpNextTStrArrayEntry(TStrArray);
                }
                NlPrint((NL_INIT,"\n" ));
            }
        }

        for ( i=0; i<sizeof(ParseTable)/sizeof(ParseTable[0]); i++ ) {
            NlPrint((NL_INIT,
                         "   %ws = %lu (0x%lx)\n",
                         ParseTable[i].Keyword,
                         *(PULONG)(((LPBYTE)NlParameters)+ParseTable[i].ValueOffset),
                         *(PULONG)(((LPBYTE)NlParameters)+ParseTable[i].ValueOffset) ));
        }

        for ( i=0; i<sizeof(BoolParseTable)/sizeof(BoolParseTable[0]); i++ ) {
            NlPrint(( NL_INIT,
                          "   %ws = %s\n",
                          BoolParseTable[i].Keyword,
                          (*(PBOOL)(((LPBYTE)NlParameters)+BoolParseTable[i].ValueOffset)) ?
                                    "TRUE":"FALSE" ));
        }
    }

#endif // NETLOGONDBG

    return TRUE;
}

VOID
NlParseFree(
    IN PNETLOGON_PARAMETERS NlParameters
    )
/*++

Routine Description:

    Free any allocated parameters.

Arguments:

    NlParameters - Structure describing all parameters

Return Value:

    None.

--*/
{
    if ( NlParameters->SiteName != NULL) {
        (VOID) NetApiBufferFree( NlParameters->SiteName );
        NlParameters->SiteName = NULL;
    }

    if ( NlParameters->SiteCoverage != NULL) {
        (VOID) NetApiBufferFree( NlParameters->SiteCoverage );
        NlParameters->SiteCoverage = NULL;
    }

    if ( NlParameters->GcSiteCoverage != NULL) {
        (VOID) NetApiBufferFree( NlParameters->GcSiteCoverage );
        NlParameters->GcSiteCoverage = NULL;
    }

    if ( NlParameters->NdncSiteCoverage != NULL) {
        (VOID) NetApiBufferFree( NlParameters->NdncSiteCoverage );
        NlParameters->NdncSiteCoverage = NULL;
    }

    if ( NlParameters->DnsAvoidRegisterRecords != NULL) {
        (VOID) NetApiBufferFree( NlParameters->DnsAvoidRegisterRecords );
        NlParameters->DnsAvoidRegisterRecords = NULL;
    }

    if ( NlParameters->UnicodeScriptPath != NULL) {
        (VOID) NetApiBufferFree( NlParameters->UnicodeScriptPath );
        NlParameters->UnicodeScriptPath = NULL;
    }

    if ( NlParameters->UnicodeSysvolPath != NULL) {
        (VOID) NetApiBufferFree( NlParameters->UnicodeSysvolPath );
        NlParameters->UnicodeSysvolPath = NULL;
    }
}


VOID
NlReparse(
    VOID
    )

/*++

Routine Description:


    This routine handle a registry change notification.

Arguments:

    None.

Return Value:

    None

--*/
{
    NETLOGON_PARAMETERS LocalParameters;
    ULONG i;
    LPWSTR TempString;

    BOOLEAN UpdateDns = FALSE;
    BOOLEAN UpdateShares = FALSE;
    BOOLEAN UpdateSiteName = FALSE;

    ULONG OldDnsTtl;
    BOOL OldSysVolReady;

    BOOL OldDisablePasswordChange;
    ULONG OldScavengeInterval;
    ULONG OldMaximumPasswordAge;

    //
    // Grab any old values that might be interesting.
    //

    OldDnsTtl = NlGlobalParameters.DnsTtl;
    OldSysVolReady = NlGlobalParameters.SysVolReady;
    OldDisablePasswordChange = NlGlobalParameters.DisablePasswordChange;
    OldScavengeInterval = NlGlobalParameters.ScavengeInterval;
    OldMaximumPasswordAge = NlGlobalParameters.MaximumPasswordAge;


    //
    // Parse both sections in registry relevant to us
    //

    if (! NlparseAllSections( &LocalParameters, TRUE ) ) {
        return;
    }

    //
    // Be Verbose
    //

    NlPrint((NL_INIT, "Following are the effective values after parsing\n"));

    if ( (LocalParameters.UnicodeSysvolPath == NULL && NlGlobalParameters.UnicodeSysvolPath != NULL ) ||
         (LocalParameters.UnicodeSysvolPath != NULL && NlGlobalParameters.UnicodeSysvolPath == NULL ) ||
         (LocalParameters.UnicodeSysvolPath != NULL && NlGlobalParameters.UnicodeSysvolPath != NULL ) && _wcsicmp( LocalParameters.UnicodeSysvolPath, NlGlobalParameters.UnicodeSysvolPath) != 0 ) {
        NlPrint((NL_INIT,"   Sysvol = " FORMAT_LPWSTR "\n",
                        LocalParameters.UnicodeSysvolPath));

        // We can get away with this since only Netlogon's main thread touches
        // this variable.
        TempString = LocalParameters.UnicodeSysvolPath;
        LocalParameters.UnicodeSysvolPath = NlGlobalParameters.UnicodeSysvolPath;
        NlGlobalParameters.UnicodeSysvolPath = TempString;
        UpdateShares = TRUE;
    }

    if ( (LocalParameters.UnicodeScriptPath == NULL && NlGlobalParameters.UnicodeScriptPath != NULL ) ||
         (LocalParameters.UnicodeScriptPath != NULL && NlGlobalParameters.UnicodeScriptPath == NULL ) ||
         (LocalParameters.UnicodeScriptPath != NULL && NlGlobalParameters.UnicodeScriptPath != NULL ) && _wcsicmp( LocalParameters.UnicodeScriptPath, NlGlobalParameters.UnicodeScriptPath) != 0 ) {

        NlPrint((NL_INIT,"   Scripts = " FORMAT_LPWSTR "\n",
                    LocalParameters.UnicodeScriptPath));

        // We can get away with this since only Netlogon's main thread touches
        // this variable.
        TempString = LocalParameters.UnicodeScriptPath;
        LocalParameters.UnicodeScriptPath = NlGlobalParameters.UnicodeScriptPath;
        NlGlobalParameters.UnicodeScriptPath = TempString;
        UpdateShares = TRUE;

    }

    //
    // Check whether the exclusive share access to Sysvol share needs update
    //

    if ( LocalParameters.AllowExclusiveSysvolShareAccess ) {
        if ( !NlGlobalParameters.AllowExclusiveSysvolShareAccess ) {
            UpdateShares = TRUE;
        }
    } else {
        if ( NlGlobalParameters.AllowExclusiveSysvolShareAccess ) {
            UpdateShares = TRUE;
        }
    }

    //
    // Check whether the exclusive share access to Scripts share needs update
    //

    if ( LocalParameters.AllowExclusiveScriptsShareAccess ) {
        if ( !NlGlobalParameters.AllowExclusiveScriptsShareAccess ) {
            UpdateShares = TRUE;
        }
    } else {
        if ( NlGlobalParameters.AllowExclusiveScriptsShareAccess ) {
            UpdateShares = TRUE;
        }
    }

    if ( (LocalParameters.SiteNameConfigured != NlGlobalParameters.SiteNameConfigured ) ||
         (LocalParameters.SiteName == NULL && NlGlobalParameters.SiteName != NULL ) ||
         (LocalParameters.SiteName != NULL && NlGlobalParameters.SiteName == NULL ) ||
         (LocalParameters.SiteName != NULL && NlGlobalParameters.SiteName != NULL ) && _wcsicmp( LocalParameters.SiteName, NlGlobalParameters.SiteName) != 0 ) {

        NlPrint((NL_INIT,"   SiteName (%ld) = " FORMAT_LPWSTR "\n",
                    LocalParameters.SiteNameConfigured,
                    LocalParameters.SiteName ));

        // We can get away with this since only Netlogon's main thread touches
        // this variable.
        TempString = LocalParameters.SiteName;
        LocalParameters.SiteName = NlGlobalParameters.SiteName;
        NlGlobalParameters.SiteName = TempString;
        NlGlobalParameters.SiteNameConfigured = LocalParameters.SiteNameConfigured;
        UpdateSiteName = TRUE;
    }

    //
    // Handle SiteCoverage changing
    //

    if ( NlSitesSetSiteCoverageParam( DOM_REAL_DOMAIN, LocalParameters.SiteCoverage ) ) {

        LPTSTR_ARRAY TStrArray;

        NlPrint((NL_INIT,"   SiteCoverage = " ));

        TStrArray = LocalParameters.SiteCoverage;
        if ( TStrArray == NULL ) {
            NlPrint((NL_INIT,"<NULL>" ));
        } else {
            while (!NetpIsTStrArrayEmpty(TStrArray)) {
                NlPrint((NL_INIT," '%ws'", TStrArray ));
                TStrArray = NetpNextTStrArrayEntry(TStrArray);
            }
        }
        NlPrint((NL_INIT,"\n" ));

        // NlSitesSetSiteCoverageParam used this allocated buffer
        LocalParameters.SiteCoverage = NULL;

        UpdateDns = TRUE;
    }

    //
    // Handle GcSiteCoverage changing
    //

    if ( NlSitesSetSiteCoverageParam( DOM_FOREST, LocalParameters.GcSiteCoverage ) ) {

        LPTSTR_ARRAY TStrArray;

        NlPrint((NL_INIT,"   GcSiteCoverage = " ));

        TStrArray = LocalParameters.GcSiteCoverage;
        if ( TStrArray == NULL ) {
            NlPrint((NL_INIT,"<NULL>" ));
        } else {
            while (!NetpIsTStrArrayEmpty(TStrArray)) {
                NlPrint((NL_INIT," '%ws'", TStrArray ));
                TStrArray = NetpNextTStrArrayEntry(TStrArray);
            }
        }
        NlPrint((NL_INIT,"\n" ));

        // NlSitesSetSiteCoverageParam used this allocated buffer
        LocalParameters.GcSiteCoverage = NULL;

        UpdateDns = TRUE;
    }

    //
    // Handle NdncSiteCoverage changing
    //

    if ( NlSitesSetSiteCoverageParam( DOM_NON_DOMAIN_NC, LocalParameters.NdncSiteCoverage ) ) {

        LPTSTR_ARRAY TStrArray;

        NlPrint((NL_INIT,"   NdncSiteCoverage = " ));

        TStrArray = LocalParameters.NdncSiteCoverage;
        if ( TStrArray == NULL ) {
            NlPrint((NL_INIT,"<NULL>" ));
        } else {
            while (!NetpIsTStrArrayEmpty(TStrArray)) {
                NlPrint((NL_INIT," '%ws'", TStrArray ));
                TStrArray = NetpNextTStrArrayEntry(TStrArray);
            }
        }
        NlPrint((NL_INIT,"\n" ));

        // NlSitesSetSiteCoverageParam used this allocated buffer
        LocalParameters.NdncSiteCoverage = NULL;

        UpdateDns = TRUE;
    }

    //
    // Handle DnsAvoidRegisterRecords changing
    //

    if ( NlDnsSetAvoidRegisterNameParam( LocalParameters.DnsAvoidRegisterRecords ) ) {

        LPTSTR_ARRAY TStrArray;

        NlPrint((NL_INIT,"   DnsAvoidRegisterRecords = " ));

        TStrArray = LocalParameters.DnsAvoidRegisterRecords;
        if ( TStrArray == NULL ) {
            NlPrint((NL_INIT,"<NULL>" ));
        } else {
            while (!NetpIsTStrArrayEmpty(TStrArray)) {
                NlPrint((NL_INIT," '%ws'", TStrArray ));
                TStrArray = NetpNextTStrArrayEntry(TStrArray);
            }
        }
        NlPrint((NL_INIT,"\n" ));

        // NlSitesSetSiteCoverageParam used this allocated buffer
        LocalParameters.DnsAvoidRegisterRecords = NULL;

        UpdateDns = TRUE;
    }

    //
    // Install all the numeric parameters.
    //

    for ( i=0; i<sizeof(ParseTable)/sizeof(ParseTable[0]); i++ ) {
        if ( (*(PULONG)(((LPBYTE)(&LocalParameters))+ParseTable[i].ValueOffset) !=
            *(PULONG)(((LPBYTE)(&NlGlobalParameters))+ParseTable[i].ValueOffset) ) ) {
            NlPrint((NL_INIT,
                     "   %ws = %lu (0x%lx)\n",
                     ParseTable[i].Keyword,
                     *(PULONG)(((LPBYTE)(&LocalParameters))+ParseTable[i].ValueOffset),
                     *(PULONG)(((LPBYTE)(&LocalParameters))+ParseTable[i].ValueOffset) ));

            //
            // Actually set the value
            //
            *(PULONG)(((LPBYTE)(&NlGlobalParameters))+ParseTable[i].ValueOffset) =
                *(PULONG)(((LPBYTE)(&LocalParameters))+ParseTable[i].ValueOffset);

            //
            // If this changed value affects DNS,
            //  note that fact.
            //

            if ( ParseTable[i].ChangesDnsRegistration ) {
                UpdateDns = TRUE;
            }
        }
    }

    for ( i=0; i<sizeof(BoolParseTable)/sizeof(BoolParseTable[0]); i++ ) {
        if ( (*(PULONG)(((LPBYTE)(&LocalParameters))+BoolParseTable[i].ValueOffset) !=
              *(PULONG)(((LPBYTE)(&NlGlobalParameters))+BoolParseTable[i].ValueOffset) ) ) {

            NlPrint(( NL_INIT,
                      "   %ws = %s\n",
                      BoolParseTable[i].Keyword,
                      (*(PBOOL)(((LPBYTE)(&LocalParameters))+BoolParseTable[i].ValueOffset)) ?
                                "TRUE":"FALSE" ));

            //
            // Actually set the value
            //
            *(PULONG)(((LPBYTE)(&NlGlobalParameters))+BoolParseTable[i].ValueOffset) =
                *(PULONG)(((LPBYTE)(&LocalParameters))+BoolParseTable[i].ValueOffset);

            //
            // If this changed value affects DNS,
            //  note that fact.
            //

            if ( BoolParseTable[i].ChangesDnsRegistration ) {
                UpdateDns = TRUE;
            }

            //
            // If this changed value affects LSA, inform it
            //
            if ( !NlGlobalMemberWorkstation &&
                 wcscmp(BoolParseTable[i].Keyword, NETLOGON_KEYWORD_NT4EMULATOR) == 0 ) {

                LsaINotifyNetlogonParametersChangeW(
                       LsaEmulateNT4,
                       REG_DWORD,
                       (PWSTR)&NlGlobalParameters.Nt4Emulator,
                       sizeof(NlGlobalParameters.Nt4Emulator) );
            }
        }
    }

    //
    // Convert parameters to a more convenient form.
    //

    NlParseRecompute( &NlGlobalParameters );

    //
    // Notify other components of parameters that have changed.
    //

    //
    // Enable detection of duplicate event log messages
    //
    NetpEventlogSetTimeout ( NlGlobalEventlogHandle,
                             NlGlobalParameters.DuplicateEventlogTimeout*1000 );


    //
    // Do member workstation specific updates
    //

    if ( NlGlobalMemberWorkstation ) {

        //
        // Update site name
        //
        if ( UpdateSiteName ) {
            (VOID) NlSetSiteName( NlGlobalParameters.SiteName, NULL );
        }

    //
    // Do DC specific updates
    //
    } else {
        //
        // Re-register DNS records
        //
        // If DnsTtl has changed,
        //  force all records to be registered.
        //

        if ( UpdateDns ) {
            NlDnsForceScavenge( TRUE,  // refresh domain records
                                NlGlobalParameters.DnsTtl != OldDnsTtl );
        }

        //
        // Update the Netlogon and Sysvol shares
        //

        if ( UpdateShares || OldSysVolReady != NlGlobalParameters.SysVolReady ) {
            NlCreateSysvolShares();
        }
    }

    //
    // If the settings that affect the scavenger have changed,
    //  trigger it now.
    //

    if ( OldDisablePasswordChange != NlGlobalParameters.DisablePasswordChange ||
        OldScavengeInterval != NlGlobalParameters.ScavengeInterval ||
        OldMaximumPasswordAge != NlGlobalParameters.MaximumPasswordAge ) {

        //
        // We don't need to set NlGlobalTimerEvent since we're already processing
        //  a registry notification event.  That'll make NlMainLoop notice the change.
        //
        EnterCriticalSection( &NlGlobalScavengerCritSect );
        NlGlobalScavengerTimer.Period = 0;
        LeaveCriticalSection( &NlGlobalScavengerCritSect );

    }


// Cleanup:
    NlParseFree( &LocalParameters );
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\replutil.c ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    replutil.c

Abstract:

    Low level functions for SSI Replication apis

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    22-Jul-1991 (cliffv)
        Ported to NT.  Converted to NT style.

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.

    04-Apr-1992 (madana)
        Added support for LSA replication.

--*/

//
// Common include files.
//

#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop

//
// Include files specific to this .c file
//

#include <accessp.h>    // NetpConvertWorkstationList
#include "lsarepl.h"



DWORD
NlCopyUnicodeString (
    IN PUNICODE_STRING InString,
    OUT PUNICODE_STRING OutString
    )

/*++

Routine Description:

    This routine copies the input string to the output. It assumes that
    the input string is allocated by MIDL_user_allocate() and sets the
    input string buffer pointer to NULL so that the buffer will be not
    freed on return.

Arguments:

    InString - Points to the UNICODE string to copy.

    OutString - Points to the UNICODE string which will be updated to point
        to the input string.

Return Value:

    Return the size of the MIDL buffer.

--*/
{
    if ( InString->Length == 0 || InString->Buffer == NULL ) {
        OutString->Length = 0;
        OutString->MaximumLength = 0;
        OutString->Buffer = NULL;
    } else {
        OutString->Length = InString->Length;
        OutString->MaximumLength = InString->Length;
        OutString->Buffer = InString->Buffer;
        InString->Buffer = NULL;
    }

    return( OutString->MaximumLength );
}


DWORD
NlCopyData(
    IN LPBYTE *InData,
    OUT LPBYTE *OutData,
    DWORD DataLength
    )

/*++

Routine Description:

    This routine copies the input data pointer to output data pointer.
    It assumes that the input data buffer is allocated by the
    MIDL_user_allocate() and sets the input buffer buffer pointer to
    NULL on return so that the data buffer will not be freed by SamIFree
    rountine.

Arguments:

    InData - Points to input data buffer pointer.

    OutString - Pointer to output data buffer pointer.

    DataLength - Length of input data.

Return Value:

    Return the size of the data copied.

--*/
{
    *OutData = *InData;
    *InData = NULL;

    return(DataLength);
}


VOID
NlFreeDBDelta(
    IN PNETLOGON_DELTA_ENUM Delta
    )
/*++

Routine Description:

    This routine will free the midl buffers that are allocated for
    a delta. This routine does nothing but call the midl generated free
    routine.

Arguments:

    Delta: pointer to the delta structure which has to be freed.

Return Value:

    nothing

--*/
{
    if( Delta != NULL ) {
        _fgs__NETLOGON_DELTA_ENUM (Delta);
    }
}


VOID
NlFreeDBDeltaArray(
    IN PNETLOGON_DELTA_ENUM DeltaArray,
    IN DWORD ArraySize
    )
/*++

Routine Description:

    This routine will free up all delta entries in enum array and the
    array itself.

Arguments:

    Delta: pointer to the delta structure array.

    ArraySize: num of delta structures in the array.

Return Value:

    nothing

--*/
{
    DWORD i;

    if( DeltaArray != NULL ) {

        for( i = 0; i < ArraySize; i++) {
            NlFreeDBDelta( &DeltaArray[i] );
        }

        MIDL_user_free( DeltaArray );
    }
}



NTSTATUS
NlPackSamUser (
    IN ULONG RelativeId,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize,
    IN PSESSION_INFO SessionInfo
    )
/*++

Routine Description:

    Pack a description of the specified user into the specified buffer.

Arguments:

    RelativeId - The relative Id of the user query.

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

    SessionInfo: Info describing BDC that's calling us

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;
    SAMPR_HANDLE UserHandle = NULL;
    PNETLOGON_DELTA_USER DeltaUser;
    PSAMPR_USER_INFO_BUFFER UserAll = NULL;



    DEFPACKTIMER;
    DEFSAMTIMER;

    INITPACKTIMER;
    INITSAMTIMER;

    STARTPACKTIMER;

    NlPrint((NL_SYNC_MORE, "Packing User Object %lx\n", RelativeId));

    *BufferSize = 0;

    Delta->DeltaType = AddOrChangeUser;
    Delta->DeltaID.Rid = RelativeId;
    Delta->DeltaUnion.DeltaUser = NULL;

    //
    // Open a handle to the specified user.
    //

    STARTSAMTIMER;

    Status = SamIOpenAccount( DBInfo->DBHandle,
                              RelativeId,
                              SecurityDbObjectSamUser,
                              &UserHandle );
    STOPSAMTIMER;


    if (!NT_SUCCESS(Status)) {
        UserHandle = NULL;
        goto Cleanup;
    }



    //
    // Query everything there is to know about this user.
    //

    STARTSAMTIMER;

    Status = SamrQueryInformationUser(
                UserHandle,
                UserInternal3Information,
                &UserAll );
    STOPSAMTIMER;


    if (!NT_SUCCESS(Status)) {
        UserAll = NULL;
        goto Cleanup;
    }


    NlPrint((NL_SYNC_MORE,
            "\t User Object name %wZ\n",
            (PUNICODE_STRING)&UserAll->Internal3.I1.UserName));

#define FIELDS_USED ( USER_ALL_USERNAME | \
                      USER_ALL_FULLNAME | \
                      USER_ALL_USERID | \
                      USER_ALL_PRIMARYGROUPID | \
                      USER_ALL_HOMEDIRECTORY | \
                      USER_ALL_HOMEDIRECTORYDRIVE | \
                      USER_ALL_SCRIPTPATH | \
                      USER_ALL_PROFILEPATH | \
                      USER_ALL_ADMINCOMMENT | \
                      USER_ALL_WORKSTATIONS | \
                      USER_ALL_LOGONHOURS | \
                      USER_ALL_LASTLOGON | \
                      USER_ALL_LASTLOGOFF | \
                      USER_ALL_BADPASSWORDCOUNT | \
                      USER_ALL_LOGONCOUNT | \
                      USER_ALL_PASSWORDLASTSET | \
                      USER_ALL_ACCOUNTEXPIRES | \
                      USER_ALL_USERACCOUNTCONTROL | \
                      USER_ALL_USERCOMMENT | \
                      USER_ALL_COUNTRYCODE | \
                      USER_ALL_CODEPAGE | \
                      USER_ALL_PARAMETERS    | \
                      USER_ALL_NTPASSWORDPRESENT | \
                      USER_ALL_LMPASSWORDPRESENT | \
                      USER_ALL_PRIVATEDATA | \
                      USER_ALL_SECURITYDESCRIPTOR )

    NlAssert( (UserAll->Internal3.I1.WhichFields & FIELDS_USED) == FIELDS_USED );



    //
    // Allocate a buffer to return to the caller.
    //

    DeltaUser = (PNETLOGON_DELTA_USER)
        MIDL_user_allocate( sizeof(NETLOGON_DELTA_USER) );

    if (DeltaUser == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaUser, sizeof(NETLOGON_DELTA_USER) );
    // INIT_PLACE_HOLDER(DeltaUser);

    Delta->DeltaUnion.DeltaUser = DeltaUser;
    *BufferSize += sizeof(NETLOGON_DELTA_USER);

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&UserAll->Internal3.I1.UserName,
                    &DeltaUser->UserName );

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&UserAll->Internal3.I1.FullName,
                    &DeltaUser->FullName );

    DeltaUser->UserId = UserAll->Internal3.I1.UserId;
    DeltaUser->PrimaryGroupId = UserAll->Internal3.I1.PrimaryGroupId;

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&UserAll->Internal3.I1.HomeDirectory,
                    &DeltaUser->HomeDirectory );

    *BufferSize += NlCopyUnicodeString(
                   (PUNICODE_STRING)&UserAll->Internal3.I1.HomeDirectoryDrive,
                   &DeltaUser->HomeDirectoryDrive );

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&UserAll->Internal3.I1.ScriptPath,
                    &DeltaUser->ScriptPath );

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&UserAll->Internal3.I1.AdminComment,
                    &DeltaUser->AdminComment );

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&UserAll->Internal3.I1.WorkStations,
                    &DeltaUser->WorkStations );

    DeltaUser->LastLogon = UserAll->Internal3.I1.LastLogon;
    DeltaUser->LastLogoff = UserAll->Internal3.I1.LastLogoff;

    //
    // Copy Logon Hours
    //

    DeltaUser->LogonHours.UnitsPerWeek = UserAll->Internal3.I1.LogonHours.UnitsPerWeek;
    DeltaUser->LogonHours.LogonHours = UserAll->Internal3.I1.LogonHours.LogonHours;
    UserAll->Internal3.I1.LogonHours.LogonHours = NULL; // Don't let SAM free this.
    *BufferSize += (UserAll->Internal3.I1.LogonHours.UnitsPerWeek + 7) / 8;



    DeltaUser->BadPasswordCount = UserAll->Internal3.I1.BadPasswordCount;
    DeltaUser->LogonCount = UserAll->Internal3.I1.LogonCount;

    DeltaUser->PasswordLastSet = UserAll->Internal3.I1.PasswordLastSet;
    DeltaUser->AccountExpires = UserAll->Internal3.I1.AccountExpires;

    //
    // Don't copy lockout bit to BDC unless it understands it.
    //

    DeltaUser->UserAccountControl = UserAll->Internal3.I1.UserAccountControl;
    if ( (SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_ACCOUNT_LOCKOUT) == 0 ){
        DeltaUser->UserAccountControl &= ~USER_ACCOUNT_AUTO_LOCKED;
    }

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&UserAll->Internal3.I1.UserComment,
                    &DeltaUser->UserComment );

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&UserAll->Internal3.I1.Parameters,
                    &DeltaUser->Parameters );

    DeltaUser->CountryCode = UserAll->Internal3.I1.CountryCode;
    DeltaUser->CodePage = UserAll->Internal3.I1.CodePage;

    //
    // Set private data.
    //  Includes passwords and password history.
    //

    DeltaUser->PrivateData.SensitiveData = UserAll->Internal3.I1.PrivateDataSensitive;

    if ( UserAll->Internal3.I1.PrivateDataSensitive ) {

        CRYPT_BUFFER Data;

        //
        // encrypt private data using session key
        // Re-use the SAM's buffer and encrypt it in place.
        //

        Data.Length = Data.MaximumLength = UserAll->Internal3.I1.PrivateData.Length;
        Data.Buffer = (PUCHAR) UserAll->Internal3.I1.PrivateData.Buffer;
        UserAll->Internal3.I1.PrivateData.Buffer = NULL;

        Status = NlEncryptSensitiveData( &Data, SessionInfo );

        if( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        DeltaUser->PrivateData.DataLength = Data.Length;
        DeltaUser->PrivateData.Data = Data.Buffer;
    } else {

        DeltaUser->PrivateData.DataLength = UserAll->Internal3.I1.PrivateData.Length;
        DeltaUser->PrivateData.Data = (PUCHAR) UserAll->Internal3.I1.PrivateData.Buffer;

        UserAll->Internal3.I1.PrivateData.Buffer = NULL;
    }

    { // ?? Macro requires a Local named SecurityDescriptor
        PSAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor;
        SecurityDescriptor = &UserAll->Internal3.I1.SecurityDescriptor;
        DELTA_SECOBJ_INFO(DeltaUser);
    }


    //
    // copy profile path in DummyStrings
    //

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&UserAll->Internal3.I1.ProfilePath,
                    &DeltaUser->DummyString1 );

    //
    // Copy LastBadPasswordTime to DummyLong1 and DummyLong2.
    //

    DeltaUser->DummyLong1 = UserAll->Internal3.LastBadPasswordTime.HighPart;
    DeltaUser->DummyLong2 = UserAll->Internal3.LastBadPasswordTime.LowPart;

    //
    // All Done
    //

    Status = STATUS_SUCCESS;


Cleanup:


    STARTSAMTIMER;

    if( UserHandle != NULL ) {
        (VOID) SamrCloseHandle( &UserHandle );
    }

    if ( UserAll != NULL ) {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserAll, UserInternal3Information );
    }

    STOPSAMTIMER;

    if( !NT_SUCCESS(Status) ) {
        NlFreeDBDelta( Delta );
        *BufferSize = 0;
    }

    STOPPACKTIMER;

    NlPrint((NL_REPL_OBJ_TIME,"Time taken to pack USER object:\n"));
    PRINTPACKTIMER;
    PRINTSAMTIMER;

    return Status;
}


NTSTATUS
NlPackSamGroup (
    IN ULONG RelativeId,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    LPDWORD BufferSize
    )
/*++

Routine Description:

    Pack a description of the specified group into the specified buffer.

Arguments:

    RelativeId - The relative Id of the group query.

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;
    SAMPR_HANDLE GroupHandle = NULL;
    PNETLOGON_DELTA_GROUP DeltaGroup;

    //
    // Information returned from SAM
    //

    PSAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    PSAMPR_GROUP_INFO_BUFFER GroupGeneral = NULL;

    DEFPACKTIMER;
    DEFSAMTIMER;

    INITPACKTIMER;
    INITSAMTIMER;

    STARTPACKTIMER;

    NlPrint((NL_SYNC_MORE, "Packing Group Object %lx\n", RelativeId ));

    *BufferSize = 0;

    Delta->DeltaType = AddOrChangeGroup;
    Delta->DeltaID.Rid = RelativeId;
    Delta->DeltaUnion.DeltaGroup = NULL;

    //
    // Open a handle to the specified group.
    //

    STARTSAMTIMER;

    Status = SamIOpenAccount( DBInfo->DBHandle,
                              RelativeId,
                              SecurityDbObjectSamGroup,
                              &GroupHandle );

    if (!NT_SUCCESS(Status)) {
        GroupHandle = NULL;
        goto Cleanup;
    }

    STOPSAMTIMER;

    QUERY_SAM_SECOBJ_INFO(GroupHandle);

    STARTSAMTIMER;

    Status = SamrQueryInformationGroup(
                GroupHandle,
                GroupReplicationInformation,
                &GroupGeneral );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        GroupGeneral = NULL;
        goto Cleanup;
    }

    NlPrint((NL_SYNC_MORE,
        "\t Group Object name %wZ\n",
            (PUNICODE_STRING)&GroupGeneral->General.Name ));

    DeltaGroup = (PNETLOGON_DELTA_GROUP)
        MIDL_user_allocate( sizeof(NETLOGON_DELTA_GROUP) );

    if( DeltaGroup == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaGroup, sizeof(NETLOGON_DELTA_GROUP) );
    // INIT_PLACE_HOLDER(DeltaGroup);

    Delta->DeltaUnion.DeltaGroup = DeltaGroup;
    *BufferSize += sizeof(NETLOGON_DELTA_GROUP);

    *BufferSize = NlCopyUnicodeString(
                    (PUNICODE_STRING)&GroupGeneral->General.Name,
                    &DeltaGroup->Name );

    DeltaGroup->RelativeId = RelativeId;
    DeltaGroup->Attributes = GroupGeneral->General.Attributes;

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&GroupGeneral->General.AdminComment,
                    &DeltaGroup->AdminComment );


    DELTA_SECOBJ_INFO(DeltaGroup);

    //
    // All Done
    //

    Status = STATUS_SUCCESS;

Cleanup:
    STARTSAMTIMER;

    if( GroupHandle != NULL ) {
        (VOID) SamrCloseHandle( &GroupHandle );
    }

    if ( SecurityDescriptor != NULL ) {
        SamIFree_SAMPR_SR_SECURITY_DESCRIPTOR( SecurityDescriptor );
    }

    if ( GroupGeneral != NULL ) {
        SamIFree_SAMPR_GROUP_INFO_BUFFER( GroupGeneral,
                                          GroupReplicationInformation );
    }

    STOPSAMTIMER;

    if( !NT_SUCCESS(Status) ) {
        NlFreeDBDelta( Delta );
        *BufferSize = 0;
    }

    STOPPACKTIMER;

    NlPrint((NL_REPL_OBJ_TIME,"Time taken to pack GROUP object:\n"));
    PRINTPACKTIMER;
    PRINTSAMTIMER;

    return Status;
}


NTSTATUS
NlPackSamGroupMember (
    IN ULONG RelativeId,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    LPDWORD BufferSize
    )
/*++

Routine Description:

    Pack a description of the membership of the specified group into
    the specified buffer.

Arguments:

    RelativeId - The relative Id of the group query.

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;
    SAMPR_HANDLE GroupHandle = NULL;
    DWORD Size;
    PNETLOGON_DELTA_GROUP_MEMBER DeltaGroupMember;

    //
    // Information returned from SAM
    //

    PSAMPR_GET_MEMBERS_BUFFER MembersBuffer = NULL;

    DEFPACKTIMER;
    DEFSAMTIMER;

    INITPACKTIMER;
    INITSAMTIMER;

    STARTPACKTIMER;

    NlPrint((NL_SYNC_MORE, "Packing GroupMember Object %lx\n", RelativeId));

    *BufferSize = 0;

    Delta->DeltaType = ChangeGroupMembership;
    Delta->DeltaID.Rid = RelativeId;
    Delta->DeltaUnion.DeltaGroupMember = NULL;

    //
    // Open a handle to the specified group.
    //

    STARTSAMTIMER;

    Status = SamIOpenAccount( DBInfo->DBHandle,
                              RelativeId,
                              SecurityDbObjectSamGroup,
                              &GroupHandle );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        GroupHandle = NULL;
        goto Cleanup;
    }

    //
    // Find out everything there is to know about the group.
    //

    STARTSAMTIMER;

    Status = SamrGetMembersInGroup( GroupHandle, &MembersBuffer );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        MembersBuffer = NULL;
        goto Cleanup;
    }

    DeltaGroupMember = (PNETLOGON_DELTA_GROUP_MEMBER)
        MIDL_user_allocate( sizeof(NETLOGON_DELTA_GROUP_MEMBER) );

    if( DeltaGroupMember == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaGroupMember,
                    sizeof(NETLOGON_DELTA_GROUP_MEMBER) );

    Delta->DeltaUnion.DeltaGroupMember = DeltaGroupMember;
    *BufferSize += sizeof(NETLOGON_DELTA_GROUP_MEMBER);

    if ( MembersBuffer->MemberCount != 0 ) {
        Size = MembersBuffer->MemberCount * sizeof(*MembersBuffer->Members);

        *BufferSize += NlCopyData(
                        (LPBYTE *)&MembersBuffer->Members,
                        (LPBYTE *)&DeltaGroupMember->MemberIds,
                        Size );

        Size = MembersBuffer->MemberCount *
                    sizeof(*MembersBuffer->Attributes);

        *BufferSize += NlCopyData(
                        (LPBYTE *)&MembersBuffer->Attributes,
                        (LPBYTE *)&DeltaGroupMember->Attributes,
                        Size );
    }

    DeltaGroupMember->MemberCount = MembersBuffer->MemberCount;

    //
    // Initialize placeholder strings to NULL.
    //

    DeltaGroupMember->DummyLong1 = 0;
    DeltaGroupMember->DummyLong2 = 0;
    DeltaGroupMember->DummyLong3 = 0;
    DeltaGroupMember->DummyLong4 = 0;

    //
    // All Done
    //

    Status = STATUS_SUCCESS;

Cleanup:
    STARTSAMTIMER;

    if( GroupHandle != NULL ) {
        (VOID) SamrCloseHandle( &GroupHandle );
    }

    if ( MembersBuffer != NULL ) {
        SamIFree_SAMPR_GET_MEMBERS_BUFFER( MembersBuffer );
    }

    STOPSAMTIMER;

    if( !NT_SUCCESS(Status) ) {
        NlFreeDBDelta( Delta );
        *BufferSize = 0;
    }

    STOPPACKTIMER;

    NlPrint((NL_REPL_OBJ_TIME,"Time taken to pack GROUPMEMBER object:\n"));
    PRINTPACKTIMER;
    PRINTSAMTIMER;

    return Status;
}


NTSTATUS
NlPackSamAlias (
    IN ULONG RelativeId,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    LPDWORD BufferSize
    )
/*++

Routine Description:

    Pack a description of the specified alias into the specified buffer.

Arguments:

    RelativeId - The relative Id of the alias query.

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;
    SAMPR_HANDLE AliasHandle = NULL;
    PNETLOGON_DELTA_ALIAS DeltaAlias;

    //
    // Information returned from SAM
    //

    PSAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor = NULL;

    PSAMPR_ALIAS_INFO_BUFFER AliasGeneral = NULL;

    DEFPACKTIMER;
    DEFSAMTIMER;

    INITPACKTIMER;
    INITSAMTIMER;

    STARTPACKTIMER;

    NlPrint((NL_SYNC_MORE, "Packing Alias Object %lx\n", RelativeId));

    *BufferSize = 0;

    Delta->DeltaType = AddOrChangeAlias;
    Delta->DeltaID.Rid = RelativeId;
    Delta->DeltaUnion.DeltaAlias = NULL;

    //
    // Open a handle to the specified alias.
    //

    STARTSAMTIMER;

    Status = SamIOpenAccount( DBInfo->DBHandle,
                              RelativeId,
                              SecurityDbObjectSamAlias,
                              &AliasHandle );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        AliasHandle = NULL;
        goto Cleanup;
    }

    QUERY_SAM_SECOBJ_INFO(AliasHandle);

    //
    // Determine the alias name.
    //

    STARTSAMTIMER;

    Status = SamrQueryInformationAlias(
                    AliasHandle,
                    AliasReplicationInformation,
                    &AliasGeneral );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        AliasGeneral = NULL;
        goto Cleanup;
    }

    NlPrint((NL_SYNC_MORE, "\t Alias Object name %wZ\n",
            (PUNICODE_STRING)&(AliasGeneral->General.Name)));

    DeltaAlias = (PNETLOGON_DELTA_ALIAS)
        MIDL_user_allocate( sizeof(NETLOGON_DELTA_ALIAS) );

    if( DeltaAlias == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaAlias, sizeof(NETLOGON_DELTA_ALIAS) );
    // INIT_PLACE_HOLDER(DeltaAlias);

    Delta->DeltaUnion.DeltaAlias = DeltaAlias;
    *BufferSize += sizeof(NETLOGON_DELTA_ALIAS);

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&(AliasGeneral->General.Name),
                    &DeltaAlias->Name );

    DeltaAlias->RelativeId = RelativeId;

    DELTA_SECOBJ_INFO(DeltaAlias);

    //
    // copy comment string
    //

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&(AliasGeneral->General.AdminComment),
                    &DeltaAlias->DummyString1 );

    //
    // All Done
    //

    Status = STATUS_SUCCESS;

Cleanup:
    STARTSAMTIMER;

    if( AliasHandle != NULL ) {
        (VOID) SamrCloseHandle( &AliasHandle );
    }

    if ( SecurityDescriptor != NULL ) {
        SamIFree_SAMPR_SR_SECURITY_DESCRIPTOR( SecurityDescriptor );
    }


    if( AliasGeneral != NULL ) {

        SamIFree_SAMPR_ALIAS_INFO_BUFFER (
            AliasGeneral,
            AliasReplicationInformation );
    }

    STOPSAMTIMER;

    if( !NT_SUCCESS(Status) ) {
        NlFreeDBDelta( Delta );
        *BufferSize = 0;
    }

    STOPPACKTIMER;

    NlPrint((NL_REPL_OBJ_TIME,"Time taken to pack ALIAS object:\n"));
    PRINTPACKTIMER;
    PRINTSAMTIMER;

    return Status;
}


NTSTATUS
NlPackSamAliasMember (
    IN ULONG RelativeId,
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    LPDWORD BufferSize
    )
/*++

Routine Description:

    Pack a description of the membership of the specified alias into
    the specified buffer.

Arguments:

    RelativeId - The relative Id of the alias query.

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;
    SAMPR_HANDLE AliasHandle = NULL;
    PNETLOGON_DELTA_ALIAS_MEMBER DeltaAliasMember;
    DWORD i;

    //
    // Information returned from SAM
    //

    NLPR_SID_ARRAY Members;
    PNLPR_SID_INFORMATION Sids;

    DEFPACKTIMER;
    DEFSAMTIMER;

    INITPACKTIMER;
    INITSAMTIMER;

    STARTPACKTIMER;

    NlPrint((NL_SYNC_MORE, "Packing AliasMember Object %lx\n", RelativeId));

    *BufferSize = 0;

    Delta->DeltaType = ChangeAliasMembership;
    Delta->DeltaID.Rid = RelativeId;
    Delta->DeltaUnion.DeltaAliasMember = NULL;

    Members.Sids = NULL;


    //
    // Open a handle to the specified alias.
    //

    STARTSAMTIMER;

    Status = SamIOpenAccount( DBInfo->DBHandle,
                              RelativeId,
                              SecurityDbObjectSamAlias,
                              &AliasHandle );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        AliasHandle = NULL;
        goto Cleanup;
    }

    //
    // Find out everything there is to know about the alias.
    //

    STARTSAMTIMER;

    Status = SamrGetMembersInAlias( AliasHandle,
                (PSAMPR_PSID_ARRAY_OUT)&Members );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        Members.Sids = NULL;
        goto Cleanup;
    }


    DeltaAliasMember = (PNETLOGON_DELTA_ALIAS_MEMBER)
        MIDL_user_allocate( sizeof(NETLOGON_DELTA_ALIAS_MEMBER) );

    if( DeltaAliasMember == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // wipe off the buffer so that cleanup will not be in fault.
    //

    RtlZeroMemory( DeltaAliasMember,
                        sizeof(NETLOGON_DELTA_ALIAS_MEMBER) );

    Delta->DeltaUnion.DeltaAliasMember = DeltaAliasMember;
    *BufferSize += sizeof(NETLOGON_DELTA_ALIAS_MEMBER);

    //
    // tie up sam return node to our return node
    //

    DeltaAliasMember->Members = Members;

    //
    // however, compute the MIDL buffer consumed for members node.
    //

    for(i = 0, Sids = Members.Sids; i < Members.Count; ++i, Sids++) {

        *BufferSize += (sizeof(PNLPR_SID_INFORMATION) +
                            RtlLengthSid(Sids->SidPointer));

    }

    *BufferSize += sizeof(SAMPR_PSID_ARRAY);

    //
    // Initialize placeholder strings to NULL.
    //

    DeltaAliasMember->DummyLong1 = 0;
    DeltaAliasMember->DummyLong2 = 0;
    DeltaAliasMember->DummyLong3 = 0;
    DeltaAliasMember->DummyLong4 = 0;

    //
    // All Done
    //

    Status = STATUS_SUCCESS;

Cleanup:

    STARTSAMTIMER;

    if( AliasHandle != NULL ) {
        (VOID) SamrCloseHandle( &AliasHandle );
    }

    if ( Members.Sids != NULL ) {

        //
        // don't free this node because we have tied up this
        // node to our return info to RPC which will free it up
        // when it is done with it.
        //
        // however, free this node under error conditions
        //

    }

    if( !NT_SUCCESS(Status) ) {

        SamIFree_SAMPR_PSID_ARRAY( (PSAMPR_PSID_ARRAY)&Members );

        if( Delta->DeltaUnion.DeltaAliasMember != NULL ) {
            Delta->DeltaUnion.DeltaAliasMember->Members.Sids = NULL;
        }

        NlFreeDBDelta( Delta );
        *BufferSize = 0;
    }

    STOPSAMTIMER;

    STOPPACKTIMER;

    NlPrint((NL_REPL_OBJ_TIME,"Timing for ALIASMEBER object packing:\n"));
    PRINTPACKTIMER;
    PRINTSAMTIMER;

    return Status;
}


NTSTATUS
NlPackSamDomain (
    IN OUT PNETLOGON_DELTA_ENUM Delta,
    IN PDB_INFO DBInfo,
    IN LPDWORD BufferSize
    )
/*++

Routine Description:

    Pack a description of the sam domain into the specified buffer.

Arguments:

    Delta: pointer to the delta structure where the new delta will
        be returned.

    DBInfo: pointer to the database info structure.

    BufferSize: size of MIDL buffer that is consumed for this delta is
        returned here.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;

    PNETLOGON_DELTA_DOMAIN DeltaDomain = NULL;

    //
    // Information returned from SAM
    //

    PSAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    PSAMPR_DOMAIN_INFO_BUFFER DomainGeneral = NULL;
    PSAMPR_DOMAIN_INFO_BUFFER DomainPassword = NULL;
    PSAMPR_DOMAIN_INFO_BUFFER DomainModified = NULL;
    PSAMPR_DOMAIN_INFO_BUFFER DomainLockout = NULL;

    DEFPACKTIMER;
    DEFSAMTIMER;

    INITPACKTIMER;
    INITSAMTIMER;

    STARTPACKTIMER;

    NlPrint((NL_SYNC_MORE, "Packing Domain Object\n"));

    *BufferSize = 0;

    Delta->DeltaType = AddOrChangeDomain;
    Delta->DeltaID.Rid = 0;
    Delta->DeltaUnion.DeltaDomain = NULL;


    QUERY_SAM_SECOBJ_INFO(DBInfo->DBHandle);

    STARTSAMTIMER;

    Status = SamrQueryInformationDomain(
                DBInfo->DBHandle,
                DomainGeneralInformation,
                &DomainGeneral );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        DomainGeneral = NULL;
        goto Cleanup;
    }


    STARTSAMTIMER;

    Status = SamrQueryInformationDomain(
                DBInfo->DBHandle,
                DomainPasswordInformation,
                &DomainPassword );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        DomainPassword = NULL;
        goto Cleanup;
    }

    STARTSAMTIMER;

    Status = SamrQueryInformationDomain(
                DBInfo->DBHandle,
                DomainModifiedInformation,
                &DomainModified );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        DomainModified = NULL;
        goto Cleanup;
    }

    STARTSAMTIMER;

    Status = SamrQueryInformationDomain(
                DBInfo->DBHandle,
                DomainLockoutInformation,
                &DomainLockout );

    STOPSAMTIMER;

    if (!NT_SUCCESS(Status)) {
        DomainLockout = NULL;
        goto Cleanup;
    }

    //
    // Fill in the delta structure
    //


    DeltaDomain = (PNETLOGON_DELTA_DOMAIN)
        MIDL_user_allocate( sizeof(NETLOGON_DELTA_DOMAIN) );

    if( DeltaDomain == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Zero the buffer so that cleanup will not access violate.
    //

    RtlZeroMemory( DeltaDomain, sizeof(NETLOGON_DELTA_DOMAIN) );
    // INIT_PLACE_HOLDER(DeltaDomain);

    Delta->DeltaUnion.DeltaDomain = DeltaDomain;
    *BufferSize += sizeof(NETLOGON_DELTA_DOMAIN);

    *BufferSize += NlCopyUnicodeString(
                    (PUNICODE_STRING)&DomainGeneral->General.DomainName,
                    &DeltaDomain->DomainName );

    *BufferSize = NlCopyUnicodeString(
                    (PUNICODE_STRING)&DomainGeneral->General.OemInformation,
                    &DeltaDomain->OemInformation );

    DeltaDomain->ForceLogoff = DomainGeneral->General.ForceLogoff;
    DeltaDomain->MinPasswordLength =
            DomainPassword->Password.MinPasswordLength;
    DeltaDomain->PasswordHistoryLength =
            DomainPassword->Password.PasswordHistoryLength;

    NEW_TO_OLD_LARGE_INTEGER(
        DomainPassword->Password.MaxPasswordAge,
        DeltaDomain->MaxPasswordAge );

    NEW_TO_OLD_LARGE_INTEGER(
        DomainPassword->Password.MinPasswordAge,
        DeltaDomain->MinPasswordAge );

    NEW_TO_OLD_LARGE_INTEGER(
        DomainModified->Modified.DomainModifiedCount,
        DeltaDomain->DomainModifiedCount );

    NEW_TO_OLD_LARGE_INTEGER(
        DomainModified->Modified.CreationTime,
        DeltaDomain->DomainCreationTime );


    DELTA_SECOBJ_INFO(DeltaDomain);

    //
    // replicate PasswordProperties using reserved field.
    //

    DeltaDomain->DummyLong1 =
            DomainPassword->Password.PasswordProperties;

    //
    // Replicate DOMAIN_LOCKOUT_INFORMATION using reserved field.
    //

    DeltaDomain->DummyString1.Buffer = (LPWSTR) DomainLockout;
    DeltaDomain->DummyString1.MaximumLength =
        DeltaDomain->DummyString1.Length = sizeof( DomainLockout->Lockout);
    DomainLockout = NULL;

    //
    // All Done
    //

    Status = STATUS_SUCCESS;

Cleanup:

    STARTSAMTIMER;

    if ( SecurityDescriptor != NULL ) {
        SamIFree_SAMPR_SR_SECURITY_DESCRIPTOR( SecurityDescriptor );
    }

    if ( DomainGeneral != NULL ) {
        SamIFree_SAMPR_DOMAIN_INFO_BUFFER( DomainGeneral,
                                           DomainGeneralInformation );
    }

    if ( DomainPassword != NULL ) {
        SamIFree_SAMPR_DOMAIN_INFO_BUFFER( DomainPassword,
                                           DomainPasswordInformation );
    }

    if ( DomainModified != NULL ) {
        SamIFree_SAMPR_DOMAIN_INFO_BUFFER( DomainModified,
                                           DomainModifiedInformation );
    }

    if ( DomainLockout != NULL ) {
        SamIFree_SAMPR_DOMAIN_INFO_BUFFER( DomainLockout,
                                           DomainLockoutInformation );
    }

    STOPSAMTIMER;

    if( !NT_SUCCESS(Status) ) {
        NlFreeDBDelta( Delta );
        *BufferSize = 0;
    }

    STOPPACKTIMER;

    NlPrint((NL_REPL_OBJ_TIME,"Timing for DOMAIN object packing:\n"));
    PRINTPACKTIMER;
    PRINTSAMTIMER;

    return Status;
}





NTSTATUS
NlEncryptSensitiveData(
    IN OUT PCRYPT_BUFFER Data,
    IN PSESSION_INFO SessionInfo
    )
/*++

Routine Description:

    Encrypt data using the the server session key.

    Either DES or RC4 will be used depending on the negotiated flags in SessionInfo.

Arguments:

    Data: Pointer to the data to be decrypted.  If the decrypted data is longer
        than the encrypt data, this routine will allocate a buffer for
        the returned data using MIDL_user_allocate and return a description to
        that buffer here.  In that case, this routine will free the buffer
        containing the encrypted text data using MIDL_user_free.

    SessionInfo: Info describing BDC that's calling us

Return Value:

    NT status code

--*/
{
    NTSTATUS Status;
    DATA_KEY KeyData;


    //
    // If both sides support RC4 encryption, use it.
    //

    if ( SessionInfo->NegotiatedFlags & NETLOGON_SUPPORTS_RC4_ENCRYPTION ) {

        NlEncryptRC4( Data->Buffer, Data->Length, SessionInfo );
        Status = STATUS_SUCCESS;


    //
    // If the other side is running NT 3.1,
    //  use the slower DES based encryption.
    //

    } else {
        CYPHER_DATA TempData;

        //
        // Build a data buffer to describe the encryption key.
        //

        KeyData.Length = sizeof(NETLOGON_SESSION_KEY);
        KeyData.MaximumLength = sizeof(NETLOGON_SESSION_KEY);
        KeyData.Buffer = (PVOID)&SessionInfo->SessionKey;

        //
        // Build a data buffer to describe the encrypted data.
        //

        TempData.Length = 0;
        TempData.MaximumLength = 0;
        TempData.Buffer = NULL;

        //
        // First time make the encrypt call to determine the length.
        //

        Status = RtlEncryptData(
                        (PCLEAR_DATA)Data,
                        &KeyData,
                        &TempData );

        if( Status != STATUS_BUFFER_TOO_SMALL ) {
            return(Status);
        }

        //
        // allocate output buffer.
        //

        TempData.MaximumLength = TempData.Length;
        TempData.Buffer = MIDL_user_allocate( TempData.Length );

        if( TempData.Buffer == NULL ) {
            return(STATUS_NO_MEMORY);
        }

        //
        // Encrypt the data.
        //

        IF_NL_DEBUG( ENCRYPT ) {
            NlPrint((NL_ENCRYPT, "NlEncryptSensitiveData: Clear data: " ));
            NlpDumpBuffer( NL_ENCRYPT, Data->Buffer, Data->Length  );
        }

        Status = RtlEncryptData(
                        (PCLEAR_DATA)Data,
                        &KeyData,
                        &TempData );

        IF_NL_DEBUG( ENCRYPT ) {
            NlPrint((NL_ENCRYPT, "NlEncryptSensitiveData: Encrypted data: " ));
            NlpDumpBuffer( NL_ENCRYPT, TempData.Buffer, TempData.Length );
        }

        //
        // Return either the clear text or encrypted buffer to the caller.
        //

        if( NT_SUCCESS(Status) ) {
            MIDL_user_free( Data->Buffer );
            Data->Length = TempData.Length;
            Data->MaximumLength = TempData.MaximumLength;
            Data->Buffer = TempData.Buffer;
        } else {
            MIDL_user_free( TempData.Buffer );
        }

    }

    return( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\samregp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    samregp.h

Abstract:

    This file contains definitions private to the SAM server program.

    Only those definitions defining the registry structure are here.
    This file is shared by test programs (e.g., nltest.exe) that read the
    registry directly.

Author:

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NTSAMREGP_
#define _NTSAMREGP_


//
// Fixed length portion of a user account
// (previous release formats of this structure follow)
//
// Note:  GroupCount could be treated as part of the fixed length
//        data, but it is more convenient to keep it with the Group RID
//        list in the GROUPS key.
//
// Note: in version 1.0 of NT, the fixed length portion of
//       a user was stored separate from the variable length
//       portion.  This allows us to compare the size of the
//       data read from disk against the size of a V1_0A form
//       of the fixed length data to determine whether it is
//       a Version 1 format or later format.


//
// This is the fixed length user from NT3.51 QFE and SUR
//


typedef struct _SAMP_V1_0A_FIXED_LENGTH_USER {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   LastLogon;
    LARGE_INTEGER   LastLogoff;
    LARGE_INTEGER   PasswordLastSet;
    LARGE_INTEGER   AccountExpires;
    LARGE_INTEGER   LastBadPasswordTime;

    ULONG           UserId;
    ULONG           PrimaryGroupId;
    ULONG           UserAccountControl;

    USHORT          CountryCode;
    USHORT          CodePage;
    USHORT          BadPasswordCount;
    USHORT          LogonCount;
    USHORT          AdminCount;
    USHORT          Unused2;
    USHORT          OperatorCount;

} SAMP_V1_0A_FIXED_LENGTH_USER, *PSAMP_V1_0A_FIXED_LENGTH_USER;

//
// This is the fixed length user from NT3.5 and NT3.51
//


typedef struct _SAMP_V1_0_FIXED_LENGTH_USER {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   LastLogon;
    LARGE_INTEGER   LastLogoff;
    LARGE_INTEGER   PasswordLastSet;
    LARGE_INTEGER   AccountExpires;
    LARGE_INTEGER   LastBadPasswordTime;

    ULONG           UserId;
    ULONG           PrimaryGroupId;
    ULONG           UserAccountControl;

    USHORT          CountryCode;
    USHORT          CodePage;
    USHORT          BadPasswordCount;
    USHORT          LogonCount;
    USHORT          AdminCount;

} SAMP_V1_0_FIXED_LENGTH_USER, *PSAMP_V1_0_FIXED_LENGTH_USER;

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// This structure is used to describe where the data for               //
// an object's variable length attribute is.  This is a                //
// self-relative structure, allowing it to be stored on disk           //
// and later retrieved and used without fixing pointers.               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef struct _SAMP_VARIABLE_LENGTH_ATTRIBUTE {
    //
    // Indicates the offset of data from the address of this data
    // structure.
    //

    LONG Offset;


    //
    // Indicates the length of the data.
    //

    ULONG Length;


    //
    // A 32-bit value that may be associated with each variable
    // length attribute.  This may be used, for example, to indicate
    // how many elements are in the variable-length attribute.
    //

    ULONG Qualifier;

}  SAMP_VARIABLE_LENGTH_ATTRIBUTE, *PSAMP_VARIABLE_LENGTH_ATTRIBUTE;

#define SAMP_USER_VARIABLE_ATTRIBUTES   (17L)

#endif // _NTSAMREGP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\logonsrv\server\secpkg.c ===
/*--


Copyright (c) 1994-1997  Microsoft Corporation

Module Name:

    secpkg.c

Abstract:

    Security package used for Netlogon's secure channel between two netlogon
    processes.

Author:


Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    05-Mar-1994 (MikeSw)
        Created as user mode example SSPI

    02-Nov-1997 (CliffV)
        Converted to be the Netlogon security package.

--*/

//
// Common include files.
//
#include "logonsrv.h"   // Include files common to entire service
#pragma hdrstop


//
// Include files specific to this .c file
//

#include <spseal.h>

//
// Authentication Data for the Netlogon Authentication Package.
//
// This is the auth data to pass to RpcBindingSetAuthInfo for the
//  Netlogon authentication package.
//

typedef struct _NL_AUTH_DATA {

    //
    // Signature to identify that this is really AUTH Data
    //

    ULONG Signature;

#define NL_AUTH_DATA_SIGNATURE 0x29120227

    //
    // Size of this structure (in bytes)
    //

    ULONG Size;

    //
    // Information describing the session between the client and server.
    //
    SESSION_INFO SessionInfo;

    //
    // Domain name of the domain we're connecting to.
    //

    ULONG OemNetbiosDomainNameOffset;
    ULONG OemNetbiosDomainNameLength;

    ULONG Utf8DnsDomainNameOffset;

    //
    // Computer name of this machine
    //

    ULONG OemComputerNameOffset;
    ULONG OemComputerNameLength;

    ULONG Utf8ComputerNameOffset;
    ULONG Utf8ComputerNameLength;

    ULONG Utf8DnsHostNameOffset;

} NL_AUTH_DATA, *PNL_AUTH_DATA;


//
// A single credential
//  Only the outbound side has a credential allocated.  The inbound side simply
//  returns a constant handle to the caller.

#define NL_AUTH_SERVER_CRED 0xfefefefe

typedef struct _NL_AUTH_CREDENTIAL {

    //
    // Handle identifying the credential
    //
    CredHandle CredentialHandle;

    //
    // Global list of all credentials
    //
    struct _NL_AUTH_CREDENTIAL *Next;

    //
    // Reference count
    //

    ULONG ReferenceCount;

    //
    // For a client side (outbound) credential,
    //  this is a pointer to the information from the client session structure
    //  representing the secure channel to the server.
    //
    PNL_AUTH_DATA ClientAuthData;

} NL_AUTH_CREDENTIAL, *PNL_AUTH_CREDENTIAL;


//
// A single context.
//

typedef struct _NL_AUTH_CONTEXT {

    //
    // Handle identifying the context
    //
    CtxtHandle ContextHandle;

    //
    // Global list of all contexts
    //
    struct _NL_AUTH_CONTEXT * Next;
    LARGE_INTEGER Nonce;

    ULONG ContextFlags;

    //
    // Information describing the session between the client and server.
    //
    SESSION_INFO SessionInfo;

    enum {
        Idle,
        FirstInit,
        FirstAccept,
        SecondInit
    } State;

    //
    // Flags
    //

    BOOLEAN Inbound;
} NL_AUTH_CONTEXT, *PNL_AUTH_CONTEXT;


#define BUFFERTYPE(_x_) ((_x_).BufferType & ~SECBUFFER_ATTRMASK)


//
// On the wire message transmitted from client to server during the bind.
//
typedef enum {
    Negotiate,
    NegotiateResponse
} NL_AUTH_MESSAGE_TYPE;

typedef struct _NL_AUTH_MESSAGE {
    NL_AUTH_MESSAGE_TYPE MessageType;
    ULONG Flags;
#define NL_AUTH_NETBIOS_DOMAIN_NAME         0x0001      // Netbios Domain name exists in buffer
#define NL_AUTH_NETBIOS_COMPUTER_NAME       0x0002      // Netbios Computer name exists in buffer
#define NL_AUTH_DNS_DOMAIN_NAME             0x0004      // DNS Domain name exists in buffer
#define NL_AUTH_DNS_HOST_NAME               0x0008      // DNS Host name exists in buffer
#define NL_AUTH_UTF8_NETBIOS_COMPUTER_NAME  0x0010      // UTF-8 Netbios Computer name exists in buffer

    UCHAR Buffer[1];
} NL_AUTH_MESSAGE, *PNL_AUTH_MESSAGE;

//
// Signature for signed and sealed messages
//

#define NL_AUTH_ETYPE       KERB_ETYPE_RC4_PLAIN_OLD    // Encryption algorithm to use
#define NL_AUTH_CHECKSUM    KERB_CHECKSUM_MD5_HMAC  // Checksum algorithm to use

typedef struct _NL_AUTH_SIGNATURE {
    BYTE SignatureAlgorithm[2];           // see below table for values
    union {
        BYTE SignFiller[4];               // filler, must be ff ff ff ff
        struct {
            BYTE SealAlgorithm[2];
            BYTE SealFiller[2];
        };
    };
    BYTE Flags[2];

#define NL_AUTH_SIGNED_BYTES 8  // Number of bytes in signature before SequenceNumber

#define NL_AUTH_SEQUENCE_SIZE 8
    BYTE SequenceNumber[NL_AUTH_SEQUENCE_SIZE];
    BYTE Checksum[8];

    // Confounder must be the last field in the structure since it isn't sent on
    // the wire if we're only signing the message.
#define NL_AUTH_CONFOUNDER_SIZE    8
    BYTE Confounder[NL_AUTH_CONFOUNDER_SIZE];
} NL_AUTH_SIGNATURE, *PNL_AUTH_SIGNATURE;




#define PACKAGE_NAME            NL_PACKAGE_NAME
#define PACKAGE_COMMENT         L"Package for securing Netlogon's Secure Channel"
#define PACAKGE_CAPABILITIES    (SECPKG_FLAG_TOKEN_ONLY | \
                                 SECPKG_FLAG_MULTI_REQUIRED | \
                                 SECPKG_FLAG_CONNECTION | \
                                 SECPKG_FLAG_INTEGRITY | \
                                 SECPKG_FLAG_PRIVACY)
#define PACKAGE_VERSION         1
#define PACKAGE_RPCID           RPC_C_AUTHN_NETLOGON
#define PACKAGE_MAXTOKEN        (sizeof(NL_AUTH_MESSAGE) + DNLEN + 1 + CNLEN + 1 + 2*(NL_MAX_DNS_LENGTH+1) )
#define PACKAGE_SIGNATURE_SIZE  sizeof(NL_AUTH_SIGNATURE)



SecurityFunctionTableW SecTableW = {SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                                    EnumerateSecurityPackagesW,
                                    NULL,
                                    AcquireCredentialsHandleW,
                                    FreeCredentialsHandle,
                                    NULL, // LogonUser
                                    InitializeSecurityContextW,
                                    AcceptSecurityContext,
                                    NULL,
                                    DeleteSecurityContext,
                                    NULL,
                                    QueryContextAttributesW,
                                    ImpersonateSecurityContext,
                                    RevertSecurityContext,
                                    MakeSignature,
                                    VerifySignature,
                                    FreeContextBuffer,
                                    QuerySecurityPackageInfoW,
                                    SealMessage,
                                    UnsealMessage,
                                   };


PNL_AUTH_CONTEXT ContextList;
PNL_AUTH_CREDENTIAL CredentialList;

//
// Id's to identify a context or credential.
//  Access serialized by NlGlobalSecPkgCritSect
//
LARGE_INTEGER NextId = {0,0};

TimeStamp Forever = {0x7fffffff,0xfffffff};
TimeStamp Never = {0,0};



PVOID
NlBuildAuthData(
    PCLIENT_SESSION ClientSession
    )
/*++

Routine Description:

    Allocate an authentication data structure suitable for passing to
    RpcBindingSetAuthInfo

    On Entry,
        The caller must be a writer of the trust list entry.
        The trust list entry must be authenticated.

Arguments:

    ClientSession - Authenticated session describing the secure channel to a
        DC.

Return Value:

    Pointer to the AUTH_DATA.  (Buffer should be freed by calling I_NetLogonFree.)

    NULL: memory could not be allocated

--*/
{
    ULONG Size;
    PNL_AUTH_DATA ClientAuthData;
    LPBYTE Where;
    ULONG DnsDomainNameSize;
    ULONG DnsHostNameSize;

    NlAssert( ClientSession->CsReferenceCount > 0 );
    NlAssert( ClientSession->CsFlags & CS_WRITER );
    NlAssert( ClientSession->CsState == CS_AUTHENTICATED );

    //
    // Determine the size of the entry
    //

    DnsDomainNameSize =
        (ClientSession->CsUtf8DnsDomainName != NULL ?
            (strlen( ClientSession->CsUtf8DnsDomainName ) + 1) :
            0);

#ifdef notdef
    DnsHostNameSize =
        (ClientSession->CsDomainInfo->DomUtf8DnsHostName != NULL ?
            (strlen( ClientSession->CsDomainInfo->DomUtf8DnsHostName ) + 1) :
            0);
#else // notdef
    DnsHostNameSize = 0;
#endif // notdef

    Size = sizeof(NL_AUTH_DATA) +
           ClientSession->CsOemNetbiosDomainNameLength + 1 +
           ClientSession->CsDomainInfo->DomOemComputerNameLength + 1 +
           ClientSession->CsDomainInfo->DomUtf8ComputerNameLength + 1 +
           DnsDomainNameSize +
           DnsHostNameSize;

    //
    // Allocate the entry
    //

    ClientAuthData = NetpMemoryAllocate( Size );

    if ( ClientAuthData == NULL ) {
        return NULL;
    }

    Where = (LPBYTE) (ClientAuthData + 1);
    RtlZeroMemory( ClientAuthData, sizeof(NL_AUTH_DATA) );

    //
    // Fill in the fixed length fields.
    //

    ClientAuthData->Signature = NL_AUTH_DATA_SIGNATURE;
    ClientAuthData->Size = Size;

    ClientAuthData->SessionInfo.SessionKey = ClientSession->CsSessionKey;
    ClientAuthData->SessionInfo.NegotiatedFlags = ClientSession->CsNegotiatedFlags;


    //
    // Copy the Netbios domain name of the domain hosted by the DC into the buffer
    //

    if ( ClientSession->CsOemNetbiosDomainNameLength != 0 ) {

        ClientAuthData->OemNetbiosDomainNameOffset = (ULONG) (Where-(LPBYTE)ClientAuthData);
        ClientAuthData->OemNetbiosDomainNameLength =
            ClientSession->CsOemNetbiosDomainNameLength;

        RtlCopyMemory( Where,
                       ClientSession->CsOemNetbiosDomainName,
                       ClientSession->CsOemNetbiosDomainNameLength + 1 );
        Where += ClientAuthData->OemNetbiosDomainNameLength + 1;
    }


    //
    // Copy the OEM Netbios computer name of this machine into the buffer.
    //
    // ???: Only copy the Netbios computername or DNS host name.  Copy the
    //  one that was passed to the server on the NetServerReqChallenge.
    //
    if ( ClientSession->CsDomainInfo->DomOemComputerNameLength != 0 ) {

        ClientAuthData->OemComputerNameOffset = (ULONG) (Where-(LPBYTE)ClientAuthData);
        ClientAuthData->OemComputerNameLength =
            ClientSession->CsDomainInfo->DomOemComputerNameLength;

        RtlCopyMemory( Where,
                       ClientSession->CsDomainInfo->DomOemComputerName,
                       ClientSession->CsDomainInfo->DomOemComputerNameLength + 1);
        Where += ClientAuthData->OemComputerNameLength + 1;

    }

    //
    // Copy the UTF-8 Netbios computer name of this machine into the buffer.
    //
    if ( ClientSession->CsDomainInfo->DomUtf8ComputerNameLength != 0 ) {

        ClientAuthData->Utf8ComputerNameOffset = (ULONG) (Where-(LPBYTE)ClientAuthData);
        ClientAuthData->Utf8ComputerNameLength =
            ClientSession->CsDomainInfo->DomUtf8ComputerNameLength;

        RtlCopyMemory( Where,
                       ClientSession->CsDomainInfo->DomUtf8ComputerName,
                       ClientSession->CsDomainInfo->DomUtf8ComputerNameLength +1 );
        Where += ClientAuthData->Utf8ComputerNameLength + 1;

    }




    //
    // Copy the DNS domain name of the domain hosted by the DC into the buffer.
    //

    if ( ClientSession->CsUtf8DnsDomainName != NULL ) {

        ClientAuthData->Utf8DnsDomainNameOffset = (ULONG) (Where-(LPBYTE)ClientAuthData);

        RtlCopyMemory( Where, ClientSession->CsUtf8DnsDomainName, DnsDomainNameSize );
        Where += DnsDomainNameSize;
    }

    //
    // Copy the DNS host name name of this machine into the buffer.
    //
    // ???: Only copy the Netbios computername or DNS host name.  Copy the
    //  one that was passed to the server on the NetServerReqChallenge.
    //

#ifdef notdef
    if ( ClientSession->CsDomainInfo->DomUtf8DnsHostName != NULL ) {

        ClientAuthData->Utf8DnsHostNameOffset = (ULONG) (Where-(LPBYTE)ClientAuthData);

        RtlCopyMemory( Where, ClientSession->CsDomainInfo->DomUtf8DnsHostName, DnsHostNameSize );
        Where += DnsHostNameSize;
    }
#endif // notdef


    return ClientAuthData;

}

BOOL
NlEqualClientSessionKey(
    PCLIENT_SESSION ClientSession,
    PVOID ClientContext
    )
/*++

Routine Description:

    Checks whether the session key on the client session is equal
    to the session key on the client context.

    On Entry,
        The caller must be a writer of the trust list entry.

Arguments:

    ClientSession - Authenticated session describing the secure channel to a DC

    ClientContext - Client context returned from a previous call to NlBuildAuthData

Return Value:

    TRUE if the two session keys are equal.
    FALSE, otherwise.

--*/
{
    PNL_AUTH_DATA ClientAuthData = ClientContext;

    if ( ClientAuthData == NULL ) {
        return FALSE;
    }

    if ( RtlEqualMemory( &ClientSession->CsSessionKey,
                         &ClientAuthData->SessionInfo.SessionKey,
                         sizeof(ClientSession->CsSessionKey) ) ) {
        return TRUE;
    } else{
        return FALSE;
    }
}

BOOL
NlStartNetlogonCall(
    VOID
    )
/*++

Routine Description:

    Start a procedure call from outside the Netlogon service into the
    Netlogon Service.


Arguments:

    None.

Return Value:

    TRUE - Call is OK.  (Caller must call NlEndNetlogonCall())

    FALSE - Netlogon is not started.

--*/
{
    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    EnterCriticalSection( &NlGlobalMsvCritSect );
    if ( !NlGlobalMsvEnabled ) {
        LeaveCriticalSection( &NlGlobalMsvCritSect );
        return FALSE;
    }
    NlGlobalMsvThreadCount ++;
    LeaveCriticalSection( &NlGlobalMsvCritSect );
    return TRUE;
}


VOID
NlEndNetlogonCall(
    VOID
    )
/*++

Routine Description:

    End a procedure call from outside the Netlogon service into the
    Netlogon Service.


Arguments:

    None.

Return Value:

    None.

--*/
{

    //
    // Indicate that the calling thread has left netlogon.dll
    //

    EnterCriticalSection( &NlGlobalMsvCritSect );
    NlGlobalMsvThreadCount --;
    if ( NlGlobalMsvThreadCount == 0 && !NlGlobalMsvEnabled ) {
        if ( !SetEvent( NlGlobalMsvTerminateEvent ) ) {
            NlPrint((NL_CRITICAL, "Cannot set MSV termination event: %lu\n",
                              GetLastError() ));
        }
    }
    LeaveCriticalSection( &NlGlobalMsvCritSect );
}

PNL_AUTH_CREDENTIAL
LocateCredential(
    PCredHandle CredentialHandle
    )
/*++

Routine Description:

    Find a credential given its handle

Arguments:

    CredentialHandle - Handle to the credential to locate

Return Value:

    Pointer to the credential

--*/
{
    PNL_AUTH_CREDENTIAL TestCredential;
    RtlEnterCriticalSection(&NlGlobalSecPkgCritSect);

    for ( TestCredential = CredentialList;
          TestCredential != NULL;
          TestCredential = TestCredential->Next ) {

        if ( TestCredential->CredentialHandle.dwUpper == CredentialHandle->dwUpper &&
             TestCredential->CredentialHandle.dwLower == CredentialHandle->dwLower ) {
            break;
        }
    }

    RtlLeaveCriticalSection(&NlGlobalSecPkgCritSect);
    return(TestCredential);

}

BOOLEAN
DeleteCredential(
    PCtxtHandle CredentialHandle
    )
/*++

Routine Description:

    Delete a credential given its handle

Arguments:

    CredentialHandle - Handle to the credential to locate

Return Value:

    TRUE: if credential existed.

--*/
{
    PNL_AUTH_CREDENTIAL TestCredential, LastCredential;

    //
    // Find the credential.
    //
    RtlEnterCriticalSection(&NlGlobalSecPkgCritSect);
    LastCredential = NULL;

    for ( TestCredential = CredentialList;
          TestCredential != NULL ;
          TestCredential = TestCredential->Next ) {

        if ( TestCredential->CredentialHandle.dwUpper == CredentialHandle->dwUpper &&
             TestCredential->CredentialHandle.dwLower == CredentialHandle->dwLower ) {
            break;
        }
        LastCredential = TestCredential;
    }


    //
    // If we found it,
    //  Dereference it.
    //

    if ( TestCredential != NULL ) {

        TestCredential->ReferenceCount --;

        //
        // If this is the last dereference,
        //  delink it and delete it.
        //

        if ( TestCredential->ReferenceCount == 0 ) {
            if (LastCredential != NULL) {
                LastCredential->Next = TestCredential->Next;
            } else {
                NlAssert(CredentialList == TestCredential);
                CredentialList = TestCredential->Next;
            }
            NlPrint(( NL_SESSION_MORE,
                      "DeleteCredential: %lx.%lx: credential freed\n",
                      CredentialHandle->dwUpper, CredentialHandle->dwLower ));
            LocalFree(TestCredential);
        } else {
            NlPrint(( NL_SESSION_MORE,
                      "DeleteCredential: %lx.%lx: credential dereferenced: %ld\n",
                      CredentialHandle->dwUpper, CredentialHandle->dwLower,
                      TestCredential->ReferenceCount ));
        }

    } else {
        NlPrint(( NL_SESSION_MORE,
                  "DeleteCredential: %lx.%lx: credential handle not found\n",
                  CredentialHandle->dwUpper, CredentialHandle->dwLower ));
    }
    RtlLeaveCriticalSection(&NlGlobalSecPkgCritSect);

    return( TestCredential == NULL ? FALSE : TRUE );
}


PNL_AUTH_CREDENTIAL
AllocateCredential(
    IN PNL_AUTH_DATA ClientAuthData
    )
/*++

Routine Description:

    Allocate and initialize a credential (Client or server side)

Arguments:

    ClientAuthData - The client auth data to capture.

Return Value:

    Allocated credential. Delete this credential by DeleteCredential( Credential->CredentialHandle );
    NULL if credential cannot be allocated.

--*/
{
    PNL_AUTH_CREDENTIAL Credential;

    //
    // Determine if we already have a credential
    //

    RtlEnterCriticalSection(&NlGlobalSecPkgCritSect);

    for ( Credential = CredentialList;
          Credential != NULL;
          Credential = Credential->Next ) {

        if ( ClientAuthData->Size == Credential->ClientAuthData->Size &&
             RtlEqualMemory( ClientAuthData,
                             Credential->ClientAuthData,
                             ClientAuthData->Size ) ) {

            //
            // Return the existing credential to the caller.
            //

            Credential->ReferenceCount ++;

            NlPrint(( NL_SESSION_MORE,
                      "AllocateCredential: %lx.%lx: credential referenced: %ld\n",
                      Credential->CredentialHandle.dwUpper,
                      Credential->CredentialHandle.dwLower,
                      Credential->ReferenceCount ));

            goto Cleanup;
        }
    }

    //
    // Allocate a credential block.
    //

    Credential = (PNL_AUTH_CREDENTIAL)
            LocalAlloc( LMEM_ZEROINIT,
                        sizeof(NL_AUTH_CREDENTIAL) +
                            ClientAuthData->Size );

    if (Credential == NULL) {
        goto Cleanup;
    }

    //
    // Initialize the credential.
    //

    NextId.QuadPart ++;
    Credential->CredentialHandle.dwUpper = NextId.HighPart;
    Credential->CredentialHandle.dwLower = NextId.LowPart;
    Credential->ReferenceCount = 1;

    Credential->Next = CredentialList;
    CredentialList = Credential;

    //
    // Capture a local copy of the credential
    //  The caller might free the one passed in to us.
    //

    Credential->ClientAuthData = (PNL_AUTH_DATA)
        (((LPBYTE)Credential) + sizeof(NL_AUTH_CREDENTIAL));

    RtlCopyMemory( Credential->ClientAuthData,
                   ClientAuthData,
                   ClientAuthData->Size );

    NlPrint(( NL_SESSION_MORE,
              "AllocateCredential: %lx.%lx: credential allocated\n",
              Credential->CredentialHandle.dwUpper,
              Credential->CredentialHandle.dwLower ));


Cleanup:
    RtlLeaveCriticalSection(&NlGlobalSecPkgCritSect);
    return Credential;
}


PNL_AUTH_CONTEXT
LocateContext(
    PCtxtHandle ContextHandle
    )
/*++

Routine Description:

    Find a context given its handle

Arguments:

    ContextHandle - Handle to the context to locate

Return Value:

    Pointer to the context

--*/
{
    PNL_AUTH_CONTEXT TestContext;
    RtlEnterCriticalSection(&NlGlobalSecPkgCritSect);

    for ( TestContext = ContextList;
          TestContext != NULL;
          TestContext = TestContext->Next ) {

        if ( TestContext->ContextHandle.dwUpper == ContextHandle->dwUpper &&
             TestContext->ContextHandle.dwLower == ContextHandle->dwLower ) {
            break;
        }
    }

    RtlLeaveCriticalSection(&NlGlobalSecPkgCritSect);
    return(TestContext);

}

BOOLEAN
DeleteContext(
    PCtxtHandle ContextHandle
    )
/*++

Routine Description:

    Delete a context given its handle

Arguments:

    ContextHandle - Handle to the context to locate

Return Value:

    TRUE: Context existed

--*/
{
    PNL_AUTH_CONTEXT TestContext, LastContext;

    //
    // Find the context.
    //
    RtlEnterCriticalSection(&NlGlobalSecPkgCritSect);
    LastContext = NULL;

    for ( TestContext = ContextList;
          TestContext != NULL ;
          TestContext = TestContext->Next ) {

        if ( TestContext->ContextHandle.dwUpper == ContextHandle->dwUpper &&
             TestContext->ContextHandle.dwLower == ContextHandle->dwLower ) {
            break;
        }
        LastContext = TestContext;
    }

    //
    // If we found it,
    //  and it is no longer needed as a context or a credential,
    //  delink it and delete it.
    //

    if ( TestContext != NULL ) {

        if (LastContext != NULL) {
            LastContext->Next = TestContext->Next;
        } else {
            NlAssert(ContextList == TestContext);
            ContextList = TestContext->Next;
        }
        NlPrint(( NL_SESSION_MORE,
                  "DeleteContext: %lx.%lx: context freed\n",
                  ContextHandle->dwUpper, ContextHandle->dwLower ));
        LocalFree(TestContext);
    } else {
        NlPrint(( NL_SESSION_MORE,
                  "DeleteContext: %lx.%lx: context handle not found\n",
                  ContextHandle->dwUpper, ContextHandle->dwLower ));
    }
    RtlLeaveCriticalSection(&NlGlobalSecPkgCritSect);

    return( TestContext == NULL ? FALSE : TRUE );
}


PNL_AUTH_CONTEXT
AllocateContext(
    IN ULONG fContextReq
    )
/*++

Routine Description:

    Allocate and initialize a context (Client or server side)

Arguments:

    fContextReq - Context request flags

Return Value:

    Allocated context. Delete this context by DeleteContext( Context->ContextHandle, FALSE );
    NULL if context cannot be allocated.

--*/
{
    PNL_AUTH_CONTEXT Context;

    //
    // Allocate a context block.
    //

    Context = (PNL_AUTH_CONTEXT) LocalAlloc( LMEM_ZEROINIT, sizeof(NL_AUTH_CONTEXT) );

    if (Context == NULL) {
        return NULL;
    }

    //
    // Initialize the context.
    //
    Context->State = Idle;
    Context->ContextFlags = fContextReq;

    RtlEnterCriticalSection(&NlGlobalSecPkgCritSect);
    NextId.QuadPart ++;
    Context->ContextHandle.dwUpper = NextId.HighPart;
    Context->ContextHandle.dwLower = NextId.LowPart;

    Context->Next = ContextList;
    ContextList = Context;
    RtlLeaveCriticalSection(&NlGlobalSecPkgCritSect);

    return Context;
}




PSecBuffer
LocateBuffer(PSecBufferDesc Buffer, ULONG MinimumSize)
/*++

Routine Description:


Arguments:

    Standard.

Return Value:



--*/
{
    ULONG Index;
    if (Buffer == NULL) {
        return(NULL);
    }

    for (Index = 0; Index < Buffer->cBuffers  ; Index++) {
        if ( BUFFERTYPE(Buffer->pBuffers[Index]) == SECBUFFER_TOKEN) {

            //
            // Do size checking
            //

            if (Buffer->pBuffers[Index].cbBuffer < MinimumSize) {
                return(NULL);
            }
            return(&Buffer->pBuffers[Index]);
        }
    }
    return(NULL);
}



PSecBuffer
LocateSecBuffer(PSecBufferDesc Buffer)
/*++

Routine Description:

    Locate a buffer suitable for authentication

Arguments:

    Standard.

Return Value:



--*/
{
    return(LocateBuffer(Buffer, sizeof(NL_AUTH_MESSAGE)));
}



PSecBuffer
LocateSigBuffer(PSecBufferDesc Buffer)
/*++

Routine Description:

    Locate a buffer suitable for a signature

Arguments:

    Standard.

Return Value:



--*/
{
    return(LocateBuffer(Buffer, PACKAGE_SIGNATURE_SIZE - NL_AUTH_CONFOUNDER_SIZE ));
}




PSecurityFunctionTableW SEC_ENTRY
InitSecurityInterfaceW(VOID)
/*++

Routine Description:

    Initialization routine called by RPC to get pointers to all other routines.

Arguments:

    None.

Return Value:

    Pointer to function table.


--*/
{

    NlPrint(( NL_SESSION_MORE,
        "InitSecurityInterfaceW: called\n" ));

    return(&SecTableW);
}





SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleW(
    LPWSTR                      pszPrincipal,       // Name of principal
    LPWSTR                      pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
/*++

Routine Description:

    Client and Server side routine to grab a credential handle.

Arguments:

    Standard.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus;
    PNL_AUTH_CREDENTIAL Credential = NULL;

    NlPrint(( NL_SESSION_MORE,
        "AcquireCredentialsHandleW: called\n" ));

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return SEC_E_SECPKG_NOT_FOUND;
    }

    //
    // Validate the input parameters
    //

    if ((fCredentialUse & (SECPKG_CRED_BOTH)) == 0) {
        NlPrint(( NL_CRITICAL,
                  "AcquireCredentialHandle: Bad Credential Use 0x%lx.\n", fCredentialUse ));
        SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
        goto Cleanup;
    }
    if ((fCredentialUse & (SECPKG_CRED_BOTH)) == SECPKG_CRED_BOTH) {
        NlPrint(( NL_CRITICAL,
                  "AcquireCredentialHandle: Bad Credential Use 0x%lx.\n", fCredentialUse ));
        SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
        goto Cleanup;
    }

    //
    // Handle a client credential
    //

    if ((fCredentialUse & (SECPKG_CRED_BOTH)) == SECPKG_CRED_OUTBOUND) {

        //
        // Sanity check the client session
        //

        if ( pAuthData == NULL ) {
            NlPrint(( NL_CRITICAL,
                      "AcquireCredentialHandle: NULL auth data\n" ));
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }
        if ( ((PNL_AUTH_DATA)pAuthData)->Signature != NL_AUTH_DATA_SIGNATURE ) {
            NlPrint(( NL_CRITICAL,
                      "AcquireCredentialHandle: Invalid Signature on auth data\n" ));
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }


        //
        // Allocate a credential to remember the AuthData (ClientSession) in.
        //

        Credential = AllocateCredential( (PNL_AUTH_DATA)pAuthData );

        if (Credential == NULL) {
            NlPrint(( NL_CRITICAL,
                      "AcquireCredentialHandle: Cannot allocate context\n" ));
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }



        //
        // Return to the caller.
        //
        *phCredential = Credential->CredentialHandle;
        *ptsExpiry = Forever;
        SecStatus = SEC_E_OK;

    //
    // Handle a server credential
    //
    // We don't need a credential on the server side.
    // Silently succeed.
    //

    } else {
        phCredential->dwUpper = NL_AUTH_SERVER_CRED; // Just return a constant
        phCredential->dwLower = 0;
        *ptsExpiry = Forever;
        SecStatus = SEC_E_OK;
        goto Cleanup;
    }

Cleanup:

    NlPrint(( NL_SESSION_MORE,
              "AcquireCredentialsHandleW: %lx.%lx: returns 0x%lx\n",
              phCredential->dwUpper, phCredential->dwLower,
              SecStatus ));

    // Let netlogon service exit.
    NlEndNetlogonCall();
    return SecStatus;


    UNREFERENCED_PARAMETER( pvGetKeyArgument );
    UNREFERENCED_PARAMETER( pGetKeyFn );
    UNREFERENCED_PARAMETER( pAuthData );
    UNREFERENCED_PARAMETER( pvLogonId );
    UNREFERENCED_PARAMETER( pszPackageName );
    UNREFERENCED_PARAMETER( pszPrincipal );

}





SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    )
/*++

Routine Description:


Arguments:

    Standard.

Return Value:



--*/
{

    NlPrint(( NL_SESSION_MORE,
              "FreeCredentialsHandle: %lx.%lx: called\n",
              phCredential->dwUpper, phCredential->dwLower ));

    //
    // Don't require that Netlogon be running.  Some credential handles are
    //  deleted as Netlogon is shutting down.
    //

    //
    // Ignore server side credentials.
    //

    if ( phCredential->dwUpper == NL_AUTH_SERVER_CRED &&
         phCredential->dwLower == 0 ) {

        return(SEC_E_OK);
    }

    //
    // For the Client side,
    //  Delete the credential.
    //

    if ( DeleteCredential( phCredential ) ) {
        return(SEC_E_OK);
    } else {
        return(SEC_E_UNKNOWN_CREDENTIALS);
    }
}






SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
/*++

Routine Description:

    Client side routine to define a security context.

Arguments:

    Standard.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus;

    NET_API_STATUS NetStatus;
    PNL_AUTH_CONTEXT Context = NULL;
    PNL_AUTH_CREDENTIAL Credential = NULL;
    NL_AUTH_MESSAGE UNALIGNED *Message = NULL;
    PSecBuffer OutputBuffer;
    PSecBuffer InputBuffer;
    WORD CompressOffset[10];
    CHAR *CompressUtf8String[10];
    ULONG CompressCount = 0;
    ULONG Utf8StringSize;
    LPBYTE Where;

    NlPrint(( NL_SESSION_MORE,
        "InitializeSecurityContext: %ws: called\n", pszTargetName ));

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return SEC_E_SECPKG_NOT_FOUND;
    }


    if (fContextReq & ISC_REQ_ALLOCATE_MEMORY) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    OutputBuffer = LocateSecBuffer(pOutput);
    if (OutputBuffer == NULL) {
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }


    //
    // Handle the first init call,
    //

    if (phContext == NULL) {
        PNL_AUTH_DATA ClientAuthData;

        //
        // Find the credential and ensure it is outbound
        //

        if ( phCredential == NULL ) {
            SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
            goto Cleanup;
        }

        NlPrint(( NL_SESSION_MORE,
            "InitializeSecurityContext: %lx.%lx: %ws: called with cred handle\n",
            phCredential->dwUpper, phCredential->dwLower,
            pszTargetName ));

        //
        // Locate the credential and make sure this is a client side call.
        //

        Credential = LocateCredential( phCredential );
        if (Credential == NULL) {
            SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
            goto Cleanup;
        }

        ClientAuthData = Credential->ClientAuthData;
        if ( ClientAuthData == NULL ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }
        NlAssert( ClientAuthData->Signature == NL_AUTH_DATA_SIGNATURE );

        //
        // Build an output token.
        //
        // This token simply tells the server side of the authentication
        // package our computer name.
        //

        Message = (PNL_AUTH_MESSAGE) OutputBuffer->pvBuffer;
        SmbPutUlong( &Message->MessageType, Negotiate );
        Message->Flags = 0;
        Where = &Message->Buffer[0];

        //
        // Copy the Netbios domain name of the domain hosted by the DC into the buffer
        //
        //  OEM on the wire is bad.  Luckily, if the DC is in a different locale,
        //  that DC also has a DNS domain name and we'll use that to find the
        //  hosted domain.
        //

        if ( ClientAuthData->OemNetbiosDomainNameLength != 0 ) {
            strcpy( Where,
                    ((LPBYTE)ClientAuthData) +
                        ClientAuthData->OemNetbiosDomainNameOffset );
            Where += ClientAuthData->OemNetbiosDomainNameLength + 1;
            Message->Flags |= NL_AUTH_NETBIOS_DOMAIN_NAME;
        }


        //
        // Copy the computer name of this machine into the buffer.
        //
        // ???: Only copy the Netbios computername or DNS host name.  Copy the
        //  one that was passed to the server on the NetServerReqChallenge.
        //
        // OEM on the wire is bad.  So pass the UTF-8 version, too.
        //

        if ( ClientAuthData->OemComputerNameLength != 0 ) {
            strcpy( Where,
                    ((LPBYTE)ClientAuthData) +
                        ClientAuthData->OemComputerNameOffset );
            Where += ClientAuthData->OemComputerNameLength + 1;

            Message->Flags |= NL_AUTH_NETBIOS_COMPUTER_NAME;
        }



        //
        // Copy the DNS domain name of the domain hosted by the DC into the buffer.
        //

        Utf8StringSize = 2*(NL_MAX_DNS_LENGTH+1);
        CompressCount = 0;  // No strings compressed yet.

        if ( ClientAuthData->Utf8DnsDomainNameOffset != 0 ) {

            NetStatus = NlpUtf8ToCutf8(
                            (LPBYTE)Message,
                            ((LPBYTE)ClientAuthData) +
                                ClientAuthData->Utf8DnsDomainNameOffset,
                            FALSE,
                            &Where,
                            &Utf8StringSize,
                            &CompressCount,
                            CompressOffset,
                            CompressUtf8String );

            if ( NetStatus != NO_ERROR ) {
                NlPrint((NL_CRITICAL,
                        "Cannot pack DomainName into message %ld\n",
                        NetStatus ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }
            Message->Flags |= NL_AUTH_DNS_DOMAIN_NAME;
        }

        //
        // Copy the DNS host name name of this machine into the buffer.
        //
        // ???: Only copy the Netbios computername or DNS host name.  Copy the
        //  one that was passed to the server on the NetServerReqChallenge.
        //

        if ( ClientAuthData->Utf8DnsHostNameOffset != 0 ) {

            NetStatus = NlpUtf8ToCutf8(
                            (LPBYTE)Message,
                            ((LPBYTE)ClientAuthData) +
                                ClientAuthData->Utf8DnsHostNameOffset,
                            FALSE,
                            &Where,
                            &Utf8StringSize,
                            &CompressCount,
                            CompressOffset,
                            CompressUtf8String );

            if ( NetStatus != NO_ERROR ) {
                NlPrint((NL_CRITICAL,
                        "Cannot pack dns host name into message %ld\n",
                        NetStatus ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }
            Message->Flags |= NL_AUTH_DNS_HOST_NAME;
        }


        //
        // Copy the UTF-8 netbios computer name of this machine into the buffer.
        //
        // ???: Only copy the Netbios computername or DNS host name.  Copy the
        //  one that was passed to the server on the NetServerReqChallenge.
        //
        // OEM on the wire is bad.  So pass the UTF-8 version, too.
        //

        if ( ClientAuthData->Utf8ComputerNameLength != 0 ) {

            NetStatus = NlpUtf8ToCutf8(
                            (LPBYTE)Message,
                            ((LPBYTE)ClientAuthData) +
                                ClientAuthData->Utf8ComputerNameOffset,
                            TRUE,
                            &Where,
                            &Utf8StringSize,
                            &CompressCount,
                            CompressOffset,
                            CompressUtf8String );

            if ( NetStatus != NO_ERROR ) {
                NlPrint((NL_CRITICAL,
                        "Cannot pack UTF-8 netbios computer name into message %ld\n",
                        NetStatus ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            Message->Flags |= NL_AUTH_UTF8_NETBIOS_COMPUTER_NAME;
        }

        //
        // Allocate a context.
        //

        Context = AllocateContext( fContextReq );

        if ( Context == NULL) {
            NlPrint(( NL_CRITICAL,
                      "InitializeSecurityContext: Cannot allocate context\n" ));
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }


        //
        // Mark the context to indicate what state we're in.
        //
        Context->State = FirstInit;
        Context->Inbound = FALSE;

        //
        // Grab the session key
        //

        Context->SessionInfo = ClientAuthData->SessionInfo;

        //
        // Ask the caller to call us back
        //

        OutputBuffer->cbBuffer = (DWORD)(Where - (LPBYTE)Message);
        *phNewContext = Context->ContextHandle;
        *pfContextAttr = fContextReq;
        *ptsExpiry = Forever;

        SecStatus = SEC_I_CONTINUE_NEEDED;

    //
    // Handle the second call
    //
    } else {

        NlPrint(( NL_SESSION_MORE,
            "InitializeSecurityContext: %lx.%lx: %ws: called with context handle\n",
            phContext->dwUpper, phContext->dwLower,
            pszTargetName ));

        //
        // This is the second call. Lookup the old context.
        //
        // Locate the context and make sure this is a client side call.
        //

        Context = LocateContext( phContext );
        if (Context == NULL) {
            SecStatus = SEC_E_INVALID_HANDLE;
            goto Cleanup;
        }

        //

        // Ensure we're in the right state.
        //
        if ( Context->State != FirstInit ) {
            SecStatus = SEC_E_INVALID_HANDLE;
            goto Cleanup;
        }


        //
        // Check that the input message is what we expected.
        //

        InputBuffer = LocateSecBuffer(pInput);
        if (InputBuffer == NULL) {
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        Message = (PNL_AUTH_MESSAGE) InputBuffer->pvBuffer;

        if ( InputBuffer->cbBuffer < sizeof(NL_AUTH_MESSAGE) ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        if ( Message->MessageType != NegotiateResponse ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        Context->State = SecondInit;
        Context->Nonce.QuadPart = 0;

        //
        // Return to the caller.
        //
        OutputBuffer->cbBuffer = 0;

        *pfContextAttr = fContextReq;
        *ptsExpiry = Forever;
        SecStatus = SEC_E_OK;
    }

Cleanup:

    NlPrint(( NL_SESSION_MORE,
        "InitializeSecurityContext: returns 0x%lx\n", SecStatus ));

    // Let netlogon service exit.
    NlEndNetlogonCall();
    return SecStatus;

    UNREFERENCED_PARAMETER( Reserved2 );
    UNREFERENCED_PARAMETER( TargetDataRep );
    UNREFERENCED_PARAMETER( Reserved1 );
    UNREFERENCED_PARAMETER( pszTargetName );
    UNREFERENCED_PARAMETER( pInput );
}





SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
/*++

Routine Description:

    Servert side routine to define a security context.

Arguments:

    Standard.

Return Value:



--*/
{
    SECURITY_STATUS SecStatus;
    PNL_AUTH_CONTEXT Context = NULL;
    NL_AUTH_MESSAGE UNALIGNED *Message = NULL;

    PSecBuffer OutputBuffer = NULL;
    PSecBuffer InputBuffer;
    LPBYTE Where;
    LPSTR DnsDomainName = NULL;
    LPSTR DnsHostName = NULL;
    LPSTR Utf8ComputerName = NULL;
    LPSTR OemDomainName = NULL;
    LPWSTR UnicodeDomainName = NULL;
    LPSTR OemComputerName = NULL;
    LPWSTR UnicodeComputerName = NULL;
    PDOMAIN_INFO DomainInfo = NULL;
    PSERVER_SESSION ServerSession;
    SESSION_INFO SessionInfo;
    SecHandle CurrentHandle = {0};

    NlPrint(( NL_SESSION_MORE,
        "AcceptSecurityContext: called\n" ));

    //
    // If caller is calling when the netlogon service isn't running,
    //  tell it so.
    //

    if ( !NlStartNetlogonCall() ) {
        return SEC_E_SECPKG_NOT_FOUND;
    }


    if (fContextReq & ISC_REQ_ALLOCATE_MEMORY) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    InputBuffer = LocateSecBuffer(pInput);
    if (InputBuffer == NULL) {
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Make sure the output buffer exists.
    //

    OutputBuffer = LocateSecBuffer(pOutput);
    if (OutputBuffer == NULL) {
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Handle the first server side call.
    //

    if (phContext == NULL) {

        //
        // Validate the credential handle.
        //

        if ( phCredential == NULL ||
             phCredential->dwUpper != NL_AUTH_SERVER_CRED ||
             phCredential->dwLower != 0 ) {

            SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
            goto Cleanup;
        }

        CurrentHandle = *phCredential;



        //
        // Check that the input message is what we expected.
        //

        Message = (PNL_AUTH_MESSAGE) InputBuffer->pvBuffer;

        if ( InputBuffer->cbBuffer < sizeof(NL_AUTH_MESSAGE) ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        if ( Message->MessageType != Negotiate ) {
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        Where = &Message->Buffer[0];

        //
        // Get Netbios hosted domain name from the buffer
        //
        if ( Message->Flags & NL_AUTH_NETBIOS_DOMAIN_NAME ) {
            if ( !NetpLogonGetOemString(
                        Message,
                        InputBuffer->cbBuffer,
                        &Where,
                        DNLEN+1,
                        &OemDomainName ) ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: cannot get netbios domain name\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }
        }

        //
        // Get the Netbios client computer name from the message.
        //
        if ( Message->Flags & NL_AUTH_NETBIOS_COMPUTER_NAME ) {
            //
            // Get the computer name of the
            if ( !NetpLogonGetOemString(
                        Message,
                        InputBuffer->cbBuffer,
                        &Where,
                        CNLEN+1,
                        &OemComputerName ) ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot parse computer name\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }


        }


        //
        // Get the domain name of the hosted domain from the message.
        //
        // Either get a utf-8 DNS domain name or an OEM netbios domain name
        //

        if ( Message->Flags & NL_AUTH_DNS_DOMAIN_NAME ) {
            if ( !NetpLogonGetCutf8String(
                            Message,
                            InputBuffer->cbBuffer,
                            &Where,
                            &DnsDomainName ) ) {
                NlPrint(( NL_CRITICAL,
                          "AcceptSecurityContext: %lx.%lx: DNS domain bad.\n",
                          CurrentHandle.dwUpper, CurrentHandle.dwLower ));

                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }
        }


        //
        // Get the DNS client computer name from the message.
        //
        //
        if ( Message->Flags & NL_AUTH_DNS_HOST_NAME ) {

            if ( !NetpLogonGetCutf8String(
                            Message,
                            InputBuffer->cbBuffer,
                            &Where,
                            &DnsHostName ) ) {
                NlPrint(( NL_CRITICAL,
                          "AcceptSecurityContext: %lx.%lx: DNS hostname bad.\n",
                          CurrentHandle.dwUpper, CurrentHandle.dwLower
                          ));

                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // Ensure Netbios name isn't also present
            //

            if ( Message->Flags & NL_AUTH_NETBIOS_COMPUTER_NAME ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: both DNS '%s' and Netbios '%s' client name specified\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        DnsHostName,
                        OemComputerName ));
                /* This isn't fatal */
            }

        }

        //
        // Get the UTF8 netbios computer name
        //

        if ( Message->Flags & NL_AUTH_UTF8_NETBIOS_COMPUTER_NAME ) {

            if ( !NetpLogonGetCutf8String(
                            Message,
                            InputBuffer->cbBuffer,
                            &Where,
                            &Utf8ComputerName ) ) {
                NlPrint(( NL_CRITICAL,
                          "AcceptSecurityContext: %lx.%lx: UTF8 computer name bad.\n",
                          CurrentHandle.dwUpper, CurrentHandle.dwLower
                          ));

                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }
        }

        //
        // Try to find the hosted domain using DNS
        //

        if ( DnsDomainName != NULL ) {
            DomainInfo = NlFindDnsDomain( DnsDomainName,
                                          NULL,
                                          FALSE,  // don't lookup NDNCs
                                          TRUE,   // check alias names
                                          NULL ); // don't care if alias name matched

            if ( DomainInfo == NULL ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot find domain %s\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        DnsDomainName ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

        //
        // Try to find hosted domain name using netbios.
        //
        } else {

            //
            // Make sure we were passed one.
            //

            if ( OemDomainName == NULL) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Neither DNS or netbios domain name specified (fatal)\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            //
            // Convert to unicode
            //  Note: this is bogus since the clients OEM code page may be different
            //  than ours.
            //

            UnicodeDomainName = NetpAllocWStrFromStr( OemDomainName );

            if ( UnicodeDomainName == NULL ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot alloc domain name %s\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        OemDomainName ));
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }

            //
            // Look the name up.
            //

            DomainInfo = NlFindNetbiosDomain( UnicodeDomainName, FALSE );

            if ( DomainInfo == NULL ) {

                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot find domain %ws (fatal)\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        UnicodeDomainName ));
                SecStatus = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }
        }

        //
        // Get the name of the client machine.
        //
        // If the client computer passed us its DnsHostName,
        //  use that.
        //

        if ( DnsHostName != NULL ) {

            UnicodeComputerName = NetpAllocWStrFromUtf8Str( DnsHostName );

            if ( UnicodeComputerName == NULL ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot alloc DNS computer name %s\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        DnsHostName ));
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }

        //
        // If the client computer passed us its Netbios name in UTF-8,
        //  use that.
        //

        } else if ( Utf8ComputerName != NULL ) {

            UnicodeComputerName = NetpAllocWStrFromUtf8Str( Utf8ComputerName );

            if ( UnicodeComputerName == NULL ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot alloc utf8 computer name %s\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        Utf8ComputerName ));
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }

        //
        // If the client computer passed us its Netbios name in OEM,
        //  use that.
        //  OEM is bad since the clients code page might be different than ours.
        //
        } else if ( OemComputerName != NULL ) {
            UnicodeComputerName = NetpAllocWStrFromStr( OemComputerName );

            if ( UnicodeComputerName == NULL ) {
                NlPrint((NL_CRITICAL,
                        "AcceptSecurityContext: %lx.%lx: Cannot alloc oem computer name %s\n",
                        CurrentHandle.dwUpper, CurrentHandle.dwLower,
                        OemComputerName ));
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }

        //
        // At this point it is fatal if we don't know the client computer name
        //

        } else {

            NlPrint((NL_CRITICAL,
                    "AcceptSecurityContext: %lx.%lx: Don't know client computer name.\n",
                    CurrentHandle.dwUpper, CurrentHandle.dwLower ));
            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }


        //
        // Find the server session containing the session key
        //  and make a copy of it.
        //

        NlPrint((NL_SESSION_MORE,
                "AcceptSecurityContext: %lx.%lx: from %ws\n",
                CurrentHandle.dwUpper, CurrentHandle.dwLower,
                UnicodeComputerName ));

        LOCK_SERVER_SESSION_TABLE( DomainInfo );
        ServerSession = NlFindNamedServerSession( DomainInfo, UnicodeComputerName );
        if (ServerSession == NULL) {
            UNLOCK_SERVER_SESSION_TABLE( DomainInfo );

            NlPrint((NL_CRITICAL,
                    "AcceptSecurityContext: %lx.%lx: Can't NlFindNamedServerSession for %ws\n",
                    CurrentHandle.dwUpper, CurrentHandle.dwLower,
                    Unico